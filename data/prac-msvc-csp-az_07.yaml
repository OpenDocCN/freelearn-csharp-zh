- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Flexible Configurations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活配置
- en: .NET offers flexible configurations using a provider-based model to read configurations
    from different sources. In the last chapter, we configured environment variables
    with Azure Container Apps to override the JSON file configuration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了基于提供者模型的灵活配置，可以从不同的来源读取配置。在上章中，我们使用 Azure 容器应用配置环境变量以覆盖 JSON 文件配置。
- en: 'In this chapter, you will learn how to use the app configuration with .NET
    and how to add a configuration provider to use a central configuration store:
    **Azure App Configuration**. For secrets, we have another Azure service available:
    **Azure Key Vault**. In this chapter, you’ll also learn how to combine Azure Key
    Vault with Azure App Configuration and reduce the number of secrets you need to
    store by using **Azure** **managed identities**.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 .NET 应用配置，以及如何添加配置提供者以使用中央配置存储：**Azure App Configuration**。对于秘密，我们还有一个可用的
    Azure 服务：**Azure Key Vault**。在本章中，你还将学习如何将 Azure Key Vault 与 Azure App Configuration
    结合使用，并通过使用 **Azure** **托管标识**来减少需要存储的秘密数量。
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Explore the functionality of .NET configurations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 .NET 配置的功能
- en: Store configurations with Azure App Configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure App Configuration 存储配置
- en: Store secrets with Azure Key Vault
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure Key Vault 存储秘密
- en: Reduce the number of secrets needed using managed identities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用托管标识减少所需的秘密数量
- en: Use environments with Azure App Configuration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure App Configuration 使用环境
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Similar to the previous chapter, an Azure subscription, the Azure CLI, Azure
    Developer CLI, and Docker Desktop are required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，需要 Azure 订阅、Azure CLI、Azure 开发者 CLI 和 Docker Desktop。
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下 GitHub 存储库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure)。
- en: 'In the `ch07` folder, you’ll see these projects with the final result of this
    chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ch07` 文件夹中，你会看到本章最终结果的这些项目：
- en: '`ConfigurationPrototype` – This is a new project that shows some concepts with
    configuration before implementing this with the games API and the bot service.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigurationPrototype` – 这是一个新项目，在实现游戏 API 和机器人服务之前，展示了配置的一些概念。'
- en: '`Codebreaker.InitializeAppConfig` – This is a new project to initialize values
    with Azure App Configuration.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.InitializeAppConfig` – 这是一个新项目，用于使用 Azure App Configuration 初始化值。'
- en: '`Codebreaker.AppHost` – The app model defined with this project is enhanced
    to include the `ConfigurationPrototype` and `Codebreaker.InitializeAppConfig`
    projects and add App Configuration and Azure Key Vault resources to the app model.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost` – 使用此项目定义的应用模型得到了增强，包括 `ConfigurationPrototype` 和 `Codebreaker.InitializeAppConfig`
    项目，并将 App Configuration 和 Azure Key Vault 资源添加到应用模型中。'
- en: '`Codebreaker.GameAPIs` – The games API project we used in the previous chapter
    is enhanced using App Configuration.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs` – 我们在上一章中使用过的游戏 API 项目通过 App Configuration 进行了增强。'
- en: '`Codebreaker.Bot` – This is the implementation of the bot service that plays
    games. This project is enhanced with App Configuration as well.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Bot` – 这是实现游戏服务的机器人服务的实现。该项目还通过 App Configuration 进行了增强。'
- en: You can start with the results from the previous chapter to work on your own
    through this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从上一章的结果开始，通过本章进行自己的工作。
- en: 'To publish the solution to Azure (which is needed later in this chapter when
    we use managed identities), use the Azure Developer CLI with the current directory
    set to the `solution` folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布 Azure 的解决方案（在本章后面使用托管标识时需要），请使用 Azure 开发者 CLI，并将当前目录设置为 `solution` 文件夹：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With `azd init`, select to analyze the code in the folder, accept to deploy
    Azure Container Apps, specify an environment such as `codebreaker-07`, and select
    the game APIs, the bot, and the configuration prototype to be accessible from
    the Ingress controller. With `azd up`, the resources are deployed to your configured
    environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `azd init`，选择分析文件夹中的代码，接受部署 Azure 容器应用，指定一个环境，例如 `codebreaker-07`，并选择可从 Ingress
    控制器访问的游戏 API、机器人服务和配置原型。使用 `azd up`，资源将部署到配置的环境。
- en: Check the README file of the `ch07` folder of the repository for the latest
    updates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看存储库中 `ch07` 文件夹的 README 文件以获取最新更新。
- en: Experiencing .NET configurations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 体验 .NET 配置
- en: 'In this chapter, we will create a new Web API project to try out .NET configuration
    features before adding configuration features to the game APIs and the bot service:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的 Web API 项目，在将配置功能添加到游戏 API 和机器人服务之前，尝试使用 .NET 配置功能：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: .NET is flexible in how to read configuration values. Configuration values can
    be retrieved from different sources such as JSON files, environment variables,
    and command-line arguments. Depending on the environment (for example, production
    and development), different configuration values are also retrieved. Using this
    core .NET feature, it’s easily possible to add other configuration sources and
    customize environments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 在读取配置值方面非常灵活。配置值可以从不同的源检索，例如 JSON 文件、环境变量和命令行参数。根据环境（例如，生产环境和开发环境），还可以检索不同的配置值。使用此核心
    .NET 功能，很容易添加其他配置源并自定义环境。
- en: Behind the scenes, the `ConfigurationManager` class is used to configure sources
    for the application configuration. This configuration is done at application startup
    when invoking `WebApplication.CreateBuilder`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`ConfigurationManager` 类用于配置应用程序配置的源。此配置是在调用 `WebApplication.CreateBuilder`
    时在应用程序启动时完成的。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With .NET 8, other builder methods, such as `CreateSlimBuilder` and `CreateEmptyBuilder`,
    are available. With these builders, the number of services registered is reduced
    to increase performance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 中，其他构建器方法，如 `CreateSlimBuilder` 和 `CreateEmptyBuilder`，也可用。使用这些构建器，注册的服务数量减少，以提高性能。
- en: 'With the default configuration as done by `WebApplicationBulder.CreateBuilder`,
    a list of configuration providers has already been added:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `WebApplicationBulder.CreateBuilder` 完成的默认配置，已添加配置提供程序列表：
- en: '`webroot` key is set to the path of the web directory. Instead of using other
    APIs to get this information, you can retrieve it using configuration keys.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webroot` 键设置为 Web 目录的路径。您可以使用配置键而不是使用其他 API 来检索此信息。'
- en: '`ASPNETCORE_` and `DOTNETCORE_` prefixes to have them available early in the
    process, which allows overriding the values by all providers following. Another
    environment variable configuration provider adds all other environment variables.
    The `ASPNETCORE_HTTP_PORTS` and `ASPNETCORE_HTTPS_PORTS` environment variables
    are new since .NET 8 to easily change the listening ports of the Kestrel server.
    .NET Aspire passes environment variables to the configured projects.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASPNETCORE_` 和 `DOTNETCORE_` 前缀，以便在处理早期即可使用，这允许所有后续提供程序覆盖这些值。另一个环境变量配置提供程序添加所有其他环境变量。`ASPNETCORE_HTTP_PORTS`
    和 `ASPNETCORE_HTTPS_PORTS` 环境变量是 .NET 8 中新增的，可以轻松更改 Kestrel 服务器的监听端口。.NET Aspire
    将环境变量传递给配置的项目。'
- en: '`appsettings.json` and `appsettings.{environmentName}.json`. In case the environment
    name is `Development`, the values from `appsettings.Development.json` are retrieved.
    This overwrites settings from the previously loaded `appsettings.json` file.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.json` 和 `appsettings.{environmentName}.json`。如果环境名称是 `Development`，则检索
    `appsettings.Development.json` 中的值。这将覆盖之前加载的 `appsettings.json` 文件中的设置。'
- en: 'In your environment, you can use multiple JSON files (for example, `connectionstrings.json`)
    in case you prefer to have all the connection strings separated:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在您的环境中，如果您更喜欢将所有连接字符串分开，可以使用多个 JSON 文件（例如，`connectionstrings.json`）：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `AddJsonFile` extension method adds the filename as another JSON configuration
    provider. If the `optional` parameter is not configured to be `true`, an exception
    is thrown in case the file cannot be found.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AddJsonFile` 扩展方法将文件名添加为另一个 JSON 配置提供程序。如果未将 `optional` 参数配置为 `true`，则在找不到文件时抛出异常。'
- en: '**Command-line configuration provider**: The command-line provider allows overriding
    all the settings (because it is last in the providers’ list). Starting the application,
    you can pass configuration values to overwrite other settings.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行配置提供程序**：命令行提供程序允许覆盖所有设置（因为它在提供程序列表中最后）。启动应用程序时，您可以通过传递配置值来覆盖其他设置。'
- en: 'Imagine a case where a hierarchical setting is specified with JSON, such as
    this connection string:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一个使用 JSON 指定分层设置的案例，例如以下连接字符串：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In such a case, you can pass the value using command-line arguments with a
    `:` separator:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用冒号 `:` 分隔符通过命令行参数传递值：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using `:` is not possible with environment variables. As you saw in the previous
    chapter, when passing environment variables for hierarchical configurations, two
    underscores (`__`) are used as separators.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `:` 在环境变量中是不可能的。如您在上一章中看到的，在传递用于分层配置的环境变量时，使用两个下划线 (`__`) 作为分隔符。
- en: '`UserSecretsId` is set with the project file:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserSecretsId` 在项目文件中设置：'
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: dotnet user-secrets -h to see the other commands available.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 dotnet user-secrets -h 查看其他可用的命令。
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Running a .NET Aspire solution on the development system, the app model with
    its dependencies is used to create environment variables containing referenced
    information with the processes running the services. When deploying the solution
    to Microsoft Azure, with Azure Container Apps, environment variables and secrets
    are created. Because environment variables by default are configured as configuration
    providers, nothing special needs to be done running the services.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发系统上运行 .NET Aspire 解决方案时，使用包含运行服务进程的引用信息的应用程序模型及其依赖项来创建环境变量。当将解决方案部署到 Microsoft
    Azure，并使用 Azure Container Apps 时，会创建环境变量和秘密。由于默认情况下环境变量被配置为配置提供者，因此运行服务时无需进行特殊操作。
- en: Retrieving configuration values
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索配置值
- en: 'How can we access configuration values? To get custom configuration values,
    let’s enhance the `appsettings.json` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何访问配置值？要获取自定义配置值，让我们增强 `appsettings.json` 文件：
- en: ConfigurationPrototype/appsettings.json
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/appsettings.json
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Config1` key is added to the root elements of the file. With `Service1`,
    we use a parent-child relationship and define multiple child elements, `Config1`
    and `Config2`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Config1` 键被添加到文件的根元素中。使用 `Service1`，我们使用父子关系并定义多个子元素，`Config1` 和 `Config2`。'
- en: 'To retrieve configuration values, we just need to inject the `IConfiguration`
    interface, as shown in the following code snippet. You need to add this code snippet
    before the `app.Run` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索配置值，我们只需注入 `IConfiguration` 接口，如下面的代码片段所示。您需要在 `app.Run` 方法之前添加此代码片段：
- en: ConfigurationPrototype/Program.cs
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `IConfiguration` interface is injected in the `GET` request of the API implementation.
    Using a C# indexer, we retrieve the value for the `Config1` key. To retrieve child
    elements, we can use the `GetSection` method and use the indexer from the returned
    section. `GetSection` returns an object implementing the `IConfigurationSection`
    interface. This interface itself derives from `IConfiguration`, thus the members
    of the `IConfiguration` interface are available.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`IConfiguration` 接口在 API 实现的 `GET` 请求中注入。使用 C# 索引器，我们检索 `Config1` 键的值。要检索子元素，我们可以使用
    `GetSection` 方法并使用返回的节中的索引器。`GetSection` 返回一个实现 `IConfigurationSection` 接口的对象。该接口本身继承自
    `IConfiguration`，因此 `IConfiguration` 接口的成员都是可用的。'
- en: 'Try it out: start the `ConfigurationPrototype` app, and with the OpenAPI test
    page, test the `/``readconfig` endpoint.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下：启动 `ConfigurationPrototype` 应用程序，并使用 OpenAPI 测试页面测试 `/``readconfig` 端点。
- en: To retrieve the children, we’ll use a different approach with options next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索子元素，我们将使用不同的方法来使用选项。
- en: Using options
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选项
- en: When configuration values are needed, many .NET services make use of the **options
    pattern**. This adds some flexibility in where to get these values – this can
    be the configuration, but these service configuration values can also be assigned
    programmatically.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要配置值时，许多 .NET 服务都使用 **选项模式**。这为获取这些值提供了更多灵活性——这可以是配置，但这些服务配置值也可以通过编程方式分配。
- en: 'Strongly typed configuration values are another feature of this pattern. Add
    this class to map the configuration values:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型配置值是此模式的另一个特性。将此类添加到映射配置值：
- en: ConfigurationPrototype/Program.cs
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The class to map the configuration values needs a parameter-less constructor
    and properties that match the configuration values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 映射配置值的类需要一个无参数构造函数和与配置值匹配的属性。
- en: 'To fill the values, the `Service1Options` class is configured with the `builder.Build`
    method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要填充值，使用 `Service1Options` 类并通过 `builder.Build` 方法进行配置：
- en: ConfigurationPrototype/Program.cs
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `IServiceCollection` `Configure` extension method offers two overloads.
    With one overload, a delegate can be assigned to fill the `Service1Options` instance
    programmatically. The second overload – which is used here – receives an `IConfiguration`
    parameter. Remember – in the configuration file created earlier, a `Service1`
    parent element was defined. The `GetSection` method retrieves the values within
    this section. Because the configuration keys map to the class, the values are
    filled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceCollection`的`Configure`扩展方法提供了两种重载。其中一种重载允许通过一个委托程序来程序化地填充`Service1Options`实例。第二种重载——在这里使用的是——接收一个`IConfiguration`参数。记住——在之前创建的配置文件中，定义了一个`Service1`父元素。`GetSection`方法检索该部分内的值。因为配置键映射到类，所以填充了这些值。'
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A new .NET 8 feature with a binding configuration is a source generator. Using
    native AOT (see [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110)), this source
    generator is enabled by default. With non-AOT projects, `EnableConfigurationBindingGenerator`
    can be added to the project file to turn off this source generator.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的.NET 8特性，具有绑定配置的是源生成器。使用原生AOT（见[*第5章*](B21217_05.xhtml#_idTextAnchor110)），此源生成器默认启用。对于非AOT项目，可以将`EnableConfigurationBindingGenerator`添加到项目文件中以关闭此源生成器。
- en: 'With this configuration in place, let’s retrieve these configuration values.
    Add this code before `app.Run` to configure the endpoint:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置就绪后，让我们检索这些配置值。在`app.Run`之前添加此代码以配置端点：
- en: ConfigurationPrototype/Program.cs
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `IOptions` interface with the `Service1Options` generic parameter is injected,
    and with this, the configured values can be used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有`Service1Options`泛型参数的`IOptions`接口进行注入，并且通过这种方式，可以使用配置的值。
- en: After you have made these code changes, run the `ConfigurationPrototype` project
    again. Use the `/readoptions` endpoint to retrieve the configured values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些代码更改后，再次运行`ConfigurationPrototype`项目。使用`/readoptions`端点检索配置的值。
- en: Using environments
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境
- en: As the application runs in different environments (for example, production,
    staging, and development), there’s a need for different configuration values.
    For example, in the development environment, you don’t want to use the production
    database. The .NET configuration easily supports different environments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序在不同的环境中运行（例如，生产、预发布和开发），需要不同的配置值。例如，在开发环境中，您不想使用生产数据库。.NET配置很容易支持不同的环境。
- en: With the default configuration, an `appsettings.{environment}.json` file is
    loaded to specify environment-specific configuration values – for example, `appsettings.staging.json`
    in the staging environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置下，加载`appsettings.{environment}.json`文件以指定特定环境的配置值——例如，在预发布环境中为`appsettings.staging.json`。
- en: Aside from using different filenames to load environment-specific configuration
    values, we can programmatically verify the current environment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用不同的文件名来加载特定环境的配置值外，我们还可以程序化地验证当前环境。
- en: 'The template-generated code contains this code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模板生成的代码包含以下代码：
- en: ConfigurationPrototype/Program.cs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `IsDevelopment` extension method compares the environment with the `Development`
    string. `Environment` is a property of the `WebApplication` class. Other methods
    available are `IsProduction`, `IsStaging`, and `IsEnvironment`. Invoking the `IsEnvironment`
    method, any string can be passed to check if the application is running in the
    specified environment. Instead of using the `IsEnvironment` method, you can also
    create a custom extension method extending the `IHostEnvironment` type to compare
    with the environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsDevelopment`扩展方法将环境与`Development`字符串进行比较。`Environment`是`WebApplication`类的一个属性。其他可用的方法有`IsProduction`、`IsStaging`和`IsEnvironment`。调用`IsEnvironment`方法时，可以传递任何字符串来检查应用程序是否在指定的环境中运行。您也可以创建一个自定义扩展方法，扩展`IHostEnvironment`类型以与环境进行比较，而不是使用`IsEnvironment`方法。'
- en: What environment the application is running in is defined by the `ASPNETCORE_ENVIRONMENT`
    environment variable, as mentioned earlier. While debugging locally, the `launchsettings.json`
    file (in the `Properties` folder) defines the environment to the `Development`
    value. If the environment variable is not set, the default environment is `Production`.
    For all other environments, you need to set this environment variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行的环境由前面提到的`ASPNETCORE_ENVIRONMENT`环境变量定义。在本地调试时，`launchsettings.json`文件（在`Properties`文件夹中）将环境定义为`Development`值。如果没有设置环境变量，则默认环境为`Production`。对于所有其他环境，您需要设置此环境变量。
- en: Using configurations with Azure Container Apps
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure Container Apps 配置
- en: Azure Container Apps supports specifying environment variables, and secrets.
    In [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137), when we created the container
    app, we configured environment variables and secrets. Environment variables of
    a container app can be configured on creating the application or afterward when
    updating the application – for example, using `az` `containerapp update`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Container Apps 支持指定环境变量和秘密。在[*第 6 章*](B21217_06.xhtml#_idTextAnchor137)中，当我们创建容器应用程序时，我们配置了环境变量和秘密。容器应用程序的环境变量可以在创建应用程序时或在更新应用程序后进行配置——例如，使用
    `az` `containerapp update`。
- en: Environment variables may be visible in log files. For secrets, this can be
    a security issue. Security sniffers can catch secrets that are configured in environment
    variables and alert system administrators when these are found. With container
    apps, secrets are stored within the scope of an application but independent of
    revisions of the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可能会在日志文件中可见。对于秘密，这可能会成为一个安全问题。安全嗅探器可以捕获配置在环境变量中的秘密，并在发现这些秘密时向系统管理员发出警报。在容器应用程序中，秘密存储在应用程序的作用域内，但与应用程序的版本无关。
- en: To get even better security for secrets, container app secrets can be connected
    to secrets with the Azure Key Vault service. The Key Vault service and additional
    features we get for secrets are discussed later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的秘密安全性，容器应用程序的秘密可以连接到 Azure Key Vault 服务。Key Vault 服务以及我们为秘密获取的附加功能将在本章后面讨论。
- en: When you use multiple Azure services (for example, Azure App Service, Azure
    Functions, Azure Container Apps…), how configuration is managed is different from
    service to service. Also if you just run a large list of services within only
    container apps, you might prefer a central place where all the configuration is
    managed. Azure App Configuration offers this functionality without the need to
    create a custom configuration service.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用多个 Azure 服务（例如，Azure App Service、Azure Functions、Azure Container Apps...）时，配置的管理方式因服务而异。如果您仅在容器应用程序中运行大量服务，您可能更喜欢一个集中管理所有配置的地方。Azure
    App Configuration 提供了这种功能，而无需创建自定义配置服务。
- en: Using configurations with Azure App Configuration
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure App Configuration 配置
- en: 'In this chapter, we add Azure App Configuration and Azure Key Vault to the
    solution, as shown in *Figure 7**.1*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将 Azure App Configuration 和 Azure Key Vault 添加到解决方案中，如图 *图 7**.1* 所示：
- en: '![Figure 7.1 – Azure services](img/B21217_07_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – Azure 服务](img/B21217_07_01.jpg)'
- en: Figure 7.1 – Azure services
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Azure 服务
- en: Both of these services can be used with any service that needs configuration
    values. The Key Vault service is used to store secrets and adds great features
    for this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种服务都可以与任何需要配置值的任何服务一起使用。Key Vault 服务用于存储秘密，并为这一功能提供了许多增强特性。
- en: Let’s create an Azure App Configuration resource.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Azure App Configuration 资源。
- en: Creating an Azure App Configuration service
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Azure App Configuration 服务
- en: 'We use .NET Aspire to create an Azure App Configuration service. To use the
    .NET Aspire `AppHost` configuration from the `ConfigurationPrototype` project,
    add `AppHost` project and references the project with the app model definition):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用 .NET Aspire 创建 Azure App Configuration 服务。要使用来自 `ConfigurationPrototype`
    项目的 `.NET Aspire `AppHost` 配置，请添加 `AppHost` 项目，并使用应用程序模型定义引用该项目）:'
- en: Codebreaker.AppHost/Program.cs
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For using the Azure App Configuration resource with the `AppHost` project, we
    also need to add the `Aspire.Hosting.Azure.AppConfiguration` NuGet package. Calling
    the `AddAzureAppConfiguration` method adds the resource to the app model. In case
    you don’t use any App Configuration features with your Azure subscription yet,
    you can set the `sku` value to `Free` to use a free version of the App Configuration
    service. The free version does not offer any SLAs and is limited to 1,000 invocations
    per day, but for development, this limit can be fine. The App Configuration service
    is referenced from the `ConfigurationPrototype` project with the `WithReference`
    method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `AppHost` 项目与 Azure App Configuration 资源一起使用，我们还需要添加 `Aspire.Hosting.Azure.AppConfiguration`
    NuGet 包。调用 `AddAzureAppConfiguration` 方法将资源添加到应用程序模型。如果您尚未使用 Azure 订阅中的任何 App
    Configuration 功能，可以将 `sku` 值设置为 `Free` 以使用 App Configuration 服务的免费版本。免费版本不提供任何
    SLA，并且每天限制为 1,000 次调用，但对于开发来说，这个限制可能已经足够。App Configuration 服务通过 `ConfigurationPrototype`
    项目使用 `WithReference` 方法进行引用。
- en: 'Starting the `AppHost` project, the resources are provisioned. Remember to
    have user secrets configured with the `AppHost` project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 启动`AppHost`项目，资源将被配置。请记住，需要使用`AppHost`项目配置用户密钥：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Change the subscription ID to your subscription ID and change the location to
    your chosen Azure region. It can also be helpful to specify the source of credentials
    used to create Azure resources. Setting the value to `AzureCli`, the same account
    is used that you used to log in with the Azure CLI.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将订阅ID更改为您的订阅ID，并将位置更改为您选择的Azure区域。指定用于创建Azure资源的凭据来源也可能很有帮助。将值设置为`AzureCli`，将使用与您使用Azure
    CLI登录相同的帐户。
- en: Because user secrets store the configuration inside the user profile, when using
    the same `UserSecretsId` value with multiple projects, this information might
    already show up. .NET Aspire also adds information about resources created to
    user secrets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户密钥存储将配置存储在用户配置文件中，当使用多个项目中的相同`UserSecretsId`值时，此信息可能已经显示出来。.NET Aspire还会将创建的资源信息添加到用户密钥中。
- en: When you start the application, an additional Azure resource will be created.
    After this is completed successfully, as you can see with the .NET Aspire dashboard,
    let’s add some configuration values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动应用程序时，将创建一个额外的Azure资源。成功完成后，如.NET Aspire仪表板所示，让我们添加一些配置值。
- en: Configuring values with Azure App Configuration
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Azure App Configuration配置值
- en: 'After the creation process of the App Configuration service is completed, we
    can define configuration values using the Configuration explorer in the Azure
    portal (see *Figure 7**.2*):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成App Configuration服务的创建过程后，我们可以在Azure门户中使用配置探索器定义配置值（见图 *7.2*）：
- en: '![Figure 7.2 – Configuration explorer](img/B21217_07_02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 配置探索器](img/B21217_07_02.jpg)'
- en: Figure 7.2 – Configuration explorer
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 配置探索器
- en: With App Configuration, key-value pairs are stored. Creating a `ConfigurationPrototype:ConnectionStrings:SqlServer`
    key, we define a string value for a database connection. As the configuration
    values for all `Codebreaker` services can be configured in one place, it’s good
    practice to use the first part of the key with the name of the service – this
    way, we know which configuration values belong to which service. It’s also possible
    to use JSON content with the value, as we’ll do later with the games API. This
    reduces the number of requests for this service and can simplify the configuration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用App Configuration，键值对被存储。创建一个`ConfigurationPrototype:ConnectionStrings:SqlServer`键，我们定义了一个数据库连接的字符串值。由于所有`Codebreaker`服务的配置值都可以在一个地方配置，因此使用键名的前一部分（即服务的名称）作为键名是一个好习惯——这样我们就可以知道哪些配置值属于哪个服务。还可以使用JSON内容作为值，就像我们稍后将在游戏API中做的那样。这减少了对此服务的请求次数，并可以简化配置。
- en: Next, let’s get the configuration from the `ConfigurationPrototype` project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从`ConfigurationPrototype`项目中获取配置。
- en: Initializing app configuration values
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化应用程序配置值
- en: We can also add configuration values programmatically when the application is
    deployed. To do this, let’s create a background service that runs once.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序部署时，我们也可以通过编程方式添加配置值。为此，让我们创建一个只运行一次的后台服务。
- en: 'Create a new background worker service:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的后台工作服务：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To publish a worker project as a Docker image, you also need to enable SDK
    container support:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要将工作项目发布为Docker镜像，您还需要启用SDK容器支持：
- en: Codebreaker.InitializeAppConfig/Codebreaker.InitializeAppConfig.csproj
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.InitializeAppConfig/Codebreaker.InitializeAppConfig.csproj
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When creating worker projects, without this setting, a Docker image cannot be
    created using `dotnet publish`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建工作项目时，如果没有此设置，则无法使用`dotnet publish`创建Docker镜像。
- en: Add this project to the .NET Aspire orchestration (use .NET Aspire Orchestrator
    Support, or add a reference to the `ServiceDefaults` project and add a project
    reference from the `AppHost` project to this project). Rename the `Worker` class
    that’s created from this template to `AppConfigInitializer`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将此项目添加到.NET Aspire编排中（使用.NET Aspire编排支持，或添加对`ServiceDefaults`项目的引用，并从`AppHost`项目添加项目引用到此项目）。将由此模板创建的`Worker`类重命名为`AppConfigInitializer`。
- en: Add the `Azure.Data.AppConfiguration` and `Microsoft.Extensions.Azure` NuGet
    packages. The `Azure.Data.AppConfiguration` package offers functionality to access
    the App Configuration API to create, read, and update settings. `Microsoft.Extensions.Azure`
    provides integration with the **dependency injection** (**DI**) system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `Azure.Data.AppConfiguration` 和 `Microsoft.Extensions.Azure` NuGet 包。`Azure.Data.AppConfiguration`
    包提供了访问 App Configuration API 以创建、读取和更新设置的函数。`Microsoft.Extensions.Azure` 提供了与
    **依赖注入** (`DI`) 系统的集成。
- en: 'To write configuration settings, add this code to the `AppConfigInitializer`
    class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入配置设置，将以下代码添加到 `AppConfigInitializer` 类中：
- en: Codebreaker.InitializeAppConfig/AppConfigInitializer.cs
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.InitializeAppConfig/AppConfigInitializer.cs
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the constructor of the `AppConfigInitializer` class, the `ConfigurationClient`
    class and the `IHostApplicationLifetime` interface are injected. `ConfigurationClient`
    is the class to communicate with App Configuration. We add settings by invoking
    the `AddConfigurationSettingAsync` method. `IHostApplicationLifetime` is the interface
    for background services to be informed about start and stop events and is used
    to stop the service at the end. After the settings are written, the application
    ends, invoking the `StopApplication` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AppConfigInitializer` 类的构造函数，将 `ConfigurationClient` 类和 `IHostApplicationLifetime`
    接口注入。`ConfigurationClient` 是用于与 App Configuration 通信的类。我们通过调用 `AddConfigurationSettingAsync`
    方法添加设置。`IHostApplicationLifetime` 是用于通知后台服务有关启动和停止事件的接口，并用于在结束时停止服务。在设置写入后，应用程序结束，调用
    `StopApplication` 方法。
- en: 'Now, we can configure the `AppConfigInitializer` class with the DIC configuration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 DIC 配置来配置 `AppConfigInitializer` 类：
- en: Codebreaker.InitializeAppConfig/Program.cs
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.InitializeAppConfig/Program.cs
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `AddHostedService` method requires an object to implement the `IHostedService`
    interface. This interface is implemented with the base class of the `AppConfigInitializer`
    class, `BackgroundService`. When the service is started, the `StartAsync` method
    of `BackgroundService` is invoked, which in turn invokes the `ExecuteAsync` method
    of `AppConfigInitializer` where the configuration values are set.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddHostedService` 方法需要一个实现 `IHostedService` 接口的对象。此接口由 `AppConfigInitializer`
    类的基类 `BackgroundService` 实现。当服务启动时，会调用 `BackgroundService` 的 `StartAsync` 方法，该方法反过来调用
    `AppConfigInitializer` 的 `ExecuteAsync` 方法，在该方法中设置配置值。'
- en: '`AddAzureClients` is an extension method that allows configuring clients to
    access many of the Azure services. Here, we use the `AddConfigurationClient` extension
    method, passing the URL of the App Configuration resource.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAzureClients` 是一个扩展方法，允许配置客户端以访问许多 Azure 服务。在这里，我们使用 `AddConfigurationClient`
    扩展方法，传递 App Configuration 资源的 URL。'
- en: Starting this initializer project now adds configuration settings to the App
    Configuration service. The game APIs service can now be changed to read colors
    for games from the configuration, which allows easy changes of colors without
    recompiling.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动此初始化项目会将配置设置添加到 App Configuration 服务。游戏 API 服务现在可以更改以从配置中读取游戏颜色，这允许轻松更改颜色而无需重新编译。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before .NET Aspire was available, I configured non-secret configuration values
    such as URLs to different Azure resources with Azure App Configuration. As the
    orchestration of .NET Aspire covers this aspect and makes it easy to run the solution
    with different environments and automatically configures these dependencies, App
    Configuration is now mainly used for other application-specific configuration
    values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Aspire 可用之前，我使用 Azure App Configuration 配置了非秘密配置值，例如不同 Azure 资源的 URL。由于
    .NET Aspire 的编排覆盖了这一方面，并使得使用不同环境运行解决方案变得容易，并自动配置这些依赖项，因此 App Configuration 现在主要用于其他特定于应用程序的配置值。
- en: With this initialization in place, let’s continue to read configuration values
    from the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此初始化设置到位后，让我们继续从应用程序中读取配置值。
- en: Using Azure App Configuration from the application
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序中使用 Azure App Configuration
- en: To use the Azure App Configuration service from the .NET application, we need
    to add the `Microsoft.Azure.AppConfiguration.AspNetCore` NuGet package. This NuGet
    package offers a configuration provider.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 .NET 应用程序中使用 Azure App Configuration 服务，我们需要添加 `Microsoft.Azure.AppConfiguration.AspNetCore`
    NuGet 包。此 NuGet 包提供了一个配置提供程序。
- en: 'This provider is configured with the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供程序使用以下代码片段进行配置：
- en: ConfigurationPrototype/Program.cs
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `AddAzureAppConfiguration` extension method adds the App Configuration service
    to the configuration providers. One overload uses a string parameter to pass a
    connection string including a secret. The default orchestration configuration
    of .NET Aspire just passes the URL from the App Configuration service without
    the secret. `DefaultAzureCredential` class. This class uses a defined order to
    try different credentials, including *Visual Studio credentials*, *Azure CLI credentials*,
    and *Azure Developer CLI credentials*. The first credentials that are successfully
    retrieved are used to access the configuration service. The URL to the App Configuration
    service is forwarded from the .NET Aspire orchestrator and retrieved with the
    configuration API. After this, invoking the `Connect` method of the `AzureAppConfigurationOptions`
    class, the URL of the configuration service as well as the credentials are used
    to connect. After adding this configuration provider, App Configuration can be
    used like any other configuration provider.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAzureAppConfiguration` 扩展方法将应用程序配置服务添加到配置提供程序。一个重载使用字符串参数传递包含秘密的连接字符串。.NET
    Aspire 的默认编排配置仅传递应用程序配置服务的 URL，而不包含秘密。`DefaultAzureCredential` 类。此类使用定义的顺序尝试不同的凭据，包括
    *Visual Studio 凭据*、*Azure CLI 凭据*和*Azure Developer CLI 凭据*。首先成功检索到的凭据用于访问配置服务。应用程序配置服务的
    URL 由 .NET Aspire 编排器转发，并通过配置 API 获取。在此之后，调用 `AzureAppConfigurationOptions` 类的
    `Connect` 方法，使用配置服务的 URL 以及凭据进行连接。添加此配置提供程序后，应用程序配置可以像任何其他配置提供程序一样使用。'
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When a solution is deployed to Azure, the local credentials cannot be used.
    A managed identity is used when the solution is running within Azure. This is
    covered later in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当解决方案部署到 Azure 时，不能使用本地凭据。当解决方案在 Azure 中运行时，使用托管标识。这一点将在本章后面介绍。
- en: 'Now, all that needs to be done is to retrieve the configuration values. There’s
    no difference where the configuration is coming from:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要做的只是检索配置值。配置来源没有区别：
- en: ConfigurationPrototype/Program.cs
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Again, the `IConfiguration` interface is injected. The key configured with
    App Configuration has a hierarchical name: `ConfigurationPrototype:ConnectionStrings:SqlServer`.
    The first hierarchy is accessed using the `GetSection` method. Next, the `GetConnectionString`
    method is used. This accesses the section named `ConnectionString` and then uses
    the `SqlServer` key to get its value.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`IConfiguration` 接口被注入。使用应用程序配置配置的键具有层次化名称：`ConfigurationPrototype:ConnectionStrings:SqlServer`。第一个层次结构是通过
    `GetSection` 方法访问的。接下来，使用 `GetConnectionString` 方法。这访问名为 `ConnectionString` 的部分，然后使用
    `SqlServer` 键来获取其值。
- en: With this last change, you can run the application and retrieve the configuration
    value from the App Configuration service!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个最后的更改，您可以运行应用程序并从应用程序配置服务中检索配置值！
- en: Using the environment on your local system uses **user secrets**. In the production
    environment, you already know from the previous chapter how to configure secrets
    with Azure Container Apps to add a connection string to App Configuration in a
    secure manner with secrets of container apps. The Azure Key Vault service covered
    next offers an even more secure environment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地系统上使用环境时使用**用户秘密**。在生产环境中，您可以从上一章中了解到如何使用 Azure Container Apps 配置秘密，以安全的方式将连接字符串添加到应用程序配置中。接下来要介绍的
    Azure Key Vault 服务提供了一个更加安全的环境。
- en: Storing secrets with Azure Key Vault
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure Key Vault 存储秘密
- en: To get secret configuration values, the Azure Key Vault service can be used.
    The Key Vault service can be used to store secrets such as **passwords**, **certificates**,
    and **keys**. This service adds hardware-level encryption, automatic certificate
    renewals, and granular access control. With predefined roles, the service decides
    who is allowed to read secrets (*Key Vault Secrets User*, the application), who
    is allowed to create and update secrets but not read secrets (*Key Vault Contributor*),
    and who is allowed to monitor which users use secrets but not to create and read
    secrets (*Key Vault* *Secrets Officer*).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取秘密配置值，可以使用 Azure Key Vault 服务。Key Vault 服务可以用来存储诸如**密码**、**证书**和**密钥**之类的秘密。此服务增加了硬件级别的加密、自动证书续订和细粒度的访问控制。通过预定义的角色，服务决定谁可以读取秘密（*Key
    Vault Secrets User*，应用程序），谁可以创建和更新秘密但不能读取秘密（*Key Vault Contributor*），以及谁可以监控哪些用户使用秘密但不能创建和读取秘密（*Key
    Vault Secrets Officer*）。
- en: With .NET applications, the Key Vault service can be added as a configuration
    provider, as with Azure App Configuration. Another way to use this service is
    to link secrets stored with Key Vault to an Azure App Configuration instance.
    We will use the second option.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 .NET 应用程序，密钥保管库服务可以作为配置提供程序添加，就像 Azure App 配置一样。另一种使用此服务的方法是将存储在密钥保管库中的秘密链接到
    Azure App 配置实例。我们将使用第二种选项。
- en: When you add a key to App Configuration, instead of just supplying a key and
    value, the key can be linked to a secret stored within the Key Vault service.
    While the same API as used with App Configuration can be used with secrets, the
    user running the service needs access to the Key Vault service.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向 App 配置添加密钥时，除了提供密钥和值之外，密钥还可以链接到存储在密钥保管库服务中的秘密。虽然可以与 App 配置使用的相同 API 一起使用秘密，但运行服务的用户需要访问密钥保管库服务。
- en: 'Let’s create a key vault using the .NET Aspire app model:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 .NET Aspire 应用程序模型创建一个密钥保管库：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `AddAzureKeyVault` method adds a Key Vault resource to the app model. This
    resource is referenced from the following project configuration to pass the URL.
    As with the App Configuration before, secret information is not part of this URL
    passed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAzureKeyVault` 方法将密钥保管库资源添加到应用程序模型。此资源从以下项目配置中引用以传递 URL。与之前的 App 配置一样，秘密信息不是传递的
    URL 的一部分。'
- en: 'Run the application to create the resource. Then, you can verify the **Access
    configuration** page (in the **Settings** section) to verify the permission model,
    as shown in *Figure 7**.3*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序以创建资源。然后，您可以通过查看**访问配置**页面（在**设置**部分）来验证权限模型，如图 *7.3* 所示：
- en: '![Figure 7.3 – Key Vault access configuration](img/B21217_07_03.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 密钥保管库访问配置](img/B21217_07_03.jpg)'
- en: Figure 7.3 – Key Vault access configuration
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 密钥保管库访问配置
- en: 'The Azure Key Vault service supports two access permission models: **vault
    access policy** is the older (legacy) option. **Azure role-based access control**
    is the preferred configuration. User roles are defined to allow read or write
    access to different Key Vault objects such as keys, secrets, and certificates.
    Another setting in this category is for allowing **Azure Resource Manager** (**ARM**)-based
    deployment (which includes Bicep); for this specific resource, access needs to
    be granted.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 密钥保管库服务支持两种访问权限模型：**保管库访问策略**是较旧（遗留）的选项。**Azure 基于角色的访问控制**是首选配置。定义用户角色以允许对不同的密钥保管库对象（如密钥、秘密和证书）进行读取或写入访问。在此类别中另一个设置是允许**Azure
    资源管理器**（**ARM**）基于的部署（包括 Bicep）；对于此特定资源，需要授予访问权限。
- en: 'After the key vault creation succeeds, you can create and import **secrets**,
    **keys**, and **certificates**. In this chapter, we just use the secrets from
    the Key Vault service. Create a secret, as shown in *Figure 7**.4*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在密钥保管库创建成功后，您可以创建和导入**秘密**、**密钥**和**证书**。在本章中，我们仅使用密钥保管库服务的秘密。创建一个秘密，如图 *7.4*
    所示：
- en: '![Figure 7.4 – Creating a secret](img/B21217_07_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 创建秘密](img/B21217_07_04.jpg)'
- en: Figure 7.4 – Creating a secret
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 创建秘密
- en: In addition to the name and the secret value, you can set activation and expiration
    dates.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了名称和秘密值之外，您还可以设置激活和过期日期。
- en: 'After creating the secret, we can switch back to the Azure App Configuration
    service. Create a Key Vault reference to map a configuration value to a value
    from the Azure Key Vault service (as shown in *Figure 7**.5*):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建秘密后，我们可以切换回 Azure App 配置服务。创建一个密钥保管库引用以将配置值映射到 Azure 密钥保管库服务的值（如图 *7.5* 所示）：
- en: '![Figure 7.5 – Mapping Key Vault secrets with App Configuration](img/B21217_07_05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 使用 App 配置映射密钥保管库秘密](img/B21217_07_05.jpg)'
- en: Figure 7.5 – Mapping Key Vault secrets with App Configuration
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 使用 App 配置映射密钥保管库秘密
- en: Adding a Key Vault reference from the Configuration explorer, key values can
    be specified that correspond to the configuration keys, but for the value, a Key
    Vault resource and a secret are referenced.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置资源管理器添加密钥保管库引用时，可以指定与配置键相对应的键值，但对于值，则引用密钥保管库资源和秘密。
- en: 'To connect the App Configuration service to the Key Vault service, the App
    Configuration service needs to be updated:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将 App 配置服务连接到密钥保管库服务时，需要更新 App 配置服务：
- en: ConfigurationPrototype/Program.cs
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Connect` method of the `AzureAppConfigurationOptions` class is a fluent
    API that returns the same options type. With this, the `ConfigureKeyVault` method
    is now invoked to connect the Key Vault service to the same App Configuration
    resource. The `SetCredential` method defines the credentials that should be used
    to access the secrets. Here, we use the same credentials as used with the App
    Configuration service, but it’s also possible to use different credentials.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`AzureAppConfigurationOptions` 类的 `Connect` 方法是一个流畅的 API，它返回相同的选项类型。因此，现在调用
    `ConfigureKeyVault` 方法将 Key Vault 服务连接到相同的 App Configuration 资源。`SetCredential`
    方法定义了用于访问机密的凭证。在这里，我们使用与 App Configuration 服务相同的凭证，但也可以使用不同的凭证。'
- en: 'With this configuration in place, secrets can be accessed in the same way as
    other configuration values:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置下，机密可以像其他配置值一样访问：
- en: ConfigurationPrototype/Program.cs
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Having the Key Vault service connected to the App Configuration service, we
    can use the same configuration API we used previously. Behind the scenes, different
    access mechanisms are used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Key Vault 服务已连接到 App Configuration 服务，我们可以使用之前使用的相同配置 API。幕后，使用了不同的访问机制。
- en: Run the application and check how secrets can be retrieved successfully using
    the `DefaultAzureCredential` type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并检查如何使用 `DefaultAzureCredential` 类型成功检索机密。
- en: Before we integrate the App Configuration and Key Vault services with our game
    APIs and bot services, we can get rid of some needed secrets with configuration
    values using managed identities.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 App Configuration 和 Key Vault 服务与我们的游戏 API 和机器人服务集成之前，我们可以使用管理身份通过配置值去除一些必要的机密。
- en: Reducing the need for secrets with managed identities
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少使用管理身份的机密需求
- en: Managed identities (now known by the full name **Microsoft Entra managed identities
    for Azure resources**) remove the hassles we had with service principals. Managed
    identities abstract service principals, creating and deleting them automatically.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 管理身份（现称为**Microsoft Entra 管理身份用于 Azure 资源**）消除了我们之前与服务主体相关的麻烦。管理身份抽象化了服务主体，并自动创建和删除它们。
- en: Using an Azure service (such as Azure Container Apps), the identity of the service
    can be configured to run with a managed identity. Services that are accessed (such
    as Azure App Configuration) use role management, whereby you configure who has
    access to this resource – which includes a simple option to select a managed identity.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure 服务（如 Azure Container Apps），可以配置服务的身份以管理身份运行。访问的服务（如 Azure App Configuration）使用角色管理，您可以通过角色管理配置谁可以访问此资源——其中包括选择管理身份的简单选项。
- en: 'The kinds of managed identities that are available are **system-assigned managed
    identities** and **user-assigned** **managed identities**:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的管理身份类型包括**系统分配的管理身份**和**用户分配的管理身份**：
- en: A system-assigned managed identity is directly associated with the Azure resource.
    If the Azure resource is deleted, the managed identity and its role-based access
    are removed as well.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统分配的管理身份直接关联到 Azure 资源。如果删除 Azure 资源，管理身份及其基于角色的访问权限也会被移除。
- en: A user-assigned managed identity is created independent of an Azure service.
    As with other Azure resources, user-assigned managed identities are resources
    within a resource group.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户分配的管理身份是独立于 Azure 服务创建的。与其他 Azure 资源一样，用户分配的管理身份是资源组内的资源。
- en: Each of these two options has advantages but also disadvantages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项各有优缺点。
- en: 'Properties and advantages of system-assigned managed identities include the
    following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 系统分配的管理身份的属性和优势包括以下内容：
- en: They have the same lifetime as the service
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的生命周期与服务的生命周期相同
- en: Deleting the service also deletes the managed identity and its role assignments
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除服务也会删除管理身份及其角色分配
- en: 'Advantages of user-assigned managed identities include the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 用户分配的管理身份的优势包括以下内容：
- en: One user-assigned managed identity can be used by multiple services.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户分配的管理身份可以被多个服务使用。
- en: Deleting the service does not delete the managed identity – it can be used from
    other services.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除服务不会删除管理身份 - 它可以被其他服务使用。
- en: Multiple services can use the same managed identity. If multiple services need
    the same permissions, you only need to specify this once with the shared managed
    identity.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个服务可以使用相同的管理身份。如果多个服务需要相同的权限，您只需使用共享管理身份指定一次即可。
- en: 'One service can use multiple user-assigned managed identities. This also includes
    a disadvantage: using a user-assigned managed identity requires you to configure
    the principal ID to specify which managed identity to use.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务可以使用多个用户分配的托管标识。这也包括一个缺点：使用用户分配的托管标识需要你配置主体 ID 以指定要使用哪个托管标识。
- en: '*Figure 7**.6* shows a user-assigned managed identity that is used with the
    bot service and the games API to access the App Configuration and Key Vault services:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.6**显示了与机器人服务和游戏 API 一起使用的用户分配的托管标识，用于访问应用配置和密钥保管库服务：'
- en: '![Figure 7.6 – Assigning managed identities](img/B21217_07_06.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 分配托管标识](img/B21217_07_06.jpg)'
- en: Figure 7.6 – Assigning managed identities
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 分配托管标识
- en: Let’s create a managed identity and assign permissions to this managed identity.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个托管标识并为此托管标识分配权限。
- en: Creating a managed identity and assigning roles
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建托管标识并分配角色
- en: Running the application from the local system, managed identities are not used.
    To use managed identities within Azure, let’s deploy the solution to Azure, as
    described in the *Technical* *requirements* section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地系统上运行应用程序时，不使用托管标识。要在 Azure 中使用托管标识，请按照*技术要求*部分所述部署解决方案。
- en: 'After the resources are successfully deployed, open the Azure Container App
    service for the game APIs with the Azure portal and select **Identity** in the
    **Settings** section, as shown in *Figure 7**.7*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 资源成功部署后，使用 Azure 门户打开游戏 API 的 Azure 容器应用服务，并在**设置**部分选择**标识**，如图**7.7**所示。
- en: '![Figure 7.7 – Managed identity](img/B21217_07_07.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 托管标识](img/B21217_07_07.jpg)'
- en: Figure 7.7 – Managed identity
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 托管标识
- en: The system-assigned identity is turned off, but a user-assigned managed identity
    is created. If you open the identity configuration with the other container apps,
    you can see that the same managed identity is assigned to all these apps, making
    it easy to define permissions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 系统分配的标识已关闭，但已创建用户分配的托管标识。如果你使用其他容器应用打开标识配置，你可以看到相同的托管标识被分配给所有这些应用，这使得定义权限变得容易。
- en: 'Clicking on this managed identity, select **Add role assignment**, as shown
    in *Figure 7**.8*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此托管标识，选择**添加角色分配**，如图**7.8**所示。
- en: '![Figure 7.8 – Role-based access for the managed identity](img/B21217_07_08.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 托管标识的角色访问控制](img/B21217_07_08.jpg)'
- en: Figure 7.8 – Role-based access for the managed identity
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 托管标识的角色访问控制
- en: Here, you see that this managed identity already has several roles assigned
    – it can pull Docker images from the Azure Container Registry service, which is
    needed on deployment of the Azure Container App service, it can access the Azure
    Key Vault, and it has access to the Azure App Configuration service with the **App
    Configuration Data Owner** role. This allows setting configuration values that
    could be changed to read access if the configuration values are not set by an
    application running with this identity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到这个托管标识已经分配了几个角色——它可以从 Azure 容器注册服务中拉取 Docker 镜像，这在部署 Azure 容器应用服务时是必需的，它可以访问
    Azure 密钥保管库，并且它具有使用**应用配置数据所有者**角色的访问权限。这允许设置配置值，如果未由运行此标识的应用程序设置配置值，则可以将其更改为读取访问。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might wonder why the managed identity has the administrator role assigned
    to the Key Vault service and the **App Configuration Data Owner** role with the
    App Configuration service. This managed identity is also used during deployment.
    When the Azure Container Apps service is deployed, a secret containing the connection
    string of the Azure Cosmos DB database is added to the Key Vault service. Specifying
    configuration values can be supplied to the App Configuration service.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么托管标识被分配了密钥保管库服务的管理员角色以及应用配置服务的**应用配置数据所有者**角色。这个托管标识在部署过程中也被使用。当部署
    Azure 容器应用服务时，会向密钥保管库服务添加一个包含 Azure Cosmos DB 数据库连接字符串的秘密。可以指定配置值并将其提供给应用配置服务。
- en: To support the **principle of least privilege** (**PoLP**), only the necessary
    permissions should be applied. You can create multiple managed identities for
    different container apps or use system-assigned managed identities, whereby every
    container app has a different identity, and specify the required roles for every
    identity. A container app can have just one system-assigned managed identity but
    multiple user-assigned managed identities. Different identities can be used for
    deployment and while running the application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持**最小权限原则**（**PoLP**），应仅应用必要的权限。您可以为不同的容器应用创建多个托管标识，或使用系统分配的托管标识，这样每个容器应用都有一个不同的标识，并为每个标识指定所需的角色。容器应用可以只有一个系统分配的托管标识，但可以有多个用户分配的托管标识。不同的标识可以用于部署和运行应用程序。
- en: Let’s get back to some C# code – the games API, the bot service, and the configuration
    prototype startup code to configure Azure App Configuration with a managed identity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到一些C#代码——游戏API、机器人服务以及配置原型启动代码，以使用托管标识配置Azure应用程序配置。
- en: Configuring the Azure App Configuration provider with managed identities
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用托管标识配置Azure应用程序配置提供程序
- en: Previously, with the `ConfigurationPrototype` project, we already used the `AddAzureAppConfiguration`
    method overload, which doesn’t require a connection string containing a secret.
    Invoking the `Connect` method, we supplied a `DefaultAzureCredential` instance.
    Using a user-assigned managed identity, a change is needed here. An application
    can have just one system-assigned managed identity assigned but multiple user-assigned
    managed identities. The one we use needs to be specified.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，使用`ConfigurationPrototype`项目时，我们已经使用了`AddAzureAppConfiguration`方法重载，该方法不需要包含密钥的连接字符串。调用`Connect`方法时，我们提供了一个`DefaultAzureCredential`实例。使用用户分配的托管标识时，这里需要做出更改。一个应用程序可以分配一个系统分配的托管标识，但可以有多个用户分配的托管标识。我们需要指定我们使用的那个。
- en: 'Let’s check the configuration that has been applied to Azure Container Apps.
    Open the configuration prototype container app in the Azure portal, and within
    the **Settings** category, open **Secrets**, as shown in *Figure 7**.9*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查已应用到Azure容器应用的配置。在Azure门户中打开配置原型容器应用，在**设置**类别中打开**密钥**，如图**7.10**所示：
- en: '![Figure 7.9 – Secrets with Azure Container Apps](img/B21217_07_09.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.9 – Azure容器应用中的密钥](img/B21217_07_09.jpg)'
- en: Figure 7.9 – Secrets with Azure Container Apps
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.9 – Azure容器应用中的密钥
- en: The connection strings to the Azure App Configuration and Azure Key Vault services
    are stored with the **Secrets** configuration. This wouldn’t really be required
    as secret keys are not part of these links – but it would help if the configuration
    were changed to not only the endpoint link but also the connection string containing
    the endpoint and the secret.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Azure应用程序配置和Azure密钥保管库服务的连接字符串存储在**密钥**配置中。这实际上并不是必需的，因为密钥不是这些链接的一部分——但如果配置更改不仅包含端点链接，还包含包含端点和密钥的连接字符串，这将有所帮助。
- en: 'Because the secret is not part of this secret configuration, check the environment
    variables configured. This setting is available in the **Application** category.
    Click on **Containers** and select **Environment variables**, as shown in *Figure
    7**.10*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为密钥不是此密钥配置的一部分，请检查配置的环境变量。此设置在**应用程序**类别中可用。点击**容器**并选择**环境变量**，如图**7.10**所示：
- en: '![Figure 7.10 – Environment variables with Azure Container Apps](img/B21217_07_10.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.10 – Azure容器应用中的环境变量](img/B21217_07_10.jpg)'
- en: Figure 7.10 – Environment variables with Azure Container Apps
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.10 – Azure容器应用中的环境变量
- en: 'The identifier of the user-assigned managed ID is passed as an environment
    variable named `AZURE_CLIENT_ID`. This environment variable can be used to select
    the managed identity. Let’s use this to configure the `DefaultAzureCredential`
    object. We used this class earlier, but now it’s time to investigate the different
    options offered. `DefaultAzureCredential` uses accounts in this order:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用户分配的托管ID的标识符作为名为`AZURE_CLIENT_ID`的环境变量传递。此环境变量可以用来选择托管标识。让我们使用它来配置`DefaultAzureCredential`对象。我们之前使用过这个类，但现在我们需要调查它提供的不同选项。`DefaultAzureCredential`按照以下顺序使用账户：
- en: '`EnvironmentCredential` – This authentication needs environmental variables
    containing client IDs, tenant IDs, and secrets to be set. We don’t use this here.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnvironmentCredential` – 此认证需要设置包含客户端ID、租户ID和密钥的环境变量。我们这里不使用此方法。'
- en: '`WorkloadIdentityCredential` – When running on **Azure Kubernetes Service**
    (**AKS**), Microsoft Entra workload identities can be enabled.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkloadIdentityCredential` – 当在 **Azure Kubernetes Service** (**AKS**) 上运行时，可以启用
    Microsoft Entra 工作负载标识。'
- en: '`ManagedIdentityCredential` – This is the authentication used when the application
    runs with managed identities configured within Microsoft Azure.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManagedIdentityCredential` – 这是当应用程序在配置了 Microsoft Azure 中的托管标识时使用的认证方式。'
- en: '`SharedTokenCacheCredential` – This is a legacy mechanism that has been replaced
    by `VisualStudioCredential`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedTokenCacheCredential` – 这是一个已由 `VisualStudioCredential` 取代的传统机制。'
- en: '`VisualStudioCredential` – Using Visual Studio, in the options dialog, you
    can configure the account to be used with Azure Service authentication. This is
    the account used with `VisualStudioCredential`. Just make sure within Visual Studio
    that you don’t need to re-authenticate – otherwise, authentication via `DefaultAzureCredential`
    might not succeed.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisualStudioCredential` – 使用 Visual Studio，在选项对话框中，你可以配置用于 Azure 服务认证的账户。这是与
    `VisualStudioCredential` 一起使用的账户。只需确保在 Visual Studio 中你不需要重新认证 – 否则，通过 `DefaultAzureCredential`
    的认证可能不会成功。'
- en: '`VisualStudioCodeCredential` – This is a similar mechanism to `VisualStudioCredential`
    for Visual Studio Code but doesn’t work with the current version of the *Azure
    Account extension*. A new authentication mechanism is going to be built for Visual
    Studio Code, but this requires some time before it’s ready. Using Visual Studio
    Code, use the next option.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisualStudioCodeCredential` – 这与 `VisualStudioCredential` 类似，是用于 Visual Studio
    Code 的机制，但与当前版本的 *Azure Account 扩展* 不兼容。将为 Visual Studio Code 构建一个新的认证机制，但这需要一些时间才能准备就绪。使用
    Visual Studio Code 时，请使用下一个选项。'
- en: '`AzureCliCredential` – This is the account used by the Azure CLI. With the
    `az account list` command, you can see the Azure accounts and subscriptions you
    are logged in to. `az account show` gives you the default account and subscription
    that will be used. If this is not the correct one, use `az account set` to set
    the current active subscription.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AzureCliCredential` – 这是 Azure CLI 使用的账户。使用 `az account list` 命令，你可以看到你登录的
    Azure 账户和订阅。`az account show` 会显示将使用的默认账户和订阅。如果这不是正确的账户，请使用 `az account set` 来设置当前活动订阅。'
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case you have issues using the `DefaultAzureCredential` class in your development
    environment, you can enable diagnostic information and also enable or disable
    specific accounts explicitly to find the issues. Check this troubleshooting guide
    in case you have any errors: [https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在开发环境中使用 `DefaultAzureCredential` 类时遇到问题，你可以启用诊断信息，并显式启用或禁用特定账户以查找问题。如有错误，请查看此故障排除指南：[https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md)。
- en: 'Let’s update the configuration to use Azure App Configuration while the application
    is running within Azure:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新配置，以便在应用程序在 Azure 中运行时使用 Azure App Configuration：
- en: ConfigurationPrototype/Program.cs
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigurationPrototype/Program.cs
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`DefaultAzureCredential` not only works in the development environment but
    also when the application runs within Azure. Using system-assigned managed identities,
    a change would not be required. With user-assigned managed identities, the `ManagedIdentityClientId`
    property needs to be set to the ID of the managed identity. We do this by reading
    the `AZURE_CLIENT_ID` environment variable and passing the value to this setting.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultAzureCredential` 不仅在开发环境中有效，当应用程序在 Azure 中运行时也有效。使用系统分配的托管标识，不需要进行更改。使用用户分配的托管标识，需要将
    `ManagedIdentityClientId` 属性设置为托管标识的 ID。我们通过读取 `AZURE_CLIENT_ID` 环境变量并将值传递给此设置来完成此操作。'
- en: Using the `Select` method with the `AzureAppConfigurationOptions` class returned
    from the `Connect` method filters the configuration value. Because configuration
    values are specified for all services of the solution, we just need the ones that
    start with the `ConfigurationPrototype` key. With the bot and the game API services,
    the filtering is done with the `bot` and `gameapis` keys.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从 `Connect` 方法返回的 `AzureAppConfigurationOptions` 类的 `Select` 方法可以过滤配置值。因为配置值是为解决方案的所有服务指定的，所以我们只需要以
    `ConfigurationPrototype` 键开始的那些值。对于机器人和游戏 API 服务，过滤是通过 `bot` 和 `gameapis` 键完成的。
- en: Run the configuration prototype with these changes, and then let’s continue
    using .NET environments with App Configuration.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 运行配置原型，并使用这些更改，然后让我们继续使用 App 配置使用 .NET 环境。
- en: Using environments with Azure App Configuration
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure App 配置的环境
- en: The Azure container apps are deployed and running, using all the Azure services
    we have created so far. What’s missing with App Configuration are the different
    environments that are supported with the .NET configuration. Is the application
    running in the local development environment, in the Azure test environment, or
    on the production server? Running in the test environment, the production database
    should not be used.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 容器应用程序已部署并运行，使用了我们迄今为止创建的所有 Azure 服务。使用 App 配置缺少的是 .NET 配置支持的不同环境。应用程序是在本地开发环境中运行，在
    Azure 测试环境中运行，还是在生产服务器上运行？在测试环境中运行时，不应使用生产数据库。
- en: .NET configuration supports different environments – depending on the environment,
    either `appsettings.development.json` or `appsettings.production.json` is loaded.
    Similar functionality is possible with Azure App Configuration using **labels**.
    We can specify development, production, and testing labels to differentiate environment
    configurations. This can be mapped to .NET environments.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 配置支持不同的环境——根据环境，要么加载 `appsettings.development.json`，要么加载 `appsettings.production.json`。使用
    Azure App Configuration 也可以实现类似的功能，使用 **标签** 来区分环境配置。我们可以指定开发、生产和测试标签来区分环境配置。这可以映射到
    .NET 环境。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s a good practice to separate the production and the development environments
    across different Azure subscriptions, probably also using different Azure Active
    Directory services. Here, you also use separate Azure App Configuration services.
    Some environments can use the same subscription; for example, the production and
    the staging environments can be configured to run in the same subscription. In
    such cases, labels can be used to map different configuration values to environments.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的 Azure 订阅中区分生产环境和开发环境是一个好习惯，可能还会使用不同的 Azure Active Directory 服务。在这里，您也使用单独的
    Azure App 配置服务。某些环境可以使用相同的订阅；例如，生产环境和预发布环境可以配置为在同一个订阅中运行。在这种情况下，可以使用标签将不同的配置值映射到环境中。
- en: Using App Configuration labels to map .NET environments
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 App 配置标签映射 .NET 环境
- en: In the Azure portal, open the Azure App Configuration service again. Create
    a new key-value pair and use the `BotService` key again, but this time, set the
    label to `Development`. The default setting of this key should contain the `ApiBase`
    configuration to the games API running in the container app, whereas the `Development`
    label should reference `localhost`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 门户中，再次打开 Azure App 配置服务。创建一个新的键值对，并再次使用 `BotService` 键，但这次，将标签设置为 `Development`。此键的默认设置应包含运行在容器应用程序中的游戏
    API 的 `ApiBase` 配置，而 `Development` 标签应引用 `localhost`。
- en: 'With the startup code of the bot service, we can now change the filtering code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用机器人服务的启动代码，我们现在可以更改过滤代码：
- en: Codebreaker.Bot/Program.cs
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Bot/Program.cs
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Invoking the `Select` method multiple times works the same way as you saw at
    the beginning of this chapter with multiple configuration providers. If a setting
    is configured multiple times, the last one wins. The first `Select` method loads
    all configuration values where the key starts with `BotService`, and no label
    filter is applied. Next, all configuration values where, again, the key starts
    with the name `BotService` are loaded, but this time, only values where a label
    with the same name as the current environment name are loaded. All configuration
    values that are not overwritten from the specific environment label are unchanged
    – the value is the active one. With all keys with a matching label, the new value
    is now active.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 多次调用 `Select` 方法的方式与您在本章开头看到的使用多个配置提供程序的方式相同。如果一个设置被配置了多次，最后一个配置生效。第一个 `Select`
    方法加载所有以 `BotService` 开头的配置值，并且没有应用标签过滤器。接下来，加载所有以 `BotService` 开头的配置值，但这次，只加载与当前环境名称相同的标签的值。所有未被特定环境标签覆盖的配置值保持不变——该值是活动的。对于所有匹配标签的键，新的值现在生效。
- en: This is all that needs to be done to map different environment configuration
    values with the Azure App Configuration service.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 Azure App 配置服务映射不同环境配置值所需完成的所有工作。
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t need the Azure resources for some time, delete the resource group.
    In the next chapter, we’ll re-create the services again. `azd up` makes this easy!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一段时间内不需要 Azure 资源，请删除资源组。在下一章中，我们将重新创建这些服务。`azd up` 使得这个过程变得简单！
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was quite a journey around using Azure services for common needs such as
    Azure App Configuration and Azure Key Vault in relation to configuration with
    .NET. You learned how .NET configuration offers features to attach different providers
    and used Azure App Configuration for storing configuration values for a large
    list of services. The Azure Key Vault service was used to store secrets. In addition
    to this, you learned about using managed identities, which can help get rid of
    a lot of secrets.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次围绕使用 Azure 服务来解决常见需求（如 Azure 应用配置和 Azure Key Vault 与 .NET 配置相关）的旅程。您学习了
    .NET 配置如何提供附加不同提供者的功能，并使用 Azure 应用配置来存储大量服务的配置值。Azure Key Vault 服务用于存储机密。除此之外，您还学习了如何使用托管标识，这有助于消除许多机密。
- en: In this chapter, we used the Azure Developer CLI to create Docker images, publish
    them to the Azure Container Registry service, and create new replicas of Azure
    container apps using the new image. While `azd up` makes this easy, this can be
    automated. This is of special interest in testing, staging, and production environments.
    In the next chapter, we will automate these activities using GitHub Actions. There’s
    also more that can be done with Azure App Configuration – using feature flags
    with modern deployment patterns. This is covered in [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183)
    as well.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了 Azure 开发者 CLI 来创建 Docker 镜像，将它们发布到 Azure 容器注册表服务，并使用新镜像创建 Azure 容器应用的新副本。虽然
    `azd up` 使得这个过程变得简单，但这可以自动化。这在测试、预生产和生产环境中特别有趣。在下一章中，我们将使用 GitHub Actions 自动化这些活动。此外，Azure
    应用配置还可以做更多的事情——使用现代部署模式中的功能标志。这将在[*第 8 章*](B21217_08.xhtml#_idTextAnchor183)中介绍。
- en: Further reading
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考以下链接：
- en: 'Configuration providers in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 中的配置提供者：[https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers)
- en: 'Options pattern in .NET: [https://learn.microsoft.com/dotnet/core/extensions/options](https://learn.microsoft.com/dotnet/core/extensions/options)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 中的选项模式：[https://learn.microsoft.com/dotnet/core/extensions/options](https://learn.microsoft.com/dotnet/core/extensions/options)
- en: 'Microsoft Entra managed identities: [https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/](https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Entra 管理标识：[https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/](https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/)
- en: 'Troubleshooting with `AzureDefaultCredential`: [https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AzureDefaultCredential` 进行故障排除：[https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md)
- en: 'Built-in roles: [https://learn.microsoft.com/azure/role-based-access-control/built-in-roles](https://learn.microsoft.com/azure/role-based-access-control/built-in-roles)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置角色：[https://learn.microsoft.com/azure/role-based-access-control/built-in-roles](https://learn.microsoft.com/azure/role-based-access-control/built-in-roles)
- en: 'Azure Key Vault keys, secrets, and certificates: [https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Key Vault 密钥、机密和证书：[https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates)
- en: 'PoLP: [https://learn.microsoft.com/en-us/entra/identity-platform/secure-least-privileged-access](https://learn.microsoft.com/en-us/entra/identity-platform/secure-least-privileged-access)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PoLP：[https://learn.microsoft.com/en-us/entra/identity-platform/secure-least-privileged-access](https://learn.microsoft.com/en-us/entra/identity-platform/secure-least-privileged-access)
- en: 'Microsoft Entra Workload ID: [https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview](https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Entra Workload ID：[https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview](https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview)
