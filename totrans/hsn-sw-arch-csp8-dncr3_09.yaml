- en: How to Choose Your Data Storage in the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在云中选择您的数据存储
- en: Azure, like other clouds, offers a wide range of storage devices. The simplest
    approach is to define a scalable set of virtual machines hosted in the cloud where
    we can implement our custom solutions. For instance, we can create a SQL Server
    cluster on our cloud-hosted virtual machines to increase reliability and computational
    power. However, usually, custom architectures aren't the optimal solution and
    don't take full advantage of the opportunities offered by the cloud infrastructure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他云服务一样，Azure 提供了广泛的存储设备。最简单的方法是在云中定义一组可扩展的虚拟机，我们可以在这些虚拟机上实现我们的自定义解决方案。例如，我们可以在云托管的虚拟机上创建一个
    SQL Server 集群，以增加可靠性和计算能力。然而，通常，自定义架构并不是最佳解决方案，也没有充分利用云基础设施提供的机遇。
- en: Therefore, this chapter will not discuss such custom architectures but will
    focus mainly on the various **Storage as a Service** (**SaaS**) offerings that
    are available in the cloud and, in particular, on Azure. These offers include
    scalable solutions based on plain disk space, relational databases, NoSQL databases,
    and in-memory data stores such as Redis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将不会讨论此类自定义架构，而将主要关注云中可用的各种 **存储即服务**（**SaaS**） 提供方案，特别是 Azure。这些方案包括基于普通磁盘空间的可扩展解决方案、关系型数据库、NoSQL
    数据库以及如 Redis 这样的内存数据存储。
- en: Choosing a more adequate storage type is based not only on the application's
    functional requirements but also on performance and scaling-out requirements.
    In fact, while scaling-out when processing resources causes a linear increase
    in performance, scaling-out storage resources doesn't necessarily imply an acceptable
    increase in performance. In a few words, no matter how much you duplicate your
    data storage devices, if several requests affect exactly the same chunk of data,
    they will always queue the same amount of time to access it!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 选择更合适的存储类型不仅基于应用程序的功能需求，还基于性能和扩展需求。实际上，在处理资源时进行扩展会导致性能的线性增长，但扩展存储资源并不一定意味着性能的合理增长。简而言之，无论你复制多少数据存储设备，如果多个请求影响的是同一数据块，它们将始终需要相同的时间来排队访问它！
- en: Scaling-out data causes linear increases of read operation throughput since
    each copy can serve a different request, but it doesn't imply the same increase
    in the throughput for write operations since all copies of the same chunk of data
    must be updated! Accordingly, more sophisticated techniques are required to scale-out
    storage devices, and not all storage engines scale equally well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展数据会导致读取操作吞吐量的线性增长，因为每个副本可以服务不同的请求，但这并不意味着写入操作吞吐量会有相同的增长，因为同一数据块的所有副本都必须更新！因此，需要更复杂的技巧来扩展存储设备，并且并非所有存储引擎都能同等程度地扩展。
- en: In particular, relational databases don't scale well in all scenarios. Therefore,
    scaling needs and the need to distribute data geographically play a fundamental
    role in the choice of a storage engine, as well as in the choice of a SaaS offering.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在所有场景中，关系型数据库的扩展性都不好。因此，扩展需求和地理分布数据的需求在存储引擎的选择中起着基本作用，以及在 SaaS 提供商的选择中也是如此。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the different repositories for different purposes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同目的的不同存储库
- en: Choosing between structure or NoSQL storage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构化或 NoSQL 存储之间进行选择
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cosmos DB - 管理多大陆数据库的机会
- en: Use case – storing data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例 - 存储数据
- en: 'Let''s get started:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires that you have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您具备以下条件：
- en: Visual Studio 2017 or 2019 free Community Edition or better with all its database
    tools installed.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017 或 2019 的免费社区版或更高版本，并安装所有数据库工具。
- en: A free Azure account. The *Creating an Azure account* subsection in [Chapter
    1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the Importance
    of Software Architecture*, explains how to create one.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的 Azure 账户。[第 1 章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)中的“*创建 Azure
    账户*”小节解释了如何创建一个。
- en: For a better development experience, we advise that you also install the local
    emulator of Cosmos DB, which can be found at [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获得更好的开发体验，我们建议您还安装 Cosmos DB 的本地模拟器，可在[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)找到。
- en: Understanding the different repositories for different purposes
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同目的的不同存储库
- en: This section describes the functionalities that are offered by the most popular
    data storage techniques. Mainly, we will focus on the functional requirements
    they are able to satisfy. Performance and scaling-out features will be analyzed
    in the next section, which is dedicated to comparing relational and NoSQL databases.
    In Azure, the various offerings can be found by typing product names into the
    search bar at the top of all Azure portal pages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了最流行的数据存储技术所提供的功能。主要，我们将关注它们能够满足的功能需求。性能和扩展功能将在下一节中分析，该节专门用于比较关系型数据库和NoSQL数据库。在Azure中，可以通过在所有Azure门户页面顶部的搜索栏中输入产品名称来找到各种服务。
- en: The following subsections describe the various kinds of database that we can
    use in our C# projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节描述了我们可以用于我们的C#项目的各种数据库类型。
- en: Relational databases
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: Usually, clouds offer several database engines. Azure offers a variety of popular
    database engines, such as SQL Server (Azure SQL Server), MySQL, and Oracle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，云提供多种数据库引擎。Azure提供各种流行的数据库引擎，如SQL Server（Azure SQL Server）、MySQL和Oracle。
- en: With regard to the Oracle database engine, Azure offers configurable virtual
    machines with various Oracle editions installed on them, which you can easily
    verify by the suggestions you get after typing `Oracle` into the Azure portal
    search bar. Azure fees don't include Oracle licenses; they just bring computation
    time, so you must bring your own license to Azure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Oracle数据库引擎，Azure提供可配置的虚拟机，这些虚拟机上安装了各种Oracle版本，您可以通过在Azure门户搜索栏中输入`Oracle`后得到的建议轻松验证。Azure费用不包括Oracle许可证；它们仅提供计算时间，因此您必须将许可证带到Azure。
- en: 'With MySQL on Azure, you pay to use a private server instance. The fees you
    incur depend on the number of cores you have, how much memory has to be allocated,
    and on backup retention time. MySQL instances are redundant and you can choose
    between a local or geographically distributed redundancy:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure上使用MySQL时，您需要为使用私有服务器实例付费。您产生的费用取决于您拥有的核心数量、需要分配多少内存以及备份保留时间。MySQL实例是冗余的，您可以选择本地或地理分布式的冗余：
- en: '![](img/3a871e4b-5bbe-4c0f-906e-5e2a3377be2d.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a871e4b-5bbe-4c0f-906e-5e2a3377be2d.png)'
- en: 'Azure SQL Server is the most flexible offer. Here, you can configure resources
    that are used by every single database. When you create a database, you have the
    option to place it on an existing server instance or create a new instance. Fees
    are based on the database memory that''s been reserved and on the required **Database
    Transaction Units** (**DTUs**). Here, a DTU is a linear combination of I/O operations,
    CPU usage, and memory usage that''s determined by a reference workload. Roughly,
    maximal DB performance increases linearly when you increase DTUs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Azure SQL Server是最灵活的提供方案。在这里，您可以配置每个数据库使用的资源。当您创建数据库时，您可以选择将其放置在现有的服务器实例上或创建一个新的实例。费用基于已预留的数据库内存以及所需的**数据库事务单元**（**DTUs**）。在这里，一个DTU是由参考工作负载确定的I/O操作、CPU使用率和内存使用的线性组合。大致来说，当您增加DTUs时，最大数据库性能的增加是线性的：
- en: '![](img/04490184-bfc4-4eec-9eee-281af77ed4d3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04490184-bfc4-4eec-9eee-281af77ed4d3.png)'
- en: You can also configure data replication by enabling Read scale-out. This way,
    you can improve the performance of read operations. Backup retention is fixed
    for each offering level (basic, standard, and premium).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过启用读扩展来配置数据复制。这样，您可以提高读取操作的性能。备份保留时间对于每个服务级别（基本、标准和高级）都是固定的。
- en: If you select Yes for Want to use SQL elastic pool?, the database will be added
    to an elastic pool. Databases that are added to the same elastic pool will share
    their resources, so resources that aren't used by a database can be used during
    the *usage peaks* of other databases. Elastic pools can contain databases hosted
    on different server instances. Elastic pools are an efficient way to optimize
    resource usage in order to reduce costs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择“是”以回答“是否想使用SQL弹性池？”，则数据库将被添加到弹性池中。添加到同一弹性池的数据库将共享其资源，因此未被数据库使用的资源可以在其他数据库的*使用高峰*期间使用。弹性池可以包含托管在不同服务器实例上的数据库。弹性池是优化资源使用以降低成本的有效方式。
- en: NoSQL databases
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: In NoSQL databases, relational tables are replaced with more general collections
    that can contain heterogeneous JSON objects. That is, collections have no predefined
    structure and no predefined fields with length constraints (in the case of strings)
    but can contain any type of object. The only structural constraint associated
    with each collection is the name of the property that acts as a primary key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL数据库中，关系表被更通用的集合所取代，这些集合可以包含异构的JSON对象。也就是说，集合没有预定义的结构和没有预定义的字段长度限制（在字符串的情况下），但可以包含任何类型的对象。与每个集合相关联的唯一结构约束是作为主键的属性名称。
- en: More specifically, each collection entry can contain nested objects and object
    collections nested in object properties, that is, related entities that, in relational
    databases, are contained in different tables and connected through external keys.
    In NoSQL, databases can be nested in their father entities. Since collection entries
    contain complex nested objects instead of simple property/value pairs, as is the
    case with relational databases, entries aren't called tuples or rows, but *documents*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，每个集合条目可以包含嵌套对象和嵌套在对象属性中的对象集合，即相关实体，在关系数据库中，这些实体包含在不同的表中并通过外部键连接。在NoSQL中，数据库可以嵌套在其父实体中。由于集合条目包含复杂的嵌套对象，而不是像关系数据库那样简单的属性/值对，因此条目不被称为元组或行，而是*文档*。
- en: No relations and/or external key constraints can be defined between documents
    that belong to the same collection or to different collections. If a document
    contains the primary key of another document in one of its properties, it does
    so at its own risk. The developer has the responsibility of maintaining and keeping
    these coherent references.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一集合或不同集合中属于同一文档的文档之间不能定义关系和/或外部键约束。如果一个文档在其属性中包含另一个文档的主键，那么它这样做是有风险的。开发者有责任维护并保持这些一致性的引用。
- en: Finally, since NoSQL storage is quite cheap, whole binary files can be stored
    as the values of document properties as Base64 strings. The developer can define
    rules to decide what properties to index in a collection. Since documents are
    nested objects, properties are actually tree paths. Usually, by default, all the
    paths are indexed, but you can specify which collection of paths and subpaths
    to index.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于NoSQL存储相对便宜，整个二进制文件可以作为文档属性的值以Base64字符串的形式存储。开发者可以定义规则来决定在集合中索引哪些属性。由于文档是嵌套对象，属性实际上是树路径。通常情况下，默认情况下，所有路径都会被索引，但你也可以指定要索引哪些路径集合和子路径。
- en: NoSQL databases are queried either with a subset of SQL or with a JSON-based
    language where queries are JSON objects whose paths represent the properties to
    query, and whose values represent the query constraints that have been applied
    to them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库可以通过SQL的子集或基于JSON的语言进行查询，其中查询是JSON对象，其路径表示要查询的属性，其值表示已应用于它们的查询约束。
- en: The possibility of nesting children objects inside documents can be simulated
    in relational databases with the help of one-to-many relationships. However, with
    relational databases, we are forced to redefine the exact structure of all the
    related tables, while NoSQL collections don't impose any predefined structure
    on the objects they contain. The only constraint is that each document must provide
    a unique value for the primary key property. Therefore, NoSQL databases are the
    only option when the structure of our objects is extremely variable. However,
    often they are chosen for the way they scale-out read and write operations and,
    more generally, for their performance advantages in distributed environments.
    Their performance features will be discussed in the next section, which compares
    them to relational databases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，可以通过一对多关系使用嵌套子对象的可能性。然而，在使用关系数据库时，我们被迫重新定义所有相关表的精确结构，而NoSQL集合不对它们包含的对象施加任何预定义的结构。唯一的约束是每个文档必须为主键属性提供一个唯一的值。因此，当我们的对象结构极其多变时，NoSQL数据库是唯一的选择。然而，它们通常被选择用于扩展读/写操作的方式，以及更普遍的，在分布式环境中的性能优势。它们的功能将在下一节中讨论，该节将它们与关系数据库进行比较。
- en: The graph data model is an extreme case of a completely unstructured document.
    The whole database is a graph where queries can add, change, and delete graph
    documents.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据模型是完全无结构文档的极端情况。整个数据库是一个图，查询可以在其中添加、更改和删除图文档。
- en: 'In this case, we have two kinds of document: nodes and relations. While relationships
    have a well-defined structure (the primary key of the nodes connected by the relationship,
    plus the relationship''s name), nodes have no structure at all since properties
    and their values are added together during node update operations. Graph data
    models were conceived to represent the features of people and the objects they
    manipulate (media, posts, and so on), along with their relationships in *social
    applications*. The Gremlin language was conceived specifically to query graph
    data models. We won''t discuss this in this chapter, but references are available
    in the *Further reading* section.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两种类型的文档：节点和关系。虽然关系有一个定义良好的结构（通过关系连接的节点的主键，加上关系名称），但节点没有任何结构，因为属性及其值是在节点更新操作中一起添加的。图数据模型是为了表示人们及其操作的对象（媒体、帖子等）的特征以及他们在*社交应用*中的关系而设计的。Gremlin语言是为了查询图数据模型而专门设计的。我们不会在本章中讨论这个问题，但在*进一步阅读*部分有相关参考资料。
- en: NoSQL databases will be analyzed in detail in the remaining sections of this
    chapter, which are dedicated to describing Azure Cosmos DB and comparing it with
    relational databases.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余的部分，我们将详细分析NoSQL数据库，这些部分专门用于描述Azure Cosmos DB并将其与关系数据库进行比较。
- en: Redis
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is a distributed concurrent in-memory storage based on key-value pairs
    and supports distributed queuing. It can be used as permanent in-memory storage
    and as a web application cache for database data. Alternatively, it can render
    pages whose content doesn't change very often.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一种基于键值对的分布式并发内存存储，支持分布式队列。它可以作为永久性内存存储，也可以作为数据库数据的Web应用程序缓存。或者，它可以渲染内容变化不大的页面。
- en: Redis can also be used to store a web application's user session data. In fact,
    ASP.NET MVC, Pages, and WebForms support session data to overcome the fact that
    the HTTP protocol is stateless. More specifically, user data that's kept between
    page changes is maintained in server-side stores such as Redis and indexed by
    a session key stored in cookies.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Redis还可以用于存储Web应用程序的用户会话数据。实际上，ASP.NET MVC、Pages和WebForms支持会话数据以克服HTTP协议无状态的事实。更具体地说，用户数据在页面变化之间保持不变，并存储在Redis等服务器端存储中，并通过存储在cookie中的会话键进行索引。
- en: Interaction with the Redis server in the cloud is typically based on a REST
    interface; that is, each Redis resource is accessed via HTTP GET at a URI and
    commands are passed in the query string, while answers are returned in JSON format.
    However, clients that offer an easy-to-use interface are available in all popular
    languages. The client for .NET and .NET Core is available through the `StackExchange.Redis` NuGet
    package. The basic operations of the `StackExchange.Redis` client have been documented
    at [https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics),
    while the full documentation can be found at [https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与云中的Redis服务器交互通常基于REST接口；也就是说，每个Redis资源通过HTTP GET在URI上访问，命令通过查询字符串传递，而答案以JSON格式返回。然而，所有流行的语言中都有提供易于使用的接口的客户端。.NET和.NET
    Core的客户端可以通过`StackExchange.Redis` NuGet包获得。`StackExchange.Redis`客户端的基本操作已在[https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics)中记录，而完整文档可以在[https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis)找到。
- en: 'The user interface for defining a Redis server on Azure is quite simple:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure上定义Redis服务器的用户界面相当简单：
- en: '![](img/df820d64-6224-4523-94ef-2c30f6a9e50d.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df820d64-6224-4523-94ef-2c30f6a9e50d.png)'
- en: The Pricing tier dropdown allows us to select one of the available memory/replication
    options. A quick-start guide that explains how to use Azure Redis credentials
    and the URI with the `StackExchange.Redis` .NET Core client can be found at [https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 价格层级下拉菜单允许我们选择可用的内存/复制选项之一。一个快速入门指南，解释如何使用Azure Redis凭据和`StackExchange.Redis`
    .NET Core客户端的URI，可以在[https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart)找到。
- en: Disk memory
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磁盘内存
- en: 'All clouds offer scalable and redundant general-purpose disk memory that you
    can use as virtual disks in virtual machines and/or as external file storage.
    Azure *storage account* disk space can also be structured in Tables and Queues.
    However, these two storage options are only supported for backward compatibility
    since Azure NoSQL databases are a better option than tables and Azure Redis is
    a better option than Azure storage queues:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有云都提供可扩展和冗余的通用磁盘内存，您可以用作虚拟机中的虚拟磁盘或作为外部文件存储。Azure *存储帐户* 磁盘空间也可以在表和队列中进行结构化。然而，这两个存储选项仅支持向后兼容，因为Azure
    NoSQL数据库比表更好，Azure Redis比Azure存储队列更好：
- en: '![](img/67b90062-5d45-4cec-8625-9fa827a64189.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67b90062-5d45-4cec-8625-9fa827a64189.png)'
- en: In the rest of this chapter, we will focus on NoSQL databases and how they differ from
    relational databases. Next, we will look at how to choose one over the other.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将重点关注NoSQL数据库以及它们与关系数据库的不同之处。接下来，我们将探讨如何在这两者之间进行选择。
- en: Choosing between structured or NoSQL storage
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在结构化存储或NoSQL存储之间进行选择
- en: In the previous section, we stated that NoSQL databases should be preferred
    when data has almost no predefined structure. Actually, unstructured data can
    be represented in relational databases since variable properties of a tuple, `t`,
    can be placed in a connected table containing the property name, property value,
    and the external key of `t`. However, the problem is performance. In fact, property
    values that belong to a single object would be spread all over the available memory
    space. In a small database, *all over the available memory space* means far away
    but on the same disk; in a bigger database, this means far away but in different
    disk units; in a distributed cloud environment, this means far away but in different –
    and possibly geographically distributed – servers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到当数据几乎没有任何预定义结构时，应该优先考虑NoSQL数据库。实际上，非结构化数据可以在关系数据库中表示，因为元组`t`的可变属性可以放置在一个包含属性名称、属性值和`t`的外部键的连接表中。然而，问题是性能。事实上，属于单个对象的属性值会散布在可用的内存空间中。在一个小型数据库中，“散布在可用的内存空间中”意味着距离较远但位于同一磁盘上；在一个大型数据库中，这意味着距离较远但位于不同的磁盘单元中；在分布式云环境中，这意味着距离较远，可能位于不同的——甚至地理上分布的——服务器上。
- en: On the other hand, NoSQL databases not only keep variable attributes close to
    their owners, but they also keep some related objects close since they allow related
    objects to be nested inside properties and collections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，NoSQL数据库不仅将可变属性与其所有者保持接近，而且由于它们允许相关对象嵌套在属性和集合中，它们还将一些相关对象保持接近。
- en: Therefore, we can conclude that relational databases perform well when tables
    that are usually accessed together can be stored close in memory. NoSQL databases,
    on the other hand, automatically ensure that related data is kept close since
    each entry keeps most of the data it is related to inside it as nested objects.
    Therefore, NoSQL databases perform better when they are distributed to a different
    memory and also to different geographically distributed servers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，当通常一起访问的表可以存储在内存附近时，关系数据库表现良好。另一方面，NoSQL数据库自动确保相关数据保持接近，因为每个条目都将其相关的大部分数据作为嵌套对象包含在内。因此，当NoSQL数据库分布到不同的内存以及不同的地理上分布的服务器上时，它们的表现更好。
- en: Unfortunately, the only way to scale out storage write operations is to split
    collection entries across several servers according to the values of *shard keys*.
    For instance, we can place all the records containing usernames that start with
    A in a server, the records containing usernames that start with B on another server,
    and so on. This way, write operations for usernames with different start letters
    may be executed in parallel, ensuring that the write throughput increases linearly
    with the number of servers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，扩展存储写操作的唯一方法是将集合条目根据*分片键*的值分散到几个服务器上。例如，我们可以将所有以A开头的用户名记录放在一个服务器上，以B开头的记录放在另一个服务器上，依此类推。这样，不同起始字母的用户名的写操作可以并行执行，确保写吞吐量随着服务器数量的线性增长。
- en: However, if a *shard* collection is related to several other collections, there
    is no guarantee that related records will be placed on the same server. Also,
    putting different collections on different servers without using collection sharding
    increases write throughput linearly until we reach the limit of a single collection
    per server, but it doesn't solve the issue of being forced to perform several
    operations on different servers to retrieve or update data that's usually processed
    together.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个*分片*集合与几个其他集合相关联，不能保证相关记录会被放置在同一个服务器上。此外，在不使用集合分片的情况下，将不同的集合放在不同的服务器上可以线性地增加写入吞吐量，直到达到每个服务器单个集合的极限，但这并不能解决在检索或更新通常一起处理的数据时被迫在多个服务器上执行多个操作的问题。
- en: This issue becomes catastrophic for performance if access to related distributed
    objects must be transactional and/or must ensure structural constraints (such
    as external key constraints) aren't violated. In this case, all related objects
    must be blocked during the transaction, preventing other requests from accessing
    them during the whole lifetime of a time-consuming distributed operation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须以事务性方式访问相关分布式对象，并且必须确保结构约束（如外部键约束）不被违反，这个问题将对性能造成灾难性的影响。在这种情况下，所有相关对象必须在事务期间被阻塞，防止其他请求在整个耗时的分布式操作期间访问它们。
- en: NoSQL databases don't suffer from this problem and perform better with sharding
    and consequently with write-scaled output. This is because they don't distribute
    related data to different storage units and instead store them as nested objects
    of the same database entry.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库不受此问题的影响，并且通过分片以及随之而来的写入扩展输出表现更好。这是因为它们不会将相关数据分布到不同的存储单元，而是将它们存储为同一数据库条目的嵌套对象。
- en: In NoSQL database design, we always try to put all related objects that are
    likely to be processed together into a single entry. Related objects that are
    accessed less frequently are placed in different entries. Since external key constraints
    aren't enforced automatically and NoSQL transactions are very flexible, the developer
    can choose the best compromise between performance and coherence.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL数据库设计中，我们总是试图将所有可能一起处理的相关对象放入一个单独的条目中。访问频率较低的相关对象被放置在不同的条目中。由于外部键约束不是自动强制执行的，并且NoSQL事务非常灵活，开发者可以在性能和一致性之间选择最佳折衷方案。
- en: It is worth mentioning that there are situations where relational databases
    perform well with sharding. A typical instance is a multi-tenant application.
    In a multi-tenant application, all entries collections can be partitioned into
    non-overlapping sets called **tenants**. Only entries belonging to the same tenant
    can refer to each other, so if all the collections are sharded in the same way
    according to their object tenants, all related records end up in the same shard,
    that is, in the same server, and can be navigated efficiently.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在某些情况下，关系数据库在分片方面表现良好。一个典型的例子是多租户应用程序。在多租户应用程序中，所有条目集合可以被划分为不重叠的集合，称为**租户**。只有属于同一租户的条目可以相互引用，因此如果所有集合都根据它们的对象租户以相同的方式分片，所有相关记录最终都会落在同一个分片上，即同一个服务器上，并且可以有效地进行导航。
- en: Multi-tenant applications aren't rare in the cloud since all applications that
    offer the same services to several different users are often implemented as multi-tenant
    applications, where each tenant corresponds to a user subscription. Accordingly,
    relational databases are conceived to work in the cloud, such as Azure SQL Server,
    and usually offer sharding options for multi-tenant applications. Typically, sharding
    isn't a cloud service and must be defined with database engine commands. Here,
    we won't describe how to define shards with Azure SQL Server, but the *Further
    reading* section contains a link to the official Microsoft documentation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中，多租户应用程序并不罕见，因为向几个不同用户提供相同服务的所有应用程序通常都作为多租户应用程序实现，其中每个租户对应一个用户订阅。因此，关系数据库被设计在云中工作，例如Azure
    SQL Server，并且通常为多租户应用程序提供分片选项。通常，分片不是云服务，必须使用数据库引擎命令定义。在这里，我们不会描述如何使用Azure SQL
    Server定义分片，但*进一步阅读*部分包含了一个指向官方Microsoft文档的链接。
- en: In conclusion, relational databases offer a pure, logical view of data that's
    independent of the way they are actually stored, and use a declarative language
    to query and update them. This simplifies development and system maintenance,
    but it may cause performance issues in a distributed environment that requires
    write scale-out. In NoSQL databases, you must handle more details about how to
    store data, as well as some procedural details for all the update and query operations,
    manually, but this allows you to optimize performance in distributed environments
    that require both read and write scale-out.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，关系数据库提供了独立于实际存储方式的数据的纯粹逻辑视图，并使用声明性语言来查询和更新它们。这简化了开发和系统维护，但在需要写入扩展的分布式环境中可能会引起性能问题。在NoSQL数据库中，您必须手动处理更多关于如何存储数据的细节，以及所有更新和查询操作的一些过程性细节，但这也允许您在需要读取和写入扩展的分布式环境中优化性能。
- en: In the next section, we will look at Azure Cosmos DB, the main Azure NoSQL offering.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Azure Cosmos DB，这是Azure的主要NoSQL服务。
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Cosmos DB – 管理跨大陆数据库的机会
- en: Azure Cosmos DB is Azure's main NoSQL offering. Azure Cosmos DB has its own
    interface that is a subset of SQL, but it can be configured with a MongoDB interface.
    It can be also configured as a graph data model that can be queried with Gremlin. Cosmos
    DB allows replication for fault tolerance and read scale-out, and replicas can
    be distributed geographically to optimize communication performance. Moreover,
    you can specify which data center all the replicas are placed in. The user also
    has the option to write-enable all the replicas so that writes are immediately
    available in the geographical area where they are done. Write scale-up is achieved
    with sharding, which the user can configure by defining which properties to use
    as shard keys.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB是Azure的主要NoSQL服务。Azure Cosmos DB拥有自己的接口，它是SQL的一个子集，但可以用MongoDB接口进行配置。它也可以配置为图数据模型，可以用Gremlin查询。Cosmos
    DB允许进行复制以实现容错和读取扩展，副本可以地理分布以优化通信性能。此外，您可以指定所有副本放置在哪个数据中心。用户还可以选择启用所有副本的写入功能，以便在写入的地理区域立即可用。通过分片实现写入扩展，用户可以通过定义哪些属性用作分片键来配置它。
- en: 'You can define a Cosmos DB account by typing Cosmos DB into the Azure portal
    search bar and clicking Add. The following page will appear:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Azure门户搜索栏中键入Cosmos DB并点击添加来定义一个Cosmos DB账户。以下页面将出现：
- en: '![](img/83d9ca9f-5a23-4509-8a8a-5487e31c2409.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83d9ca9f-5a23-4509-8a8a-5487e31c2409.png)'
- en: The account name you choose is used in the resource URI as `{account name}.documents.azure.com`.
    The API dropdown lets you choose the kind of interface you prefer (SQL, MongoDB,
    or Gremlin). Then, you can decide which data center the main database will be
    placed in and whether you want to enable geographically distributed replication.
    Once you've enabled geographically distributed replication, you can choose the
    number of replicas you want to use and where to place them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的账户名称在资源URI中用作`{账户名称}.documents.azure.com`。API下拉菜单允许您选择您喜欢的接口类型（SQL、MongoDB或Gremlin）。然后，您可以决定主数据库将放置在哪个数据中心，以及您是否希望启用地理分布复制。一旦启用了地理分布复制，您可以选择您想要使用的副本数量以及它们放置的位置。
- en: Finally, the Multi-region Writes toggle lets you enable writes on geographically
    distributed replicas. If you don't do this, all write operations will be routed
    to the main data center.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，多区域写入切换功能允许您在地理分布的副本上启用写入。如果您不这样做，所有写入操作都将路由到主数据中心。
- en: '**Going to the resource**: Once you''ve created your account, select Data Explorer
    to create your databases and collections inside of them:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**访问资源**：一旦您创建了账户，选择数据探索器以在内部创建数据库和集合：'
- en: '![](img/3893d21f-a74e-491d-9845-4563487b5afb.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3893d21f-a74e-491d-9845-4563487b5afb.png)'
- en: '**Creating a collection**: Since databases just have a name and no configuration,
    you can directly add a collection and then the database where you wish to place
    it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建集合**：由于数据库只有名称而没有配置，您可以直接添加集合，然后选择您希望放置它的数据库：'
- en: '![](img/6e63a071-b4a1-48b4-80b2-db48df1aff90.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e63a071-b4a1-48b4-80b2-db48df1aff90.png)'
- en: Here, you can decide on database and collection names and the property to use
    for sharding (partition key). Since NoSQL entries are object trees, property names
    are specified as paths. You can also add properties whose values are required
    to be unique. However, uniqueness IDs are checked inside each shard, so this option
    is only useful in certain situations, such as multi-tenant applications (where
    each tenant is included in a single shard). The fees depend on the collection
    throughput that you choose.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以决定数据库和集合名称以及用于分片（分区键）的属性。由于NoSQL条目是对象树，属性名称指定为路径。您还可以添加值必须唯一的属性。然而，唯一性ID是在每个分片中检查的，因此此选项仅在特定情况下有用，例如多租户应用程序（其中每个租户都包含在单个分片中）。费用取决于您选择的集合吞吐量。
- en: '**Targeting all resource parameters to your needs**: Throughput is expressed
    in Request Unit per second, where Request Unit per second is defined as the throughput
    we have when performing a read of 1 KB per second. Hence, if you check the Provision
    database throughput option, the chosen throughput is shared with the whole database,
    instead of being reserved as a single collection.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将所有资源参数针对您的需求进行定位**：吞吐量以每秒请求单位表示，其中每秒请求单位定义为每秒执行1 KB读取时的吞吐量。因此，如果您检查“配置数据库吞吐量”选项，所选的吞吐量将共享给整个数据库，而不是作为单个集合保留。'
- en: '**Getting connection information**: By selecting the Keys menu, you will see
    all the information you need in order to connect with your Cosmos DB account from
    your application:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取连接信息**：通过选择“键”菜单，您将看到连接到您的应用中的Cosmos DB账户所需的所有信息：'
- en: '![](img/2d565e3b-bb79-41aa-aa36-09615968a7c7.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d565e3b-bb79-41aa-aa36-09615968a7c7.png)'
- en: '**Connection information page**: Here, you will find the account URI and two
    connection keys, which can be used interchangeably to connect with the account:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接信息页面**：在这里，您将找到账户URI和两个连接键，这些键可以互换使用来连接到账户：'
- en: '![](img/503dcd27-b61c-450e-871a-0232bedf3cab.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/503dcd27-b61c-450e-871a-0232bedf3cab.png)'
- en: There are also keys with read-only privileges. Every key can be regenerated
    and each account has two equivalent keys so that this operation can be handled
    efficiently; that is, when a key is changed, the other one is kept. Therefore,
    existing applications can continue using the other key before upgrading to the
    new key.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些具有只读权限的键。每个键都可以重新生成，并且每个账户都有两个等效的键，以便此操作可以高效地处理；也就是说，当一个键更改时，另一个键保持不变。因此，现有的应用程序可以在升级到新键之前继续使用另一个键。
- en: '**Selecting the default consistency level**: By selecting the Default consistency,
    you can choose the default replication consistency that you wish to apply to all
    of your collections:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择默认一致性级别**：通过选择“默认一致性”，您可以选择要应用于所有集合的默认复制一致性：'
- en: '![](img/32f7d541-7f05-4246-962b-6f83293c0d75.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32f7d541-7f05-4246-962b-6f83293c0d75.png)'
- en: This default can be overridden in each collection, either from the Data Explorer
    or programmatically. Consistency problems in read/write operations are a consequence
    of data replication. More specifically, the results of various read operations
    may be incoherent if the read operations are executed on different replicas that
    have received different partial updates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此默认值可以在每个集合中覆盖，无论是从数据资源管理器还是通过编程方式。读写操作中的一致性问题是数据复制的结果。更具体地说，如果读取操作在不同的副本上执行，并且这些副本接收到了不同的部分更新，那么各种读取操作的结果可能是不一致的。
- en: 'The following are the available consistency levels. These have been ordered
    from the weakest to the strongest:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用的可用一致性级别。这些级别已按从最弱到最强排序：
- en: '**Eventual**: After enough time has passed, if no further write operations
    are done, all the reads converge and apply all the writes.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：经过足够的时间后，如果没有进一步的写操作，所有的读取将收敛并应用所有的写操作。'
- en: '**Consistent Prefix**: All the writes are executed in the same order on all
    the replicas. So, if there are `n` write operations, each read is consistent with
    the result of applying the first `m` writes for some `m` less or equal to `n`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致前缀**：所有写操作都在所有副本上以相同的顺序执行。因此，如果有`n`个写操作，每个读取都与应用前`m`个写操作的结果一致，其中`m`小于或等于`n`。'
- en: '**Session**: This is the same as the consistency prefix but also guarantees
    that each writer sees the result of its own writes in all subsequent read operations
    and that subsequent reads of each reader are coherent (either the same database
    or a more updated version of it).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话一致性**：这与一致性前缀相同，但也保证了每个写入者在其所有后续读取操作中都能看到其自己的写入结果，并且每个读者的后续读取都是一致的（要么是相同的数据库，要么是其更新版本）。'
- en: '**Bounded Staleness**: This is associated either with a delay time, `Delta`,
    or with a number of operations, `N`. Each read sees the results of all the write
    operations that were performed before a time `Delta` (or before the last `N` operations).
    That is, its reads converge with the result of all the writes with a maximum time
    delay of `Delta` (or a maximum operations delay of `N`).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限不一致性**：这与延迟时间`Delta`或操作次数`N`相关联。每次读取都会看到在时间`Delta`之前（或最后`N`个操作之前）执行的所有写入操作的结果。也就是说，其读取与所有写入的结果收敛，最大时间延迟为`Delta`（或最大操作延迟为`N`）。'
- en: '**Strong**: This is bounded staleness combined with `Delta = 0`. Here, each
    read reflects the result of all previous write operations.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强一致性**：这是结合了`Delta = 0`的有限不一致性。在这里，每次读取都反映了所有之前的写入操作的结果。'
- en: The strongest consistency can be obtained to the detriment of performance. By
    default, the consistency is set to Session, which is a good compromise between
    coherence and performance. A lower level of consistency is difficult to handle
    in applications and is only usually acceptable if sessions are either read-only
    or write-only.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以获得最强的一致性，但会损害性能。默认情况下，一致性设置为Session，这是在一致性和性能之间的一种良好折衷。在应用程序中处理较低级别的一致性比较困难，并且通常只有在会话是只读或只写的情况下才可接受。
- en: 'If you select the Scale & settings option in the Data Explorer, you can configure
    which paths to index and which kind of indexing to apply to each data type of
    each path. The configuration consists of a JSON object. Let''s analyze its various
    properties:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择数据探索器中的“缩放和设置”选项，你可以配置要索引哪些路径以及将哪种索引应用于每个路径的每个数据类型。配置由一个JSON对象组成。让我们分析其各种属性：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you set `indexingMode` to `none` instead of `consistent`, no index is generated
    and the collection can be used as a key-value dictionary that''s indexed by the
    collection primary key. When `automatic` is set to `true`, all document properties
    are automatically indexed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`indexingMode`设置为`none`而不是`consistent`，则不会生成索引，集合可以用作以集合主键为索引的键值字典。当`automatic`设置为`true`时，所有文档属性都会自动索引：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each entry in the *Included paths* specifies a path pattern such as `/subpath1/subpath2/?`
    (settings apply just to the `/subpath1/subpath2/` property) or `/subpath1/subpath2/*`
    (settings apply to all the paths starting with `/subpath1/subpath2/`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: “包含的路径”中的每个条目指定了一个路径模式，例如`/subpath1/subpath2/?`（设置仅应用于`/subpath1/subpath2/`属性）或`/subpath1/subpath2/*`（设置应用于以`/subpath1/subpath2/`开头的所有路径）。
- en: Patterns contain the `[]` symbol when settings must be applied to child objects
    contained in collection properties; for example, `/subpath1/subpath2/[]/?`, `/subpath1/subpath2/[]/childpath1/?`,
    and so on. Settings specify the index type to apply to each data type (string,
    number, geographic point, and so on). Range indexes are needed for comparison
    operations, while hash indices are more efficient if we need equality comparisons.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置必须应用于集合属性中包含的子对象时，模式包含`[]`符号；例如，`/subpath1/subpath2/[]/?`，`/subpath1/subpath2/[]/childpath1/?`等等。设置指定要应用于每个数据类型（字符串、数字、地理点等）的索引类型。范围索引用于比较操作，而如果需要进行相等比较，则散列索引更有效。
- en: 'It is possible to specify a precision, that is, the maximum number of characters
    or digits to use in all the index keys. `-1` means no limit. `-1` is acceptable
    for strings, while a finite precision should be used for numbers. On the other
    hand, using finite precision with strings may result in unexpected behavior since
    string keys are truncated. In hash indexes, precision may vary from 1 to 8, while
    in range indexes, it may vary from 1 to 100:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定精度，即所有索引键中使用的最大字符数或数字数。`-1`表示无限制。对于字符串，`-1`是可以接受的，而对于数字，应使用有限的精度。另一方面，使用有限的精度与字符串可能会导致意外的行为，因为字符串键会被截断。在散列索引中，精度可能从1到8不等，而在范围索引中，精度可能从1到100不等：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Paths contained in `excludedPaths` aren't indexed at all. Index settings can
    also be specified programmatically.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`excludedPaths`中包含的路径根本不会被索引。索引设置也可以通过编程方式指定。'
- en: 'Here, you have two options to connect to Cosmos DB: use a version of its official
    client for your preferred programming language or use Cosmos DB''s Entity Framework
    Core provider, which at the time of writing this book, is still in preview. In
    the following subsections, we will have a look at both options. Then, we will
    describe how to use Cosmos DB''s Entity Framework Core provider with a practical
    example.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有两种连接到 Cosmos DB 的选项：使用你首选编程语言的官方客户端版本，或者使用 Cosmos DB 的 Entity Framework
    Core 提供器，截至本书编写时，它仍在预览中。在接下来的小节中，我们将探讨这两种选项。然后，我们将通过一个实际示例描述如何使用 Cosmos DB 的 Entity
    Framework Core 提供器。
- en: Cosmos DB client
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cosmos DB 客户端
- en: 'The Cosmos DB client for .NET Core is available through the `Microsoft.Azure.DocumentDB.Core`
    NuGet package. It offers full control of all Cosmos DB features, while the Cosmos
    DB Entity Framework provider is easier to use but hides some Cosmos DB peculiarities.
    Follow these steps to interact with Cosmos DB through the official Cosmos DB client
    for .NET Core:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 的 Cosmos DB 客户端可以通过 `Microsoft.Azure.DocumentDB.Core` NuGet 包获得。它提供了对所有
    Cosmos DB 功能的完全控制，而 Cosmos DB Entity Framework 提供器更容易使用，但隐藏了一些 Cosmos DB 的特性。按照以下步骤通过官方
    Cosmos DB .NET Core 客户端与 Cosmos DB 进行交互：
- en: 'Any operation requires the creation of a client object:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何操作都需要创建一个客户端对象：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don't forget that the client must be disposed of by calling its `Dispose` method
    (or by enclosing the code that references it in a `using` statement) when you
    don't need it anymore.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记，当不再需要客户端时，必须通过调用其 `Dispose` 方法（或通过将引用它的代码封装在 `using` 语句中）来释放客户端。
- en: 'Then, you can get a reference to a database and create it if it doesn''t exist
    with the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下代码获取数据库的引用并创建它（如果它不存在）：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, you can get a reference to a collection or create it if it doesn''t
    exist with the following code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以使用以下代码获取集合的引用或创建它（如果它不存在）：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: During collection creation, you can pass an `option` object, where you can specify
    the consistency level, how to index properties, and all the other collection features.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建集合期间，你可以传递一个 `option` 对象，其中你可以指定一致性级别、如何索引属性以及所有其他集合功能。
- en: Then, you must define the .NET classes that correspond to the structure of the
    JSON document you need to manipulate in your collections. You can also use the `JsonProperty`
    attribute to map class property names to JSON names if they aren't equal.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你必须定义与你在集合中需要操作的 JSON 文档结构相对应的 .NET 类。你也可以使用 `JsonProperty` 属性将类属性名称映射到 JSON
    名称，如果它们不相等的话。
- en: Once you have all the necessary classes, you can use client methods to add,
    update, and write collection entries, as well as the client `CreateDocumentQuery`
    method, which returns an `IQueryable` value that you can query with LINQ.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了所有必要的类，你可以使用客户端方法来添加、更新和写入集合条目，以及客户端 `CreateDocumentQuery` 方法，它返回一个 `IQueryable`
    值，你可以使用 LINQ 来查询。
- en: 'When you read a document, apply some modifications, and then try to upload
    your modified version of the document, someone else may have modified the same
    document. Often, you only need to perform an update if no one else has modified
    the same document. This can be done using the `_etag` property, which Cosmos DB
    automatically attaches to each document. This property value changes after each
    update, so you need to follow these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读取文档，进行一些修改，然后尝试上传你修改后的文档版本时，其他人可能已经修改了相同的文档。通常，只有当没有其他人修改了相同的文档时，你才需要执行更新。这可以通过
    `_etag` 属性来完成，Cosmos DB 会自动将其附加到每个文档上。此属性值在每次更新后都会改变，因此你需要遵循以下步骤：
- en: Map the `_etag` JSON property to a property on your .NET class so that you get
    its value when you read a document.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `_etag` JSON 属性映射到你的 .NET 类的一个属性上，这样在读取文档时你就能得到它的值。
- en: Pass the original value of the `_etag` property as the value of the `AccessCondition`
    property of the `option` object you pass to the `ReplaceDocumentAsync` client
    method.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `_etag` 属性的原始值作为传递给 `ReplaceDocumentAsync` 客户端方法的 `option` 对象中 `AccessCondition`
    属性的值。
- en: If the `_etag` has changed `ReplaceDocumentAsync`, abort the operation and return
    an exception.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `_etag` 发生了变化，则调用 `ReplaceDocumentAsync`，中止操作并返回异常。
- en: There is also the `MvcControlsToolkit.Business.DocumentDB` NuGet package, which
    simplifies and automates all operations that are required by the `Microsoft.Azure.DocumentDB.Core`
    library and overcomes some limitations of Cosmos DB SQL. The *Further reading*
    section contains references to tutorials for `Microsoft.Azure.DocumentDB.Core`
    and `MvcControlsToolkit.Business.DocumentDB`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `MvcControlsToolkit.Business.DocumentDB` NuGet 包，它简化并自动化了 `Microsoft.Azure.DocumentDB.Core`
    库所需的所有操作，并克服了 Cosmos DB SQL 的一些限制。*进一步阅读*部分包含了对 `Microsoft.Azure.DocumentDB.Core`
    和 `MvcControlsToolkit.Business.DocumentDB` 的教程的引用。
- en: Cosmos DB Entity Framework Core provider
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cosmos DB 实体框架核心提供程序
- en: 'The Cosmos DB provider for Entity Framework Core is contained in the `Microsoft.EntityFrameworkCore.Cosmos`
    NuGet package. Once you''ve added this to your project, you can proceed in a similar
    way to when you used the SQL Server provider in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*, but with a few differences.
    Let''s take a look:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Cosmos DB 实体框架核心提供程序包含在 `Microsoft.EntityFrameworkCore.Cosmos` NuGet 包中。一旦将其添加到项目中，你就可以以与在
    [第 6 章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml) 中使用 SQL Server 提供程序时类似的方式进行操作，但在一些方面有所不同。让我们来看看：
- en: 'There are no migrations since Cosmos DB databases have no structure to update.
    Instead, they have a method that ensures that the database, along with all the
    necessary collections, is created:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Cosmos DB 数据库没有结构需要更新，因此没有迁移。相反，它有一个确保数据库以及所有必要的集合被创建的方法：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`DbSet<T>` `DBContext` properties don''t map one-to-one to database collections,
    but several `DbSet<T>` properties can map to the same collection since collections
    can contain objects with different structures. Moreover, by default, all `DbSet<T>`
    properties are mapped to a unique collection since this is the cheapest option,
    but you can override this default by explicitly specifying which collection you
    want to map some entities to by using the following configuration instruction:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DbSet<T>` 和 `DBContext` 属性并不一一对应数据库集合，因为集合可以包含具有不同结构的对象，所以几个 `DbSet<T>` 属性可以映射到同一个集合。此外，默认情况下，所有
    `DbSet<T>` 属性都映射到唯一的集合，因为这是最经济的选项，但你可以通过以下配置指令显式指定要将某些实体映射到哪个集合来覆盖此默认设置：'
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only useful annotation on entity classes is the `Key` attribute, which becomes
    obligatory when the principal keys are is called `Id`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体类上唯一有用的注解是 `Key` 属性，当主键被称作 `Id` 时，该属性变得强制使用。
- en: Principal keys must be strings and can't be auto-incremented to avoid synchronization
    issues in a distributed environment. The uniqueness of primary keys can be ensured
    by generating GUIDs and transforming them into strings.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主键必须是字符串，并且不能自动递增，以避免在分布式环境中的同步问题。可以通过生成 GUID 并将其转换为字符串来确保主键的唯一性。
- en: When defining relationships between entities, you can specify that an entity
    or a collection of entities is owned by another entity, in which case it is stored
    together with the father entity.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当定义实体之间的关系时，你可以指定一个实体或实体集合属于另一个实体，在这种情况下，它将与父实体一起存储。
- en: We will look at the usage of Cosmos DB's Entity Framework provider in the next
    section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 Cosmos DB 实体框架提供程序的使用。
- en: Use case – storing data
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 存储数据
- en: 'Now that we''ve learned how to use NoSQL, we have to decide whether NoSQL databases
    are adequate for our WWTravelClub application. We need to store the following
    families of data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用 NoSQL，我们必须决定 NoSQL 数据库是否适合我们的 WWTravelClub 应用程序。我们需要存储以下数据系列：
- en: '**Information about available destinations and packages**: Relevant operations
    for this data are reads since packages and destinations don''t change very often.
    However, they must be accessed as fast as possible from all over the World in
    order to ensure a pleasant user experience when users browse the available options.
    Therefore, a distributed relational database with geographically distributed replicas
    is possible, but not necessary, since packages can be stored inside their destinations
    in a cheaper NoSQL database.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于可用目的地和套餐的信息**：对此数据的相关操作主要是读取，因为套餐和目的地不经常改变。然而，它们必须尽可能快地从世界各地访问，以确保用户浏览可用选项时的良好用户体验。因此，一个具有地理分布副本的分布式关系数据库是可能的，但不是必要的，因为套餐可以存储在其目的地内的更便宜的
    NoSQL 数据库中。'
- en: '**Destination reviews**: In this case, distributed write operations have a
    non-negligible impact. Moreover, most writes are additions, since reviews aren''t
    usually updated. Additions benefit a lot from sharding and don''t cause consistency
    issues like updates do. Accordingly, the best option for this data is a NoSQL
    collection.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地评论**：在这种情况下，分布式写入操作有不可忽视的影响。此外，大多数写入都是添加，因为评论通常不会被更新。添加操作从分片中获得很大好处，并且不会像更新那样引起一致性问题。因此，此数据的最佳选择是一个
    NoSQL 集合。'
- en: '**Reservations**: In this case, consistency errors aren''t acceptable because
    they may cause overbooking. Reads and writes have a comparable impact, but we
    need reliable transactions and good consistency checks. Luckily, data can be organized
    in a multi-tenant database where tenants are destinations since reservation information
    belonging to different destinations is completely unrelated. Accordingly, we may
    use sharded SQL Azure database instances.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预留**：在这种情况下，一致性错误是不可接受的，因为它们可能导致超订。读取和写入有相似的影响，但我们需要可靠的交易和良好的一致性检查。幸运的是，数据可以组织在一个多租户数据库中，其中租户是目的地，因为不同目的地的预订信息完全无关。因此，我们可能使用分片
    SQL Azure 数据库实例。'
- en: In conclusion, the best option for data in the first and second bullet points
    is Cosmos DB, while the best option for the third point is Azure SQL Server. Actual
    applications may require a more detailed analysis of all data operations and their
    frequencies. In some cases, it is worth implementing prototypes for various possible
    options and executing performance tests with typical workloads on all of them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，对于第一和第二点中的数据，最佳选择是 Cosmos DB，而对于第三点，最佳选择是 Azure SQL Server。实际应用程序可能需要对所有数据操作及其频率进行更详细的分析。在某些情况下，为各种可能的选项实现原型并在所有这些上执行典型工作负载的性能测试是值得的。
- en: In the remainder of this section, we will migrate the destinations/packages
    data layer we looked at in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*, to Cosmos DB.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将把我们在[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)，“使用C#与数据交互
    - Entity Framework Core”中查看的 destinations/packages 数据层迁移到 Cosmos DB。
- en: Implementing the destinations/packages database with Cosmos DB
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cosmos DB 实现目的地/包数据库
- en: 'Let''s move on to the database example we built in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting
    with Data in C# – Entity Framework Core*, to Cosmos DB by following these steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们在[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)，“使用C#与数据交互 – Entity
    Framework Core”中构建的数据库示例，按照以下步骤将其迁移到 Cosmos DB：
- en: First of all, we need to make a copy of the WWTravelClubDB project and make
    `WWTravelClubDBCosmo` the new root folder.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要复制 WWTravelClubDB 项目，并将 `WWTravelClubDBCosmo` 设置为新根文件夹。
- en: Open the project and delete the migrations folder since migrations aren't required
    anymore.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目并删除迁移文件夹，因为不再需要迁移了。
- en: We need to replace the SQL Server Entity Framework provider with the Cosmos
    DB provider. To do this, go to Manage NuGet Packages and uninstall the `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet package. Then, install the `Microsoft.EntityFrameworkCore.Cosmos` NuGet
    package.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要替换 SQL Server Entity Framework 提供程序与 Cosmos DB 提供程序。为此，转到管理 NuGet 包并卸载 `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet 包。然后，安装 `Microsoft.EntityFrameworkCore.Cosmos` NuGet 包。
- en: 'Then, do the following on the `Destination` and `Package` entities:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对 `Destination` 和 `Package` 实体执行以下操作：
- en: Remove all data annotations.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除所有数据注释。
- en: Add the `[Key]` attribute to their `Id` properties since this is obligatory
    for Cosmos DB providers.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `[Key]` 属性添加到它们的 `Id` 属性，因为这对于 Cosmos DB 提供程序是强制性的。
- en: Transform the type of the `Id` properties of both `Package` and `Destination`,
    and the `PackagesListDTO` classes from `int` to `string`. We need to turn into
    `string` also the `DestinationId` external references in the `Package`, and in
    the `PackagesListDTO` classes.  In fact, the best option for keys in distributed
    databases is a string generated from a GUID, because it is hard to maintain an
    identity counter when table data is distributed among several servers.
  id: totrans-142
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Package` 和 `Destination` 的 `Id` 属性类型以及 `PackagesListDTO` 类从 `int` 转换为 `string`。我们还需要将
    `Package` 中的 `DestinationId` 外部引用和在 `PackagesListDTO` 类中的 `DestinationId` 转换为
    `string`。实际上，对于分布式数据库中的键，最佳选择是从 GUID 生成的字符串，因为当表数据分布在多个服务器之间时，很难维护一个身份计数器。
- en: 'In the `MainDBContext` file, we need to specify that packages related to a
    destination must be stored inside the destination document itself. This can be
    achieved by replacing the Destination-Package relation configuration in the `OnModelCreatingmethod`
    method with the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainDBContext` 文件中，我们需要指定与目的地相关的包必须存储在目的地文档本身中。这可以通过在 `OnModelCreating` 方法中将
    Destination-Package 关系配置替换为以下代码来实现：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we must replace `HasMany` with `OwnsMany`. There is no equivalent to `WithOne`
    since once an entity is owned, it must have just one owner, and the fact that
    the `MyDestination` property contains a pointer to the father entity is evident
    from its type. Cosmos DB also allows the use of `HasMany`, but in this case, the
    two entities aren't nested one in the other. There is also an `OwnOne` configuration
    method for nesting single entities inside other entities.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们必须将 `HasMany` 替换为 `OwnsMany`。没有 `WithOne` 的等效项，因为一旦实体被拥有，它必须只有一个所有者，而
    `MyDestination` 属性包含对父实体的指针的事实可以从其类型中看出。Cosmos DB 也允许使用 `HasMany`，但在这种情况下，两个实体并不是嵌套在一另一个中。还有用于在实体内部嵌套单个实体的
    `OwnOne` 配置方法。
- en: Actually, both `OwnsMany` and `OwnsOne` are available for relational databases,
    but in this case, the difference between `HasMany` and `HasOne` is that children
    entities are automatically included in all queries that return their father entities,
    with no need to specify an `Include` LINQ clause. However, child entities are
    still stored in separate tables.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，`OwnsMany` 和 `OwnsOne` 都适用于关系数据库，但在这个案例中，`HasMany` 和 `HasOne` 之间的区别在于，子实体会自动包含在返回其父实体的所有查询中，无需指定
    `Include` LINQ 子句。然而，子实体仍然存储在单独的表中。
- en: '`LibraryDesignTimeDbContextFactory` must be modified to use Cosmos DB connection
    data, as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LibraryDesignTimeDbContextFactory` 必须修改为使用 Cosmos DB 连接数据，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, in our test console, we must explicitly create all entity principal
    keys using GUIDS:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的测试控制台中，我们必须明确使用 GUIDS 创建所有实体主键：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we call `context.Database.EnsureCreated()` instead of applying migrations
    since we only need to create the database. Once the database and collections have
    been created, we can fine-tune their settings from the Azure Portal. Hopefully,
    future versions of Cosmos DB Entity Framework Core provider will allow us to specify
    all collection options.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `context.Database.EnsureCreated()` 而不是应用迁移，因为我们只需要创建数据库。一旦数据库和集合被创建，我们就可以从
    Azure Portal 调整它们的设置。希望未来版本的 Cosmos DB Entity Framework Core 提供程序将允许我们指定所有集合选项。
- en: 'Finally, the final query that starts with `context.Packages.Where...` must
    be modified since queries can''t start from entities that are nested in other
    documents (in our case, `Package` entities). Therefore, we must start our query
    from the unique root `DbSet<T>` property we have in our `DBContext`, that is,
    `Destinations`. We can move from listing the external collection to listing all
    the internal collections with the help of the `SelectMany` method, which performs
    a logical merge of all nested `Packages` collections. However, since `CosmosDB`
    SQL doesn''t support `SelectMany`, we must force `SelectMany` to be simulated
    on the client with `AsIenumerable()`, as shown in the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以 `context.Packages.Where...` 开头的最终查询必须进行修改，因为查询不能从嵌套在其他文档中的实体开始（在我们的情况下，`Package`
    实体）。因此，我们必须从我们的 `DBContext` 中的唯一根 `DbSet<T>` 属性开始我们的查询，即 `Destinations`。我们可以借助
    `SelectMany` 方法从列出外部集合切换到列出所有内部集合，该方法执行所有嵌套 `Packages` 集合的逻辑合并。然而，由于 `CosmosDB`
    SQL 不支持 `SelectMany`，我们必须使用 `AsIenumerable()` 在客户端强制模拟 `SelectMany`，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The remainder of the query remains unchanged. If you run the project now, you
    should see the same outputs that were received in the case of SQL Server (with
    the exception of the primary key values).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询的其余部分保持不变。如果您现在运行项目，应该看到与 SQL Server 的情况相同的输出（除了主键值之外）。
- en: 'After executing the program, go to your Cosmos DB account. You should see something
    like the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序后，前往您的 Cosmos DB 账户。您应该看到以下类似的内容：
- en: '![](img/32c20c41-6c2d-466e-9048-f45ae8d0d406.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32c20c41-6c2d-466e-9048-f45ae8d0d406.png)'
- en: The packages have been nested inside their destinations as required and Entity
    Framework Core creates a unique collection that has the same name as the `DBContext`
    class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 包已经按照要求嵌套在其目的地内部，Entity Framework Core 创建了一个与 `DBContext` 类同名的唯一集合。
- en: 'If you would like to continue experimenting with Cosmos DB development without
    wasting all your free Azure Portal credit, you can install the Cosmos DB emulator
    available at this link: [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在不用完所有免费 Azure Portal 信用额度的情况下继续实验 Cosmos DB 开发，您可以安装此链接提供的 Cosmos DB 模拟器：[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the main storage options available in Azure and
    learned when to use them. Then, we compared relational and NoSQL databases. We
    pointed out that relational databases offer automatic consistency checking and
    transaction isolation, but NoSQL databases are cheaper and offer better performance,
    especially when distributed writes form a high percentage of the average workload.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Azure 中可用的主要存储选项，并学习了何时使用它们。然后，我们比较了关系型数据库和 NoSQL 数据库。我们指出，关系型数据库提供自动一致性检查和事务隔离，但
    NoSQL 数据库更便宜，并提供更好的性能，尤其是在平均负载中分布式写入占很大比例时。
- en: Then, we described Azure's main NoSQL option, Cosmos DB, and explained how to
    configure it and how to connect with a client.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了 Azure 的主要 NoSQL 选项 Cosmos DB，并解释了如何配置它以及如何与客户端连接。
- en: Finally, we learned how to interact with Cosmos DB with Entity Framework Core and looked
    at a practical example based on the WWTravelClubDB use case. Here, we learned
    how to decide between relational and NoSQL databases for all families of data
    involved in an application. This way, you can choose the kind of data storage
    that ensures the best compromise between data coherence, speed, and parallel access
    to data in each of your applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用 Entity Framework Core 与 Cosmos DB 交互，并查看了一个基于 WWTravelClubDB 用例的实用示例。在这里，我们学习了如何为应用程序中涉及的所有数据家族决定使用关系型数据库还是
    NoSQL 数据库。这样，您可以选择确保数据一致性、速度和每个应用程序中数据并行访问之间最佳折衷的数据存储类型。
- en: In the next chapter, we will learn all about Serverless and Azure Functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习有关 Serverless 和 Azure Functions 的所有内容。
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is Redis a valid alternative to relational databases?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis 是否是关系型数据库的有效替代品？
- en: Are NoSQL databases a valid alternative to relational databases?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NoSQL 数据库是否是关系型数据库的有效替代品？
- en: What operation is more difficult to scale out in relational databases?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关系型数据库中，哪种操作更难进行扩展？
- en: What is the main weakness of NoSQL databases? What is their main advantage?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NoSQL 数据库的主要弱点是什么？它们的主要优势是什么？
- en: Can you list all Cosmos DB consistency levels?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否列出所有 Cosmos DB 的一致性级别？
- en: Can we use auto-increment integer keys with Cosmos DB?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用自增整数键与 Cosmos DB 一起使用吗？
- en: Which Entity Framework configuration method is used to store an entity inside
    its related father document?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种 Entity Framework 配置方法用于在相关父文档中存储实体？
- en: Can nested collections be searched efficiently with Cosmos DB?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cosmos DB 是否可以有效地搜索嵌套集合？
- en: Further reading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: In this chapter, we didn't talk about how to define sharding with SQL Azure.
    Here is the link to the official documentation if you want to find out more: [https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们没有讨论如何使用 SQL Azure 定义分片。如果您想了解更多信息，请参阅官方文档链接：[https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction)。
- en: Cosmos DB was described in detail in this chapter, but further details can be
    found in the official documentation: [https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章详细介绍了 Cosmos DB，但更详细的信息可以在官方文档中找到：[https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/)。
- en: The following is a reference to the Gremlin language, which is supported by
    Cosmos DB: [http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对 Cosmos DB 支持的 Gremlin 语言的参考：[http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps)。
- en: 'The following is a general description of the Cosmos DB Graph Data Model: [https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对 Cosmos DB 图数据模型的通用描述：[https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction)。
- en: Details on how to use Cosmos DB's official .NET client can be found at [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started).
    A good introduction to the `MvcControlsToolkit.Business.DocumentDB` NuGet package
    we mentioned in this chapter is the *Fast Azure Cosmos DB Development with the
    DocumentDB Package* article contained in Issue 34 of DNCMagazine. This can be
    downloaded from [http://www.dotnetcurry.net/s/dnc-mag-34th-single](http://www.dotnetcurry.net/s/dnc-mag-34th-single).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Cosmos DB 的官方 .NET 客户端的详细信息可以在 [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started)
    找到。关于本章中提到的 `MvcControlsToolkit.Business.DocumentDB` NuGet 包的良好介绍是 DNCMagazine
    第 34 期中的 *Fast Azure Cosmos DB Development with the DocumentDB Package* 文章。这可以从
    [http://www.dotnetcurry.net/s/dnc-mag-34th-single](http://www.dotnetcurry.net/s/dnc-mag-34th-single)
    下载。
