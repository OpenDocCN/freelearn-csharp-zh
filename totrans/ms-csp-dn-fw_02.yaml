- en: Chapter 2. Core Concepts of C# and .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 C# 和 .NET 的核心概念
- en: This chapter covers the core concepts of C# and .NET, starting from the initial
    version and principal motivations behind its creation, and covering also the new
    aspects of the language, that appeared in versions 2.0 and 3.0.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 C# 和 .NET 的核心概念，从其初始版本和创建背后的主要动机开始，并涵盖了语言在 2.0 和 3.0 版本中出现的新特性。
- en: We'll illustrate all the main concepts with small code snippets, short enough
    to facilitate its understanding and easy reproduction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一些简短的小代码片段来展示所有主要概念，这些代码足够短，便于理解并易于复制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: C# and its role in the Microsoft Development ecosystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 及其在微软开发生态系统中的作用
- en: Difference between strongly typed and weakly typed languages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型语言和弱类型语言之间的区别
- en: The evolution in versions 2.0 and 3.0
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.0 和 3.0 版本的演变
- en: Generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Lambda expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: LINQ
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ
- en: Extension methods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法
- en: C# – what's different in the language?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 语言的不同之处
- en: 'I had the chance to chat with Hejlsberg a couple of times about the C # language
    and what the initial purposes and requirements imposed in its creation were and
    which other languages inspired him or contributed to his ideas.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我有机会与 Hejlsberg 几次讨论 C# 语言及其创建时的初始目的和要求，以及哪些其他语言启发了他或对他的想法有所贡献。
- en: The first time we talked, in Tech-Ed 2001 (at Barcelona, Spain), I asked him
    about the principles of *his* language and what makes it different from others.
    He first said that it was not only him who created the language, but also a group
    of people, especially *Scott Wiltamuth*, *Peter Golde*, *Peter Sollich*, and *Eric
    Gunnerson*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次谈话是在 2001 年的 Tech-Ed 上（在西班牙巴塞罗那），我问他关于他自己的语言原则以及它与其他语言的不同之处。他首先说，创造这种语言不仅仅是他的功劳，还有一群人，特别是
    *Scott Wiltamuth*、*Peter Golde*、*Peter Sollich* 和 *Eric Gunnerson*。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One of the first books ever published on the subject was, *A Programmer's Introduction
    to C#*, *Gunnerson's.E.*, APress, 2000).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于该主题最早出版的书籍之一是，《程序员 C# 入门》，作者为 *Gunnerson's.E.*，APress，2000 年）。
- en: 'About the principles, he mentioned this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于原则，他提到了以下几点：
- en: '"One of the key differences between C# and these other languages, particularly
    Java, is that we tried to stay much closer to C++ in our design. C# borrows most
    of its operators, keywords, and statements directly from C++. But beyond these
    more traditional language issues, one of our key design goals was to make the
    C# language component-oriented, to add to the language itself all of the concepts
    that you need when you write components. Concepts such as properties, methods,
    events, attributes, and documentation are all first-class language constructs."'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “C# 与这些其他语言（尤其是 Java）之间的一个关键区别在于，我们在设计上试图与 C++ 保持更接近。C# 从 C++ 中直接借用了大多数运算符、关键字和语句。但除了这些更传统的语言问题之外，我们的一个关键设计目标是使
    C# 语言面向组件，向语言本身添加你在编写组件时所需的所有概念。例如属性、方法、事件、属性和文档等都是一等语言结构。”
- en: 'He stated also this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 他还提到：
- en: '"When you write code in C#, you write everything in one place. There is no
    need for header files, IDL files (Interface Definition Language), GUIDs and complicated
    interfaces."'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “当你用 C# 编写代码时，你将所有内容都写在一个地方。不需要头文件、IDL 文件（接口定义语言）、GUID 和复杂的接口。”
- en: This means that you can write code that is self-descriptive in this way given
    that you're dealing with a self-contained unit (let's remember the role of the
    manifest, optionally embedded in assemblies). In this mode, you can also extend
    existing technologies in a variety of ways, as we'll see in the examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你处理的是一个自包含的单元（让我们记住清单的作用，它可能嵌入在程序集内），你就可以以这种方式编写自描述的代码。在这种模式下，你还可以以各种方式扩展现有技术，正如我们将在示例中看到的那样。
- en: 'Languages: strongly typed, weakly typed, dynamic, and static'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言：强类型、弱类型、动态和静态
- en: 'The C# language is a strongly typed language: this means that any attempt to
    pass a wrong kind of parameter as an argument, or to assign a value to a variable
    that is not implicitly convertible, will generate a compilation error. This avoids
    many errors that only happen at runtime in other languages.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C# 语言是一种强类型语言：这意味着任何尝试将错误类型的参数作为参数传递，或将值赋给无法隐式转换的变量，都将生成编译错误。这避免了在其他语言中仅在运行时才会发生的许多错误。
- en: 'In addition, by dynamic, we mean those languages whose rules are applied at
    runtime, while static languages apply their rules at compile time. JavaScript
    or PHP are good examples of the former case, and C/C++ of the latter. If we make
    a graphic representation of this situation, we might come up with something like
    what is shown in the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们提到动态时，我们指的是那些在运行时应用其规则的编程语言，而静态语言则在编译时应用其规则。JavaScript 或 PHP 就是前者的好例子，而
    C/C++ 则是后者的例子。如果我们对这个情况做一个图形表示，可能会得到以下图示：
- en: '![Languages: strongly typed, weakly typed, dynamic, and static](img/image00431.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![编程语言：强类型、弱类型、动态和静态](img/image00431.jpeg)'
- en: In the figure, we can see that C# is clearly strongly typed, but it's much more
    dynamic than C++ or Scala, to mention a few. Of course, there are several criteria
    to catalog languages for their typing (weak versus strong) and for their dynamism
    (dynamic versus static).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们可以看到 C# 明显是强类型的，但它比 C++ 或 Scala 等语言要动态得多。当然，有几个标准可以用来对语言进行分类，以确定它们的类型（弱类型与强类型）以及它们的动态性（动态与静态）。
- en: 'Note that this has implications in the IDE as well. Editors can tell us which
    type is expected in every case, and if you use a dynamic declaration such as `var`,
    the right side of the equality (if any) will be evaluated, and we will be shown
    the calculated value for every declaration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这也在 IDE 中有影响。编辑器可以告诉我们每种情况下期望的类型，如果你使用动态声明，如 `var`，等式的右侧（如果有）将被评估，并且对于每个声明，我们将看到计算出的值：
- en: '![Languages: strongly typed, weakly typed, dynamic, and static](img/image00432.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![编程语言：强类型、弱类型、动态和静态](img/image00432.jpeg)'
- en: Even outside of the .NET world, Visual Studio's IDE is now able to provide strongly
    typed and Intellisense experiences when using languages such as TypeScript, a
    superset of JavaScript that transpiles (converts into) pure JavaScript but can
    be written using the same coding experience as what we would have in C# or any
    other .NET language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 .NET 世界之外，Visual Studio 的 IDE 现在也能在使用 TypeScript 等语言时提供强类型和 Intellisense
    体验，TypeScript 是 JavaScript 的超集，可以编译（转换为）纯 JavaScript，但可以使用与 C# 或任何其他 .NET 语言相同的编码体验来编写。
- en: It's available as a separate type of project, if you're curious about it, and
    the latest up-to-date version is TypeScript 2.0, and it was recently published
    (you can take a look at a detailed description of its new capabilities at [https://blogs.msdn.microsoft.com/typescript/](https://blogs.msdn.microsoft.com/typescript/)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以作为独立的项目类型使用，如果你对此感兴趣，最新版本是 TypeScript 2.0，它最近刚刚发布（你可以在 [https://blogs.msdn.microsoft.com/typescript/](https://blogs.msdn.microsoft.com/typescript/)
    查看其新功能的详细描述）。
- en: As we'll see later in this chapter, Intellisense is key for the LINQ syntax,
    in which many expressions return a new (non-existing) type, which can be automatically
    assigned to the correct type by the compiler if we use a var declaration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们将在本章后面看到的那样，Intellisense 对于 LINQ 语法至关重要，在许多表达式中，它会返回一个新的（不存在的）类型，如果我们使用 var
    声明，编译器会自动将其分配给正确的类型。
- en: The main differences
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要区别
- en: 'So, going back to the title, what made C# different? I''ll point out five core
    points:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到标题，是什么让 C# 与众不同？我将指出五个核心点：
- en: Everything is an object (we mentioned this in [Chapter 1](part0015.xhtml#aid-E9OE2
    "Chapter 1. Inside the CLR"), *Inside the CLR*). Other languages, such as Smalltalk,
    Lisp, among others, have done this earlier, but due to different reasons, the
    performance penalty was pretty hard.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切都是对象（我们在 [第 1 章](part0015.xhtml#aid-E9OE2 "第 1 章。CLR 内部")中提到过，*CLR 内部*)。其他语言，如
    Smalltalk、Lisp 等，在此之前就已经这样做，但由于不同的原因，性能损失相当严重。
- en: As you know, it's enough to take a look at the Object Explorer to be able to
    check where an object comes from. It's a good practice to check the very basic
    values, such as `int` or `String`, which are nothing but aliases of `System.Int32`
    and `System.String`, and both come from object, as shown in the following screenshot:![The
    main differences](img/image00433.jpeg)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如你所知，只需查看对象资源管理器，就能检查一个对象来自哪里。检查基本值，如 `int` 或 `String` 是一个好习惯，它们不过是 `System.Int32`
    和 `System.String` 的别名，并且两者都来自对象，如下面的截图所示：![主要区别](img/image00433.jpeg)
- en: Using the Boxing and Unboxing techniques, any value type can be converted into
    an object, and the value of an object can be converted into a simple value type.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过装箱和拆箱技术，任何值类型都可以转换为对象，而对象的值也可以转换为简单的值类型。
- en: 'These conversions are made by simply casting the type to an object (and vice
    versa) in this manner:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些转换可以通过将类型转换为对象（反之亦然）以这种方式进行：
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using Reflection (the technique that allows you to read a component's metadata),
    an application can call itself or other applications, creating new instances of
    their containing classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反射（允许您读取组件元数据的技巧），应用程序可以调用自身或其他应用程序，创建它们包含的类的新的实例。
- en: 'As a short demo, this simple code launches another instance of a WPF application
    (a very simple one with just one button, but that doesn''t matter):'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为简短的演示，这段简单的代码启动了另一个WPF应用程序的实例（一个非常简单的应用程序，只有一个按钮，但这并不重要）：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, every time we click on the button, a new instance of the window is created
    and launched, indicating its creation order in the title's window:![The main differences](img/image00434.jpeg)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，每次我们点击按钮时，都会创建并启动一个新的窗口实例，这在标题窗口中指示其创建顺序：![主要区别](img/image00434.jpeg)
- en: 'You can have access to other components through a technology called Platform
    Invoke, which means you can call operating systems'' functions by importing the
    existing DLLs using the `DllImport` attribute:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过一种名为平台调用的技术访问其他组件，这意味着您可以通过使用`DllImport`属性导入现有的DLL来调用操作系统的功能：
- en: For instance, you can make an external program's window the child of your own
    window using the `SetParent` API, which is part of `User32.dll`, or you can control
    operating system events, such as trying to shut down the system while our application
    is still active.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，您可以使用`SetParent` API（它是`User32.dll`的一部分）将外部程序的窗口作为您自己的窗口的子窗口，或者您可以控制操作系统事件，例如在我们应用程序仍然活动时尝试关闭系统。
- en: Actually, once the permissions are given, your application can call any function
    located in any of the system's DLL if you need access to native resources.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，一旦权限被授予，如果您的应用程序需要访问本地资源，它可以调用系统中的任何DLL中的任何函数。
- en: The schema that gives us access to these resources looks like what is shown
    in the following figure:![The main differences](img/image00435.jpeg)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供我们访问这些资源的模式看起来就像以下图中所示：![主要区别](img/image00435.jpeg)
- en: If you want to try out some of these possibilities, the mandatory resource to
    keep in mind is [http://www.PInvoke.net](http://www.PInvoke.net), where you have
    most of the useful system APIs, with examples of how to use them in C#.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想尝试一些这些可能性，必须记住的资源是[http://www.PInvoke.net](http://www.PInvoke.net)，在那里您有大多数有用的系统API，以及如何在C#中使用它们的示例。
- en: These interoperation capabilities are extended to interactions with applications
    that admit Automation, such as those in the Microsoft Office Suite, AutoCAD, and
    so on.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些互操作性能力扩展到与接受自动化（如Microsoft Office套件、AutoCAD等）的应用程序的交互。
- en: Finally, unsafe code allows you to write inline C code with pointers, perform
    unsafe casts, and even pin down memory in order to avoid accidental garbage collection.
    However, unsafe does not mean that it is unmanaged. Unsafe code is deeply tied
    into the security system.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，不安全代码允许您使用指针编写内联C代码，执行不安全转换，甚至固定内存以避免意外垃圾回收。然而，不安全并不意味着它是未管理的。不安全代码与安全系统紧密相连。
- en: There are many situations in which this is very useful. It might be an algorithm
    that's difficult to implement or a method whose execution is so CPU-intensive
    that performance penalties become unacceptable.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多情况下，这非常有用。可能是一个难以实现的算法，或者是一个执行非常CPU密集的方法，以至于性能惩罚变得无法接受。
- en: While all this is important, I was surprised by the fact that every event handler
    in C# (as also in other .NET languages) would have two and only two arguments.
    So, I asked Anders about it, and his answer was one of the most clear and logical
    ones that I've ever heard.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些都很重要，但我对C#（以及其他.NET语言）中的每个事件处理器都会有两个且仅有两个参数的事实感到惊讶。所以我问过Anders，他的回答是我所听过的最清晰、最合逻辑的回答之一。
- en: The true reason for delegates
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理的真实原因
- en: 'It so happens that besides these architectural considerations that we''ve mentioned,
    there was another reason that was key to the design: ensuring that a .NET program
    would never produce a **BSOD** (**Blue Screen of Death**).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，除了我们提到的这些架构考虑之外，还有一个关键的设计原因：确保.NET程序永远不会产生**BSOD**（蓝屏死机）。
- en: So, the team tackled the problem scientifically and made a statistical analysis
    of their causes (more than 70,000 of these screens were used in the analysis).
    It turned out that around 90% of the causes for this problem were due to drivers,
    and the only thing they could do was get serious with manufacturers, asking them
    to pass the **Hardware Compatibility List** (**HCL**) and little else.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，团队科学地解决了这个问题，并对原因进行了统计分析（分析中使用了超过70,000个这样的屏幕）。结果显示，大约90%的问题原因都是由于驱动程序引起的，他们唯一能做的就是认真与制造商沟通，要求他们通过**硬件兼容性列表**（**HCL**）以及做其他一些事情。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The current HCL page for Windows can be found at [https://sysdev.microsoft.com/en-us/hardware/lpl/](https://sysdev.microsoft.com/en-us/hardware/lpl/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当前Windows的HCL页面可以在[https://sysdev.microsoft.com/en-us/hardware/lpl/](https://sysdev.microsoft.com/en-us/hardware/lpl/)找到。
- en: 'So, they had a remaining 10% problem due to their own software, but the big
    surprise was that instead of finding five or 10 core causes for these failures,
    the problem focused mainly on just two reasons:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他们由于自己的软件还剩下10%的问题，但最大的惊喜是，他们并没有找到五个或十个核心原因来解释这些故障，问题主要集中在仅仅两个原因上：
- en: Pointer to functions that get lost, which I represent in the graphic by **p*
    -> f(x)**
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向丢失的函数的指针，我在图中用**p* -> f(x**)表示
- en: Casting problems (trying to convert types passed to a function; failing could
    drive to unpredictable results)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影问题（尝试转换传递给函数的类型；失败可能导致不可预测的结果）
- en: 'The results, expressed in a simple Gaussian curve, look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，用简单的高斯曲线表示，看起来是这样的：
- en: '![The true reason for delegates](img/image00436.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![代表者的真正原因](img/image00436.jpeg)'
- en: 'So, covering these two issues, more than 95% (or more) of the problems, were
    solved. The first goal was achieved: focusing on the problem and reducing it to
    the maximum.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决这两个问题，超过95%（或更多）的问题都得到了解决。第一个目标实现了：专注于问题，并将其缩减到最大。
- en: 'At this point, he had to find a solution that could possibly resolve both issues.
    This is where the genius of this Danish man came in. He thought back to the origins
    of the two problems and realized that both cases were related to method calls.
    Given a twist and a return to rethink the foundations of General Information Theory
    in order to identify the specific problem within the theoretical model (the first
    pages of any book on the subject), we would find something like what is shown
    in this figure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，他必须找到一个可能解决这两个问题的解决方案。这就是这位丹麦人的天才所在。他回顾了这两个问题的起源，并意识到这两个案例都与方法调用有关。给定一个转折和一个回归，重新思考通用信息论的基础，以识别理论模型中的具体问题（任何关于这个主题的书的首页），我们会发现像这个图所示的东西：
- en: '![The true reason for delegates](img/image00437.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![代表者的真正原因](img/image00437.jpeg)'
- en: 'But, wait! ...this is also the core architecture of the event system! So, there
    is a correspondence between the two schemas in the four elements implied:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等！...这同样是事件系统的核心架构！因此，在四个元素隐含的两个方案之间存在着对应关系：
- en: '**Issuer**: It is the method that makes the call'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者**：这是发起调用的方法'
- en: '**Receiver**: Another class (or the same) responding in another method'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收者**：另一个类（或相同的）在另一个方法中做出响应'
- en: '**Channel**: It is the environment, replaced by a managed environment in .NET'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信道**：这是环境，在.NET中由托管环境替代'
- en: '**Message**: The information sent to the receiver'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：发送给接收者的信息'
- en: 'Now, the second problem is solved: the model of the target is identified as
    a case of the general pattern of information theory as well as its parts: the
    channel and the information expected to be received.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第二个问题已经解决了：目标模型的模型被识别为信息论一般模式的案例，以及它的部分：信道和期望接收的信息。
- en: 'What was missing? What has always been done in computer science to solve problems
    of direct calls? That would be calling in an intermediary. Or if you prefer otherwise,
    applying the fifth principle of the SOLID design: Dependency Inversion.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少了什么？计算机科学中一直用来解决直接调用问题的是什么？那将是调用一个中介。或者如果你愿意，应用SOLID设计原则的第五条：依赖倒置。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'We''ll talk in more detail about dependency inversion when we cover *Design
    patterns* in [Chapter 10](part0055.xhtml#aid-1KEEU1 "Chapter 10. Design Patterns"),
    *Design Patterns*, but for now, suffice to say what the principle states (in short):
    modules should not depend on low-level modules or on details but on abstractions.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第10章](part0055.xhtml#aid-1KEEU1 "第10章。设计模式")、*设计模式*中详细讨论依赖倒置时，我们将更详细地讨论依赖倒置，但到目前为止，只需简单地说一下原则的内容（简而言之）：模块不应该依赖于低级模块或细节，而应该依赖于抽象。
- en: 'This is where the factor responsible for this solution comes in: the delegate.
    Calls are never made directly but always through the delegate, which is administered
    by CLR and will not attempt to call something that is not available (it''s managed,
    remember). The function pointer problem is solved via the channel (and the elimination
    of function pointers, of course).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是导致这个解决方案的因素：委托。调用永远不会直接进行，而是总是通过委托进行，由CLR管理，并且不会尝试调用不可用的东西（记住，它是受管理的）。通过通道（以及当然消除函数指针）解决了函数指针问题。
- en: 'If you take a look at the official (Wikipedia''s) article explaining this principle
    ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)),
    you''ll discover that the recommended solution of the pattern is to change from
    scenario 1 (at the left-hand side of the figure) to scenario 2 (at the right-hand
    side), in which it is proposed that the method that is called (in object B) inherits
    (implements) an interface to make sure that the call is realized with no risks:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看解释这个原则的官方（维基百科）文章（[https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)），你会发现模式推荐解决方案是从场景1（图左侧）转换为场景2（图右侧），其中建议被调用的方法（在对象B中）继承（实现）一个接口，以确保调用没有风险：
- en: '![The true reason for delegates](img/image00438.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![委托的真实原因](img/image00438.jpeg)'
- en: The solution to the second cause, as Hejlsberg said, *seemed trivial, once turned
    above*. He just had to make the delegate's signature equal to the receiving method
    (remember, the same types of parameters and return value), and bid goodbye to
    the problems of casting, since CLR is strongly typed and the compiler (and even
    the IDE) will mark any violation of this principle, indicating that it won't compile.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Hejlsberg所说，第二个原因的解决方案“一旦转换过来，似乎很简单”。他只需要让委托的签名与接收方法相同（记住，参数类型和返回值相同），然后就可以告别类型转换的问题，因为CLR是强类型的，编译器（甚至IDE）会标记任何违反此原则的行为，表明它不会编译。
- en: This architecture avoids the problems of BSOD originated by these causes. Can
    we look at this structure in code? Sure. Actually, I'm pretty sure you have seen
    it often, only not from this point of view maybe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构避免了由这些原因引起的BSOD问题。我们能看看这个结构在代码中的样子吗？当然可以。实际上，我非常确信你经常看到它，只是可能不是从这个角度。
- en: 'Let''s go back a second to the previous case with our Reflected window. And
    let''s identify the protagonists. The emitter is clearly the `bntLaunch` button
    member, and the receiver is the previous code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前使用反射窗口的案例。现在我们来确定主要角色。发射器显然是`bntLaunch`按钮成员，接收器是之前的代码：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, when we see the click''s event handler method''s definition, we also see
    two of the members of scenario 2: the sender (the emitter) and the information
    passed in (an instance of the `RoutedEventArgs` class).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们看到点击事件处理方法的定义时，我们也看到了场景2的两个成员：发送者（发射器）和传递的信息（`RoutedEventArgs`类的实例）。
- en: 'Remember, a delegate in charge of the call should have the same signature as
    that in this method. Just right-click on the name of the method, **Search all
    references**, and you''ll find out where the connection between the method and
    the delegate is established (the usual syntax):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，负责调用的委托应该与这个方法中的签名相同。只需右键单击方法名称，**搜索所有引用**，你就可以找到方法与委托之间建立连接的地方（通常是这种语法）：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, the click member of `btnLaunch` is connected to the `btnLaunch_Click` method
    by means of a new instance of a delegate of type `RoutedEventHandler`. Once again,
    right-click on **RoutedEventHandler** and select **Go to definition** in order
    to take a look at the delegate''s signature:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`btnLaunch`的点击成员通过一个类型为`RoutedEventHandler`的新委托实例连接到`btnLaunch_Click`方法。再次点击**RoutedEventHandler**并选择**转到定义**，以便查看委托的签名：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Voilà, the signature is exactly the same as the receiver. No more casting problems,
    and if the CLR does its work, no calls will be made unless the receiver method
    is not accessible. This is because only a kernel-level component can cause a BSOD,
    never a user mode component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，签名与接收器完全相同。不再有类型转换问题，如果CLR完成其工作，除非接收方法不可访问，否则不会进行调用。这是因为只有内核级组件才能导致BSOD，永远不会是用户模式组件。
- en: 'So, a delegate is a very special class that can be declared outside or inside
    any other class and has the ability to target any method as long as their signatures
    are compatible. The `+=` syntax also tell us something important: they are multicast.
    That is, they can target more than one method in a single call.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，委托是一个非常特殊的类，可以在任何其他类的内部或外部声明，并且具有将任何方法作为目标的能力，只要它们的签名兼容。`+=`语法也告诉我们一些重要的事情：它们是多播的。也就是说，它们可以在单个调用中针对多个方法。
- en: 'Let''s place this in a scenario where we need to evaluate which numbers are
    divisible by another sequence of numbers. To put it simply, let''s start with
    two methods, checking the divisibility by 2 and 3, respectively:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个问题放在一个场景中，我们需要评估哪些数字可以被另一个数字序列整除。简单来说，让我们从两个方法开始，分别检查能否被2和3整除：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we want to evaluate the list and fill a Listbox including those numbers
    that comply with the rules:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要评估列表并填充一个包含符合规则数字的Listbox：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We declare a delegate, `DivisibleBy`, which receives a number and performs an
    action (later, we'll find that this is renamed to `Action`). So, the same delegate
    can call both methods in a sequence (note that this can make the sequence pretty
    long).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个委托，`DivisibleBy`，它接收一个数字并执行一个操作（稍后我们会发现这个名字被改成了`Action`）。因此，同一个委托可以按顺序调用两个方法（请注意，这可能会使序列变得相当长）。
- en: 'The delegate is invoked using another button that will call the following code
    when clicked:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是通过另一个按钮调用的，当点击该按钮时，将调用以下代码：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we don''t include the implementation of `PrintResults`, which you can
    imagine and which is also included in the `Chapter02_02` demo. The following result
    is expected:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们没有包括`PrintResults`的实现，您可以想象它，它也包含在`Chapter02_02`演示中。预期的结果如下：
- en: '![The true reason for delegates](img/image00439.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![委托的真实原因](img/image00439.jpeg)'
- en: The evolution in versions 2.0 and 3.0
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.0和3.0版本的演变
- en: As we see, even from the very beginning, the Hejlsberg's team started with a
    complete, flexible, and modern platform, capable of being extended in many ways
    as technology evolves. This intention became clear since version 2.0.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，从一开始，Hejlsberg的团队就从一个完整、灵活和现代的平台开始，能够以许多方式扩展，以适应技术的发展。从2.0版本开始，这种意图变得清晰。
- en: The first actual fundamental change that took place in the language was the
    incorporation of Generics. Don Syme, who would later on lead the team that created
    the F# language, was very active and led this team as well, so it was ready for
    version 2.0 of the .NET Framework (not just in C# but in C++ and VB.NET as well).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 语言中发生的第一个实际的基本变化是泛型的引入。Don Syme，后来领导了创建F#语言的团队，非常活跃，并领导了这个团队，因此它为.NET Framework
    2.0版本做好了准备（不仅是在C#中，在C++和VB.NET中也是如此）。
- en: Generics
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: The purpose of generics was mainly to facilitate the creation of more reusable
    code (one of the principles of OOP, by the way). The name refers to a set of language
    features that allow classes, structures, interfaces, methods, and delegates to
    be declared and defined with unspecified or generic type parameters instead of
    specific types (see [https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx](https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx),
    for more details).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的主要目的是为了便于创建更多可重用的代码（顺便说一句，这是面向对象编程的一个原则）。这个名字指的是一组语言特性，允许类、结构、接口、方法和委托使用未指定或泛型类型参数而不是特定类型进行声明和定义（有关详细信息，请参阅[https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx](https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx)）。
- en: So, you can define members in a sort of abstract definition, and later on, at
    the time of using it, a real, concrete type will be applied.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在一种抽象定义中定义成员，稍后在使用时，将应用一个真实、具体的类型。
- en: The basic .NET classes (BCL) were enhanced in the `System` namespace and a new
    `System.Collections.Generic` namespace was created to support this new feature
    in depth. In addition, new support methods were added to ease the use of this
    new type, such as `Type.IsGenericType` (obviously, to check types), `Type.GetGenericArguments`
    (self-descriptive), and the very useful `Type.MakeGenericType`, which can create
    a generic type of any kind from a previous nonspecified declaration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的.NET类（BCL）在`System`命名空间中得到了增强，并创建了一个新的`System.Collections.Generic`命名空间来深入支持这个新特性。此外，还添加了新的支持方法来简化新类型的使用，例如`Type.IsGenericType`（显然，用于检查类型）、`Type.GetGenericArguments`（自解释）和非常有用的`Type.MakeGenericType`，它可以从先前的非指定声明中创建任何类型的泛型类型。
- en: 'The following code uses the generic type definition for a Dictionary (`Dictionary<,>`)
    and creates an actual (build) type using this technique. The relevant code is
    the following (the rest, including the output to the console is included in `Demo_02_03`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用字典的泛型类型定义（`Dictionary<,>`）并使用此技术创建实际（构建）类型。相关代码如下（其余代码，包括输出到控制台的内容，包含在
    `Demo_02_03` 中）：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you see, `MakeGenericType` expects an array of (concrete) types. Later on
    (not in the preceding code), we use `GetGenericTypeDefinition`, `IsGenericType`,
    and `GetGenericArguments` in order to introspect the resulting types and present
    the following output in the console:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`MakeGenericType` 期望一个（具体）类型的数组。稍后（不在前面的代码中），我们使用 `GetGenericTypeDefinition`、`IsGenericType`
    和 `GetGenericArguments` 来内省生成的类型，并在控制台输出以下内容：
- en: '![Generics](img/image00440.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![泛型](img/image00440.jpeg)'
- en: So, we have different ways to declare generics with identical results as far
    as the operations in the code are concerned.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就代码中的操作而言，我们有不同的方式声明泛型，并得到相同的结果。
- en: 'Obviously, manipulating already constructed generic types is not the only possibility,
    since one of the main goals of generics is to avoid casting operations by simplifying
    the work with collections. Up until version 2.0, collections could only hold basic
    types: integers, longs, strings, and so on, along with emulating different types
    of data structures, such as stacks, queues, linked lists, and so on.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，操作已经构建的泛型类型并不是唯一的选择，因为泛型的主要目标之一是通过简化集合的工作来避免类型转换操作。直到版本 2.0，集合只能存储基本类型：整数、长整型、字符串等，以及模拟不同的数据结构，如栈、队列、链表等。
- en: 'Besides this, Generics have another big advantage: you can write methods that
    support working with different types of arguments (and return values) as long
    as you provide a correct way to handle all possible cases.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，泛型还有另一个很大的优点：你可以编写支持处理不同类型参数（和返回值）的方法，只要你提供正确处理所有可能情况的方法。
- en: Once again, the notion of contract will be crucial here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，契约的概念在这里将至关重要。
- en: Creating custom generic types and methods
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义泛型类型和方法
- en: Other useful feature is the possibility to use custom generic types. Generic
    types and the support for optional values through the `System.Nullable<T>` type
    were, for many developers, two of the most important features included in version
    2.0 of the language.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的特性是使用自定义泛型类型。泛型类型和通过 `System.Nullable<T>` 类型支持可选值的特性，对于许多开发者来说，是语言 2.0
    版本中包含的两个最重要的特性。
- en: Imagine you have a `Customer` class, which your application manages. So, in
    different use cases, you will read collections of customers and perform operations
    with them. Now, what if you need an operation such as `Compare_Customers`? What
    would be the criteria to use in this case? Even worse, what if we would like to
    use the same criteria with different types of entities, such as `Customer` and
    `Provider`?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 `Customer` 类，你的应用程序管理它。因此，在不同的用例中，你将读取客户集合并对其执行操作。现在，如果你需要像 `Compare_Customers`
    这样的操作怎么办？在这种情况下，你会使用什么标准？更糟糕的是，如果我们想使用相同的标准来处理不同类型的实体，如 `Customer` 和 `Provider`
    呢？
- en: In these cases, some characteristics of generics come in handy. To start with,
    we can build a class that has an implementation of the `IComparer` interface,
    so we establish beyond any uncertainty what the criteria to be used is in order
    to consider customer `C1` bigger or smaller than customer `C2`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，泛型的一些特性非常有用。首先，我们可以构建一个实现了 `IComparer` 接口的类，这样我们就可以确定无疑地知道用于考虑客户 `C1`
    是大于还是小于客户 `C2` 的标准。
- en: 'For instance, if the criteria is only `Balance`, we can start with a basic
    `Customer` class, to which we add a static method in order to generate a list
    of random customers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果标准仅是 `Balance`，我们可以从一个基本的 `Customer` 类开始，向其中添加一个静态方法来生成随机客户列表：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, we build another `CustomerComparer` class, which implements the `IComparer`
    interface. The difference is that this comparison method is a generic instantiation
    customized for the `Customer` objects, so we have the freedom of implementing
    this scenario just in the way that seems convenient for our logic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建另一个 `CustomerComparer` 类，它实现了 `IComparer` 接口。区别在于这个比较方法是一个针对 `Customer`
    对象的泛型实例化，因此我们可以自由地以对我们逻辑方便的方式实现这个场景。
- en: 'In this case, we''re using `Balance` as an ordering criteria, so that we would
    have the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `Balance` 作为排序标准，所以我们会得到以下内容：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see that the criteria used to compare is just the one we decided for
    our business logic. Finally, another class, `GenericCustomer`, which implements
    an entry point of the application, uses both classes in this manner:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，用于比较的标准正是我们为业务逻辑所决定的。最后，另一个类`GenericCustomer`，它实现了应用程序的入口点，以这种方式使用这两个类：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This produces an output of random customers order by their balance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个按余额排序的随机客户列表输出：
- en: '![Creating custom generic types and methods](img/image00441.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义泛型类型和方法](img/image00441.jpeg)'
- en: 'This is even better: we can change the method so that it supports both customers
    and providers indistinctly. To do this, we need to abstract a common property
    of both entities that we can use for comparison.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至更好：我们可以修改方法，使其能够无差别地支持客户和供应商。为此，我们需要抽象出这两个实体共有的一个属性，我们可以用它来进行比较。
- en: 'If our implementation of `Provider` has different or similar fields (but they''re
    not the same), it doesn''t matter as long as we have the common factor: a `Balance`
    field.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`Provider`实现有不同的或相似的字段（但它们并不相同），只要我们有这个共同因素：一个`Balance`字段，那就没关系。
- en: 'So we begin with a simple definition of this common factor, an interface called
    `IPersonBalance`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先对这个共同因素给出一个简单的定义，一个名为`IPersonBalance`的接口：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As long as our `Provider` class implements this interface, we can later create
    a common method that''s able to compare both objects, so, let''s assume our `Provider`
    class looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的`Provider`类实现了这个接口，我们就可以后来创建一个能够比较两个对象的通用方法，所以，让我们假设我们的`Provider`类看起来像这样：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we rewrite the `Comparer` method to be a `GenericComparer` class, capable
    of dealing with both types of entities:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`Comparer`方法重写为`GenericComparer`类，使其能够处理这两种类型的实体：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that in this implementation, `IComparer` depends on an interface, not on
    an actual class, and that this interface simply defines the common factor of these
    entities.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个实现中，`IComparer`依赖于一个接口，而不是一个实际的类，并且这个接口仅仅定义了这些实体的共同因素。
- en: 'Now, our new entry point will put everything together in order to obtain an
    ordered list of random `Provider` classes that uses the common comparison method
    just created:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的新入口点将把所有内容组合起来，以获得一个使用刚刚创建的通用比较方法的有序`Provider`类列表：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this way, we obtain an output like what is shown in the following figure
    (note that we didn''t take much care of formatting in order to focus on the process):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们得到一个如图所示的输出（注意，我们没有过多关注格式，以便专注于过程）：
- en: '![Creating custom generic types and methods](img/image00442.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义泛型类型和方法](img/image00442.jpeg)'
- en: 'The example shows how generics (and interfaces: also generic) come to our rescue
    in these types of situations, and—as we''ll have the opportunity to prove when
    talking about implementations of design patterns—this is key to facilitating good
    practice.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了泛型（以及接口：也是泛型）是如何在这些情况下拯救我们的，而且——当我们有机会在讨论设计模式的实现时证明这一点——这是促进良好实践的关键。
- en: 'So far, some of the most critical concepts behind generics have been discussed.
    In up coming chapters, we''ll see how other aspects related to generics show up.
    However, the real power comes from joining these capabilities with two new features
    of the language: lambda expressions and the LINQ syntax.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，泛型背后的某些最关键的概念已经被讨论过了。在接下来的章节中，我们将看到与泛型相关的其他方面是如何出现的。然而，真正的力量来自于将这些能力与语言的两个新特性相结合：lambda表达式和LINQ语法。
- en: Lambda expressions and anonymous types
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda表达式和匿名类型
- en: 'For a bit, let''s review what happens when we create a new, anonymous type
    by invoking the `new` operator, followed by a description of the object:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下当我们通过调用`new`运算符创建一个新的匿名类型时会发生什么，然后描述一下这个对象：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The compiler correctly infers the non-declared type to be anonymous. Actually,
    if we use the disassembler tool we saw in the previous chapter, we''ll discover
    how the compiler assigns a default name to this class (``f_AnonymousType0`2``):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器正确地推断出未声明的类型为匿名类型。实际上，如果我们使用前一章中提到的反汇编工具，我们会发现编译器是如何为这个类分配默认名称的（`f_AnonymousType0`2``）：
- en: '![Lambda expressions and anonymous types](img/image00443.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Lambda表达式和匿名类型](img/image00443.jpeg)'
- en: Also, we can see that a special constructor has been created along with two
    private fields and two access methods (`get_Age` and `get_Name`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以看到，已经创建了一个特殊的构造函数以及两个私有字段和两个访问方法（`get_Age`和`get_Name`）。
- en: These kind of objects are especially suitable when we deal with data coming
    from any source, and we filter the information vertically (that is, we don't require
    all fields but just a few, or maybe even one).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这类对象特别适合当我们处理来自任何来源的数据时，并且我们垂直地（即，我们不需要所有字段，只需几个，或者甚至一个）过滤信息。
- en: The resulting objects coming from such a query are not previously defined anywhere
    in our code, since every different query would required a customized definition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 来自此类查询的结果对象在我们的代码中任何地方都没有预先定义，因为每个不同的查询都需要一个定制的定义。
- en: Lambda expressions
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: With that in mind, a lambda expression is just an anonymous function, which
    is expressed in a different syntax that allows you to pass such a function as
    an argument, much in the style of functional programming languages, such as JavaScript.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，lambda表达式只是一个匿名函数，它以不同的语法表达，允许你以类似于函数式编程语言（如JavaScript）的风格将此类函数作为参数传递。
- en: 'In C# 3.0, lambda expressions appeared with a simplified syntax that uses a
    lambda operator (`=>`). This operator divides the defined function into two parts:
    the arguments to the left and the body to the right; for example, take a look
    at this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 3.0中，lambda表达式以简化的语法出现，使用lambda运算符（`=>`）。此运算符将定义的函数分为两部分：左边的参数和右边的主体；例如，看看这个：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This admits certain variations, such as the omission of parenthesis in the list
    of arguments and the omission of curly brackets in the body as long as the compiler
    is able to infer the details, types involved, and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许某些变化，例如在参数列表中省略括号以及在主体中省略花括号，只要编译器能够推断出细节、涉及的类型等。
- en: 'Since the preceding declaration is a delegate''s definition, we can assign
    it to any delegate''s variable, and so we can express the condition used when
    finding the divisible numbers by 3 or 7 in a much neater way:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的声明是委托的定义，我们可以将其分配给任何委托变量，因此我们可以以一种更整洁的方式表达在查找3或7的倍数时使用的条件：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is, variable `ed3` is assigned a lambda expression that receives an element
    (an `int`, in this case) and evaluates the body function, which calculates the
    same numbers as we did earlier. Note that the body function is not enclosed in
    curly brackets because the definition is clear enough for the compiler.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即，变量`ed3`被分配了一个lambda表达式，它接收一个元素（在这种情况下是一个`int`）并评估主体函数，该函数计算与我们之前所做的相同的数字。请注意，主体函数没有用花括号括起来，因为定义对编译器来说足够清晰。
- en: So, operating in this manner, there is no need to declare separated methods,
    and we can even pass one of these expressions as an argument to a method that
    accepts it like many of the generic collections do.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以这种方式操作，我们无需声明单独的方法，甚至可以将这些表达式之一作为参数传递给接受它的方法，就像许多泛型集合所做的那样。
- en: At this point, we start to see the power of all this when used in conjunction
    with generic collections. From version 3.0 of .NET framework, generic collections
    include a bunch of methods that admit lambda expressions as arguments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们开始看到当与泛型集合结合使用时的所有这些功能的强大之处。从.NET框架的3.0版本开始，泛型集合包含了一组接受lambda表达式作为参数的方法。
- en: It's all about signatures
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 这一切都关乎签名
- en: 'The .NET framework team, however, went a bit deeper. If you abstract the possible
    signatures behind any delegate, you can categorize them in three blocks depending
    on the return value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，.NET框架团队走得更深。如果你抽象出任何委托背后的可能签名，你可以根据返回值将它们分为三个块：
- en: Delegates with no return value (called actions and defined with the `Action`
    keyword)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有返回值的委托（称为操作，使用`Action`关键字定义）
- en: Delegates that return a Boolean (now called predicates, such as in logic, but
    defined with the `Func` keyword)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回布尔值的委托（现在称为谓词，如在逻辑中，但使用`Func`关键字定义）
- en: The rest of delegates, returning any type (also defined with the `Func` keyword)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的委托，返回任何类型（也使用`Func`关键字定义）
- en: 'So, these three reserved words became part of the C# syntax, and all the generic
    methods we find in collections will ask us for one of these three types of delegates.
    A simple look at one of these in Visual Studio will show us this situation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这三个保留字成为了C#语法的组成部分，我们在集合中找到的所有泛型方法都会要求我们提供这三种类型的委托之一。简单地在Visual Studio中查看这些之一，就会显示这种情况：
- en: '![It''s all about signatures](img/image00444.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![这关乎签名](img/image00444.jpeg)'
- en: 'The screenshot shows the definition of the `Where<T>` method. Just think about
    it: the idea is to allow us to filter collection data in a manner similar to how
    the `where` clause does in the SQL syntax. What we express in a `where` clause
    is a Boolean condition, just like in Mathematical Logic, a predicate is an assertion
    that is always evaluated to be `true` or `false`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示了`Where<T>`方法的定义。只需想想：这个想法是允许我们以类似于SQL语法中`where`子句的方式过滤集合数据。我们在`where`子句中表达的是一个布尔条件，就像在数学逻辑中，谓词是一个总是评估为`true`或`false`的断言。
- en: 'For instance, we can recode the previous scenario using `numberList` directly,
    with something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以直接使用`numberList`重写之前的场景，如下所示：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Same results are obtained with much less plumbing, so we can focus more on the
    problem to be solved and less on the algorithm required.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以更少的管道获得相同的结果，因此我们可以更多地关注要解决的问题，而不是所需的算法。
- en: Many more methods were added and immediately accepted by the programmer's community
    due to the productivity linked to them. For the case with no return values, the
    body code is supposed to act over something external to the method. In our example,
    it could be something like adding a number to the list of selected values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与它们相关的生产力，许多更多的方法被添加，并且立即被程序员社区接受。对于没有返回值的情况，代码体应该作用于方法外部的东西。在我们的例子中，这可能像是在所选值的列表中添加一个数字。
- en: 'In this way, we can handle more complex situations, such as the case where
    we need to calculate multiples of two numbers starting with a certain digit, such
    as in this code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以处理更复杂的情况，例如，我们需要计算以某个数字开头的两个数的乘积的情况，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this variation, we use the `ForEach` method, which receives an `Action`
    delegate argument, as we can see in the tooltip definition offered by the IDE''s
    Editor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变体中，我们使用`ForEach`方法，它接收一个`Action`委托参数，正如我们可以在IDE的编辑器提供的工具提示定义中看到的那样：
- en: '![It''s all about signatures](img/image00445.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![关于签名的全部内容](img/image00445.jpeg)'
- en: How do these sentences translate into real code? It might be a bit surprising
    for the curious reader to take a look at the MSIL code produced by this code.
    Even a simple lambda expression can become more complex than one might think a
    priori.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些句子如何翻译成实际的代码？对于好奇的读者来说，看看由这段代码产生的MSIL代码可能会有些惊讶。即使是一个简单的lambda表达式也可能比事先想象的要复杂。
- en: Let's take a look at the syntax of our previous `x => x % 3 == 0` lambda expression
    that we have been using. The trick here is that (internally) this is converted
    to a tree expression, and if you assign that expression to a variable of type
    `Expression<TDelegate>`, the compiler generates the code to build an expression
    tree representing that lambda expression.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们之前使用的`x => x % 3 == 0` lambda表达式的语法。这里的技巧是（在内部）这被转换为一个树表达式，如果你将这个表达式赋值给一个类型为`Expression<TDelegate>`的变量，编译器会生成代码来构建表示该lambda表达式的表达式树。
- en: 'So, consider that we express the lambda in its alternative syntax using an
    `Expression` object, such as in this code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑使用`Expression`对象以替代语法表达lambda，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once compiled, you can check the disassembly code and find the equivalent in
    the MSIL code, which is made up of several declarations of individual expressions,
    as shown in the following screenshot (just a fragment of what is inside):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译完成，你可以检查反汇编代码，并在以下屏幕截图（只是内部内容的片段）中找到MSIL代码中的等效部分：
- en: '![It''s all about signatures](img/image00446.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![关于签名的全部内容](img/image00446.jpeg)'
- en: 'This equivalence becomes more evident if we translate the code of one of these
    expressions into its individual parts. The official MSDN documentation gives us
    the clue by comparing a simple lambda built using expressions with its generated
    parts. So, they start by saying something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些表达式中之一转换为它的各个部分，这种等价性就会变得更加明显。官方MSDN文档通过比较使用表达式构建的简单lambda与其生成的部分来给我们提供线索。因此，他们首先说类似这样的话：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is followed by the decomposition of this expression tree:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这接着是分解这个表达式树：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Well, the result of this decomposition is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这种分解的结果如下：
- en: '![It''s all about signatures](img/image00447.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![关于签名的全部内容](img/image00447.jpeg)'
- en: This is equivalent to the lambda expression, but now we can see that internally,
    operating with the individual components of the tree is equivalent to the shorten
    lambda expression.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这与lambda表达式等价，但现在我们可以看到，在内部，操作树的各个部分与缩短的lambda表达式等价。
- en: The LINQ syntax
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ语法
- en: The goal of all this, besides making things easier for the way we deal with
    collections, is to facilitate data management. That means reading information
    from a source and converting it into a collection of objects of the desired type,
    thanks to these generic collections.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的目标，除了使处理集合的方式更简单之外，就是便于数据管理。这意味着从源读取信息并将其转换为所需类型的对象集合，多亏了这些泛型集合。
- en: However, what if I want to express a query in a similar syntax to a SQL query?
    Or, simply, what if the complexity of the query doesn't make it easy to express
    it with the generic methods indicated so far?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我想用类似SQL查询的语法表达一个查询怎么办？或者，简单地说，如果查询的复杂性使得用迄今为止指示的泛型方法表达它变得困难怎么办？
- en: The solution came in form of a new syntax, inherent to the C# (and other .NET
    languages), called **LINQ** (**Language-Integrated Query**). The official definition
    presents this extension as *a set of features introduced in Visual Studio 2008
    that extends powerful query capabilities to the language syntax of C#*. Specifically,
    the authors highlight this feature as something that takes the form of *LINQ provider
    assemblies that enable the use of LINQ with .NET Framework collections, SQL Server
    databases, ADO.NET Datasets, and XML documents*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案以新的语法的形式出现，这种语法是C#（和其他.NET语言）特有的，称为**LINQ**（**语言集成查询**）。官方定义将这个扩展描述为*在Visual
    Studio 2008中引入的一组功能，它将强大的查询能力扩展到C#的语言语法中*。具体来说，作者强调这个特性是*一种以LINQ提供程序集的形式出现，它使得可以在.NET
    Framework集合、SQL Server数据库、ADO.NET数据集和XML文档中使用LINQ*。
- en: So, we are given a new SQL-like syntax to generate any kind of query in such
    a way that the same sentence structure is valid for very different data sources.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了一种新的类似SQL的语法，可以生成任何类型的查询，这样相同的句子结构对非常不同的数据源都是有效的。
- en: 'Remember that previously, data queries had to be expressed as strings without
    type checking at compile time or any kind of IntelliSense support, and it was
    mandatory to learn a different query language depending on the type of data source:
    SQL databases, XML documents, Web services, and so on.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 记得之前，数据查询必须以字符串的形式表达，编译时没有类型检查或任何类型的智能感知支持，并且必须根据数据源的类型学习不同的查询语言：SQL数据库、XML文档、Web服务等等。
- en: LINQ syntax is based on the SQL language
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LINQ语法基于SQL语言
- en: 'In this case, as Hejlsberg mentioned many times, they had to change the order
    of the clauses if they wanted to provide any kind of Intellisense, so a query
    of this type adopts the form of this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正如Hejlsberg多次提到的，如果他们想要提供任何类型的智能感知，他们必须改变子句的顺序，因此这种类型的查询采用以下形式：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this way, once the user specifies the source (a collection), Visual Studio
    is able to provide you with Intellisense for the rest of the sentence. For instance,
    in order to select a few numbers from a number list, such as the ones used in
    previous examples, we can write the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，一旦用户指定了源（一个集合），Visual Studio就能为您提供剩余句子的智能感知。例如，为了从一个数字列表中选择几个数字，例如在之前的例子中使用的那些，我们可以编写以下代码：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that we have used the `&&` operator to concatenate both conditions (we''ll
    go further into this in a bit), and there is no problem with using the LINQ syntax
    in conjunction with lambda expressions. Furthermore, it is recommended that you
    express the query in the more suitable, readable, and maintainable way. Of course,
    the output is still what is expected:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`&&`运算符来连接两个条件（我们稍后会进一步讨论这一点），并且在使用LINQ语法与lambda表达式结合时没有问题。此外，建议您以更合适、更易读、更易于维护的方式表达查询。当然，输出仍然是预期的：
- en: '![LINQ syntax is based on the SQL language](img/image00448.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![LINQ语法基于SQL语言](img/image00448.jpeg)'
- en: The only condition required for the collection is that it should support `IEnumerable`
    or the generic `IEnumerable<T>` interfaces (or any other interface that inherits
    from it).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集合的唯一条件是它应该支持`IEnumerable`或泛型的`IEnumerable<T>`接口（或任何从它继承的接口）。
- en: As you may expect, often, the collection is just a previously obtained collection
    of business logic objects as the result of a query to a database table.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，通常，集合只是之前从数据库表查询得到的一个业务逻辑对象集合。
- en: Deferred execution
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟执行
- en: 'However, there is a very important point to remember: the LINQ syntax itself
    uses a model called *deferred execution* or *lazy loaded*. This means that a query
    is not executed until the first bit of data is required by another sentence.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个非常重要的要点需要记住：LINQ 语法本身使用一种称为 *延迟执行* 或 *懒加载* 的模型。这意味着查询不会执行，直到需要第一份数据的其他句子。
- en: Anyway, we can force the execution by converting the resulting collection into
    a concrete collection, for example, by calling the `ToList()` method or requiring
    other data linked to the actual use of the collection, such as counting the number
    of rows returned.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们可以通过将结果集合转换为具体集合来强制执行，例如，通过调用 `ToList()` 方法或要求与集合实际使用相关的其他数据，例如计算返回的行数。
- en: 'This is something we can do by enclosing the LINQ query in parenthesis and
    applying the solicited operation (note that the value returned is automatically
    converted into the appropriate type), as shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以通过将 LINQ 查询括起来并应用所需操作（注意返回的值会自动转换为适当的类型）来完成的，如下面的截图所示：
- en: '![Deferred execution](img/image00449.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![延迟执行](img/image00449.jpeg)'
- en: 'In a similar way, we can order the resulting collection in an ascending (the
    default) or descending manner using the `ad-hoc` clause:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以使用 `ad-hoc` 子句以升序（默认）或降序对结果集合进行排序：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Joining and grouping collections
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入和分组集合
- en: In the same way as we mimic the syntax of SQL for other queries, it's perfectly
    possible to use other advanced features of the SQL language, such as grouping
    and joining several collections.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们模仿 SQL 语法进行其他查询的方式相同，我们可以使用 SQL 语言的其它高级功能，例如对多个集合进行分组和连接。
- en: 'For the first case (grouping), the syntax is fairly simple. We just have to
    indicate the grouping factor using the group / by / into clause in this manner:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况（分组），语法相当简单。我们只需使用这种方式通过 group / by / into 子句来指示分组因素：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that we use a nested loop to print the results (one for the groups of
    words and another for the words themselves). The previous code generates the following
    output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用嵌套循环来打印结果（一个用于单词组，另一个用于单词本身）。前面的代码生成了以下输出：
- en: '![Joining and grouping collections](img/image00450.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![加入和分组集合](img/image00450.jpeg)'
- en: For the case of joining, we use the `join` clause together with the `equals`,
    `as`, and `is` operators to express conditions for the junction.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接的情况，我们使用 `join` 子句以及 `equals`、`as` 和 `is` 操作符来表达连接的条件。
- en: A simple example could be the joining of two different sets of numbers in the
    search for common elements of any kind. Every set would express a unique condition
    and the join would establish the common factor.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子可以是连接两个不同的数字集合以寻找任何类型的公共元素。每个集合都会表达一个独特的条件，连接将建立公共因子。
- en: 'For instance, starting with our selected numbers (divisible by 3 and 7), let''s
    add another subset of those that start with 7:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从我们选定的数字（能被 3 和 7 整除）开始，让我们添加另一个以 7 开头的子集：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we have two different subsets with different conditions. We can find out
    which among them fulfills both conditions, expressing the requirement by means
    of a join between both subsets:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两组不同的子集，它们有不同的条件。我们可以找出它们中哪一个满足这两个条件，通过在两个子集之间进行连接来表达要求：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We find a total of five numbers that start with 7, both being multiples of
    3 and 7, as shown in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了总共五个以 7 开头的数字，它们既是 3 的倍数也是 7 的倍数，如下面的截图所示：
- en: '![Joining and grouping collections](img/image00451.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![加入和分组集合](img/image00451.jpeg)'
- en: Type projections
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型投影
- en: Another option (and a very interesting one) is the capability of projecting
    the required output to an anonymous type (inexistent), which is the result of
    a selection or which includes the creation of another calculated field.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项（一个非常有趣的选项）是将所需的输出投影到匿名类型（不存在）的能力，这是选择的结果或包括创建另一个计算字段。
- en: 'We perform this action by creating the anonymous output type in the `select`
    declaration of the LINQ query, with the capability of naming the desired results
    the way we want (just like when we create another anonymous type). For instance,
    if we need another column indicating the even or odd character of the resulting
    numbers, we can add the following expression to the previous query like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 LINQ 查询的 `select` 声明中创建匿名输出类型来执行此操作，具有以我们想要的方式命名所需结果的能力（就像我们创建另一个匿名类型时一样）。例如，如果我们需要另一个列来指示结果数字的偶数或奇数字符，我们可以在之前的查询中添加以下表达式，如下所示：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What follows the `select` clause is an anonymous type composed of two fields,
    `Num` and `DivBy2`, using a simple `?` operator expression, which checks the integer
    division by 2, the same way we did it earlier. The results look like what is shown
    in the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 子句之后是一个匿名类型，由两个字段组成，`Num` 和 `DivBy2`，使用简单的 `?` 操作符表达式，检查整数除以 2，这与我们之前所做的方式相同。结果看起来就像以下输出所示：'
- en: '![Type projections](img/image00452.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![类型投影](img/image00452.jpeg)'
- en: Besides auxiliary operations like these, the LINQ syntax is especially useful
    when dealing with databases. Just think of the source collections as return values
    obtained by querying a valid data origin, which—in all cases—will implement the
    `IEnumerable` and/or `IQueryable` interfaces, which is what happens when we access
    a real database engine using Entity framework, for example.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些辅助操作之外，LINQ 语法在处理数据库时特别有用。只需将源集合视为通过查询有效数据源获得的返回值，在所有情况下，这些数据源都将实现 `IEnumerable`
    和/或 `IQueryable` 接口，例如，当我们使用 Entity Framework 访问真实数据库引擎时就会发生这种情况。
- en: We will cover database access in the upcoming chapters, so just keep in mind
    this methodology that will be applied when we query real data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中介绍数据库访问，所以请记住当我们查询真实数据时将应用此方法。
- en: Extension methods
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法
- en: Finally, we can extend existing classes' functionality. This means extending
    even the .NET Framework base types, such as `int` or `String`. This is a very
    useful feature, and it's performed in the way it is recommended by the documentation;
    no violation of basic principles of OOP occurs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以扩展现有类的功能。这意味着甚至可以扩展 .NET 框架的基类型，如 `int` 或 `String`。这是一个非常有用的功能，并且按照文档中推荐的方式执行；没有违反
    OOP 的基本原理。
- en: The procedure is fairly simple. We need to create a new public static top level
    (not nested) class containing a public static method with an initial argument
    declaration especially suited for the compiler to assume that the compiled code
    will be appended to the actual functionality of the type.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程相当简单。我们需要创建一个新的公共静态顶级（非嵌套）类，其中包含一个公共静态方法，具有一个特别适合编译器假设编译后的代码将被附加到类型的实际功能上的初始参数声明。
- en: The procedure can be used with any class, either belonging to the .NET framework
    or a customized user or class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以与任何类一起使用，无论是属于 .NET 框架还是自定义用户或类。
- en: 'Once we have the declaration, its usage is fairly simple, as shown in this
    code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了声明，其使用方法相当简单，如下所示：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the first argument, referred with the `this` keyword, references
    the string to be used; so, in this example, we will call the method without any
    extra arguments (although we can pass as many arguments as we need for other extensions).
    To put it to work, we just have to add something like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个参数，使用 `this` 关键字引用，指的是将要使用的字符串；因此，在这个例子中，我们将不带任何额外参数调用该方法（尽管我们可以传递我们需要的任何数量的参数用于其他扩展）。为了使其发挥作用，我们只需添加如下内容：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will get the extended output with the word enclosed in double brackets:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到包含在双括号中的扩展输出：
- en: '![Extension methods](img/image00453.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![扩展方法](img/image00453.jpeg)'
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw some of the most relevant enhancements made to the C#
    language in versions 2 and 3.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了在版本 2 和 3 中对 C# 语言所做的最相关的增强。
- en: We started by reviewing the main differences between C# and other languages
    and understanding the meaning of strongly typed, in this case, together with the
    concepts of static and dynamic.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先回顾了 C# 与其他语言之间的主要区别，并理解了强类型化的含义，在这种情况下，与静态和动态的概念一起。
- en: Then, we explained some of the main reasons behind the creation of the concept
    of delegates—absolutely crucial in .NET—and whose origins were motivated by very
    serious and solid architectural reasons. We also revised .NET usage in several
    common programming scenarios.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们解释了创建委托概念背后的主要原因——在 .NET 中绝对至关重要，其起源是由非常严肃和稳固的架构原因所激发的。我们还回顾了在几个常见的编程场景中
    .NET 的使用。
- en: We followed this up with an examination of the generics feature that appeared
    in version 2.0 of the framework and analyzed some samples to illustrate some typical
    use cases, including the creation of custom generic methods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后对框架版本 2.0 中出现的泛型功能进行了检查，并分析了几个示例来展示一些典型的用例，包括创建自定义泛型方法。
- en: From generics, we moved on to Lambda expressions, which appeared in the version
    that follows, allowing us to simplify calls to generic methods by passing anonymous
    methods expressed in a very elegant syntax.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从泛型到 Lambda 表达式，后者出现在后续版本中，它允许我们通过传递以非常优雅的语法表达的匿名方法来简化对泛型方法的调用。
- en: Finally, we covered the LINQ syntax, which permits the implementation of complex
    queries to a collection in a way that strongly reminds you about the SQL syntax
    you surely know and use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 LINQ 语法，它允许以类似于您所熟知和使用的 SQL 语法的方式对集合执行复杂查询。
- en: We ended with a simple extension method to check how we can use the existing
    functionality in order to extend its default methods in a way that suits our programming
    requirements without affecting the original definitions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个简单的扩展方法结束，这个方法展示了如何使用现有功能来扩展其默认方法，以满足我们的编程需求，同时不影响原始定义。
- en: In the next chapter, we'll look at news and enhancements that appeared in the
    recent versions of the framework (4, 4.5, and 4.6), which include dynamic definitions,
    improved logical expressions, new operators, and so on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨框架最近版本（4、4.5 和 4.6）中出现的新功能和增强，包括动态定义、改进的逻辑表达式、新运算符等。
