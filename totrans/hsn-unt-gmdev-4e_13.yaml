- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: 'Material Alchemy: Using URP and Shader Graph for Stunning Visuals'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质炼金术：使用URP和Shader Graph创建惊人的视觉效果
- en: Welcome to the first chapter of *Section 3*, *Elevating Visuals, Effects, and
    Audio* Here, we will dive deep into the different graphics and audio systems of
    Unity to dramatically improve the look and feel of the game. Let’s begin our journey
    into the world of shaders, the artists behind the scenes in every Unity game,
    and learn how to craft our own from scratch. We will start by discussing what
    a shader is and how to create our own to achieve several custom effects that couldn’t
    be accomplished using the default Unity shaders. We will be creating a simple
    water animation effect using Shader Graph, a visual shader editor included in
    the Universal Render Pipeline (URP), the preferred option for creators to launch
    their games on a wide variety of devices, including web and mobile. Also known
    as URP, this is one of the different rendering pipelines available in Unity, which
    provides rendering features oriented toward performance. We will be discussing
    some of its capabilities in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第3部分*提升视觉效果、效果和音频*的第一章。在这里，我们将深入探讨Unity的不同图形和音频系统，以显著提升游戏的外观和感觉。让我们开始我们的着色器世界之旅，着色器是每个Unity游戏背后的艺术家，我们将学习如何从头开始制作自己的着色器。我们将从讨论什么是着色器以及如何创建自己的着色器以实现一些默认Unity着色器无法实现的自定义效果开始。我们将使用Shader
    Graph创建一个简单的水动画效果，Shader Graph是包含在通用渲染管道（URP）中的可视化着色器编辑器，是创作者将游戏发布到包括网页和移动设备在内的各种设备上的首选选项。也称为URP，这是Unity中可用的不同渲染管道之一，它提供面向性能的渲染功能。我们将在本章中讨论其一些功能。
- en: 'In this chapter, we will examine the following shader concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下着色器概念：
- en: Introducing shaders and URP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍着色器和URP
- en: Creating shaders with Shader Graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shader Graph创建着色器
- en: Introducing shaders and URP
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍着色器和URP
- en: Remember the glowing orb material we created in *Section 1*, *Getting Started
    with Unity*? Let’s explore how its shader property manipulates light to create
    that glow effect. In this first section, we will be exploring the concept of a
    shader as a way to program the video card to achieve custom visual effects. We
    will also be discussing how URP works with those shaders, and the default shaders
    it provides.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在*第1部分，Unity入门*中创建的那个发光球体材质吗？让我们探索其着色器属性如何操纵光线以创建那种发光效果。在本节中，我们将探讨着色器作为编程显卡以实现自定义视觉效果的方法。我们还将讨论URP如何与这些着色器一起工作，以及它提供的默认着色器。
- en: 'In this section, we will cover the following concepts related to shaders:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与着色器相关的以下概念：
- en: Shader pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器管道
- en: Render pipeline and URP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染管道和URP
- en: URP built-in shaders
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URP内置着色器
- en: Let’s start by discussing how a shader modifies the shader pipeline to achieve
    effects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一下着色器如何修改着色器管道以实现效果。
- en: Shader pipeline
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器管道
- en: Whenever a video card renders a 3D model, it needs different information to
    process, such as a **mesh**, **textures**, the transformation of the object (position,
    rotation, and scale), and lights that affect the object. With that data, the video
    card must output the pixels of the object into the **back buffer**, an image where
    the video card will be drawing our objects, but the user won’t see this yet. This
    is done to prevent the user from seeing unfinished results, given we can still
    be drawing at the time the monitor refreshes. That image will be shown when Unity
    finishes rendering all objects (and some effects) to display the finished scene,
    swapping the **back buffer** with the **front buffer**, the image that the user
    actually sees. You can imagine this as having a page with an image that is being
    shown to the user while you draw a new image, and when you finish the new drawing,
    you just swap the pages and start drawing again on the page the user does not
    see, repeating this with every frame.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当显卡渲染3D模型时，它需要不同的信息来处理，例如**网格**、**纹理**、对象的变换（位置、旋转和缩放）以及影响对象的光线。有了这些数据，显卡必须将对象的像素输出到**后缓冲区**，这是一个显卡将要绘制我们的对象但用户还看不到的图像。这样做是为了防止用户看到未完成的结果，因为我们在显示器刷新时仍在绘制。当Unity完成所有对象（和一些效果）的渲染以显示完成的场景时，将**后缓冲区**与用户实际看到的**前缓冲区**交换，这时图像才会显示出来。你可以想象这就像有一页带有图像的页面，在向用户展示图像的同时，你在绘制新的图像，当你完成新的绘制后，你只需交换页面，然后在用户看不到的页面上重新开始绘制，每帧重复这个过程。
- en: That’s the usual way to render an object, but what happens between the input
    of the data and the output of the pixels can be handled in a myriad of different
    ways and techniques that depend on how you want your object to look; maybe you
    want it to be realistic or look like a hologram, or maybe the object needs a disintegration
    effect or a toon effect—there are endless possibilities. The way to specify how
    our video card will handle the rendering of the object is through a shader.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是渲染对象的方式，但从数据输入到像素输出的过程中可以采用无数种不同的方法和技巧来处理，这取决于你希望对象看起来如何；可能你希望它看起来逼真，或者像全息图一样，或者可能对象需要分解效果或卡通效果——可能性无穷无尽。指定我们的显卡如何处理对象渲染的方式是通过着色器来实现的。
- en: 'A **shader** is a program coded in specific video card languages, such as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器**是一种用特定显卡语言编写的程序，例如：'
- en: '**HLSL**: The DirectX shading language, DirectX being a graphics library.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HLSL**：DirectX着色语言，DirectX是一个图形库。'
- en: '**GLSL**: The OpenGL shading language, OpenGL also being a graphics library.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLSL**：OpenGL着色语言，OpenGL也是一个图形库。'
- en: '**CG**: A language that can output either HLSL or GLSL, depending on which
    graphics library we use in our game.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CG**：一种可以输出HLSL或GLSL的语言，取决于我们在游戏中使用哪个图形库。'
- en: '**Shader Graph**: A visual language that will be automatically converted into
    one of the previously mentioned languages according to our needs. This is the
    one we will be using given its simplicity (more on that later).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器图**：一种将根据我们的需求自动转换为之前提到的一种语言的视觉语言。这是我们将会使用的一种，因为它简单（后面会详细介绍）。'
- en: Any of those languages can be used to configure different stages of the render
    process necessary to render a given object, sometimes not only configuring them
    but also replacing them with completely custom code to achieve the exact effect
    we want. All of the stages to render an object make up what we call the shader
    pipeline, a chain of modifications applied to the input data until it is transformed
    into pixels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言中的任何一种都可以用来配置渲染给定对象所需的渲染过程的各个阶段，有时不仅配置它们，还可以用完全定制的代码来替换它们，以实现我们想要的确切效果。渲染一个对象的各个阶段构成了我们所说的着色器管线，这是一系列应用于输入数据的修改，直到将其转换为像素。
- en: 'Each stage of the pipeline is in charge of different modifications, and depending
    on the video card shader model, this pipeline can vary a lot. In the next diagram,
    you can find a simplified shader pipeline, skipping advanced/optional stages that
    are not important right now:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 管线中的每个阶段负责不同的修改，并且根据显卡的着色器模型，这个管线可能会有很大的变化。在下一张图中，你可以找到一个简化的着色器管线，跳过了现在不重要的高级/可选阶段：
- en: '![A blue rectangle with black text  Description automatically generated with
    low confidence](img/B21361_10_01_PE.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![一个蓝色矩形，上面有黑色文字  描述由低置信度自动生成](img/B21361_10_01_PE.png)'
- en: 'Figure 10.1: Common shader pipeline'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：常见的着色器管线
- en: Think of the shader pipeline as an assembly line in a factory, where each stage
    represents a different worker specializing in a specific task, collectively contributing
    to the final product.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将着色器管线想象成工厂中的一条装配线，其中每个阶段代表一位专注于特定任务的工人，他们共同协作完成最终产品。
- en: 'Let’s discuss each of the stages:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个阶段：
- en: '**Input Assembler**: Here is where all of the mesh data, such as vertex position,
    UVs, and normals, is assembled to be prepared for the next stage.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入汇编器**：在这里，所有网格数据，如顶点位置、UV和法线，被组装起来，为下一阶段做准备。'
- en: '**Vertex Shader**: This stage used to be limited to applying the transformation
    of the object, the position and perspective of the camera, and simple lighting
    calculations. In modern GPUs, you are in charge of doing whatever you want. This
    stage receives each of the vertices of the object to render and outputs a modified
    one. You have the chance to modify the geometry of the object here. The usual
    code here applies the transform of the object, but you can also apply several
    effects, such as inflating the object along its normals to apply the old toon
    effect technique or apply distortion, adding random offsets to each vertex to
    recreate a hologram. There’s also the opportunity to calculate data for the next
    stages.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这个阶段过去仅限于应用对象的变换、摄像机的位置和透视以及简单的光照计算。在现代GPU中，你可以做任何你想做的事情。这个阶段接收要渲染的对象的每个顶点，并输出一个修改后的顶点。你有机会在这里修改对象的几何形状。这里的常用代码应用对象的变换，但你也可以应用多种效果，例如沿着法线膨胀对象以应用旧的卡通效果技术，或者应用扭曲，为每个顶点添加随机偏移以重新创建全息图。还有机会计算下一阶段所需的数据。'
- en: '**Primitive Culling**: Most of the models you are going to render have the
    particularity that you will never see the back side of a model face. With a cube,
    there’s no way to look at its inner sides. Given that, rendering both sides of
    each face of the cube makes no sense, and this stage takes care of that. Primitive
    culling will determine whether the face needs to be rendered based on the orientation
    of the face, saving lots of pixel calculation of occluded faces. You can change
    this to behave differently for specific cases; as an example, we can create a
    glass box that needs to be transparent to see all sides of the box. Don’t confuse
    this with other types of culling, like frustum culling. This other type of culling
    filters objects outside the camera view area before they are even sent to the
    shader pipeline.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原语裁剪**: 您将要渲染的大多数模型具有一个特性，那就是您永远不会看到模型面的背面。对于一个立方体来说，没有方法可以看到它的内部侧面。鉴于这一点，渲染立方体每个面的两面是没有意义的，这个阶段就负责处理这个问题。原语裁剪将根据面的方向确定是否需要渲染面，从而节省大量被遮挡面的像素计算。您可以更改此设置以适应特定情况；例如，我们可以创建一个需要透明以看到盒子所有面的玻璃盒子。不要将此与其他类型的裁剪混淆，如视锥裁剪。这种其他类型的裁剪在将对象发送到着色器管道之前，会过滤掉相机视图区域外的对象。'
- en: '**Rasterizer**: Now that we have the modified and visible geometry of our model
    calculated, it’s time to convert it into pixels. The rasterizer creates all pixels
    for the triangles of our mesh. Lots of things happen here, but again, we have
    very little control over that; the usual way to rasterize is just to create all
    pixels inside the edges of the mesh triangles. We have other modes that just render
    the pixels on the edges to see a wireframe effect, but this is usually used for
    debugging purposes:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光栅化器**: 现在我们已经计算出了模型修改后的可见几何形状，是时候将其转换为像素了。光栅化器为我们的网格三角形创建所有像素。这里发生了很多事情，但同样，我们对这些事情的控制非常有限；通常的渲染方法是仅创建网格三角形边缘内的所有像素。我们还有其他模式，仅渲染边缘上的像素以看到线框效果，但这通常用于调试目的：'
- en: '![Image result for rasterizer](img/B21361_10_02_PE.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![光栅化器图像结果](img/B21361_10_02_PE.png)'
- en: 'Figure 10.2: Example of figures being rasterized'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：图元光栅化的示例
- en: '**Fragment Shader**: This is one of the most customizable stages of all. Its
    purpose is simple: just determine the color of each of the fragments (pixels)
    that the rasterizer has generated. Here, lots of things can happen, from simply
    outputting a plain color or sampling a texture to applying complex lighting calculations
    such as normal mapping and PBR. Also, you can use this stage to create special
    effects such as water animations, holograms, distortions, disintegrations, and
    any special effects that require you to modify what the pixels look like. We will
    explore how we can use this stage in the next sections of this chapter.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**: 这是所有阶段中最可定制的之一。它的目的是简单的：只是确定光栅化器生成的每个片段（像素）的颜色。在这里，可以发生很多事情，从简单地输出纯色或采样纹理到应用复杂的照明计算，如法线贴图和PBR。此外，您还可以使用这个阶段创建特殊效果，例如水动画、全息图、扭曲、分解以及任何需要您修改像素外观的特殊效果。我们将在本章的下一节中探讨如何使用这个阶段。'
- en: '**Depth Testing**: Before showing a pixel on the screen, we need to check whether
    it can be seen. This stage checks whether the pixel’s depth is behind or in front
    of the previous pixel rendered in the same position, guaranteeing that, regardless
    of the rendering order of the objects, the nearest pixels to the camera are always
    drawn on top of others. Again, usually, this stage is left in its default state,
    prioritizing pixels that are nearer to the camera, but some effects require different
    behavior. Also, nowadays we have **early-Z testing**, which does this same test
    but before the Fragment Shader stage. But let’s keep things simple for now. As
    an example, in the next screenshot, you can see an effect that allows you to see
    objects that are behind other objects, like the one used in *Age of Empires* when
    a unit is behind a building:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度测试**: 在屏幕上显示像素之前，我们需要检查它是否可见。这个阶段检查像素的深度是在之前在同一位置渲染的像素之前还是之后，确保无论对象的渲染顺序如何，离相机最近的像素总是绘制在其他像素之上。同样，通常这个阶段会保留默认状态，优先考虑离相机更近的像素，但某些效果需要不同的行为。此外，如今我们还有**早期Z测试**，它在这个阶段之前执行相同的测试。但让我们现在保持简单。例如，在下一张屏幕截图中，您可以看到一个效果，允许您看到位于其他对象后面的对象，就像在*帝国时代*中，一个单位在建筑物后面时的情况：'
- en: '![Image result for occluded effect shader](img/B21361_10_03_PE.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![遮挡效果着色器图像结果](img/B21361_10_03_PE.png)'
- en: 'Figure 10.3: Rendering the occluded parts of the character'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：渲染角色的遮挡部分
- en: '**Blending**: Once the color of the pixel is determined and we are sure the
    pixel is not occluded by a previous pixel, the final step is to put it in the
    back buffer (the frame or image you are drawing). Usually, we just override whatever
    pixel was in that position (because our pixel is nearer to the camera), but if
    you think about transparent objects, we need to combine our pixel with the previous
    one to make the transparent effect. Transparencies have other things to take into
    account aside from the blending, but the main idea is that blending controls exactly
    how the pixel will be combined with the previously rendered pixel in the back
    buffer.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：一旦确定了像素的颜色并且我们确信该像素没有被之前的像素遮挡，最后的步骤就是将其放入后缓冲区（你正在绘制的帧或图像）。通常，我们只是覆盖掉该位置上原有的像素（因为我们的像素更靠近相机），但如果考虑透明物体，我们需要将我们的像素与之前的像素结合，以产生透明效果。透明度除了混合之外还有其他需要考虑的因素，但主要思想是混合精确控制像素如何与后缓冲区中之前渲染的像素结合。'
- en: Shader pipelines would require an entire book to cover, but for the scope of
    this book, the previous description will give you a good idea of what a shader
    does, and the possible effects that it can achieve. Now that we have discussed
    how a shader renders a single object, it is worth discussing how Unity renders
    all of the objects using the render pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器管线需要整本书来涵盖，但就本书的范围而言，前面的描述将给你一个关于着色器做什么以及它能实现的可能效果的良好概念。现在我们已经讨论了着色器如何渲染单个对象，值得讨论Unity如何使用渲染管线渲染所有对象。
- en: 'For more information about shaders, you can use the following link: [https://docs.unity3d.com/Manual/shader-writing.html](https://docs.unity3d.com/Manual/shader-writing.html)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于着色器的更多信息，你可以使用以下链接：[https://docs.unity3d.com/Manual/shader-writing.html](https://docs.unity3d.com/Manual/shader-writing.html)
- en: Render pipeline and URP
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染管线和URP
- en: We have covered how the video card renders an object, but Unity is in charge
    of asking the video card to execute a shader pipeline per object. To do so, Unity
    needs to do lots of preparations and calculations to determine exactly how and
    when each shader needs to be executed. The responsibility of doing this is with
    what Unity calls the render pipeline.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了视频卡如何渲染一个对象，但Unity负责要求视频卡为每个对象执行一个着色器管线。为此，Unity需要进行大量的准备工作并计算，以确定每个着色器确切地何时以及如何执行。执行这一职责的是Unity所说的渲染管线。
- en: Think of Unity’s render pipeline like a film director orchestrating how each
    scene (object) is presented, with URP as one of its advanced cameras, optimizing
    how each shot is captured. Also, think of the render pipeline as the stage crew
    of a theater, setting the scene and lighting for each object (actor) to ensure
    they look the best under the spotlight.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将Unity的渲染管线想象成一个电影导演，负责如何呈现每个场景（对象），其中URP就像其高级相机之一，优化每个镜头的捕捉。同时，将渲染管线想象成剧院的舞台工作人员，为每个对象（演员）设置场景和灯光，以确保他们在聚光灯下看起来最好。
- en: A render pipeline is a way to draw the objects of the scene. At first, it sounds
    like there should be just one simple way of doing this, for example, iterating
    over all objects in the scene and executing the shader pipeline with the shader
    specified in each object’s material, but it can be more complex than that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管线是绘制场景中对象的一种方式。起初，这听起来应该只有一个简单的方法来做这件事，例如，遍历场景中的所有对象，并使用每个对象材质中指定的着色器执行着色器管线，但它可能比这更复杂。
- en: Usually, the main difference between one render pipeline and another is the
    way in which lighting and some advanced effects are calculated, but they can differ
    in other ways.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个渲染管线与另一个渲染管线之间的主要区别在于光照和一些高级效果的计算方式，但它们在其他方面也可能有所不同。
- en: In previous Unity versions, there was just one single render pipeline, which
    is now called the **built-in renderer pipeline** (also known as **BIRP**). It
    was a pipeline that had all of the possible features you would need for all kinds
    of projects, from mobile 2D graphics and simple 3D to cutting-edge 3D graphics
    like the ones you can find in consoles or high-end PCs. This sounds ideal, but
    actually, it isn’t. Having one single giant renderer that needs to be highly customizable
    to adapt to all possible scenarios generates lots of overhead and limitations
    that cause more headaches than creating a custom render pipeline. Luckily, the
    last versions of Unity introduced the **Scriptable Render Pipeline** (**SRP**),
    a way to create a render pipeline adapted to your project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Unity版本中，只有一个单一的渲染管线，现在被称为**内置渲染管线**（也称为**BIRP**）。这是一个包含所有可能需要的功能的管线，适用于各种项目，从移动2D图形和简单的3D到像在游戏机或高端PC上找到的尖端3D图形。这听起来很理想，但实际上并非如此。拥有一个需要高度可定制以适应所有可能场景的单一大型的渲染器会产生大量的开销和限制，这比创建一个自定义渲染管线要麻烦得多。幸运的是，Unity的最新版本引入了**可脚本渲染管线**（**SRP**），这是一种创建适合您项目渲染管线的方法。
- en: 'Luckily, Unity doesn’t want you to create your own render pipeline for each
    project (which is a complex task), so it has created two custom pipelines for
    you that are ready to use: **URP** (formerly called LWRP, or Lightweight Render
    Pipeline), which stands for **Universal Render Pipeline**, and **HDRP**, which
    stands for **High Definition Render Pipeline**. The idea is that you must choose
    one or the other based on your project’s requirements (unless you really need
    to create your own).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Unity不希望您为每个项目创建自己的渲染管线（这是一个复杂的工作），因此它为您创建了两个可用的自定义管线：**URP**（以前称为LWRP，或轻量级渲染管线），代表**通用渲染管线**，以及**HDRP**，代表**高清渲染管线**。想法是您必须根据项目需求选择其中一个（除非您真的需要创建自己的）。
- en: 'URP, the one we selected when creating the project for our game, is a render
    pipeline suitable for most games that don’t require lots of advanced graphics
    features, such as mobile games or simple PC games, while HDRP is packed with lots
    of advanced rendering features for high-quality games. The latter requires high-end
    hardware to run, while URP runs on almost every relevant target device. It is
    worth mentioning that you can swap between BIRP, HDRP, and URP whenever you want,
    including after creating the project (but this is not recommended):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: URP，我们在创建游戏项目时选择的一个渲染管线，适用于大多数不需要大量高级图形功能的游戏，如移动游戏或简单的PC游戏，而HDRP则包含大量高级渲染功能，适用于高质量游戏。后者需要高端硬件才能运行，而URP几乎可以在所有相关目标设备上运行。值得一提的是，您可以在任何时候（包括在创建项目之后）在BIRP、HDRP和URP之间切换（但不推荐这样做）：
- en: '![](img/B21361_10_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_04.png)'
- en: 'Figure 10.4: Project wizard showing HDRP and URP templates'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：项目向导显示HDRP和URP模板
- en: We could discuss how each one is implemented and the differences between each,
    but again, this could fill entire chapters. Right now, the idea of this section
    is for you to know why we picked URP when we created our project; it has some
    restrictions we will encounter throughout this book that we will need to take
    into account, so it is good to know why we accepted those limitations. One reason
    we chose it was that it allows us to run our game on all relevant hardware.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以讨论每个是如何实现的以及它们之间的区别，但同样，这可能会填满整个章节。目前，本节的想法是让您知道为什么我们在创建项目时选择了URP；我们在本书中会遇到一些限制，我们需要考虑这些限制，所以了解我们为什么接受这些限制是好的。我们选择它的一个原因是可以让我们在所有相关硬件上运行我们的游戏。
- en: 'Another reason why we have chosen URP is that it has support for Shader Graph,
    the Unity tool that we will be using in this chapter to create custom effects.
    Previous Unity built-in pipelines didn’t provide us with such a tool (aside from
    third-party plugins). Finally, another reason to introduce the concept of URP
    is that it comes with lots of built-in shaders that we will need to know about
    before creating our own to prevent reinventing the wheel. This will allow us to
    get used to those shaders, because if you came from previous versions of Unity,
    the shaders you already know won’t work here; actually, this is exactly what we
    are going to discuss in the next section of this chapter: the difference between
    the different URP built-in shaders.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择URP的另一个原因是它支持Shader Graph，这是我们在本章中使用的Unity工具，用于创建自定义效果。之前的Unity内置管线没有提供这样的工具（除了第三方插件）。最后，引入URP概念的另一个原因是它附带了许多内置着色器，在创建我们自己的着色器之前，我们需要了解这些着色器，以避免重复造轮子。这将使我们熟悉这些着色器，因为如果你来自Unity的早期版本，你已知的着色器在这里将不起作用；实际上，这正是我们将在本章下一节讨论的内容：不同URP内置着色器之间的区别。
- en: URP built-in shaders
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URP内置着色器
- en: 'Now that we know the difference between URP and other pipelines, let’s discuss
    which shaders are integrated into URP. Let’s briefly describe the three most important
    shaders in this pipeline:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了URP与其他管线之间的区别，让我们来讨论哪些着色器被集成到URP中。让我们简要描述这个管线中三个最重要的着色器：
- en: '**Lit**: This is the replacement of the old Standard Shader. This shader is
    useful for creating all kinds of realistic physics materials, such as wood, rubber,
    metal, skin, and combinations of them (such as a character with skin and metal
    armor). It supports features like normal mapping, occlusion, different lighting
    workflows like Metallic and Specular, and transparencies.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lit**: 这是旧版标准着色器的替代品。这个着色器适用于创建各种逼真的物理材质，例如木材、橡胶、金属、皮肤以及它们的组合（例如带有皮肤和金属护甲的角色）。它支持诸如法线贴图、遮挡、金属和镜面等不同的光照工作流程以及透明度等功能。'
- en: '**Simple Lit**: This is the replacement of the old Mobile/Diffuse Shader. As
    the name suggests, this shader is a simpler version of Lit, meaning that its lighting
    calculations are simpler approximations of how light works, with fewer features
    than its counterpart. Basically, when you have simple graphics without realistic
    lighting effects, this is the best choice.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Simple Lit**: 这是旧版Mobile/Diffuse着色器的替代品。正如其名所示，这个着色器是Lit的一个简化版本，意味着它的光照计算是对光照工作原理的简单近似，比其对应版本具有更少的功能。基本上，当你有简单的图形而没有逼真的光照效果时，这是最佳选择。'
- en: '**Unlit**: This is the replacement of the old Unlit/Texture Shader. Sometimes,
    you need objects with no lighting whatsoever, and in that case, this is the shader
    for you. No lighting doesn’t mean an absence of light or complete darkness; it
    actually means that the object has no shadows at all, and it’s fully visible without
    any shade. Some simplistic graphics can work with this, relying on shadowing being
    baked in the texture, meaning that the texture comes with the shadow.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unlit**: 这是旧版Unlit/Texture着色器的替代品。有时，你需要完全没有光照的对象，在这种情况下，这个着色器就是为你准备的。没有光照并不意味着没有光或完全黑暗；实际上，这意味着对象完全没有阴影，并且在没有阴影的情况下完全可见。一些简单的图形可以使用这个着色器，依靠纹理中烘焙的阴影，这意味着纹理自带阴影。'
- en: 'This is extremely performant, especially for low-end devices such as mobile
    phones. Also, you have other cases such as light tubes or screens, objects that
    can’t receive shadows because they emit light, so they will be seen at their full
    color even in complete darkness. In the following screenshot, you can see a 3D
    model using an Unlit Shader. It looks like it’s being lit, but it’s just the texture
    of the model that applied lighter and darker colors in different parts of the
    object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这在性能上非常出色，尤其是对于低端设备，如手机。还有其他情况，例如光管或屏幕，这些不能接收阴影的对象因为它们会发光，所以即使在完全黑暗中，它们也会以全色显示。在下面的屏幕截图中，你可以看到一个使用Unlit着色器的3D模型。它看起来像是有光照，但实际上只是模型纹理在不同部分应用了浅色和深色颜色：
- en: '![A picture containing design  Description automatically generated](img/B21361_10_05_PE.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![包含设计描述的图片自动生成](img/B21361_10_05_PE.png)'
- en: 'Figure 10.5: Pod using an Unlit effect to simulate cheap lighting'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：使用Unlit效果模拟廉价光照的Pod
- en: 'Let’s do an interesting disintegration effect with the Simple Lit Shader to
    demonstrate its capabilities. You must do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Simple Lit着色器做一个有趣的分解效果，以展示其功能。你必须执行以下操作：
- en: 'Begin by sourcing a **Cloud Noise** texture. You can find suitable textures
    on various free asset websites. Ensure the texture’s resolution and format are
    compatible with Unity for optimal results:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先获取一个**Cloud Noise**纹理。你可以在各种免费资产网站上找到合适的纹理。确保纹理的分辨率和格式与Unity兼容，以获得最佳效果：
- en: '![Image result for cloud noise texture](img/B21361_10_06_PE.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![云噪声纹理的结果图像](img/B21361_10_06_PE.png)'
- en: 'Figure 10.6: Noise texture'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：噪声纹理
- en: Select the recently imported texture in the **Project** panel.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中选择最近导入的纹理。
- en: In the Inspector, set the **Alpha Source** property to **From Gray Scale**.
    This will make the alpha channel of the texture be calculated based on the grayscale
    of the image. We will use the calculated alpha value to determine which pixels
    need to be deintegrated first (the darker ones first):![A screenshot of a computer  Description
    automatically generated with medium confidence](img/B21361_10_07_PE.png)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将**Alpha源**属性设置为**从灰度**。这将使纹理的alpha通道根据图像的灰度进行计算。我们将使用计算出的alpha值来确定哪些像素需要首先分解（首先是较暗的像素）：![计算机截图  描述自动生成，置信度中等](img/B21361_10_07_PE.png)
- en: 'Figure 10.7: Applying the Alpha Source From Gray Scale texture setting'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.7：应用Alpha源从灰度纹理设置
- en: The alpha channel of a color is often associated with transparency, but you
    will notice that our object won’t be transparent. The alpha channel is extra color
    data that can be used for several purposes when creating effects. In this case,
    we will use it to determine which pixels are being disintegrated first.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 颜色的alpha通道通常与透明度相关联，但你会注意到我们的物体不会是透明的。alpha通道是额外的颜色数据，在创建效果时可以用于多个目的。在这种情况下，我们将使用它来确定哪些像素首先被分解。
- en: 'Click the **+** icon in the **Project** view and select **Material.** You can
    rename it, giving it a name that makes it easier to find later:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中点击**+**图标，并选择**材质**。你可以重命名它，给它一个更容易找到的名字：
- en: '![](img/B21361_10_08.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_08.png)'
- en: 'Figure 10.8: Material creation button'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：材质创建按钮
- en: 'Create a cube by going to the top menu and selecting **GameObject | 3D Object
    | Cube**:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过顶部菜单选择**GameObject | 3D Object | Cube**来创建一个立方体：
- en: '![](img/B21361_10_09.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_09.png)'
- en: 'Figure 10.9: Cube primitive creation'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：创建立方体原语
- en: Drag the material from the **Project** window to the cube in the **Scene** window.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质从**项目**窗口拖动到**场景**窗口中的立方体上。
- en: 'Click in the drop-down menu at the right of the **Shader** property in the
    Inspector and look for the **Universal Render Pipeline | Simple Lit** option.
    We could also work with the default shader (**Lit**), but **Simple Lit** is going
    to be easier on performance, and we don’t need the advanced features of **Lit**:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中**Shader**属性右侧的下拉菜单中点击，查找**Universal Render Pipeline | Simple Lit**选项。我们也可以使用默认的着色器（**Lit**），但**Simple
    Lit**对性能的影响更小，我们也不需要**Lit**的高级功能：
- en: '![](img/B21361_10_10.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_10.png)'
- en: 'Figure 10.10: Simple Lit Shader selection'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：简单Lit着色器选择
- en: Next, select the newly created material in your project. Drag and drop the downloaded
    `Cloud Noise` texture into the **Base Map** section. This step visually binds
    your texture to the shader, enabling the disintegration effect.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择项目中新建的材质。将下载的`Cloud Noise`纹理拖放到**基础贴图**部分。这一步将纹理视觉上绑定到着色器上，启用分解效果。
- en: Enable the **Alpha Clipping** option and adjust the **Threshold** slider to
    `0.5`. **Alpha Clipping** plays a critical role in how the shader interprets texture
    transparency, influencing the disintegration effect’s appearance.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**Alpha裁剪**选项，并将**阈值**滑块调整到`0.5`。**Alpha裁剪**在着色器解释纹理透明度方面起着关键作用，影响着分解效果的显示。
- en: '![](img/B21361_10_11.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_11.png)'
- en: 'Figure 10.11: Alpha Clipping Threshold material slider'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：Alpha裁剪阈值材质滑块
- en: 'As you move the **Threshold** slider, the object will start to disintegrate.
    **Alpha Clipping** discards pixels that have less alpha intensity than the **Threshold**
    value:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你移动**阈值**滑块时，物体将开始分解。**Alpha裁剪**会丢弃alpha强度低于**阈值**值的像素：
- en: '![A black and white cube  Description automatically generated with medium confidence](img/B21361_10_12_PE.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![黑白立方体  描述自动生成，置信度中等](img/B21361_10_12_PE.png)'
- en: 'Figure 10.12: Disintegration effect with Alpha Clipping'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：使用Alpha裁剪的分解效果
- en: 'Finally, set **Render Face** to **Both** to see both sides of the cube’s faces:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**渲染面**设置为**两面**以查看立方体面的两侧：
- en: '![](img/B21361_10_13.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_13.png)'
- en: 'Figure 10.13: Double-sided render face'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：双面渲染面
- en: 'Take into account that the artist that creates the texture can configure the
    **Alpha** channel manually instead of calculating it from the grayscale, just
    to control exactly how the disintegration effect must look regardless of the texture’s
    color distribution:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，创建纹理的艺术家可以手动配置**Alpha**通道，而不是从灰度值计算它，以便精确控制分解效果的外观，无论纹理的颜色分布如何：
- en: '![A black and white cube  Description automatically generated with medium confidence](img/B21361_10_14_PE.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![黑白立方体  使用中等置信度自动生成的描述](img/B21361_10_14_PE.png)'
- en: 'Figure 10.14: Double-sided Alpha Clipping'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：双面Alpha裁剪
- en: The idea of this section is not to give a comprehensive guide of all of the
    properties of all URP shaders but to give you an idea of what a shader can do
    when properly configured and when to use each of the integrated shaders. Sometimes,
    you can achieve the effect you need just by using existing shaders, probably in
    99% of cases in simple games, so try to stick to them as much as you can. But
    if you really need to create a custom shader to create a very specific effect,
    the next section will teach you how to use the URP tool called Shader Graph.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的不是提供所有URP着色器的所有属性的全面指南，而是给你一个概念，了解当着色器被正确配置时它能做什么，以及何时使用每个内置的着色器。有时候，你只需使用现有的着色器就能达到所需的效果，在简单游戏中，这可能是99%的情况，所以尽可能多地坚持使用它们。但如果确实需要创建一个自定义着色器来创建一个非常具体的效果，下一节将教你如何使用URP工具——着色器图。
- en: Creating shaders with Shader Graph
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用着色器图创建着色器
- en: Now that we know how shaders work and the existing shaders in URP, we have a
    basic notion of when it is necessary to create a custom shader and when it is
    not necessary. In case you really need to create one, this section will cover
    the basics of effects creation with Shader Graph, a tool to create effects using
    a visual node-based editor. This is an easy tool to use when you are not used
    to coding.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了着色器的工作原理以及URP中的现有着色器，我们对何时需要创建自定义着色器以及何时不需要有了基本的概念。如果你真的需要创建一个，本节将涵盖使用着色器图创建效果的基础，着色器图是一个使用基于节点的可视化编辑器创建效果的工具。当你不习惯编码时，这是一个易于使用的工具。
- en: 'In this section, we will discuss the following concepts of Shader Graph:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下着色器图的概念：
- en: Creating our first Shader Graph
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个着色器图
- en: Using textures
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理
- en: Combining textures
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并纹理
- en: Applying transparency
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用透明度
- en: Creating vertex effects
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建顶点效果
- en: Let’s start by seeing how we can create and use a Shader Graph.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何创建和使用一个着色器图。
- en: Creating our first Shader Graph
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个着色器图
- en: 'Shader Graph is a tool that allows us to create custom effects using a node-based
    system. An effect in Shader Graph can look like in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器图是一个允许我们使用基于节点的系统创建自定义效果的工具。在着色器图中，效果可以看起来像以下截图：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_15_PE.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B21361_10_15_PE.png)'
- en: 'Figure 10.15: Shader Graph with nodes to create a custom effect'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：带有节点以创建自定义效果的着色器图
- en: We will discuss later what those nodes do and we will be creating an example
    effect step by step, but in the screenshot, you can see how we created and connected
    several nodes—the interconnected boxes—with each one executing a specific process
    to achieve the effect. The idea of creating effects with Shader Graph is to learn
    which specific nodes you need and how to connect them properly. This is similar
    to the way we code the gameplay of the game, but this Shader Graph is adapted
    and simplified just for effect purposes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论这些节点的作用，并将逐步创建一个示例效果，但在截图上，你可以看到我们如何创建和连接几个节点——相互连接的盒子，每个节点执行特定的过程以实现效果。使用着色器图创建效果的想法是学习你需要哪些特定的节点以及如何正确地连接它们。这与我们编写游戏玩法代码的方式类似，但这个着色器图是为了效果目的而调整和简化的。
- en: 'To create and edit our first Shader Graph, do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和编辑我们的第一个着色器图，请执行以下操作：
- en: 'In the **Project** window, click the **+** icon and find the **Shader Graph
    | URP | Lit Shader Graph** option. This will create a Shader Graph using the PBR
    mode, meaning that this shader will support lighting effects (unlike Unlit graphs):'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，点击**+**图标，找到**Shader Graph | URP | Lit Shader Graph**选项。这将创建一个使用PBR模式的着色器图，这意味着这个着色器将支持光照效果（与Unlit图不同）：
- en: '![](img/B21361_10_16.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_16.png)'
- en: 'Figure 10.16: PBR Shader Graph creation'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：PBR着色器图创建
- en: 'Name it `Water`. If you want the opportunity to rename the asset, remember
    that you can select the asset, right-click, and select **Rename**:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`Water`。如果你想有机会重命名资产，请记住你可以选择资产，右键单击，并选择**重命名**：
- en: '![A picture containing screenshot, symbol, logo, electric blue  Description
    automatically generated](img/B21361_10_17_PE.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、符号、标志、电蓝色的图片，自动生成描述](img/B21361_10_17_PE.png)'
- en: 'Figure 10.17: Shader Graph asset'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17：着色器图资产
- en: 'Create a new material called `WaterMaterial` and set **Shader** to **Shader
    Graphs/Water**. If for some reason Unity doesn’t allow you to do that, try right-clicking
    on the **Water** graph and clicking **Reimport**. As you can see, the created
    Shader Graph now appears as a shader in the material:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`WaterMaterial`的新材质，并将**着色器**设置为**Shader Graphs/Water**。如果由于某种原因Unity不允许你这样做，尝试在**Water**图上右键单击并单击**重新导入**。正如你所见，创建的着色器图现在作为着色器出现在材质中：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_18_PE.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述，置信度低](img/B21361_10_18_PE.png)'
- en: 'Figure 10.18: Setting a Shader Graph as a material shader'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：设置Shader Graph作为材质着色器
- en: Create a plane with the **GameObject | 3D Object | Plane** option by right-clicking
    from the **Hierarchy** window.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**层次结构**窗口中右键单击，使用**GameObject | 3D Object | Plane**选项创建一个平面。
- en: Drag the material to the plane to apply it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质拖到平面上以应用它。
- en: Now, you have created your first custom shader and applied it to a material.
    So far, it doesn’t look interesting at all—it’s just a gray effect—but now it’s
    time to edit the graph to unlock its full potential. As the name of the graph
    suggests, we will be creating a water effect in this chapter to illustrate several
    nodes of the Shader Graph toolset and how to connect them. So, let’s start by
    discussing the Master Node.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经创建了自己的第一个自定义着色器并将其应用于材质。到目前为止，它看起来一点也不有趣——它只是一个灰色效果——但现在是你编辑图以解锁其全部潜力的时候了。正如图的名称所暗示的，在本章中我们将创建一个水效果来展示Shader
    Graph工具集的几个节点以及如何连接它们。所以，让我们先从讨论主节点开始。
- en: 'When you open the graph by double-clicking the shader asset, you will see the
    following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过双击着色器资产打开图时，你会看到以下内容：
- en: '![](img/B21361_10_19_PE.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_19_PE.png)'
- en: 'Figure 10.19: Master Node with all of the properties needed to calculate the
    object’s appearance'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19：包含计算对象外观所需所有属性的Master节点
- en: All nodes will have input pins, the data needed to work, and output pins, the
    results of their process. As an example, in a sum operation, we will have two
    input numbers and an output number, the result of the sum. In this case, you can
    see that the Master Node only contains inputs, and that’s because all data that
    enters the Master Node will be used by Unity to calculate the rendering and lighting
    of the object, things such as the desired object color or texture (the **Base
    Color** input pin), how smooth it is (the **Smoothness** input pin), or how much
    metal it contains (the **Metallic** input pin), properties that will affect how
    the lighting will be applied to the object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都将具有输入引脚，所需工作的数据，以及输出引脚，其处理的结果。例如，在求和操作中，我们将有两个输入数字和一个输出数字，即求和的结果。在这种情况下，你可以看到主节点只包含输入，这是因为所有进入主节点的数据都将被Unity用于计算对象的渲染和照明，例如所需的对象颜色或纹理（**基础颜色**输入引脚）、其平滑度（**平滑度**输入引脚）或其含有的金属量（**金属**输入引脚），这些属性将影响照明如何应用于对象。
- en: 'You can see that the Master Node is split between a **Vertex** section and
    a **Fragment** section. The first is capable of changing the mesh of the object
    we are modifying to deform it, animate it, etc., while the latter will change
    how it will look, which textures to use, how it will be illuminated, etc. Let’s
    start exploring how we can change that data in the **Fragment** section by doing
    the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到主节点被分为**顶点**部分和**片段**部分。前者能够改变我们正在修改的对象的网格以变形它、动画化它等，而后者将改变其外观，使用哪些纹理，如何照明等。让我们从以下操作开始探索如何在**片段**部分更改这些数据：
- en: Double-click the **Shader Graph** asset in the **Project** view to open its
    editor.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中双击**Shader Graph**资产以打开其编辑器。
- en: 'Click in the gray rectangle at the left of the **Base Color** input pin:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**基础颜色**输入引脚左侧的灰色矩形中单击：
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B21361_10_20_PE.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、设计的图片，自动生成描述](img/B21361_10_20_PE.png)'
- en: 'Figure 10.20: Base Color node input pin'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20：基础颜色节点输入引脚
- en: 'In the color picker, select a light blue color, like water. Select the bluish
    part of the circle and then a shade of that color in the middle rectangle:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在颜色选择器中，选择一种浅蓝色，就像水一样。选择圆圈的蓝色部分，然后在中间矩形中选择该颜色的一个色调：
- en: '![A screenshot of a phone  Description automatically generated with low confidence](img/B21361_10_21_PE.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![手机截图 描述自动生成，低置信度](img/B21361_10_21_PE.png)'
- en: 'Figure 10.21: Color picker'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21：颜色选择器
- en: 'Set **Smoothness** to `0.9`, which will make the object almost completely smooth
    (90% of the total smoothness possible). This will make our water reflect the sky
    almost completely:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**平滑度**设置为`0.9`，这将使物体几乎完全光滑（达到总平滑度的90%）。这将使我们的水面几乎完全反射天空：
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B21361_10_22_PE.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、设计的图片 描述自动生成](img/B21361_10_22_PE.png)'
- en: 'Figure 10.22: Smoothness PBR Master Node input pin'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22：平滑度PBR主节点输入引脚
- en: 'Click the **Save Asset** button at the top left of the window:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口左上角的**保存资产**按钮：
- en: '![A screen shot of a computer  Description automatically generated with low
    confidence](img/B21361_10_23_PE.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 描述自动生成，低置信度](img/B21361_10_23_PE.png)'
- en: 'Figure 10.23: Shader Graph saving options'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23：Shader Graph保存选项
- en: 'Go back to the **Scene** view and check that the plane is light blue with the
    sun reflected on it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**场景**视图，检查平面是否呈现浅蓝色，并且太阳反射在其上：
- en: '![A screenshot of a video game  Description automatically generated with medium
    confidence](img/B21361_10_24_PE.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图 描述自动生成，中等置信度](img/B21361_10_24_PE.png)'
- en: 'Figure 10.24: Initial Shader Graph results'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24：初始Shader Graph结果
- en: As you can see, the behavior of the shader varies according to the properties
    you set in the Master Node, but so far, doing this is no different than creating
    an Unlit Shader and setting up its properties; the real power of Shader Graph
    is when you use nodes that do specific calculations as inputs of the Master Node.
    We will start looking at the texture nodes, which allow us to apply textures to
    our model.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，着色器的行为根据您在主节点中设置的属性而变化，但到目前为止，这样做与创建一个无光照着色器并设置其属性没有区别；Shader Graph的真正威力在于您使用节点作为主节点的输入进行特定计算时。我们将开始查看纹理节点，这些节点允许我们将纹理应用到我们的模型上。
- en: Using textures
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理
- en: 'The idea of using textures is to have an image applied to the model in a way
    that we can paint different parts of the models with different colors. Remember
    that the model has a UV map, which allows Unity to know which part of the texture
    will be applied to which part of the model:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纹理的想法是将图像应用到模型上，以便我们可以用不同的颜色为模型的各个部分上色。请记住，模型有一个UV贴图，这使得Unity能够知道纹理的哪一部分将被应用到模型的哪一部分：
- en: '![](img/B21361_10_25.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_25.png)'
- en: 'Figure 10.25: On the left, a face texture; on the right, the same texture applied
    to a face mesh'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25：左侧为面部纹理；右侧为应用于面部网格的相同纹理
- en: 'Like in visual scripting, we will use interconnected nodes in our shader graph
    that will execute specific shader operations. We have several nodes to do this
    task, one of them being **Sample Texture 2D**, a node that has two main inputs.
    First, it asks us for the texture to sample or apply to the model, and then for
    the UV. You can see it in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在视觉脚本中一样，我们将在着色器图中使用相互连接的节点来执行特定的着色器操作。我们有几个节点来完成这项任务，其中之一是**Sample Texture
    2D**，这是一个有两个主要输入的节点。首先，它要求我们提供要采样或应用到模型上的纹理，然后是UV。您可以在以下屏幕截图中看到它：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_26_PE.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 描述自动生成，中等置信度](img/B21361_10_26_PE.png)'
- en: 'Figure 10.26: Sample Texture 2D node'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26：样本2D纹理节点
- en: 'As you can see, the default value of the **Texture** input node is **None**,
    so there’s no texture by default, and we need to manually specify that. For **UV**,
    the default value is `UV0`, meaning that, by default, the node will use the main
    UV channel of the model; and yes, a model can have several UVs set. For now, we
    will stick with the main one. If you are not sure what that means, **UV0** is
    the safest option. Let’s try this node, by doing the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**纹理**输入节点的默认值是**None**，因此默认情况下没有纹理，我们需要手动指定。对于**UV**，默认值是`UV0`，这意味着默认情况下，节点将使用模型的主要UV通道；是的，一个模型可以设置多个UV。目前，我们将坚持使用主要的一个。如果您不确定这意味着什么，**UV0**是最佳选择。让我们尝试这个节点，按照以下步骤进行：
- en: 'Download and import a tileable water texture from the internet:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网下载并导入一个可平铺的水纹理：
- en: '![Image result for tileable water texture](img/B21361_10_27_PE.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![可平铺水纹理的图像结果](img/B21361_10_27_PE.png)'
- en: 'Figure 10.27: Tileable water texture'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27：可平铺的水纹理
- en: 'Select the texture and be sure that the **Wrap Mode** property of the texture
    is set to **Repeat**, which will allow us to repeat the texture as we did in the
    terrain because the idea is to use this shader to cover large water areas:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择纹理并确保纹理的**包裹模式**属性设置为**重复**，这将允许我们像在地形中那样重复纹理，因为我们的想法是使用这个着色器来覆盖大面积的水域：
- en: '![A picture containing text, font, screenshot, white  Description automatically
    generated](img/B21361_10_28_PE.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、截图、白色的图片，自动生成描述](img/B21361_10_28_PE.png)'
- en: 'Figure 10.28: Texture Repeat mode'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28：纹理重复模式
- en: 'In the **Water Shader Graph**, right-click in an empty area of the Shader Graph
    and select **Create Node**:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**水着色器图**中，在着色器图的一个空白区域右键单击并选择**创建节点**：
- en: '![A picture containing text, font, screenshot, graphics  Description automatically
    generated](img/B21361_10_29_PE.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、截图、图形的图片，自动生成描述](img/B21361_10_29_PE.png)'
- en: 'Figure 10.29: Shader Graph Create Node option'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29：着色器图创建节点选项
- en: 'In the **Search** box, write `Sample texture` and all of the sampler nodes
    will show up. Double-click **SampleTexture2D**. If for some reason you can’t double-click
    the option, right-click on it first and then try again. There is a known bug in
    this tool and this is the workaround:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索**框中，键入`Sample texture`，所有采样节点都会显示出来。双击**SampleTexture2D**。如果由于某种原因无法双击选项，请先右键单击它，然后再尝试。这个工具中有一个已知的错误，这是解决方案：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_30_PE.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述，低置信度](img/B21361_10_30_PE.png)'
- en: 'Figure 10.30: Sample texture node search'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30：纹理节点搜索示例
- en: 'Click in the circle to the left of the **Texture** input pin of the **Sample
    Texture 2D** node. It will allow us to pick a texture to sample—just select the
    **water** one. You can see that the texture can be previewed in the bottom part
    of the node:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Sample Texture 2D**节点的**纹理**输入引脚左侧的圆圈。这将允许我们选择要采样的纹理——只需选择**水**纹理。您可以看到纹理可以在节点的底部部分预览：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_31_PE.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述](img/B21361_10_31_PE.png)'
- en: 'Figure 10.31: Sample texture node with a texture in its input pin'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31：具有纹理输入引脚的纹理节点示例
- en: 'Drag the **RGBA** output pin from the **Sample Texture 2D** node to the **Base
    Color** input pin of the Master Node:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Sample Texture 2D**节点的**RGBA**输出引脚拖到主节点的**基色**输入引脚：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_32_PE.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述，中等置信度](img/B21361_10_32_PE.png)'
- en: 'Figure 10.32: Connecting the results of texture sampling with the Base Color
    pin of the Master Node'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32：将纹理采样结果连接到主节点的基色引脚
- en: 'Click the **Save Asset** button in the top-left part of the Shader Graph editor
    and see the changes in the **Scene** view:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在着色器图编辑器的左上角点击**保存资产**按钮，并在**场景**视图中查看更改：
- en: '![](img/B21361_10_33_PE.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_33_PE.png)'
- en: 'Figure 10.33: Results of applying a texture in our Shader Graph'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33：在Shader Graph中应用纹理的结果
- en: As you can see, the texture is properly applied to the model, but if you take
    into account that the default plane has a size of 10x10 meters, the ripples of
    the water seem too big. So, let’s tile the texture!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，纹理已正确应用于模型，但如果考虑到默认平面的尺寸为10x10米，水的波纹看起来太大。所以，让我们平铺纹理吧！
- en: To do this, we need to change the UVs of the model, making them bigger. You
    may imagine that bigger UVs mean the texture should also get bigger, but take
    into account that we are not making the object bigger; we are just modifying the
    UV.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要更改模型的UV，使它们更大。您可能会想象更大的UV意味着纹理也应该更大，但请记住，我们并没有使对象变大；我们只是在修改UV。
- en: 'In the same object area, we will display more of the texture area, meaning
    that in the bigger texture sample area (achieved by bigger UVs), repetitions of
    the texture may appear. To do so, follow the next steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同对象区域，我们将显示更多纹理区域，这意味着在更大的纹理采样区域（通过更大的UV实现），纹理可能会重复。要这样做，请按照以下步骤操作：
- en: 'Right-click in any empty space and click **New Node** to search for the **UV**
    node:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何空白区域右键单击并点击**新建节点**以搜索**UV**节点：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_34_PE.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述，中等置信度](img/B21361_10_34_PE.png)'
- en: 'Figure 10.34: Searching for the UV node'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34：搜索UV节点
- en: Using the same method, create a **Multiply** node.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的方法创建一个**乘法节点**。
- en: Drag the **Out** pin of the **UV** node to the **A** pin of the **Multiply**
    node to connect them.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UV节点**的**Out**引脚拖动到**乘法节点**的**A**引脚以连接它们。
- en: 'Set the **B** pin input value of **Multiply** to `4`,`4`,`4`,`4`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**乘法**的**B**引脚输入值设置为`4`,`4`,`4`,`4`：
- en: '![A picture containing screenshot  Description automatically generated](img/B21361_10_35_PE.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![包含屏幕截图的图片  自动生成的描述](img/B21361_10_35_PE.png)'
- en: 'Figure 10.35: Multiplying the UVs by 4'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.35：将UV乘以4
- en: 'Drag the **Out** pin of the **Multiply** node to **UV** of the **Sample Texture
    2D** node to connect them:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**乘法节点**的**Out**引脚拖动到**样本纹理2D节点**的**UV**上以连接它们：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_36_PE.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述，中等置信度](img/B21361_10_36_PE.png)'
- en: 'Figure 10.36: Using the multiplied UVs to sample the texture'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36：使用乘法UV进行纹理采样
- en: 'If you save the graph and go back to the **Scene** view, you can see that now
    the ripples are smaller, because we have tiled the UVs of our model. You can also
    see that in the preview of the **Sampler Texture 2D** node:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您保存图表并返回到**场景视图**，您会看到现在波纹更小，因为我们已经平铺了模型的UV。您也可以在**采样纹理2D节点**的预览中看到：
- en: '![A picture containing screenshot, aqua, turquoise, design  Description automatically
    generated](img/B21361_10_37_PE.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![包含屏幕截图、青绿色、蓝绿色、设计的图片  自动生成的描述](img/B21361_10_37_PE.png)'
- en: 'Figure 10.37: Results of the model’s UV multiplication'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37：模型UV乘法的结果
- en: 'Another interesting effect we can do now is to apply an offset to the texture
    to move it. The idea is that even if the plane is not actually moving, we will
    simulate the flow of the water through it, moving just the texture. Remember,
    the responsibility of determining the part of the texture to apply to each part
    of the model belongs to the UV, so if we add values to the UV coordinates, we
    will be moving them, generating a texture sliding effect. To do so, let’s do the
    following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以做的另一个有趣的效果是给纹理应用偏移以移动它。想法是即使平面实际上没有移动，我们也会模拟水流通过它，只是移动纹理。记住，确定将纹理的哪一部分应用到模型的每一部分的职责属于UV，所以如果我们向UV坐标添加值，我们就会移动它们，生成纹理滑动效果。为此，让我们做以下操作：
- en: Create an **Add** node to the right of the **UV** node.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**UV节点**的右侧创建一个**加法节点**。
- en: 'Connect the **Out** pin of **UV** to the **A** pin of the **Add** node:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UV**的**Out**引脚连接到**加法节点**的**A**引脚：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_38_PE.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述，低置信度](img/B21361_10_38_PE.png)'
- en: 'Figure 10.38: Adding values to the UVs'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38：向UV添加值
- en: Create a **Time** node at the left of the **Add** node.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**加法节点**的左侧创建一个**时间节点**。
- en: 'Connect the **Time** node to the **B** pin of the **Add** node:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**时间节点**连接到**加法节点**的**B**引脚：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_39_PE.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述，中等置信度](img/B21361_10_39_PE.png)'
- en: 'Figure 10.39: Adding Time to the UVs'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39：向UV添加时间
- en: 'Connect the **Out** pin of the **Add** node to the **A** input pin of the **Multiply**
    node:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**加法节点**的**Out**引脚连接到**乘法节点**的**A**输入引脚：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_10_40_PE.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图  自动生成的描述，中等置信度](img/B21361_10_40_PE.png)'
- en: 'Figure 10.40: Added and multiplied UVs as an input of the sample texture'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.40：将添加和乘法UV作为样本纹理的输入
- en: 'Save and see the water moving in the **Scene** view. If you don’t see it moving,
    click the layers icon in the top bar of the scene and check **Always Refresh**:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并查看在**场景视图**中的水流动。如果您看不到它在移动，请点击场景顶部栏中的图层图标并检查**始终刷新**：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_41_PE.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B21361_10_41_PE.png)'
- en: 'Figure 10.41: Enabling Always Refresh to preview the effect'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.41：启用始终刷新以预览效果
- en: 'If you feel the water is moving too fast, try using the multiplication node
    to make the time a smaller value. I recommend you try it by yourself before looking
    at the next screenshot, which has the answer:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您觉得水移动得太快，可以尝试使用乘法节点来使时间值更小。我建议您在查看下一个截图之前自己尝试一下，该截图有答案：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_42_PE.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_10_42_PE.png)'
- en: 'Figure 10.42: Multiplication of time to move the texture more slowly'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42：减慢移动纹理的时间
- en: 'If you feel the graph is too big, try to hide some of the node previews by
    clicking on the **up** (**^**) arrow that appears on the preview when you move
    the mouse over it:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您觉得图表太大，可以尝试通过点击鼠标悬停在预览上时出现的向上箭头（**↑**）来隐藏一些节点预览：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_43_PE.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_10_43_PE.png)'
- en: 'Figure 10.43: Hiding the preview from the graph nodes'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.43：隐藏图节点中的预览
- en: 'Also, you can hide unused pins by selecting the node and clicking the arrow
    at its top right:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您可以通过选择节点并点击其右上角的箭头来隐藏未使用的引脚：
- en: '![A picture containing screenshot, text, font, number  Description automatically
    generated](img/B21361_10_44_PE.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、文本、字体、数字的图片  描述自动生成](img/B21361_10_44_PE.png)'
- en: 'Figure 10.44: Hiding unused pins from the graph nodes'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.44：隐藏图节点中的未使用引脚
- en: So, to recap, first we added the time to the UV to move it and then multiplied
    the result of the moved UV to make it bigger to tile the texture. It is worth
    mentioning that there’s a **Tiling and Offset** node that does all of this process
    for us, but I wanted to show you how a simple multiplication to scale the UV and
    an add operation to move it generates a nice effect; you can’t imagine all of
    the possible effects you can achieve with other simple mathematical nodes! Actually,
    let’s explore other usages of mathematical nodes to combine textures in the next
    section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，我们首先将时间添加到UV以移动它，然后将移动的UV的结果相乘以使其变大，从而平铺纹理。值得一提的是，有一个**平铺和偏移**节点可以为我们完成所有这些过程，但我想要向您展示一个简单的乘法来缩放UV和一个加法操作来移动它会产生一个很好的效果；您无法想象您可以用其他简单的数学节点实现的所有可能效果！实际上，让我们在下一节中探索数学节点组合纹理的其他用法。
- en: 'When learning DirectX, making shaders was harder given you needed to learn
    a less user-friendly language called HLSL. While for most cases Shader Graph is
    all you need, I don’t regret at all learning such shader languages, as they have
    access to more advanced features that node-based shading languages usually don’t,
    and they give you a deeper understanding of the internals of the GPU. For more
    info about how to create code-based shaders in URP, you can check this: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习DirectX时，由于您需要学习一个不太友好的语言HLSL，制作着色器会更困难。虽然对于大多数情况Shader Graph就足够了，但我一点也不后悔学习这样的着色器语言，因为它们可以访问基于节点的着色语言通常不具备的更高级功能，并且它们能给您更深入地了解GPU内部结构。有关如何在URP中创建基于代码的着色器的更多信息，您可以查看以下链接：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html)
- en: Combining textures
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合纹理
- en: 'Even though we have used nodes, we haven’t created anything that can’t be created
    using regular shaders, but that’s about to change. So far, we can see the water
    moving, but it still looks static, and that’s because the ripples are always the
    same. We have several techniques to generate ripples; the simplest one would be
    to combine two water textures moving in different directions to mix their ripples.
    Actually, we can simply use the same texture, just flipped to save some memory.
    To combine the textures, we will sum them and then divide them by 2, so basically,
    we are calculating the average of the textures! Let’s do that by doing the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了节点，但我们还没有创建出任何不能使用常规着色器创建的东西，但这种情况即将改变。到目前为止，我们可以看到水在移动，但它仍然看起来很静止，这是因为波纹总是相同的。我们有几种生成波纹的技术；最简单的一种是将两个在不同方向上移动的水纹理组合起来以混合它们的波纹。实际上，我们可以简单地使用相同的纹理，只需翻转一下以节省一些内存。为了组合纹理，我们将它们相加，然后除以2，所以基本上，我们是在计算纹理的平均值！让我们通过以下步骤来完成它：
- en: 'Select all of the nodes between **Time** and **Sampler 2D** (including them)
    by creating a selection rectangle by clicking in any empty space in the graph,
    holding and dragging the click, and then releasing when all target nodes are covered:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在图表中的任何空白区域点击，按住并拖动点击，当所有目标节点都被覆盖时释放，选择**时间**和**2D采样器**之间的所有节点（包括它们）：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_45_PE.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，置信度中等](img/B21361_10_45_PE.png)'
- en: 'Figure 10.45: Selecting several nodes'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.45：选择多个节点
- en: Right-click and select **Copy**, and then again right-click and select **Paste**,
    or use the classic *Ctrl* + *C*, *Ctrl* + *V* commands (*Command* + *C*, *Command*
    + *V* on Mac).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并选择**复制**，然后再次右键点击并选择**粘贴**，或者使用经典的*Ctrl* + *C*，*Ctrl* + *V*命令（在Mac上为*Command*
    + *C*，*Command* + *V*）。
- en: 'Move the copied nodes below the original ones:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的节点移动到原始节点下方：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_46_PE.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成](img/B21361_10_46_PE.png)'
- en: 'Figure 10.46: Duplication of nodes'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.46：节点的复制
- en: For the copied nodes, set the **B** pin of the **Multiply** node connected to
    **Sample Texture 2D** to `-4`,`-4`,`-4`,`-4`. You can see that that flipped the
    texture.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于复制的节点，将连接到**2D采样纹理**的**乘法**节点的**B**引脚设置为`-4`,`-4`,`-4`,`-4`。你可以看到这翻转了纹理。
- en: 'Also, set the **B** pin of the **Multiply** node connected to the **Time**
    node to `-0.1`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将连接到**时间**节点的**乘法**节点的**B**引脚设置为`-0.1`：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_47_PE.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成](img/B21361_10_47_PE.png)'
- en: 'Figure 10.47: Multiplication of values'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.47：值的乘法
- en: 'Create an **Add** node at the right of both **Sampler Texture 2D** nodes and
    connect the outputs of those nodes to the **A** and **B** input pins of the **Add**
    node:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个**2D采样器**节点的右侧创建一个**加法**节点，并将这些节点的输出连接到**加法**节点的**A**和**B**输入引脚：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_48_PE.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，置信度中等](img/B21361_10_48_PE.png)'
- en: 'Figure 10.48: Adding two textures'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.48：添加两种纹理
- en: 'You can see that the resulting combination is too bright because we have summed
    up the intensity of both textures, so let’s fix that by multiplying the **Out**
    of the **Add** node by `0.5,0.5,0.5,0.5`, which will divide each resulting color
    channel by 2, averaging the color. You can also experiment with what happens when
    you set different values for each channel if you want, but for our purposes, `0.5`
    is the proper value for each channel:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到，由于我们同时计算了两种纹理的强度，所以结果组合太亮了，所以让我们通过将**加法**节点的**Out**乘以`0.5,0.5,0.5,0.5`来修复这个问题，这将把每个结果颜色通道除以2，平均颜色。你也可以尝试设置每个通道的不同值，看看会发生什么，但就我们的目的而言，`0.5`是每个通道的正确值：
- en: '![A picture containing screenshot, text, multimedia software, line  Description
    automatically generated](img/B21361_10_49_PE.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、文本、多媒体软件、行的图片  描述自动生成](img/B21361_10_49_PE.png)'
- en: 'Figure 10.49: Dividing the sum of two textures to get the average'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.49：将两个纹理的总和除以得到平均值
- en: Connect the **Out** pin of the **Multiply** node to the **Base Color** pin of
    the **Master** Node to apply all of those calculations to the color of the object.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**乘法**节点的**Out**引脚连接到**主节点**的**基础颜色**引脚，以将所有这些计算应用于物体的颜色。
- en: 'Save the asset and see the results in the **Scene** view:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存资产，并在**场景**视图中查看结果：
- en: '![](img/B21361_10_50_PE.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_50_PE.png)'
- en: 'Figure 10.50: Results of texture blending'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.50：纹理混合的结果
- en: You can keep adding nodes to make the effect more diverse, such as using **Sine**
    nodes (which will execute the trigonometry sine function) to apply non-linear
    movements, but I will let you learn that by experimenting with it by yourself.
    For now, we will stop here. As always, this topic deserves a full book, and the
    intention of this chapter is to give you a small taste of this powerful Unity
    tool. I recommend you look for other Shader Graph examples on the internet to
    learn other usages of the same nodes and, of course, new nodes. One thing to consider
    here is that everything we have done so far is basically applied to the Fragment
    Shader stage of the shader pipeline we discussed earlier. Now, let’s use the Blending
    shader pipeline stage to apply some transparency to the water.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续添加节点以使效果更加多样化，例如使用**正弦**节点（这将执行三角函数的正弦运算）来应用非线性运动，但我会让您通过自己实验来学习这一点。现在，我们将在这里停止。像往常一样，这个主题值得一本完整的书，而本章的目的是给您这个强大的Unity工具的小小品尝。我建议您在网上寻找其他Shader
    Graph示例来学习相同节点的其他用法，当然，还有新节点。在这里要考虑的一点是，我们迄今为止所做的一切基本上都是应用于我们之前讨论过的着色器管道的片段着色器阶段。现在，让我们使用混合着色器管道阶段来给水应用一些透明度。
- en: 'For more examples of shader graphs, I recommend checking out the following
    link: [https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html](mailto:https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于着色器图样的示例，我建议查看以下链接：[https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html](mailto:https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html)
- en: Applying transparency
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用透明度
- en: Before declaring our effect finished, a little addition we can do is to make
    the water a little bit transparent. Remember that the shader pipeline has a blending
    stage, which has the responsibility of blending each pixel of our model into the
    image being rendered in this frame. The idea is to make our Shader Graph modify
    that stage to apply **Alpha Blending**, a blending mode that combines our model
    and the previously rendered models based on the `Alpha` value of our model.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在宣布我们的效果完成之前，我们可以做的一个小补充是使水稍微透明一些。记住，着色器管道有一个混合阶段，该阶段负责将我们的模型中的每个像素混合到当前帧正在渲染的图像中。我们的想法是让我们的Shader
    Graph修改这个阶段以应用**Alpha混合**，这是一种基于我们模型`Alpha`值的混合模式。
- en: 'To get that effect, take the following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到这种效果，请按照以下步骤操作：
- en: Look for the **Graph Inspector** window floating around. If you don’t see it,
    click the **Graph Inspector** button in the top-right part of the Shader Graph
    editor. Try also expanding the Shader Graph window to display it in case it’s
    hidden behind the right bound of the window.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找浮动在周围的**图形检查器**窗口。如果您看不到它，请点击Shader Graph编辑器右上角的**图形检查器**按钮。也可以尝试展开Shader
    Graph窗口以显示它，以防它被窗口的右边界隐藏。
- en: Click the **Graph Settings** tab.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**图形设置**选项卡。
- en: Set the **Surface Type** property to **Transparent**.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**表面类型**属性设置为**透明**。
- en: 'Set the **Blending Mode** property to **Alpha** if it isn’t already at that
    value:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**混合模式**属性尚未设置为该值，请将其设置为**Alpha**：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_51_PE.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B21361_10_51_PE.png)'
- en: 'Figure 10.51: Graph Inspector transparency settings'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.51：图形检查器透明度设置
- en: Set the **Alpha** input pin of the Master Node to `0.5`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主节点的**Alpha**输入引脚设置为`0.5`。
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_52_PE.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度低](img/B21361_10_52_PE.png)'
- en: 'Figure 10.52: Setting Alpha of the Master Node'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.52：设置主节点的Alpha
- en: 'Save the Shader Graph and see the transparency applied in the **Scene** view.
    If you can’t see the effect, just put a cube into the water to make the effect
    more evident:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存Shader Graph并查看在**场景**视图中应用的透明度。如果您看不到效果，只需将一个立方体放入水中，使效果更加明显：
- en: '![A black and white cube on a tile floor  Description automatically generated
    with low confidence](img/B21361_10_53_PE.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![黑白立方体在瓷砖地板上  描述自动生成，置信度低](img/B21361_10_53_PE.png)'
- en: 'Figure 10.53: Shadows from the water being applied to a cube'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.53：将水产生的阴影应用于立方体
- en: You can see the shadows that the water is casting on our cube because Unity
    doesn’t know the object is transparent and hence casts shadows. Click on the water
    plane and look for the **Mesh Renderer** component in the Inspector. If you don’t
    see the shadow, click the lightbulb at the top of the **Scene** view.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到水在我们立方体上投射的阴影，因为 Unity 不知道该对象是透明的，因此会投射阴影。点击水面，在检查器中查找 **网格渲染器** 组件。如果你看不到阴影，点击
    **场景** 视图顶部的灯泡。
- en: '![A screen shot of a computer  Description automatically generated with low
    confidence](img/B21361_10_54_PE.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成的低置信度描述](img/B21361_10_54_PE.png)'
- en: 'Figure 10.54: Enabling lights in the Scene view'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.54：在场景视图中启用灯光
- en: 'In the **Lighting** section, set **Cast Shadows** to **Off**; this will disable
    shadow casting from the plane on the parts of the cube that are underwater:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **照明** 部分中，将 **投射阴影** 设置为 **关闭**；这将禁用在水下部分的立方体上从平面上投射阴影：
- en: '![](img/B21361_10_55.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_10_55.png)'
- en: 'Figure 10.55: Disabling shadow casting'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.55：禁用阴影投射
- en: 'Adding transparency is a simple process but it has its caveats, like the shadow
    problem, and in more complex scenarios, it can have other problems, like increasing
    overdraw, meaning the same pixel needs to be drawn several times (the pixel belonging
    to the transparent object, and one of the objects behind). I would suggest you
    avoid using transparency unless it is necessary. Actually, our water can live
    without transparency, especially when we apply this water to the river basin around
    the base, because we don’t need to see the part under the water; but the idea
    is for you to know all of your options. In the next screenshot, you can see how
    we have put a giant plane with this effect below our base, big enough to cover
    the entire basin:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 添加透明度是一个简单的过程，但它有其注意事项，比如阴影问题，在更复杂的情况下，它可能还有其他问题，比如增加过度绘制，意味着同一个像素需要绘制多次（属于透明对象的像素，以及背后物体中的一个）。我建议你在不必要的情况下避免使用透明度。实际上，我们的水可以不透明地存在，尤其是当我们将这种水应用到基础周围的河盆时，因为我们不需要看到水下部分；但目的是让你知道所有选项。在下一张截图，你可以看到我们如何在基础下方放置了一个带有这种效果的大型平面，足够大，可以覆盖整个盆地：
- en: '![A picture containing grass, screenshot  Description automatically generated](img/B21361_10_56_PE.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![包含草的图片，截图，自动生成的描述](img/B21361_10_56_PE.png)'
- en: 'Figure 10.56: Using our water in the main scene'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.56：在主场景中使用我们的水
- en: 'I have a friend who always jokes about me, saying that everything can be solved
    with a shader, but jokes aside, it is an extremely useful tool if used cleverly.
    In the past, developers used shaders to do non-graphics-related processing, like
    mathematics simulations, reading the generated pixels as the needed results. That
    led to what today is known as compute shaders, which essentially refers to running
    custom programs on a GPU to do calculations, leveraging the power of the GPU.
    Of course, Unity supports compute shaders; you can learn more about them here:
    [https://docs.unity3d.com/Manual/class-ComputeShader.html](https://docs.unity3d.com/Manual/class-ComputeShader.html)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个朋友总是拿我开玩笑，说所有问题都可以用着色器解决，但玩笑归玩笑，如果使用得当，它是一个非常实用的工具。在过去，开发者使用着色器进行与图形无关的处理，比如数学模拟，读取生成的像素作为所需的结果。这导致了今天我们所知的计算着色器，它本质上是指在
    GPU 上运行自定义程序以进行计算，利用 GPU 的强大功能。当然，Unity 支持计算着色器；你可以在这里了解更多信息：[https://docs.unity3d.com/Manual/class-ComputeShader.html](https://docs.unity3d.com/Manual/class-ComputeShader.html)
- en: From now on, we can do plenty of things with our shader. We can think about
    simulating water foam for the pixels that are higher than a certain height, leveraging
    the vertex animation we added. We could also change the water scrolling direction
    via scripting or using sine nodes. The sky is the limit!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们可以用我们的着色器做很多事情。我们可以考虑为高于一定高度像素模拟水泡，利用我们添加的顶点动画。我们也可以通过脚本或使用正弦节点来改变水的滚动方向。天空才是极限！
- en: Now that we have modified how the object looks through the **Fragment** node
    section, let’s discuss how to use the **Vertex** section to apply a mesh animation
    to our water.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过 **片段** 节点部分修改了对象的外观，让我们讨论如何使用 **顶点** 节点来将网格动画应用到我们的水上。
- en: Creating vertex effects
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建顶点效果
- en: So far, we have applied water textures to our water, but it’s still a flat plane.
    We can go further than that and make the ripples not only via textures but also
    by animating the mesh. To do so, we will apply the noise texture we used at the
    beginning of the chapter in the shader, but instead of using it as another color
    to add to the **Base Color** of the shader, we will instead use it to offset the
    **Y** position of the vertexes of our plane.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将水纹理应用到我们的水上，但它仍然是一个平面。我们可以更进一步，不仅通过纹理，还可以通过动画网格来制作波纹。要做到这一点，我们将在着色器中应用我们在本章开头使用的噪声纹理，但不是将其用作添加到着色器**基础颜色**的另一种颜色，而是用它来偏移我们平面的顶点的**Y**位置。
- en: 'Due to the chaotic nature of the noise texture, the idea is that we will apply
    a vertical offset to different parts of the model, so we can emulate the ripples:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于噪声纹理的混沌性质，我们的想法是对模型的各个部分应用垂直偏移，这样我们就可以模拟波纹：
- en: '![A picture containing line, symmetry, square, black and white  Description
    automatically generated](img/B21361_10_57_PE.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![包含线条、对称、正方形、黑白图案的图片  自动生成的描述](img/B21361_10_57_PE.png)'
- en: 'Figure 10.57: Default plane mesh subdivided into a grid of 10x10 with no offset'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.57：默认平面网格细分为10x10的网格，无偏移
- en: 'To accomplish something like this, you can modify the **Vertex** section of
    your shader to look like the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类似的效果，您可以修改着色器的**顶点**部分，使其看起来如下：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_58_PE.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B21361_10_58_PE.png)'
- en: 'Figure 10.58: Ripples vertex effect'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.58：波纹顶点效果
- en: In the graph, you can see how we are creating a vector whose *y* axis depends
    on the noise texture we downloaded at the beginning of the chapter. The idea behind
    that is to create a vector pointing upward whose length is proportional to the
    grayscale factor of the texture; the whiter the pixel of the texture, the longer
    the offset. This texture has an irregular yet smooth pattern so it can emulate
    the behavior of the tide.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，您可以看到我们如何创建一个向量，其**y**轴取决于我们在本章开头下载的噪声纹理。背后的想法是创建一个向上指的向量，其长度与纹理的灰度因子成正比；纹理的像素越白，偏移量越长。这种纹理具有不规则但平滑的图案，可以模拟潮汐的行为。
- en: Please notice that, here, we used **Sample Texture 2D LOD** instead of **Sample
    Texture 2D**; the latter does not work in the **Vertex** section, so keep that
    in mind.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里，我们使用了**采样2D纹理LOD**而不是**采样2D纹理**；后者在**顶点**部分不起作用，所以请记住这一点。
- en: Then we multiply the result by `0.3` to reduce the height of the offset to add,
    and then we add the result to the **Position** node. See that the **Space** property
    of the **Position** node is set to **Object** mode. We need that mode to work
    with the **Vertex** section of the Shader Graph (we discussed *World* and *Local*
    spaces before in *Chapter 2*, *Crafting Scenes and Game Elements*, but you can
    also search `Object vs World Space` on the internet for more info about this).
    Finally, the result is connected to the **Position** node of the **Vertex** section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将结果乘以`0.3`以减少要添加的偏移高度，然后将结果添加到**位置**节点。注意，**位置**节点的**空间**属性设置为**对象**模式。我们需要这种模式来与着色器图（我们在*第2章*，*制作场景和游戏元素*中讨论了*世界*和*局部*空间，但您也可以在网上搜索`Object
    vs World Space`以获取更多关于此的信息）。最后，结果连接到**顶点**部分的**位置**节点。
- en: 'If you save, you will see something like the following image:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存，你会看到以下类似图像：
- en: '![A picture containing aqua, turquoise, pattern, teal  Description automatically
    generated](img/B21361_10_59_PE.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![包含青绿色、绿松石色、图案、蓝绿色的图片  自动生成的描述](img/B21361_10_59_PE.png)'
- en: 'Figure 10.59: Ripples vertex effect applied'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.59：应用波纹顶点效果
- en: 'Of course, in this case, the ripples are static because we didn’t add any time
    offset to the UV as we did before. In the following screenshot, you can see how
    to add that, but before looking at it, I recommend you try to resolve it first
    by yourself as a personal challenge:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，波纹是静态的，因为我们没有像之前那样对UV添加任何时间偏移。在下面的屏幕截图中，您可以查看如何添加它，但在查看之前，我建议您先自己尝试解决它作为一个个人挑战：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_60_PE.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B21361_10_60_PE.png)'
- en: 'Figure 10.60: Animated ripples vertex effect graph'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.60：动画波纹顶点效果图
- en: As you can see, we are again taking the original UV and adding the time multiplied
    by any factor so it will slowly move, the same as we did previously with our water
    texture. You can keep playing around with this, changing how this looks with different
    textures, multiplying the offset to increase or reduce the height of the ripples,
    applying interesting math functions like sine, and so much more; but for now,
    let’s finish with this.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们再次使用原始的 UV，并添加任何因子的乘以时间，这样它就会慢慢移动，就像我们之前在水面纹理上所做的那样。你可以继续尝试不同的纹理，改变其外观，通过乘以偏移量来增加或减少波纹的高度，应用如正弦等有趣的数学函数，以及更多；但现在，让我们先完成这个。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how a shader works in the GPU and how to create
    our first simple shader to achieve a nice water effect. Working with shaders is
    a complex and interesting job, and in a team, there is usually one or more people
    in charge of creating all of these effects, in a position called technical artist;
    so, as you can see, this topic can expand to a whole career. Remember, the intention
    of this book is to give you a small taste of all the possible roles you can take
    in the industry, so if you really liked this role, I suggest you start reading
    shader-exclusive books. You have a long but super interesting road in front of
    you.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了着色器在 GPU 中的工作原理以及如何创建我们的第一个简单着色器以实现良好的水面效果。与着色器一起工作是一项复杂而有趣的工作，在一个团队中，通常有一人或多人负责创建所有这些效果，这个职位被称为技术艺术家；所以，正如你所见，这个主题可以扩展成一个完整的职业。记住，这本书的目的是给你一个行业所有可能角色的微小品尝，所以如果你真的喜欢这个角色，我建议你开始阅读专注于着色器的书籍。你面前有一条漫长但超级有趣的道路。
- en: Enough shaders for now! In the next chapter, we will look at how to improve
    our graphics and create visual effects with particle systems!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在足够多的着色器了！在下一章中，我们将探讨如何通过粒子系统改进我们的图形并创建视觉效果！
- en: Learn more on Discord
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过 Ask Me Anything 会话与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1498477041053909218.png)'
