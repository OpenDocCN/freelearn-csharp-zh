- en: 12 Behavioral Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter explores two new design patterns from the well-known **Gang of
    Four** (**GoF**). They are behavioral patterns, meaning they help simplify system
    behavior management.Often, we need to encapsulate some core algorithm while allowing
    other pieces of code to extend that implementation. That is where the **Template
    Method** pattern comes into play.Other times, we have a complex process with multiple
    algorithms that all apply to one or more situations, and we need to organize it
    in a testable and extensible fashion. This is where the **Chain of Responsibility**
    pattern can help. For example, the ASP.NET Core middleware pipeline is a Chain
    of Responsibility where all the middleware inspects and acts on the request.In
    this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Template Method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Chain of Responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing the Template Method and Chain of Responsibility patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Template Method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Template Method** is a GoF behavioral pattern that uses inheritance to
    share code between the base class and its subclasses. It is a very powerful yet
    simple design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of the Template Method pattern is to encapsulate the outline of an
    algorithm in a base class while leaving some parts of that algorithm open for
    modification by the subclasses, which adds flexibility at a low cost.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need to define a base class that contains the `TemplateMethod` method
    and then define one or more sub-operations that need to be implemented by its
    subclasses (`abstract`) or that can be overridden (`virtual`).Using UML, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Class diagram representing the Template Method pattern](img/file68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Class diagram representing the Template Method pattern'
  prefs: []
  type: TYPE_NORMAL
- en: How does this work?
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractClass` implements the shared code: the algorithm in its `TemplateMethod`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteClass` implements its specific part of the algorithm in its inherited
    `Operation` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client` calls `TemplateMethod()`, which calls the subclass implementation
    of one or more specific algorithm elements (the `Operation` method in this case).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could also extract an interface from `AbstractClass` to allow even more flexibility,
    but that’s beyond the scope of the Template Method pattern.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s now get into some code to see the Template Method pattern in action.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Building a search machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with a simple, classic example to demonstrate how the Template
    Method pattern works.**Context**: Depending on the collection, we want to use
    a different search algorithm. We want to use a *binary search* for sorted collections,
    but we want to use a *linear search* for unsorted collections.Let’s start with
    the consumer, a REST endpoint in the `Program.cs` file that returns `plain/text`
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As highlighted in the first few lines, we configure `LinearSearchMachine` and
    `BinarySearchMachine` as two `SearchMachine` implementations. We initialize each
    instance using a different sequence of numbers.Afterward, we inject all registered
    `SearchMachine` services into the endpoint (highlighted in the code block). That
    handler iterates all `SearchMachine` instances and tries to find all elements
    of the `elementsToFind` array before outputting the `text/plain` results.Next,
    let’s explore the `SearchMachine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SearchMachine` class represents `AbstractClass`. It exposes the `IndexOf`
    template method, which uses the required hook represented by the `abstract` `Find`
    method (see highlighted code). The hook is required because each subclass must
    implement that method, thereby making that method a required extension point (or
    hook).Next, we explore our first implementation of `ConcreteClass`, the `LinearSearchMachine`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LinearSearchMachine` class is a `ConcreteClass` representing the linear
    search implementation used by `SearchMachine`. It contributes a part of the `IndexOf`
    algorithm through its `Find` method.Finally, we move on to the `BinarySearchMachine`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `BinarySearchMachine` class is a `ConcreteClass` representing the binary
    search implementation of `SearchMachine`. As you may have noticed, we skipped
    the binary search algorithm’s implementation by delegating it to the built-in
    `Array.BinarySearch` method. Thanks to the .NET team!
  prefs: []
  type: TYPE_NORMAL
- en: The binary search algorithm requires an ordered collection to work; hence the
    sorting done in the constructor when passing the values to the base class (`OrderBy`).
    That may not be the most performant way of ensuring the array is sorted (precondition/guard),
    but it is a very fast to write and readable way to write it. Moreover, in our
    case, performance is not an issue.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you must optimize such an algorithm to work with a large data set, you can
    leverage parallelism (multithreading) to help out. In any case, run a proper benchmark
    to ensure you optimize the right thing and assess your real gains. Look at BenchmarkDotNet
    ([https://adpg.link/C5E9](https://adpg.link/C5E9)) if you are looking at benchmarking
    .NET code.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we have defined the actors and explored the code, let’s see what is
    happening in our consumer (the `Client`):'
  prefs: []
  type: TYPE_NORMAL
- en: The `Client` uses the registered `SearchMachine` instances and searches for
    values 1, 10, and 11.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterward, `Client` displays to the user whether the numbers were found or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Find` method returns `null` when it does not find a value and, by extension,
    the `IndexOf` method.By running the program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output shows the two algorithms at play. Both `SearchMachine`
    implementations did not contain the value `11`. They both contained the values
    `1` and `10` placed at different positions. Here is a reminder of the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer was iterating the `SearchMachine` registered with the IoC container.
    The base class implements the `IndexOf` but delegates the search (`Find`) algorithm
    to the subclasses. The preceding output shows that each `SearchMachine` could
    execute the expected task by implementing only the `Find` piece of the algorithm.And
    voilà! We have covered the Template Method pattern, as easy as that. Of course,
    our algorithm was trivial, but the concept remains.To ensure the correctness of
    the implementation, I also created two tests, one per class. Here’s a test for
    the `LinearSearchMachine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test ensures that the correct values are found or not by the
    `IndexOf` method of the `LinearSearchMachine` class.Next is a similar test for
    the `BinarySearchMachine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test does a similar job of ensuring that the correct values are
    found or not by the `IndexOf` method of the `BinarySearchMachine` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add `virtual` methods in the base class to create optional hooks. Those
    methods would become optional extension points that subclasses can implement or
    not. That would allow a more complex and more versatile scenario to be supported.
    We will not cover this here because it is not part of the pattern itself, even
    if very similar. There are many examples in the .NET **base class library** (**BCL**),
    like most methods of the `ComponentBase` class (in the `Microsoft.AspNetCore.Components`
    namespace). For example, when overriding the `OnInitialized` method in a Blazor
    component, we leverage an optional extension hook. The base method does nothing
    and is there only for extensibility purposes, allowing us to run code as part
    of the component’s lifecycle. You can consult the `ComponentBase` class code in
    the official .NET repo on GitHub: [https://adpg.link/1WYq](https://adpg.link/1WYq).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This concludes our study of another simple yet powerful design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Template Method is a powerful and easy-to-implement design pattern allowing
    subclasses to reuse the algorithm’s skeleton while implementing (abstract) or
    overriding (virtual) subparts. It allows implementation-specific classes to extend
    the core algorithm. It can reduce the duplication of logic and improve maintainability
    while not cutting out any flexibility in the process. There are many examples
    in the .NET BCL, and we leverage this pattern at the end of the chapter based
    on a real-world scenario.Now, let’s see how the Template Method pattern can help
    us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: The Template Method pushes algorithm-specific portions of the code to
    subclasses while keeping the core algorithm in the base class. Doing that helps
    follow the **single responsibility principle** (**SRP**) by distributing responsibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: By opening extension hooks, it opens the template for extensions (allowing
    subclasses to extend it) and closes it from modifications (no need to modify the
    base class since the subclasses can extend it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: As long as the subclasses are the implementations and do not alter the
    base class per se, following the **Liskov substitution principle** (**LSP**) should
    not be a problem. However, this principle is tricky, so it is possible to break
    it; by throwing a new type of exception or altering the state of a more complex
    base class in a way that changes its behavior, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: As long as the base class implements the smallest cohesive surface possible,
    using the Template Method pattern should not negatively impact the program. On
    top of this, having a smaller interface surface in classes diminishes the chances
    of breaking the LSP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The Template Method pattern is based on an abstraction, so as long as
    consumers depend on that abstraction, it should help to get in line with the **dependency
    inversion principle** (**DIP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we move to the Chain of Responsibility design pattern before mixing the
    Template Method and the Chain of Responsibility pattern to improve our code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Chain of Responsibility pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Chain of Responsibility** is a GoF behavioral pattern that chains classes
    to handle complex scenarios efficiently, with limited effort. Once again, the
    goal is to take a complex problem and break it into multiple smaller units.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern aims to chain multiple handlers that each
    solve a limited number of problems. If a handler cannot solve the specific problem,
    it passes the resolution to the chain’s next handler.
  prefs: []
  type: TYPE_NORMAL
- en: We often create a default handler that executes logic at the end of the chain
    as the terminal handler. Such a handler can throw an exception (for example, `OperationNotHandledException`)
    to cascade the issue up the call stack to a consumer who knows how to handle and
    react to it. Another strategy is creating a terminal handler that does the opposite
    and ensures nothing happens.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic Chain of Responsibility starts by defining an interface that
    handles a request (`IHandler`). Then we add classes that handle one or more scenarios
    (`Handler1` and `Handler2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Class diagram representing the Chain of Responsibility pattern](img/file69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Class diagram representing the Chain of Responsibility pattern'
  prefs: []
  type: TYPE_NORMAL
- en: A difference between the Chain of Responsibility pattern and many other patterns
    is that no central dispatcher knows the handlers; all handlers are independent.
    The consumer receives a handler and tells it to handle the request. Each handler
    determines if it can process the request. If it can, it processes it. In both
    cases, it also evaluates if it should forward the request to the next handler
    in the chain. The handler can execute these two tasks in any order, like executing
    some logic, sending the request down the chain, then executing more logic when
    the request comes back (like a pipeline).This pattern allows us to divide complex
    logic into multiple pieces that handle a single responsibility, improving testability,
    reusability, and extensibility in the process. Since no orchestrator exists, each
    chain element is independent, leading to a cohesive and loosely coupled design.
  prefs: []
  type: TYPE_NORMAL
- en: When creating the chain of responsibility, you can order the handlers so that
    the most requested handlers are closer to the beginning of the chain and the least
    requested handlers are closer to the end. This helps limit the number of “chain
    links” that are visited for each request before reaching the right handler.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enough theory; let’s look at some code.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Message interpreter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We need to create the receiving end of a messaging application
    where each message is unique, making it impossible to create a single algorithm
    to handle them all.After analyzing the problem, we decided to build a chain of
    responsibility where each handler can manage a single message. The pattern seems
    more than perfect!'
  prefs: []
  type: TYPE_NORMAL
- en: This project is based on something that I built years ago. IoT devices were
    sending bytes (messages) due to limited bandwidth. Then, we had to associate those
    bytes with real values in a web application. Each message had a fixed header size
    but a variable body size. The headers were handled in a base handler (template
    method), and each handler in the chain managed a different message type. For the
    current example, we keep it simpler than parsing bytes, but the concept is the
    same.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For our demo application, the messages are as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Name` property is used as a discriminator to differentiate messages, and
    each handler is responsible for doing something with the `Payload` property.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t do anything with the payload as it is irrelevant to the pattern, but
    conceptually, that is the logic that should happen.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The handlers are very simple, here’s the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing a handler can do is handle a message. Our initial application
    can handle the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AlarmTriggeredHandler` class handles `AlarmTriggered` messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AlarmPausedHandler` class handles `AlarmPaused` messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AlarmStoppedHandler` class handles `AlarmStopped` messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real-world logic is that a machine can send an alarm to a REST API indicating
    it has reached a certain threshold. Then the REST API can push that information
    to a UI, send an email, a text message, or whatnot.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An alerted human can then pause the alarm while investigating the issue so other
    people know the alarm is getting handled.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finally, a human can go to the physical device and stop the alarm because the
    person has resolved the issue.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We could extrapolate on many more sub-scenarios, but this is the gist.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The three handlers are very similar and share quite a bit of logic, but we
    fix that later. In the meantime, we have the following handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each handler does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It receives an optional “next handler” from its constructor (highlighted in
    the code). This creates a chain similar to a singly linked list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles only the request it knows about, delegating the others to the next
    handler in the chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use `Program.cs` as the consumer of the Chain of Responsibility (the
    Client) and use a POST requests to interface with our REST API and build the message.Here
    is the first part of our REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we manually create the Chain of Responsibility and register
    it as a singleton bound to the `IMessageHandler` interface. In that registration
    code, each handler is manually injected in the previous constructor (created with
    the `new` keyword).The next code represents the second half of the `Program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The consuming endpoint is reachable through the `/handle` URL and expects a
    `Message` object in its body. It then uses the injected implementation of the
    `IMessageHandler` interface and passes it the message. If we run any of the HTTP
    requests in the `ChainOfResponsibility.http` file, we get a successful result
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that even if we send an invalid message, there is no way to
    know from the consumer, so it is always valid even when no handler picks up the
    message.To handle this scenario, let’s add a fourth handler (terminal handler)
    that notifies the consumers of invalid requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This new terminal handler throws an exception that notifies the consumers about
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: We can create custom exceptions to make differentiating between system and application
    errors easier. In this case, throwing a system exception is good enough. In a
    real-world application, I recommend creating a custom exception that represents
    the end of the chain and contains the relevant information for the consumers to
    react to it according to your use case.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, let’s register it in our chain (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we send a POST request with the name `SomeUnhandledMessageName`, the endpoint
    now yields the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good, but the experience is not great, so let’s add a try-catch
    block to handle this in the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we send an invalid message, the API gently returns the following
    message to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of course, when you expect machines to consume your APIs, you should produce
    a data structure that is easier to parse, like using JSON.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And voilà. We have built a simple Chain of Responsibility that handles messages.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Chain of Responsibility pattern is another great GoF pattern. It divides
    a large problem into smaller, cohesive units, each doing one job: handling its
    specific request(s).Now, let’s see how the Chain of Responsibility pattern can
    help us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: The Chain of Responsibility pattern aims to this exact principle: create
    a single unit of logic per class!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: The Chain of Responsibility pattern allows the addition, removal, and
    reordering of handlers without touching the code but by altering the chain''s
    composition in the composition root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: The Chain of Responsibility pattern helps with the ISP if we create
    a small interface. The handler interface is not limited to a single method; it
    can expose multiple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: By using the handler interface, no element of the chain, nor the consumers,
    depends on a specific handler; they only depend on the interface that represents
    the chain, which helps invert the dependency flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s use the Template Method and Chain of Responsibility patterns to
    encapsulate our handlers’ duplicated logic.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing the Template Method and Chain of Responsibility patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section explores a combination of two powerful design patterns: the Template
    Method and the Chain of Responsibility. As we are about to explore, those two
    patterns fit together well. We use the Template Method pattern as the base structure,
    providing the handlers'' blueprint. Meanwhile, the Chain of Responsibility pattern
    manages the handling sequence, ensuring each request is routed to the correct
    handler.When these two patterns work in tandem, they form a robust framework that
    facilitates easy management, maintains order, and increases the adaptability of
    our system.'
  prefs: []
  type: TYPE_NORMAL
- en: Project – Improved message interpreter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know both the **Chain of Responsibility** and the **Template Method**
    patterns, it is time to *DRY* out our handlers by extracting the shared logic
    into an abstract base class using the Template Method pattern and providing extension
    points to the subclasses.OK, so what logic is duplicated?
  prefs: []
  type: TYPE_NORMAL
- en: The `next` handler injection code is the same in all but the terminal handlers.
    Moreover, this is an important part of the pattern we should encapsulate in the
    base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logic testing whether the current handler can handle the message is also
    the same in all but the terminal handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create a new base class that implements the Template Method pattern and
    a large part of the logic of our chain of responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on those few changes, what is the template method, and what are the extension
    points (hooks)?The `MessageHandlerBase` class adds the `Handle` template method.
    Then, the `MessageHandlerBase` class exposes the following extension points:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CanHandle` method tests whether `HandledMessageName` is equal to the value
    of the `message.Name` property. A subclass can override this method if it requires
    a different comparison logic. This method is an optional hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All subclasses must implement the `HandledMessageName` property, which is the
    key driver of the `CanHandle` method. This property is a mandatory hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All subclasses must implement the `Process` method, allowing them to run their
    logic against the message. This method is a mandatory hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how these hooks play out, let’s take a look at the three simplified
    alarm handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the updated alarm handlers, they are now limited to a single
    responsibility: processing the messages they can handle. In contrast, `MessageHandlerBase`
    now handles the chain of responsibility’s plumbing. We left the `DefaultHandler`
    class unchanged since it is the end of the chain and does not support having a
    next handler, nor processing messages.Mixing those two patterns created a complex
    messaging system that divides responsibilities into handlers. There is one handler
    per message, and the chain logic is pushed into a base class.The beauty of such
    a system is that we don’t have to think about all the messages simultaneously;
    we can focus on just one message at a time. When dealing with a new type of message,
    we can focus on that precise message, implement its handler, and forget about
    the other *N* types. The consumers can also be super dumb, sending the request
    into the pipe without knowing about the Chain of Responsibility, and like magic,
    the right handler shall prevail!Nonetheless, have you noticed an issue with this
    design? Let’s have a look next.'
  prefs: []
  type: TYPE_NORMAL
- en: Project – A final, finer-grained design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last example, we used `HandledMessageName` and `CanHandle` to decide
    whether a handler could handle a request. There is one problem with that code:
    if a subclass decides to override `CanHandle`, and then decides that it no longer
    requires `HandledMessageName`, we would end up having a lingering, unused property
    in our system.'
  prefs: []
  type: TYPE_NORMAL
- en: There are worse situations, but we are talking component design here, so why
    not push that system a little further toward a better design?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'One way to fix this is to create a finer-grained class hierarchy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Class diagram representing the design of the finer-grained project
    that implements the Chain of Responsibility and Template Method patterns](img/file70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Class diagram representing the design of the finer-grained project
    that implements the Chain of Responsibility and Template Method patterns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram looks more complicated than it is. But let’s look at
    our refactored code first, starting with the new `MessageHandlerBase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MessageHandlerBase` class manages the Chain of Responsibility by handling
    the next handler logic and by exposing two hooks (the Template Method pattern)
    for subclasses to extend:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool CanHandle(Message message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Process(Message message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This class is similar to the previous one, but the `CanHandle` method is now
    abstract, and we removed the `HandledMessageName` property leading to a better
    responsibility segregation and better hooks.Next, let’s look at the `SingleMessageHandlerBase`
    class, which replaces the logic we removed from the `MessageHandlerBase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SingleMessageHandlerBase` class inherits from the `MessageHandlerBase`
    class and overrides the `CanHandle` method. It implements the logic related to
    it and adds the `HandledMessageName` property that subclasses must define for
    the `CanHandle` method to work (a required extension point).The `AlarmPausedHandler`,
    `AlarmStoppedHandler`, and `AlarmTriggeredHandler` classes now inherit from `SingleMessageHandlerBase`
    instead of `MessageHandlerBase`, but nothing else has changed. Here’s the code
    as a reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Those subclasses of `SingleMessageHandlerBase` implement the `HandledMessageName`
    property, which returns the message name they can handle, and they implement the
    handling logic by overriding the `Process` method as before.Next, we look at the
    `MultipleMessageHandlerBase` class, which enables its sub-types to handle more
    than one message type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MultipleMessageHandlerBase` class does the same as `SingleMessageHandlerBase`,
    but it uses a string array instead of a single string, supporting multiple handler
    names.The `DefaultHandler` class has not changed. For demonstration purposes,
    let’s add the `SomeMultiHandler` class that simulates a message handler that can
    handle `"Foo"`, `"Bar"`, and `"Baz"` messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This class hierarchy may sound complicated, but what we did was to allow extensibility
    without the need to keep any unnecessary code in the process, leaving each class
    with a single responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: The `MessageHandlerBase` class handles `_next`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SingleMessageHandlerBase` class handles the `CanHandle` method of handlers
    supporting a single message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MultipleMessageHandlerBase` class handles the `CanHandle` method of handlers
    supporting multiple messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other classes implement their version of `Process` method to handle one or more
    messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And voilà! This is another example demonstrating the strength of the Template
    Method and Chain of Responsibility patterns working together. That last example
    also emphasizes the importance of the SRP by allowing greater flexibility while
    keeping the code reliable and maintainable.Another strength of that design is
    the interface at the top. Anything that does not fit the class hierarchy can be
    implemented directly from the interface instead of trying to adapt logic from
    inappropriate structures. The `DefaultHandler` class is a good example of that.
  prefs: []
  type: TYPE_NORMAL
- en: Tricking code into doing your bidding instead of properly designing that part
    of the system leads to half-baked solutions that become hard to maintain.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mixing the Template Method and the Chain of Responsibility patterns leads to
    smaller classes with a single responsibility each.We removed the lingering property
    while keeping that logic out of the handlers. We even extended the logic to more
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we covered two GoF behavioral patterns. These patterns can
    help us create flexible yet easy-to-maintain systems. As the name suggests, behavioral
    patterns aim at encapsulating application behaviors into cohesive pieces.First,
    we looked at the Template Method pattern, which allows us to encapsulate an algorithm’s
    outline inside a base class, leaving some parts open for modification by subclasses.
    The subclasses then fill in the gaps and extend that algorithm at those predefined
    locations. These locations can be required (`abstract`) or optional (`virtual`).Then,
    you learned about the Chain of Responsibility pattern, which opens the possibility
    of chaining multiple small handlers into a chain of processing, inputting the
    message to be processed at the beginning of the chain (the interface), and waiting
    for one or more handlers to execute the logic related to that message against
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to stop the chain’s execution at the first handler. The Chain
    of Responsibility can become a pipeline instead of associating one message to
    one handler, as we explored.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lastly, leveraging the Template Method pattern to encapsulate the Chain of Responsibility’s
    chaining logic led us to a simpler, robust, flexible, and testable implementation
    without any sacrifices. The two design patterns fits very well together.In the
    next chapter, we dig into the Operation Result design pattern to discover efficient
    ways of managing return values.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the main goal of the Template Method pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main goal of the Chain of Responsibility pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that we can only add one `abstract` method when implementing the
    Template Method design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we use the Strategy pattern in conjunction with the Template Method pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that there is a limit of 32 handlers in a Chain of Responsibility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a Chain of Responsibility, can multiple handlers process the same message?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what way can the Template Method help implement the Chain of Responsibility
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Template Method pattern encapsulates an algorithm's outline in a base class
    while leaving some parts of that algorithm open for modification by its subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern divides a larger problem into small pieces
    (handlers). Each piece is self-governed, while the chain's existence is abstracted
    from its consumers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False; you can create as many `abstract` (required) or `virtual` (optional)
    extension points (hooks) as you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, there is no reason not to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, there is no greater limit than with any other code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, you can have one handler per message or multiple handlers per message.
    It is up to you and your requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It helps divide responsibilities between classes by encapsulating the shared
    logic into one or more base classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
