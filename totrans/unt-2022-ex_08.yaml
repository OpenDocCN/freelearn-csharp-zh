- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing the Adventure Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), we covered the larger scope
    of the adventure game by extending the **Game Design Document** (**GDD**) for
    the game and explored the level and environment design while also considering
    new principles to guide the player. We also imported and prepped artwork for use
    with additional 2D tooling that will bring the game to life.
  prefs: []
  type: TYPE_NORMAL
- en: We also challenged the player by exploring and adding moving platforms and interactive
    elements in the level design, immersing the player with a parallax effect on a
    layered background, and optimizing the sprite draw calls to keep things performant.
  prefs: []
  type: TYPE_NORMAL
- en: With the game level and environment established, we can now move on to creating
    our player character using the 2D Animation package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the player character with PSD Importer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an Input Action Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the player with a player controller script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the character with Mecanim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to set up a 2D sprite-based character
    rigged for animation and driven by player input. You’ll also be able to assign
    and transition between different animations required for the player’s current
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along in this chapter and use the same artwork that was created for
    the project in this book, download the adventure game 2D art assets from the following
    GitHub link: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets).'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop or use a graphics program that can export layered PSD/PSB
    files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the player character with PSD Importer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating our player character for the 2D adventure game will be a multi-step
    process. In this section, we’ll cover all the steps required to make an animated
    2D character controlled by the player.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the import settings for the artwork and setting up the character
    bones that will allow us to animate. You’ll repeat these actions many times throughout
    a project while importing artwork and assets. **PSD Importer** is an asset importer
    that can work with multilayered PSB/PSD files to create a Prefab of sprites based
    on the source layers.
  prefs: []
  type: TYPE_NORMAL
- en: The import options allow Unity to generate both a sprite sheet and a character
    rig that arranges the sprites according to their original position and layer order,
    significantly simplifying the creation of a sprite-based animated character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and import the artwork for the player character. Here, we will
    set up the source file so that it uses PSD Importer to create the actor (the Prefab
    created based on the multilayered Photoshop file is called an **actor**):'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in the `Assets/Sprites/Character` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `PlayerCharacter1.psd` into the newly created folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the imported file and, in the **Inspector** window, change **Importer**
    to **UnityEditor.U2D.PSD.PSDImporter** in the dropdown list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PSD Importer** provides two new options that appear as tabs once it’s selected
    as the importer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Settings**: This is where you will set the properties for how the file will
    be imported. The fields under **Settings** are similar to the default texture
    importer, with the addition of the **Layer Import** (when **Texture Type** is
    set to **Multiple**) and **Character** **Rig** sections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer Management**: This is where you can customize which layers from the
    Photoshop file are imported'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the default import settings, we are already in good shape to continue with
    the player character setup since we’ll be using all the layers. The importer will
    keep the layer positions and sorting order from Photoshop so that our character
    sprites are arranged correctly for our actor.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t have to recreate the player character in Unity from the individual
    sprites that make up the character – arms, torso, legs, head, and so on. So, we
    are ready for the next step – rigging the character by adding bones.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Preparing and importing artwork: [https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'PSD Importer Inspector properties: [https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Rigging the actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the actor (the player character PSD file) still selected in the **Project**
    window, click the **Open Sprite Editor** button in the **Inspector** window. The
    default view is the sliced sprite shape representing our Photoshop layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry – as I said, we won’t have to work with our character in a dismembered
    way, as shown in *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Actor sprite sheet](img/B18347_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Actor sprite sheet
  prefs: []
  type: TYPE_NORMAL
- en: If the artwork is shown with the individual sprites representing the Photoshop
    layers, then we need to switch to **Sprite Skinning Editor** (part of the 2D Animation
    package), where we’ll continue setting up the animation rig for the actor.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Sprite Editor** dropdown, select **Skinning Editor** – the sprites
    should now represent the character, as seen in the original Photoshop source file.
    Sweet!
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire workflow of setting up the actor for animations looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a rig**: A skeleton made up of individual bones.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generate mesh geometry**: This will influence the sprite’s position, rotation,
    and, optionally, deformation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adjust bone influence**: Change the attributes of a sprite to specify which
    bone or bones affect it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adjust weights**: How much a bone, or bones, influence a given sprite (the
    entire sprite, or just part(s) of it).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Preview pose**: Test, test, and test again regarding the rig and sprite bone,
    geometry, and weight assignments until everything is looking and working correctly
    when bones are moved or rotated; this is a cyclical process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inverse kinematics** (**IK**): You can apply IK to a chain of bones to automatically
    calculate positions and rotations that make it much easier to animate the actor’s
    limbs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Inverse kinematics (IK)
  prefs: []
  type: TYPE_NORMAL
- en: IK is a technique that’s used in computer animation and robotics to control
    the position and orientation of limbs. It calculates the joint angles required
    to place the end effector in a given position and orientation – endpoints such
    as hands and feet. It’s useful for creating natural and realistic human motion,
    especially for complex poses.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more at [https://docs.unity3d.com/Manual/InverseKinematics.xhtml](https://docs.unity3d.com/Manual/InverseKinematics.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Animate**: Create animations for the actor’s different gameplay states, such
    as idle, walking, jumping, and attacking.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Game development is a multidisciplinary craft that combines both technical and
    artistic skills. Creating a character rig with individual bones to affect individual
    sprites combines both skill sets. Thankfully, the rigging process is non-destructive,
    so we’ll be able to go back and make changes at any time to adjust and fix anything
    that doesn’t seem to be working well or look correct.
  prefs: []
  type: TYPE_NORMAL
- en: The general creation process we’ll follow when creating the rig is to start
    with the pelvic bone – this bone will represent the *true center* of the character.
    Moving or rotating this bone will affect all child bones in the rig, moving the
    entire actor.
  prefs: []
  type: TYPE_NORMAL
- en: This first bone we’ll create can be seen in *Figure 5**.2* as the small red
    bone pointing upwards in the pelvic area of the character. In the bone hierarchy
    (as shown in the `bone_1`, is the root bone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our bones! Perform the following steps to develop the whole character
    rig:'
  prefs: []
  type: TYPE_NORMAL
- en: We should already be in **Skinning Editor**; if not, select it from the **Sprite**
    **Editor** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To view the hierarchy of the bones being created (or to manage the visibility
    of the sprites you’re working with), toggle on the **Visibility** panel (the top
    right of the window next to **Revert** and **Apply**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, under the **Bones** section (the left-hand side of the window), select
    the **Create Bone** button – your cursor should now have a red dot at the tip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start at the character’s pelvis and click to start creating the root bone. Click
    again slightly above the first click point to make the small red root bone – refer
    to *Figure 5**.2* for the general size and orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue by clicking again to create a bone that will represent the lower portion
    of the torso (yellow bone) and again to make a bone for the upper part of the
    torso (green bone); this will allow us to bend the character’s torso (for example,
    arching forward or backward).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving up the spine, create two additional bones – a small bone for the neck
    and another for the head (refer to *Figure 5**.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click or press the *Esc* key to stop creating bones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our actor now has a spine (if you’ll forgive the pun). Creating the limbs will
    follow a similar process, but the critical difference in creating bones for limbs
    is to first select the bone that will parent the limb bones. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With **Create Bone** still selected, click on the upper torso bone (green).
    You should now see a semi-transparent bone coming from the bone that was just
    clicked (this indicates parenting; you can also see this in the **Visibility**
    window’s **Bone** **Hierarchy** view).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll start by creating a limb for the character’s left arm (the arm behind
    the torso), so click where the left shoulder joint should be to begin making bones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that to make placing bones easier for sprites behind others, you can toggle
    the visibility off for the sprites in front by using the **Visibility** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep clicking to create bones for the upper arm, lower arm, and hand (refer
    to *Figure 5**.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click or press the *Esc* key to stop creating bones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue creating the other limb bones for the right arm and both legs by selecting
    the parent bone again – for the legs, parent to the pelvic bone (the red root
    bone we started creating the rig from).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your actor’s entire skeleton rig should look similar to the rig shown in *Figure
    5**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The actor rig and Auto Geometry with Weights](img/B18347_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The actor rig and Auto Geometry with Weights
  prefs: []
  type: TYPE_NORMAL
- en: If you want to have your bones named more intelligibly – making it easier for
    you to know which bones you are working with – you can easily rename them while
    using the `bone_14` to `foot_right`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the rig is just the first step in making a fully animatable character.
    Let’s take the next step by assigning the sprite’s mesh geometry to the rig’s
    bones – as you continue to work with the rig, it may help to know that the sprite
    mesh geometry a bone influences will be the same color as the bone.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the sprite mesh geometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the sprite mesh geometry and apply default
    bone weights that will influence the sprites that we’ll start with:'
  prefs: []
  type: TYPE_NORMAL
- en: First, double-click in the checkered area to unselect all sprites (noting that
    this action is not apparent).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Auto Geometry** button under the **Geometry** section (the left-hand
    side of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Geometry** panel at the window’s bottom-right section, ensure **Weights**
    is enabled; this will automatically generate bone weights along with the mesh
    geometry, saving a step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish up by clicking the **Generate For All** **Visible** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '2D Animation | Editor tools and shortcuts: [https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the **Generate For All Visible** button for the geometry, all
    your sprites will have taken on coloring from the associated bones. You’ll notice
    that it does not look like the solid colors seen in *Figure 5**.2* since the generated
    weights were distributed across adjacent bones; instead, the coloring will be
    a gradient of the adjoining bone colors.
  prefs: []
  type: TYPE_NORMAL
- en: This is due to both the overlapping sprites and Unity wanting to blend the sprite
    deformation across the bones, which is desired in some cases. We’ll be addressing
    this shortly in the *Editing sprite bone weights* section for the torso and neck
    sprites. For the remainder of the sprites, we only want one bone to influence
    a sprite (represented by the solid color) for this particular character.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll fix this by adjusting the bone influence for each sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the bone influence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process we’re going to follow is to remove – or set – bones in the **Bone
    Influences** property of the sprites. This will ensure that our character’s sprites
    are not deformed or distorted while positioned or rotated by only assigning a
    single bone.
  prefs: []
  type: TYPE_NORMAL
- en: For a different style character, we may very well want a single sprite to be
    deformed by multiple bones (as we will do shortly with the torso and neck), but
    that is not what we want for the style character we’re building here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to assign the correct bone influence for all of
    the sprites (again, except for the torso and neck):'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Bone Influence** button under the **Weights** section (the left-hand
    side of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on a sprite. For example, in *Figure 5**.3*, we’ll double-click
    on the *wing* for the right foot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The panel in the bottom right of the window will now show the selected sprite
    and the bones influencing it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we only want one bone to influence the sprite, we’ll select `bone_13`
    (the yellow bone) in the list and then click the minus (**-**) button on the small
    tab below the list to remove it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The sprite will turn the same color as the remaining assigned bone, which is
    green in this case, as seen in *Figure 5**.3*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Bone Influence editing](img/B18347_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Bone Influence editing
  prefs: []
  type: TYPE_NORMAL
- en: Note that if there is more than one bone to remove, you can select multiple
    bones by holding the *Ctrl*/*Cmd* key down while clicking and then clicking the
    minus (**-**) button.
  prefs: []
  type: TYPE_NORMAL
- en: This workflow was for assigning a single bone to a sprite. Next, we’ll learn
    how to use multiple bones to influence the deformation of a sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Editing sprite bone weights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use two weight tools to assign the bones and adjust the weight influence
    each bone has over the sprite: **Weight Slider** and **Weight Brush**.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with **Weight Slider** to adjust the overall influence of the bones
    and then perform any fine-tuning with **Weight Brush**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Auto Weights** generation may have already performed an excellent job
    but let’s examine the results and make some adjustments, starting with the neck
    sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the neck sprite (note that you can use the mouse scroll wheel
    to zoom in on a sprite to work with it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Auto Weights** assigned three bones with influence over the neck sprite,
    so this sprite should have a color gradient representing the color of the three
    bones: the (green) upper torso, (cyan) neck, and (blue) head bone (see *Figure
    5**.4*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Weight Slider** button under the **Weights** section (the left-hand
    side of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Weight Slider** panel in the window’s lower-right corner, you can now
    adjust the amount of influence a selected bone has over the sprite; drag the **Amount**
    slider left or right to increase or decrease the influence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Preview the effect of weight changes to see how the mesh deforms by rotating
    the bones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can rotate and move bones by simply clicking and dragging on them (the
    mouse cursor will show a rotate or move icon, depending on where you are hovering
    on the bone). Adjust the **Weight Slider** amount until you get overall pleasing
    results – this operation is a lot more artistic than technical:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Editing weights with Weight Brush](img/B18347_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Editing weights with Weight Brush
  prefs: []
  type: TYPE_NORMAL
- en: You may find it challenging to get good results using **Weight Slider** alone.
    In this case, continue to fine-tune the bone influence for any problem areas using
    **Weight Brush**.
  prefs: []
  type: TYPE_NORMAL
- en: With the sprite still selected, select the **Weight Brush** button under the
    **Weights** section (the left-hand side of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the bone you want to paint weights for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now adjust the **Weight Brush** properties in the **Weight Brush** panel
    in the window’s lower-right corner or start painting weights. The sprite mesh
    geometry will update in real time as you paint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue to rotate the bones by hovering your mouse over the bone to show the
    rotate icon. Then, click and drag to rotate the bone to test the weight painting
    and adjust it until you’ve achieved the desired results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that you can undo bone rotations using *Ctrl*/*Cmd* + *Z*. If you’ve made
    many bone rotations and aren’t sure how much influence is being applied, then
    you can use the **Reset Pose** button under the **Pose** section (the top-left
    corner of the window) to start over.
  prefs: []
  type: TYPE_NORMAL
- en: Continue to repeat this process for the actor’s torso. Once you’re finished
    with the torso, this is probably a great time to think about saving your work.
    Use the **Apply** button in the toolbar on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re relatively satisfied with the bone weights and want to see how things
    are progressing, you can do some pose tests! Doing some pose tests allows you
    to test the range of motion and see if the sprites are associated with only the
    correct bones that influence the sprite weights without undesirable distortion.
    This provides you with the first indication of how the character may look when
    animated.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.5* represents an example of a test pose for the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Pose test for the actor](img/B18347_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Pose test for the actor
  prefs: []
  type: TYPE_NORMAL
- en: Being able to pose our character is great, but for the limbs, in particular,
    it can be time-consuming and challenging to get good results by rotating all the
    bones individually. Thankfully, there is a better way – using **IK**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up inverse kinematics (IK)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve now finished working with **Skinning Editor** and will continue working
    with the actor in the scene to add IK. So, let’s create a Prefab from the actor
    for our player character:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `PlayerCharacter1` asset from the **Project** window into the **Hierarchy**
    window or **Scene** view (optionally, you can create a new empty scene to work
    in).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parent the actor to a new empty GameObject and name it `Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, drag the GameObject into the `Assets/Prefabs` folder to create the Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we’ll be using an IK setup to position our actor for animation, we’ll
    want to change the actor’s rig to make posing the limbs – in particular, the legs
    – much better. We could have done this when we first created the actor’s rig,
    but it’s easier to show the reason for this change while implementing IK, and
    it shows that we can go back and make changes to the bone structure at any time
    and make corrections where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll be adding a new root bone to the rig using the same **Create Bone**
    workflow we used to create the actor’s complete skeleton rig:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new bone at the feet of the actor and name it `root_bone`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the color to gray (just as an indication to us that no sprites are being
    influenced by it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, click and drag the existing rig (`bone_1`) to parent it to the new root
    bone, as shown in *Figure 5**.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Adding root_bone for IK and the parent existing rig](img/B18347_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Adding root_bone for IK and the parent existing rig
  prefs: []
  type: TYPE_NORMAL
- en: Be patient with me – this will all make sense in a bit when we add **IK Limb
    Solvers** for the legs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding IK Solvers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will make IK-constrained limbs for the arms and legs, starting with the right
    arm (the arm in front of the actor).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add GameObjects that act as our IK Effectors (the transform the
    IK Solver solves for) and work in tandem with the limb solver’s Target:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the forearm bone of the arm in front of the character’s torso – `bone_7`
    in my case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it in the **Inspector** window and click **Create Empty** to
    add a child GameObject – this will make the new object a sibling of the hand bone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it `IK Effector` and then position it at the tip of the forearm bone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the red arrow of the position tool gizmo, drag it down, extending it past
    the hand just a bit. Positioning the effector outside of the sprites will make
    them more visible and easier to click on to manipulate (this step is purely personal
    preference; you may also leave it at the tip of the forearm bone).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat these steps for the other arm (the arm behind the actor) and both legs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our effectors in place, add the `IK Manager 2D` component to the root bone
    and start adding **IK Solvers** for the limbs by clicking the plus (**+**) button
    in the tab and then selecting **Limb**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re making this selection because it’s meant for posing joints specifically
    for arms and legs (also known as a **two-bone Solver**).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'IK Solvers: [https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an `LimbSolver2D` component added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the IK limb setup for the front arm:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename `New LimbSovler2D` to `Front Arm LimbSolver2D` and keep it selected so
    that the `LimbSolver2D` component is visible in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the `IK Effector` object for the front forearm to the `LimbSolver2D`
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this `_Target` child GameObject for the limb solver that we can now manipulate
    the position of in the **Scene** view to pose the limb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the circle icon that has now appeared on the **Target** transform
    in the **Scene** view to test out the IK limb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the default value for **Flip** is disabled, which may work just fine
    for how the target was created, but if the limb is bending backward as you drag
    the target around, then enable **Flip** to solve this issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 5**.7* illustrates the results of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – IK Effector and limb solver setup](img/B18347_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – IK Effector and limb solver setup
  prefs: []
  type: TYPE_NORMAL
- en: The `Front Arm LimbSolver2D_Target` object’s transform position is what is keyframed
    during animation.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Once the IK Solvers have been set up, we can no longer scale the player character
    with the **Pixels Per Unit** value in the **PSD Importer** settings – this is
    due to the IK targets being based on the transform local positions, which won’t
    update when the sprite’s PPU is scaled. Instead, change the transform scale on
    the parented **PlayerCharacter1** object.
  prefs: []
  type: TYPE_NORMAL
- en: You can now follow these steps any time you need to create an IK limb on a skinned
    actor rig. Go ahead and make IK limbs for the back arm and both legs. With that,
    we’re ready to animate!
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to apply changes to the **Player** Prefab!
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources | 2D characters
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option for getting a head start on creating your rigged and animated
    2D characters is to work with existing example characters from either the Dagon
    Crashers or Lost Crypt sample projects that Unity provides on the Asset Store:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dragon Crashers: [https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721](https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lost Crypt: [https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673](https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating actor animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Actor animation** is the process of repositioning or rotating the actor’s
    bones at different times on the timeline of the **Animation** window, which is
    recorded as keyframes that hold the transform data. In [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    we performed a simpler version of this process when we animated the vines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start animating the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll make an idle animation by opening the **Animation** window by going
    to **Window** | **Animation** | **Animation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `PlayerCharacter1` in the hierarchy (not the root `Player` object; we
    want to animate the *graphics*, which can be later switched out with a different
    actor that may not have the same skeletal rig) and click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create an animation asset file (`.anim`) that we’ll name `Player Idle`
    and save to the `Assets/Animation` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, put your animator hat on again, because it’s time to animate!
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note while animating with IK limbs is why we added the new
    root bone in the *Setting Up inverse kinematics (IK)* section. Select the `bone_1`,
    our *original* root bone).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that a square outline has appeared at the larger end of the bone
    (the base) and that hovering the mouse pointer within this square will show a
    move icon. Hovering over the part of the bone outside of the square will show
    a rotate icon. Click and hold the left-mouse button within the square and slowly
    drag it down.
  prefs: []
  type: TYPE_NORMAL
- en: The whole actor will start to move down except for the feet – they will remain
    firmly grounded in place. This would not be possible without IK and the new root
    bone we added. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing to note with the IK limbs before letting you lose to create
    your idle animation – you can position the limbs in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By clicking and dragging the IK circular targets in the **Scene** view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By selecting the `… LimbSolver2D_Target` objects in the **Hierarchy** window
    and using the **Move** tool in the **Scene** view (or entering **Transform** values
    in the **Inspector** window)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not try to keyframe individual bones in the IK chains, the IK Effector objects,
    or the objects with the `LimbSolver2D` components! Create your idle animation
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the red record button (the **Animation** window; **Keyframe Recording**
    mode) to start recording keyframes (any time a bone is rotated or repositioned,
    a key will be created).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pose your actor into a nice starting position for a simple idling in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scrub the timeline ahead about 1.5 seconds and make a second pose by lowering
    the torso bending into the knees, bending the arms, and tilting down the head
    slightly – something like that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to animate between these two poses, click and drag a rectangle around the
    starting frame’s keys – press *Ctrl*/*Cmd* + *C* to copy those keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scrub the timeline to 3 seconds and press *Ctrl*/*Cmd* + *V* to paste the keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the red record button again to stop recording, then use the **Play** button
    to check the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You know the drill – animation is more art than technical, so fiddle with the
    poses and timing until you get good results. *Figure 5**.8* illustrates a completed
    actor idle animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Actor keyframe idle animation](img/B18347_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Actor keyframe idle animation
  prefs: []
  type: TYPE_NORMAL
- en: Note that in *Figure 5**.8*, I’ve changed the color of the IK Solvers (the `IKManager2D`
    component on the `root_bone` object) to give the limb bones their own color –
    another way to visually organize the different components that make up the actor
    and make it a bit easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: With our base idle animation added to the character, let’s look at how to drive
    animation and apply movement to our character from player input.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Input Action Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll continue to use the new `Input System` package installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Package Manager** by going to **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default **Packages** location is **In Project**, so if you see **Input System**
    in the list under the **Package – Unity** section, then we’re all set!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you can’t find **Input System**, then switch the **Packages** dropdown to
    **Unity Registry**, select **Input System** from the list, and click **Install**
    (the bottom-right corner of the window). See [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041),
    section *New Input System* for a refresher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the collection game, we received input directly from **Input Device**; this
    time, we will use the **Input Action** approach. For that, we’re going to need
    an **Action** **Map** asset.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, creating a default action map for the player character is quite
    trivial – with most of the device inputs we’ll need for the keyboard and a game
    controller already made!
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: The magic happens via the `Player Input` component. So, add it to the root object
    of the `Player` Prefab by using the **Add Component** button in the **Inspector**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can work with the **Player** Prefab by adding it to a scene or working on
    it directly by double-clicking the Prefab in the **Project** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Player Input` component has been added, click the **Create Actions…**
    button, as shown in the following screenshot. This will create a default set of
    **Input Action Maps**, **Input Actions**, and **Input Bindings**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Player Input | Create Actions](img/B18347_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Player Input | Create Actions
  prefs: []
  type: TYPE_NORMAL
- en: You will be prompted to save the new `.inputactions` asset. Select the `Assets/Settings`
    folder and use `Player Input` as the name for it. This asset will then be connected
    to the `Player Input` component and bring up the **Input** **Actions editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we can see all of the actions pre-populated for the player action map,
    as shown in *Figure 5**.10* – everything we need plus more!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Player Input Action Maps (Input Actions)](img/B18347_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Player Input Action Maps (Input Actions)
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Input System: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Editing Input Actions Assets: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets).'
  prefs: []
  type: TYPE_NORMAL
- en: The `Player Input` component also provides everything we need to respond to
    input from the player. *Figure 5**.10* sets the `SendMessage()` on the GameObject
    to which the `Player Input` component belongs, calling the name on every component
    (`MonoBehaviour`) added to the GameObject. As shown in *Figure 5**.10*, the relevant
    method names will be called as listed in the box just below the **Behavior** field.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Notification behaviors: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors).'
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity’s sake, we’ll stick with the `SendMessage()`, which is slower
    due to having to use **Reflection**.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection | C#
  prefs: []
  type: TYPE_NORMAL
- en: '**SendMessage()** heavily relies on **Reflection** to find the method to call
    at runtime. **Reflection** is slow (supposedly 3x slower than calling the method
    directly) because it requires managed code to read (search) its metadata to find
    assemblies.'
  prefs: []
  type: TYPE_NORMAL
- en: With our input set up and we know how to respond to the inputs we’ve defined,
    we’re ready to write our player controller code!
  prefs: []
  type: TYPE_NORMAL
- en: Moving the player with a player controller script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll need more than just input to move our player character around the level.
    We’ll have to configure the `Player` object to work with the **Physics** system
    so that it interacts with our level’s ground and platforms and interactivity trigger
    volumes, and then applies the movement force.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the `Player` Prefab’s root GameObject with the following components
    while referring to *Figure 5**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Rigidbody2D` component (by pressing the `1`: We’ll add some drag to
    the player’s movement to provide additional constraints on the move to help the
    player feel more grounded and not very floaty.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Constraints** | **Freeze Rotation Z** enabled: We want to prevent the player
    from spinning around and have them always stand vertically (perpendicular to the
    ground plane).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `CapsuleCollider2D` (by pressing the **Add Component** button). Use the
    **Edit bounding volume** button and modify the collider’s shape until it encompasses
    the actor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This represents the player’s hitbox, which may need to be adjusted over time
    as you playtest:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Player physics setup](img/B18347_05_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.11 – Player physics setup
  prefs: []
  type: TYPE_NORMAL
- en: With the required `Player Input` component is only responsible for reading the
    device input and invoking the assigned action.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Player Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While we could use the device input directly, as we did in the *Player controller
    script* section of [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), it’s essential
    to understand the value of using **Input Action Map**. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple device inputs can be simultaneously configured without the need to
    change the input handling code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A different action map can be switched to, depending on the current input actions
    required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key rebinding can be implemented without changing the input handling code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with this knowledge, you can determine the best approach for different
    use cases (are you prototyping? Are you engineering a flexible solution for a
    commercial title?).
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we continuously polled the `isPressed` key state directly on the
    input device in the `Update()` loop to control the player movement, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since we’re receiving our input handling from `SendMessage()` now, we’ll need
    to make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: '`SendMessage()` is called anytime there is input. Input is not continuously
    polled! It behaves like an event whenever an input action occurs, which means
    that for the *Move* action, `OnMove()` will be called when a key is pressed and
    when it’s released.'
  prefs: []
  type: TYPE_NORMAL
- en: The `SendMessage()` method names that were invoked for the defined input actions.
  prefs: []
  type: TYPE_NORMAL
- en: '`SendMessage()` will also pass an `InputValue` parameter representing the `Vector2`
    in the case of *Move*, which holds the horizontal and vertical input values.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the horizontal (X-axis) value to determine if a **move left/right**
    button was pressed or released since we want to move our player while the button
    is being held down (or while holding a game controller’s stick in a certain direction).
  prefs: []
  type: TYPE_NORMAL
- en: Our `move` method (`OnMove()`) will be called with a `Vector2` X-axis value
    for a horizontal input of `-1` and `1` for left and right, respectively, when
    a button is pressed, and a value of `0` when the button is released.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all this information, we can begin to code our input handler!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PlayerController script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a new C# script named `PlayerController` in the `Assets/Scripts`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: We can now add our input handler method for the *move* action – `OnMove()` –
    and assign the `InputValue` parameter’s `Vector2` value to a private member variable
    named `_movementInput`. We’ll use this later when we calculate the movement to
    be applied to the player’s **Rigidbody2D** velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what our initial code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the input values of the input using the `Get()` method of the `value`
    parameter variable. We’re only interested in the horizontal movement here and
    will set the `_movementInput` value depending on the input state: pressed or released.'
  prefs: []
  type: TYPE_NORMAL
- en: So, if `move.x` equals `0`, then the button key was released (think of it as
    `IsPressed == false`). Then, using a ternary operator (`?:`), we’ll assign `Vector2.zero`
    to make sure that any/all input is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `move.x` is not equal to zero, we have a button key press input value
    that represents the direction (`-1`: *left*, `1`: *right*) and assign it to `_movementInput`
    with a new `Vector2` of the direction and no vertical value: `new` `Vector2(move.x,
    0f)`.'
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we can still respond to vertical input later, such as one
    for a jetpack! Now that we have a direction, we can apply force (in the form of
    velocity) to move the player character in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the following code to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this code down item by item:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_rb` variable: This private member variable will hold a reference to the
    `Rigidbody2D` component that we previously added, and we’ll be setting the velocity
    here to move the player. We once made this a `public` field that could be assigned
    in the **Inspector** window, but we’ll keep it private this time to encapsulate
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Awake()` method (expression body): Since our `Rigidbody2D` variable is
    private, we’re only using this Unity message event to get the reference to the
    `Rigidbody2D` component on this object at runtime using `GetComponent()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**GameObject.GetComponent**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FixedUpdate()` method (expression body): This Unity message event is called
    at every `UpdateVelocity()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `UpdateVelocity()` method: This method will calculate and apply the velocity
    vector to the Player’s `Rigidbody2D` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var velocity`: This holds the current value of the `Rigidbody2D` component’s
    velocity that we’ll modify and assign back.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `velocity` calculation: This adds the movement input vector multiplied
    by `fixedDeltaTime` to the velocity variable. Multiplying by `fixedDeltaTime`
    ensures frame rate independence.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `_rb.velocity` assignment: Here, we simply assign the calculated velocity
    back to the `Rigidbody2D` component, which moves the player. Remember that `FixedUpdate`
    should always be used for executing physics-related code, especially for applying
    force to a `Rigidbody` component!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Author’s note
  prefs: []
  type: TYPE_NORMAL
- en: I’ve read discussions on whether it’s necessary to apply **deltaTime** in **FixedUpdate**
    because it runs at a consistent framerate. Anyway, I err on the side of knowing
    that the **FixedUpdate** interval is always relative to the in-game time. Also,
    the Unity-provided example code always includes **deltaTime**, and being consistent
    in including it will ensure we achieve frame rate independence across all devices.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Time.fixedDeltaTime**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time and Frame Rate Management: [https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying by zero always gives zero, so `Vector2.zero` with `_movementInput`
    will assign a velocity value of zero, stopping the player’s movement.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve applied velocity to the player, but don’t get too excited. This will likely
    have no net effect on moving the player because the velocity value is too small!
    Let’s fix that by applying an acceleration multiplier to the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables and make the changes that are shown here
    to the `UpdateVelocity()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve added two new variables, `_acceleration` and `_speedMax`, which we’ve
    set to private but made available to assign in the `[SerializeField]` attribute
    to decorate a private accessor field, we’re telling Unity to serialize it and
    make it available for assignment in the `_acceleration`: This applies our overall
    velocity amount (force) for how quickly we’ll reach the maximum speed value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_speedMax`: The maximum speed of the player character’s movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `UpdateVelocity()` method, we’ve made the following changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve modified the line that adds to the velocity vector by multiplying by the
    `_acceleration` value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve ensured that `velocity.x` will be clamped to the maximum speed value by
    using the `Mathf.Clamp()` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**SerializeField**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: You can now add the `PlayerController` script to the root of the `Player` Prefab,
    add your player to a scene with some ground (don’t forget to add a collider),
    and playtest. You can move the player with the *A* and *D* keys, left and right
    arrow keys, or a game controller’s left stick. You can adjust values for acceleration,
    max speed, and the **Rigidbody2D** properties for mass and linear drag.
  prefs: []
  type: TYPE_NORMAL
- en: PlayerController.cs code
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the completed code for the **PlayerController** class, visit the following
    GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting means tweaking these movement variables repeatedly until the player
    control *feels right* to you. I’ve currently settled on values of `30` for acceleration
    and `8` for max speed. As you build out the game, you’ll find yourself going back
    and tweaking these values many, many more times – game feel is crucial to player
    satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Physics materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While playtesting, you may notice that the player may slide for a bit when you
    release the key (or controller stick). This can be corrected by freezing the player
    in place when the key is released, but I believe a better way is to change the
    properties of the ground the player is currently standing on. By adjusting the
    friction of the ground, we can provide different types of ground, including ice,
    where the player would slide when input is released.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to add a **physics material** to the ground to provide *higher default
    friction*. That way, we can have areas with less friction later to change up the
    gameplay, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a new physics material and apply it to the ground
    objects in your level:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Settings` folder, create a new folder and name it `Physics Materials`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click within the new folder, select `Default Friction`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the newly created physics material and, in the `10` (this, like all other
    gameplay variables, is subject to change with playtesting).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, assign the physics material to your ground objects by dragging it into
    the `Collider` component, as seen in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Assigning a physics material to the ground collider](img/B18347_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Assigning a physics material to the ground collider
  prefs: []
  type: TYPE_NORMAL
- en: Continue to playtest and adjust these values.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll finish up the initial player controller next by adding a run animation
    and having the player always face the direction of movement.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the character with Mecanim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Creating actor animations* section, we added an `PlayerCharacter1` object
    when we created the idle animation for the actor. The `Animator` component allows
    us to assign animation to a GameObject in the **Scene** view – it’s the interface
    responsible for controlling Unity’s **Mecanim** animation system (on the actor
    or any other GameObject you’d like to animate).
  prefs: []
  type: TYPE_NORMAL
- en: An `Animator` component. This controller asset defines what animations to use
    and when and how to transition and blend them.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Animator: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: To continue setup in the `Animator` component, we’ll need a second animation
    to transition to when our player character moves or, let’s say, runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create an additional animation for the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PlayerCharacter1` object in the **Scene** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the **Animation** window, click the **Animation Clips** list dropdown
    (the top left of the window just under the playback controls), then click **Create
    New Clip…**, as seen in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Create New Clip…](img/B18347_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Create New Clip…
  prefs: []
  type: TYPE_NORMAL
- en: Save the new clip as `Player Run` in the `Assets/Animation` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animate a run cycle. You’ve got this!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Seriously though, animation is a skill you’ll need to grow into. While I can
    create animations, I still need lots of practice in this area to get better at
    it (I’ll likely employ a skilled character animator for the final actor animations
    in the finished project files for this book, and these will be available for you
    to use and learn from as well).
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources | 2D character animation
  prefs: []
  type: TYPE_NORMAL
- en: Another option for getting a head start on character animations is to work with
    existing example characters from either the Dragon Crashers or Lost Crypt sample
    projects that Unity provides on the Asset Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dragon Crashers: [https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721](https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lost Crypt: [https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673](https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673).'
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to wiring up the transition for the *idle to* *run* animation.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning animation states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To open the `Animator` component on the `PlayerCharacter1` object or double-click
    on the `PlayerCharacter1` asset in the `Assets/Animation` folder in the **Project**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Animator** window open (you may want to dock it so that you can
    still see all the Editor windows clearly), you should see the default states (**Any
    State**, **Entry**, **Exit**) as well as states for the animation clips currently
    on the actor (**Player Idle**, **Player Run**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Actor animation transition with Mecanim](img/B18347_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Actor animation transition with Mecanim
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can navigate the **Animator** window using the mouse scroll wheel
    to zoom in/out and use the *Alt* + left-mouse button/*Option* + left-mouse button
    shortcut to pan the view. Click and drag on any State Node to reposition it in
    an orderly fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Animator** window: [https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a **Transition** from the **Player Idle** to **Player**
    **Run** states:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a Boolean parameter for whether we are running or not by executing
    the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, select the `Running` – we want a Boolean parameter to hold the state
    for if the player is running (`true`) or not running (`false`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Player Idle** node and select **Make Transition** from
    the popup menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Transition** arrow attached to the mouse pointer, click on the **Player**
    **Run** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the newly created transition line (*B* in *Figure 5**.14*) to
    view its properties in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `true`; meaning, transition to the assigned node when the `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to *step 2* and repeat the instructions to transition back to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step is to disable **Has Exit Time** (*D* in *Figure 5**.14*) for both
    transitions. We want the state to exit (the animation to stop) as soon as the
    condition is met and not wait for the animation to play completely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we haven’t wired up the animation states to the player input yet, you
    can test manually to make sure the transition is working well by entering **Play
    Mode** and, while viewing both the **Game view** and **Animator** windows, toggling
    the **Running** parameter on/off. The player should change from an *idle* to *run*
    animation and back every time you toggle the parameter. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s make this transition based on the player’s input.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the animation state with code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we’ll need is a variable to hold the reference to the `Animator`
    component (assignable in the `Running` parameter to `true`, and when the player
    stops moving the character, we will set the `Running` parameter to `false`. We’ll
    make quick work of this and accomplish it with only one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `PlayerController` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `_animator` variable declaration is our reference to the `Animator` component
    in the `Player` object. We marked it as `private` so that no other class can modify
    it but decorated it with the `[SerializeField]` attribute so that it’s serialized
    and assignable in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: In the `UpdateVelocity()` method, we added a call to `_animator.SetBool()` and
    passed in the `Running` string to identify the bool parameter we’d like to set.
    We’ll pass in the evaluation result of the `_movementInput.x != 0f` expression
    for the bool value.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that if our player is receiving movement input (value is
    not zero), then we are moving (`Running` equals `true`); otherwise, (that is,
    `if _movementInput.x == 0f`), we are standing still (`Running` equals `false`).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added and saved this code, drag the child `PlayerCharacter1` object
    to the `PlayerController` component’s **Animator** field using the **Hierarchy**
    and **Inspector** windows in the **Editor** view.
  prefs: []
  type: TYPE_NORMAL
- en: Enter **Play Mode** and move the player left and right to test that the animation
    is transitioning from idle to run and back. You’ll likely notice that even though
    the animation is transitioning, the actor is facing the wrong direction while
    moving to the left!
  prefs: []
  type: TYPE_NORMAL
- en: We’ll address this next to finish up the player movement.
  prefs: []
  type: TYPE_NORMAL
- en: Flipping the player character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the `PlayerController` script to ensure the player is always facing the
    direction of movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PlayerController` script and, at the end of the `OnMove()` method,
    add a call to a new method named `UpdateDirection`. Create the `UpdateDirection()`
    method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The simple trick we’re employing to flip the direction the player character
    is facing is to set the `localScale X` value to `-1` for the player object’s **Transform**
    if the movement input value is less than zero (that is, input indicating moving
    to the left).
  prefs: []
  type: TYPE_NORMAL
- en: The first `if` statement in `UpdateDirection()` checks if we have any input
    for moving the player. Remember, a value of zero means that the player released
    the direction key (or game controller stick).
  prefs: []
  type: TYPE_NORMAL
- en: If the movement’s input horizontal value is not zero, we first set a default
    scale for facing right (an `X` value of `1`). If it turns out that the movement
    input is for facing left (an `X` value of `-1`), then we set `localScale` to `Vector3`
    with an X-axis value of `-``1`. Easy-peasy.
  prefs: []
  type: TYPE_NORMAL
- en: Bonus activity
  prefs: []
  type: TYPE_NORMAL
- en: Based on the techniques learned in this chapter for processing player input,
    moving the player via its **Rigidbody2D** component and animating the player using
    the **Animator** all within the **PlayerController** script, add the ability for
    the player character to jump. Might as well jump, go ahead and jump!
  prefs: []
  type: TYPE_NORMAL
- en: 'I didn’t necessarily leave you hanging here. If you’re looking for a lifeline
    to solve this problem, you can view instructions for completing this jumping bonus
    activity by visiting the following GitHub link: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to create animations and apply them to the
    player, as well as how to transition and change the animation state with code,
    all while using Mecanim. We finished off by learning how to flip the facing direction
    of the player character.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter walked us through the complete setup of an animated 2D player character,
    including importing art and setting up an animatable rig via PSD Importer, setting
    up IK Solvers, and creating and applying animations to the player using Mecanim.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by adding movement ability from player input by using an Input
    Action Map asset with the new Input System, coding a simple player controller
    script, processing input, and changing animations based on the current player
    action, also using Mecanim.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll add a weapon for the player so that they can shoot
    projectiles efficiently.
  prefs: []
  type: TYPE_NORMAL
