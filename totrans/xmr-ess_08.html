<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Sharing with Xamarin.Forms</h1></div></div></div><p>In this chapter, we will discuss Xamarin.Forms, a cross-platform development framework. With this in mind, we will cover the following areas:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pages, Views (Controls), and Layouts</li><li class="listitem" style="list-style-type: disc">Navigation in Xamarin.Forms</li><li class="listitem" style="list-style-type: disc">XAML and code-behind classes</li><li class="listitem" style="list-style-type: disc">Data binding</li><li class="listitem" style="list-style-type: disc">Renderers</li><li class="listitem" style="list-style-type: disc">The <code class="literal">DependencyService</code> API</li><li class="listitem" style="list-style-type: disc">App startup</li><li class="listitem" style="list-style-type: disc">Project organization</li><li class="listitem" style="list-style-type: disc">Converting the <code class="literal">NationalParks</code> app to use Xamarin.Forms</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec58"/>An insight into the Xamarin.Forms framework</h1></div></div></div><p>The <a class="indexterm" id="id616"/>Xamarin.Forms framework can be used to develop mobile apps for Android, iOS, and Windows Phone. It uses virtually the same source code base for each platform while still providing a platform-specific look and feel. Xamarin.Forms is available for use from any of the paid licenses available at Xamarin or from the 30-day evaluation.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>While we mention that Xamarin.Forms apps can run on Windows Phone, the licensing, configuration, and development details for Windows Phone are beyond the scope of this book.</p></div></div><p>Unlike the approaches described previously in this book, Xamarin.Forms provides you with a set of abstractions that cover the entire user interface, thus allowing the UI code and specification to be reused across multiple platforms. At runtime, Xamarin.Forms renders user interfaces using Controls that are native to each platform, which allows apps to retain a native look and feel.</p><p>This chapter is divided into two main sections: in the first section, we cover the core concepts that need to be understood prior to using Xamarin.Forms, and in the second section, we will <a class="indexterm" id="id617"/>convert our <code class="literal">NationalParks</code> app to use the Xamarin.Forms framework.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec77"/>Pages</h2></div></div></div><p>A <strong>Page</strong> is a visual <a class="indexterm" id="id618"/>element that organizes the content a user sees on the screen at a single time. A Xamarin.Forms Page is essentially similar to an Android activity or an iOS <a class="indexterm" id="id619"/>View controller. Xamarin.Forms provides the following base Pages for use in your apps, where you can find a description accompanied with each type:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ContentPage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id620"/>allows you to organize a set of Controls, or <a class="indexterm" id="id621"/>Views, into a Layout for display and interaction with the user</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MasterDetailPage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id622"/>manages two pages—a master and a <a class="indexterm" id="id623"/>detail page—and the navigation between them</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">NavigationPage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This manages <a class="indexterm" id="id624"/>navigation over a set of other <a class="indexterm" id="id625"/>pages</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TabbedPage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id626"/>manages a set of child pages and allows <a class="indexterm" id="id627"/>you to navigate via tabs</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CarouselPage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id628"/>manages a set of child pages and allows <a class="indexterm" id="id629"/>you to navigate via swipe</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec78"/>Views</h2></div></div></div><p>A <strong>View</strong> is a visual <a class="indexterm" id="id630"/>control (or widget) that presents information and allows the user to interact with your app (things such as buttons, labels, and edit boxes). These controls <a class="indexterm" id="id631"/>generally inherit properties from the <code class="literal">View</code> class. The following table represents the list of Views provided by Xamarin.Forms at the time of writing this book:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ActivityIndicator</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BoxView</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Button</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">DatePicker</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Editor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Entry</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Image</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Label</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ListView</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">OpenGLView</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Picker</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ProgressBar</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SearchBar</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Slider</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Stepper</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Switch</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TableView</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">TimePicker</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">WebView</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec79"/>Layouts</h2></div></div></div><p>Controls are <a class="indexterm" id="id632"/>hosted within a special type of View called a <strong>Layout</strong>. There are two different types of Layouts: managed and unmanaged. Managed Layouts are responsible for <a class="indexterm" id="id633"/>arranging their hosted Controls, and unmanaged Layouts require the developer to specify how controls should be arranged. Xamarin.Forms provides the following Layouts:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Layout</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ContentView</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a class="indexterm" id="id634"/>Layout that can contain <a class="indexterm" id="id635"/>child views. Generally, <code class="literal">ContentView</code> is not used directly, but is used as a base for other layouts.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Frame</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a class="indexterm" id="id636"/>Layout that can contain a single child view and provide <a class="indexterm" id="id637"/>framing options such as padding.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ScrollView</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id638"/>Layout is capable of scrolling its child <a class="indexterm" id="id639"/>views.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AbsoluteLayout</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id640"/>Layout allows it's child views to be positioned <a class="indexterm" id="id641"/>by absolute positions as requested by the app.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Grid</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id642"/>Layout allows content to be displayed in rows <a class="indexterm" id="id643"/>and columns.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">RelativeLayout</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id644"/>Layout positions views relative to other views it <a class="indexterm" id="id645"/>owns by use of constraints.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">StackLayout</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id646"/>Layout positions views horizontally or vertically <a class="indexterm" id="id647"/>in a single line.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec80"/>Cells</h2></div></div></div><p>A <strong>Cell</strong> is a special <a class="indexterm" id="id648"/>type of Control used to arrange information in a list; specifically, <code class="literal">ListView</code> or <code class="literal">TableView</code>. Cells derive from the <code class="literal">Element</code> class rather than the <code class="literal">VisualElement</code> <a class="indexterm" id="id649"/>class and act as a template to create <code class="literal">VisualElements</code>.</p><p>Xamarin.Forms provides the following types of Cells:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Cell type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EntryCell</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a class="indexterm" id="id650"/>Cell with a label and single text entry <a class="indexterm" id="id651"/>field.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SwitchCell</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a class="indexterm" id="id652"/>Cell with a label and switch view (on/off).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TextCell</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a Cell <a class="indexterm" id="id653"/>with primary and secondary text. Generally, the primary text is used as a title and the secondary text as a subtitle.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ImageCell</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a class="indexterm" id="id654"/><code class="literal">TextCell</code> that also <a class="indexterm" id="id655"/>includes an image.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec81"/>Navigation</h2></div></div></div><p>
<strong>Navigation</strong> in a <a class="indexterm" id="id656"/>Xamarin.Forms app is accomplished with the use of the navigation property of <code class="literal">VisualElement</code>. This is generally accessed via a Page. The navigation <a class="indexterm" id="id657"/>property is typed as the <code class="literal">INavigation</code> interface, which provides the following methods:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PushAsync()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id658"/>method pushes a Page on the navigation <a class="indexterm" id="id659"/>stack</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PushModalAsync()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id660"/>method pushes a Page on the navigation <a class="indexterm" id="id661"/>stack as a modal dialog</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PopAsync()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id662"/>method pops the current Page off the <a class="indexterm" id="id663"/>navigation stack</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PopModalAsync()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id664"/>method pops the current modal Page <a class="indexterm" id="id665"/>off the navigation stack</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PopToRootAsync()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id666"/>method pops all the Pages off the <a class="indexterm" id="id667"/>navigation stack, except the root Page</p>
</td></tr></tbody></table></div><p>The beauty of navigation in Xamarin.Forms lies in its simplicity. To navigate to a new Page and pass data into the new Page, all you need to do is create an instance of the new Page passing the data in the constructor and then push this Page on the navigation stack, as demonstrated by the following sample code snippet:</p><div><pre class="programlisting">public partial class ParkDetailPage : ContentPage
{
    . . .
    public void EditClicked(object sender, EventArgs e)
    {
        Navigation.PushModalAsync (
            new ParkEditPage (_park));
    }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec82"/>Defining Xamarin.Forms user interfaces</h2></div></div></div><p>Like many <a class="indexterm" id="id668"/>UI frameworks, Xamarin.Forms allows two different approaches to create user interfaces: declarative and programmatic:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Programmatic approach</strong>: When using this approach, the developers embed API calls <a class="indexterm" id="id669"/>to construct a UI, and control the size and placement</li><li class="listitem" style="list-style-type: disc"><strong>Declarative approach</strong>: When using this approach, the developers create XAML <a class="indexterm" id="id670"/>files that define the content and layout for a user interface</li></ul></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec58"/>Extensible Application Markup Language (XAML)</h3></div></div></div><p>
<strong>Extensible Application Markup Language</strong> (<strong>XAML</strong>) is an XML-based language developed by Microsoft. XAML <a class="indexterm" id="id671"/>allows developers to use XML to specify a hierarchy of objects to instantiate. It can be used in a number of ways, but most successfully <a class="indexterm" id="id672"/>as a means to specify user's interfaces in <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>), Silverlight, Windows Runtime, and now Xamarin.Forms.</p><p>XAML files are parsed at build time to verify objects that have been specified and at runtime to instantiate the hierarchy of objects.</p><p>In addition to specifying a hierarchy of objects, XAML also allows developers to specify property values and assign event handlers. However, it does not allow you to embed code or logic.</p><p>The following XAML file defines the content for a <code class="literal">ContentPage</code> view:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;ContentPage xmlns="http://xamarin.com/schemas/...
    xmlns:x="http://schemas.microsoft.com/winfx...
    x:Class="NationalParks.ParkEditPage"&gt;
  &lt;StackLayout Orientation="Vertical"
    HorizontalOptions="StartAndExpand"&gt;
    &lt;Grid&gt;
      &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition Width="*" /&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Label
          Text="Name:"
          Grid.Row="0" Grid.Column="0" /&gt;
  &lt;Entry
          x:Name="descriptionEntry"
          Text="{Binding Name}"
          Grid.Row="0" Grid.Column="1"
          HorizontalOptions="FillAndExpand" /&gt;
  . . .
   &lt;/Grid&gt;
   &lt;Button
       x:Name="doneButton" 
       Text="Done"
       Clicked="DoneClicked" /&gt;
  &lt;/StackLayout&gt;
&lt;/ContentPage&gt;</pre></div><p>Take a look <a class="indexterm" id="id673"/>at the previous XAML specification:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The class name is <code class="literal">ParkEditPage</code> and is specified in the <code class="literal">ContentPage</code> element</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Grid</code> Layout is used to organize the content in the Page</li><li class="listitem" style="list-style-type: disc">Two components are assigned property names, <code class="literal">nameEntry</code> and <code class="literal">doneButton</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">doneButton</code> component is assigned a <code class="literal">Clicked</code> event handler named <code class="literal">DoneClicked</code></li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec59"/>Code-behind classes</h3></div></div></div><p>When you <a class="indexterm" id="id674"/>create a Page in a Xamarin.Forms app, two files are actually created: an XAML file and a class file. Xamarin <a class="indexterm" id="id675"/>Studio nests the class files under the XAML files in the <strong>Solution</strong> pad, as shown in the following screenshot:</p><div><img alt="Code-behind classes" src="img/0838OT_08_01.jpg"/></div><p>The <code class="literal">.xaml.cs</code> files are sometimes referred to as code-behind classes. They are created to contain all the app logic in event handlers that go hand in hand with the Page definition. The following example shows the code-behind class for <code class="literal">ParkEditPage</code>:</p><div><pre class="programlisting">public partial class ParkEditPage : ContentPage
{
  NationalPark _park;
  public ParkEditPage()
  {
    InitializeComponent ();
  }
  protected void DoneClicked(object sender, EventArgs e)
  {
    // perform event handler logic
  }
}</pre></div><p>You should take note of the following aspects of the class definition:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ParkEditPage</code> is a partial class definition.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">DoneClicked()</code> event handler is defined within this class file. This is the event handler that was assigned to the <code class="literal">Done</code> button in XAML.</li><li class="listitem" style="list-style-type: disc">There are no property definitions defined in the earlier file.</li></ul></div><p>So, where are the <a class="indexterm" id="id676"/>property definitions? Xamarin Studio generates a second code file each time the app is built. For our example, the <a class="indexterm" id="id677"/>file will be named <code class="literal">ParkEditPage.xaml.g.cs</code> and will contain the following code snippet:</p><div><pre class="programlisting">public partial class ParkEditPage : ContentPage {
    private Entry nameEntry;    
    . . .    
    private Button doneButton;  
    private void InitializeComponent() {
        this.LoadFromXaml(typeof(ParkEditPage));
        nameEntry =
          this.FindByName &lt;Entry&gt;("nameEntry");
        . . .
        doneButton =
          this.FindByName &lt;Button&gt;("doneButton");
    }
}</pre></div><p>You should take note of the following points here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are two properties defined on the <code class="literal">ParkEditPage</code> file: <code class="literal">nameEntry</code> and <code class="literal">doneButton</code>. These are generated directly from the names found in the XAML file.</li><li class="listitem" style="list-style-type: disc">A method named <code class="literal">InitializeComponent()</code> is generated. This method must be called from any constructors defined in <code class="literal">ParkEditPage.xaml.cs</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">InitializeComponent()</code> method calls <code class="literal">LoadFromXaml()</code> to instantiate all the objects defined by <code class="literal">ParkEditPage.xaml</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">InitializeComponent()</code> method calls <code class="literal">FindByName()</code> to bind each property to <a class="indexterm" id="id678"/>its corresponding <a class="indexterm" id="id679"/>instance.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec83"/>Data binding</h2></div></div></div><p>The concepts <a class="indexterm" id="id680"/>behind data binding are covered in detail in <a class="link" href="ch07.html" title="Chapter 7. Sharing with MvvmCross">Chapter 7</a>, <em>Sharing with MvvmCross</em>, under the section titled <em>Data binding</em>. Xamarin.Forms <a class="indexterm" id="id681"/>provides a data binding capability that follows the same architecture as MvvmCross, <strong>Windows </strong><a class="indexterm" id="id682"/><strong>Presentation Foundation</strong> (<strong>WPF</strong>), Silverlight, and Windows Runtime.</p><p>Within a <a class="indexterm" id="id683"/>Xamarin.Forms app, binding specifications are generally specified in XAML. The following XAML specification demonstrates binding the <code class="literal">Text</code> property of an <code class="literal">Entry</code> control to the <code class="literal">Name</code> property of a <code class="literal">NationalPark</code> object:</p><div><pre class="programlisting">    &lt;Entry x:Name="nameEntry"
        Text="{Binding Name}"
        Grid.Row="0" Grid.Column="1"
        HorizontalOptions="FillAndExpand" /&gt;</pre></div><p>Generally, the binding context is set with code. The following example demonstrates how to programmatically set the binding context at a Page level to a <code class="literal">NationalPark</code> object:</p><div><pre class="programlisting">public ParkEditPage (NationalPark park)
{
    InitializeComponent ();
    _park = park;
    BindingContext = _park;
}</pre></div><p>In the previous example, the binding context was set for an entire Page. Sometimes, Controls provide a binding context that needs to be set to accomplish data binding. The following example <a class="indexterm" id="id684"/>demonstrates setting the binding context for a <code class="literal">ListView</code> <a class="indexterm" id="id685"/>control:</p><div><pre class="programlisting">parksListView.ItemsSource =
  NationalParksData.Instance.Parks;</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Note that the binding context for the <code class="literal">ListView</code> control is a property named <code class="literal">ItemsSource</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec84"/>Using Renderers</h2></div></div></div><p>Xamarin.Forms <a class="indexterm" id="id686"/>uses platform-native controls to render user interfaces that allow apps to maintain a look and feel that the users would expect for each platform. This is accomplished with the use of Renderers. Pages, Layouts, and Controls <a class="indexterm" id="id687"/>represent the set of abstractions used to describe a user interface. Each of these elements is rendered using a <code class="literal">Renderer</code> class, which in turn creates a native control based on the platform the app is running on.</p><p>Developers can create their own Renderers in order to customize the way a particular Control is rendered on a platform.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Native features and the DependencyService API</h2></div></div></div><p>Until now, we <a class="indexterm" id="id688"/>have primarily focused on working with abstractions that can be reused across all platforms. What if you need access to <a class="indexterm" id="id689"/>platform-specific capabilities? That's <a class="indexterm" id="id690"/>where the <code class="literal">DependencyService</code> API comes in. The <code class="literal">DependencyService</code> API is an API that allows each platform to register a platform-specific service that can be called by shared code through a common interface.</p><p>Using the <code class="literal">DependencyService</code> API involves the following three steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, you need to create an interface that exposes the platform-specific methods that must be implemented for each platform the app will run on.</li><li class="listitem">After this step, create an implementation of the interface for each platform and register the implementation using an <code class="literal">assembly</code> attribute.</li><li class="listitem">To conclude, call <code class="literal">DependencyService.Get&lt;MyInterface&gt;</code> from the shared code to look up the appropriate implementation and invoke services on the returned instance.</li></ol></div><p>We will <a class="indexterm" id="id691"/>demonstrate the use of the <code class="literal">DependencyService</code> API <a class="indexterm" id="id692"/>later in this chapter in the section titled <em>Adding calls to DependencyService</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec86"/>App startup</h2></div></div></div><p>Xamarin.Forms <a class="indexterm" id="id693"/>apps start up as native apps, meaning the traditional startup sequence is followed. During the startup sequence, an app performs <a class="indexterm" id="id694"/>the following two tasks:</p><div><ol class="orderedlist arabic"><li class="listitem">Make a call to initialize the Xamarin.Forms runtime.</li><li class="listitem">Start the first Page.</li></ol></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec60"/>Shared App classes</h3></div></div></div><p>By <a class="indexterm" id="id695"/>default, Xamarin.Forms apps have a shared <code class="literal">App</code> class created, which contains a single static method that returns the first Page that should be presented when an app starts up. The following code demonstrates this:</p><div><pre class="programlisting">public class App
{
    public static Page GetMainPage()
    {
        return new HelloWorldPage();
    }
}</pre></div><p>This simple approach <a class="indexterm" id="id696"/>allows the platform-specific startup code in each app to call the <code class="literal">GetMainPage()</code> method in order to determine which Page to start with. Therefore, it is only specified at one place.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec61"/>iOS apps</h3></div></div></div><p>In a <a class="indexterm" id="id697"/>Xamarin.Forms iOS app, initialization is performed in the <code class="literal">FinishedLaunching()</code> method of the <code class="literal">AppDelegate</code> class, as shown in the <a class="indexterm" id="id698"/>following sample demonstration:</p><div><pre class="programlisting">[Register("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate
{
  UIWindow window;
  public override bool FinishedLaunching(UIApplication app, NSDictionary options)
  {
    Forms.Init();
    window = new UIWindow(UIScreen.MainScreen.Bounds);
    window.RootViewController =
        App.GetMainPage().CreateViewController();
    window.MakeKeyAndVisible();
    return true;
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec62"/>Android apps</h3></div></div></div><p>In a <a class="indexterm" id="id699"/>Xamarin.Forms Android <a class="indexterm" id="id700"/>app, initialization is done in the <code class="literal">Activity</code> instance marked with the <code class="literal">MainLauncher=true</code> attribute. This is shown in the following sample <a class="indexterm" id="id701"/>code snippet:</p><div><pre class="programlisting">namespace HelloWorld.Android
{
    [Activity(Label="HelloWorld", MainLauncher=true)]
    public class MainActivity : AndroidActivity
    {
        protected override void OnCreate(Bundle bundle)
        {
            base.OnCreate(bundle);
            Xamarin.Forms.Forms.Init(this, bundle);
            SetPage(App.GetMainPage());
        }
    }
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec87"/>Project organization</h2></div></div></div><p>Xamarin.Forms <a class="indexterm" id="id702"/>projects are generally <a class="indexterm" id="id703"/>created using one of the following two project templates, which can be found by navigating to <strong>C#</strong> | <strong>Mobile Apps</strong> of the <strong>New Solution</strong> dialog box:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Blank App (Xamarin.Forms Potable)</strong></li><li class="listitem" style="list-style-type: disc"><strong>Blank App (Xamarin.Forms Shared)</strong></li></ul></div><p>The difference between these two templates is the type of project created to house the shared code. Using the first template, shared code is housed in a Portable Class Library, and using the second template, shared code is housed in a shared project. Shared projects allow all referencing projects to reuse the code it contains, but the code is compiled specifically for each referencing project.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>If you plan to add a Windows Phone project to the solution at some point, you will be well versed to go with the PCL solution. It will require you to work within the restrictions of a PCL, but will ensure your code is compatible with more platforms.</p></div></div><p>After creating a Xamarin.Forms solution, you will see that three actual projects were created. The first project contains the shared code, the second project contains the iOS code, and the third project contains the Android code. If we are successful with Xamarin.Forms, the bulk of the code will end up in the shared project. The following screenshot <a class="indexterm" id="id704"/>shows an example of a project <a class="indexterm" id="id705"/>created with the PCL template:</p><div><img alt="Project organization" src="img/0838OT_08_02.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Creating the NationalParks Xamarin.Forms app</h1></div></div></div><p>Now that we <a class="indexterm" id="id706"/>have a solid understanding of Xamarin.Forms, let's convert our <code class="literal">NationalParks</code> app to use the new framework. For this exercise, we will follow the same app flow that we have used in the iOS app so far, meaning that we will have a list page, a detail page to view, and an edit page to add and update.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec88"/>Creating the solution</h2></div></div></div><p>We will start by <a class="indexterm" id="id707"/>creating an entirely new project by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To <a class="indexterm" id="id708"/>start with, access the <strong>File</strong> menu and navigate to <strong>New</strong> | <strong>New Solution</strong>.</li><li class="listitem">In the <strong>New Solution</strong> dialog box, navigate to <strong>C#</strong> | <strong>Mobile Apps</strong>, select the <strong>Blank App (Xamarin.Forms Portable)</strong> template, enter <code class="literal">NationalParks</code> in the <strong>Name</strong> field, choose the appropriate <strong>Location</strong> value, and click on <strong>OK</strong>.</li><li class="listitem">Review the project structure. You will see the following pointers:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Open <code class="literal">AppDelegate.cs</code> in the <code class="literal">NationalParks.iOS</code> project. Note the calls to <code class="literal">Forms.Init()</code> and <code class="literal">App.GetMainPage()</code>.</li><li class="listitem" style="list-style-type: disc">Open <code class="literal">MainActivity.cs</code> in the <code class="literal">NationalParks.Android</code> project. Note the calls to <code class="literal">Forms.Init()</code> and <code class="literal">App.GetMainPage()</code>.</li><li class="listitem" style="list-style-type: disc">Open <code class="literal">App.cs</code> in the <code class="literal">NationalParks</code> project. Note the static method, <code class="literal">GetMainPage()</code>.</li></ul></div></li><li class="listitem">To <a class="indexterm" id="id709"/>finish, run the <a class="indexterm" id="id710"/><code class="literal">NationalParks.Android</code> and <code class="literal">NationalParks.iOS</code> projects.</li></ol></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec63"/>Adding NationalParks.PortableData</h3></div></div></div><p>Our <a class="indexterm" id="id711"/>next step is to bring in the storage solution from <a class="link" href="ch07.html" title="Chapter 7. Sharing with MvvmCross">Chapter 7</a>, <em>Sharing with MvvmCross</em>. Perform the <a class="indexterm" id="id712"/>following steps to add the storage solution to our new Xamarin.Forms solutions:</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, you need to copy the <code class="literal">NationalParks.PortableData</code> and <code class="literal">NationalParks.IO</code> projects from the solution folder of <a class="link" href="ch07.html" title="Chapter 7. Sharing with MvvmCross">Chapter 7</a>, <em>Sharing with MvvmCross</em>, to the new solution folder.</li><li class="listitem">Add each project to the new solution folder by selecting the solution, right-clicking on it, navigating to <strong>Add</strong> | <strong>Add Existing Project</strong>, and selecting the project file, for example, <code class="literal">NationalParks.IO.csproj</code>.</li><li class="listitem">Add the <code class="literal">NationalParks.PortableData</code> project to the new <code class="literal">NationalParks</code>, <code class="literal">NationalParks.Android</code>, and <code class="literal">NationalParks.iOS</code> projects as a reference by selecting the <code class="literal">References</code> folder in each of the projects, right-clicking on them, choosing <strong>Edit References</strong>, and selecting <code class="literal">NationalParks.PortableData</code>.</li><li class="listitem">We now need to add a link to the <code class="literal">FileHandler.cs</code> file to both the <code class="literal">NationalParks.Android</code> and <code class="literal">NationalParks.iOS</code> projects. For each project, create a new folder named <code class="literal">NationalParks.IO</code> and add a link to <code class="literal">FileHandler.cs</code> by selecting the new folder, right-clicking on it, navigating to <strong>Add</strong> | <strong>Add Files</strong>, selecting <code class="literal">FileHandler</code>, choosing <strong>Open</strong>, selecting <strong>Add a link to the file</strong>, and clicking on <strong>OK</strong>.</li><li class="listitem">To verify all of the previous steps, you should compile the new solution.</li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec89"/>Implementing ParksListPage</h2></div></div></div><p>We can <a class="indexterm" id="id713"/>now begin work on the user interface starting with a list view to display the parks by performing the <a class="indexterm" id="id714"/>following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the <code class="literal">NationalParks</code> project, right-click on it, and navigate to <strong>Add</strong> | <strong>New File</strong>. From the <strong>New File</strong> dialog box, navigate to <strong>Forms</strong> | <strong>Forms ContentPage Xaml</strong>, enter <code class="literal">ParksListPage</code> for the <strong>Name</strong> field, and choose <strong>New</strong>.</li><li class="listitem">You should now open <code class="literal">ParkListPage.xaml</code>. You will see an empty <code class="literal">ContentPage</code> element. Add <code class="literal">StackLayout</code>, which is vertically oriented, with a child <code class="literal">ListView</code> and <code class="literal">Button</code> instances, as follows:<div><pre class="programlisting">&lt;StackLayout Orientation="Vertical"
    HorizontalOptions="StartAndExpand"&gt;
    &lt;ListView x:Name="parksListView"
        IsVisible="true"
        ItemSelected="ParkSelected"&gt;
    &lt;/ListView&gt;
    &lt;Button Text="New"
  Clicked="NewClicked" /&gt;
&lt;/StackLayout&gt;</pre></div><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>Take note of the <code class="literal">ParkSelected</code> event handler for <code class="literal">parkListView</code> and the <code class="literal">NewClicked</code> event handler for the <code class="literal">New</code> button.</p></div></div></li><li class="listitem">Now, let's add the row definitions for <code class="literal">ListView</code>. The <code class="literal">ListView</code> element has a <code class="literal">DataTemplate</code> property that defines a layout for each row. The following Layout should define a label for the name and description of the park. This should be placed within the <code class="literal">ListView</code> element of the XAML:<div><pre class="programlisting">&lt;ListView.ItemTemplate&gt;
  &lt;DataTemplate&gt;
    &lt;ViewCell&gt;
       &lt;ViewCell.View&gt;
     &lt;StackLayout Orientation="Vertical"
           HorizontalOptions="StartAndExpand"&gt;
           &lt;Label Text="{Binding Name}"
             HorizontalOptions="FillAndExpand" /&gt;
         &lt;/StackLayout&gt;
      &lt;/ViewCell.View&gt;
    &lt;/ViewCell&gt;
  &lt;/DataTemplate&gt;
&lt;/ListView.ItemTemplate&gt;</pre></div><p>Note the binding specifications for the two Label views.</p></li><li class="listitem">Open <code class="literal">App.cs</code> in the <code class="literal">NationalParks</code> project and change the main page to <code class="literal">ParksListPage</code>. We also need to create <code class="literal">NavigationPage</code> as the owner of <code class="literal">ParksListPage</code> to support push and pop navigation. The <code class="literal">GetMainPage()</code> method should contain the following code:<div><pre class="programlisting">public static Page GetMainPage ()
{
    NavigationPage mainPage =
        new NavigationPage(new ParksListPage());
    return mainPage;
}</pre></div></li><li class="listitem">Open <code class="literal">AppDelegate.cs</code> in the <code class="literal">NationalParks.iOS</code> project. You should then add the following initialization of code to the <code class="literal">FinishedLaunching()</code> method just before the <code class="literal">Forms.Init()</code> call:<div><pre class="programlisting">// Initialize data service
NationalParksData.Instance.DataDir =
    Environment.CurrentDirectory;
NationalParksData.Instance.FileHandler =
    new FileHandler ();</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.cs</code> in the <code class="literal">NationalParks.Android</code> project. Once you're <a class="indexterm" id="id715"/>in, add the following initialization code to the <code class="literal">OnCreate()</code> method just before the call to <code class="literal">Forms.Init()</code>:<div><pre class="programlisting">// Initialize data service
NationalParksData.Instance.DataDir =
    System.Environment.GetFolderPath(
        System.Environment.SpecialFolder.MyDocuments);
NationalParksData.Instance.FileHandler =
    new FileHandler ();</pre></div></li><li class="listitem">Open <a class="indexterm" id="id716"/><code class="literal">ParksListPage.xaml.cs</code>, add a method to load the parks data, and set the binding context:<div><pre class="programlisting">public async Task LoadData()
{
  await NationalParksData.Instance.Load();
  parksListView.ItemsSource =
      NationalParksData.Instance.Parks;
}</pre></div></li><li class="listitem">Add a call to <code class="literal">LoadData()</code> from the constructor:<div><pre class="programlisting">  InitializeComponent ();
  LoadData ();</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>You will not be able to use <code class="literal">await</code> on the <code class="literal">LoadData()</code> method because it's being called from a constructor. In this case, there is actually no need to await the call.</p></div></div></li><li class="listitem">The last step is <a class="indexterm" id="id717"/>to create two stub event handlers for <code class="literal">NewClicked</code> and <code class="literal">ParkSelected</code>, which we will fill in later as we complete the app.</li><li class="listitem">We are <a class="indexterm" id="id718"/>now ready to test our work. Compile and run both the <code class="literal">NationalParks.iOS</code> and <code class="literal">NationalParks.Android</code> apps.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec90"/>Implementing ParkDetailPage</h2></div></div></div><p>Now, we <a class="indexterm" id="id719"/>need a page to <a class="indexterm" id="id720"/>display the details of a Park. To create <code class="literal">ParkDetailPage</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new <code class="literal">ContentPage</code> instance named <code class="literal">ParkDetailPage</code>.</li><li class="listitem">For <code class="literal">ParkDetailPage</code>, we will display a series of <code class="literal">Label</code> views in <code class="literal">Grid</code> and a set of <code class="literal">Buttons</code> below <code class="literal">Grid</code> to initiate actions. All this content will be hosted within <code class="literal">StackLayout</code>, which is vertically oriented. Start by adding <code class="literal">StackLayout</code> like we did in the previous section.</li><li class="listitem">Add a <code class="literal">Grid</code> layout with a series of the <code class="literal">Label</code> view to display the properties of <code class="literal">NationalPark</code>, as follows:<div><pre class="programlisting">&lt;Grid&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition Width="*" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Label Text="Name:"
        Grid.Row="0" Grid.Column="0" /&gt;
    &lt;Label Text="{Binding Name}"
        Grid.Row="0" Grid.Column="1"
        HorizontalOptions="FillAndExpand" /&gt;
    . . .
&lt;/Grid&gt;</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Note the <code class="literal">Grid.Row</code> and <code class="literal">Grid.Column</code> specifications, which control how the <code class="literal">Label</code> and <code class="literal">Entry</code> views are positioned.</p></div></div></li><li class="listitem">Now, add three <code class="literal">Button</code> definitions for the actions that can be taken from the Page, as follows:<div><pre class="programlisting">&lt;Button Text="Edit"
              WidthRequest="175"
              HorizontalOptions="Center"
              Clicked="EditClicked" /&gt;
&lt;Button Text="Directions"
              WidthRequest="175"
              HorizontalOptions="Center"
              Clicked="DirectionsClicked" /&gt;
&lt;Button Text="Photos"
              WidthRequest="175"
              HorizontalOptions="Center"
              Clicked="PhotosClicked" /&gt;</pre></div></li><li class="listitem">Add a <a class="indexterm" id="id721"/>constructor that accepts a <code class="literal">NationalPark</code> instance to be displayed. The following code sample demonstrates what is needed:<div><pre class="programlisting">NationalPark _park;
public ParkDetailPage (NationalPark park)
{
InitializeComponent ();
  _park = park;
  BindingContext = _park;
}</pre></div><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Note that the last line in the constructor sets <code class="literal">BindingContext</code>. This tells the Page how to resolve the binding specifications declared in XAML.</p></div></div></li><li class="listitem">Add stub <a class="indexterm" id="id722"/>event handlers for <code class="literal">EditClicked</code>, <code class="literal">DirectionsClicked</code>, and <code class="literal">PhotosClicked</code>.</li><li class="listitem">Now, we need to return to the <code class="literal">ParksListPage</code> class and add the navigation logic. Open <code class="literal">ParksListPage.xaml.cs</code> and update the <code class="literal">ParkSelected()</code> event handler to make a call to <code class="literal">PushAsync()</code> for <code class="literal">ParkDetailPage</code>, as follows:<div><pre class="programlisting">protected void ParkSelected(object sender,
SelectedItemChangedEventArgs e)
{
    Navigation.PushAsync (new
        ParkDetailPage ((NationalPark) e.SelectedItem));
}</pre></div></li><li class="listitem">Compile <a class="indexterm" id="id723"/>and <a class="indexterm" id="id724"/>run both the <code class="literal">NationalParks.iOS</code> and <code class="literal">NationalParks.Android</code> apps.</li></ol></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec64"/>Using DependencyService to show directions and photos</h3></div></div></div><p>As we <a class="indexterm" id="id725"/>discussed earlier, the <code class="literal">DependencyService</code> API allows apps to take advantage of platform-specific features. We <a class="indexterm" id="id726"/>will demonstrate the use of <code class="literal">DependencyService</code> to implement the ability to show directions and photos for a park.</p><div><div><div><div><h4 class="title"><a id="ch08lvl4sec26"/>Creating the interface</h4></div></div></div><p>The first <a class="indexterm" id="id727"/>step is to create an interface in the shared <a class="indexterm" id="id728"/>project that describes the methods that need to be supported. To create the <code class="literal">IParkInfoServices</code> interface, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To begin with, select the <code class="literal">NationalParks</code> project, right-click on it, and navigate to <strong>Add</strong> | <strong>New File</strong>.</li><li class="listitem">Navigate to <strong>General</strong> | <strong>Empty Interface</strong>, enter <code class="literal">IParkInfoServices</code> in the <strong>Name</strong> field, and choose <strong>New</strong>.</li><li class="listitem">You now need to create two methods on the interface, one to show directions and one to show photos; each should accept <code class="literal">NationalPark</code> as a parameter:<div><pre class="programlisting">public interface IParkInfoServices
{
    void ShowDirections(NationalPark park);
    void ShowPhotos(NationalPark park);
}</pre></div></li></ol></div></div><div><div><div><div><h4 class="title"><a id="ch08lvl4sec27"/>Creating the iOS implementation</h4></div></div></div><p>Now, let's <a class="indexterm" id="id729"/>create an iOS implementation <a class="indexterm" id="id730"/>by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the <code class="literal">NationalParks.iOS</code> project, right-click on it, and navigate to <strong>Add</strong> | <strong>New File</strong>. In this dialog box, navigate to <strong>General</strong> | <strong>Empty Class</strong> in the <strong>New File</strong> dialog box, enter <code class="literal">iOSParkInfoServices</code> in the <strong>Name</strong> field, and choose <strong>New</strong>.</li><li class="listitem">Add <code class="literal">using</code> clauses for the namespaces, Xamarin.Forms, <code class="literal">NationalParks</code>, <code class="literal">NationalParks.PortableData</code>, and <code class="literal">NationalParks.iOS</code>.</li><li class="listitem">Change the <code class="literal">iOSParkInfoServices</code> class specification so that it implements <code class="literal">IParkInfoServices</code>.</li><li class="listitem">Select <code class="literal">IParkInfoService</code>, right-click on it, navigate to <strong>Refactor</strong> | <strong>Implement interface</strong>, and press <em>Enter</em>.</li><li class="listitem">You <a class="indexterm" id="id731"/>should then <a class="indexterm" id="id732"/>provide implementations for the two methods calls, as follows:<div><pre class="programlisting">public void ShowDirections(NationalPark park)
{
  if ((park.Latitude.HasValue) &amp;&amp;
      (park.Longitude.HasValue))
  {
    NSUrl url = new NSUrl (
        String.Format (
 "http://maps.apple.com/maps?daddr={0},{1}&amp;saddr=CurrentLocation", park.Latitude, park.Longitude));

    UIApplication.SharedApplication.OpenUrl (url);
  }
}
public void ShowPhotos(NationalPark park)
{
    UIApplication.SharedApplication.OpenUrl (
        new NSUrl(String.Format (
          "http://www.bing.com/images/search?q={0}",
          park.Name)));
}</pre></div></li><li class="listitem">Finally, add the following <code class="literal">Dependency</code> attribute to the <code class="literal">class</code> file outside the <code class="literal">namespace</code> definition, as follows:<div><pre class="programlisting">[assembly: Dependency (typeof (iOSParkInfoServices))]
namespace NationalParks.iOS
{
    . . .</pre></div><p>The <a class="indexterm" id="id733"/><code class="literal">Dependency</code> attribute registers the class with <code class="literal">DependencyService</code> so that <a class="indexterm" id="id734"/>when <code class="literal">Get()</code> is called, a platform-specific implementation can be located.</p></li></ol></div></div><div><div><div><div><h4 class="title"><a id="ch08lvl4sec28"/>Creating the Android implementation</h4></div></div></div><p>Now, let's <a class="indexterm" id="id735"/>create an Android <a class="indexterm" id="id736"/>implementation by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the <code class="literal">NationalParks.Android</code> project, right-click on it, and navigate to <strong>Add</strong> | <strong>New File</strong>. You should then navigate to <strong>General</strong> | <strong>Empty Class</strong> in the <strong>New File</strong> dialog box, enter <code class="literal">AndroidParkInfoServices</code> in the <strong>Name</strong> field, and choose <strong>New</strong>.</li><li class="listitem">Add <code class="literal">using</code> clauses for the namespaces, Xamarin.Forms, <code class="literal">NationalParks</code>, <code class="literal">NationalParks.PortableData</code>, and <code class="literal">NationalParks.Droid</code>.</li><li class="listitem">Change the <code class="literal">AndroidParkInfoServices</code> class specification so that it implements <code class="literal">IParkInfoServices</code>.</li><li class="listitem">After this, select <code class="literal">IParkInfoService</code>, right-click on it, navigate to <strong>Refactor</strong> | <strong>Implement interface</strong>, and press <em>Enter</em>.</li><li class="listitem">Provide implementations for the two method calls, as follows:<div><pre class="programlisting">public void ShowDirections(NationalPark park)
{
  if ((park.Latitude.HasValue) &amp;&amp;
    (park.Longitude.HasValue))
 {
     Intent mapIntent = new Intent (Intent.ActionView,
      Android.Net.Uri.Parse (
     String.Format ("geo:0,0?q={0},{1}&amp;z=16 ({2})",
            park.Latitude, park.Longitude,
            park.Name)));
      Forms.Context.StartActivity (mapIntent);
  }
}
public void ShowPhotos(NationalPark park)
{
  Intent urlIntent = new Intent (Intent.ActionView);
  urlIntent.SetData (Android.Net.Uri.Parse (
        String.Format (
        "http://www.bing.com/images/search?q={0}",
        park.Name)));
  Forms.Context.StartActivity (urlIntent);
}</pre></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Note the use of <code class="literal">Forms.Context</code>. In the case of Android, this contains the currently executing <code class="literal">Activity</code>; in our case, <code class="literal">MainActivity</code>.</p></div></div></li><li class="listitem">Add <a class="indexterm" id="id737"/>the following <a class="indexterm" id="id738"/><code class="literal">Dependency</code> attribute to the <code class="literal">class</code> file outside the <code class="literal">namespace</code> definition, as follows:<div><pre class="programlisting">[assembly: Dependency (typeof (AndroidParkInfoServices))]
namespace NationalParks.iOS
{
    . . .</pre></div></li></ol></div></div><div><div><div><div><h4 class="title"><a id="ch08lvl4sec29"/>Adding calls to DependencyService</h4></div></div></div><p>Now, we <a class="indexterm" id="id739"/>need to add code to the shared project in <a class="indexterm" id="id740"/>order to actually invoke <code class="literal">ShowDirections()</code> and <code class="literal">ShowPhotos()</code>. All you need to do is open <code class="literal">ParkDetailPage.xaml.cs</code> and fill in the stub implementations for <code class="literal">DirectionsClicked()</code> and <code class="literal">PhotosClicked()</code>, as follows:</p><div><pre class="programlisting">public void DirectionsClicked(
    object sender, EventArgs e)
{
    DependencyService.Get&lt;IParkInfoServices&gt; ().
        ShowDirections (_park);
}
public void PhotosClicked(
    object sender, EventArgs e)
{
    DependencyService.Get&lt;IParkInfoServices&gt; ().
        ShowPhotos (_park);
}</pre></div></div><div><div><div><div><h4 class="title"><a id="ch08lvl4sec30"/>Running the app</h4></div></div></div><p>We are finally <a class="indexterm" id="id741"/>ready to run the app. While there were <a class="indexterm" id="id742"/>several steps, the <code class="literal">DependencyService</code> API provided a very clean approach to separate shared and platform-specific code. Run both the <code class="literal">NationalParks.iOS</code> and <code class="literal">NationalParks.Android</code> apps.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec91"/>Implementing ParkEditPage</h2></div></div></div><p>Now, we <a class="indexterm" id="id743"/>need a Page to update the park information. To implement <code class="literal">ParkEditPage</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To <a class="indexterm" id="id744"/>begin with, add a new <code class="literal">ContentPage</code> named <code class="literal">ParkDetailsPage</code>.</li><li class="listitem">We will use a similar Layout for <code class="literal">ParkEditPage</code> as we did for <code class="literal">ParkDetailPage</code> with the exception that we will use <code class="literal">Entry</code> views to allow editing of the properties of <code class="literal">NationalPark</code>. Add a <code class="literal">StackLayout</code> and <code class="literal">Grid</code> instance to <code class="literal">ParkEditPage</code>, and add a series of <code class="literal">Label</code> and <code class="literal">Entry</code> views for each property of <code class="literal">NationalPark</code>, as shown in the following code snippet:<div><pre class="programlisting">&lt;Label Text="Name:"
    Grid.Row="0" Grid.Column="0" /&gt;
&lt;Entry x:Name="nameEntry"
    Text="{Binding Name}"
    Grid.Row="0" Grid.Column="1"
    HorizontalOptions="FillAndExpand" /&gt;</pre></div></li><li class="listitem">You can then add a <code class="literal">Done</code> button to complete the editing process, as follows:<div><pre class="programlisting">&lt;Button x:Name="doneButton"
             Text="Done"
              WidthRequest="175"
              HorizontalOptions="Center"
              Clicked="DoneClicked" /&gt;</pre></div></li><li class="listitem">Create two constructors, one that accepts a <code class="literal">NationalPark</code> instance and will be used to edit existing parks, and one that does not accept a <code class="literal">NationalPark</code> instance and will be used to create a new park, as shown in the following code snippet:<div><pre class="programlisting">public ParkEditPage()
{
InitializeComponent ();
  _park = new NationalPark ();
  BindingContext = _park;
}
public ParkEditPage (NationalPark park)
{
  InitializeComponent ();
  _park = park;
  BindingContext = _park;
}</pre></div></li><li class="listitem">Create the <code class="literal">DoneClicked()</code> event handler with a call to save the updated park, and a navigation call to <code class="literal">PopAsync()</code> to return to the Page that displayed <code class="literal">ParkEditPage</code>, as follows:<div><pre class="programlisting">protected void DoneClicked(object sender, EventArgs e)
{
    NationalParksData.Instance.Save(_park);
    Navigation.PopAsync ();
}</pre></div></li><li class="listitem">We now need to add navigation logic to both <code class="literal">ParkListPage</code> and <code class="literal">ParkDetailPage</code>. Open <code class="literal">ParkDetailPage.xaml.cs </code>and fill in the <code class="literal">EditClicked()</code> event handler with a call to <code class="literal">PushAsync()</code> in order to display <code class="literal">ParkEditPage</code>. Pass the park that is being viewed to the <code class="literal">ParkEditPage</code> constructor, as follows:<div><pre class="programlisting">public void EditClicked(object sender, EventArgs e)
{
   Navigation.PushAsync(new ParkEditPage(_park));
}</pre></div></li><li class="listitem">Open <code class="literal">ParkListPage.xaml.cs</code> and fill in the <code class="literal">NewClicked()</code> event handler with a call <a class="indexterm" id="id745"/>to <code class="literal">PushAsync()</code> in order to display <code class="literal">ParkEditPage</code>. Call the empty <code class="literal">ParkEditPage</code> constructor so that a new park will be created, as follows:<div><pre class="programlisting">protected void NewClicked(object sender, EventArgs e)
{
    Navigation.PushAsync(new ParkEditPage());
}</pre></div></li><li class="listitem">We <a class="indexterm" id="id746"/>are now ready with our app; compile and run both the <code class="literal">NationalParks.iOS</code> and <code class="literal">NationalParks.Android</code> apps.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Considering the pros and cons</h1></div></div></div><p>As we <a class="indexterm" id="id747"/>have seen from the exercise, Xamarin.Forms <a class="indexterm" id="id748"/>provides a solid approach to dramatically increase the amount of code reused across your mobile apps; it has many great features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">XAML is a great way to define user interfaces and allows you to create properties and assign event handlers in a convenient, concise way</li><li class="listitem" style="list-style-type: disc">The data binding capabilities are great and eliminate a lot of tedious mind-numbing code from being written</li><li class="listitem" style="list-style-type: disc">The <code class="literal">DependencyService</code> API provides a great way to access platform-specific capabilities</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Renderer</code> architecture provides for ultimate customizability</li></ul></div><p>However, at the time <a class="indexterm" id="id749"/>of writing this book, Xamarin.Forms is still somewhat immature, and there are some weaknesses:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is no visual designer for the XAML code, so you have to construct your UI and run the app to see it visually rendered</li><li class="listitem" style="list-style-type: disc">Due to the <a class="indexterm" id="id750"/>newness of the framework, there is a limited number of examples available for reference, and many of the examples use code to construct the UI rather than XAML</li><li class="listitem" style="list-style-type: disc">Validation capabilities seem pretty weak</li></ul></div><p>These criticisms should not be taken too strongly; cross-platform UI frameworks are tough to build, and I feel confident that Xamarin is on the right track and will evolve the framework rapidly.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter, we reviewed the capabilities of Xamarin.Forms and converted our existing <code class="literal">NationalParks</code> app to use the framework. In the next chapter, we will look at the process of preparing an iOS app for distribution.</p></div></body></html>