- en: Microservices with .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the last few years, a paradigm shift has happened in the way applications
    are designed, in the form of suites of smaller and independently deployable services,
    also known as **microservice architecture** or just **microservices**. The intent
    is to develop simpler and independent services, to release them quickly, and to
    release them often and ensure that if one service is down then other services
    are not impacted, making the app more robust, reliable, and highly scalable. In
    the spirit of this new philosophy, and keeping up with the latest and greatest
    in the technology space, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handy things to know
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor—a new experiment from the ASP.NET team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's coming in .NET Core 2.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a lot to cover, so let's start with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand and appreciate the microservice architecture, we first
    need to see what a service is and how the traditional service monolithic architecture
    has limitations that can be overcome by microservices. Once we have this context
    set up, we will define microservices.
  prefs: []
  type: TYPE_NORMAL
- en: A traditional service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create any server-side enterprise app, it must support a variety of
    different clients, including desktop and mobile browsers, mobile apps, and so
    on. We may also expose APIs, so that third parties can consume them and integrate
    with our system. Like third parties, we may also need to integrate our application
    with other applications through APIs. The app would handle the requests by executing
    business logic, then performing read-write operations by accessing a database
    and/or other data providers and systems, and return an HTML/JSON/XML response.
    What I have described here is a typical enterprise application. We have different
    logical modules in the application to fulfill the business requirements. These
    modules are what we can refer to as services.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, a service is just a software component that provides functionality
    to other pieces of software within your system. A service should be well defined,
    self contained, and should not depend on the context or state of other services.
    The other pieces of software could be anything—a website, a web app, a mobile
    app, a desktop app, or even another service. If I were to give an example, take
    any e-commerce website of your choice. The website displays the products and the
    deals. To display products and deals, it talks to a service. The service is actually
    responsible for the creation,update, deletion, and retrieval of data from the
    database, so the service provides functionality to the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The communication between the different software components and the service
    normally happens over a network using some kind of communication protocol. For
    example, your Facebook mobile app communicates to a service through the internet.
    A system which uses a service or multiple services in this fashion has what''s
    called a **service-oriented architecture**, abbreviated as **SOA**. The idea behind
    SOA is to use a thick server rather than a thick client. This way, many clients
    can have the same functionality. In future, we can have newer or different types
    of clients connecting to the same service, reusing this functionality. As a software
    architecture, SOA has been very successful. A few of the benefits and features
    of SOA are:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows the application to scale up when demand increases, by enabling us
    to have a copy of the service on multiple servers. When the burst of traffic comes
    in, a load balancer will redirect requests to a specific instance of the service.
    We can have multiple instances of a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows reusability of functionality. For instance, in a shopping web app,
    the function to create an order could be the same functionality, which is triggered
    by a mobile app on our service. So, it's the same code creating an order for both
    the website and the mobile app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows standardized contracts or interface-based development. When a client
    application calls a service, it actually invokes a method in the service. The
    signature of the method typically doesn't change when the service implementation
    changes, so we can upgrade our service without having to upgrade our clients,
    as long as the contract and the signature of the method doesn't change. This way,
    we do not have to upgrade the clients when the service is upgraded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is stateless. When a request comes from a client to a service, that instance
    of the service does not have to remember the previous request from that specific
    client. It has all the information from the request that it needs in order to
    retrieve all the data associated with the previous request within the service,
    so a service does not have to remember the previous call the client has made to
    that particular instance of the service and no context needs to be maintained.
    It's stateless, therefore any instance of the service can honor any income request
    from a client, because it does not have to remember any previous interaction with
    any other instance of a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is simple to develop, deploy, and scale the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should now have a fair idea of the SOA that we may have been using without
    knowing what it is for years. Traditional services, which may be using SOA, have
    typically been deployed as a monolith. Monolith consists of two words, mono and
    lith. Mono means single and lith means stone. However, in a software dictionary,
    monolithic architecture refers to applications that are deployed as a single unit.
    An important consideration when developing an application is how easy it is to
    learn and modify, and how quickly new developers can become productive on the
    application. These desired features give rise to an architecture that is simple
    and easily understandable. Another desired aspect is that it should be easy to
    deploy. Keeping all these things in mind, the architecture would be a layered
    application that has a user interface layer which communicates to a service layer,
    which does the data manipulation on the data provider. A typical layered application
    architecture would look as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10cb449a-f43b-4443-b69c-de7fb2542d1e.png)'
  prefs: []
  type: TYPE_IMG
- en: The application is deployed as a single monolithic application and we can run
    multiple instances of the application behind a load balancer in order to scale
    and improve availability.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, as the number of users of the application grows and new enhancements
    are added to the application, the code base grows at a rapid pace and it becomes
    difficult to understand and modify the code. So, the developers become less productive,
    especially the new ones. Since it is complex to understand and modify the code
    base, the bug count in the application increases, which degrades the quality of
    the application. As the code base grows, the IDE (such as Visual Studio) becomes
    overloaded and hence slower, making developers less productive. A large monolithic
    application is also an obstacle to continuous deployment. In order to update/deploy
    one component, the entire application needs to be deployed, which results in down
    time. A monolithic application is also an obstacle to scaling development. Once
    the application gets to a certain size, it's useful to divide up the engineering
    organization into teams that focus on specific functional areas. The trouble with
    a monolithic application is that it prevents the teams from working independently,
    as the code and functionality is coupled in a single monolith. Monolithic architecture
    forces us to be married to a technology stack. So if we have used a Java stack,
    we need to be with Java as long as the application lasts, even if there are better
    tools and technology innovations in other stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The monolithic architecture of an e-commerce website is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecd1e776-88ea-44a5-8495-27a9d4114e7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Due to these limitations, monolithic architecture, which has been around for
    a quite a while, has started to lose popularity over the years. Data speaks for
    itself. So, if we look at the Google trend report for SOA over the last five years,
    it is a graph of losing interest over time. It can be seen at [https://trends.google.com/trends/explore?date=today%205-y&q=SOA](https://trends.google.com/trends/explore?date=today%205-y&q=SOA):[](https://trends.google.com/trends/explore?date=today%205-y&q=SOA)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e91d2568-a095-4273-8065-f03c8339a105.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunate but true, as it happens everywhere else, a loss for one is a gain
    for another. The decline of SOA has seen the rise of microservices. If we look
    at the Google trend report for microservices over the same period of the last
    five years, we see a graph of increasing interest over time, as shown here. This
    can be seen at [https://trends.google.com/trends/explore?date=today%205-y&q=Microservice](https://trends.google.com/trends/explore?date=today%205-y&q=Microservice):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1cf0db8-5840-4717-87eb-4f82eacc7f76.png)'
  prefs: []
  type: TYPE_IMG
- en: This is not just because it is trending, but because major large enterprises
    such as Netflix, Amazon, eBay, and so on have talked about the way they scaled
    and eased out the continuous delivery of their services using microservice architecture,
    so microservice architecture design doesn't seems to be a buzz to ignore. This
    architectural framework is one of the core selling points for emerging start-ups,
    such as Docker, which at the time of writing is valued at about $1 billion while
    still in funding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microservices,** also known as the **microservice architecture**, is an architectural
    style that structures an application as a collection of loosely coupled independent
    services that implement business capabilities. The microservice architecture enables
    the continuous delivery and deployment of large, complex applications. It also
    enables an organization to evolve its technology stack. The microservice architecture
    is basically an improved version of SOA, and therefore it shares all the key characteristics
    of SOA, such as scalability, re-usability, standardized contracts in interfaces
    for backwards compatibility, and the idea of having a stateless service that we
    discussed previously. Microservice capabilities are expressed formally with business-oriented
    APIs. In short, the microservice architectural style defines a setup where application
    components are standalone applications of their own. These independent application
    components talk to each other either using **Remote Method Invocation** (**RMI**),
    RESTful web services or push messaging. Each microservice owns its related domain
    data model and domain logic, based on different data storage technologies and
    different programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the name, you may ask what the size of a microservice should be.
    When developing microservices, size is not a critical factor to consider. The
    imperative point is to make loosely coupled services, so that we have autonomy
    of development, and deployment and scaling for each service. Obviously, we should
    strive to make them as small as possible, as long as we don't have an excessive
    number of direct dependencies upon other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a typical microservice architecture of an e-commerce
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29a01e66-81bc-4472-990d-dda58543f138.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that, compared to the monolithic architecture, this has a lot more
    modularity and autonomy and the services communicate with other microservices.
    Think of a situation where, due to some unavoidable issue, **Payment Services**
    goes down, maybe due to bad code being checked in. The users of the site would
    still be able to view and update the cart. Only the payment functionality would
    be down and the rest of the services would keep serving the users. Now, think
    about a monolithic architecture where there is no independence of module and this
    sort of bad code issue happens. The chances of failure in such cases would be
    higher in monolithic architecture and we may even have a situation where a number
    of features stop working due to dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image presents a good comparison between monolithic and microservice
    architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41472c96-127f-4c77-989f-ca4257bc8c54.png)'
  prefs: []
  type: TYPE_IMG
- en: Microsoft has provided a sample reference app and architecture guidance for
    microservices with ASP.NET Core. The sample is available on GitHub at [https://github.com/dotnet-architecture/eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers).[](https://trends.google.com/trends/explore?date=today%205-y&q=SOA)
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a reasonable understanding and hands-on experience in the development
    of microservices, it is recommended that the reader has a good look at the repository.
    What we have discussed is the tip of the iceberg and just an introduction to microservices.
    We will conclude this discussion with the reference links to microservices, so
    that enthusiastic readers can gain more insights into this new paradigm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET application architecture**: [https://www.microsoft.com/net/learn/architecture](https://www.microsoft.com/net/learn/architecture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**News on .NET architecture**: [https://github.com/dotnet-architecture/News](https://github.com/dotnet-architecture/News)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Martin Fowler on microservices**: [http://martinfowler.com/articles/microservices.html](http://martinfowler.com/articles/microservices.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice architecture pattern**: [http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will be discussing tips and tricks that I found really
    helpful while doing development, debugging, and monitoring the ASP.NET Core 2.0
    web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Handy things to know
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s important for us to understand that there are fundamental architecture
    differences between ASP.NET and ASP.NET Core. A few of the important ones are
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: An important difference between ASP.NET and ASP.NET Core is that ASP.NET Core
    doesn't have a request queue, unlike ASP.NET. The `RequestQueue` class which resides
    in the `System.Web` namespace is designed to prevent thread pool starvation in
    ASP.NET. This no longer exists in ASP.NET Core, so as you can rightly guess, there
    can be thread pool starvation if we do not write proper code. Just so that we
    are on the same page, starvation describes a situation where a thread is unable
    to gain regular access to shared resources and is unable to make progress. This
    happens when shared resources are made unavailable for long periods by greedy
    long running threads. For example, suppose an object provides a synchronized method
    that often takes a long time to return. If one thread invokes this method frequently,
    other threads that also need frequent synchronized access to the same object will
    often be blocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppDomain` is another area where ASP.NET Core is different to ASP.NET. Running
    many instances of `AppDomain` require runtime support and are generally quite
    expensive. ASP.NET Core doesn''t use `AppDomain`. There is a single process and
    a single `AppDomain`, if that makes things easier to comprehend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ASP.NET Core doesn''t have `SyncronizationContext`. If you don''t know `SyncronizationContext`,
    don''t worry. We are discussing it right now. C# 5 came with two new keywords,
    `async` and `await`, which provide a new and easier asynchronous programming experience.
    The approach to use is simple. Have the `async` keyword in the method definition.
    Change the return type of the method from `T` to `Task<T>` or `Task`, if it doesn''t
    return anything (I would not recommend using `void`, unless it''s an event handler
    method). It is also a good practice to use the `async` suffix in the method name,
    so that it is easy to identify that the method is asynchronous. You would also
    need to use at least one `await` statement in the method. Under the hood, the
    compiler translates the `async` method into a state machine and virtually converts
    it into a method that is invoked multiple times, once at the actual method invocation
    that proceeds till the statement containing the `await` keyword and then returns.
    When the statement containing the `await` keyword is executed, the method is invoked
    again from there and executes the remainder of the statements, in the same fashion.
    The following code lists a sample `async` method leveraging the `async` and `await`
    keywords:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An important feature of the `async` and `await` keywords is support for `SyncronizationContext`.
    `SyncronizationContext` has been inside the framework since .NET 2.0 and is not
    something newly added to the framework. As discussed previously, when we `await`
    on an `async` method, the compiler hooks up the continuation, if there is any,
    and the resulting code is aware of the context. So, if the `SyncronizationContext`
    is available, the `await` expression will capture it and use it to invoke the
    continuation, very similar to the `ContinueWith` method offered in the **Task
    Parallel Library** (**TPL**). `SyncronizationContext` should be used with utmost
    care and if we consume the method in blocking fashion, it may lead to deadlock.
    For example, in a non-ASP.NET Core environment, if we wait on a `Task` using the
    `Wait` method or using the `Result` property, we block the main thread. When eventually
    the task completes inside that method in the thread pool, it will invoke the continuation
    to post back to the main thread. But since we have blocked the main thread and
    the task is waiting for the main thread, we will have deadlock. As a precaution,
    library writers are advised to use `ConfigureAwait(false)` while invoking `async`
    APIs, to avoid deadlock. Now that we know `SyncronizationContext`, remember that
    ASP.NET Core doesn't have it! So `ConfigureAwait(false)` doesn't do anything in
    ASP.NET Core. But that doesn't mean threads can't get blocked in ASP.NET Core.
    Bad code can still do wonders.
  prefs: []
  type: TYPE_NORMAL
- en: 'While ASP.NET works on top of `System.Web`, has a rather tight integration
    with **Internet Information Server** (**IIS**), and runs inside the IIS process
    (`w3wp.exe`), ASP.NET Core runs outside of the IIS process. The **ASP.NET Core
    Module** (**ANCM**) enables the ASP.NET Core apps to run behind IIS in a reverse
    proxy configuration, which we saw in an earlier chapter. Just to refresh our memories,
    the work of the proxy or forward proxy is to send a request to the server on behalf
    of a client, while that of the reverse proxy is to receive the request on behalf
    of a server. The following image is the high-level architecture of ASP.NET Core.
    Notice that the center box containing ANCM is the only module that runs inside
    of `w3wp.exe`. The **Kestrel** server and the **App Code** runs inside `dotnet.exe`.
    Contrast it with traditional ASP.NET, which runs inside `w3wp.exe`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3c4df845-3c71-4052-82dc-21e1bd7fb594.png)'
  prefs: []
  type: TYPE_IMG
- en: General tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the differences, let''s move on to some tips and tricks that
    are based on top of these architectural differences and more:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently, I was working on the performance optimization of the ASP.NET Core
    app. We had used in-memory caching with a cache get timeout of five seconds. You
    would expect that any data from in-memory caching would be retrieved in a matter
    of milliseconds as it is an in-process cache and this was generally true. However,
    under load we figured out that data was not getting picked up from the cache.
    Once we added logging, we figured out that the `Get` operation in cache was timing
    out. Yes, even with a five-second value, we had a timeout while fetching data
    from the cache. On investigation, we figured out that we had thread starvation
    in the app. As discussed previously, there is no `RequestQueue` class in ASP.NET
    Core for avoiding this, so here are some tips to avoid thread starvation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always prefer to use `async` all the way, that is, all the APIs must be `async`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid blocking APIs in your ASP.NET Core application as much as possible. So,
    **DON''T USE**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Wait()`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Result`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.Sleep`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetAwaiter().GetResult()`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `sync` over `async` as they are essentially blocking `async` methods.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `async` over `sync` as they have scalability issues.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log thread pool stats in the application code. This helps identify thread starvation.
    Here is the sample code that can be used for logging thread stats. It gives stats
    for both `iopc` and `worker` threads:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Use tools such as [https://github.com/benaadams/Ben.BlockingDetector](https://github.com/benaadams/Ben.BlockingDetector)
    to diagnose blocking.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Set minimum threads using `ThreadPool.SetMinThreads` to keep you safe from starvation.
    The number of minimum threads depends on what your app does and you may have to
    fine-tune it based on your testing. Note that `ThreadPool` can quickly (read instantly)
    span the threads up to the minimum number of thread pool threads specified. After
    that, if more threads are needed, they are throttled by 500 ms and this can cause
    delays or timeouts in service, which are hard to comprehend in production environments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may also want to read about this issue here: [https://github.com/aspnet/KestrelHttpServer/issues/2104](https://github.com/aspnet/KestrelHttpServer/issues/2104).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of `AppDomain` no longer exists in ASP.NET Core, so for code isolation,
    Microsoft recommends processes and/or containers. For dynamic loading of assemblies,
    the recommendation is to use the `AssemblyLoadContext` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is no `SyncronizationContext` in ASP.NET Core, thankfully there
    shouldn't be any deadlocks in ASP.NET Core if you block a task through `Task.Wait`
    or `Task.Result`. However, this should not be taken as a license to use blocking.
    We must always strive for `async` all the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As discussed previously, `ConfigureAwait (false)` has no effect in ASP.NET
    Core, so the following two code snippets work the same way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Task continuations in ASP.NET Core are queued to `ThreadPool` and hence can
    run in parallel. Don't be surprised if your `task.ContinueWith(x=>SomeFunction())`
    stops working in ASP.NET Core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpContext` is not thread safe. Accessing it in parallel may lead to unreliable
    data and issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use Swagger for API testing and documentation. Swagger makes it incredibly
    easy to document and test your APIs. I highly recommend you make use of Swagger
    for the documentation of APIs. There are other tools such as Postman and Fiddler
    that can be used for testing the APIs but Swagger does a great job at it as well.
    Performing a basic API test is as simple as reading this link: [https://swagger.io/blog/how-to-perform-a-basic-api-test/](https://swagger.io/blog/how-to-perform-a-basic-api-test/).
    Read the steps for using Swagger to generate documentation at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio).[](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `InMemory` provider of Ef Core is very useful when you want to test components
    using something that approximates connecting to the real database, without the
    overhead of actual database operation. Please see this link for the step-by-step
    approach: [https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory).[](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ANCM is designed in such a way that if your first request takes a lot of time,
    it will disconnect the client and close the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security is one of the most important but often overlooked aspects in the development
    of web apps. Security is such a vast topic to cover that it is beyond the scope
    of this book, but I would highly recommend developers thoroughly go through the
    security documentation of ASP.NET Core at [https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)
    and inculcate their learning in day-to-day development activities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At times, we may have an issue even while starting the app, due to an incorrect
    code. Though the console logger logs the output in the console window that appears
    briefly at the startup, as soon as the console vanishes (which happens pretty
    quickly), we have no means to know what happened or what prevented the app from
    being started. In such situations, generally the ASP.NET Core module configuration
    can help us unearth the root cause of the issue. The configuration is done in
    the `aspNetCore` section of the `system.webserver` node present in the `web.config`
    file, which is located at the root of the web app. We can enable the output logging
    and specify the log file path. So, in such cases, the detailed error message will
    be logged, and we will be able to identify the cause of the issue. The following
    entry from `web.config` illustrates this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the app is deployed in Azure, the `stdoutLogFile` path is modified to direct
    the app to the `LogFiles` folder of the app.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed a few points relating to the usage of ASP.NET
    Core. In the next section, we will discuss a few tips on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Performance tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core is one of the fastest platforms on the fundamentals of web request
    routing, as per benchmarks. Read the complete story at [https://www.techempower.com/blog/2016/11/16/framework-benchmarks-round-13/](https://www.techempower.com/blog/2016/11/16/framework-benchmarks-round-13/).
    In this section, we will discuss the points we can use to achieve better performance
    in our ASP.NET Core apps:'
  prefs: []
  type: TYPE_NORMAL
- en: It might sound repetitive, but please use `async` all the way. This is key to
    the performance of an ASP.NET Core app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test, test, and test! Perform load testing of your app early and often to find
    the issues early in development. Our team, in fact, came up with a radical idea
    to identify performance bottlenecks. The idea is to write middleware, that calculates
    the response time of the API, and if the response time is higher than the threshold,
    throw an exception, so the developer has to fix it. I would not recommend going
    this drastic but the intent is to identify the performance issues early in the
    game. If your app is deployed in Azure, you can do the performance testing in
    the Azure portal itself, using the following simple steps (here I am assuming
    there is no authentication header needed, otherwise we can write Visual Studio
    performance tests as well):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Azure portal, navigate to the App Service that we wish to performance
    test.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left panel of the App Service, there is an item called Performance test.
    Click on it. It will open the Performance test blade.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the required fields for user load and duration. Each of the fields has
    a help tool tip so it should be easy to identify the purpose of each field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the test to use either a manual URL or a Visual Studio web test. If
    you select manual test, you will need to specify the URL that needs to be load
    tested. If of a Visual Studio web test, you will need to upload the Visual Studio
    web test file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Done** and then click **Run test**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The performance test will run and display the run stats, such as successful
    requests, failed requests with errors, memory and CPU usage, and so on:![](img/51840ec0-f83a-473d-b6b3-686ce738248a.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use caching to store static, less frequently changing and frequently accessed
    data. If you are building an enterprise application, consider leveraging the Azure
    Redis cache for fast data access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the garbage collector in server garbage collection mode. This will ensure
    that your memory footprint doesn''t increase over time. This can be done by the
    following configuration in the `web.config` file, or add an `app.config` file
    with the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about the `gcServer` element at [https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element).
  prefs: []
  type: TYPE_NORMAL
- en: If you make use of web APIs in your application, use `HttpClient` to make the
    API calls. Remember to create the `HttpClient` instance only once and reuse it
    multiple times, that is, create a singleton instance of `HttpClient` and don't
    create it every time. In terms of Dependency Injection, use it as singleton and
    not as transient or scoped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While developing the API, follow these rules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bring only the data that you need**: For the purpose of code re-usability,
    I have seen teams using a single API that returns a plethora of data, even though
    only a part of it is needed. For a small number of users, it may not perform badly,
    but as the user load increases, this will start causing performance bottlenecks,
    so be very miserly with the data that your service returns.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choice of serializer**: A considerable amount of time is spent by a service
    API in serializing the data and then sending it as a response. The client then
    gets the response and deserializes it back which again takes time. It is worth
    investing in a serializer that does the job faster, to provide better response
    time performance. There are a number of serializers at the developer''s disposal
    such as JSON, BSON, MessagePack, Protocol Buffers, and so on. We recently changed
    JSON to MessagePack and found massive performance gains, as a MessagePack payload
    is about 66% of JSON and about three times as fast.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compression:** Think of compressing the data sent from the service API to
    the client. This will be beneficial to mobile users, as well as to whoever may
    be using your app on a flaky and low bandwidth network, so less data to load would
    make apps faster. Also, by compressing the payload, we make our application scalable
    as the bandwidth available to us is limited. There are numerous ways of doing
    it. Of course, `HttpClient` has support for `GZip` compression so we can leverage
    it. Equally important is the fact that we can choose what properties to serialize.
    So, if your entity has ten properties and you need only two properties, then it
    makes perfect sense to serialize only those two properties and ignore the remaining
    eight properties, to reduce the payload. This is well supported in JSON and we
    made extensive use of it, and in a few cases came down from 32 MB data to less
    than 1 MB data. Imagine if this API is called by hundreds of users!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make good use of bundling and minification, as discussed in an earlier chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response caching reduces the number of requests a client or proxy makes to a
    web server. Response caching also reduces the amount of work the web server performs
    to generate a response, hence improving the performance. Please make a note that
    response caching is not supported for ASP.NET Core Razor pages, but support is
    expected to come in ASP.NET Core 2.1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While using parallelism or multiple threads to write data, make use of concurrent
    collections. In fact, if you think you may have multiple threads modifying a collection,
    it's always safe to use concurrent collections, with little overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid API or database calls inside a loop. In the case of APIs, try to create
    an API that takes the collection as input and processes that to return a consolidated
    but trimmed set of required data. In the case of a database, create a stored procedure
    that accepts a user-defined table as a parameter and returns the data in one go.
    This will make the application less chatty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not perform string concatenation inside loops. Use `StringBuilder` if you
    need to concatenate strings inside loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visual Studio has great support for profiling your application to identify
    high CPU issues, so do make good use of the Visual Studio profiler while in the
    development phase. It''s very simple to use, as illustrated in these steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the app that you wish to profile is up and running in the machine.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Visual Studio and in the quick launch, search for Performance Explorer.
    Alternatively, you can navigate through Debug | Profiler | Performance Explorer
    | Attach/Detach, as shown here:![](img/f4952a2a-0817-435e-9dc3-47fd3956883c.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It will open a dialog, displaying the list of running processes. Select the
    process that you wish to profile and click Attach.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The profiling will start. Now is the time to reproduce your high CPU issue and
    once it is reproduced, stop the profiling. It will generate a detailed profiling
    report. We will see what the profile report looks like a little later when we
    discuss profiling in Azure.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Profile your memory to identify whether there is a memory leak. Always remember,
    that if your memory percentage remains constant or keeps increasing over a period
    of time, there may be a memory leak. Memory leak can be described as a situation
    where a program holds on to the memory even if that memory is discarded and no
    longer needed. Due to bad coding, the developer code can prevent the **Garbage
    Collector** (**GC**) from reclaiming the memory, and hence, used memory keeps
    increasing over a period of time, resulting in performance issues or failures.
    Apart from Visual Studio, there are many good profiling tools that can be used
    such as dotTrace, MemProfiler, ANTS Memory Profiler, PerfView, to name a few.
    One of the common causes of memory leak in the ASP.NET Core applications that
    I have encountered is wrong Dependency Injection. So, if an object needs to be
    scoped or transient and you register it as a singleton, we may be injecting memory
    leak if it's not meant to be a singleton. Static objects and dictionaries are
    another common cause of memory leak, so please think multiple times before marking
    an object as static.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core has support for analyzers. Code analysis, as the name suggests,
    is the analysis of the code to identify potential code issues, such as improper
    coding, noncompliance to standards, security violations, and design problems.
    Code analysis can be static or dynamic. In static, the analysis is done without
    actually running the code. StyleCop, FxCop are few of the most well-known and
    frequently used code analyzers. Make use of analyzers to identify code issues
    early. A few of the great ones are `Microsoft.CodeAnalysis`, `SonarAnalyzer.Csharp`,
    `FxCop analyzer`, `Roslynator.Analyzers`, and `Stylecop analyzer`, to name a few.
    These are also simple to use—right-click on the project and select Nuget Package
    Manager. Search for the analyzer of your choice and install it. Build your project
    and observe the warnings and errors in the error window. This will help you nail
    a variety of issues, such as possible performance bottlenecks, security vulnerabilities,
    as well as not following best practices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read this excellent MSDN blog post on performance improvements in ASP.NET Core:
    [https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/](https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/).'
  prefs: []
  type: TYPE_NORMAL
- en: Also, read the official performance documentation of ASP.NET Core at [https://docs.microsoft.com/en-us/aspnet/core/performance/](https://docs.microsoft.com/en-us/aspnet/core/performance/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at a few of the cool and handy features of Azure that can
    help us be more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Azure tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure has a plethora of features and most of them remain unexplored or unused
    by a number of developers, though they are extremely useful and provide value.
    A few of the important ones I came across are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure in your pocket**: We will start with a cheesy one. Yes, Azure in your
    pocket. Now Azure is available as a mobile app, and you can virtually carry your
    Azure subscription wherever you go. You can keep track of your Azure resources
    on the go and stay connected—anytime, anywhere. The following image shows a glimpse
    of the Azure mobile app:![](img/d12f8f80-285f-47f6-8381-552aadc944ac.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advisor**: In the left panel of the Azure portal, there is an item called
    Advisor. Although it''s free, it''s a relatively lesser-used and talked about
    feature of Azure. It''s completely free and it provides real-time advisory services
    on your Azure resources, based on how they are used. Just click on the Advisor
    and it will give security, performance, cost, and availability recommendations.
    The recommendations can also be downloaded in CSV or PDF format. Here is the teaser
    of Azure Advisor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/502b6376-7da3-4313-a53b-291a50aedd71.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Security Center**: Just like Advisor, there is a Security Center option in
    the left panel. This is a great and free feature of Azure. It does threat detection
    all the Azure resources in your subscription and gives pointed recommendations.
    It also lets you know of any security incidents that occurred with your resources
    and threat assessment reports. There is a paid plan which has advanced threat
    detection but the free option is a good starting point. The following image shows
    the Security Center:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/52cad30f-da83-436a-b310-8a831c0997d4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Activity logs**: When I have worked in a team that is working on Azure, there
    have been instances where I am working on the web app and some other team member
    accidentally changes the configuration, or maybe restarts or deletes a resource,
    and I have no clue what happened. I have myself been the culprit, modifying the
    configuration while the performance test was running, which restarted the web
    app. Azure has a solution for these kinds of situations as well. Every action
    that a user does is logged in the activity log of the resource you are working
    with. So, next time you encounter something like this, just go and see the activity
    log, as shown here. In the Azure portal, go to the resource you wish to see the
    activity log of. On the left panel of the resource, click on Activity Log. You
    can also apply filters and choose the time duration for which you wish to see
    the activity log:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1a49b25f-8382-4241-8193-8e2af8b8d833.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Diagnostic logging**: If you are running into issues in the app deployed
    in Azure and do not know what''s going on, enable logging and Application Insights
    in your app. We looked at Application Insights earlier. Logging can give us details
    such as failed request tracing and detailed error logs. You will see two options
    for Application Logging—Blob and Filesystem. As the name suggests, logs are stored
    in blob and filesystem. Filesystem logging is enabled only for 12 hours, as there
    is a risk of logs eating up memory. The following image shows the diagnostic logging
    configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/779e4da9-2644-4bf0-8ade-71cb02493c79.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Diagnosing and solving issues**: This is another cool feature in Azure. If
    you run into issues or suspect something is going wrong in your App Service, Azure
    provides very good diagnoses and a fix for the issues. It is able to clearly identify
    whether the issue is due to a platform or application code issue. It diagnoses
    a variety of problem categories such as web app down, slow web app, high CPU usage,
    high memory usage, web app restarted, TCP connections. It has a chat interface
    making it easier to use. Just click on one of the problem categories and it will
    do the analysis on the app for the last 24 hours and share the graph and findings,
    which makes it extremely easy to identify the issue. It will also give recommendations
    if you need to scale out your app. Also, you can do a health checkup of the resource
    on demand, which gives a single view for application errors, performance, CPU,
    and memory usage. This is definitely a very handy tool to use for diagnosis. Here
    is the screenshot for diagnosing and solving issues:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d9b7e223-36d8-44ba-a9c2-03eebc20cf50.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Diagnostics as a Service (DaaS)**: Yet another great troubleshooting tool
    for developers is DaaS. When you open the diagnose and solve issues blade for
    your App Service, there is a panel on the right displaying a number of links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3c7d2aaf-ca58-46d3-90bb-d89655987fcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of them is a great diagnostic and support tool in itself, but we will
    focus on DaaS. I would highly recommend you explore each of these links. Coming
    back to DaaS, this is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2267c33-46bf-41f3-b576-d994519f3125.png)'
  prefs: []
  type: TYPE_IMG
- en: It has support for ASP.NET, PHP, and Java applications. We will select ASP.NET
    as our application type and when we do that, we will see ASP.NET-specific diagnosers
    such as CLR Profiler, Event Viewer Logs, Memory Dump, and HTTP Logs. Based on
    the diagnosis that we need to do, we can select appropriate options. I generally
    check everything whenever I am doing diagnosis. Memory Dump analysis can be great
    to identify memory leaks, but the dump needs to be taken when you observe constant
    high or increasing memory usage. Now, how to do it. Well, it's simple, you can
    see the memory and CPU usage of your App Service in the Overview blade of your
    App Service in the portal. Note that you would need at least two memory dumps
    to confirm a memory leak. Likewise, CLR Profiler can be used to find out what
    section of your code is doing the most work at the time of profiling, so it's
    important to profile when the time issue is occurring in your App Service. After
    selecting the options, click Run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure will capture the data and then perform the analysis, and share the analysis
    report which you download and act upon, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b183337-c5f3-41ca-9cea-d2b460ca50a6.png)'
  prefs: []
  type: TYPE_IMG
- en: The CLR Profiler `.diagsession` file can be downloaded by clicking on the `.diagsession`
    file shown in the image under the Collection Status column, and opened in Visual
    Studio. It will give you the hot path as well as the code block and methods doing
    the most work during the profiling session. The Memory Dump can also be downloaded
    and you can do a memory dump analysis locally using Windbg or DebugDiag, as needed.
    Azure provides a DebugDiag analysis report which can be directly downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Service Profiler**: Use Azure Service Profiler to identify high CPU
    issues. This has great support for ASP.NET Core 2.0\. The setup details and value
    it provides can be seen at [https://www.azureserviceprofiler.com/](https://www.azureserviceprofiler.com/).
    On installing this Profiler for your web app, it will run as a web job and diagnose
    the issue by identifying the hot paths. It also summarizes performance data to
    find long-tail performance problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiling the app for high CPU**: With the detailed metrics on CPU and memory
    provided by Azure, we can easily identify whether the App Service is using high
    CPU. If it is, how do we figure out what is causing the app to use high CPU? Yes,
    profiling. Profiling is easy to do in Visual Studio and even in Azure. Even though
    DaaS does the profiling, I always see `w3wp.exe` getting profiled and not the
    actual application `.exe` that we have built. To profile our application code,
    we can do the following simple steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Azure portal, select the App Service that you wish to profile (search
    for the App Service and click it).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left panel of the App Service, click on Advanced Tools. This will open
    the Advanced Tools blade. Click on the Go button in this blade. This will take
    you to the Kudu site of your App Service. There is a shortcut to reach here. If
    your App Service URL is [http://myappservice.azurewebsites.net](http://myappservice.azurewebsites.net),
    then the corresponding Kudu site would be [http://myappservice.**scm**.azurewebsites.net](http://myappservice.scm.azurewebsites.net).
    Notice `scm` between `myappservice` and `azurewebsites.net`. You must have required
    access to the Kudu site, so not everyone can go to the Kudu site of any website:![](img/7b91ffaa-1eb3-4da3-b782-54895d5c72bb.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top bar, select Process explorer. This will open the Process Explorer
    as shown here:![](img/7d5bdf46-c149-4041-9db8-3cdf4207e597.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Start Profiling button of your application `.exe`, when you observe
    high CPU in the app. It will take a while to start profiling. Once the profiling
    is done, click on Stop Profiling. This will start generating the diagnostics and
    generate the `.diagsession` file, which you will be prompted to download.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon downloading the file, open it with Visual Studio. It will show the CPU
    graph. There will be a button called Create detailed report. Click on it and it
    will open a nice-looking report with hot paths, a summary, and will lead you to
    the code causing the high CPU, as shown here:![](img/79c138b4-1f4b-465b-ab47-545726067c37.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Support**: Now that we know the Kudu site, another diagnostic tool that may
    be useful is Azure App Service Support, which can be browsed by appending `/support`
    in the Kudu site URL. For the preceding example, the support site would be [http://myappservice.scm.azurewebsites.net/support](http://myappservice.scm.azurewebsites.net/support).
    As of writing this chapter, it is in a preview state. We can Observe, Analyze,
    and Mitigate the issues from here, as shown in the following screenshot. The Observe
    section can be used to view stats such as requests/second and errors/sec. The
    Analyze section can be used to view FREB (**F**ailed **R**equest **E**rror **B**uffering)
    Logs, Event Viewer logs, and running Diagnostics to figure out CPU and memory
    issues. The Mitigate section has a switch to autoheal the app. Most memory and
    CPU issues are resolved upon restart and that is where the autoheal feature comes
    into the picture. If you have a scenario where you need to recycle the application
    automatically, after it has served, say, *X* number of requests in *Y* amount
    of time, you can consider autoheal as an option—*X* and *Y* can be configured
    by means of a rule:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/98dd093c-23ed-4a30-bd6c-259228453019.png)'
  prefs: []
  type: TYPE_IMG
- en: '**New support request**: If none of these options seem to have helped you identify
    the issue, which shouldn''t happen often if done well, you can leverage the expertise
    of Azure support to help you with an issue, by creating a New support request
    in the left panel of your App Service, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/91bb1d5d-6ef3-4a0e-9f3a-e19c0becbe55.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's have a quick look at a new experimental project of the ASP.NET team
    called Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Blazor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor is a new experiment by the ASP.NET team. Blazor got its name from two
    words, Browser and Razor.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is an experimental web UI framework using C#, Razor, and HTML, running
    in the browser through WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: What is WebAssembly? **WebAssembly** or **wasm** is an open, new-age format
    standard, with an initial version that has reportedly reached cross-browser consensus.
    It is described as *a new portable, size-and load-time-efficient format suitable
    for compilation to the Web.* WebAssembly is a new type of code that can be run
    in modern web browsers. It is a low-level assembly-like language with a compact
    binary format that runs with near-native performance and provides languages, such
    as C/C++, with a compilation target so that they can run on the web. It is also
    designed to run alongside JavaScript, allowing both to work together. It is a
    browser improvement. Since it is a binary format, we'll be able to compile binary
    bundles that compress to a smaller size than the text JavaScript. Smaller payloads
    means faster delivery and so it may run faster than JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor runs .NET code in the browser via a small, portable .NET runtime called
    **DotNetAnywhere** (**DNA**) compiled to WebAssembly. Essentially, Blazor makes
    life easier and happier for developers like me who are not great at JavaScript
    and want to write less of it. You can code your entire app in C#, Razor, and HTML,
    which runs inside the browser, without having to write a single line of JavaScript
    and it works just like any **Single-Page Application** (**SPA**). It gives all
    the benefits of a rich and modern platform while letting us use .NET end to end.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is developed as a personal project by Steve Sanderson, who is part of
    the ASP.NET team and works out of the UK. He has a detailed blog which talks about
    it and how it works. It can be read at [http://blog.stevensanderson.com/2018/02/06/blazor-intro/](http://blog.stevensanderson.com/2018/02/06/blazor-intro/).[](http://blog.stevensanderson.com/2018/02/06/blazor-intro/)
  prefs: []
  type: TYPE_NORMAL
- en: Other blogs providing great insights into Blazor can be read at [https://visualstudiomagazine.com](https://visualstudiomagazine.com/articles/2017/08/09/blazor.aspx).[/articles/2017/08/09/blazor.aspx](https://visualstudiomagazine.com/articles/2017/08/09/blazor.aspx)
    and [https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/](https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/).[](https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project/)
  prefs: []
  type: TYPE_NORMAL
- en: The demo of Blazor can be seen at [https://blazor-demo.github.io/](https://blazor-demo.github.io/).[](https://blazor-demo.github.io/)
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds exciting, there is even more exciting stuff in the upcoming 2.1
    release of ASP.NET Core. Let's have a sneak peek at it.
  prefs: []
  type: TYPE_NORMAL
- en: What's coming in .NET Core 2.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preview version of .NET Core 2.1 is launched on February 27th 2018\. We
    can start developing a .NET Core 2.1 application using Visual Studio 2017 15.6
    Preview 6 or later, and also using Visual Studio Code. Let's see what is newly
    added to .NET Core 2.1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build performance:** In .NET Core 2.1, build time performance has improved.
    CLI tools and MSBuild have improved and are much faster than before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor version roll forward:** We can run the .NET Core X.x application on
    later minor versions with the same major version range, such as .NET Core 2.1
    applications on .NET Core 2.6\. This roll forward feature is applicable to minor
    versions only, so 2.1 can''t be automatically rolled forward to .NET Core 3.0,
    or any other major version. Roll forward behavior is only relevant when the expected
    .NET Core version is not present in the given environment. We can disable this
    feature using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variable**: `DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX=0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**runtimeconfig.json**: `rollForwardOnNoCandidateFx=0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLI**: `roll-forward-on-no-candidate-fx=0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sockets performance and HTTP managed handler:** As part of the new version,
    socket performance has increased. Sockets are the basis of outgoing and incoming
    network communication. In .NET Core 2.0 ASP.NET, the Kestrel web server and `HttpClient`
    use native `Socket` not the .NET `Socket` class. There will be three significant
    performance improvements for sockets. It supports `Span<T>` and `Memory<T>` in
    `Socket` and `NetworkStream`. `SocketHttpHandler` performance has improved. A
    few benefits are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform dependencies have been eliminated on libcurl (linux) and WinHTTP (Windows)—this
    simplifies both development, deployment, and servicing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent behavior across all platforms and platform/dependency versions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can opt in to using the `SocketHTTPHandler` in one of the following ways
    with Preview 1:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variable**: `COMPlus_UseManagedHttpClientHandler=true`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AppContext**: `System.Net.Http.UseManagedHttpClientHandler=true`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Span<T>**, **Memory<T>:** New types are introduced for using arrays and for
    other types of memory, which is efficient and increases performance. Using `Span`,
    we can pass a subset of an array, for example 5 elements of a 100 element array,
    we can create a `Span<T>` which provides a virtual of that array, without time
    or space cost. Now, no need to make a copy of those five arrays. This is also
    `struct`, so no allocation cost. With slicing capabilities, it obviates the need
    for expensive copying and allocation in many cases, such as string manipulation
    buffer management and so on. Here is an example of creating `Span<T>` from an
    array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we can easily and efficiently create a `Span` to represent/point
    to just a subset of this array, utilizing an overload of the span’s `Slice` method.
    From there, you can index into the resulting span to write and read data in the
    relevant portion of the original array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Windows Compatibility Pack:** When we port existing code from the .NET Framework
    to .NET Core, we can use the [new Windows Compatibility Pack](https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack-for-net-core/).
    It provides access additional 20,000 APIs, compared to what is available in .NET
    Core. This includes `System.Drawing`, EventLog, WMI, Performance Counters, and
    Windows Services. The following example illustrates accessing the Window registry
    with APIs provided by the Windows Compatibility Pack. The sample fetches the value
    of `TechnicalEditor` of book `NetCore2ByExample` from `CurrentUser` registry hive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about .NET Core 2.1 features, please visit the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/webdev/2018/02/02/asp-net-core-2-1-roadmap/](https://blogs.msdn.microsoft.com/webdev/2018/02/02/asp-net-core-2-1-roadmap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we conclude the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got an overview of microservice architecture how it is an
    extension of SOA and overcomes the limitations of traditional monolithic apps.
    We also learned the important architectural differences between ASP.NET and ASP.NET
    Core. We discussed a few tips to keep in mind while developing ASP.NET Core 2.0
    applications, due to the architectural differences. We then discussed a few handy
    tips to improve the performance of ASP.NET Core apps. We discussed a few tips
    on Azure as well and then moved our discussion to the new experimental project
    of the ASP.NET Core team, called Blazor. We concluded the chapter with a discussion
    on the features that are coming in ASP.NET Core 2.1\. In the next and final chapter
    of the book, we will discuss functional programming with F#.
  prefs: []
  type: TYPE_NORMAL
