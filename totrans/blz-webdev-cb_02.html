<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-65">
    <a id="_idTextAnchor065">
    </a>
    
     2
    
   </h1>
   <h1 id="_idParaDest-66">
    <a id="_idTextAnchor066">
    </a>
    
     Synchronous and Asynchronous Data Binding
    
   </h1>
   <p>
    
     In this chapter, we will explore various facets of data binding in Blazor.
    
    <strong class="bold">
     
      Binding
     
    </strong>
    
     is a cornerstone
    
    <a id="_idIndexMarker077">
    </a>
    
     in modern web development.
    
    
     We’ll start with the fundamentals of binding values with DOM elements.
    
    
     Then, we will progress to binding specific DOM events, ensuring that your Blazor application is highly interactive and responsive.
    
    
     Most commercial applications will require integration with an external data provider.
    
    
     With that, you will have to perform asynchronous actions.
    
    
     We will explore how to pair them with bindings
    
    
     
      as well.
     
    
   </p>
   <p>
    
     Further, we’ll cover customizing getters and setters, allowing for greater data handling flexibility.
    
    
     We will also cover the
    
    <strong class="source-inline">
     
      bind-Value
     
    </strong>
    
     binding pattern, which should simplify most of your binding scenarios.
    
    
     Lastly, we will implement a commercial scenario of seamless binding with an external data provider.
    
    
     That comes in handy when implementing search modules or data
    
    
     
      persistence mechanisms.
     
    
   </p>
   <p>
    
     However, we will fully skip building forms or using Blazor-native components that can simplify binding – we cover that in
    
    <a href="B22020_06.xhtml#_idTextAnchor203">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     , which covers
    
    <em class="italic">
     
      building
     
    </em>
    
     <em class="italic">
      
       interactive forms
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     By the end of this chapter, you will gain a deep understanding of data binding in Blazor.
    
    
     It will enable you to build more dynamic and user-friendly web applications.
    
    
     All interactivity you’ll come to implement will come down to binding.
    
    
     You’ll have recipes at hand to handle those synchronous and
    
    
     
      asynchronous scenarios.
     
    
   </p>
   <p>
    
     Here’s the list of recipes we’ll cover in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Binding values with
     
     
      
       markup elements
      
     
    </li>
    <li>
     
      Binding to a specific
     
     
      
       DOM event
      
     
    </li>
    <li>
     
      Performing asynchronous actions
     
     
      
       after binding
      
     
    </li>
    <li>
     
      Customizing get and set
     
     
      
       binding logic
      
     
    </li>
    <li>
     
      Simplifying binding with the
     
     
      <strong class="source-inline">
       
        bind-Value
       
      </strong>
     
     
      
       pattern
      
     
    </li>
    <li>
     
      Binding with an external
     
     
      
       data provider
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-67">
    <a id="_idTextAnchor067">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     As we will be exploring fundamental concepts of Blazor and web development, you won’t need any paid add-ons or additional tools.
    
    
     You will, however, need
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      A modern IDE (of
     
     
      
       your choice)
      
     
    </li>
    <li>
     
      A modern web browser (
     
     
      
       supporting
      
     
     
      <strong class="bold">
       
        WebAssembly
       
      </strong>
     
     
      
       )
      
     
    </li>
    <li>
     
      A
     
     
      
       Blazor project
      
     
    </li>
   </ul>
   <p>
    
     All the code examples (and data samples) that you’ll see next can be found in a dedicated GitHub
    
    
     
      repository
     
    
    
     
      at
     
    
    
     
      :
     
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter02">
     
      
       https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter0
      
     
     
      
       2
      
     
    </a>
   </p>
   <h1 id="_idParaDest-68">
    <a id="_idTextAnchor068">
    </a>
    
     Binding values with markup elements
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker078">
    </a>
    
     introduce the foundational concept
    
    <a id="_idIndexMarker079">
    </a>
    
     of data binding in Blazor applications.
    
    
     This feature bridges the gap between the user interface and the application’s data or state.
    
    
     A deep understanding of this concept will allow you to level up the interactivity of your projects.
    
    
     We start with mastering
    
    
     
      the basics.
     
    
   </p>
   <p>
    
     Let’s bind a simple text field to a backing variable to see the data flowing from the user interface to
    
    
     
      the backend.
     
    
   </p>
   <h2 id="_idParaDest-69">
    <a id="_idTextAnchor069">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into binding, create a
    
    <strong class="source-inline">
     
      Recipe01
     
    </strong>
    
     directory – this will be your
    
    
     
      working directory.
     
    
   </p>
   <h2 id="_idParaDest-70">
    <a id="_idTextAnchor070">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to bind a C# value with a
    
    
     
      markup element:
     
    
   </p>
   <ol>
    <li>
     
      Add a routable
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component that renders in an
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch02r01"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      , initialize a
     
     <strong class="source-inline">
      
       User
      
     </strong>
     
      variable to store the user
     
     
      
       input value:
      
     
     <pre class="source-code">
@code {
    protected string User = string.Empty;
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup, add a call to action and an input field with a
     
     <strong class="source-inline">
      
       @bind
      
     </strong>
     
      attribute assigned to the
     
     
      <strong class="source-inline">
       
        User
       
      </strong>
     
     
      
       variable:
      
     
     <pre class="source-code">
&lt;h3&gt;What's your name?&lt;/h3&gt;
&lt;input class="form-control w-50" @bind="@User" /&gt;</pre>
    </li>
    <li>
     
      As part of the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup, construct a little logic to dynamically
     
     <a id="_idIndexMarker080">
     </a>
     
      display
     
     <a id="_idIndexMarker081">
     </a>
     
      a greeting once the user fills the
     
     
      
       input field:
      
     
     <pre class="source-code">
@if (string.IsNullOrWhiteSpace(User)) return;
&lt;hr /&gt;
&lt;h1&gt;Hello @User!&lt;/h1&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-71">
    <a id="_idTextAnchor071">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We kick off the recipe with a routine step in Blazor development – the creation of a new component.
    
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we execute a routine step in Blazor development – we create a new
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component and declare its render mode.
    
    
     In our case, we opt for
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     and initialize a
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     backing field – crucial for our
    
    
     
      data-binding operation.
     
    
   </p>
   <p>
    
     The actual binding magic starts in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     .
    
    
     We move to the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     markup and, next to a call to action, we embed an
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     element and leverage Blazor’s native
    
    <strong class="source-inline">
     
      @bind
     
    </strong>
    
     attribute for the first time.
    
    
     The
    
    <strong class="source-inline">
     
      @bind
     
    </strong>
    
     attribute enables a two-way data binding – not only assigning the input value to the
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     backing field but also ensuring that the UI is updated to reflect this change.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we add another section of the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     markup – we display the current
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     value when a user fills the input.
    
    
     That will help us to visualize the behavior of
    
    
     
      our binding.
     
    
   </p>
   <p>
    
     The two-way binding, facilitated by the
    
    <strong class="source-inline">
     
      @bind
     
    </strong>
    
     attribute, simplifies the implementation of user interactivity.
    
    
     It is a go-to method for most simple binding cases, where you don’t need to execute additional logic.
    
    
     Notably, by default, this binding occurs when the user exits the input box, but
    
    <a id="_idIndexMarker082">
    </a>
    
     that’s
    
    <a id="_idIndexMarker083">
    </a>
    
     fully customizable.
    
    
     We will explore and clarify this behavior and its underlying mechanics in the
    
    
     
      next recipe.
     
    
   </p>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor072">
    </a>
    
     Binding to a specific DOM event
    
   </h1>
   <p>
    
     Now, we will dive into
    
    <a id="_idIndexMarker084">
    </a>
    
     targeted and efficient handling of user interactions in Blazor applications.
    
    
     While general data binding is crucial, binding specific actions to specific
    
    <strong class="bold">
     
      DOM events
     
    </strong>
    
     takes your application’s interactivity to the next level.
    
    
     This approach allows for a more controlled and responsive user experience.
    
    
     You can directly link an event, such as a click or a key press, to a corresponding C# method or action.
    
    
     You’ll learn how to identify and bind to these events and which events
    
    
     
      are bindable.
     
    
   </p>
   <p>
    
     Let’s implement a simple text field but trigger binding as the user types, not when they exit the field, which is the
    
    
     
      default behavior.
     
    
   </p>
   <h2 id="_idParaDest-73">
    <a id="_idTextAnchor073">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before exploring binding on a specific event, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy your
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Binding values with markup elements
      
     </em>
     
      recipe or copy its implementation from the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-74">
    <a id="_idTextAnchor074">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To bind to a specific DOM event, follow
    
    
     
      these instructions:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block in your
     
     
      <strong class="source-inline">
       
        IntroduceYourself
       
      </strong>
     
     
      
       component.
      
     
    </li>
    <li>
     
      Alongside the existing
     
     <strong class="source-inline">
      
       User
      
     </strong>
     
      variable, initialize a new
     
     <strong class="source-inline">
      
       Greeting
      
     </strong>
     
      variable.
     
     
      We will use it to hold a greeting for
     
     
      
       the user:
      
     
     <pre class="source-code">
protected string User = string.Empty,
                 Greeting = string.Empty;</pre>
    </li>
    <li>
     
      Implement the
     
     <strong class="source-inline">
      
       IsGreetingReady
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       IsUserFilled
      
     </strong>
     
      methods, which allow you to
     
     <a id="_idIndexMarker085">
     </a>
     
      evaluate the state of the
     
     <strong class="source-inline">
      
       User
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        Greeting
       
      </strong>
     
     
      
       variables:
      
     
     <pre class="source-code">
private bool IsGreetingReady
    =&gt; !string.IsNullOrWhiteSpace(Greeting);
private bool IsUserFilled
    =&gt; !string.IsNullOrWhiteSpace(User);</pre>
    </li>
    <li>
     
      Add a
     
     <strong class="source-inline">
      
       SayHello()
      
     </strong>
     
      method that prepares a
     
     
      
       greeting message:
      
     
     <pre class="source-code">
private void SayHello() =&gt; Greeting = $"Hello {User}";</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup, extend the input field binding by adding
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        bind:event="oninput"
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;input class="form-control w-50"
       @bind="@User"
       @bind:event="oninput" /&gt;</pre>
    </li>
    <li>
     
      Extend the input field binding further by attaching a
     
     <strong class="source-inline">
      
       SayHello()
      
     </strong>
     
      behavior to the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        onfocusout
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
&lt;input class="form-control w-50" @bind="@User"
       @bind:event="oninput"
       @onfocusout="@SayHello" /&gt;</pre>
    </li>
    <li>
     
      Remove any existing checks of the
     
     <strong class="source-inline">
      
       User
      
     </strong>
     
      value from the previous implementation and implement a conditional greeting rendering based on the
     
     
      
       state-checking methods:
      
     
     <pre class="source-code">
@if (IsGreetingReady)
{
    &lt;h1&gt;@Greeting&lt;/h1&gt;
    return;
}
@if (IsUserFilled)
{
    &lt;h1&gt;Introducing @User...&lt;/h1&gt;
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-75">
    <a id="_idTextAnchor075">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we’re
    
    <a id="_idIndexMarker086">
    </a>
    
     enhancing the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component to make it more interactive and engaging.
    
    
     Our goal is to enable the component to greet the user and display the progress of the user
    
    
     
      name input.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component, and in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we go straight to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block and initialize an additional
    
    <strong class="source-inline">
     
      Greeting
     
    </strong>
    
     variable to store the generated greeting message.
    
    
     That sets the stage for our dynamic user interaction.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we introduce
    
    <strong class="source-inline">
     
      IsUserFilled
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      IsGreetingReady
     
    </strong>
    
     parameterless methods that check the state of the
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Greeting
     
    </strong>
    
     variables and allow us to simplify the markup code and make our logic more readable.
    
    
     Moving on to
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we add another method –
    
    <strong class="source-inline">
     
      SayHello()
     
    </strong>
    
     .
    
    
     We will invoke
    
    <strong class="source-inline">
     
      SayHello()
     
    </strong>
    
     when the user finishes typing their name to generate a greeting and assign it to the
    
    <strong class="source-inline">
     
      Greeting
     
    </strong>
    
     variable.
    
    
     It adds a personalized touch to the
    
    
     
      user experience.
     
    
   </p>
   <p>
    <em class="italic">
     
      Step 5
     
    </em>
    
     is where we take control of the binding logic.
    
    
     You can trigger binding on any event applicable in script-based frameworks, such as
    
    <strong class="source-inline">
     
      oncopy
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      onpaste
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      onblur
     
    </strong>
    
     .
    
    
     We chose the
    
    <strong class="source-inline">
     
      oninput
     
    </strong>
    
     event for this example.
    
    
     We override the default binding event with
    
    <strong class="source-inline">
     
      @bind:event="oninput"
     
    </strong>
    
     and enable
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     value live updates as the user types.
    
    
     Notice the lowercase syntax of the
    
    <strong class="source-inline">
     
      @bind:event
     
    </strong>
    
     attribute, as Razor is a case-sensitive language framework.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we take interactivity a step further.
    
    
     We use a native Blazor reference to the
    
    <strong class="source-inline">
     
      @onfocusout
     
    </strong>
    
     event and when the user navigates away from the input field, we invoke the
    
    <strong class="source-inline">
     
      SayHello()
     
    </strong>
    
     method, effectively generating the
    
    
     
      greeting message.
     
    
   </p>
   <p>
    
     Finally, in
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we implement a little rendering logic to ensure that the greeting is displayed only when the
    
    <a id="_idIndexMarker087">
    </a>
    
     user has finished typing.
    
    
     Until then, the message
    
    <strong class="bold">
     
      Introducing...
     
    </strong>
    
     is generated.
    
    
     That way, we provide a clear indicator of UI interactivity
    
    
     
      and progress.
     
    
   </p>
   <h2 id="_idParaDest-76">
    <a id="_idTextAnchor076">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     It’s important to know that Blazor allows you to intercept all event arguments.
    
    
     You can accomplish this by adding a parameter that matches the event argument type corresponding to the
    
    
     
      triggered event.
     
    
   </p>
   <p>
    
     For instance, let’s consider
    
    <strong class="source-inline">
     
      DragEventArgs
     
    </strong>
    
     .
    
    
     When a user is dragging elements into or within your application, you can intercept cursor positions and any active
    
    
     
      keyboard combinations.
     
    
   </p>
   <p>
    
     Here’s how simple it is to intercept a
    
    
     
      dragging event:
     
    
   </p>
   <pre class="source-code">
public void OnDragging(DragEventArgs args) { /*...*/ }</pre>
   <p>
    
     Similarly, with
    
    <strong class="source-inline">
     
      InputFileChangeEventArgs
     
    </strong>
    
     , you can access the details of the file that the user has uploaded.
    
    
     It also exposes the
    
    <strong class="source-inline">
     
      IBrowserFile
     
    </strong>
    
     object, which you can use to stream the content to
    
    
     
      your servers.
     
    
   </p>
   <p>
    
     Here’s how you can intercept details of a file uploaded by
    
    
     
      a user:
     
    
   </p>
   <pre class="source-code">
public void OnFileInput(InputFileChangeEventArgs args)
{
    var droppedFile = args.File;
    // ...
}</pre>
   <p>
    
     The capability to intercept specific events and details of those actions opens possibilities for more advanced
    
    <a id="_idIndexMarker088">
    </a>
    
     and nuanced event handling in your
    
    
     
      Blazor applications.
     
    
   </p>
   <h1 id="_idParaDest-77">
    <a id="_idTextAnchor077">
    </a>
    
     Performing asynchronous actions after binding
    
   </h1>
   <p>
    
     Asynchronous
    
    <a id="_idIndexMarker089">
    </a>
    
     actions are pivotal in modern web
    
    <a id="_idIndexMarker090">
    </a>
    
     applications, especially when dealing with data-intensive operations such as fetching data from
    
    <a id="_idIndexMarker091">
    </a>
    
     an
    
    <strong class="bold">
     
      API
     
    </strong>
    
     or database.
    
    
     It’s also crucial that your application remains responsive as it’s executing a long-running task.
    
    
     In this recipe, I’ll guide you through data binding when working with asynchronous tasks.
    
    
     You will learn how to integrate asynchronous actions, allowing non-blocking UI updates and smoother
    
    
     
      user experiences.
     
    
   </p>
   <p>
    
     Let’s enable an
    
    <strong class="bold">
     
      auto-complete
     
    </strong>
    
     feature on a
    
    <a id="_idIndexMarker092">
    </a>
    
     simple input field and generate a list of suggestions as the user types
    
    
     
      their name.
     
    
   </p>
   <h2 id="_idParaDest-78">
    <a id="_idTextAnchor078">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before diving into the auto-complete implementation, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy your
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Binding to a specific DOM event
      
     </em>
     
      recipe or copy its implementation from the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Next to
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      , copy the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory from the GitHub repository, containing the
     
     <strong class="source-inline">
      
       SuggestionsApi
      
     </strong>
     
      class required in
     
     
      
       this recipe
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-79">
    <a id="_idTextAnchor079">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to trigger asynchronous actions after
    
    
     
      data binding:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file of your application and register the
     
     <strong class="source-inline">
      
       SuggestionsApi
      
     </strong>
     
      service to enable communication with
     
     
      
       the API:
      
     
     <pre class="source-code">
builder.Services.AddTransient&lt;SuggestionsApi&gt;();</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component and clean up the section, so only the
     
     <strong class="source-inline">
      
       User
      
     </strong>
     
      variable is
     
     
      
       still there:
      
     
     <pre class="source-code">
@code {
    protected string User = string.Empty;
}</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, inject the
     
     <strong class="source-inline">
      
       SuggestionsApi
      
     </strong>
     
      service and initialize a
     
     <strong class="source-inline">
      
       Suggestions
      
     </strong>
     
      collection that will hold the
     
     
      
       autocomplete results:
      
     
     <pre class="source-code">
[Inject] private SuggestionsApi Api { get; init; }
protected IList&lt;string&gt; Suggestions = [];</pre>
    </li>
    <li>
     
      Still within
     
     <a id="_idIndexMarker093">
     </a>
     
      the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <a id="_idIndexMarker094">
     </a>
     
      new asynchronous
     
     <strong class="source-inline">
      
       AutocompleteAsync()
      
     </strong>
     
      method responsible for calling the API and updating the
     
     <strong class="source-inline">
      
       Suggestions
      
     </strong>
     
      collection based on
     
     
      
       user input:
      
     
     <pre class="source-code">
private async Task AutocompleteAsync()
{
    Suggestions = string.IsNullOrWhiteSpace(User) ?
        [] : await Api.FindAsync(User);
    await InvokeAsync(StateHasChanged);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup, find the
     
     <strong class="source-inline">
      
       input
      
     </strong>
     
      field and replace the
     
     <strong class="source-inline">
      
       @onfocusout
      
     </strong>
     
      assignment with the
     
     <strong class="source-inline">
      
       @bind:after
      
     </strong>
     
      attribute that triggers the
     
     
      <strong class="source-inline">
       
        AutocompleteAsync()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
&lt;input class="form-control w-50" @bind=@User
       @bind:event="oninput"
       @bind:after="@AutocompleteAsync" /&gt;</pre>
    </li>
    <li>
     
      Below
     
     <strong class="source-inline">
      
       input
      
     </strong>
     
      , under the
     
     <strong class="source-inline">
      
       &lt;hr /&gt;
      
     </strong>
     
      separator, clear out the existing greeting and introduction sections and construct a fast-return when suggestions are
     
     
      
       currently unavailable:
      
     
     <pre class="source-code">
&lt;hr /&gt;
@if (!Suggestions.Any()) return;</pre>
    </li>
    <li>
     
      Lastly, at the end of the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup, render the
     
     <strong class="source-inline">
      
       Suggestions
      
     </strong>
     
      collection received from the
     
     
      
       API response.
      
     
     <pre class="source-code">
&lt;h5&gt;Did you mean?&lt;/h5&gt;
@foreach (var name in Suggestions)
{
    &lt;div&gt;@name&lt;/div&gt;
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor080">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we add a
    
    <strong class="source-inline">
     
      SuggestionsApi
     
    </strong>
    
     service to the
    
    <strong class="bold">
     
      dependency injection
     
    </strong>
    
     container of our application.
    
    
     That makes
    
    <strong class="source-inline">
     
      SuggestionsApi
     
    </strong>
    
     readily available for injection across the
    
    <a id="_idIndexMarker095">
    </a>
    
     application, ensuring we can
    
    <a id="_idIndexMarker096">
    </a>
    
     utilize it wherever needed.
    
    
     Similar to other .NET web frameworks, Blazor can manage services with three lifetimes – singleton, scoped,
    
    
     
      and transient:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Singleton
      
     </strong>
     
      services are
     
     <a id="_idIndexMarker097">
     </a>
     
      created once per application and shared across all components
     
     
      
       and requests.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Transient
      
     </strong>
     
      services
     
     <a id="_idIndexMarker098">
     </a>
     
      are created anew each time they are requested, which makes them perfect for lightweight, stateless services (i.e.
     
     
      
       API integrations).
      
     
    </li>
    <li>
     <strong class="bold">
      
       Scoped
      
     </strong>
     
      services are a
     
     <a id="_idIndexMarker099">
     </a>
     
      little trickier.
     
     
      In client-side applications, scoped services generally behave like singleton services because there is no connection context to differentiate sessions.
     
     
      However, that changes when an
     
     <strong class="source-inline">
      
       OwningComponentBase
      
     </strong>
     
      component comes into play.
     
     <strong class="source-inline">
      
       OwningComponentBase
      
     </strong>
     
      is a base class for components ensuring that the component and its dependencies are disposed of gracefully when Blazor destroys the
     
     
      
       component instance.
      
     
    </li>
   </ul>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we move on to the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component and clear out the greeting implementation, so only the
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     variable remains.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we inject
    
    <strong class="source-inline">
     
      SuggestionsApi
     
    </strong>
    
     into our
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component and initialize a
    
    <strong class="source-inline">
     
      Suggestions
     
    </strong>
    
     collection to store the results from calls we make to the API.
    
    
     Moving on to
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     asynchronous method, playing a crucial role in simplifying the logic within the markup.
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     checks whether the user has entered any input and calls the API’s
    
    <strong class="source-inline">
     
      FindAsync()
     
    </strong>
    
     method to fetch suggestions; otherwise, it short-circuits the operation, returning an
    
    
     
      empty array.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we enhance the markup of
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     .
    
    
     We refine the binding logic on the input field, by removing the
    
    <strong class="source-inline">
     
      @onfocusout
     
    </strong>
    
     event and replacing it with the
    
    <strong class="source-inline">
     
      @bind:after
     
    </strong>
    
     directive, which invokes the
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     method immediately after the binding completes.
    
    
     With this setup, we ensure that a new set of auto-suggestions is requested from the API each time the user modifies the input.
    
    
     Finally, in
    
    <em class="italic">
     
      step 6
     
    </em>
    
     and
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we introduce additional markup to display the results of the auto-complete operation.
    
    
     We render a list of found names, starting with the same set of characters that
    
    <a id="_idIndexMarker100">
    </a>
    
     the user entered, if the API
    
    
     
      returns any.
     
    
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor081">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In our example, we utilized the
    
    <strong class="source-inline">
     
      [Inject]
     
    </strong>
    
     attribute to inject
    
    <strong class="source-inline">
     
      SuggestionsApi
     
    </strong>
    
     into a component.
    
    
     However, Blazor provides additional methods for service injection.
    
    
     Let’s review all
    
    
     
      of them:
     
    
   </p>
   <ul>
    <li>
     
      You will commonly use the
     
     <strong class="source-inline">
      
       [Inject]
      
     </strong>
     
      attribute when injecting services within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of a
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        razor
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
@code {
    [Inject] private SuggestionsApi Api { get; init; }
}</pre>
    </li>
    <li>
     
      You would also use the
     
     <strong class="source-inline">
      
       [Inject]
      
     </strong>
     
      attribute if you were adopting a code-behind approach, where you separate your Blazor component’s logic in a
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        cs
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
public partial class IntroduceYourself
{
    [Inject] private SuggestionsApi Api { get; init; }
}</pre>
    </li>
    <li>
     
      When working in a code-behind fashion, you can also leverage a
     
     <strong class="bold">
      
       constructor injection
      
     </strong>
     
      pattern
     
     <a id="_idIndexMarker101">
     </a>
     
      and avoid using any attributes
     
     
      
       at all:
      
     
     <pre class="source-code">
public partial class IntroduceYourself(
    SuggestionsApi Api) { }</pre>
    </li>
    <li>
     
      Lastly, Blazor allows injecting services directly within the component’s markup – in that case, you would use the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        inject
       
      </strong>
     
     
      
       directive:
      
     
     <pre class="source-code">
@page "/ch02r01"
@inject SuggestionsApi Api</pre>
    </li>
   </ul>
   <p>
    
     All those methods serve the same purpose but accommodate various coding styles and preferences.
    
    
     None is
    
    <a id="_idIndexMarker102">
    </a>
    
     better than the other, so choose what best fits the structure and organization of your
    
    
     
      code base.
     
    
   </p>
   <h1 id="_idParaDest-82">
    <a id="_idTextAnchor082">
    </a>
    
     Customizing get and set binding logic
    
   </h1>
   <p>
    
     Data binding is
    
    <a id="_idIndexMarker103">
    </a>
    
     not just about connecting a UI element to a data source.
    
    
     It’s also about how data is retrieved and updated.
    
    
     Customizing these
    
    <strong class="source-inline">
     
      get
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     operations makes state management and data flow more flexible.
    
    
     In this recipe, I’ll guide you through the caveats of using
    
    <strong class="source-inline">
     
      get
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     explicitly and executing asynchronous logic when setting values.
    
    
     These mechanisms will allow you to simplify your code and take even greater control of the interactivity of your
    
    
     
      Blazor application.
     
    
   </p>
   <p>
    
     Let’s implement a simple text field with explicit
    
    <strong class="source-inline">
     
      get
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     operations so we can execute additional, asynchronous logic as binding
    
    
     
      is commencing.
     
    
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor083">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     This time, we will take a shortcut with preparations for this
    
    
     
      upcoming recipe:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy your
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Performing asynchronous actions after binding
      
     </em>
     
      recipe or copy its implementation from the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Next to
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      , copy the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory from the GitHub repository, containing the objects required in
     
     
      
       this recipe
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor084">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To customize
    
    <strong class="source-inline">
     
      get
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     binding logic, follow
    
    
     
      these instructions:
     
    
   </p>
   <ol>
    <li>
     
      Locate the
     
     <strong class="source-inline">
      
       input
      
     </strong>
     
      field within the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component’s markup.
     
     
      Keep the
     
     <strong class="source-inline">
      
       @bind:event
      
     </strong>
     
      directive but replace others with custom
     
     <strong class="source-inline">
      
       @bind:get
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        bind:set
       
      </strong>
     
     
      
       logic:
      
     
     <pre class="source-code">
&lt;input class="form-control w-50" @bind:event="oninput"
       @bind:get="@User"
       @bind:set="@AutocompleteAsync" /&gt;</pre>
    </li>
    <li>
     
      Navigate
     
     <a id="_idIndexMarker104">
     </a>
     
      to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      and adapt the
     
     <strong class="source-inline">
      
       AutocompleteAsync()
      
     </strong>
     
      method to align with a setter pattern, enforced by the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        bind:set
       
      </strong>
     
     
      
       directive:
      
     
     <pre class="source-code">
private async Task AutocompleteAsync(string value)
{
    User = value;
    Suggestions = string.IsNullOrWhiteSpace(User) ?
        [] : await Api.FindAsync(User);
    await InvokeAsync(StateHasChanged);
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-85">
    <a id="_idTextAnchor085">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we update the binding logic on the
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     field.
    
    
     We keep the
    
    <strong class="source-inline">
     
      oninput
     
    </strong>
    
     event because we want our methods to execute as the user types but we replace the other directives with
    
    <strong class="source-inline">
     
      @bind:get
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      @bind:set
     
    </strong>
    
     .
    
    
     We use
    
    <strong class="source-inline">
     
      @bind:get
     
    </strong>
    
     to specify where Blazor should retrieve the input value from – which in our case is just a reference to the
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     variable.
    
    
     With the
    
    <strong class="source-inline">
     
      @bind:set
     
    </strong>
    
     directive, we define the logic to execute when Blazor binds the input value to the component’s state.
    
    
     That’s when we trigger the
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     method.
    
    
     At this point, your IDE should highlight a
    
    
     
      compilation error.
     
    
   </p>
   <p>
    
     Typically, a
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     method
    
    <a id="_idIndexMarker105">
    </a>
    
     in C# receives a
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     object
    
    
     
      by default:
     
    
   </p>
   <pre class="source-code">
private string _userName;
public string UserName
{
    get =&gt; _userName;
    set =&gt; _userName = value;
}</pre>
   <p>
    
     In Blazor, the method used for
    
    <strong class="source-inline">
     
      @bind:set
     
    </strong>
    
     must follow a similar pattern.
    
    
     The difference is that we can define the name of the incoming
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     object, offering greater control and clarity.
    
    
     So, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we extend
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     by adding a
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     parameter and keeping it in line with the conventional
    
    <strong class="source-inline">
     
      get
     
    </strong>
    
     -
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     pattern.
    
    
     Pay extra attention to the parameter type consistency.
    
    
     Since we bound
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     object of type
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     , the
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     method also expects a string.
    
    
     If, for instance, you were binding to an
    
    <strong class="source-inline">
     
      Age
     
    </strong>
    
     variable of type
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     , your binding method would need to accept an
    
    
     <strong class="source-inline">
      
       int
      
     </strong>
    
    
     
      parameter.
     
    
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor086">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     So why do
    
    <strong class="source-inline">
     
      @bind:after
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      @bind:set
     
    </strong>
    
     both exist if they do virtually the same thing?
    
    
     The execution time of each event is critical.
    
    
     When you need to execute additional logic, often asynchronous, using the default binding operation,
    
    <strong class="source-inline">
     
      @bind:after
     
    </strong>
    
     , should be your choice as it spares you the complexity of persisting the incoming value manually.
    
    
     On the other hand,
    
    <strong class="source-inline">
     
      @bind:set
     
    </strong>
    
     provides more flexibility as it’s executed upon setting the binding value.
    
    
     It enables the integration of validation logic, including asynchronous operations, into the binding process.
    
    
     Crucially,
    
    <strong class="source-inline">
     
      @bind:set
     
    </strong>
    
     allows you to assess the incoming value and, based on the outcome of any validation, decide whether to discard or accept it before it
    
    <a id="_idIndexMarker106">
    </a>
    
     becomes part of the component state.
    
    
     Both features are invaluable for ensuring data integrity and implementing sophisticated validation mechanisms in your
    
    
     
      Blazor applications.
     
    
   </p>
   <h1 id="_idParaDest-87">
    <a id="_idTextAnchor087">
    </a>
    
     Simplifying binding with the bind-Value pattern
    
   </h1>
   <p>
    
     The
    
    <strong class="source-inline">
     
      bind-Value
     
    </strong>
    
     pattern
    
    <a id="_idIndexMarker107">
    </a>
    
     is a game-changer
    
    <a id="_idIndexMarker108">
    </a>
    
     in simplifying the linking process of your UI elements to data properties.
    
    
     It enhances the clarity and conciseness of your code by reducing the boilerplate often associated with handling two-way data binding.
    
    
     In this recipe, I will guide you through a practical example, showcasing the pattern’s utility in creating more maintainable and simple code, ultimately enhancing your
    
    
     
      development workflow.
     
    
   </p>
   <p>
    
     Let’s implement a component that allows binding directly to its parameters in a structure similar to the standard binding to
    
    
     
      HTML elements.
     
    
   </p>
   <h2 id="_idParaDest-88">
    <a id="_idTextAnchor088">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we start implementing a component that enables the
    
    <strong class="source-inline">
     
      bind-Value
     
    </strong>
    
     pattern, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Next to
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      , copy the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory from the GitHub repository, containing
     
     <strong class="source-inline">
      
       SkillLevel
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       DataSeed
      
     </strong>
     
      , required in
     
     
      
       this recipe
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-89">
    <a id="_idTextAnchor089">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to apply the
    
    <strong class="source-inline">
     
      bind-Value
     
    </strong>
    
     
      binding pattern:
     
    
   </p>
   <ol>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       IntroductionForm
      
     </strong>
     
      component and add the required assembly reference at
     
     
      
       the top:
      
     
     <pre class="source-code">
@using BlazorCookbook.App.Client.Chapters.Chapter02.Data</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       IntroductionForm
      
     </strong>
     
      , declare a
     
     <strong class="source-inline">
      
       string
      
     </strong>
     
      parameter for
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      .
     
     
      Alongside it, add
     
     <strong class="source-inline">
      
       EventCallback&lt;string&gt;
      
     </strong>
     
      to communicate changes to the
     
     
      <strong class="source-inline">
       
        Name
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
[Parameter]
public string Name { get; set; }
[Parameter]
public EventCallback&lt;string&gt; NameChanged { get; set; }</pre>
    </li>
    <li>
     
      Similarly, right below
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       NameChanged
      
     </strong>
     
      , add a
     
     <strong class="source-inline">
      
       Skill
      
     </strong>
     
      and an
     
     <strong class="source-inline">
      
       EventCallback&lt;SkillLevel&gt;
      
     </strong>
     
      parameters to manage the skill
     
     
      
       level state:
      
     
     <pre class="source-code">
[Parameter]
public SkillLevel Skill { get; set; }
[Parameter]
public EventCallback&lt;SkillLevel&gt; SkillChanged { get; set; }</pre>
    </li>
    <li>
     
      Still within
     
     <a id="_idIndexMarker109">
     </a>
     
      the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement
     
     <a id="_idIndexMarker110">
     </a>
     
      a method invoking the
     
     <strong class="source-inline">
      
       NameChanged
      
     </strong>
     
      callback and propagating changes to the
     
     
      <strong class="source-inline">
       
        Name
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
private Task OnNameChanged()
    =&gt; NameChanged.InvokeAsync(Name);</pre>
    </li>
    <li>
     
      Lastly, complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block with another method, handling changes of the
     
     <strong class="source-inline">
      
       Skill
      
     </strong>
     
      value, that retrieves the
     
     <strong class="source-inline">
      
       ChangeEventArgs
      
     </strong>
     
      parameter and sets the skill level based on the resolved value and underlying
     
     <strong class="source-inline">
      
       DataSeed.SkillLevels
      
     </strong>
     
      
       data source:
      
     
     <pre class="source-code">
private Task OnSkillChanged(ChangeEventArgs args)
{
    var id = int.Parse(args.Value.ToString());
    var skill = DataSeed.SkillLevels
        .SingleOrDefault (it =&gt; it.Id == id);
    return SkillChanged.InvokeAsync(skill);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       IntroductionForm
      
     </strong>
     
      markup, below
     
     <strong class="source-inline">
      
       @using
      
     </strong>
     
      , add a section where the user can input their name.
     
     
      Declare the binding to occur on the
     
     <strong class="source-inline">
      
       oninput
      
     </strong>
     
      event and set it to trigger the
     
     <strong class="source-inline">
      
       OnNameChanged
      
     </strong>
     
      method after the binding
     
     
      
       is complete:
      
     
     <pre class="source-code">
&lt;h5&gt;What's your name?&lt;/h5&gt;
&lt;input class="form-control w-50 mb-1" @bind="@Name"
       @bind:event="oninput"
       @bind:after=@OnNameChanged /&gt;</pre>
    </li>
    <li>
     
      Add another
     
     <a id="_idIndexMarker111">
     </a>
     
      markup
     
     <a id="_idIndexMarker112">
     </a>
     
      section below allowing you to select the user’s skill level.
     
     
      Utilize the
     
     <strong class="source-inline">
      
       DataSeed.SkillLevels
      
     </strong>
     
      data source to populate the selection options and ensure that the binding of selection changes occurs with the
     
     
      <strong class="source-inline">
       
        onchange
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
&lt;h5&gt;What's your skill level?&lt;/h5&gt;
&lt;select class="form-control w-50 mb-1"
        @onchange="@OnSkillChanged"&gt;
    &lt;option value="0"&gt;-&lt;/option&gt;
    @foreach (var level in DataSeed.SkillLevels)
    {
        &lt;option value="@level.Id"&gt;
            @level.Title
        &lt;/option&gt;
    }
&lt;/select&gt;</pre>
    </li>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      routable component, rendering in an
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      mode, and reference the data
     
     
      
       objects assembly:
      
     
     <pre class="source-code">
@using BlazorCookbook.App.Client.Chapters.Chapter02.Data
@page "/ch02r05"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, initialize
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Skill
      
     </strong>
     
      variables to capture the user input and generate
     
     
      
       the greeting:
      
     
     <pre class="source-code">
protected string Name { get; set; }
protected SkillLevel Skill { get; set; }</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement an
     
     <strong class="source-inline">
      
       IsGreetingReady
      
     </strong>
     
      method, allowing you to
     
     <a id="_idIndexMarker113">
     </a>
     
      check
     
     <a id="_idIndexMarker114">
     </a>
     
      whether the greeting is ready
     
     
      
       to render:
      
     
     <pre class="source-code">
private bool IsGreetingReady
    =&gt; !string.IsNullOrWhiteSpace(Name)
    &amp;&amp; Skill is not null;</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup, embed
     
     <strong class="source-inline">
      
       IntroductionForm
      
     </strong>
     
      and leverage the
     
     <strong class="source-inline">
      
       bind-Value
      
     </strong>
     
      pattern to dynamically bind the
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Skill
      
     </strong>
     
      parameters to the corresponding
     
     
      
       target variables:
      
     
     <pre class="source-code">
&lt;IntroductionForm @bind-Name="@Name"
                  @bind-Skill="@Skill" /&gt;</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup by adding a section separator and conditional rendering of the user greeting, when
     
     
      
       it’s ready:
      
     
     <pre class="source-code">
&lt;hr /&gt;
@if (!IsGreetingReady) return;
&lt;h5&gt;Welcome @Name on level @Skill.Title!&lt;/h5&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-90">
    <a id="_idTextAnchor090">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create an
    
    <strong class="source-inline">
     
      IntroductionForm
     
    </strong>
    
     component and reference the assembly with sample data at the top.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we define a pair of parameters of type
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      EventCallback&lt;string&gt;
     
    </strong>
    
     , that we will bind to the form, and we intentionally call them
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      NameChanged
     
    </strong>
    
     respectively.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we add a similar pair to handle the skill level and name them
    
    <strong class="source-inline">
     
      Skill
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      SkillChanged
     
    </strong>
    
     respectively.
    
    
     The pairing of a value of type
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     and a matching
    
    <strong class="source-inline">
     
      EventCallback&lt;T&gt;
     
    </strong>
    
     handler forms the basis of the
    
    <strong class="source-inline">
     
      bind-Value
     
    </strong>
    
     pattern.
    
    
     Similar to recognizing
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     implicitly, when working with
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     , Blazor’s code generators recognize
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      EventCallback&lt;T&gt;
     
    </strong>
    
     and compile the
    
    <strong class="source-inline">
     
      @bind-Value
     
    </strong>
    
     directive.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we declare an
    
    <strong class="source-inline">
     
      OnNameChanged()
     
    </strong>
    
     method to invoke the intended
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     and propagate the changes in
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     .
    
    
     To handle value changes of the
    
    <strong class="source-inline">
     
      Skill
     
    </strong>
    
     parameter, we implement a bit
    
    <a id="_idIndexMarker115">
    </a>
    
     more
    
    <a id="_idIndexMarker116">
    </a>
    
     complex logic in
    
    <em class="italic">
     
      step 5
     
    </em>
    
     .
    
    
     We intercept a
    
    <strong class="source-inline">
     
      ChangeEventArgs
     
    </strong>
    
     object that carries the selected option’s value, which we use to retrieve the corresponding
    
    <strong class="source-inline">
     
      SkillLevel
     
    </strong>
    
     object from the
    
    <strong class="source-inline">
     
      DataSeed.SkillLevels
     
    </strong>
    
     collection.
    
    
     We then pass this value to the intended
    
    
     <strong class="source-inline">
      
       EventCallback
      
     </strong>
    
    
     
      handler.
     
    
   </p>
   <p>
    
     With the logic in place, in
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we proceed to the
    
    <strong class="source-inline">
     
      IntroductionForm
     
    </strong>
    
     markup.
    
    
     We add a simple
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     field and bind it to the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     parameter.
    
    
     We also hook up the
    
    <strong class="source-inline">
     
      OnNameChanged()
     
    </strong>
    
     method, so it’s triggered after the binding completes.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we construct a
    
    <strong class="source-inline">
     
      select
     
    </strong>
    
     field to allow the user to choose their skill level.
    
    
     We render a neutral option, displaying
    
    <strong class="bold">
     
      -
     
    </strong>
    
     , and skill options from the
    
    <strong class="source-inline">
     
      DataSeed.SkillLevels
     
    </strong>
    
     collection.
    
    
     We wire the
    
    <strong class="source-inline">
     
      @onchanged
     
    </strong>
    
     event of the
    
    <strong class="source-inline">
     
      select
     
    </strong>
    
     field to the
    
    
     <strong class="source-inline">
      
       OnSkillChanged()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component that renders in an
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode.
    
    
     We also reference the sample data assembly, leveraging the
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we initialize a
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block within the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component and declare
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Skill
     
    </strong>
    
     backing properties for binding and generating the user’s greeting.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we implement a simple
    
    <strong class="source-inline">
     
      IsGreetingReady
     
    </strong>
    
     method that checks whether both
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Skill
     
    </strong>
    
     have meaningful values and a greeting can be
    
    
     
      safely generated.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     markup and witness the
    
    <strong class="source-inline">
     
      bind-Value
     
    </strong>
    
     pattern in action.
    
    
     Since
    
    <strong class="source-inline">
     
      IntroductionForm
     
    </strong>
    
     exposes
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Skill
     
    </strong>
    
     parameters with pattern-matching event callbacks, we can dynamically bind them using
    
    <strong class="source-inline">
     
      @bind-Name
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      @bind-Skill
     
    </strong>
    
     .
    
    
     Your IDE will recognize this pattern automatically and should even suggest these directives.
    
    
     We finalize the markup in
    
    <em class="italic">
     
      step 12
     
    </em>
    
     by adding a conditional rendering of a greeting message built from the current
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       Skill
      
     </strong>
    
    
     
      values.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      bind-Value
     
    </strong>
    
     pattern encapsulates binding logic and validation within a component, greatly simplifying unit testing and enhancing the parent component’s cleanliness and robustness.
    
    
     It only requires the parent component to provide backing variables, streamlining the development process.
    
    
     It’s even more powerful as all the binding directives
    
    <a id="_idIndexMarker117">
    </a>
    
     that
    
    <a id="_idIndexMarker118">
    </a>
    
     we’ve covered (
    
    <strong class="source-inline">
     
      @bind:after
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      @bind:get
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      @bind:set
     
    </strong>
    
     ), you can also pair with the
    
    
     <strong class="source-inline">
      
       bind-Value
      
     </strong>
    
    
     
      pattern.
     
    
   </p>
   <h1 id="_idParaDest-91">
    <a id="_idTextAnchor091">
    </a>
    
     Binding with an external data provider
    
   </h1>
   <p>
    
     When building web
    
    <a id="_idIndexMarker119">
    </a>
    
     applications that interact with external data
    
    <a id="_idIndexMarker120">
    </a>
    
     sources, it’s common to trigger API calls in response to user input.
    
    
     However, this can lead to a flood of requests, straining the API and degrading the user’s experience.
    
    
     To address that challenge, we’ll implement input
    
    <strong class="bold">
     
      throttling
     
    </strong>
    
     – a technique that moderates the rate at which requests are sent based on user input.
    
    
     In this recipe, I will guide you through setting up input throttling in a Blazor component, ensuring efficient and responsible usage of external APIs.
    
    
     You’ll create more robust and user-friendly applications capable of handling a heavy load of user interactions without overwhelming your
    
    
     
      data providers.
     
    
   </p>
   <p>
    
     Let’s implement a simple text field that uses throttling to limit calls to the external API and seamlessly waits for a user to
    
    
     
      finish typing.
     
    
   </p>
   <h2 id="_idParaDest-92">
    <a id="_idTextAnchor092">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into throttling implementation, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Next to
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      , copy the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory from the GitHub repository, containing a
     
     <strong class="source-inline">
      
       SuggestionsApi
      
     </strong>
     
      class required in
     
     
      
       this recipe
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component from the
     
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-93">
    <a id="_idTextAnchor093">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To implement throttling when calling an external API, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file of your application and register the
     
     <strong class="source-inline">
      
       SuggestionsApi
      
     </strong>
     
      service to enable communication with
     
     
      
       the API:
      
     
     <pre class="source-code">
builder.Services.AddTransient&lt;SuggestionsApi&gt;();</pre>
    </li>
    <li>
     
      Enhance
     
     <a id="_idIndexMarker121">
     </a>
     
      the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component with the implementation of the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      interface
     
     <a id="_idIndexMarker122">
     </a>
     
      using the
     
     <strong class="source-inline">
      
       @implements
      
     </strong>
     
      directive, below the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        rendermode
       
      </strong>
     
     
      
       directive:
      
     
     <pre class="source-code">
@rendermode InteractiveWebAssembly
@implements IDisposable</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      component, declare the
     
     <strong class="source-inline">
      
       Timer
      
     </strong>
     
      variable and two
     
     <strong class="source-inline">
      
       TimeSpan
      
     </strong>
     
      variables – for throttling and
     
     
      
       overall timeout:
      
     
     <pre class="source-code">
private Timer _debounceTimer;
private readonly TimeSpan
    _throttle = TimeSpan.FromMilliseconds(500),
    _timeout = TimeSpan.FromMinutes(1);</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement an
     
     <strong class="source-inline">
      
       OnUserInput()
      
     </strong>
     
      method with a proxy logic that uses the
     
     <strong class="source-inline">
      
       Timer
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TimeSpan
      
     </strong>
     
      variables to throttle the API requests encapsulated inside the
     
     
      <strong class="source-inline">
       
        AutocompleteAsync()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
private void OnUserInput()
{
    _debounceTimer?.Dispose();
    _debounceTimer = new Timer(
        _ =&gt; InvokeAsync(AutocompleteAsync),
        null, _throttle, _timeout);
}</pre>
    </li>
    <li>
     
      To complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement the
     
     <strong class="source-inline">
      
       Dispose()
      
     </strong>
     
      lifecycle method, required by the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      interface, and explicitly dispose of the
     
     
      <strong class="source-inline">
       
        _debounceTimer
       
      </strong>
     
     
      
       instance:
      
     
     <pre class="source-code">
public void Dispose() =&gt; _debounceTimer?.Dispose();</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       IntroduceYourself
      
     </strong>
     
      markup, update the
     
     <strong class="source-inline">
      
       @bind:after
      
     </strong>
     
      directive to invoke the
     
     <strong class="source-inline">
      
       OnUserInput()
      
     </strong>
     
      method, where we’ve added the
     
     
      
       throttling logic:
      
     
     <pre class="source-code">
&lt;input class="form-control w-50" @bind=@User
       @bind:event="oninput"
       @bind:after="@OnUserInput" /&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-94">
    <a id="_idTextAnchor094">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we
    
    <a id="_idIndexMarker123">
    </a>
    
     register
    
    <a id="_idIndexMarker124">
    </a>
    
     the
    
    <strong class="source-inline">
     
      SuggestionsApi
     
    </strong>
    
     service in the application’s dependency injection container.
    
    
     If you’re following along with the entire chapter, you might already have
    
    
     <strong class="source-inline">
      
       SuggestionsApi
      
     </strong>
    
    
     
      there.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , with the help of the
    
    <strong class="source-inline">
     
      @implements
     
    </strong>
    
     directive, we enhance the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component with an
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     pattern.
    
    
     In Blazor, the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface is used to release unmanaged resources or detach event handlers when disposing of a component.
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     requires the implementation of a
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method, which Blazor will then automatically invoke when a component is removed from the UI, ensuring proper cleanup and preventing memory leaks.
    
    
     Without the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method in place, your IDE will highlight compilation errors.
    
    
     We will address that in
    
    
     
      subsequent steps.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we lay the groundwork for throttling logic.
    
    
     In the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     component, we initialize two key variables:
    
    <strong class="source-inline">
     
      _throttle
     
    </strong>
    
     , which defines the idle time (500 milliseconds in our example) between user interactions and API calls, and
    
    <strong class="source-inline">
     
      _timeout
     
    </strong>
    
     , which sets an overall timeout for the external communication.
    
    
     We also declare a
    
    <strong class="source-inline">
     
      _debounceTimer
     
    </strong>
    
     variable of type
    
    <strong class="source-inline">
     
      Timer
     
    </strong>
    
     , which is the backbone of managing the frequency of API calls.
    
    
     The
    
    <strong class="source-inline">
     
      Timer
     
    </strong>
    
     class wraps a scheduler that delays the execution of a method for a specified time, making it ideal for throttling.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , still within the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, we implement an
    
    <strong class="source-inline">
     
      OnUserInput()
     
    </strong>
    
     method with throttling proxy logic.
    
    
     First, we stop the currently scheduled operation, by disposing of the
    
    <strong class="source-inline">
     
      _debounceTimer
     
    </strong>
    
     instance, to avoid any overlapping executions.
    
    
     Next, we instantiate a
    
    <a id="_idIndexMarker125">
    </a>
    
     new
    
    <strong class="source-inline">
     
      Timer
     
    </strong>
    
     object, wrapping the existing
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     method
    
    <a id="_idIndexMarker126">
    </a>
    
     within the
    
    <strong class="source-inline">
     
      InvokeAsync()
     
    </strong>
    
     method for thread safety.
    
    
     As we don’t need to maintain any state between timer invocations, we pass
    
    <strong class="source-inline">
     
      null
     
    </strong>
    
     for the state object and complete the
    
    <strong class="source-inline">
     
      _debounceTimer
     
    </strong>
    
     initialization with the
    
    <strong class="source-inline">
     
      _throttle
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      _timeout
     
    </strong>
    
     variables.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block by implementing the missing
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method to gracefully dispose of the
    
    <strong class="source-inline">
     
      _debounceTimer
     
    </strong>
    
     instance.
    
    
     The compilation errors should now
    
    
     
      be gone.
     
    
   </p>
   <p>
    
     Lastly, in
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we slightly update the
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     field in the
    
    <strong class="source-inline">
     
      IntroduceYourself
     
    </strong>
    
     markup.
    
    
     Rather than invoking
    
    <strong class="source-inline">
     
      AutocompleteAsync()
     
    </strong>
    
     after the binding completes, we update the
    
    <strong class="source-inline">
     
      @bind:after
     
    </strong>
    
     attribute to invoke the
    
    <strong class="source-inline">
     
      OnUserInput()
     
    </strong>
    
     method, containing our throttling logic.
    
    
     Now, every keystroke goes through the throttling mechanism, optimizing application responsiveness and reducing the load on the
    
    
     
      external API.
     
    
   </p>
  </div>
 </body></html>