- en: Logging and Health Checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the essential aspects of building web services is logging and health
    checks. Nowadays, it is preferred to have services with a small scope. This kind
    of approach provides enormous benefits, but it makes it hard for us to verify
    whether a service behaves in the right way. Logging helps us to track the actions
    and the information processed by the web service on the other side, the health
    check mechanisms provide a way to verify that the service is healthy and all the
    required dependencies are satisfied. The chapter goes through some of the logging
    parts of ASP.NET Core, and it shows how to implement health checks using the tools
    provided by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing logging providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom logging in tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web service health check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start this chapter by providing an overview of the different logging
    components of ASP.NET Core. The framework provides different interfaces that support
    logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ILoggerProvider` is used to define a specific type of logging bind with an
    output channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ILoggerFactory` takes an `ILoggerProvider` interface and initializes it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ILogger` interface is a particular instance of the logging component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The logging interface structure of ASP.NET Core can be described using the
    following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86e0d6bc-3ac4-474f-bda7-eb95785ea19f.png)'
  prefs: []
  type: TYPE_IMG
- en: In short, the `ILoggerProvider` interface represents the output of the logs,
    `ILoggerFactory` creates the right type of instance, and `ILogger` is the actual
    instance of the logger.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of approach guarantees secure isolation between the `ILogger` interface
    consumer and the logging provider part. Furthermore, we may choose to add the
    calls to the `ILogger` interface in the development phase; then, during the release
    phase, we can decide which provider to use to output our logging data. Moreover,
    our logging code becomes very flexible, and we can change the output based on
    the type of environment our service runs in. Let's proceed by learning about the
    different characteristics of the logging system of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: The key characteristics of logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ASP.NET Core logging system is characterized by some key attributes that
    are always present in each log record. Furthermore, it is essential to keep logs
    as coherent as possible. The crucial components of the ASP.NET Core logging system
    are the *log category*, the *log level*, the *log event id*, and the *log message*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *log category* is specified when the `ILogger<T>` interface is initialized.
    It is an essential part of the logging process because it identifies the component
    that is emitting the log record. The *log category* usually corresponds to the
    type or class that''s firing the log records. Let''s use the `ItemController`
    class of the catalog service as an example. The *log category* is defined during
    the `ILogger` interface injection process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `ItemController` class uses the widespread technique of constructor injection
    to initialize the `ILogger<ItemController>` type. Therefore, the log category
    is implicitly defined in the signature of the `_logger` property. Although the
    *log category* helps us identify which component is firing that specific log message,
    we also need to define the importance of that message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *log level* provides information that indicates the severity or importance
    of the log record. ASP.NET Core provides a helpful extension method that offers
    some abstraction over the log level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these methods is an abstraction that''s provided by the `Microsoft.Extensions.Logging`
    namespace. For example, if we examine the `_logger.LogInformation` method implementation,
    under the hood, it merely calls the generic `logger.Log` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LogInformation` extension method wraps the `logger.Log` method calls by
    implicitly defining the level of information provided by the framework. The `LogLevel`
    attribute is an `enum` structure that''s exposed by the `Microsoft.Extension.Logging`
    namespace, which provides the following out of the box logging levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code describes the different log levels that are provided by the
    `LogLevel` enumerator. The log levels go from `Trace`, which describes detailed
    information about the system, to the `Critical` level, which means that the service
    is unable to work correctly and is shutting down. The `LogLevel` attribute is
    essential because it is usually used to filter the log messages which tells us
    of the priority of a logging message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve identified the level of severity of a specific log message, we
    need to provide the *log event id*, which helps us identify a specific event in
    the logging output. While the *log category* usually represents the full path
    of the class, the *log event id* is useful if we wish to express the method that
    is currently generating the logging output. Let''s use the action methods contained
    in the `ItemController` class as an example (`Get`, `GetById`, `Create`, `Update`,
    and `Delete`). It is possible to create a log event class that maps each action
    method to a specific event id:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we can pass the corresponding log event id when we call the `ILogger`
    interface in an action method of the `ItemController` class. By doing this, it
    is possible to identify and group events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, another essential part of logging records is the message associated
    with the log record. The logging system of ASP.NET Core also provides a templating
    system that''s analogous to the C# string interpolation feature. Therefore, it
    is possible to use the templating system in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code logs a message about *information* severity using the `LoggingEvents.GetById`
    event id and adds the message `"GetById {id} "`. Now that we have looked at the
    different logging characteristics provided by ASP.NET Core, we will look at a
    concrete implementation that's been applied to the *catalog service* project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the logging part
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to perform logging in the *catalog web service*.
    Let''s start by choosing a layer where we''ll execute the logging statements.
    Since the logic is encapsulated in the `Catalog.Domain` layer project, we will
    continue by implementing the logging part on the service classes defined in the
    project. First of all, let''s start by defining a new logging class, which contains
    the corresponding *event id* for each operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have established a corresponding *log event id* for each activity,
    we need to define the logging messages that will be used by the `ILogger` interface.
    For now, we can determine the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one refers to the number of records affected by a change, while the
    second is the entity that''s been changed. Finally, the third one provides a message
    for the target entity of the handler. It is essential to note that both constants
    follow a naming convention: the first part of their name refers to the content
    of the message; after the first underscore, we have the parameters that will be
    replaced by values when we use the logging templating system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can proceed by changing the `IItemService` methods by implementing
    logging. Let''s start with the `AddItemAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code tracks the information about the number of affected records
    and the id of the added record. We can do the same with the other methods of the
    `ItemService` class. In the case of read-only operations, we can add the id of
    the target record; for example, in the case of the `GetItemAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code logs the information related to the id that was retrieved
    by the service by using the `Event.GetById` field. It uses the `Messages` type
    to specify the event message. In the next section, we will learn how to log exceptions
    by enhancing the exception handling implementation of logs.
  prefs: []
  type: TYPE_NORMAL
- en: Exception logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if part of the service throws an exception? Handling exceptions is a crucial
    part of the development process of services. As we saw in [Chapter 7](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml),
    *Filter Pipeline*, it is possible to use them to catch exceptions using a filter.
    Filters are one of the crucial parts of the MVC stack: they act before and after
    action methods, and they can be used to log exceptions in a single implementation.
    Let''s have a look at `JsonExceptionAttribute` in `Catalog.API`again*:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The class tracks and returns exceptions using the analog pattern, which can
    be seen in the implementation of the handler: the `ILogger<T>` interface is injected
    into the constructor using dependency injection and the `_logger.LogError` method.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to verify logging in our test using `Moq`.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying logging using Moq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s learn how to verify our implemented logging. The dependency injection
    system of the `ILogger` interface helps us to mock the logging mechanism and validate
    the resulting implementation. It is essential to note that our handlers are using
    the extension methods of the `ILogger` interface. Let''s use the ASP.NET Core
    implementation of the `LogInformation` extension method in the `Microsoft.Extensions.Logging`
    namespace as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods are *not* a mock-oriented construct. They are static methods
    and, by definition, it is not possible to mock a static construct in C#'s runtime.
    Thus, we need to provide an *abstraction* over the `ILogger` factory that allows
    us to inject and mock the interface that's used in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it isn't possible to test static methods. Moreover, mock libraries
    typically create mocks by dynamically creating classes at runtime. Typically,
    they override the behavior of types by extending them. Since the static methods
    cannot be overridden, it isn't possible to mock them. Therefore, when we need
    to mock a static element, it is suggested that we abstract them and encapsulate
    them into classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the declaration of the `LoggerAbstraction` class in the `Catalog.Fixture`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`LoggerAbstraction` is a generic class that implements the `ILogger<T>` interface.
    More specifically, the abstract class defines the `Log<TState>` method by executing
    an overloaded version of the `void Log` method. Both the `Log` method and the
    `LoggerAbstraction` class are abstract, which means we can mock their behavior.
    Thus, it is possible to mock the behavior of the logging class, as shown in the
    following modified version of the `ItemServiceTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemServiceTests` class initializes the `LoggerAbstraction<IItemService>`
    type as a class attribute. The constructor of the class uses `ITestOutputHelper`
    to mock the logging system that''s used by the service layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`ITestOutputHelper` is an interface that''s exposed by the `Xunit.Abstractions`
    namespace and resolved by the `Xunit` runtime. It allows us to write in the test
    console of the test runner. Finally, the test class implements the `additem_should_log_information`
    test method. The test method calls the `AddItemAsync` method that we implemented
    in the `ItemService` class. Finally, it is possible to verify the `ILogger` interface
    using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet verifies that the `Log` method is called two times. It
    also outputs the resulting log as part of the logging system that's defined by
    the `ITestOutputHelper` interface. Now that we have implemented the logging mechanism
    in the service layer of the `Catalog.Domain` project, we will examine and implement
    the necessary logging providers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing logging providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have defined *what* to log in our application; in this section, we
    will illustrate *how* to do this. In ASP.NET Core, the logging provider is initialized
    using dependency injection. Moreover, it is possible to conditionally initialize
    it, depending on the environment or other startup options.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides some *built-in* logging providers, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Providers** | **Namespace** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Console` | `Microsoft.Extensions.Logging.Console` | Sets the console of
    the running application as the output of the logs. |'
  prefs: []
  type: TYPE_TB
- en: '| `Debug` | `Microsoft.Extensions.Logging.Debug` | Writes messages in the debug
    output window when a debugger is attached. |'
  prefs: []
  type: TYPE_TB
- en: '| `EventSource` | `Microsoft.Extensions.Logging.EventSource` | Sets the Windows
    ETW as the main log''s output. |'
  prefs: []
  type: TYPE_TB
- en: '| `EventLog` | `Microsoft.Extensions.Logging.EventLog` | Sets the Windows event
    log as the main log''s output. |'
  prefs: []
  type: TYPE_TB
- en: '| `TraceSource` | `Microsoft.Extensions.Logging.TraceSource` | To use this
    provider, ASP.NET Core needs to run on the .NET Framework. The application will
    use the listeners that are provided by the trace source. |'
  prefs: []
  type: TYPE_TB
- en: 'It is crucial to note that all the logging providers are complementary. Furthermore,
    it is possible to add many of them so that we can perform trace logging in more
    sources. We can configure the provider in the `Startup` class and in the `Program`
    class. Let''s take a look at the `Program` class of `Catalog.API`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `Program` class uses `WebHost.CreateDefaultBuilder` to create the
    `WebHostBuilder` instance of the service. If we go further into the method, we
    will see that it uses the following syntax to define the log''s provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Program` class defines three built-in providers by default.
    Also, it uses the `Configuration` instance to pass the configurations that are
    described in the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, it is possible to override the default provider by explicitly calling
    the `ConfigureLogging` extension method in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet is useful if we want to add a custom logging provider
    to our application. ASP.NET Core also provides us with a convenient way to configure
    the logging provider in the `Startup` class: it is possible to use the `AddLogging`
    extension method in `ConfigureServices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet initializes the logging services on the execution of `ConfigureServices`
    in the `Startup` class. The initialization of the logging provider at the `Startup`
    level is useful when we want to initialize the log provider in terms of the environment
    or a specific configuration flag. Let's proceed by learning how to implement a
    custom logging provider.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom log provider in tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already have seen, the logging system of ASP.NET Core is designed for
    maximum extensibility. In this section, we will learn how to implement a custom
    logging provider that we can use in our tests. All the test classes that are present
    in the `Catalog.API.Tests` project use `InMemoryApplicationFactory<T>` to run
    a web server and provide `HttpClient` to call the API. As you may have noticed,
    the tests don''t return an explicit error when one of the tests fails. For example,
    let''s examine the following test method in the `ItemControllerTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If for any reason, the call returns an error, we will receive the following
    message on the test side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we don''t know *why* the API has returned an `InternalServerError`. Here,
    we can use the `ITestOutputHelper` interface provided by `Xunit` to create a new
    logger provider and use it in our tests. To declare a logger in ASP.NET Core,
    we need the following structure and components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dfecc86-0882-4390-82df-2e36edc66afb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding schema describes two main components: the `TestOutputLoggerProvider`
    type and the `TestOutputLogger` type. The `TestOutputLoggerProvider` type''s purpose
    is to manage a list of logger instances. The `TestOutputLogger` class describes
    the actual implementation of the logging mechanism. Let''s start by defining the
    custom `ILogger` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`ITestOutputClass` implements the methods provided by the `ILogger` interface.
    First of all, it declares an `ITestOutputHelper` field in the constructor. Then,
    it uses the `_output` attribute inside the concrete implementation of the `Log`
    method by calling the `_output.WriteLine` method. The class also implements the
    `IsEnabled` method to check whether the log level corresponds to the `LogLevel.Error`
    field. If the log record doesn''t do this, `LogLevel.Error` is written in the
    console''s output. To finalize this implementation, we need a logger provider
    to initialize the custom logger. Let''s continue by creating another class called
    `TestOutputLoggerProvider`, which extends the `ILoggerProvider` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`TestOutputLoggerProvider` defines a `ConcurrentDictionary`, which contains
    a pair of `string` and `TestOutputLogger`; it also accepts the `ITestOutputHelper`
    interface as an interface, which is used in the `CreateLogger` method to add the
    logger to the logging pipeline. By doing this, we can integrate the custom logger
    into our tests. We will use the `InMemoryApplicationFactory<T>` class, which is
    implemented in the `Catalog.Fixtures` project, to add the custom logger, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class declares a new `ITestOutputHelper` attribute type and defines
    a setter. It is possible to add our custom logger by calling the `AddProvider`
    extension method inside the `ConfigureTestService` class by creating a new instance
    of `TestOutputLoggerProvider`. After making these changes, we can proceed by integrating
    the custom logger into the `ItemControllerTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `ItemControllerTests` calls `_factory.SetTestOutputHelper` in
    the constructor by setting the injected `ITestOutputHelper` interface. Now, we'll
    get detailed error messages every time a test throws an error. It is essential
    to note that the `ITestOutputHelper` interface is assigned in the test class,
    which means this is the only point where it is possible to obtain the interface
    using dependency injection. In the next section, we will learn how to implement
    health checks related to web service dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Web service health check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another essential feature that's always present in web services is the *health
    checking process* for dependencies. In general, the health check processes are
    used by the CI/CD pipeline to check whether a service is healthy after its deployment
    or to perform the feature check-in a monitoring dashboard. Health checks are usually
    performed by calling HTTP routes to detect whether there are any ongoing issues
    in the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these services expose the health check routes. The monitoring of these
    health checks is implemented in an independent and separate application. Furthermore,
    this practice allows us to keep the services independent from the monitoring logic.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core provides some out-of-the-box implementations to help developers
    add health check processes to their services. These features are implemented using
    a *middleware-oriented approach.* Furthermore, the health checks are exposed as
    HTTP endpoints, and they can be used to check the status of third-party services,
    databases, and data storage systems. Thus, we can test the dependencies of the
    service to confirm their availability and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The health checks feature was introduced with the *ASP.NET Core 2.2.0-preview1*
    version in August 2018\. This feature introduced the `IHealthCheck` interface*.*
    In the future, it will be integrated with the `Polly` library to provide better
    resilience when users perform logging checks.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing health checks on databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Databases are usually one of the main dependencies of a web service. Therefore,
    it is always essential to check the connection between the service and the database.
    Let''s start by learning how to implement health checks using the `AspNetCore.HealthChecks.SqlServer`
    ([https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/](https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/))
    and `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore` ([https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/](https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/))
    packages. We are going to apply these changes to the *catalog service* project.
    Let''s start by adding this package to the `Catalog.API`project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AspNetCore.HealthChecks.SqlServer` package allows us to perform health
    checks on SQL Server instances. Let''s proceed by registering the following services
    in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code configures the *health check middleware* using the
    `AddHealthChecks` extension method, which returns an `IHealthChecksBuilder` interface;
    it calls the `AddSqlServer` extension method provided by the builder to bind the
    health check with the SQL Server database. Finally, the code adds the middleware
    by calling the `UseHealthChecks` method and passing in the health check route.
    If we can call our service at the `https://<hostname>:<port>/health` route, we
    will receive the `Healthy`/`Unhealthy` response, depending on the connection to
    our data source.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom health checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core''s health check feature is not only suitable for the data source
    of our service; it can also be used to perform sophisticated and custom health
    checks. The framework provides the `IHealthCheck` interface so that we can implement
    our health check. Let''s create a new class called `RedisCacheHealthCheck` in
    the `HealthCheck` folder, inside the `Catalog.API` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `RedisCacheHealthCheck` class uses the `StackExchange.Redis` package to
    create a connection with the Redis instance specified in the setting's connection
    string. The core part of this class is the `CheckHealthAsync` method; it returns
    `HealthCheckResult.Healthy` or `HealthCheckResult.Unhealthy`, depending on the
    response time of the Redis instance. If a ping takes less than five seconds to
    come back, it means that the instance is healthy; otherwise, it isn't. The class
    is part of the ASP.NET Core stack, and it can use the dependency injection engine
    of the framework to solve dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, it is possible to add the class to the health check stack by adding
    the following snippet to the `ConfigureServices` method of the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This approach will add the check for the SQL Server connection and the custom
    check we implemented in the `RedisCacheHealthCheck` class to the middleware pipeline.
    If both of them succeed, the service will be classed as healthy. Futhermore it
    will be possible to run the catalog containers using the `docker-compose up --build`
    command and verify the status of the dependencies of the catalog web service by
    calling the `http://<hostname:port>/health` route.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to track the state of our services using logging.
    We also learned how to customize a logger provider and how to integrate it with
    an ASP.NET Core application. Furthermore, we dealt with the new health checking
    feature of ASP.NET Core and learned how to build a custom health check.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how to implement logging in an ASP.NET Core application and create
    a custom logger provider. You will be able to use these skills to keep track of
    the data that's exposed by your services and monitor the status of your web service
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to bring our web service to the cloud
    using Azure.
  prefs: []
  type: TYPE_NORMAL
