- en: Implementing a Level Editor with Spatial Partition
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the concept of spatial partitioning. Unlike
    in previous chapters, the main subject is not traditionally defined as a software
    design pattern but more as a process and a technique. But because it offers us
    a reusable and structured approach to solving recurrent game-programming problems,
    we will treat it as a design pattern in the context of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach we are going to take in this chapter is different from previous
    chapters for the following specific reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We are taking a hands-off approach; in other words, we will not attempt to implement
    a code example but will instead review some code segments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not try to stay faithful to any academic definition but will instead
    use the general concept of spatial partitioning to build a level editor for our
    racing game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest definition of spatial partitioning is a process that offers an
    efficient way of locating objects by collating them in a data structure ordered
    by their positions. The level editor we are implementing in this chapter will
    be built with a stack data structure, and the type of object we will keep in a
    specific order on a stack is a race track segment. These individual segments of
    the race track will be spawned or deleted in a particular order, depending on
    their relation to the player's position on the map.
  prefs: []
  type: TYPE_NORMAL
- en: All of this might sound very abstract, but it's pretty easy to achieve this
    with the Unity **application programming interface** (**API**), as we will see
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The system we are implementing in this chapter is too elaborate to boil down
    into a skeleton code example. So, unlike in previous chapters, the code presented
    is not meant to be reproduced or used as a template. We instead recommend reviewing
    a complete code example of the level editor in the `/FPP` folder of the Git project.
    The link can be found in the *Technical requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Spatial Partition pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a level editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a level editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will also be using the following specific Unity engine API features:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScriptableObjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml), *A
    Short Primer to Programming in Unity*.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at the following link: [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: A Stack is a linear data structure with two primary operations: **Push**,which
    adds an element on top of the stack, and **Pop**,which removesthe most recent
    element from the top.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Spatial Partition pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spatial Partition pattern name comes from the process known as space partitioning,
    which plays an integral part in computer graphics and is often used in ray-tracing
    rendering implementations. The process is utilized to organize objects in virtual
    scenes by storing them in a space-partitioning data structure such as a **binary
    space partitioning** (**BSP**) tree; this makes it faster to perform geometry
    queries on a large set of **three-dimensional** (**3D**) objects. In this chapter,
    we will use the general concept of spatial partitioning without being faithful
    to how it's usually implemented in computer graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very high-level and conceptual way of visualizing spatial partitioning is
    with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/338d48b6-7ba3-4d14-849b-a358f2c5816e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – A diagram that illustrates spatial partitioning on a map
  prefs: []
  type: TYPE_NORMAL
- en: The first example represents the position of enemies on the map without any
    partitioning. If we want to quickly look up the location of enemies in relation
    to the player, it could be challenging to do this efficiently. Of course, we could
    use ray casts to calculate the distance between entities, but this could become
    inefficient as the number of enemies grows.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the diagram shows that if we partition the map, we can now
    easily visualize the clusters of enemies in relation to the player's location.
    In code, we could now quickly look up which enemy is the closest to the player
    and where there's the largest cluster of them, and because we don't need the exact
    position of each enemy but just their general geographical relation to the player,
    just knowing which approximate cell of the grid they are in is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: '**BSP** is a 3D programming technique that recursively subdivides space into
    convex pairs using a series of hyperplanes. The method is implemented with a binary-tree
    data structure. John Carmack has famously used BSP to develop games such as *Doom*
    and *Quake*.'
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Spatial Partition pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3D programming is beyond the scope of this book, yet the most important takeaway
    of the description of spatial partitioning is that it offers a solution to organizing
    a large set of objects in a scene in an optimal manner. Therefore, if you find
    yourself needing a quick way to query an extensive collection of objects in a
    scene while keeping track of their spatial relations, keep in mind the principles
    of spatial partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review the overall design of the level editor and
    examine its technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a level editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on a multi-disciplinary game development team, the responsibilities
    of a game programmer are not limited to implementing cool game mechanics and features.
    We are often tasked with building asset-integration pipelines and editing tools.
    The most common tool we might need to implement early on in a production cycle
    is a custom level editor for the level designers on our team.
  prefs: []
  type: TYPE_NORMAL
- en: Before writing a single line of code, we need to keep in mind that our game
    has no randomness integrated into its core game systems. It's a game of skill
    in which players have the primary goal of reaching the top of the leaderboard
    by memorizing each track's intricacies and getting to the finish line as fast
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, based on these core design pillars, we can't use a solution such as procedural
    generation maps that spawn random obstacles based on specific rules and constraints. Consequently,
    the level designers in our team will have to design the layout of each race track
    by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this brings us to our most significant challenge: in our game, a bike travels
    through a 3D world in a straight line at very high speeds. If we wish to have
    a race that lasts more than a dozen seconds, we will need a massive amount of
    assets in the memory, and our designers will have to deal with editing massive
    levels in the editor.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach is neither efficient during the editing phase nor at runtime.
    So, instead of managing a single race track as one entity, we will divide it into
    segments, and each segment will be editable individually and then assembled in
    a specific order to form a single track.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this high-level concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/980dd515-a76d-4ebc-8bd0-00021cb4eb36.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – A diagram of the sequencing of track segments
  prefs: []
  type: TYPE_NORMAL
- en: 'We gain two key benefits from this system, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our level designers can author new tracks by creating new segments and sequencing
    them in various layouts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need to load the entire content of the race track into memory, just
    to spawn the segments we need at the right moment in relation to the player's
    current position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next diagram illustrates how the track controller uses a stack data structure
    to manage which track to unload and which ones to spawn in relation to the current
    position of the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/969c0861-9eee-44f6-8d25-12481ba438e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – A diagram of the segment stack
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two distinct characteristics of our game that we must keep in mind
    while implementing this system, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The bike never moves from its initial position. It's the track segments that
    move toward the player. Therefore, the sense of speed and movement is simulated
    and provides a visual illusion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player can only see forward. There are no rear-view windows or look-back
    cameras. This camera-view limitation means we can unload track segments immediately
    after they are behind the player's field of view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, with a single system, we have resolved two potential core issues
    for our project. Foremost, we are establishing a level design pipeline, and lastly,
    we have a mechanism to load our levels dynamically with a degree of optimization
    embedded in the design.
  prefs: []
  type: TYPE_NORMAL
- en: I was inspired by miniature electric-toy slot cars when designing the racing
    game we are building in this book. One unique aspect of this toy is that you can
    assemble individual track segments in various configurations. It was sometimes
    more fun thinking of new and unique track layouts than actually racing the toy
    cars.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a level editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review some code that will implement the core components
    of our level editor. Unlike in previous chapters, we will not try to make this
    code runnable or testable. Instead, we will review the implementations to understand
    how we use the general idea of spatial partitioning to build a functional level
    editor for designers while optimizing the way we load levels at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The code presented in the next section is to be reviewed but not compiled, as
    it's not a complete self-contained example.
  prefs: []
  type: TYPE_NORMAL
- en: Steps for implementing a level editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, we are going to write a `ScriptableObject` class named `Track`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this `ScriptableObject` class, our level designers will be able to design
    new variations of race tracks by adding segments into a list and then sequencing
    them in a specific order. Each track asset will be fed to the `TrackController` class,
    which will spawn each segment automatically and in the order that the designers
    sequenced them.
  prefs: []
  type: TYPE_NORMAL
- en: For the player, this process is seamless as it runs in the background, and segments
    are spawned before they are in the camera's field of view. So, from the point
    of view of the player, it looks like the whole level is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `TrackController` class. In it, we are going to implement the
    segment-loading mechanism, but because it''s an extensive class, we are going
    to divide it up and look at it in sections, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first section is just the initialization code and is self-explanatory,
    but the following region of the code gets more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, in the `Update()` loop, we are moving the track parent object
    toward the player to simulate movement. And in the `InitTrack()` method, we instantiate
    a track `GameObject`, which will act as the container of the track segments. But
    there''s one significant line of code in the function that''s a critical component
    to our segment-loading mechanism, and this is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: On this line, we are injecting the list of segments into a new Stack container.
    As mentioned at the beginning of the chapter, an essential part of the spatial-partitioning
    technique is the organization *of environment objects in a data structure* so
    that they are easier to query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code snippet, we are going to see how we use the Stack data structure
    to load segments in the correct order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `LoadSegment()` private method is at the heart of the system. It accepts
    as a parameter a specific amount of segments. This value will determine the number
    of segments that it will load when called. If there are enough segments remaining
    on the stack, it pops one from the top and initializes it behind the previously
    loaded segment. It continues this circular process until it has loaded the expected
    amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking yourself: *How do we destroy segments that have passed
    behind the player?* There are many ways we can calculate or detect if one entity
    is behind another, but for our context, we are going to use a twofold solution.
    Every segment prefab has an entity called a segment marker loaded at its edge;
    this is composed of two pillars and an invisible trigger.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the bike goes through the trigger, the segment marker deletes its parent
    `GameObject`, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When an entity with the `BikeController` component exits a segment marker's
    trigger, it requests the destruction of its parent `GameObject`, which in this
    case would be a `Segment` entity.
  prefs: []
  type: TYPE_NORMAL
- en: When an entity with the `BikeController` component exits a segment marker's
    trigger, it requests the destruction of its parent `GameObject`, which would be
    a `Segment` entity in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the `LoadSegment()` method from the `TrackController` class, every
    time we pop a new segment from the top of the stack, we attach to it a script
    as a component named `Segment`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we are passing the current instance of the `TrackController` class
    to its `trackController` parameter, the `Segment` object can call back the `TrackController` class
    and request the loading of the following sequence of segments just before it gets
    destroyed, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This approach creates a circular mechanism that loads and unloads a controlled
    amount of segments automatically at specific intervals. With this approach, we
    are managing the number of spawned entities in the scene at a given time. In theory,
    this will result in a more consistent frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of this approach, which is more gameplay-related, is that the
    segment markers can act as landmarks for a checkpoint system. Checkpoints are
    often used in time-limit racing game modes in which a player must reach several
    points on the track within a specific timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent example of a checkpoint-based racing game is *Rad Racer* from 1987.
  prefs: []
  type: TYPE_NORMAL
- en: Using the level editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can play with the level editor by opening up the `/FPP` folder in the Git
    repository and then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Under the `/Scenes/Gyms` folder, you should find a scene named `Segment`. In
    this scene, you will be able to edit and create new segment prefabs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the **Assets-> Create-> Track** menu, you have an option to create new
    track assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, you can modify and attach new tracks to the `TrackController` classby
    opening the `Track`scene under the **`Scenes/Main` **folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to improve the code and, more importantly, have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the level-editor implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementations in this chapter are simplified versions of the code of
    a more complex system, but if you take the time to review an advanced version
    of the level editor in the `/FPP` folder of the Git project, we will see some
    improvements, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Segments**: There''s an authoring pipeline for segments that uses ScriptableObjects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object pooling**: The `TrackController` class is using an object pool to
    optimize the loading time of individual segments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I didn't include these optimizations in the chapter to keep the code examples
    short and simple, for educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an actual production context, and if time permits, I would build our game's
    level editor differently. I would instead design a top-down track editor that
    would allow the level designers to draw rails and drag and drop obstacles on them.
    The designers would then be able to save their work in a serialized format.
  prefs: []
  type: TYPE_NORMAL
- en: Then, using spatial-partitioning principles, the tracks would be automatically
    divided into segments by the `TrackController` class and put into an object pool.
    This approach would automate the process of generating individual segments while
    optimizing the spawning process.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, the designers would not have to author individual segments as
    prefabs, and they could design new tracks while visualizing the entire layout
    in an editor.
  prefs: []
  type: TYPE_NORMAL
- en: When I'm building tools and setting up integration pipelines, my end goal is
    always automation. I always try to automate myself out of a job so that I don't
    waste time on manual tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a hands-off approach and reviewed how to build a basic
    level editor while using the broad ideas of the Spatial Partition pattern. Our
    goal wasn't to be faithful to standard definitions of the pattern. Instead, we
    use it as a starting point to build our system. I encourage you to take the time
    to review the code in the `/FPP` folder and refactor it to make it better.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review some alternative patterns that are good
    to know but have general use cases. Therefore, compared to the previous chapters,
    the use cases will have a broader scope without being specific to a game mechanic
    or system. The first pattern that we will tackle is the Adapter pattern. As its
    name implies, we will use it to integrate an adapter between two incompatible
    systems.
  prefs: []
  type: TYPE_NORMAL
