- en: Gameplay and Screen Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法和屏幕效果
- en: When it comes to creating believable and immersive games, the material design
    is not the only aspect that we need to take into account. The overall feeling
    can be altered using screen effects. This is very common in movies, for instance,
    when colors are corrected in the post-production phase. You can implement these
    techniques in your games too, using the knowledge from [Chapter 9](part0227.html#6OFFM0-e8c76c858d514bc3b1668fda96f8fa08),
    *Screen Effects with Unity Render Texture*. Two interesting effects are presented
    in this chapter; you can, however, adapt them to fit your needs and create your
    very own screen effect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建逼真和沉浸式的游戏时，材质设计并不是我们需要考虑的唯一方面。整体感觉可以通过屏幕效果来改变。这在电影中非常常见，例如，在后期制作阶段校正颜色。你可以在游戏中使用从[第9章](part0227.html#6OFFM0-e8c76c858d514bc3b1668fda96f8fa08)，“使用Unity渲染纹理的屏幕效果”中获得的知识来实现这些技术。本章中介绍了两个有趣的效果；然而，你可以根据需要调整它们，创建你自己的屏幕效果。
- en: 'In this chapter, you will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Creating an old movie screen effect
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建老电影屏幕效果
- en: Creating a night vision screen effect
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建夜视屏幕效果
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: If you are reading this book, you are most likely a person who has played a
    game or two in your time. One of the aspects of real-time games is the effect
    of immersing a player into a world to make it feel as if they were actually playing
    in the real world. More modern games make heavy use of screen effects to achieve
    this immersion.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，你很可能是这样一个在某个时候玩过一两个游戏的人。实时游戏的一个方面是让玩家沉浸在一个世界中，让他们感觉就像他们真的在现实世界中玩游戏一样。更现代的游戏大量使用屏幕效果来实现这种沉浸感。
- en: With screen effects, we can turn the mood of a certain environment from calm
    to scary, just by changing the look of the screen. Imagine walking into a room
    that is contained within a level, then the game takes over and goes into a cinematic
    moment. Many modern games will turn on different screen effects to change the
    mood of the current moment. Understanding how to create effects triggered by gameplay
    is next in our journey about shader writing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过屏幕效果，我们只需改变屏幕的外观，就能将某个环境的情绪从平静转变为恐怖。想象一下走进一个位于关卡内的房间，然后游戏接管并进入一个电影时刻。许多现代游戏会开启不同的屏幕效果来改变当前时刻的氛围。了解如何创建由游戏玩法触发的效果是我们关于着色器编写的旅程中的下一个环节。
- en: In this chapter, we are going to take a look at some of the more common gameplay
    screen effects. You are going to learn how to change the look of the game from
    normal to an old movie effect, and we are going to take a look at how many first-person
    shooter games apply their night vision effects to the screen. With each of these
    recipes, we are going to look at how to hook these up to game events so that they
    are turned on and off as the game's current presentation require.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些更常见的游戏玩法屏幕效果。你将学习如何将游戏的外观从正常转变为老电影效果，并且我们将探讨许多第一人称射击游戏如何将夜视效果应用到屏幕上。对于这些配方中的每一个，我们将探讨如何将它们连接到游戏事件，以便它们根据游戏当前的表现需求开启和关闭。
- en: Creating an old movie screen effect
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建老电影屏幕效果
- en: Many games are set in different times. Some take place in fantasy worlds or
    future sci-fi worlds, and some even take place in the Old West, where film cameras
    were just being developed and the movies that people watched were black and white
    or sometimes tinted with what is called a **sepia effect**. The look is very distinct,
    and we are going to replicate this look using a screen effect in Unity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏设定在不同的时代。有些发生在幻想世界或未来科幻世界中，有些甚至发生在老西部，当时电影摄影机刚刚被开发出来，人们观看的电影是黑白或有时被一种称为**棕褐色效果**的颜色着色。这种外观非常独特，我们将使用Unity中的屏幕效果来复制这种外观。
- en: 'There are a few steps to achieving this look; just to make the whole screen
    black and white or grayscale, we need to break down this effect into its component
    parts. If we analyze some reference footage of an old movie, we can begin to do
    this. Let''s take a look at the following image and break down the elements that
    make up the old movie look:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种外观有几个步骤；仅仅为了让整个屏幕变成黑白或灰度，我们需要将这个效果分解为其组成部分。如果我们分析一些老电影的参考片段，我们就可以开始这样做。让我们看一下以下图像，并分解构成老电影外观的元素：
- en: '![](img/00202.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00202.jpeg)'
- en: We constructed this image using a few reference images found online. It is always
    a good idea to try and utilize Photoshop to construct images like this to aid
    you in creating a plan for your new screen effect. Performing this process not
    only tells us the elements we will have to code in, but it also gives us a quick
    way to see which blending modes work and how we will construct the layers of our
    screen effect.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用网上找到的一些参考图像构建了这张图片。尝试使用 Photoshop 构建这样的图片总是一个好主意，这可以帮助你为新屏幕效果制定计划。执行此过程不仅告诉我们将需要编码的元素，而且还给我们提供了一个快速查看哪些混合模式有效以及我们将如何构建屏幕效果层的方法。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Now that we know what we have to make, let''s take a look at how each of the
    layers is combined to create the final effect and gather some resources for our
    shader and screen effect script:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们要制作什么，让我们看看每一层是如何组合在一起以创建最终效果，并为我们的着色器和屏幕效果脚本收集一些资源：
- en: '**Sepia tone**: This is a relatively simple effect to achieve, as we just need
    to bring all the pixel colors of the original render texture to a single color
    range. This is easily achieved using the luminance of the original image and adding
    a constant color. Our first layer will look like the following screenshot:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**棕褐色调**：这是一个相对简单的效果，因为我们只需要将原始渲染纹理的所有像素颜色调整到单个颜色范围内。这可以通过使用原始图像的亮度并添加一个常数颜色轻松实现。我们的第一层将看起来像以下截图：'
- en: '![](img/00203.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00203.jpeg)'
- en: '**Vignette effect**: We can always see some sort of soft border around old
    films when they are being projected using an old movie projector. This is caused
    because the bulb that is used for the movie projector has more brightness in the
    middle than it does at the edges of the film. This effect is generally called
    the vignette effect and is the second layer in our screen effect. We can achieve
    this with an overlaid texture over the whole screen. The following screenshot
    demonstrates what this layer looks like, isolated as a texture:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**晕影效果**：当使用老旧电影放映机放映老电影时，我们总能看到某种类型的软边框。这是由于用于电影放映机的灯泡在电影边缘的亮度比中间的亮度要低。这种效果通常被称为晕影效果，并且是屏幕效果的第二层。我们可以通过在整个屏幕上叠加纹理来实现这一点。以下截图演示了这一层看起来像什么，隔离为纹理：'
- en: '![](img/00204.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00204.jpeg)'
- en: '**Dust and scratches**: The third and final layer in our old movie screen effect
    is dust and scratches. This layer will utilize two different tiled textures, one
    for scratches and one for dust. The reason is that we will want to animate these
    two textures over time at different tiling rates. This will give the effect that
    the film is moving along and there are small scratches and dust on each frame
    of the old film. The following screenshot demonstrates this effect isolated to
    its own texture:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灰尘和划痕**：在我们老旧电影屏幕效果中的第三和最后一层是灰尘和划痕。这一层将利用两种不同的平铺纹理，一种用于划痕，一种用于灰尘。原因是我们将想要在时间上以不同的平铺速率动画化这两种纹理。这将产生一种效果，即电影在移动，并且每一帧的老电影上都有小划痕和灰尘。以下截图演示了将此效果隔离到其自身纹理中的样子：'
- en: '![](img/00205.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00205.jpeg)'
- en: 'Let''s get our screen effect system ready with the preceding textures. Perform
    the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面的纹理准备好我们的屏幕效果系统。执行以下步骤：
- en: Gather up a vignette texture and a dust and scratches texture, like the ones
    we just saw.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集晕影纹理和灰尘划痕纹理，就像我们刚才看到的那些。
- en: 'We will also need a scene for which we want to emulate the effect we''re trying
    to build. I have created a sample scene that you can use in the `Chapter 10` folder
    of the example code, called `10.1 Starter Scene`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个场景，我们想要模拟我们试图构建的效果。我创建了一个示例场景，你可以将其用于示例代码中的`第10章`文件夹，名为`10.1 Starter
    Scene`：
- en: '![](img/00206.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00206.jpeg)'
- en: Create a new shader by duplicating the `ScreenGrayscale` code; select it from
    the Project tab under the `Chapter 9 `| `Shaders` folder and press *Ctrl* + *D*.
    Once duplicated, rename the script to `ScreenOldFilm`. Then, drag and drop the
    script into the `Chapter 10 `| `Shaders` folder, creating it if needed.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制`ScreenGrayscale`代码创建一个新的着色器；从`第9章`|`着色器`文件夹下的`项目`选项卡中选择它，然后按*Ctrl* + *D*。一旦复制，将脚本重命名为`ScreenOldFilm`。然后，将脚本拖放到`第10章`|`着色器`文件夹中，如果需要则创建它。
- en: Next, go to the `Chapter 9 `| `Scripts` folder and duplicate the `TestRenderImage`
    script. Rename the new file to `RenderOldFilm` and then drag and drop it into
    the `Chapter 10 `| `Scripts` folder, creating it if needed.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到`第9章`|`脚本`文件夹，复制`TestRenderImage`脚本。将新文件重命名为`RenderOldFilm`，然后将其拖放到`第10章`|`脚本`文件夹中，如果需要则创建它。
- en: Finally, with our screen effect system up and running and our textures gathered,
    we can begin the process of recreating this old film effect.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们的屏幕效果系统运行良好并且我们已经收集了纹理后，我们可以开始重新创建这个老式电影效果的过程。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Our individual layers for our old film screen effect are quite simple, but when
    combined, we get some very visually stunning effects. Let's run through how to
    construct the code for our script and shader, then we can step through each line
    of code and learn why things are working the way they are. At this point, you
    should have the screen effects system up and running, as we will not be covering
    how to set this up in this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的老式电影屏幕效果的各个单独层相当简单，但结合在一起，我们会得到一些非常视觉上令人惊叹的效果。让我们来了解一下如何构建我们的脚本和着色器的代码，然后我们可以逐行分析代码，了解为什么事情会以这种方式工作。到目前为止，你应该已经启动并运行了屏幕效果系统，因为我们不会在这个配方中介绍如何设置它。
- en: 'We will begin by entering the code in our script. Our first step in modifying
    our script is to rename the class to match our filename, `RenderOldFilm`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从在脚本中输入代码开始。修改我们的脚本的第一步是将类名重命名为与我们的文件名匹配，`RenderOldFilm`：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first block of code that we will enter will define the variable that we
    want to expose to Inspector, in order to let the user of this effect adjust it
    as they see fit. We can also use our mocked-up Photoshop file as a reference when
    deciding what we will need to expose to the Inspector of this effect. Enter the
    following code in your effect script:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要输入的第一个代码块将定义我们想要暴露给 Inspector 的变量，以便用户可以根据需要调整此效果。我们还可以在决定需要暴露给此效果 Inspector
    的内容时，将我们的模拟 Photoshop 文件作为参考。在你的效果脚本中输入以下代码：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to fill in the contents of our `OnRenderImage()` function. Here,
    we will be passing the data from our variables to our shader so that the shader
    can then use this data in the processing of the render texture:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要填充我们的 `OnRenderImage()` 函数的内容。在这里，我们将从我们的变量传递数据到着色器，以便着色器可以使用这些数据来处理渲染纹理：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To complete the script portion of this effect, we simply need to make sure
    that we clamp the values of the variables that need to have a clamped range instead
    of being any value:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个效果的脚本部分，我们只需确保我们将需要限制范围的变量值进行限制，而不是任何值：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With our script complete, let''s turn our attention to our shader file. We
    need to create the corresponding variables, which we created in our script in
    our shader. This will allow the script and shader to communicate with one another.
    Enter the following code in the `Properties` block of the shader:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的脚本完成后，让我们将注意力转向我们的着色器文件。我们需要创建在脚本中创建的相应变量，这样脚本和着色器就可以相互通信。在着色器的 `Properties`
    块中输入以下代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, as usual, we need to add these same variable names to our `CGPROGRAM`
    block so that the `Properties` block can communicate with the `CGPROGRAM` block:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，像往常一样，我们需要将这些相同的变量名添加到我们的 `CGPROGRAM` 块中，以便 `Properties` 块可以与 `CGPROGRAM`
    块通信：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we simply fill in the guts of our `frag()` function so that we can process
    the pixels for our screen effect. To start with, let''s get the render texture
    and vignette texture passed to us by the script:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需填充我们的 `frag()` 函数的内部逻辑，以便我们可以处理屏幕效果的像素。首先，让我们从脚本中获取传递给我们的渲染纹理和晕影纹理：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then need to add the process for the dust and scratches by entering the
    following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要通过输入以下代码来添加灰尘和划痕的处理过程：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The sepia tone process is next on our list:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来在我们的列表中是棕褐色调过程：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we combine all of our layers and colors and return the final screen
    effect texture:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有层和颜色组合在一起，并返回最终的屏幕效果纹理：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With all of our code entered and no errors, return to the Unity editor and
    add the `RenderOldFilm` component to the `MainCamera` in our example scene. From
    there, drag and drop our shader into the Cur Shader property. Afterward, under
    Sepia Color,  assign a brown color like the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入所有代码且没有错误后，返回 Unity 编辑器，并将 `RenderOldFilm` 组件添加到示例场景中的 `MainCamera` 上。从那里，将我们的着色器拖放到
    Cur Shader 属性中。之后，在棕褐色调下，分配一个类似以下的棕色：
- en: '![](img/00207.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00207.jpeg)'
- en: 'Afterward, assign each of the textures given to the appropriate property. You
    should then notice something similar to the following on the screen:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将提供的每个纹理分配给相应的属性。你应该会在屏幕上注意到以下类似的内容：
- en: '![](img/00208.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00208.jpeg)'
- en: Also, make sure to hit Play in the Unity Editor to see the full extent of the
    effects of the dust and scratches and the slight image shift that we gave the
    screen effect.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，确保在Unity编辑器中点击播放，以查看灰尘和划痕效果的全貌以及我们给予屏幕效果的轻微图像偏移。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now, let's walk through each of the layers in this screen effect, break down
    why each of the lines of code is working the way it is, and get more insight about
    how we can add more to this screen effect.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一分析这个屏幕效果中的每一层，解释每一行代码为什么能按预期工作，并深入了解我们如何为这个屏幕效果添加更多内容。
- en: Now that our old film screen effect is working, let's step through the lines
    of code in our `frag()` function, as all the other code should be pretty self-explanatory
    at this point in the book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们老旧的电影屏幕效果已经生效，让我们逐步分析`frag()`函数中的代码行，因为在此书此阶段，其他代码应该相当直观易懂。
- en: Just like our Photoshop layers, our shader is processing each layer and then
    compositing them together, so while we go through each layer, try to imagine how
    the layers in Photoshop work. Keeping this concept in mind always helps when developing
    new screen effects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的Photoshop图层一样，我们的着色器正在处理每一层并将它们组合在一起，所以当我们逐层分析时，试着想象Photoshop中的图层是如何工作的。保持这个概念在心中，在开发新的屏幕效果时总是有帮助的。
- en: 'Here, we have the first set of lines of code in our `frag()` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`frag()`函数中的第一组代码行：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line of code, just after the `frag()` function declaration, is the
    definition of how the UVs should work for our main render texture or the actual
    rendered frame of our game. As we are looking to fake the effect of an old film
    style, we want to adjust the UVs of our render texture in every frame, such that
    they flicker. This flickering simulates how the winding of the film's projector
    is just a bit off. This tells us that we need to animate the UVs and this is what
    this first line of code is doing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行，紧随`frag()`函数声明之后，定义了UVs应该如何为我们的主渲染纹理或游戏实际渲染的帧工作。由于我们想要模拟老旧电影风格的效果，我们希望在每一帧中调整渲染纹理的UVs，使其闪烁。这种闪烁模拟了电影放映机卷轴略微偏移的情况。这告诉我们需要动画化UVs，这正是第一行代码所做的事情。
- en: We used the built-in `_SinTime` variable, which Unity provides, to get a value
    between `-1` and `1`. We then multiply this by a very small number, in this case,
    `0.005`, to reduce the intensity of the effect. The final value is then multiplied
    again by the `_RandomValue` variable, which we generated in the effect script.
    This value bounces back and forth between `-1` and `1` to basically flip the direction
    of the motion back and forth.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Unity提供的内置`_SinTime`变量，以获取介于`-1`和`1`之间的值。然后我们将其乘以一个非常小的数字，在这个例子中是`0.005`，以减少效果强度。最终的值然后再次乘以我们在效果脚本中生成的`_RandomValue`变量。这个值在`-1`和`1`之间来回弹跳，基本上是来回翻转运动的方向。
- en: Once our UVs are built and stored in the `renderTexUV` variable, we can sample
    the render texture using a `tex2D()` function. This operation then gives us our
    final render texture, which we can use to process further in the rest of the shader.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的UVs构建并存储在`renderTexUV`变量中，我们就可以使用`tex2D()`函数来采样渲染纹理。这个操作然后给我们最终的渲染纹理，我们可以在着色器的其余部分进一步处理它。
- en: Moving on to the last line in the previous image, we simply do a straight sample
    of the vignette texture using the `tex2D()` function. We don't need to use the
    animated UVs we already created, as the vignette texture will be tied to the motion
    of the camera itself and not to the flickering of the camera film.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来看上一张图片中的最后一行，我们只是简单地使用`tex2D()`函数对晕影纹理进行直接采样。我们不需要使用之前已经创建的动画UVs，因为晕影纹理将与摄像机的运动本身相关联，而不是与摄像机胶片的闪烁相关联。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These lines of code are almost exactly like the previous lines of code, in which
    we need to generate unique animated UV values to modify the position of our screen
    effect layers. We simply use the built-in `_SinTime` value to get a value between
    `-1` and `1`, multiply it by our random value, and then by another multiplier
    to adjust the overall speed of the animation. Once these UV values are generated,
    we can then sample our dust and scratches texture using these new animated values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行几乎与之前的代码行完全相同，我们需要生成独特的动画UV值来修改屏幕效果层的位置。我们简单地使用内置的`_SinTime`值来获取介于`-1`和`1`之间的值，乘以我们的随机值，然后再乘以另一个乘数来调整动画的整体速度。一旦生成了这些UV值，我们就可以使用这些新的动画值来采样灰尘和划痕纹理。
- en: 'Our next set of code handles the creation of the colorizing effect for our
    old film screen effect. The following code snippet demonstrates these lines:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一组代码处理的是为我们的老电影屏幕效果创建着色效果。以下代码片段演示了这些行：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this set of code, we are creating the actual color tinting of the entire
    render texture. To accomplish this, we first need to turn the render texture into
    the grayscale version of itself. To do this, we can use the luminosity values
    given to us by the `YIQ` values. `YIQ` values are the color space used by the
    NTSC color TV system. Each letter in `YIQ` actually stores color constants that
    are used by TVs to adjust the color for readability.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这组代码，我们正在创建整个渲染纹理的实际颜色着色。为了实现这一点，我们首先需要将渲染纹理转换为它自己的灰度版本。为此，我们可以使用由 `YIQ` 值提供的亮度值。`YIQ`
    值是 NTSC 彩色电视系统使用的颜色空间。`YIQ` 中的每个字母实际上存储了电视用来调整可读性的颜色常数。
- en: While it is not necessary to actually know the reasons for this color scale,
    it should be known that the `Y` value in `YIQ` is the constant luminance value
    for any image. So, we can generate a grayscale image of our render texture by
    taking each pixel of the render texture and dotting it with our luminance values.
    This is what the first line in this set is doing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实际上知道这种颜色尺度的原因并不是必要的，但应该知道，`YIQ` 中的 `Y` 值是任何图像的恒定亮度值。因此，我们可以通过将渲染纹理的每个像素与我们的亮度值点积来生成渲染纹理的灰度图像。这就是这组代码中的第一行所做的事情。
- en: Once we have the luminance values, we can simply add the color we want to tint
    the image with. This color is passed from our script to our shader, then to our
    `CGPROGRAM` block, where we can add it to our grayscale render to texture. Once
    completed, we will have a perfectly tinted image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了亮度值，我们就可以简单地添加我们想要给图像着色的颜色。这种颜色从我们的脚本传递到我们的着色器，然后到我们的 `CGPROGRAM` 块，在那里我们可以将其添加到我们的灰度渲染纹理中。一旦完成，我们就会得到一个完美着色的图像。
- en: 'Finally, we create the blending between each of our layers in our screen effect.
    The following code snippet shows the set of code we are looking at:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在屏幕效果中创建每一层的混合。以下代码片段显示了我们所查看的代码集：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our last set of code is relatively simple and doesn't really need a ton of explanation.
    In short, it is simply multiplying all the layers together to reach our final
    result. Just like we multiplied our layers together in Photoshop, we multiply
    them together in our shader. Each layer is processed through a `lerp()` function
    so that we can adjust the opacity of each layer, which gives more artistic control
    over the final effect. The more tweaks one can offer, the better when it comes
    to screen effects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一组代码相对简单，实际上并不需要太多解释。简而言之，它只是将所有层相乘以得到最终结果。就像我们在 Photoshop 中将层相乘一样，我们在着色器中将它们相乘。每一层都通过一个
    `lerp()` 函数进行处理，这样我们就可以调整每一层的透明度，从而对最终效果有更多的艺术控制。在屏幕效果方面，提供的调整越多，效果越好。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information on the `YIQ` values, refer to the following links:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `YIQ` 值的更多信息，请参阅以下链接：
- en: '[http://en.wikipedia.org/wiki/YIQ](http://en.wikipedia.org/wiki/YIQ)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/YIQ](http://en.wikipedia.org/wiki/YIQ)'
- en: '[http://www.blackice.com/colorspaceYIQ.htm](http://www.blackice.com/colorspaceYIQ.htm)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.blackice.com/colorspaceYIQ.htm](http://www.blackice.com/colorspaceYIQ.htm)'
- en: Creating a night vision screen effect
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建夜视屏幕效果
- en: 'Our next screen effect is definitely a more popular one. The night vision screen
    effect is seen in *Call of Duty: Modern Warfare*, *Halo*, and just about any first-person
    shooter out in the market today. It is the effect of brightening the whole image
    using that very distinct lime-green color.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '我们下一个屏幕效果绝对是一个更受欢迎的效果。夜视屏幕效果在 *Call of Duty: Modern Warfare*、*Halo* 以及市场上几乎任何第一人称射击游戏中都可以看到。这是使用非常独特的草绿色来提亮整个图像的效果。'
- en: 'In order to achieve our night vision effect, we need to break down our effect
    using Photoshop. It is a simple process of finding some reference images online
    and composing a layered image to see what kind of blending modes you will need
    or in which order we will need to combine our layers. The following screenshot
    shows the result of performing just this process in Photoshop:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的夜视效果，我们需要使用 Photoshop 将效果分解。这是一个简单的过程，即在网上找到一些参考图像，并组合一个分层图像来查看你需要什么样的混合模式，或者我们需要按什么顺序组合我们的层。以下截图显示了在
    Photoshop 中执行此过程的成果：
- en: '![](img/00209.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00209.jpeg)'
- en: Let's begin to break down our rough Photoshop composite image into its component
    parts so that we can better understand the assets we will have to gather. In the
    next recipe, we will cover the process of doing this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将粗糙的 Photoshop 合成图像分解成其组成部分，以便我们更好地理解我们需要收集的资产。在下一章中，我们将介绍这一过程。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s begin this screen effect by again breaking down our effect into its
    component layers. Using Photoshop, we can construct a layered image to better
    illustrate how we can go about capturing the effect of night vision:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次将我们的效果分解为其组成部分，以此开始这个屏幕效果。使用 Photoshop，我们可以构建一个分层图像，以更好地说明我们如何捕捉夜视效果：
- en: '**Tinted green**: Our first layer in our screen effect is the iconic green
    color, found in just about every night vision image. This will give our effect
    that signature night vision look, as shown in the following screenshot:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色绿色**：我们屏幕效果中的第一层是标志性的绿色，几乎在每一张夜视图像中都能找到。这将给我们的效果带来独特的夜视外观，如下面的截图所示：'
- en: '![](img/00210.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00210.jpeg)'
- en: '**Scan lines**: To increase the effect of this being a new type of display
    for the player, we include scan lines over the top of our tinted layer. For this,
    we will use a texture created in Photoshop and let the user tile it so that the
    scan lines can be bigger or smaller.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扫描线**：为了增加这种新类型显示器对玩家的效果，我们在着色层上方添加了扫描线。为此，我们将使用在 Photoshop 中创建的纹理，并允许用户平铺它，以便扫描线可以更大或更小。'
- en: '**Noise**: Our next layer is a simple noise texture that we tile over the tinted
    image and scan lines to break up the image and add even more detail to our effect.
    This layer simply emphasizes that digital read-out look:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声**：我们的下一层是一个简单的噪声纹理，我们将其平铺在着色图像和扫描线上，以打破图像并为我们添加更多细节。这一层仅仅强调了数字读数的外观：'
- en: '![](img/00211.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00211.jpeg)'
- en: '**Vignette**: The last layer in our night vision effect is the vignette. If
    you look at the night vision effect in *Call of Duty: Modern Warfare*, you will
    notice that it uses a vignette that fakes the effect of looking down a scope.
    We will do that for this screen effect:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**晕影**：我们夜视效果中的最后一层是晕影。如果你查看《使命召唤：现代战争》中的夜视效果，你会注意到它使用了一个模仿通过瞄准镜向下看的晕影效果。我们将为这个屏幕效果做同样的事情：'
- en: '![](img/00212.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00212.jpeg)'
- en: 'Let''s create a screen effect system by gathering our textures. Perform the
    following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过收集我们的纹理来创建一个屏幕效果系统。执行以下步骤：
- en: Gather up a vignette texture, noise texture, and scan line texture, like the
    ones we just saw. Like before, I have these textures available in the book's example
    code under the `Chapter 10` | `Textures` folder.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集晕影纹理、噪声纹理和扫描线纹理，就像我们刚才看到的。就像之前一样，我在书的示例代码中的`Chapter 10` | `Textures`文件夹中提供了这些纹理。
- en: Find a sample scene to make it easy to see the effect of the shader. I will
    be using the same scene as in the previous recipe, so feel free to use the `10.1
    Sample Scene` again.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找一个示例场景以便更容易看到着色器的效果。我将使用与上一章相同的场景，所以请随意再次使用`10.1 Sample Scene`。
- en: Create a new shader by duplicating the `ScreenGrayscale` code; select it from
    the Project tab under the `Chapter 9` | `Shaders` folder and press *Ctrl *+ *D*.
    Once duplicated, rename the script to  `ScreenNightVision`. Then drag and drop
    the script into the `Chapter 10 `| `Shaders` folder, creating it if needed.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制`ScreenGrayscale`代码创建一个新的着色器；从`Chapter 9` | `Shaders`文件夹下的`Project`标签中选择它，然后按*Ctrl*
    + *D*。一旦复制，将脚本重命名为`ScreenNightVision`。然后将脚本拖放到`Chapter 10` | `Shaders`文件夹中，如果需要则创建它。
- en: Next, go the `Chapter 9 `| `Scripts` folder and duplicate the `TestRenderImage` script.
    Rename the new file to `RenderNightVision` and then drag and drop it into the `Chapter
    10 `| `Scripts` folder, creating it if needed.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，前往`Chapter 9` | `Scripts`文件夹，复制`TestRenderImage`脚本。将新文件重命名为`RenderNightVision`，然后将其拖放到`Chapter
    10` | `Scripts`文件夹中，如果需要则创建它。
- en: Finally, with our screen effect system up and running and our textures gathered,
    we can begin the process of recreating this night vision effect.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们的屏幕效果系统运行起来并且我们已经收集了纹理后，我们可以开始重新创建这个夜视效果的过程。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'With all of our assets gathered and the screen effect system running smoothly,
    let''s begin to add the code necessary to both the script and shader. We will
    begin our coding with the `RenderNightVision.cs` script, so double-click on this
    file now to open it in your code editor of choice:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集了所有资产并且屏幕效果系统运行顺畅后，让我们开始添加必要的代码，包括脚本和着色器。我们将从`RenderNightVision.cs`脚本开始编码，所以现在请双击此文件，在您选择的代码编辑器中打开它：
- en: 'We will begin by entering the code in our script. Our first step in modifying
    our script is to rename the class to match our filename, `RenderNightVision`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在我们的脚本中输入代码。修改脚本的第一步是将类重命名为与文件名匹配，即`RenderNightVision`：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need to create a few variables that will allow the user of this effect to
    adjust it in the script''s Inspector. Enter the following code in the `NightVisionEffect.cs`
    script:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一些变量，使用户能够通过脚本的检查器调整此效果。在`NightVisionEffect.cs`脚本中输入以下代码：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we need to complete our `OnRenderImage()` function so that we are passing
    the right data to the shader in order for the shader to process the screen effect
    properly. Complete the `OnRenderImage()` function with the following code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要完成我们的`OnRenderImage()`函数，以便正确地将数据传递给着色器，以便着色器能够正确处理屏幕效果。使用以下代码完成`OnRenderImage()`函数：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To complete the `NightVisionEffect.cs` script, we simply need to make sure
    that we clamp certain variables so that they stay within a range. These ranges
    are arbitrary and can be changed at a later time. These are just values that worked
    well:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成`NightVisionEffect.cs`脚本，我们只需确保某些变量被限制在一定的范围内，这样它们才能保持在这个范围内。这些范围是任意的，可以在以后的时间进行更改。这些只是工作得很好的值：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now turn our attention over to the shader portion of this screen effect.
    Open the shader, if you haven''t already, and begin by entering the following
    properties in the `Properties` block:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将注意力转向这个屏幕效果的着色器部分。如果您还没有打开着色器，请打开它，并首先在`Properties`块中输入以下属性：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To make sure that we are passing the data from our `Properties` block to our
    `CGPROGRAM` block, we need to make sure to declare them with the same name in
    the `CGPROGRAM` block:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们从`Properties`块传递数据到`CGPROGRAM`块，我们需要确保在`CGPROGRAM`块中使用相同的名称声明它们：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our effect is also going to include a lens distortion to further convey the
    effect that we are looking through a lens and the edges of the image are being
    distorted by the angle of the lens. Enter the following function just after the
    variable declarations in the `CGPROGRAM` block:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的效果还将包括镜头畸变，以进一步传达我们正在通过镜头看，图像的边缘正被镜头的角度所扭曲。在`CGPROGRAM`块的变量声明之后输入以下函数：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now concentrate on the meat of our `NightVisionEffect` shader. Let''s
    start this by entering the code that is necessary to get the render texture and
    vignette texture. Enter the following code in the `frag()` function of our shader:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于我们的`NightVisionEffect`着色器的核心部分。让我们首先输入获取渲染纹理和晕影纹理所需的代码。在着色器的`frag()`函数中输入以下代码：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next step in our `frag()` function is to process the scan lines and `Noise`
    textures and apply the proper animated UVs to them:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`frag()`函数中的下一步是处理扫描线和`Noise`纹理，并将适当的动画UV应用到它们上：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To complete all of our layers in the screen effect, we simply need to process
    the luminance value of our render texture, and then apply the night vision color
    to it to achieve that iconic night vision look:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成屏幕效果中的所有层，我们只需处理渲染纹理的亮度值，然后将其应用于夜视颜色，以实现标志性的夜视外观：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we will combine all the layers together and return the final color
    of our night vision effect:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有层合并在一起，并返回我们夜视效果的最终颜色：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you have finished entering the code, return to the Unity editor to let
    the script and shader compile. If there are no errors, select the `MainCamera`
    in your scene. Remove the Render Old Film component, if it is there already, and
    add the `RenderNightVision` component. Once there, drag and drop the `ScreenNightVision`
    shader into the Cur Shader property of the component and then assign the Night
    Vision Color property to a green color like the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成代码输入后，返回Unity编辑器，让脚本和着色器编译。如果没有错误，选择场景中的`MainCamera`。如果已经存在，移除`Render Old
    Film`组件，并添加`RenderNightVision`组件。一旦完成，将`ScreenNightVision`着色器拖放到组件的Cur Shader属性中，然后将夜视颜色属性分配为绿色，如下所示：
- en: '![](img/00213.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00213.jpeg)'
- en: 'Afterward, assign the textures to their proper spot:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将纹理分配到它们正确的位置：
- en: '![](img/00214.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00214.jpeg)'
- en: 'Afterward, make sure to play in the editor to see the full, final version of
    the effect:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，确保在编辑器中运行以查看效果的完整最终版本：
- en: '![](img/00215.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00215.jpeg)'
- en: The final result of our night-vision screen effect
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们夜视屏幕效果的最终结果
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The night vision effect is actually very similar to the old film screen effect,
    which shows us just how modular we can make these components. Just by simply swapping
    the textures that we are using for overlays and changing the speed at which our
    tiling rates are being calculated, we can achieve very different results using
    the same code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 夜视效果实际上与老式电影屏幕效果非常相似，这展示了我们可以将这些组件做得多么模块化。只需简单地交换我们用于叠加的纹理，并改变我们的平铺率计算速度，我们就可以使用相同的代码实现非常不同的结果。
- en: The only difference with this effect is the fact that we are including a lens
    distortion to our screen effect. So let's break this down so that we can get a
    better understanding of how it works.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与此效果唯一的区别是我们将镜头畸变效果包含到了屏幕效果中。因此，让我们将其分解，以便更好地理解其工作原理。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is not uncommon in video games to have the need to highlight certain objects.
    For instance, a thermal visor should only apply a post-processing effect to people
    and other sources of heat. Doing this is already possible with the knowledge gathered
    so far in this book; you can, in fact, change the shader or material of an object
    by code. However, this is often laborious and has to be replicated on every the
    object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，需要突出显示某些对象的情况并不少见。例如，热视镜应该只对人和其他热源应用后处理效果。根据本书迄今为止收集的知识，这样做已经可能；实际上，您可以通过代码更改对象的着色器或材质。然而，这通常很费时，并且必须在每个对象上重复。
- en: 'A more effective way to use replaced shaders. Each shader has a tag called
    `RenderType` that has never been used so far. This property can be used to force
    a camera to apply a shader only to certain objects. You can do this by attaching
    the following script to the camera:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换着色器的更有效方法。每个着色器都有一个名为 `RenderType` 的标签，迄今为止从未使用过。此属性可以用来强制相机仅对某些对象应用着色器。您可以通过将以下脚本附加到相机上来实现这一点：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After entering the play mode, the camera will query all the objects that it
    has to render. If they don't have a shader decorated with `RenderType = "Heat"`,
    they will not be rendered. Objects with such a tag will be rendered with the shader
    attached to the script.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进入播放模式后，相机将查询所有需要渲染的对象。如果它们没有装饰有 `RenderType = "Heat"` 的着色器，则不会进行渲染。带有此类标签的对象将使用脚本附加的着色器进行渲染。
