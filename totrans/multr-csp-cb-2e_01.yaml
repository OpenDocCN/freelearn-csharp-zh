- en: Chapter 1. Threading Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the basic tasks to work with threads in C#.
    You will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a thread wait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aborting a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining a thread state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreground and background threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking with a C# lock keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking with a `Monitor` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point of time in the past, the common computer had only one computing
    unit and could not execute several computing tasks simultaneously. However, operating
    systems could already work with multiple programs simultaneously, implementing
    the concept of multitasking. To prevent the possibility of one program taking
    control of the CPU forever, causing other applications and the operating system
    itself to hang, the operating systems had to split a physical computing unit across
    a few virtualized processors in some way and give a certain amount of computing
    power to each executing program. Moreover, an operating system must always have
    priority access to the CPU and should be able to prioritize CPU access to different
    programs. A thread is an implementation of this concept. It could be considered
    as a virtual processor that is given to the one specific program and runs it independently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that a thread consumes a significant amount of operating system resources.
    Trying to share one physical processor across many threads will lead to a situation
    where an operating system is busy just managing threads instead of running programs.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, while it was possible to enhance computer processors, making them
    execute more and more commands per second, working with threads was usually an
    operating system task. There was no sense in trying to compute some tasks in parallel
    on a single-core CPU because it would take more time than running those computations
    sequentially. However, when processors started to have more computing cores, older
    programs could not take advantage of this because they just used one processor
    core.
  prefs: []
  type: TYPE_NORMAL
- en: To use a modern processor's computing power effectively, it is very important
    to be able to compose a program in a way that it can use more than one computing
    core, which leads to organizing it as several threads that communicate and synchronize
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter focus on performing some very basic operations with
    threads in the C# language. We will cover a thread's life cycle, which includes
    creating, suspending, making a thread wait, and aborting a thread, and then, we
    will go through the basic synchronization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the following recipes, we will use Visual Studio 2015 as the main
    tool to write multithreaded programs in C#. This recipe will show you how to create
    a new C# program and use threads in it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A free Visual Studio Community 2015 IDE can be downloaded from the Microsoft
    website and used to run the code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found in the `BookSamples\Chapter1\Recipe1`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in or register to our website using your e-mail address and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Code Downloads & Errata**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the name of the book in the **Search** box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the book for which you're looking to download the code files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose from the drop-down menu where you purchased this book from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Code Download**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR/7-Zip for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipeg/iZip / UnRarX for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7-Zip/PeaZip for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create a new C# program and use threads in it, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the project uses .NET Framework 4.6 or higher; however, the code
    in this chapter will work with previous versions.![How to do it...](img/B05292_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program. The output will be something like the following screenshot:![How
    to do it...](img/B05292_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1 and 2, we created a simple console application in C# using .Net Framework
    version 4.0\. Then, in step 3, we included the `System.Threading` namespace, which
    contains all the types needed for the program. Then, we used the `using static`
    feature from C# 6.0, which allows us to use the `System.Console` type's static
    methods without specifying the type name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of a program that is being executed can be referred to as a process.
    A process consists of one or more threads. This means that when we run a program,
    we always have one main thread that executes the program code.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we defined the `PrintNumbers` method, which will be used in both
    the main and newly created threads. Then, in step 5, we created a thread that
    runs `PrintNumbers`. When we construct a thread, an instance of the `ThreadStart`
    or `ParameterizedThreadStart` delegate is passed to the constructor. The C# compiler
    creates this object behind the scenes when we just type the name of the method
    we want to run in a different thread. Then, we start a thread and run `PrintNumbers`
    in the usual manner on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, there will be two ranges of numbers from 1 to 10 randomly crossing
    each other. This illustrates that the `PrintNumbers` method runs simultaneously
    on the main thread and on the other thread.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to make a thread wait for some time without wasting
    operating system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to make a thread wait without wasting operating system resources,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program is run, it creates a thread that will execute a code in the
    `PrintNumbersWithDelay` method. Immediately after that, it runs the `PrintNumbers`
    method. The key feature here is adding the `Thread.Sleep` method call to a `PrintNumbersWithDelay`
    method. It causes the thread executing this code to wait a specified amount of
    time (2 seconds in our case) before printing each number. While a thread sleeps,
    it uses as little CPU time as possible. As a result, we will see that the code
    in the `PrintNumbers` method, which usually runs later, will be executed before
    the code in the `PrintNumbersWithDelay` method in a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Making a thread wait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how a program can wait for some computation in another
    thread to complete to use its result later in the code. It is not enough to use
    the `Thread.Sleep` method because we don't know the exact time the computation
    will take.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how a program waits for some computation in another thread to
    complete in order to use its result later, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program is run, it runs a long-running thread that prints out numbers
    and waits two seconds before printing each number. But, in the main program, we
    called the `t.Join` method, which allows us to wait for the thread `t` to complete
    working. When it is complete, the main program continues to run. With the help
    of this technique, it is possible to synchronize execution steps between two threads.
    The first one waits until another one is complete and then continues to work.
    While the first thread waits, it is in a `blocked` state (as it is in the previous
    recipe when you call `Thread.Sleep`).
  prefs: []
  type: TYPE_NORMAL
- en: Aborting a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will describe how to abort another thread's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to abort another thread''s execution, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the static `System.Threading.Thread`, add the following code snippet
    below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program and a separate number-printing thread run, we wait for
    six seconds and then call a `t.Abort` method on a thread. This injects a `ThreadAbortException`
    method into a thread, causing it to terminate. It is very dangerous, generally
    because this exception can happen at any point and may totally destroy the application.
    In addition, it is not always possible to terminate a thread with this technique.
    The target thread may refuse to abort by handling this exception by calling the
    `Thread.ResetAbort` method. Thus, it is not recommended that you use the `Abort`
    method to close a thread. There are different methods that are preferred, such
    as providing a `CancellationToken` object to cancel a thread execution. This approach
    will be described in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"),
    *Using a Thread Pool*.
  prefs: []
  type: TYPE_NORMAL
- en: Determining a thread state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe the possible states a thread could have. It is useful
    to get information about whether a thread is started yet or whether it is in a
    blocked state. Note that because a thread runs independently, its state could
    be changed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to determine a thread state and acquire useful information
    about it, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two different threads; one of them
    will be aborted and the other runs successfully. The thread state is located in
    the `ThreadState` property of a `Thread` object, which is a C# enumeration. At
    first, the thread has a `ThreadState.Unstarted` state. Then, we run it and assume
    that for the duration of 30 iterations of a cycle, the thread will change its
    state from `ThreadState.Running` to `ThreadState.WaitSleepJoin`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the current `Thread` object is always accessible through the `Thread.CurrentThread`
    static property.
  prefs: []
  type: TYPE_NORMAL
- en: If this does not happen, just increase the number of iterations. Then, we abort
    the first thread and see that now it has a `ThreadState.Aborted` state. It is
    also possible that the program will print out the `ThreadState.AbortRequested`
    state. This illustrates, very well, the complexity of synchronizing two threads.
    Keep in mind that you should not use thread abortion in your programs. I've covered
    it here only to show the corresponding thread state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can see that our second thread `t2` was completed successfully and
    now has a `ThreadState.Stopped` state. There are several other states, but they
    are partly deprecated and not as useful as those we examined.
  prefs: []
  type: TYPE_NORMAL
- en: Thread priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe the different options for thread priority. Setting
    a thread priority determines how much CPU time a thread will be given.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the workings of thread priority, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two different threads. The first one,
    `threadOne`, has the highest thread priority `ThreadPriority.Highest`, while the
    second one, that is `threadTwo`, has the lowest `ThreadPriority.Lowest` priority.
    We print out the main thread priority value and then start these two threads on
    all available cores. If we have more than one computing core, we should get an
    initial result within two seconds. The highest priority thread should calculate
    more iterations usually, but both values should be close. However, if there are
    any other programs running that load all the CPU cores, the situation could be
    quite different.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this situation, we set up the `ProcessorAffinity` option, instructing
    the operating system to run all our threads on a single CPU core (number 1). Now,
    the results should be very different, and the calculations will take more than
    two seconds. This happens because the CPU core runs mostly the high-priority thread,
    giving the rest of the threads very little time.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is an illustration of how an operating system works with thread
    prioritization. Usually, you should not write programs relying on this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Foreground and background threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe what foreground and background threads are and how
    setting this option affects the program's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the effect of foreground and background threads on a program,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two different threads. By default,
    a thread that we create explicitly is a foreground thread. To create a background
    thread, we manually set the `IsBackground` property of the `threadTwo` object
    to `true`. We configure these threads in a way that the first one will be completed
    faster, and then we run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first thread is complete, the program shuts down and the background
    thread is terminated. This is the main difference between the two: a process waits
    for all the foreground threads to complete before finishing the work, but if it
    has background threads, they just shut down.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to mention that if a program defines a foreground thread
    that does not get completed; the main program does not end properly.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to provide code that we run in another thread
    with the required data. We will go through the different ways to fulfill this
    task and review common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to pass parameters to a thread, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it first creates an object of the `ThreadSample`
    class, providing it with a number of iterations. Then, we start a thread with
    the object's `CountNumbers` method. This method runs in another thread, but it
    uses the number `10`, which is the value that we passed to the object's constructor.
    Therefore, we just passed this number of iterations to another thread in the same
    indirect way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to pass data is to use the `Thread.Start` method by accepting an
    object that can be passed to another thread. To work this way, a method that we
    started in another thread must accept one single parameter of the type `object`.
    This option is illustrated by creating a `threadTwo` thread. We pass `8` as an
    object to the `Count` method, where it is cast to an `integer` type.
  prefs: []
  type: TYPE_NORMAL
- en: The next option involves the use of lambda expressions. A lambda expression
    defines a method that does not belong to any class. We create such a method that
    invokes another method with the arguments needed and start it in another thread.
    When we start the `threadThree` thread, it prints out 12 numbers, which are exactly
    the numbers we passed to it via the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: The use of lambda expressions involves another C# construct named `closure`.
    When we use any local variable in a lambda expression, C# generates a class and
    makes this variable a property of this class. So, actually, we do the same thing
    as in the `threadOne` thread, but we do not define the class ourselves; the C#
    compiler does this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This could lead to several problems; for example, if we use the same variable
    from several lambdas, they will actually share this variable value. This is illustrated
    by the previous example where, when we start `threadFour` and `threadFive`, they
    both print `20` because the variable was changed to hold the value `20` before
    both threads were started.
  prefs: []
  type: TYPE_NORMAL
- en: Locking with a C# lock keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to ensure that when one thread uses some resource,
    another does not simultaneously use it. We will see why this is needed and what
    the thread safety concept is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe9`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use the C# lock keyword, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it first creates an object of the `Counter` class.
    This class defines a simple counter that can be incremented and decremented. Then,
    we start three threads that share the same counter instance and perform an increment
    and decrement in a cycle. This leads to nondeterministic results. If we run the
    program several times, it will print out several different counter values. It
    could be `0`, but mostly won't be.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because the `Counter` class is not thread-safe. When several threads
    access the counter at the same time, the first thread gets the counter value `10`
    and increments it to `11`. Then, a second thread gets the value `11` and increments
    it to `12`. The first thread gets the counter value `12`, but before a decrement
    takes place, a second thread gets the counter value `12` as well. Then, the first
    thread decrements `12` to `11` and saves it into the counter, and the second thread
    simultaneously does the same. As a result, we have two increments and only one
    decrement, which is obviously not right. This kind of a situation is called a
    race condition and is a very common cause of errors in a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that this does not happen, we must ensure that while one thread
    works with the counter, all other threads wait until the first one finishes the
    work. We can use the `lock` keyword to achieve this kind of behavior. If we lock
    an object, all the other threads that require an access to this object will wait
    in a blocked state until it is unlocked. This could be a serious performance issue
    and later, in [Chapter 2](ch02.html "Chapter 2. Thread Synchronization"), *Thread
    Synchronization*, you will learn more about this.
  prefs: []
  type: TYPE_NORMAL
- en: Locking with a Monitor construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe illustrates another common multithreaded error called a deadlock.
    Since a deadlock will cause a program to stop working, the first piece in this
    example is a new `Monitor` construct that allows us to avoid a deadlock. Then,
    the previously described `lock` keyword is used to get a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe10`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the multithreaded error deadlock, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the `LockTooMuch` method. In this method, we just lock the
    first object, wait for a second, and then lock the second object. Then, we start
    this method in another thread and try to lock the second object and then the first
    object from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the `lock` keyword like in the second part of this demo, there will
    be a deadlock. The first thread holds a `lock` on the `lock1` object and waits
    while the `lock2` object gets free; the main thread holds a `lock` on the `lock2`
    object and waits for the `lock1` object to become free, which will never happen
    in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the `lock` keyword is syntactic sugar for the `Monitor` class usage.
    If we were to disassemble code with `lock`, we would see that it turns into the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we can use the `Monitor` class directly; it has the `TryEnter` method,
    which accepts a timeout parameter and returns `false` if this timeout parameter
    expires before we can acquire the resource protected by `lock`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to handle exceptions in other threads properly.
    It is very important to always place a `try/catch` block inside the thread because
    it is not possible to catch an exception outside a thread's code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe11`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the handling of exceptions in other threads, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two threads that will throw an exception.
    One of these threads handles an exception, while the other does not. You can see
    that the second exception is not caught by a `try/catch` block around the code
    that starts the thread. So, if you work with threads directly, the general rule
    is to not throw an exception from a thread, but to use a `try/catch` block inside
    a thread code instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the older versions of .NET Framework (1.0 and 1.1), this behavior was different
    and uncaught exceptions did not force an application shutdown. It is possible
    to use this policy by adding an application configuration file (such as `app.config`)
    that contains the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
