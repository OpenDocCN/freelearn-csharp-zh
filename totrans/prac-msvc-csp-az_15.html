<html><head></head><body>
		<div><h1 id="_idParaDest-350" class="chapter-number"><a id="_idTextAnchor349"/>15</h1>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor350"/>Asynchronous Communication with Messages and Events</h1>
			<p>In the previous chapter, we updated our services using binary communication. However, some services don’t need connected services: the client and the server do not need to be connected at the same time, which means communication can be done asynchronously. This communication can be done by sending messages to a queue or publishing events.</p>
			<p>In this chapter, we’ll use Azure services for asynchronous communication – that is, Azure Queue Storage and Azure Event Hubs. We’ll also use Apache Kafka as an alternative option.</p>
			<p>You’ll learn how to do the following:</p>
			<ul>
				<li>Differentiate message queues and events</li>
				<li>Send and receive messages using a queue</li>
				<li>Publish and subscribe events with Azure Event Hubs</li>
				<li>Use Apache Kafka for event processing</li>
			</ul>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor351"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription and Docker Desktop.</p>
			<p>The code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</a>.</p>
			<p>The <code>ch15</code> folder contains the projects for this chapter, along with their outputs. To add the functionality from this chapter, you can start with the source code from the previous chapter.</p>
			<p>We’ll be considering the following projects in this chapter:</p>
			<ul>
				<li><code>Codebreaker.AppHost</code>: The .NET Aspire host project. The app model has been enhanced by adding Azure Storage, Azure Event Hubs, and Apache Kafka services.</li>
				<li><code>Codebreaker.BotQ</code>: This is a new project that contains nearly the same code as <code>Codebreaker.Bot</code>. However, instead of using a REST API to trigger gameplay, a message queue is used.</li>
				<li><code>Codebreaker.GameAPIs</code>: This project has been updated so that it doesn’t forward completed games to <code>live-service</code> directly. Instead, it publishes events to Azure Event Hubs or Apache Kafka depending on the launch profile startup.</li>
				<li><code>Codebreaker.Live</code>: This project has been changed so that it subscribes to events from Azure Event Hubs using async streams. The SignalR implementation has also been changed so that it uses async streams.</li>
				<li><code>Codebreaker.Ranking</code>: This is a new project that receives events from Azure Event Hubs or Kafka, writes this information to an Azure Cosmos DB database, and offers a REST service to retrieve the rank of the day. With Event Hub, we have a different way to receive events than we do when using <code>live-service</code>.</li>
			</ul>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor352"/>Comparing messages and events</h1>
			<p>In the previous chapter, we used<a id="_idIndexMarker1118"/> connected network communication<a id="_idIndexMarker1119"/> with all the services. First, we look into the communication between the bot and the game APIs as shown in <em class="italic">Figure 15</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B21217_15_01.jpg" alt="Figure 15.1 - Synchronous communication between the bot and the game APIs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 - Synchronous communication between the bot and the game APIs</p>
			<p>The bot service can be accessed<a id="_idIndexMarker1120"/> via REST. The bot service itself invokes the game<a id="_idIndexMarker1121"/> APIs service via gRPC (all other clients use REST with the game APIs service). The bot service then continues communication with the game APIs service, sends moves until the game is complete, and continues with the next game until a specified number of games is played. The bot client invokes the bot service via REST which is (like gRPC) synchronous communication, with request/reply. The bot service here doesn’t have a synchronous implementation, as the bot client doesn’t need to wait until all the games are played – the HTTP protocol would timeout during this time. Instead, the bot service returns an HTTP <code>ACCEPTED</code> answer (status code 202) with a unique identifier which can be used by the client to check for a status. The protocol itself is synchronous, as the client waits for answer 202.</p>
			<p>When a game ends, the next part of the communication is shown with <em class="italic">Figure 15</em><em class="italic">.2</em>.</p>
			<div><div><img src="img/B21217_15_02.jpg" alt="Figure 15.2 - Synchronous communication initiated from the game APIs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 - Synchronous communication initiated from the game APIs</p>
			<p>The game APIs service informs<a id="_idIndexMarker1122"/> the ranking service and the live service<a id="_idIndexMarker1123"/> using gRPC. The live service continues communication via SignalR to inform all connected clients about the game end. The ranking service will be implemented in this chapter to write all ended games to a new database. To simplify this image, some services that are used within the communication are not shown. There’s synchronous communication between the game APIs and Azure Cosmos DB, similar to the ranking service.</p>
			<p>With synchronous communication, if there’s a delay in one of the services, the delay goes back to the original caller. If there’s an error in one of the services, the client does not receive a successful response.</p>
			<p>Microsoft Azure offers several services that can be used to create asynchronous communication: Azure Queue Storage, the Azure Service Bus, Azure Event Gird, and Azure Event Hub. Let’s have a look at a new version of the new sequence with the communication with the bot client and the bot service in <em class="italic">Figure 15</em><em class="italic">.3</em>.</p>
			<div><div><img src="img/B21217_15_03.jpg" alt="Figure 15.3 - Asynchronous communication between the bot client and the bot service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 - Asynchronous communication between the bot client and the bot service</p>
			<p>With the new implementation<a id="_idIndexMarker1124"/> the Azure Queue Storage comes into play. The bot service<a id="_idIndexMarker1125"/> registers with the queue to receive messages. The bot client, instead of using HTTP to communicate with the bot service, sends a message to the queue. The bot client does not need to wait if anybody started to work on this message. For the client, the job is done. The bot service, because it registered to receive messages, receives the message from the queue and plays the games in the same way as before, this doesn’t change.</p>
			<p>Next, we look at the asynchronous communication initiated by the game APIs service in <em class="italic">Figure 15</em><em class="italic">.4</em>.</p>
			<div><div><img src="img/B21217_15_04.jpg" alt="Figure 15.4 – Asynchronous communication initiated from the game APIs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – Asynchronous communication initiated from the game APIs</p>
			<p>Here, the Azure Event Hub comes<a id="_idIndexMarker1126"/> into play. The game APIs service, instead<a id="_idIndexMarker1127"/> of doing synchronous communication both with the ranking and the live services, just communicates with the event hub. A game-ended event is pushed to this service. The game APIs doesn’t need to know who is interested in this event, who is receiving this event. Here, two subscribers, the ranking service and the live service are registered, and receive this event. From here on, communication is the same as before. The ranking service writes the received information to a database (which is not shown), and the live service forwards this information to clients that are subscribed to the live service – if they are subscribed to the same game type that is stored with the event.</p>
			<p>The important difference between using message queues and events can be seen in this scenario. When sending a message to a queue, just one receiver deals with the message. Multiple readers can be connected to the same queue (for performance reasons), but only one reader processes the message. If the message is processed successfully, it’s removed from the queue. With<a id="_idIndexMarker1128"/> events, multiple subscribers receive and process<a id="_idIndexMarker1129"/> the same event.</p>
			<p>Let’s look at the different options that are available with Microsoft Azure for messages and events.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor353"/>Message queues</h2>
			<p>Microsoft Azure offers Azure<a id="_idIndexMarker1130"/> Queue Storage (part of the Azure Storage Account) and Service Bus queues that can be used for queuing messages. Azure Queue Storage is the simpler and cheaper option to use, but Azure Service Bus offers a lot more features, such as ordering guarantees, atomic operations, sending messages in a batch, duplicate detection, and more. See <a href="https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted">https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted</a> for details.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor354"/>Events</h2>
			<p>To publish and subscribe<a id="_idIndexMarker1131"/> to events, you can use Azure Event Grid and Azure Event Hubs. <strong class="bold">Azure Event Grid</strong> is easy to use to subscribe to events<a id="_idIndexMarker1132"/> with most Azure resources. In the Azure portal, with most resources, you can see the <strong class="bold">Events</strong> menu in the left bar. For example, when opening an Azure Storage Account, after clicking on <strong class="bold">Events</strong>, click <strong class="bold">Event Subscription</strong>. With a storage account, you’ll see event types such as <strong class="bold">Blob Created</strong>, <strong class="bold">Blob Deleted</strong>, <strong class="bold">Blob Renamed</strong>, <strong class="bold">Directory Created</strong>, <strong class="bold">Directory Deleted</strong>, <strong class="bold">Directory Renamed</strong>, <strong class="bold">Blob Tier Changed</strong>, and others, as shown in <em class="italic">Figure 15</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B21217_15_05.jpg" alt="Figure 15.5 – Create Event Subscription"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – Create Event Subscription</p>
			<p>Event types are predefined by Azure resources. With event subscriptions, you can specify where the event should be fired. You can choose this with the endpoint, which can be an Azure function, a storage queue, a hybrid connection, a Webhook, and so on.</p>
			<p>Event Grid also allows you to specify custom topics to be defined, high throughput with up to 10,000,000 events per second, and 100,000 operations a month for free. This service is available as a PaaS<a id="_idIndexMarker1133"/> offering running on Azure with the name <strong class="bold">Event Grid on Kubernetes with Azure Arc</strong> on Kubernetes.</p>
			<p>To support even more events, massive scaling with partitions, and a big data<a id="_idIndexMarker1134"/> streaming platform with low latency, <strong class="bold">Azure Event Hubs</strong> can be used. This service offers reliable event delivery where events are stored for up to 7 days in case they have not been delivered. Event Hubs also has great integration with streaming analytics.</p>
			<p>Let’s update the Codebreaker<a id="_idIndexMarker1135"/> solution with Azure Queues and Azure Event Hubs.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, .NET Aspire has planned support with Azure Event Grid. Event Hubs, Queue Storage, and Azure Service Bus are already available.</p>
			<p>Let’s start reading from Azure Queue Storage with the Codebreaker bot service.</p>
			<h1 id="_idParaDest-356"><a id="_idTextAnchor355"/>Creating a service that reads from Azure Queue Storage</h1>
			<p>The <code>Codebreaker.Bot</code> project we used<a id="_idIndexMarker1136"/> previously offers a minimal API service. With the updates, a REST API isn’t needed – a simple console application will do. Just create a new console application (<code>dotnet new console -o Codebreaker.BotQ</code>) and copy the source code from <code>Codebreaker.Bot</code>. The new bot will also use gRPC for communication with the game APIs service. Because this isn’t an ASP.NET Core application, these NuGet packages are needed for gRPC:</p>
			<ul>
				<li><code>Google.Protobuf</code></li>
				<li><code>Grpc.Net.ClientFactory</code></li>
				<li><code>Grpc.Tools</code></li>
			</ul>
			<p>For the DI container, we also need <code>Microsoft.Extensions.Hosting</code>, and for the .NET Aspire Storage<a id="_idIndexMarker1137"/> Queues component, we need <code>Aspire.Azure.Storage.Queues</code>.</p>
			<p>Next, we’ll update the app model.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor356"/>Defining app-model for Azure Storage</h2>
			<p>With the AppHost<a id="_idIndexMarker1138"/> project, reference<a id="_idIndexMarker1139"/> the newly created project, <code>Codebreaker.BotQ</code>, and add the <code>Aspire.Hosting.Azure.Storage</code> NuGet package so that you can use the Azure Storage resource.</p>
			<p>Invoke the <code>AddAzureStorage</code> method to specify Azure Storage with the app model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">// code removed for brevity</strong>
if (startupMode == "OnPremises")
{
}
else
{
<strong class="bold">  var storage = builder.AddAzureStorage("storage");</strong>
<strong class="bold">  var botQueue = storage.AddQueues("botqueue");</strong>
<strong class="bold">}</strong></pre>
			<p>The Azure Storage resource supports queues, tables, and blobs. This time, we’ll use queues, hence why we’re invoking the <code>AddQueues</code> extension method.</p>
			<p>The project configuration references the queue:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">string botLoop =</strong>
<strong class="bold">  builder.Configuration.GetSection("Bot")["Loop"] ??</strong>
<strong class="bold">    "false";</strong>
<strong class="bold">string botDelay =</strong>
<strong class="bold">  builder.Configuration.GetSection("Bot")["Delay"] ??</strong>
<strong class="bold">    "1000";</strong>
<strong class="bold">// code removed for brevity</strong>
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_BotQ&gt;("bot")</strong>
<strong class="bold">  .WithReference(insights)</strong>
<strong class="bold">  </strong><strong class="bold">.WithReference(botQueue)</strong>
<strong class="bold">  .WithReference(gameAPIs)</strong>
<strong class="bold">  .WithEnvironment("Bot__Loop", botLoop)</strong>
<strong class="bold">  .WithEnvironment("Bot__Delay", botDelay);</strong></pre>
			<p>Pay attention to using<a id="_idIndexMarker1140"/> the new bot project<a id="_idIndexMarker1141"/> instead of the old one. The new project references the queue to pass the connection string. In addition, we specify the <code>Loop</code> and <code>Delay</code> parameters, which are read from the configuration and set as environment variables on starting <code>bot-service</code>.</p>
			<p>These values are specified within the AppHost development configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/appsettings.Development.json</p>
			<pre class="source-code">
{
  // configuration removed for brevity
<strong class="bold">  "Bot": {</strong>
<strong class="bold">    "Loop": true,</strong>
<strong class="bold">    "Delay": 2000</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>The new <code>bot-service</code> can read values from the storage queue in a loop – which is configured here. When published <a id="_idIndexMarker1142"/>with Azure, the loop<a id="_idIndexMarker1143"/> isn’t needed. This will be covered later in the <em class="italic">Deploying the solution to Microsoft </em><em class="italic">Azure</em> section.</p>
			<p>Now that the app model has been specified, let’s continue with the new bot project.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor357"/>Using the storage queue component</h2>
			<p>With the previous bot<a id="_idIndexMarker1144"/> project, we received<a id="_idIndexMarker1145"/> values so that we could start playing a sequence of games. The same information is needed with the new bot:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
public record class BotMessage(
  int Count, int Delay, int ThinkTime);</pre>
			<p>The <code>Count</code> property is for the number of games to play, the <code>Delay</code> property is for the delay between games, and the <code>ThinkTime</code> property is for the value of the think time between game moves.</p>
			<p>The <code>BotQueueClientOptions</code> class is used to receive the configuration values that are passed from the AppHost:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
// code removed for brevity
public class BotQueueClientOptions
{
  public bool Loop { get; set; } = false;
  public int Delay { get; set; } = 1000;
}</pre>
			<p>Within the constructor of the <code>BotQueueClient</code> class, <code>options</code>, <code>logger</code>, the previously used <code>CodebreakerTimer</code>, and <code>QueueServiceClient</code> are injected:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
public class BotQueueClient(
<strong class="bold">  QueueServiceClient client,</strong>
<strong class="bold">  CodebreakerTimer timer,</strong>
  ILogger&lt;BotQueueClient&gt; logger,
  <strong class="bold">IOptions&lt;BotQueueClientOptions&gt; options</strong>)
{
// code removed for brevity</pre>
			<p>The <code>QueueService</code> client class<a id="_idIndexMarker1146"/> is from the <code>Azure.Storage.Queues</code> namespace and communicates<a id="_idIndexMarker1147"/> with the Azure Storage queue resources to get information about queues, as well as to create queues. With the implementation of <code>CodebreakerTimer</code>, a timer is used to play game after game. It uses the values we receive in the message from the queue.</p>
			<p>The <code>RunAsync</code> method kicks off the work:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
public async Task RunAsync()
{
<strong class="bold">  var queueClient = client.GetQueueClient(«botqueue»);</strong>
<strong class="bold">  await queueClient.CreateIfNotExistsAsync();</strong>
<strong class="bold">  var deadLetterClient = client.GetQueueClient(</strong>
<strong class="bold">    «dead-letter»);</strong>
<strong class="bold">  await deadLetterClient.CreateIfNotExistsAsync();</strong>
  bool repeat = options.Value.Loop;
  do
  {
<strong class="bold">    await ProcessMessagesAsync(</strong>
<strong class="bold">    queueClient, deadLetterClient);</strong>
    await Task.Delay(options.Value.Delay);
  } while (repeat);
}
// code removed for brevity</pre>
			<p>To read messages<a id="_idIndexMarker1148"/> from the queue, we use the <code>QueueClient</code> class. The <code>QueueServiceClient</code> method, <code>GetQueueClient</code>, returns <code>QueueClient</code> to communicate<a id="_idIndexMarker1149"/> with the queue named <code>botqueue</code>. With the app model we specified earlier, only the storage account is created, not the queue itself. We create the queue if it doesn’t already exist. Then – in a loop – we invoke <code>ProcessMessagesAsync</code>. If the loop isn’t set, messages are retrieved only once. This can be used when publishing Azure Container Apps jobs, as will be discussed in the <em class="italic">Deploying the solution to Microsoft </em><em class="italic">Azure</em> section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A dead letter queue can be checked to find out if there have been issues with messages. When a message cannot be successfully processed a few times, for example, when the receiver throws, the message is written to the dead letter queue.</p>
			<p>Next, <code>ProcessMessageAsync</code> reads a message from the queue:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
private async Task ProcessMessagesAsync(
  <strong class="bold">QueueClient queueClient,</strong>
<strong class="bold">  QueueClient deadLetterClient</strong>)
{
<strong class="bold">  QueueProperties properties =</strong>
<strong class="bold">    await queueClient.GetPropertiesAsync();</strong>
  if (<strong class="bold">properties.ApproximateMessagesCount &gt; 0</strong>)
  {
<strong class="bold">    QueueMessage[] messages =</strong>
<strong class="bold">      await queueClient.ReceiveMessagesAsync();</strong>
    foreach (var encodedMessage in messages)
    {
      if (<strong class="bold">encodedMessage.DequeueCount &gt; 3</strong>)
      {
<strong class="bold">        await deadLetterClient.SendMessageAsync(</strong>
<strong class="bold">          encodedMessage.MessageText);</strong>
<strong class="bold">        await queueClient.DeleteMessageAsync(</strong>
<strong class="bold">          encodedMessage.MessageId,</strong>
<strong class="bold">          encodedMessage.PopReceipt);</strong>
        continue;
      }
      byte[] bytes = Convert.FromBase64String(
        encodedMessage.MessageText);
<strong class="bold">      string message = Encoding.UTF8.GetString(bytes);</strong>
<strong class="bold">      var botMessage =</strong>
<strong class="bold">        JsonSerializer.Deserialize&lt;BotMessage&gt;(message);</strong>
<strong class="bold">      timer.Start(</strong>
<strong class="bold">        botMessage.Delay,</strong>
<strong class="bold">        botMessage.Count,</strong>
<strong class="bold">        botMessage.ThinkTime);</strong>
<strong class="bold">      await queueClient.DeleteMessageAsync(</strong>
<strong class="bold">        encMessage.MessageId, encMessage.PopReceipt);</strong>
    }
  }
}
// code removed for brevity</pre>
			<p>First, attributes of the queue are checked to see if there’s a message available using the <code>ApproximateMessagesCount</code> property. If this is the case, messages are retrieved using <code>ReceiveMessagesAsync</code>. This method reads the messages from the queue, at which point the messages can no longer be seen by others. The time the message is not visible can be set with the <code>visibilityTimeout</code> parameter. The default is 30 seconds. When successfully deserializing the message, it is deleted using <code>DeleteMessageAsync</code>. The <code>timer.Start</code> method starts a task to play the games asynchronously. So, if a game takes longer to play (with many games or with higher think times), this does not influence deleting the message. If the message returns to the queue, it can be processed again. The implementation<a id="_idIndexMarker1150"/> checks for the dequeue count of the message that’s retrieved. If it’s read three times, the message goes to a dead-letter queue and can be manually<a id="_idIndexMarker1151"/> checked for issues.</p>
			<p>Next, let’s configure the DI container:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
<strong class="bold">  builder.AddAzureQueueClient("botqueue");</strong>
<strong class="bold">  builder.Services.AddScoped&lt;BotQueueClient&gt;();</strong>
<strong class="bold">  var botConfig = builder.Configuration.GetSection("Bot");</strong>
<strong class="bold">  </strong><strong class="bold">builder.Services.Configure&lt;BotQueueClientOptions&gt;(</strong>
<strong class="bold">    section);</strong>
  builder.Services.AddScoped&lt;CodebreakerTimer&gt;();
  builder.Services.AddScoped&lt;CodebreakerGameRunner&gt;();
  builder.Services.AddSingleton&lt;IGamesClient,
    GrpcGamesClient&gt;()
    .AddGrpcClient&lt;GrpcGame.GrpcGameClient&gt;(
      client =&gt;
      {
        client.Address = new Uri("https://gameapis");
      });
}</pre>
			<p>The <code>AddAzureQueueClient</code> method is defined with the <code>Aspire.Azure.Storage.Queues</code> NuGet package. This method configures the Aspire component and registers the <code>QueueService</code> client with the DI container. With the environment variables passed by the AppHost, these values are retrieved using <code>builder.Configuration.GetSection</code> and configured<a id="_idIndexMarker1152"/> with the <code>BotQueueClientOptions</code> class, which defines the loop’s behavior. Other than this, the timer, game runner, and gRPC are configured<a id="_idIndexMarker1153"/> in the same way as the previous bot service implementation.</p>
			<p>Now, we are ready to run the application and test queues.</p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor358"/>Running the application</h2>
			<p>You can set breakpoints<a id="_idIndexMarker1154"/> within the new bot service project to verify the functionality of the queue. When you start the application, an Azure Storage Account is created. With the initialization of <code>BotQueueClient</code>, message queues are created. This can verified in the Azure portal, as shown in <em class="italic">Figure 15</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/B21217_15_06.jpg" alt="Figure 15.6 – Storage queues created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – Storage queues created</p>
			<p>The <code>botqueue</code> and <code>dead-letter</code> storage queues<a id="_idIndexMarker1155"/> have been created. Now, open <code>botqueue</code> to pass a valid JSON message, as shown in <em class="italic">Figure 15</em><em class="italic">.7</em>:</p>
			<div><div><img src="img/B21217_15_07.jpg" alt="Figure 15.7 – Add message to queue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – Add message to queue</p>
			<p><code>BotMessage</code> class:</p>
			<pre class="source-code">
{
  "Count": 3,
  "Delay": 5,
  "ThinkTime": 1
}</pre>
			<p>With a valid JSON message, you will see that the message is processed. After sending a message that’s not in JSON<a id="_idIndexMarker1157"/> format, you’ll see the message in the dead-letter queue – after some retries.</p>
			<p>As the bot now starts playing games when we send messages, let’s get into the next enhancement – using Azure Event Hubs.</p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor359"/>Publishing messages to Azure Event Hubs</h1>
			<p>To use Azure Event Hubs, we’ll implement<a id="_idIndexMarker1158"/> the game APIs service<a id="_idIndexMarker1159"/> so that we can publish events.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor360"/>Defining app-model for Event Hubs</h2>
			<p>To use Azure Event Hubs<a id="_idIndexMarker1160"/> with the AppHost project, the <code>Aspire.Hosting.Azure.EventHubs</code> NuGet package<a id="_idIndexMarker1161"/> is required.</p>
			<p>Here, Event Hubs needs to be added to the app model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var eventHub =
  <strong class="bold">builder.AddAzureEventHubs("codebreakerevents")</strong>
<strong class="bold">    .AddEventHub("games");</strong>
// code removed for brevity</pre>
			<p>The <code>AddAzureEventHubs</code> method, adds an Azure Event Hubs namespace, <code>AddEventHub</code>, as an event hub. A namespace is a management container with network endpoints and access control. The default Event Hub namespace that’s created is in the Standard tier. For development, you can change this to the Basic tier. Event hubs are created within namespaces. For scalability, event hubs use one or more partitions. By default, the event hub is created with four partitions. A partition contains an ordered stream of events. The number of partitions doesn’t change the price, but the number of throughput units does. With the number of throughput units, you specify a number of events per second. The number of partitions should be equal to or higher than the number of throughput units. Throughput units can be changed as needed; the number of partitions can only be changed in premium and dedicated tiers.</p>
			<p>With the event hub specified, we can reference it:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var gameAPIs =</strong>
<strong class="bold">  </strong><strong class="bold">builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;(</strong>
<strong class="bold">    "gameapis")</strong>
    .WithExternalHttpEndpoints()
    .WithReference(cosmos)
    .WithReference(redis)
    .WithReference(insights)
<strong class="bold">    .WithReference(eventHub)</strong>
    .WithEnvironment("DataStore", dataStore);</pre>
			<p>With the game APIs service, we replace<a id="_idIndexMarker1162"/> the referenced live service<a id="_idIndexMarker1163"/> with the event hub. The reference to live service is no longer needed.</p>
			<p>With this, we can look at the game APIs service.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor361"/>Using the .NET Aspire Event Hubs component to produce events</h2>
			<p>To use the .NET Aspire Event Hubs<a id="_idIndexMarker1164"/> component, we must<a id="_idIndexMarker1165"/> add the <code>Aspire.Azure.Messaging.EventHub</code> NuGet package.</p>
			<p>Using this package, we can configure the DI container:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
<strong class="bold">  builder.AddAzureEventHubProducerClient(</strong>
<strong class="bold">    "codebreakerevents",settings =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">      </strong><strong class="bold">settings.EventHubName = "games";</strong>
<strong class="bold">    });</strong></pre>
			<p>From the game APIs service, to send<a id="_idIndexMarker1166"/> information about completed<a id="_idIndexMarker1167"/> games, in previous chapters, we created the <code>LiveReportClient</code> class to call a REST service and the <code>GrpcLiveReportClient</code> class to invoke a gRPC service. Now, we can implement the same interface we used earlier – <code>IGameReport</code> with the <code>EventHubReportProducer</code> class.</p>
			<p>Sending events can easily be done, as shown here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/EventHubReportProducer.cs</p>
			<pre class="source-code">
<strong class="bold">public class EventHubReportProducer(</strong>
<strong class="bold">  EventHubProducerClient producerClient,</strong>
<strong class="bold">  ILogger&lt;EventHubLiveReportClient&gt; logger) :</strong>
<strong class="bold">  IGameReport</strong>
<strong class="bold">{</strong>
<strong class="bold">  public async Task ReportGameEndedAsync(</strong>
<strong class="bold">    GameSummary game,</strong>
<strong class="bold">    CancellationToken cancellationToken = default)</strong>
<strong class="bold">  {</strong>
<strong class="bold">    var data = BinaryData.FromObjectAsJson(game);</strong>
<strong class="bold">    await producerClient.SendAsync(</strong>
<strong class="bold">      [ new EventData(data) ],</strong>
<strong class="bold">      cancellationToken);</strong>
<strong class="bold">    // code removed for brevity</strong>
<strong class="bold">  }</strong>
<strong class="bold">}</strong></pre>
			<p>The <code>EventHubReportProducer</code> class injects the <code>EventHubProducerClient</code> class to send events to the event hub. <code>GameSummary</code> is converted into <code>BinaryData</code> with <code>BinaryData.FromObjectAsJson</code>. The <code>EventData </code>class from the <code>Azure.Messaging.EventHubs</code> namespace allows us to pass a string, <code>BinaryData</code>, and <code>ReadOnlyMemory&lt;byte&gt;</code>. Then, the event<a id="_idIndexMarker1168"/> is published by invoking<a id="_idIndexMarker1169"/> the <code>SendAsync</code> method.</p>
			<p>Now that we’ve published some events, let’s subscribe to them.</p>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor362"/>Subscribing to Azure Event Hubs events</h1>
			<p>The <code>Codebreaker.Live</code> project previously<a id="_idIndexMarker1170"/> offered a gRPC service that was invoked by the game APIs service to publish completed games via SignalR. Instead of offering a gRPC service, we can subscribe to events.</p>
			<p>Create a new <code>Codebreaker.Ranking</code> project so that you can offer minimal APIs. This project will receive the same events as <code>Codebreaker.Live</code> but write them to a database to offer ranks for games based on days, weeks, and months.</p>
			<p>To create the <code>Codebreaker.Ranking</code> project, use the following command:</p>
			<pre class="console">
dotnet new webapi -minimal -o Codebreaker.Ranking</pre>
			<p>Add the newly created project as a reference to <code>Codebreaker.AppHost</code>, and reference <code>Codebreaker.ServiceDefaults</code> to configure the service defaults. Now, we can update app model.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor363"/>Defining app-model for Event Hubs subscribers</h2>
			<p>With the AppHost<a id="_idIndexMarker1171"/> project, the live and ranks<a id="_idIndexMarker1172"/> projects reference the event hub, similar to the events publishing project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var storage = builder.AddAzureStorage("storage");
<strong class="bold">var blob = storage.AddBlobs("checkpoints");</strong>
var live =
  builder.AddProject&lt;Projects.Codebreaker_Live&gt;("live")
  .WithExternalHttpEndpoints()
  .WithReference(insights)
<strong class="bold">  .WithReference(eventHub)</strong>
  .WithReference(signalR);
builder.AddProject&lt;Projects.Codebreaker_Ranking&gt;("ranking")
  .WithExternalHttpEndpoints()
  .WithReference(cosmos)
  .WithReference(insights)
<strong class="bold">  .WithReference(eventHub)</strong>
<strong class="bold">  .WithReference(blob);</strong>
// code removed for brevity</pre>
			<p>Subscribing to events can be done<a id="_idIndexMarker1173"/> in two ways, either with the event<a id="_idIndexMarker1174"/> hub consumer client or the event processor client. The event hub consumer client is simpler to use and supports async streams. The event processor client is more powerful and supports receiving from multiple partitions in parallel. The second option needs to save checkpoints in an Azure blob storage account. We use the same account that we already use for queues.</p>
			<p>We will implement both versions. The Codebreaker live service uses async streams, and the event hub consumer client with the class <code>EventHubConsumerClient</code> fits its need. The Codebreaker ranking<a id="_idIndexMarker1175"/> service makes use of the event<a id="_idIndexMarker1176"/> processor client, using <code>EventProcessorClient</code>.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor364"/>Using the Event Hubs component with async streaming</h2>
			<p>When using<a id="_idIndexMarker1177"/> the <code>Codebreaker.Live</code> project, references<a id="_idIndexMarker1178"/> to the <code>Aspire.Azure.Messaging.EventHubs</code> NuGet package are required:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>Codebreaker.Live</code> project was created in <a href="B21217_13.xhtml#_idTextAnchor317"><em class="italic">Chapter 13</em></a>. Here, we’ll create a new SignalR hub to offer streaming.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  builder.Services.AddSignalR()
    .AddMessagePackProtocol()
    .AddNamedAzureSignalR("signalr");
<strong class="bold">   builder.AddAzureEventHubConsumerClient("codebreakerevents",</strong>
<strong class="bold">  settings =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    </strong><strong class="bold">settings.EventHubName = "games";</strong>
<strong class="bold">  });</strong>
}</pre>
			<p>The <code>AddAzureEventHubConsumerClient</code> method configures the <code>EventHubConsumerClient</code> class as a singleton within the DI container.</p>
			<p>Now, we must create a new SignalR hub to inject <code>EventHubConsumerClient</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/StreamingLiveHub.cs</p>
			<pre class="source-code">
public class StreamingLiveHub(
<strong class="bold">  EventHubConsumerClient consumerClient,</strong>
  ILogger&lt;StreamingLiveHub&gt; logger) : Hub
{
  // code removed for brevity</pre>
			<p>By using the primary <a id="_idIndexMarker1179"/>constructor, <code>EventHubConsumerClient</code> is injected<a id="_idIndexMarker1180"/> to retrieve the events.</p>
			<p>Now, create the <code>SubscribeToGameCompletions</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/StreamingLiveHub.cs</p>
			<pre class="source-code">
<strong class="bold">public async IAsyncEnumerable&lt;GameSummary&gt;</strong>
<strong class="bold">  SubscribeToGameCompletions(</strong>
<strong class="bold">    string gameType,</strong>
<strong class="bold">    [EnumeratorCancellation] CancellationToken</strong>
<strong class="bold">      cancellationToken)</strong>
{
<strong class="bold">  await foreach (PartitionEvent ev in</strong>
<strong class="bold">    consumerClient.ReadEventsAsync(cancellationToken))</strong>
  {
    GameSummary gameSummary;
    try
    {
<strong class="bold">      logger.ProcessingGameCompletionEvent();</strong>
<strong class="bold">      gameSummary = ev.Data.EventBody</strong>
<strong class="bold">        .ToObjectFromJson&lt;GameSummary&gt;();</strong>
    }
    catch (Exception ex)
    {
      logger.ErrorProcessingGameCompletionEvent(
        ex, ex.Message);
      continue;
    }
      if (gameSummary.GameType == gameType)
      {
<strong class="bold">        yield return gameSummary;</strong>
      }
      else
      {
<strong class="bold">        continue;</strong>
      }
    }
  }</pre>
			<p>SignalR supports async streaming<a id="_idIndexMarker1181"/> with methods<a id="_idIndexMarker1182"/> returning <code>IAsyncEnumerable</code>. The <code>SubscribeToGameCompletions</code> method receives a game type parameter that only returns game completions of this game type. <code>EventHubConsumerClient</code> supports async streaming by invoking the <code>ReadEventsAsync</code> method. If the received game summary is of the requested game type, it’s returned to the client via the async stream.</p>
			<p>At this point, the middleware needs to be configured so that it references the new hub:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
app.MapHub&lt;LiveHub&gt;("/livesubscribe");
<strong class="bold">app.MapHub&lt;StreamingLiveHub&gt;("/streaminglivesubscribe");</strong></pre>
			<p>We also need to update<a id="_idIndexMarker1183"/> the client by using async streaming<a id="_idIndexMarker1184"/> and the new link:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/StreamingLiveClient.cs</p>
			<pre class="source-code">
public async Task SubscribeToGame(string gameType, CancellationToken cancellationToken = default)
{
  if (_hubConnection is null) throw new InvalidOperationException("Start a connection first!");
  try
  {
<strong class="bold">    await foreach (GameSummary summary in</strong>
<strong class="bold">      _hubConnection.StreamAsync&lt;GameSummary&gt;(</strong>
<strong class="bold">        "SubscribeToGameCompletions",</strong>
<strong class="bold">        gameType,</strong>
<strong class="bold">        cancellationToken))</strong>
    {
      string status = summary.IsVictory ? "won" : "lost";
      Console.WriteLine($"Game {summary.Id} {status} " +
        $"by {summary.PlayerName} after " +
        $"{summary.Duration:g} with " +
        $"{summary.NumberMoves} moves");
    }
  }
  catch (HubException ex)
  {
    logger.LogError(ex, ex.Message);
    throw;
  }
  catch (OperationCanceledException ex)
  {
    logger.LogWarning(ex.Message);
  }
}</pre>
			<p>With the same SignalR initialization configuration we created in <a href="B21217_13.xhtml#_idTextAnchor317"><em class="italic">Chapter 13</em></a>, the client now uses the <code>StreamAsync</code> method from the SignalR <code>HubConnection</code> class to async stream the results that are returned from the service.</p>
			<p>With these changes, you can already<a id="_idIndexMarker1185"/> test and run the solution, starting<a id="_idIndexMarker1186"/> from the message queue up to the SignalR streaming client, to receive completed games. However, let’s add another Event Hubs client to process messages, this time with the Event Hubs processor.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor365"/>Using the .NET Aspire Event Hubs component to process messages</h2>
			<p>The <code>Codebreaker.Ranking</code> project receives<a id="_idIndexMarker1187"/> events, writes those events<a id="_idIndexMarker1188"/> to an Azure Cosmos database, and offers minimal APIs to get ranking<a id="_idIndexMarker1189"/> information from the players. This project references<a id="_idIndexMarker1190"/> the .NET Aspire <code>Aspire.Azure.Messaging.EventHubs</code> and <code>Aspire.Azure.Storage.Blobs</code> components:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  // code removed for brevity
<strong class="bold">  builder.AddKeyedAzureBlobClient("checkpoints");</strong>
  <strong class="bold">builder.AddAzureEventProcessorClient("codebreakerevents",</strong>
<strong class="bold">    settings =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">      settings.EventHubName = "games";</strong>
<strong class="bold">      settings.BlobClientServiceKey = "checkpoints";</strong>
<strong class="bold">    });</strong>
  <strong class="bold">builder.Services.AddDbContextFactory&lt;RankingsContext&gt;(</strong>
<strong class="bold">    options =&gt;</strong>
    {
      string connectionString =
        builder.Configuration.GetConnectionString(
          "codebreakercosmos") ??
          throw new InvalidOperationException(
            "Could not read the Cosmos connection-string");
      options.UseCosmos(connectionString, "codebreaker");
    });
  builder.EnrichCosmosDbContext&lt;RankingsContext&gt;();
  <strong class="bold">builder.Services</strong>
<strong class="bold">    .AddSingleton&lt;IGameSummaryEventProcessor,</strong>
<strong class="bold">      GameSummaryEventProcessor&gt;();</strong>}</pre>
			<p><code>AddAzureEventProcessorClient</code> registers a singleton instance of the <code>EventProcessorClient</code> class. We connect to the same namespace and event hub, so this configuration is the same. What’s different is that <code>AddKeyedAzureBlobClient</code> is a method from the .NET Aspire Blob Storage component. This method registers a singleton instance with the DI container to read and write blobs. The storage is connected to the event hub by setting <code>BlobClientServiceKey</code> to write checkpoints.</p>
			<p>You can also simplify the configuration by not registering a keyed configuration. The one default storage component that’s registered is automatically used from the event hub component.</p>
			<p>Other than the event hub<a id="_idIndexMarker1191"/> configuration, an EF Core <a id="_idIndexMarker1192"/>context must be configured to write the received game summary information to an Azure Cosmos DB database. Check out <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a> for more details. Contrary to <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, we register an EF Core context factory with the DI container, which allows us to inject this into a singleton object and create the context objects with a shorter lifetime.</p>
			<p>The registered <code>GameSummaryEventProcessor</code> is our implementation for dealing with events:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs</p>
			<pre class="source-code">
public class GameSummaryEventProcessor(
<strong class="bold">  EventProcessorClient client,</strong>
  IDbContextFactory&lt;RankingsContext&gt; factory,
  ILogger&lt;GameSummaryEventProcessor&gt; logger)
{
  public async Task <strong class="bold">StartProcessingAsync</strong>(
    CancellationToken = default)
  {
    // code removed for brevity
  }
  public Task <strong class="bold">StopProcessingAsync</strong>(
    CancellationToken cancellationToken = default)
  {
  }
}</pre>
			<p>The class injects <code>EventProcessorClient</code> and the EF Core context factory. This class implements <a id="_idIndexMarker1193"/>methods to start<a id="_idIndexMarker1194"/> and stop the processing of events.</p>
			<p>The <code>StartProcessingAsync</code> method is shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs</p>
			<pre class="source-code">
public async Task StartProcessingAsync(CancellationToken cancellationToken = default)
{
  // code removed for brevity
  <strong class="bold">client.ProcessEventAsync += async (args) =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    GameSummary summary = args.Data.EventBody</strong>
<strong class="bold">      .ToObjectFromJson&lt;GameSummary1&gt;();</strong>
    using var context = await factory.CreateDbContextAsync(
      cancellationToken);
<strong class="bold">    await context.AddGameSummaryAsync(summary,</strong>
<strong class="bold">      cancellationToken);</strong>
<strong class="bold">    await args.UpdateCheckpointAsync(cancellationToken);</strong>
  };
  client.ProcessErrorAsync += (args) =&gt;
  {
    logger.LogError(args.Exception,
      "Error processing event, {error}",
      args.Exception.Message);
    return Task.CompletedTask;
  };
<strong class="bold">  await client.StartProcessingAsync(cancellationToken);</strong>
}</pre>
			<p>Once you start processing events by invoking the <code>StartProcessingAsync</code> method, the <code>EventProcessorClient</code> class fires .NET events that are invoked when messages are received, and on errors: <code>ProcessEventAsync</code> and <code>ProcessErrorAsync</code>. A received message is converted from binary into a <code>GameSummary</code> object and written<a id="_idIndexMarker1195"/> to the database. In addition to that, the checkpoint in the storage account is written<a id="_idIndexMarker1196"/> so that we know which event message was processed last.</p>
			<p>When this is in place, start the application, open the Azure portal to send messages to the bot queue to let the bot play some games, and monitor how events are sent. <em class="italic">Figure 15</em><em class="italic">.8</em> shows the Azure portal showing Event Hub metrics:</p>
			<div><div><img src="img/B21217_15_08.jpg" alt="Figure 15.8 – Event Hub metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – Event Hub metrics</p>
			<p>Apart from checking the Event Hub metrics, verify the data that’s been written to the rankings database. Also, start the SignalR<a id="_idIndexMarker1197"/> client application<a id="_idIndexMarker1198"/> so that you can monitor event data with async streaming.</p>
			<p>Open the Event Hub instance in the Azure portal and select <strong class="bold">Configuration</strong> within the <strong class="bold">Settings</strong> category (see <em class="italic">Figure 15</em><em class="italic">.9</em>):</p>
			<div><div><img src="img/B21217_15_09.jpg" alt="Figure 15.9 – Event Hub configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – Event Hub configuration</p>
			<p>Here, you can see the configured partition count and can disable the hub. Regarding <code>ranking-service</code> is not running on one day, there’s still enough time to process the games afterward.</p>
			<p>You can also configure how<a id="_idIndexMarker1199"/> data is captured (<strong class="bold">Features</strong> | <strong class="bold">Capture</strong>) with an Azure Storage Account (<strong class="bold">Avro</strong> serialization format) or Azure<a id="_idIndexMarker1200"/> Data Lake (<strong class="bold">Parquet</strong> or <strong class="bold">Delta Lake</strong> serialization format). Make<a id="_idIndexMarker1201"/> sure you check<a id="_idIndexMarker1202"/> out the pricing options before configuring capturing<a id="_idIndexMarker1203"/> or other SKUs.</p>
			<p>Mentioning prices, what do you need to be aware of when you’re deploying the solution to Microsoft Azure?</p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor366"/>Deploying the solution to Microsoft Azure</h1>
			<p>When using a low load, the complete<a id="_idIndexMarker1204"/> solution is not expensive<a id="_idIndexMarker1205"/> when it’s running on Microsoft Azure. CPU power typically results in higher cost. How many containers are running with Azure Container Apps? <code>bot-service</code>, the <code>game-apis</code> service, <code>live-service</code>, <code>ranking-service</code>, and the Redis container. The <code>game-apis</code> service should scale with the minimum value set to 1, which provides a fast response for the first user so that they get a fast first answer. If you scale to 1 when the service is idle, there’s an idle price that reduces the cost of the CPU considerably. <code>bot-service</code>, <code>live-service</code>, and <code>ranking-service</code> can scale down to 0, which means there’s no cost in terms of CPU and memory. However, be aware of custom health checks (covered in <a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a>), which can play against scaling to 0. With <code>live-service</code>, if there’s no listener to query for running games, you can’t subscribe to events. Thus, cost only applies if clients are connected.</p>
			<p>The bot contains a loop that keeps running and checks the queue repeatedly. This is not necessary with the Azure Container Apps environment. Here, we can create an <strong class="bold">Azure Container Apps job</strong> resource. This resource<a id="_idIndexMarker1206"/> is only started based on a trigger – for example, a cron time or an event such as a message available in a storage queue.</p>
			<p>Creating Azure Container Apps jobs is not yet supported with .NET Aspire out of the box. However, this is possible with some customization. Here’s what you need to do:</p>
			<ol>
				<li>Initialize the project with <code>azd init</code>.</li>
				<li>Use <code>azd infra synth</code> to create Bicep files and manifest files.</li>
				<li>Create Azure resources using <code>azd provision</code>.</li>
				<li>Change the manifest file of the project that should be deployed as a Container App Job instead of a Container App.</li>
				<li>Deploy the projects using <code>azd deploy</code> (you can deploy project by project using <code>azd deploy &lt;service&gt;</code> or deploy all).</li>
			</ol>
			<p>Because of the quick updates<a id="_idIndexMarker1207"/> that are made to .NET Aspire, check out<a id="_idIndexMarker1208"/> the README file in this chapter’s GitHub repository for the latest updates.</p>
			<p>Next, let’s look at an alternative option to using Azure services.</p>
			<h1 id="_idParaDest-368"><a id="_idTextAnchor367"/>Using Apache Kafka for event processing</h1>
			<p>Apache Kafka can be an alternative<a id="_idIndexMarker1209"/> to using Azure Queue Storage<a id="_idIndexMarker1210"/> and Azure Event Hubs – especially when it comes to on-premises solutions. This technology is used by many companies in their on-premises environments for high performance application-to-application messaging, supports a scalable multiple producers and consumers environment (like Event Hub), and supports a read-only-once scenario like message queues.</p>
			<p>Starting the AppHost with the <code>OnPremises</code> launch profile will now use the previously created <code>Codebreaker.Bot</code>. This uses a REST API instead of message queues, replaces the event publishing mechanism of the <code>game-apis</code> service, and makes the event subscription from <code>ranking-service</code> use Apache Kafka.</p>
			<p>First, we’ll change <code>app-model</code>.</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor368"/>Configuring Apache Kafka with app-model</h2>
			<p>To use the Apache Kafka<a id="_idIndexMarker1211"/> resource with <code>app-model</code>, we must<a id="_idIndexMarker1212"/> add the <code>Aspire.Hosting.Kafka</code> NuGet package:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var kafka = builder.AddKafka("kafkamessaging");</strong>
// code removed for brevity
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
  .WithExternalHttpEndpoints()
  .WithReference(sqlServer)
  .WithReference(redis)
<strong class="bold">  .WithReference(kafka)</strong>
  .WithEnvironment("DataStore", dataStore)
<strong class="bold">  .WithEnvironment("StartupMode", startupMode);</strong>
  builder.AddProject&lt;Projects.Codebreaker_Ranking&gt;("ranking")
  .WithExternalHttpEndpoints()
  .WithReference(cosmos)
<strong class="bold">  .WithReference(kafka)</strong>
<strong class="bold">  .WithEnvironment("StartupMode", startupMode);</strong></pre>
			<p>The <code>AddKafka</code> method adds a Docker container for local development. This resource is referenced from the <code>game-apis</code> service and <code>ranking-service</code> to forward the connection. <code>StartupMode</code> is configured with the launch profile and forwarded as an environment variable to both of these projects so that they can choose between Azure Event Hubs and Apache Kafka.</p>
			<p>Next, we’ll use an Aspire component to publish events.</p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor369"/>Publishing Apache Kafka events</h2>
			<p>When it comes to publishers<a id="_idIndexMarker1213"/> and subscribers, the <code>Aspire.Confluent.Kafka</code> NuGet package is used. Within this package, in the <code>Confluent.Kafka</code> namespace, the <code>IProducer</code> interface is defined. An object of this type is injected with the <code>KafkaGameReportProducer</code> class to publish completed games:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/KafkaGameReportProducer.cs</p>
			<pre class="source-code">
public class KafkaGameReportProducer(
<strong class="bold">  IProducer&lt;string, string&gt; producerClient</strong>,
  ILogger&lt;KafkaLiveReportProducer&gt; logger)
<strong class="bold">  : IGameReport</strong>
{
  public async Task ReportGameEndedAsync(
    GameSummary game,
    CancellationToken cancellationToken = default)
  {
<strong class="bold">    Message&lt;string, string&gt; message = new()</strong>
<strong class="bold">    {</strong>
<strong class="bold">      Key = game.Id.ToString(),</strong>
<strong class="bold">      Value = JsonSerializer.Serialize(game)</strong>
<strong class="bold">    </strong><strong class="bold">};</strong>
    string[] topics = ["ranking", "live"];
    foreach (var topic in topics)
    {
<strong class="bold">      _ = producerClient.ProduceAsync(topic, message,</strong>
<strong class="bold">        cancellationToken);</strong>
    }
<strong class="bold">    producerClient.Flush(TimeSpan.FromSeconds(5));</strong>
    logger.GameCompletionSent(game.Id, "Kafka");
    return Task.CompletedTask;
  }
}</pre>
			<p><code>KafkaGameReportProducer</code> implements the same interface that was used before – that is, <code>IGameReport</code>. The generic parameters of the <code>IProducer</code> interface define types for the key and the value. With Kafka, serializers can be specified, which allows for custom serialization. We can use simple strings that easily work across different platforms. With .NET, we can use the <code>System.Text.Json</code> serializer to serialize <code>GameSummary</code> objects to strings.</p>
			<p>The <code>IProducer</code> interface defines the <code>ProduceAsync</code> method to publish messages. The first parameter names a topic. Upon invoking the <code>ProduceAsync</code> method, the message is sent to a Kafka broker service. The message is kept there until it is read by a subscriber for the topic – up to a retention period. The default retention period is 1 week. To send messages to multiple subscribers (<code>live-service</code> and <code>ranking-service</code>), a list of topics is used.</p>
			<p>The <code>ProduceAsync</code> method returns <code>DeliveryResult</code> when the message is delivered to the broker. We don’t wait for the message to be delivered; instead, we use a loop to send the same message with multiple topics. <code>Task.WhenAll</code> could be used to wait for all deliveries or the <code>Flush</code> method to wait until a timeout is reached. The <code>Flush</code> method returns the number of items in the queue. Before the producer gets disposed of, you need to make sure that all messages are delivered to the broker. Because the producer is configured<a id="_idIndexMarker1214"/> as a singleton with the DI container, we can keep the flush for later.</p>
			<p>Now, we must configure the DI container:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
// code removed for brevity
string? mode = builder.Configuration["StartupMode"];
if (mode == "OnPremises")
{
<strong class="bold">  builder.AddKafkaProducer&lt;string, string&gt;(</strong>
<strong class="bold">    "kafkamessaging", settings =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    settings.Config.AllowAutoCreateTopics = true;</strong>
<strong class="bold">  });</strong>
<strong class="bold">  builder.Services.AddSingleton&lt;IGameReport,</strong>
<strong class="bold">    KafkaGameReportProducer&gt;();</strong>
}</pre>
			<p>The <code>AddKafkaProducer</code> method registers the <code>IProducer</code> interface as a singleton. <code>kafkamessaging</code> is the string that’s used with <code>app-model</code> to get the connection string to the Kafka server. With the <code>KafkaProducerSettings</code> parameter, telemetry configuration and producer settings can be configured. Here, the <code>AllowAutoCreateTopics</code> setting is set to <code>true</code> – which is the default with producers. With consumers, this value is <code>false</code> by default. The previously created <code>KafkaGameReportProducer</code> class is registered as a singleton as well. The <code>IGameReport</code> interface is already used by the <code>GameService</code> class to report completed games, regardless<a id="_idIndexMarker1215"/> of how this reporting is implemented.</p>
			<p>Now, let’s subscribe to these events with the ranking service.</p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor370"/>Subscribing to Apache Kafka events</h2>
			<p>Subscriber applications such<a id="_idIndexMarker1216"/> as <code>Codebreaker.Ranking</code> need the same .NET Aspire component package to be referenced. When it comes<a id="_idIndexMarker1217"/> to consumer classes, the <code>IConsumer</code> interface must be injected:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/GameSummaryKafkaConsumer.cs</p>
			<pre class="source-code">
public class GameSummaryKafkaConsumer(
<strong class="bold">  IConsumer&lt;string, string&gt; kafkaClient,</strong>
  IDbContextFactory&lt;RankingsContext&gt; factory,
  ILogger&lt;GameSummaryEventProcessor&gt; logger)
  : IGameSummaryProcessor
{
  public async Task StartProcessingAsync(
    CancellationToken cancellationToken = default)
  {
<strong class="bold">    kafkaClient.Subscribe("ranking");</strong>
    try
    {
      while (!cancellationToken.IsCancellationRequested)
      {
        try
        {
<strong class="bold">          var result = kafkaClient.Consume(</strong>
<strong class="bold">            cancellationToken);</strong>
<strong class="bold">          var value = result.Message.Value;</strong>
<strong class="bold">          var summary =</strong>
<strong class="bold">            JsonSerializer.Deserialize&lt;GameSummary&gt;(value);</strong>
          // code removed for brevity
          using var context = await
            factory.CreateDbContextAsync(
              cancellationToken);
          await context.AddGameSummaryAsync(
            summary, cancellationToken);
        }
<strong class="bold">        catch (ConsumeException ex) when</strong>
<strong class="bold">          (ex.HResult == -2146233088)</strong>
<strong class="bold">        {</strong>
<strong class="bold">          logger.LogWarning("Consume exception {Message}",</strong>
<strong class="bold">            ex.Message);</strong>
<strong class="bold">          await Task.Delay(TimeSpan.FromSeconds(10));</strong>
<strong class="bold">        }</strong>
      }
    }
  }
}</pre>
			<p>The ranking service subscribes to messages with the <code>ranking</code> topic using the <code>Subscribe</code> method. The topic was used when publishing messages. If the topic doesn’t exist because a message hasn’t been written yet, the <code>Consume</code> method throws a <code>ConsumeException</code> error. This exception is caught, and the <code>Consume</code> method is repeated after a delay. A game might not be completed when the ranking service starts up and the Docker container of the Kafka service hasn’t been configured to keep state.</p>
			<p>When a message is received, it is written<a id="_idIndexMarker1218"/> to the database, as we saw earlier with Azure Event Hubs.</p>
			<p>Now, we just need to configure the DI container:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/ApplicationServices.cs</p>
			<pre class="source-code">
string? mode = builder.Configuration["StartupMode"];
if (mode == "OnPremises")
{
<strong class="bold">  builder.AddKafkaConsumer&lt;string, string&gt;(</strong>
<strong class="bold">    "kafkamessaging", settings =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    settings.Config.GroupId = "Ranking";</strong>
<strong class="bold">  };</strong>
<strong class="bold">  builder.Services.AddSingleton&lt;IGameSummaryProcessor,</strong>
<strong class="bold">    GameSummaryKafkaConsumer&gt;();</strong>
}</pre>
			<p>To register the <code>IConsumer</code> interface, we use the <code>AddKafkaConsumer</code> method. <code>GroupId</code> needs to be configured with a Kafka consumer client. Groups are used for scalability. Similar to Azure Event Hubs, Kafka makes use of partitions. Multiple subscribers using the same group ID receive messages from different partitions. This allows for high scalability.</p>
			<p>Now, start the solution<a id="_idIndexMarker1219"/> with the <code>OnPremises</code> launch profile. Start the Open API page of the bot to let it play some games and debug and monitor the services. <em class="italic">Figure 15</em><em class="italic">.10</em> shows metrics counts for the <code>game-apis</code> service with the bytes transmitted:</p>
			<div><div><img src="img/B21217_15_10.jpg" alt="Figure 15.10 – Kafka metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – Kafka metrics</p>
			<p>Check the bytes, the messages<a id="_idIndexMarker1220"/> that have been published and subscribed to, and the queue sizes for the publisher and the subscriber. Now is also a good time to take a break and play a few rounds of Codebreaker.</p>
			<h1 id="_idParaDest-372"><a id="_idTextAnchor371"/>Summary</h1>
			<p>In this chapter, you learned how to decouple services by using asynchronous communication technologies, messages, and events. With Microsoft Azure, we used queues from an Azure Storage Account and events from Azure Event Hubs. Instead of using these PaaS services, you can also run Kafka within a Docker container in an Azure Container Apps environment, but you need to configure this with the app model.</p>
			<p>You also learned the differences between using message queues and a publish/subscribe event model with multiple subscribers.</p>
			<p>Be sure to check out the .NET Aspire component for Azure Service Bus in the <em class="italic">Further reading</em> section. This service offers more features with message queues, and you’ll learn about some concepts you already know about from Apache Kafka.</p>
			<p>After all the different services, in the next chapter we’ll look into what more we should think about when deploying the application to the production environment, and we’ll deploy the solution to a Kubernetes cluster.</p>
			<h1 id="_idParaDest-373"><a id="_idTextAnchor372"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the following links:</p>
			<ul>
				<li><em class="italic">.NET Aspire Azure Blob Storage </em><em class="italic">component</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component">https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component</a></li>
				<li><em class="italic">.NET Aspire Azure Queue Storage </em><em class="italic">component</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component">https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component</a></li>
				<li><em class="italic">Azure Event Hubs </em><em class="italic">documentation</em>: <a href="https://learn.microsoft.com/en-us/azure/event-hubs/">https://learn.microsoft.com/en-us/azure/event-hubs/</a></li>
				<li>.<em class="italic">NET Aspire Azure Event Hubs </em><em class="italic">component</em>: <a href="https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs">https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs</a></li>
				<li><em class="italic">.NET Aspire Azure Service Bus </em><em class="italic">component</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component">https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component</a></li>
				<li><em class="italic">.NET Aspire RabbitMQ </em><em class="italic">component</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component">https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component</a></li>
				<li><em class="italic">.NET Aspire Apache Kafka </em><em class="italic">component</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component">https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component</a></li>
				<li><em class="italic">Apache Kafka .NET </em><em class="italic">Client</em>: <a href="https://docs.confluent.io/kafka-clients/dotnet/current/overview.html">https://docs.confluent.io/kafka-clients/dotnet/current/overview.html</a></li>
			</ul>
		</div>
	</body></html>