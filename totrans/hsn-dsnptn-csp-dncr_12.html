<html><head></head><body>
        

                            
                    <h1 class="header-title">Functional Programming Practices</h1>
                
            
            
                
<p>The previous chapter (<a href="ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml">Chapter 8</a>, <em>Concurrent Programming in .NET Core</em>) introduced concurrent programming in .NET Core, and the aim of the chapter was to take advantage of <kbd>async</kbd>/<kbd>await</kbd> and parallelism, to make our program more performant.</p>
<p>In this chapter, we will get a taste of functional programming, using the C# language. We will also dive deeper into the concepts that show you how to leverage C# in .NET Core to perform functional programming. The aim of this chapter is to help you understand what functional programming is and how we can use it using the C# language.</p>
<p>Functional programming was inspired by mathematics, and it solves problems in a functional way. In mathematics, we have formulas and, in functional programming, we use math in the form of various functions. The best part of functional programming is that it helps to implement concurrency seamlessly. </p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding functional programming</li>
<li>The inventory application </li>
<li>Strategy patterns and functional programming</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter contains various code examples to explain the concepts of functional programming. The code is kept simple and is just for demonstration purposes. Most of the examples involve a .NET Core console application written in C#.</p>
<p>The complete source code is available at the following link: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9</a>.<a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9"/></p>
<p>To run and execute the code, the prerequisites are as follows: </p>
<ul>
<li>Visual Studio 2019 (a Visual Studio 2017 update 3 or later can also be used to run the application).</li>
<li>Setting up .NET Core</li>
<li>SQL server (the Express Edition is used in this chapter)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Visual Studio</h1>
                
            
            
                
<p>To run these code examples, you need to install Visual Studio 2017 (or a later version such as 2019). To do so, follow these instructions:</p>
<ol>
<li>Download Visual Studio from the following download link, which includes installation instructions: <a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio">https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio</a>.</li>
<li>Follow the installation instructions.</li>
<li>Multiple versions are available for the Visual Studio installation. Here, we are using Visual Studio for Windows.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up .NET Core</h1>
                
            
            
                
<p class="mce-root">If you do not have .NET Core installed, you need to follow these instructions:</p>
<ol>
<li class="mce-root">Download .NET Core for Windows at <a href="https://www.microsoft.com/net/download/windows">https://www.microsoft.com/net/download/windows</a>.</li>
<li>For multiple versions and a related library, visit <a href="https://dotnet.microsoft.com/download/dotnet-core/2.2">https://dotnet.microsoft.com/download/dotnet-core/2.2</a>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing SQL Server</h1>
                
            
            
                
<p class="mce-root">If you do not have SQL Server installed, you need to follow these instructions:</p>
<ol>
<li>Download SQL Server from the following link: <a href="https://www.microsoft.com/en-in/download/details.aspx?id=1695">https://www.microsoft.com/en-in/download/details.aspx?id=1695</a>.</li>
<li>Find the installation instructions here: <a href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017</a>.<a href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017"/></li>
</ol>
<p>For troubleshooting and more information, refer to the following link: <a href="https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm">https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding functional programming </h1>
                
            
            
                
<p>In simple terms, <strong>functional programming</strong> is an approach to symbolic computation that is done in the same way as solving mathematical problems. Any functional programming is based on mathematical functions and its coding style. Any language that supports functional programming works for solutions for the following two questions:</p>
<ul>
<li>What does it need to solve?</li>
<li>How does it solve it?</li>
</ul>
<p>Functional programming is not a new invention. This language has existed in the industry for a long time. The following are some well-known programming languages that support functional programming:</p>
<ul>
<li>Haskell</li>
<li>Scala</li>
<li>Erlang</li>
<li>Clojure</li>
<li>Lisp</li>
<li>OCaml</li>
</ul>
<p>In 2005, Microsoft released the first version of F# (pronounced <em>EffSharp—</em><a href="https://fsharp.org/">https://fsharp.org/</a>). This is a functional programming language that has a lot of good features that any functional programming should have. In this chapter, we are not going to discuss much F#, but we will be discussing functional programming and its implementation using the C# language.</p>
<p>Pure functions are the ones that strengthen functional programming by saying that they're pure. These functions work on two levels:</p>
<ul>
<li>The end result/output will always remain the same for the provided parameters.</li>
<li>They will not impact the behavior of the program or the execution path of the application, even when they are being called a hundred times.</li>
</ul>
<p>Consider the following example from our FlixOne inventory application:</p>
<pre>public static class PriceCalc<br/>{<br/>    public static decimal Discount(this decimal price, decimal discount) =&gt; <br/>        price * discount / 100;<br/><br/>    public static decimal PriceAfterDiscount(this decimal price, decimal discount) =&gt;<br/>        decimal.Round(price - Discount(price, discount));<br/>}</pre>
<p>As you can see, we have a <kbd>PriceCalc</kbd> class with two extension methods: <kbd>Discount</kbd> and <kbd>PriceAfterDiscount</kbd>. These functions could be called pure functions; both the <kbd>PriceCalc</kbd> function and the <kbd>PriceAfterDiscount</kbd> function are meeting the criteria to be <kbd>Pure</kbd> function; the <kbd>Discount</kbd> method will calculate the discount based on the current price and discount. In this case, the output of the method will never change for the supplied parameter values. In this way, the product with a price of <kbd>190.00</kbd> and a discount of <kbd>10.00</kbd> will be calculated in this way: <kbd>190.00 * 10.00 /100</kbd>, and this will return <kbd>19.00</kbd>. Our next method—<kbd>PriceAfterDiscount</kbd>—with the same parameter values will calculate <kbd>190.00 - 19.00</kbd> and return the value of <kbd>171.00</kbd>.</p>
<p>One more important point in functional programming is that functions are pure and convey complete information (also called <strong>functional honesty</strong>). Consider the <kbd>Discount</kbd> method from the previous code; this is a pure function that is also honest. So, if someone accidentally supplies a negative discount or a discount that is more than its actual price (more than 100%), will this function remain pure and honest? To handle this scenario, our mathematics function should be written in such a way that if someone enters <kbd>discount &lt;= 0 or discount &gt; 100</kbd>, then the system will not entertain it. Consider the following code with this approach:</p>
<pre>public static decimal Discount(this decimal price, ValidDiscount validDiscount)<br/>{<br/>    return price * validDiscount.Discount / 100;<br/>}</pre>
<p>As you can see, our <kbd>Discount</kbd> function has a parameter type named <kbd>ValidDiscount</kbd>, which validates the input we have discussed. In this way, our function is now an honest function.</p>
<p>These functions are as simple as functional programming, but working with functional programming still requires a lot of practice. In the upcoming sections, we will discuss advanced concepts of functional programming, including functional programming principles.</p>
<p class="mce-root">Consider the following code, where we are checking whether the discount value is valid:</p>
<pre>private readonly Func&lt;decimal, bool&gt; _vallidDiscount = d =&gt; d &gt; 0 || d % 100 &lt;= 1;</pre>
<p>In the preceding code snippet, we have a field named <kbd>_validDiscount</kbd>. Let's look at what this is doing: <kbd>Func</kbd> accepts <kbd>decimal</kbd> as an input and returns <kbd>bool</kbd> as an output. From its name, you can see that <kbd>field</kbd> stores only valid discounts.</p>
<div><kbd>Func</kbd> is a type of delegate that points to a method of one or more arguments and returns a value. The general declaration of <kbd>Func</kbd> is <kbd>Func&lt;TParameter, TOutput&gt;</kbd>, where <kbd>TParameter</kbd> is the input parameter of any valid datatype and <kbd>TOutput</kbd> is the return value of any valid datatype.</div>
<p>Consider the following code snippet, where we are using the <kbd>_validDiscount</kbd> field in a method:</p>
<pre>public IEnumerable&lt;DiscountViewModel&gt; FilterOutInvalidDiscountRates(<br/>    IEnumerable&lt;DiscountViewModel&gt; discountViewModels)<br/>{<br/>    var viewModels = discountViewModels.ToList();<br/>    var res = viewModels.Select(x =&gt; x.Discount).Where(_vallidDiscount);<br/>    return viewModels.Where(x =&gt; res.Contains(x.Discount));<br/>}</pre>
<p>In the preceding code, we have the <kbd>FilterOutInvalidDiscountRates</kbd> method. This method is self-explanatory and indicates that we are filtering out invalid discount rates. Let's analyze the code now.</p>
<p>The <kbd>FilterOutInvalidDiscountRates</kbd> method returns a collection of <kbd>DiscountViewModel</kbd> class for the products that have a valid discount. The following code is of our <kbd>DiscountViewModel</kbd> class:</p>
<pre>public class DiscountViewModel<br/>{<br/>    public Guid ProductId { get; set; }<br/>    public string ProductName { get; set; }<br/>    public decimal Price { get; set; }<br/>    public decimal Discount { get; set; }<br/>    public decimal Amount { get; set; }<br/>}</pre>
<p>Our <kbd>DiscountViewModel</kbd> class contains the following:</p>
<ul>
<li><kbd>ProductId</kbd>: This represents the ID of a product.</li>
<li><kbd>ProductName</kbd>: This represents the name of a product.</li>
<li><kbd>Price</kbd>: This contains the actual price of the product. The actual price is before any discount, taxes, and so on.</li>
<li><kbd>Discount</kbd>: This contains the percentage of a discount such as 10 or 3. A valid discount rate should not be negative, equal to zero, or more than 100% (in other words, it should not be more than the actual cost of the product).</li>
<li><kbd>Amount</kbd>: This contains the product value after any discount, taxes, and so on.</li>
</ul>
<p>Now, let's jump back to our <kbd>FilterOutInavlidDiscountRates</kbd> method and take a look at <kbd>viewModels.Select(x =&gt; x.Discount).Where(_vallidDiscount)</kbd>. Here, you might notice that we are selecting discount rates from our <kbd>viewModels</kbd> list. This list contains discount rates that are valid as per the <kbd>_validDiscount</kbd> field. In the next line, our method is returning records with valid discount rates.</p>
<p>In functional programming, these functions are also known as <strong>first-class functions</strong>. These are the functions whose values can be used as an input or output for any other function. They can also be assigned to variables or stored in collections.</p>
<p>Go to Visual Studio and open the <kbd>FlixOne</kbd> inventory application. From here, run the application and you will see the following screenshot:</p>
<div><img src="img/a92e6211-c9db-44ae-8dde-6c0cff7213f5.png" style=""/></div>
<p class="mce-root">The previous screenshot is the Product Listing page that is showing all the available products. This is a simple page; you can also call it the Product Listing dashboard, where you'll find all the products. From Create New Product, you can add a new product, and Edit will give you the facility to update an existing product. In addition, the Details page will show the complete details of a specific product. By clicking Delete, you can remove the existing product from the listing.</p>
<p>Please refer to our <kbd>DiscountViewModel</kbd> class. We have the option to have multiple discount rates for a product with a business rule, which establishes that only one discount rate is active at a time. To view all the discount rates for a product, click on a discount rate from the preceding screen (Product Listing). This will show the following screen:</p>
<div><img src="img/70619b88-ea6e-4cbd-814b-22c43ab44ae0.png" style=""/></div>
<p>The preceding screen is Product Discount Listing that shows the discount listing for the product name Mango. This has two discount rates, but only the Seasonal Discount rate is active. You might have noticed the remarks column; this is marked as an invalid discount rate because, as per <kbd>_validDiscount</kbd>—which is discussed in the previous section—this discount rate does not match the criteria for a valid discount rate.</p>
<div><kbd>Predicate</kbd> is also a delegate type, similar to <kbd>Func</kbd> delegates. This represents a method that validates the set of criteria. In other words, <kbd>Predicate</kbd> returns the type of <kbd>Predicate &lt;T&gt;</kbd>, where <kbd>T</kbd> is a valid datatype. It works if the criteria matches and returns a value of type <kbd>T</kbd>.</div>
<p>Consider the following code, where we are validating the Product Name to be valid as sentence case:</p>
<pre>private static readonly TextInfo TextInfo = new CultureInfo("en-US", false).TextInfo;<br/>private readonly Predicate&lt;string&gt; _isProductNameTitleCase = s =&gt; s.Equals(TextInfo.ToTitleCase(s));</pre>
<p>In the preceding code, we are using the <kbd>Predicate</kbd> keyword, and this analyzes the condition to validate <kbd>ProductName</kbd> using <kbd>TitleCase</kbd> keyword. If the criteria matches, the result will be <kbd>true</kbd>. If not, the result will be <kbd>false</kbd>. Consider the following code snippet, where we are using <kbd>_isProductNameTitleCase</kbd>:</p>
<pre>public IEnumerable&lt;ProductViewModel&gt; FilterOutInvalidProductNames(<br/>    IEnumerable&lt;ProductViewModel&gt; productViewModels) =&gt; productViewModels.ToList()<br/>    .Where(p =&gt; _isProductNameTitleCase(p.ProductName));</pre>
<p>In the preceding code, we have the <kbd>FilterOutInvalidProductNames</kbd> method. The aim of this method is to pick the products with a valid product name (a <kbd>TitleCase</kbd> product name only).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enhancing our inventory application</h1>
                
            
            
                
<p>The project is for a hypothetical situation where a company, FlixOne, wants to enhance an inventory management application to manage its growing collection of products. This is not a new application, as we have already started the development of this application and discussed the initial stage in <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns - Basics Part 1</em>, where we have started developing a console-based inventory system. From time to time, stakeholders will review the application and try to meet end users' requirements. The enhancement is important, as this application will be used by both staff (to manage the inventory) and by customers (to browse and create new orders). The application will need to be scalable, and is an essential system for the business.</p>
<p>As this is a technical book, we will mostly discuss the various technical observations from the development team's perspective and discuss the patterns and practices used to implement the inventory management application. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Requirements</h1>
                
            
            
                
<p>There is a need to enhance the application, and this cannot be achieved in one day. This will require a lot of meetings and discussions. Over the course of several meetings, the business and the development teams discussed the requirements of the new enhancements to the inventory management system. Progress toward defining a clear set of requirements was slow, and the vision of the final product was not clear. The development team decided to pare down the enormous list of requirements to just enough functionality so that a key individual could start to record some inventory information. This would allow for simple inventory management and provide a basis that the business could extend upon. We will work on the requirement and take a <strong>Minimal Viable Product</strong> (<strong>MVP</strong>) approach.</p>
<p>MVP is the smallest set of features of an application that can still be released and have enough value for a user base.</p>
<p class="mce-root">After several meetings and discussions between management and business analysts, a list of requirements was produced to enhance our <kbd>FlixOne</kbd> web application. The high-level requirements are as follows:</p>
<ul>
<li><strong>Implementation of pagination</strong>: Currently, all page listings are not paginated. It is really challenging to view items with large page counts by scrolling down or scrolling up the screen.</li>
<li><strong>Discount Rates</strong>: Currently, there is no provision to add or see the various discount rates for a product. The business rules for discount rates are as follows:<br/>
<ul>
<li>A product can have more than one discount rate.</li>
<li>A product can only have one active discount rate.</li>
<li>A valid discount rate should not be a negative value and should not be more than 100%.</li>
</ul>
</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Back to FlixOne </h1>
                
            
            
                
<p>In the previous section, we discussed what is required in order to enhance an application. In this section, we will implement these requirements. Let's first revisit the file structure of our project. Take a look at the following snapshot:</p>
<div><img src="img/fb23aa69-1daf-4775-b51f-5afe3c7d9bc9.png" style=""/></div>
<p>The previous snapshot is depicting our FlixOne web application, having a folder structure as follows:</p>
<ul>
<li><strong>wwwroot</strong>: This is the folder that comes with static contents, such as CSS and jQuery files, which are required for the UI project. This folder comes with the default template provided by Visual Studio.</li>
<li><strong>Common</strong>: This contains all the common files and operations related to business rules and more.</li>
<li><strong>Contexts</strong>: This contains <kbd>InventoryContext</kbd>, which is a <kbd>DBContext</kbd> class that provides <kbd>Entity Framework Core</kbd> capabilities.</li>
<li><strong>Controllers</strong>: This contains all the controller classes of our <kbd>FlixOne</kbd> application.</li>
<li><strong>Migration</strong>: This contains the <kbd>InventoryModel</kbd> snapshot and initially created entities.</li>
<li><strong>Models:</strong> This contains data models, <kbd>ViewModels</kbd>, that are required for our application.</li>
<li><strong>Persistence:</strong> This contains the  <kbd>InventoryRepository</kbd> and its operations.</li>
<li><strong>Views</strong>: This contains all the views/screens of the application.</li>
</ul>
<p>Consider the following code:</p>
<pre>public interface IHelper<br/>{<br/>    IEnumerable&lt;DiscountViewModel&gt; FilterOutInvalidDiscountRates(<br/>        IEnumerable&lt;DiscountViewModel&gt; discountViewModels);<br/><br/>    IEnumerable&lt;ProductViewModel&gt; FilterOutInvalidProductNames(<br/>        IEnumerable&lt;ProductViewModel&gt; productViewModels);<br/>}</pre>
<p>The preceding code contains an <kbd>IHelper</kbd> interface that is holding two methods. We will implement this interface in the following code snippet:</p>
<pre>public class Helper : IHelper<br/>{<br/>    private static readonly TextInfo TextInfo = new CultureInfo("en-US", false).TextInfo;<br/>    private readonly Predicate&lt;string&gt; _isProductNameTitleCase = s =&gt; s.Equals(TextInfo.ToTitleCase(s));<br/>    private readonly Func&lt;decimal, bool&gt; _vallidDiscount = d =&gt; d == 0 || d - 100 &lt;= 1;<br/><br/>    public IEnumerable&lt;DiscountViewModel&gt; FilterOutInvalidDiscountRates(<br/>        IEnumerable&lt;DiscountViewModel&gt; discountViewModels)<br/>    {<br/>        var viewModels = discountViewModels.ToList();<br/>        var res = viewModels.Select(x =&gt; x.ProductDiscountRate).Where(_vallidDiscount);<br/>        return viewModels.Where(x =&gt; res.Contains(x.ProductDiscountRate));<br/>    }<br/><br/>    public IEnumerable&lt;ProductViewModel&gt; FilterOutInvalidProductNames(<br/>        IEnumerable&lt;ProductViewModel&gt; productViewModels) =&gt; productViewModels.ToList()<br/>        .Where(p =&gt; _isProductNameTitleCase(p.ProductName));<br/>}</pre>
<p>The <kbd>Helper</kbd> class implements the <kbd>IHelper</kbd> interface. In this class, we have two main, and important, methods: one is to check for a valid discount and the other is to check for a valid  <kbd>ProductName</kbd> attribute.</p>
<p>Before we use this functionality in our application, we should add this to our <kbd>Startup.cs</kbd> file, as shown in the following code:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddTransient&lt;IInventoryRepositry, InventoryRepositry&gt;();<br/>    services.AddTransient&lt;IHelper, Helper&gt;();<br/>    services.AddDbContext&lt;InventoryContext&gt;(o =&gt; o.UseSqlServer(Configuration.GetConnectionString("FlixOneDbConnection")));<br/>    services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;<br/>    {<br/>        // This lambda determines whether user consent for non-essential cookies is needed for a given request.<br/>        options.CheckConsentNeeded = context =&gt; true;<br/>        options.MinimumSameSitePolicy = SameSiteMode.None;<br/>    });<br/>}</pre>
<p>In the preceding code snippet, we have a written statement, <kbd>services.AddTransient&lt;IHelper, Helper&gt;();</kbd>. With this, we are adding a transient service to our application. We have already discussed the <em>Inversion of control</em> section in <a href="fd71001a-4673-4391-a10b-2490e07f135e.xhtml">Chapter 5</a>, <em>Implementing Design Patterns - .Net Core</em>.</p>
<p>Consider the following code, where we are using the <kbd>IHelper</kbd> class by taking leverage of Inversion of control:</p>
<pre>public class InventoryRepositry : IInventoryRepositry<br/>{<br/>    private readonly IHelper _helper;<br/>    private readonly InventoryContext _inventoryContext;<br/><br/>    public InventoryRepositry(InventoryContext inventoryContext, IHelper helper)<br/>    {<br/>        _inventoryContext = inventoryContext;<br/>        _helper = helper;<br/>    }<br/><br/>... <br/>}</pre>
<p class="mce-root">The preceding code contains the <kbd>InventoryRepository</kbd> class, where we can see the use of a proper <strong>Dependency Injection</strong> (<strong>DI</strong>):</p>
<pre>    public IEnumerable&lt;Discount&gt; GetDiscountBy(Guid productId, bool activeOnly = false)<br/>        {<br/>            var discounts = activeOnly<br/>                ? GetDiscounts().Where(d =&gt; d.ProductId == productId &amp;&amp; d.Active)<br/>                : GetDiscounts().Where(d =&gt; d.ProductId == productId);<br/>            var product = _inventoryContext.Products.FirstOrDefault(p =&gt; p.Id == productId);<br/>            var listDis = new List&lt;Discount&gt;();<br/>            foreach (var discount in discounts)<br/>            {<br/>                if (product != null)<br/>                {<br/>                    discount.ProductName = product.Name;<br/>                    discount.ProductPrice = product.Price;<br/>                }<br/><br/>                listDis.Add(discount);<br/>            }<br/><br/>            return listDis;<br/>        }</pre>
<p>The preceding code is the <kbd>GetDiscountBy</kbd> method of the <kbd>InventoryRepository</kbd> class that is a returning collection of the discount model for the <kbd>active</kbd> or <kbd>de-active</kbd> records. Consider the following code snippet that is used for the <kbd>DiscountViewModel</kbd> collection:</p>
<pre>    public IEnumerable&lt;DiscountViewModel&gt; GetValidDiscoutedProducts(<br/>        IEnumerable&lt;DiscountViewModel&gt; discountViewModels)<br/>    {<br/>        return _helper.FilterOutInvalidDiscountRates(discountViewModels);<br/>    }<br/>}</pre>
<p>The preceding code that uses a collection of <kbd>DiscountViewModel</kbd> is filtering out the products that do not have a valid discount as per the business rule we discussed previously. The <kbd>GetValidDiscountProducts</kbd> method returns the collection of <kbd>DiscountViewModel</kbd>.</p>
<p>If we forget to define <kbd>IHelper</kbd> in our project <kbd>startup.cs</kbd> file, we will meet an exception, as shown in the following screenshot:</p>
<div><img src="img/18dae3fc-bf2b-4296-be43-c0447ffc8d47.png" style=""/></div>
<p>The preceding screenshot is clearly saying that the <kbd>IHelper</kbd> service is not resolved. In our case, we will not face this exception, as we have already added <kbd>IHelper</kbd> to the <kbd>Startup</kbd> class.</p>
<p>Until now, we have added helper methods to fulfill our new requirement for discount rates and to validate them. Now, let's add a controller and subsequent action methods. To do so, add a new <kbd>DiscountController</kbd> controller from Solution Explorer. After this, our <kbd>FlixOne</kbd> web solution will look similar to the following snapshot:</p>
<div><img src="img/8c9cb2fd-c823-4cd2-bcac-143a3fd6ff2c.png" style=""/></div>
<p>In the preceding snapshot, we can see that our <kbd>Controller</kbd> folder now has one additional controller, which is <kbd>DiscountController</kbd>.  The following code is from <kbd>DiscountController</kbd>:</p>
<pre>public class DiscountController : Controller<br/>{<br/>    private readonly IInventoryRepositry _repositry;<br/><br/>    public DiscountController(IInventoryRepositry inventoryRepositry)<br/>    {<br/>        _repositry = inventoryRepositry;<br/>    }<br/><br/>    public IActionResult Index()<br/>    {<br/>        return View(_repositry.GetDiscounts().ToDiscountViewModel());<br/>    }<br/><br/>    public IActionResult Details(Guid id)<br/>    {<br/>        return View("Index", _repositry.GetDiscountBy(id).ToDiscountViewModel());<br/>    }<br/>}</pre>
<p>Execute the application and, from the main screen, click on Products and then click on Product Discount Listing. From here, you will get the following screen:</p>
<div><img src="img/b228c14a-47b4-427b-9f13-b4bff9507521.png" style=""/></div>
<p>The preceding snapshot is depicting Product Discount Listing for all the available products. The Product Discount Listing has a lot of records; therefore, it requires scrolling up or scrolling down to view items on the screen. To handle this difficult situation, we should implement paging.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Strategy pattern and functional programming</h1>
                
            
            
                
<p>During the first four chapters of this book, we discussed patterns and practices a lot. The strategy pattern is one of the important patterns of <strong>Gang of Four</strong> (<strong>GoF</strong>) patterns. This falls under the behavioral patterns category and is also known as a policy pattern. This is a pattern that is usually implemented with the help of classes. This is also an easier one to implement using functional programming.</p>
<p>Jump back to the <em>Understanding functional programming</em> section of this chapter and reconsider the paradigm of functional programming. Higher-order functions are one of the important paradigms of functional programming; using this, we can easily implement a strategy pattern in a functional way.</p>
<div><strong>Higher-order functions</strong> (<strong>HOFs</strong>) are the functions that take parameters as functions. They can also return functions.</div>
<p>Consider the following code that shows the implementation of HOFs in functional programming:</p>
<pre>public static IEnumerable&lt;T&gt; <strong>Where</strong>&lt;T&gt;<br/>    (this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; criteria)<br/>{<br/>    foreach (var item in source)<br/>        if (criteria(item))<br/>            yield return item;<br/>}</pre>
<p>The preceding code is a simple implementation of the <kbd>Where</kbd> clause, in which we used <kbd>LINQ Query</kbd>. In this, we are iterating a collection and returning an item if it meets the criteria. The preceding code can be further simplified. Consider the following code for a more simplified version of the preceding code:</p>
<pre>public static IEnumerable&lt;T&gt; <strong>SimplifiedWhe</strong>re&lt;T&gt;<br/>    (this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; criteria) =&gt; <br/>    Enumerable.Where(source, criteria);</pre>
<p>As you can see, the <kbd>SimplifiedWhere</kbd> method produces the same result as the previously discussed <kbd>Where</kbd> method. This method is criteria-based and has a strategy to return results, and this criterion executes at runtime. We can easily call the preceding function in a subsequent method to take advantage of functional programming. Consider the following code:</p>
<pre>public IEnumerable&lt;ProductViewModel&gt;<br/>    GetProductsAbovePrice(IEnumerable&lt;ProductViewModel&gt; productViewModels, decimal price) =&gt;<br/>    productViewModels.SimplifiedWhere(p =&gt; p.ProductPrice &gt; price);</pre>
<p>We have a method called <kbd>GetProductsAbovePrice</kbd>. In this method, we are providing the price. This method is self-explanatory, and it works on a collection of <kbd>ProductViewModel</kbd> with a criteria to list the products that have a product price that is more than the parameter price. In our <kbd>FlixOne</kbd> inventory application, you can find further scope to implement functional programming.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Functional programming is all about functions and, predominantly, mathematical functions. Any language that supports functional programming always works on the solution with two main questions: what needs to be solved and how can this be solved? We saw functional programming and its easy implementation using the C# programming language.</p>
<p>We also learned about <kbd>Func</kbd>, <kbd>Predicate</kbd>, LINQ, <kbd>Lambda</kbd>, anonymous functions, closures, expression trees, currying, closures, and recursion. Finally, we looked into the implementation of the strategy pattern using functional programming.</p>
<p>In the next chapter (<a href="84b551c9-fcee-4017-bea5-31c803184e9f.xhtml">Chapter 10</a>, <em>Reactive Programming Patterns and Techniques</em>), we will discuss reactive programming as well as its model and principles. We will also discuss <strong>reactive extensions</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<p class="mce-root">The following questions will allow you to consolidate the information contained in this chapter:</p>
<ol>
<li class="mce-root">What is functional programming?</li>
<li>What is referential transparency in functional programming?</li>
<li>What is a pure function?</li>
</ol>


            

            
        
    </body></html>