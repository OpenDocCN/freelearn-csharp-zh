<html><head></head><body>
        

                            
                    <h1 class="header-title">3D Animation</h1>
                
            
            
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Configuring a character's Avatar and idle animation</li>
<li>Moving your character with root motion and Blend Trees</li>
<li>Mixing animations with Layers and Masks</li>
<li>Organizing States into Sub-State Machines</li>
<li>Transforming the Character Controller via script</li>
<li>Adding rigid props to animated characters</li>
<li>Using Animation Events to throw an object</li>
<li>Applying Ragdoll physics to a character</li>
<li>Rotating the character's torso to aim a weapon</li>
<li>Creating geometry with Probuilder</li>
<li>Creating a game with the 3D Gamekit</li>
<li>Importing third-party 3D models and animations from Mixamo</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>The <strong>Mecanim</strong> animation system has revolutionized how characters are animated and controlled within Unity. In this chapter, we will learn how to take advantage of its flexibility, power, and friendly and highly visual interface.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>Controlling a playable character with the <strong>Mecanim</strong> system might look like a complex task, but it is actually very straightforward:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/34f06f4e-109a-415a-8a94-972a3bbab6ea.png"/></p>
<p>By the end of the chapter, you will have gained a basic understanding of the Mecanim system. For a more complete overview of the subject, consider taking a look at Jamie Dean's <em>Unity Character Animation with Mecanim</em>, also published by Packt Publishing.</p>
<p>All the recipes will make use of Mixamo motion packs. Mixamo is a complete solution for character production, rigging, and animation. In fact, the character used was designed with Mixamo's character creation software called Fuse and rigged with the Mixamo Auto-Rigger. You can find out more about Mixamo and their products at Unity's Asset Store or the Mixamo website:<br/>
<a href="https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320">https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320</a><br/>
<a href="https://www.mixamo.com/">https://www.mixamo.com/</a></p>
<p>Please note that although Mixamo offers <strong>Mecanim</strong>-ready characters and animation clips, for the recipes in this chapter, we will use unprepared animation clips. The reason for this is to make you more confident when dealing with assets obtained by other methods and sources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring a character's Avatar and idle animation</h1>
                
            
            
                
<p>One feature that makes <strong>Mecanim</strong> so flexible and powerful is the ability to quickly reassign Animation Clips from one character to another. This is made possible through the use of <strong>Avatars</strong>, which are basically a layer between your character's original rig and Unity's <strong>Animator</strong> system.</p>
<p>In this recipe, we will learn how to configure an <strong>Avatar</strong> skeleton on a rigged character.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, you will need the MsLaser@T-Pose.fbx and Swat@rifle_aiming_idle.fbx files, which are provided in the <kbd>09_03</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To configure an Avatar skeleton, follow these steps:</p>
<ol>
<li>Import the MsLaser@T-Pose.fbx and Swat@rifle_aiming_idle.fbx files into your project.</li>
<li>Select the MsLaser@T-Pose model from the Project panel.</li>
<li>In the Inspector, under MsLaser@T-Pose Import Settings, activate the Rig section. Change Animation Type to Humanoid. Then, leave Avatar Definition as Create From this Model. Now, click Apply to apply these settings. Finally, click on the Configure... button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/87582a63-d224-4996-92ad-46f949695cdb.png"/></p>
<ol start="4">
<li>The Inspector will show the newly created <strong>Avatar</strong>. Observe how Unity correctly mapped the bones of our character to its structure, assigning, for instance, the mixamoRig:LeftForeArm bone as the Avatar's Lower Arm. We could, of course, reassign bones if needed. For now, just click on the Done button to close the view:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bd882499-ea2a-46e9-95a9-8669556fc202.png"/></p>
<ol start="5">
<li>Now that we have our <strong>Avatar</strong> ready, let's configure our animation for the Idle state. From the Project panel, select the Swat@rifle_aiming_idle file.</li>
<li>Select the Rig section, change Animation Type to Humanoid, and leave Avatar Definition as Create From this Model. Confirm by clicking on Apply.</li>
</ol>
<ol start="7">
<li>Select the Animations section (to the right of the Rig). The rifle_aiming_idle clip should be selected. Drag MsLaser@T-Pose to the Preview area at the bottom of the <strong>Inspector</strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3a193af9-5bb5-4d3b-a0db-f27766a6f40a.png"/></p>
<ol start="8">
<li>With rifle_aiming_idle selected from the Clips list, check the Loop Time and Loop Pose options. Also, click on the Clamp Range button to adjust the timeline to the actual time of the <strong>Animation Clip</strong>. Then, under Root Transform Rotation, check Bake Into Pose and select Based Upon | Original. Under Root Transform Position (Y), check Bake Into Pose and select Based upon Original. Under Root Transform Position (XZ), leave Bake Into Pose unchecked and select Based Upon (at Start) | Center of Mass. Finally, click on Apply to confirm the changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bcae7636-51cf-4628-a618-905a08048cff.png"/></p>
<ol start="9">
<li>In order to access <strong>Animation Clips</strong> and play them, we need to create a Controller. Do this by choosing Project panel menu: Create | Animator Controller. Name it MainCharacter.</li>
<li>Double-click on the Animator Controller to open the <strong>Animator</strong> panel.</li>
<li>From the <strong>Animator</strong> panel, right-click on the grid to open a context menu. Then, select the Create State | Empty option. A new box named New State will appear. It will be in orange, indicating that it is the default state:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b5d8d019-5a2f-466b-ba7e-d62e86df030f.png" style="width:34.83em;height:9.50em;"/></p>
<ol start="12">
<li>Select New State and, in the Inspector, change its name to Idle. Also, in the Motion field, choose rifle_aiming_idle by either selecting it from the list or dragging it from the Project panel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ed89f835-c4a4-4670-b3f3-881e6eee7baf.png" style="width:39.92em;height:10.92em;"/></p>
<ol start="13">
<li>Drag the MsLaser@T-Pose model from the Project panel into the Hierarchy and place it in the Scene.</li>
<li>Select MsLaser@T-Pose from the Hierarchy and observe its <strong>Animator</strong> component in the Inspector. Then, assign the newly created MainCharacter controller to its Controller field:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8e06a3e2-4293-4a2f-b575-47216ae51927.png" style="width:37.50em;height:15.67em;"/></p>
<ol start="15">
<li>Play your <strong>Scene</strong> to see the character correctly animated.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Preparing our character for animation took many steps. First, we created its Avatar, based on the character model's original bone structure. Then, we set up the <strong>Animation Clip</strong> (which, as the character mesh, is stored in an .fbx file), using its own Avatar.</p>
<p>After this, we adjusted the Animation Clip, clamping its size and making it a loop. We also baked its Root Transform Rotation to follow the original file's orientation. Finally, an Animator Controller was created, and the edited <strong>Animation Clip</strong> was made into its default Animation State.</p>
<p>The concept of the Avatar is what makes Mecanim so flexible. Once you have an <strong>Animator Controller</strong>, you can apply it to other humanoid characters, as long as they have an Avatar body mask.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to go further with this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Use Controller with another 3D character Avatar</h1>
                
            
            
                
<p>Let's swap MsLaser for a Mascot 3D character. Do the following:</p>
<ol>
<li>Import the provided model, mascot.fbx.</li>
<li>The apply steps 3 and 4 for this character to create its Avatar.</li>
<li>Drag an instance of the model into the <strong>Scene</strong>.</li>
<li>In the Inspector for its Animator Component, set the Controller to the MainCharacter Animator Controller you created in this recipe.</li>
<li>Run the Scene; you should see the mascot playing the rifle_aiming_idle animation clip.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>To read more information about the Animator Controller, check out Unity's documentation at <a href="http://docs.unity3d.com/Manual/class-AnimatorController.html">http://docs.unity3d.com/Manual/class-AnimatorController.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving your character with root motion and Blend Trees</h1>
                
            
            
                
<p>The Mecanim animation system is capable of applying Root Motion to characters. In other words, it actually moves the character according to the animation clip, as opposed to arbitrarily translating the character model while playing an in-place animation cycle. This makes most of the Mixamo animation clips perfect for use with Mecanim.</p>
<p>Another feature of the animation system is Blend Trees, which can blend Animation Clips smoothly and easily. In this recipe, we will take advantage of these features to make our character walk/run forward and backward, and also strafe right and left at different speeds.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity package named Character_02, containing a character and featuring a basic <strong>Animator Controller</strong>. The package can be found inside the <kbd>09_02</kbd> folder, along with the FBX files for the animation clips you need.</p>
<p>There are two ways to import animations in Unity. One approach involves having each animation as a separate file, named in the form <kbd>modelName@animation</kbd>, such as <kbd>MsLazer@idle</kbd>, <kbd>MsLazer@jumping</kbd>, and so on. The other approach is when a model has several animations all in a single take, in which case you can break the take into separate named animation clips in the Unity editor, specifying the start and end frame for each clip. In this chapter, we'll use the first approach, since it's more straightforward. Learn more from the Unity documentation at <a href="https://docs.unity3d.com/Manual/Splittinganimations.html">https://docs.unity3d.com/Manual/Splittinganimations.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To apply Root Motion to your character using Blend Trees, follow these steps:</p>
<ol>
<li>Import Character_02.unityPackage into a new project. Also, import the following FBX files:
<ul>
<li>Swat@rifle_run</li>
<li>Swat@run_backward</li>
<li>Swat@strafe</li>
<li>Swat@strafe_2</li>
<li>Swat@strafe_left</li>
<li>Swat@strafe_right</li>
<li>Swat@walking</li>
<li>Swat@walking_backward</li>
</ul>
</li>
<li>We need to configure our Animation Clips. From the Project panel, select Swat@rifle_run.</li>
<li>Activate the Rig section. Change Animation Type to Humanoid and Avatar Definition to Create From this Model. Confirm by clicking on Apply:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/488103ca-0a42-4c68-bce1-3285395ed716.png" style="width:41.58em;height:14.25em;"/></p>
<ol start="4">
<li>Now, activate the Animations section (to the right of Rig). Clip rifle_run should be selected. The Preview area (at the bottom of the <strong>Inspector</strong>) will display the message No model is available for preview. Drag MsLaser@T-Pose onto the Preview area.</li>
<li>With asset Swat@rifle_run still selected in the Project panel, in the <strong>Inspector</strong> check the Loop Time and Loop Pose options. Also, click on the Clamp Range button to adjust the timeline to the actual time of the animation clip. Click on Apply to confirm these changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c27e89d8-2cbf-401a-9dbf-4d61af337893.png" style="width:37.58em;height:9.00em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>Then, under Root Transform Rotation, check Bake Into Pose and select Based Upon | Original. Under Root Transform Position (Y), check Bake Into Pose and select Based Upon (at Start) | Original. Under Root Transform Position (XZ), leave Bake Into Pose unchecked and select Based Upon (at Start) | Center of Mass. Finally, click on Apply to confirm the changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8ace8f4c-4f86-46e2-9add-64cda34e9120.png"/></p>
<ol start="7">
<li>Repeat steps 3 to 6 for each one of the following animation clips: Swat@run_backward, Swat@strafe, Swat@strafe_2, Swat@strafe_left, Swat@strafe_right, Swat@walking, and Swat@walking_backward.</li>
<li>Add a 3D Plane to the <strong>Scene</strong>, choose menu: Create | 3D Object | Plane.</li>
<li>Drag an instance of the MsLaser prefab into the <strong>Scene</strong> and position it on the 3D Plane.</li>
<li>From the Hierarchy panel, select the MsLaser GameObject. In the <strong>Inspector</strong>, add a Character Controller component to it (click Add Component and choose Component | Physics | Character Controller). Then, set its Skin Width to 0.0001 and its Center as (0, 0.9, 0); also, change its Radius to 0.34 and its Height to 1.79:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1a6ab6f6-580e-4e68-8958-da19d36f1304.png"/></p>
<ol start="11">
<li>In the Project panel, double-click the MainCharacter controller asset file; it should open in the <strong>Animator</strong> panel.</li>
<li>In the top-left corner of the <strong>Animator</strong> panel, select the Parameters section and use the + sign to create three new Parameters (Float) named xSpeed, zSpeed, and Speed:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3a925c86-f9db-4cf0-9aef-ee082e67a429.png" style="width:37.58em;height:8.33em;"/></p>
<ol start="13">
<li>We do have an Idle state for our character, but we need new ones. Right-click on the grid area and, from the context menu, navigate to Create State | From New Blend Tree. In the <strong>Inspector</strong>, change its name from the Default Blend Tree to Move:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cd6c1355-cc9f-4db0-9de3-b7abe36e0b27.png" style="width:54.25em;height:7.67em;"/></p>
<ol start="14">
<li>Double-click on the Move state. You will see the empty blend tree that you have created. Select it and in the <strong>Inspector</strong>, rename it Move. Then, change its Blend Type to 2D Freeform Directional, also setting xSpeed and zSpeed in the Parameters tab. Finally, using the + sign from the bottom of the Motion list, add nine new Motion Fields:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cbbc374c-8258-446b-9403-c95be58d4d9f.png" style="width:41.75em;height:20.50em;"/></p>
<ol start="15">
<li>Now, populate the Motion list with the following motion clips and respective Pos X and Pos Y values: Run_backwards, 0, -1; Walking_backwards, 0,-0.5; Rifle_aiming_idle, 0, 0; Walking, 0, 0.5; Rifle_run, 0, 1; Strafe, -1, 0; Strafe_left, -0.5, 0; Strafe_right, 0.5, 0; Strafe_2, 1, 0. You can populate the Motion list by selecting it from the list or, if there is more than one clip with the same name, you can drag it from the Project panel onto the slot by expanding the appropriate model icon:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5dbc5888-9733-4f2a-9468-3fe3fb2b7a9f.png" style="width:39.50em;height:17.67em;"/></p>
<ol start="16">
<li>To return to the Base Layer, either double-click on the grid background of the <strong>Animator</strong> panel, or click the Base Layer button in the information bar along the top of the <strong>Animator</strong> panel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/186b5ece-e528-41b5-a05b-fbd2765ee2ac.png" style="width:21.83em;height:6.83em;"/></p>
<ol start="17">
<li>Since we have the rifle_aiming_idle Motion clip in our Move blend tree, we can get rid of the original Idle state. Right-click on the Idle state box and, from the menu, select Delete. The Move blend state will become the new default state, turning orange.</li>
<li>Now, we must create the script-class that will actually transform the player's input into those variables that are created to control the animation. Create a new C# script-class named BasicController, and add an instance-object as a component of the MsLazer GameObject:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    using UnityEngine;<br/>     using System.Collections;<br/> <br/>     public class BasicController: MonoBehaviour {<br/>       private Animator anim;<br/>       private CharacterController controller;<br/>       public float transitionTime = .25f;<br/>       private float speedLimit = 1.0f;<br/>       public bool moveDiagonally = true;<br/>       public bool mouseRotate = true;<br/>       public bool keyboardRotate = false;<br/> <br/>       void Start () {<br/>         controller = GetComponent&lt;CharacterController&gt;();<br/>         anim = GetComponent&lt;Animator&gt;();<br/>       }<br/> <br/>       void Update () {<br/>         if(controller.isGrounded){<br/>           if (Input.GetKey (KeyCode.RightShift) ||Input.GetKey (KeyCode.LeftShift))<br/>             speedLimit = 0.5f;<br/>           else<br/>             speedLimit = 1.0f;<br/> <br/>           float h = Input.GetAxis("Horizontal");<br/>           float v = Input.GetAxis("Vertical");<br/>           float xSpeed = h * speedLimit;<br/>           float zSpeed = v * speedLimit;<br/>           float speed = Mathf.Sqrt(h*h+v*v);<br/> <br/>           if(v!=0 &amp;&amp; !moveDiagonally)<br/>             xSpeed = 0;<br/> <br/>           if(v!=0 &amp;&amp; keyboardRotate)<br/>             this.transform.Rotate(Vector3.up * h, Space.World);<br/> <br/>           if(mouseRotate)<br/>             this.transform.Rotate(Vector3.up * (Input.GetAxis("Mouse X")) * Mathf.Sign(v), <br/>                                                                             Space.World);<br/> <br/>           anim.SetFloat("zSpeed", zSpeed, transitionTime, Time.deltaTime);<br/>           anim.SetFloat("xSpeed", xSpeed, transitionTime, Time.deltaTime);<br/>           anim.SetFloat("Speed", speed, transitionTime, Time.deltaTime);<br/>         }<br/>       }<br/>     }</pre>
<ol start="19">
<li>Play your <strong>Scene</strong> and test the game. You should be able to control your character with the arrow keys (or <em>WASD</em> keys). Keeping the <em>Shift</em> key pressed will slow it down.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Whenever the BasicController script detects any directional keys in use, it sets the Speed variable of the Animator state to a value higher than 0, changing the Animator state from Idle to Move. The Move state, in turn, blends the motion clips that it was populated with, according to the input values for xSpeed (obtained from Horizontal Axis input, typically the <em>A</em> and <em>D</em> keys) and zSpeed (obtained from Vertical Axis input, typically the <em>W</em> and <em>S</em> keys). Since <strong>Mecanim</strong> is capable of applying root motion to the characters, our character will actually move in the resulting direction.</p>
<p>For instance, if the <em>W</em> and <em>D</em> keys are pressed, the xSpeed and zSpeed values will rise to 1.0. From the <strong>Inspector</strong>, it is possible to see that such a combination will result in a blend between the motion clips called rifle_run and strafe_2, making the character run diagonally (to the front and right):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ed26ed0d-90e1-4ac6-8eeb-82a2367f27ab.png" style="width:37.42em;height:30.67em;"/></p>
<p>Our BasicController includes three checkboxes for more options: Move Diagonally, which is set as true by default and allows for blends between forward/backward and left/right clips; Mouse Rotate, which is set as true by default and allows for rotating the character with the mouse, changing their direction while moving; and Keyboard Rotate, which is set as false by default and allows for rotating the character through simultaneous use of the left/right and forward/backward directional keys.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some sources of further information about these topics.</p>
<p>Our blend tree used the 2D Freeform Directional Blend Type. However, if we only had four Animation Clips (forward, backward, left, and right), 2D Simple Directional would have been a better option. </p>
<p>Learn more about Blend Trees and 2D blending from Unity's Documentation:</p>
<ul>
<li><a href="http://docs.unity3d.com/Manual/BlendTree-2DBlending.html">http://docs.unity3d.com/Manual/BlendTree-2DBlending.html</a></li>
</ul>
<p>Also, if you want to learn more about the <strong>Mecanim</strong> Animation System, there are some links that you might want to check out, such as Unity's documentation:</p>
<ul>
<li><a href="http://docs.unity3d.com/Manual/AnimationOverview.html">http://docs.unity3d.com/Manual/AnimationOverview.html</a></li>
</ul>
<p><strong>Mecanim</strong> Example Scenes are available from the Unity <strong>Asset Store</strong>:</p>
<ul>
<li><a href="https://www.assetstore.unity3d.com/en/#!/content/5328">https://www.assetstore.unity3d.com/en/#!/content/5328</a></li>
</ul>
<p><strong>Mecanim</strong> Video Tutorial are available here:</p>
<ul>
<li><a href="http://unity3d.com/pt/learn/tutorials/topics/animation">http://unity3d.com/pt/learn/tutorials/topics/animation</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Mixing animations with Layers and Masks</h1>
                
            
            
                
<p>Mixing animations is a great way of adding complexity to your animated characters without requiring a vast number of animated clips. Using Layers and Masks, we can combine different animations by playing specific clips for specific body parts of the character.</p>
<p>In this recipe, we will apply this technique to our animated character, triggering animation clips for firing a rifle and throwing a grenade with the character's upper body. We will do this while keeping the lower body moving or idle, according to the player's input.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity Package named Mixing, containing a basic <strong>Scene</strong> that features an animated character. We have also provided the FBX animation clips Swat@firing_rifle.fbx and Swat@toss_grenade.fbx. These files can be found in the <kbd>09_03</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To mix animations using layers and masks, follow these steps:</p>
<ol>
<li>Create a new 3D project and import the Mixing Unity Package, as well as the FBX files Swat@firing_rifle.fbx and Swat@toss_grenade.fbx.</li>
<li>Then, from the Project panel, open the mecanimPlayground level.</li>
<li>We need to configure the <strong>Animation Clips</strong>. Select the Swat@firing_rifle asset in the Project panel.</li>
<li>Select the Rig section. Change Animation Type to Humanoid, and Avatar Definition to Create From this Model. Confirm this by clicking on Apply:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/52d3eac7-bc86-4f67-9bf6-76ab65010dcf.png"/></p>
<ol start="5">
<li>Now, activate the <strong>Animations</strong> section. The <kbd>firing_rifle</kbd> clip should be selected; click on the <strong>Clamp Range</strong> button to adjust the timeline and check the <strong>Loop Time</strong> and <strong>Loop Pose</strong> options. Under <strong>Root Transform Rotation</strong>, check Bake Into Pose and select Based <strong>Upon</strong> | <strong>Original</strong>. Under <strong>Root Transform Position</strong> (<strong>Y</strong>), check <strong>Bake Into Pose</strong> and select <strong>Based Upon</strong> (at Start) | Original. Under <strong>Root Transform Position</strong> (<strong>XZ</strong>), leave <strong>Bake</strong> Into Pose unchecked. Click on <strong>Apply</strong> to confirm the changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cce6703a-9c38-4747-98c5-dd67a9a68993.png" style="width:27.08em;height:27.17em;"/></p>
<ol start="6">
<li>Select the <kbd>Swat@toss_grenade</kbd> animation clip. Select the Rig section. Then, change <strong>Animation Type</strong> to Humanoid and Avatar Definition to <strong>Create From</strong> this Model. Confirm it by clicking on Apply.
<ol>
<li>Now, activate the <strong>Animations</strong> section. The <kbd>toss_grenade</kbd> animation clip should be selected. Click the Clamp Range button to adjust the timeline, and leave the <strong>Loop Time</strong> and <strong>Loop Pose</strong> options unchecked. Under Root <strong>Transform Rotation</strong><strong>,</strong> check <strong>Bake</strong> Into <strong>Pose</strong> and select <strong>Based Upon</strong> | <strong>Original</strong><strong>.</strong> Under <strong>Root Transform Position</strong> (<strong>Y</strong>), check <strong>Bake</strong> Into <strong>Pose</strong> and select Based Upon (at Start) | Original. Under Root Transform Position (XZ), leave Bake Into Pose unchecked. Click on Apply to confirm the changes.</li>
</ol>
</li>
</ol>
<ol start="7">
<li>Let's create a Mask. From the Project panel, click on the Create button and add an Avatar Mask to the project. Name it BodyMask.</li>
<li>Select the <strong>BodyMask</strong> tab and, in the <strong>Inspector,</strong> expand the Humanoid section. Green body sections and IK spots are selected (all are by default), and red are unselected. Deselect the character's two legs, the circle base the feet are standing on, and the two feet IK spots (they should turn red):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/30adaa9d-857e-4ea0-9d68-23a2da9ad5d8.png"/></p>
<ol start="10">
<li>In the <strong>Project</strong> panel, double-click the <kbd>MainCharacter</kbd> controller asset file; it should open up in the Animator panel.</li>
<li>In the Animator panel, create a new layer by clicking on the <strong>+</strong> sign in the top-left <strong>Layers</strong> tab, above the Base Layer.</li>
</ol>
<ol start="12">
<li>Name the new <kbd>layerUpperBody</kbd> and click on the gear icon for the settings. Then, change its <strong>Weight</strong> to 1 and select the <strong>BodyMask</strong> in the Mask slot. Also, change Blending to Additive:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ded015b1-998f-40a3-a9d6-857ff9a70480.png" style="width:49.67em;height:12.42em;"/></p>
<ol start="13">
<li>Now, in the Animator panel, with the <kbd>UpperBody</kbd> layer selected, create three new empty states (by right-clicking on the grid area and navigating to Create State | Empty from the menu). Name the default (orange) state null, and the other twoFire and Grenade.</li>
<li>Now, access the <strong>Parameters</strong> tab and add two new parameters of type Bool, Fire and Grenade:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f8a63d47-4f4b-4b17-81bd-bb78231970d9.png" style="width:47.50em;height:14.00em;"/></p>
<ol start="15">
<li>Select the Fire state and, in the <strong>Inspector,</strong> add the firing_rifle Animation Clip to the Motion field:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/22cb9520-f6ca-4ca4-9d3b-955f2a07f1e7.png"/></p>
<ol start="16">
<li>Now, select the <strong>Grenade</strong> state and, in the <strong>Inspector,</strong> add the <kbd>toss_grenade</kbd> animation clip to the Motion field.</li>
<li>Right-click on the null state box and, from the menu, select <strong>Make Transition</strong>. Then, drag the white arrow onto the Fire box.</li>
<li>Select the arrow (it will turn blue). From the <strong>Inspector,</strong> uncheck the Has <strong>Exit Time</strong> option. Then, access the Conditions list, click on the <strong>+</strong> sign to add a new condition, and set it as Fire and true:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a17149d4-7bab-45fe-8293-c5ac548a4ba4.png"/></p>
<ol start="19">
<li>Now, make a <strong>Transition</strong> from null to Grenade. Select the arrow (it will turn blue). From the <strong>Inspector,</strong> uncheck the Has <strong>Exit Time</strong> option. Then, access the Conditions list, click on the <strong>+</strong> sign to add a new condition, and set it as Grenade and true.</li>
<li>Now, create transitions from Fire to null, and from <strong>Grenade</strong> to null. Then, select the arrow that goes from Fire to null and, in the Conditions box, select the Fire and false options. Leave the Has <strong>Exit Time</strong> option checked.</li>
<li>Finally, select the <strong>Transition</strong> arrow that goes from <strong>Grenade</strong> to null. In the <strong>Conditions</strong> box, select the options <strong>Grenade</strong>, false. Leave the Has <strong>Exit Time</strong> option checked. See the screenshot for these setting choices:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e1b92465-bee4-4eb4-a3e7-2aae698b6284.png"/></p>
<ol start="22">
<li>Open the <kbd>BasicController</kbd> C# script-class in your code editor (in Project folder <kbd>Scripts</kbd>). Immediately before the end of the <kbd>Update()</kbd> function, add the following code:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">if(Input.GetKeyDown(KeyCode.F)){<br/>    anim.SetBool("Grenade", true);<br/>} else {<br/>    anim.SetBool("Grenade", false);<br/>}<br/> <br/>if(Input.GetButtonDown("Fire1")){<br/>    anim.SetBool("Fire", true);<br/>}<br/> <br/>if(Input.GetButtonUp("Fire1")){<br/>    anim.SetBool("Fire", false);<br/>}</pre>
<ol start="23">
<li>Save the script and play your Scene. You will be able to trigger the <kbd>firing_rifle</kbd> and <kbd>toss_grenade</kbd> animations by clicking on the fire button and pressing the <em>F</em> key. Observe how the character's legs still respond to the Move animation state, so that the character can keep walking backward while throwing the grenade.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once the Avatar mask is created, it can be used as a way of filtering the body parts that would actually play the animation states of a particular layer. In our case, we have constrained our <kbd>fire_rifle</kbd> and <kbd>toss_grenade</kbd> animation clips to the upper body of our character, leaving the lower body free to play movement-related animation clips such as walking, running, and strafing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to go further with this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Override versus Additive blending</h1>
                
            
            
                
<p>You might have noticed that the <kbd>UpperBody</kbd> layer has a parameter named Blending, which we have set to Additive. This means that animation states in this layer will be added to the ones from the lower layers.</p>
<p>If changed to Override, the animation from this would override animation states from the lower layers when played. In our case, Additive helps in keeping the aim stable when firing while running.</p>
<p>For more information on Animation Layers and Avatar Body Masks, check out Unity's documentation:</p>
<ul>
<li class="SourceCode"><a href="http://docs.unity3d.com/Manual/AnimationLayers.html" target="_blank">http://docs.unity3d.com/Manual/AnimationLayers.html</a></li>
<li class="SourceCode"><a href="http://docs.unity3d.com/Manual/class-AvatarMask.html" target="_blank">http://docs.unity3d.com/Manual/class-AvatarMask.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing States into Sub-state Machines</h1>
                
            
            
                
<p>Whenever content in the <strong>Animator</strong> panel gets too cluttered, you can always consider organizing your <strong>Animation States</strong> into <strong>Sub-State Machines</strong>. In this recipe, we will use this technique to organize animation states for turning the character. Also, since the animation clips provided do not include Root Motion, we will use the opportunity to illustrate how to overcome the lack of Root Motion via a script, using it to turn the character 45 degrees to the left and right:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9cee99f8-ed72-4175-9b9f-b6d9ea875bdc.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity Package named <strong>Turning,</strong> containing a basic scene that features an animated character. We have also provided the FBX animation clips <kbd>Swat@turn_right_45_degrees.fbx</kbd> and <kbd>Swat@turn_left.fbx.</kbd> These files can be found in the <kbd>09_04</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To organize States into Sub-State Machines, please follow these steps:</p>
<ol>
<li>Create a new 3D project and import the Mixing Unity Package, as well as the FBX files <kbd>Swat@turn_right_45_degrees.fbx</kbd> and <kbd>Swat@turn_left.fbx.</kbd></li>
<li>Then, from the <strong>Project</strong> panel, open the <kbd>mecanimPlayground</kbd> level.</li>
<li>We need to configure the <strong>Animation</strong> Clips. Select the <kbd>Swat@turn_left</kbd> asset in the <strong>Project</strong> panel.</li>
<li>Choose the Rig section. Change <strong>Animation Type</strong> to <strong>Humanoid</strong> and <strong>Avatar Definition</strong> to Create From this Model. Confirm by clicking on <strong>Apply.</strong></li>
<li>Now, choose the <strong>Animations</strong> section. The <kbd>turn_left</kbd> clip should be selected. Click the <strong>Clamp Range</strong> button to adjust the timeline and check the <strong>Loop Time</strong> option. <strong>Under Root Transform Rotation</strong>, check <strong>Bake Into Pose</strong> and navigate to Based Upon | Original. <strong>Under</strong> <strong>Root Transform Position</strong> (<strong>Y</strong>), check <strong>Bake Into Pose</strong> and select <strong>Based Upon (at Start)</strong> | <strong>Original</strong>. <strong>Under Root Transform Position (XZ)</strong>, leave <strong>Bake Into Pose</strong> unchecked. Click on <strong>Apply</strong> to confirm the changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8addff17-b81f-46bb-8c34-f1b8248584f1.png" style="width:32.83em;height:23.00em;"/></p>
<p class="mce-root"/>
<ol start="6">
<li>Repeat steps 4 and 5 for <kbd>Swat@turning_right_45_degrees.</kbd></li>
<li>In the <strong>Project</strong> panel, double-click the <kbd>MainCharacter</kbd> controller asset file; it should open in the <strong>Animator</strong> panel.</li>
<li>From the top-left corner of the <strong>Animator</strong> panel, select the <strong>Parameters</strong> section and use the <strong>+</strong> sign to create the two new Parameters (Boolean) named <kbd>TurnLeft</kbd> and <kbd>TurnRight.</kbd></li>
<li>Right-click on the grid area. From the context menu, select Create <kbd>Sub-State</kbd> Machine. In the Inspector, rename it Turn:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/37266a4b-8c2c-40b8-afaf-b99db355ce5a.png"/></p>
<ol start="10">
<li>Double-click on the <strong>Turn Sub-State Machine</strong>. Right-click on the grid area, select <strong>Create State</strong> | <strong>Empty</strong><strong>,</strong> and add a new state. Rename it to <strong>Turn Left.</strong> Then, add another state named <strong>Turn Right</strong>.</li>
<li>From the <strong>Inspector,</strong> populate Turn Left with the <kbd>turn_left</kbd> motion clip. Then, populate <strong>Turn Right</strong> with <kbd>turning_right_45_degrees</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/fce897ee-abff-43dc-81b3-a7f3e2271627.png"/></p>
<ol start="12">
<li>In the <strong>Animator</strong> panel, return to the <strong>Base Layer</strong> (click Base Layer in the information bar along the top of this panel).</li>
</ol>
<p class="mce-root"/>
<ol start="13">
<li>Create two <strong>Transitions</strong> from <strong>State Move</strong>, one into the <strong>Turn Left</strong> sub-state, and one into the <strong>Turn Right</strong> sub-state:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0836a058-4b84-4a1e-842d-f8d9564ff3d8.png" style="width:27.75em;height:10.33em;"/></p>
<ol start="14">
<li>Create two return <strong>Transitions,</strong> from the Turn Left back to Move sub-state, and from the Turn Right sub-state back to Move. Do this by entering the Turn sub-state, dragging the <strong>Transition</strong> arrows from Turn Left and Turn Right into (Up) <strong>Base Layer</strong>, and choosing <strong>State Move.</strong></li>
<li>Select the <strong>Transition</strong> arrow that goes from Turn Right to (Up) Base Layer. It will turn blue. From the <strong>Inspector,</strong> uncheck the <strong>Has Exit Time</strong> option. Then, access the Conditions list, click the <strong>+</strong> sign to add a new condition, and set it as <strong>TurnRight</strong> and <strong>false:</strong></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3ab1a0d5-0246-4185-af0b-0342c434d943.png"/></p>
<ol start="16">
<li>Select the arrow that goes from (Up) Base Layer to Turn Right. From the <strong>Inspector,</strong> uncheck the Has Exit Time option. Then, access the Conditions list, click the + sign to add a new condition, and set it as <strong>TurnRight</strong> and <strong>true.</strong></li>
<li>Repeat steps 14 and 15 with the arrows that go between (Up) Base Layer and Turn Left, using TurnLeft as a condition this time.</li>
</ol>
<ol start="18">
<li>Open the <kbd>BasicController</kbd> C# script-class in your code editor (folder Project | Scripts). Immediately after the <kbd>if(controller.isGrounded)</kbd> line, add this:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">if(Input.GetKey(KeyCode.Q)){<br/>    anim.SetBool("TurnLeft", true);<br/>    transform.Rotate(Vector3.up * (Time.deltaTime * -45.0f),  Space.World);<br/>} else {<br/>    anim.SetBool("TurnLeft", false);<br/>}<br/> <br/>if(Input.GetKey(KeyCode.E)){<br/>    anim.SetBool("TurnRight", true);<br/>    transform.Rotate(Vector3.up * (Time.deltaTime * 45.0f), Space.World);<br/>} else {<br/>    anim.SetBool("TurnRight", false);<br/>}</pre>
<ol start="19">
<li>Save your script-class. Then, select the <kbd>MsLaser</kbd> character and, from the <strong>Inspector,</strong> select the <strong>Basic Controller</strong> component. Leave the Move Diagonally and Mouse Rotate options unchecked. Also, leave the Keyboard Rotate option checked.</li>
<li>Play the <strong>Scene.</strong> You will be able to turn left and right by using the <em>Q</em> and <em>E</em> keys respectively.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As should be clear from the recipe, Sub-State Machines work in a similar way to groups or folders, allowing you to encapsulate a series of state machines into a single entity for easier reference. States from the Sub-State Machines can be Transitioned from external states, in our case the Move state, or even from different sub-state machines.</p>
<p>Regarding character rotation, we have overcome the lack of root motion by using the <kbd>transform.Rotate(Vector3.up</kbd> * <kbd>(Time.deltaTime * -45.0f)</kbd>, Space.World) command to make the character actually turn around when the Q and E keys are held down.</p>
<p>This command was used in conjunction with <kbd>animator.SetBool("TurnLeft", true)</kbd>, which triggers the right animation clip:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9ab32fd2-834a-415a-8000-2d3b36734e9b.png" style="width:34.92em;height:19.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transforming the Character Controller via scripts</h1>
                
            
            
                
<p>Applying Root Motion to your character might be a very practical and accurate way to animate it. However, every now and then, you might need to manually control one or two aspects of the character's movement. Perhaps you only have an in-place animation to work with, or maybe you want the character's movement to be affected by other variables. In these cases, you will need to override <strong>Root Motion</strong> via a script.</p>
<p>To illustrate this issue, this recipe makes use of an animation clip for jumping, which originally moves the character only in the Y-axis. In order to make her move forward or backward while jumping, we will learn how to access the character's velocity to inform the jump direction via a script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity Package named Jumping, containing a basic scene that features an animated character. We have also provided the FBX animation clip <kbd>Swat@rifle_jump.</kbd> These files can be found in the <kbd>09_05</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To apply Root Motion via a script, please follow these steps:</p>
<ol>
<li>Create a new 3D project and import the Jumping Unity Package, as well as the FBX <kbd>Swat@rifle_jump.fbx</kbd> file.</li>
<li>Then, from the Project panel, open the <kbd>mecanimPlayground</kbd> level.</li>
<li>We need to configure the <strong>Animation</strong> Clips. Select the <kbd>Swat@rifle_jump</kbd> asset in the <strong>Project</strong> panel.</li>
<li>Select the Rig section. Change Animation Type to Humanoid and Avatar Definition to Create From this Model. Confirm this by clicking on Apply.</li>
<li>Now, activate the <strong>Animations</strong> section. The <kbd>rifle_jump</kbd> clip should be selected. Click the Clamp Range button to adjust the timeline, and check the Loop Time and Loop Pose options. Under Root Transform Rotation, check Bake Into Pose and select Based Upon | Original. Under Root Transform Position (Y), leave Bake into Pose unchecked and select <strong>Based</strong> Upon (at Start) | Original. Under Root Transform Position (XZ), leave Bake Into Pose unchecked. Click on <strong>Apply</strong> to confirm the changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/96b4285f-1037-4c73-9b2e-60de1a85b657.png" style="width:35.08em;height:20.67em;"/></p>
<ol start="6">
<li>In the <strong>Project</strong> panel, double-click the <kbd>MainCharacter</kbd> controller asset file; it should open up in the Animator panel.</li>
</ol>
<ol start="7">
<li>From the top-left corner of the Animator panel, select the Parameters section and use the <strong>+</strong> sign to create a new <strong>Trigger</strong> parameter named Jump:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/39a6240f-a419-4a9a-8d00-0fea4a227ed0.png"/></p>
<ol start="8">
<li>Add a new State named Jump. Do this by right-clicking the grid area and choosing Create State | Empty, then changing its name in the Inspector.</li>
<li>Select the <strong>Jump</strong> state. Then, from the <strong>Inspector,</strong> populate it with the <kbd>rifle_jump</kbd> motion clip:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/57ca2d32-4d46-4642-94d1-e635b194fe82.png"/></p>
<ol start="10">
<li>Create a <strong>Transition</strong> from Any State to Jump (using the Make Transition right-mouse-click menu). Select the <strong>Transition,</strong> uncheck Has Exit Time, and add a Condition for Trigger Jump:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4f122a2c-759a-4219-8faa-b1c5429ac82f.png"/></p>
<p class="mce-root"/>
<ol start="11">
<li class="CDPAlignLeft CDPAlign">Now, create a <strong>Transition</strong> from Jump to Move. Ensure the Has Exit Time option is checked:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c110b9e8-cb8c-440d-8a5f-6c872a95cf74.png"/></p>
<ol start="12">
<li>Open the <kbd>BasicController</kbd> C# script-class in your code editor (folder Project | Scripts).</li>
<li>Right before the <kbd>Start()</kbd> function, add the following code:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">public float jumpHeight = 3f;<br/>private float verticalSpeed = 0f;<br/>private float xVelocity = 0f;<br/>private float zVelocity = 0f;</pre>
<ol start="14">
<li>Immediately after the <kbd>if(controller.isGrounded)</kbd> line, add this:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">if (Input.GetKey (KeyCode.Space)) {<br/>   anim.SetTrigger("Jump");<br/>   verticalSpeed = jumpHeight;<br/>}</pre>
<ol start="15">
<li>Finally, add a new function at the end of the code for this script-class. So it is inserted immediately before the final brace  (<kbd>}</kbd>) of the code:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">      void OnAnimatorMove(){<br/>         Vector3 deltaPosition = anim.deltaPosition;<br/>         if (controller.isGrounded) {<br/>           xVelocity = controller.velocity.x;<br/>           zVelocity = controller.velocity.z;<br/>         } else {<br/>           deltaPosition.x = xVelocity * Time.deltaTime;<br/>           deltaPosition.z = zVelocity * Time.deltaTime;<br/>           anim.SetBool ("Jump", false);<br/>         }<br/>         deltaPosition.y = verticalSpeed * Time.deltaTime;<br/>         controller.Move (deltaPosition);<br/>         verticalSpeed += Physics.gravity.y * Time.deltaTime;<br/>         if ((controller.collisionFlags &amp; CollisionFlags.Below)  != 0) {<br/>           verticalSpeed = 0;<br/>         }<br/>       }</pre>
<ol start="16">
<li>Save your script and play the Scene. You will be able to jump around using the spacebar. Observe how the character's velocity affects the direction of the jump.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Observe that once this function is added to the script, the Apply Root Motion field in the Animator component changes from a checked box to Handled by Script:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5e23a15e-9164-4c63-a06a-aee63fa715fb.png" style="width:31.33em;height:10.08em;"/></p>
<p>The reason is that in order to override the animation clip's original movement, we have placed a series of commands inside Unity's OnAnimatorMove() function to move our character controller while jumping. The <kbd>controller.Move (deltaPosition)</kbd> line of code basically replaces the jump's direction from the original animation with the deltaPosition 3D Vector, which is made up of the character's velocity at the instant before the jump (x and z-axis) and the calculation between the jumpHeight variable and gravity over time (y-axis).</p>
<p>The Transition from Any State to Animation State Jump has the condition that the Jump Transition has fired (become true). In the code, we activate the Trigger Jump in the Animator Controller with the <kbd> SetTrigger("Jump")</kbd> statement. Triggers are like Bool Parameters, but when set become True for one instance, then automatically return to false again. This means there is no need to write extra code to set the Trigger to False.</p>
<p>Triggers are perfect for events that happen, and then you want things to return to normal afterwards. The Transition from the Jump Animation State back to Move does not need any condition, so after the Jump animation has played, the character returns to the Move state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding rigid props to animated characters</h1>
                
            
            
                
<p>If you haven't included a sufficient number of props for your character when modeling and animating it, you might want to give her the chance to collect new ones at runtime. In this recipe, we will learn how to instantiate a GameObject and assign it to a character while respecting the animation hierarchy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity Package named Props, containing a basic Scene that features an animated character and a prefab named badge. There is also a Texture named <kbd>texture_pickupBadge.png.</kbd> The files can be found in the <kbd>09_06</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To add a rigid prop at runtime to an animated character, follow these steps:</p>
<ol>
<li>Create a new 3D project and import the Props Unity Package and the <kbd>texture_pickupBadge.png</kbd> Texture.</li>
<li>Then, from the <strong>Project</strong> panel, open the <kbd>mecanimPlayground</kbd> level.</li>
<li>From the <strong>Project</strong> panel, add the badge prop to the scene by dragging it into the Hierarchy.</li>
</ol>
<ol start="4">
<li>Make the badge a child of the <kbd>mixamorig:Spine2</kbd> Transform (use the Hierarchy tree to navigate to MsLaser | <kbd>mixamorig:Hips</kbd> | <kbd>mixamorig:Spine</kbd> | <kbd>mixamorig:Spine1</kbd> | <kbd>mixamorig:Spine2</kbd><kbd>).</kbd> Then, make the badge object visible above the character's chest by changing its Transform Position to (-0.08, 0, 0.15) and Rotation to (0.29, 0.14, -13.29):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/26e4046a-4723-4896-babb-388487b518bd.png"/></p>
<ol start="5">
<li>Make a note of the <strong>Position</strong> and <strong>Rotation</strong> values, and delete the badge object from the scene.</li>
<li>Add a 3D Cube named Cube-pickup to the Scene by choosing <strong>Create</strong> | <strong>3D Object</strong> | <strong>Cube</strong><strong>.</strong> In the <strong>Inspector,</strong> set its <strong>Transform Position</strong> to (0, 0.5, 2) and check the Is Trigger option for the Box Collider component.</li>
<li>Drag the <kbd>texture_pickupBadge.png</kbd> Texture from the <strong>Project</strong> panel onto the Cube-pickup GameObject. You should see the Pickup Badge text written on all sides of the Cube.</li>
<li>In the <strong>Project</strong> panel, create a new C# script-class named <strong>AddProp</strong> containing the following code, and add an instance-object as a component to the Cube-pickup GameObject:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    using UnityEngine;<br/>     using System.Collections;<br/> <br/>     public class PropManager : MonoBehaviour  {<br/>         public GameObject prop;<br/>         public Transform targetBone;<br/>         public Vector3 positionOffset;<br/>         public Vector3 rotationOffset;<br/>         public bool destroyTrigger = true;<br/> <br/>         void OnTriggerEnter(Collider collision) {<br/>             bool addPropCondition = targetBone.IsChildOf(collision.transform) &amp; !AlreadyHalreadyHasChildObject();<br/> <br/>             if (addPropCondition)<br/>                 AddProp();<br/>         }<br/> <br/>         private void AddProp() {<br/>             GameObject newprop;<br/>             newprop = Instantiate(prop, targetBone.position,  <br/>             targetBone.rotation) as GameObject;<br/>             newprop.name = prop.name;<br/>             newprop.transform.parent = targetBone;<br/>             newprop.transform.localPosition += positionOffset;<br/>             newprop.transform.localEulerAngles += rotationOffset;<br/> <br/>             if(destroyTrigger)<br/>                 Destroy(gameObject);<br/>         }<br/> <br/>         private bool AlreadyHalreadyHasChildObject() {<br/>             string propName = prop.name;<br/> <br/>             foreach(Transform child in targetBone){<br/>                 if (child.name == propName)<br/>                     return true;<br/>             }<br/> <br/>             return false;<br/>         }<br/>     }</pre>
<ol start="9">
<li>Select the Cube-pickup GameObject and look at the properties of the <strong>Prop Manager (Script)</strong> component in the Inspector. Populate the public variables as follows:
<ul>
<li>Prop: the badge prefab</li>
<li>Target Bone: the <kbd>mixamorig:Spine2</kbd> transform inside the <kbd>MsLaser</kbd> <strong>Hierarchy</strong> GameObject</li>
<li>Position Offset: (-0.08, 0, 0.15)</li>
<li>Rotation Offset: (0.29, 0.14, -13.29)</li>
<li>Destroy Trigger: checked (true)</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/afb575be-e9ad-4684-97f4-65b7497a1cc2.png"/></p>
<ol start="10">
<li>Run the <strong>Scene.</strong> Using the WASD keyboard control scheme, direct the character to the the Cube-pickup GameObject. Colliding with it will add a badge to the character the first time. If public variable <strong>Destroy Trigger</strong> was checked, then the Cube-pickup GameObject should be removed from the Scene after the first collision:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ae7f53cf-d82d-4c19-bf28-9c13a6f77ee6.png" style="width:39.92em;height:23.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once it's been triggered by the character, the scripted instance-object attached to the Cube-pickup GameObject instantiates the assigned prefab, making it a child of the bones that they have been "placed into." The <strong>Position Offset</strong> and <strong>Rotation Offset</strong> can be used to fine-tune the exact position of the prop relative to its parent Transform. As the props become parented by the bones of the animated character, they will follow and respect the parent character GameObejct's hierarchy and animation.</p>
<p>The <kbd>AlreadyHalreadyHasChildObject()</kbd> method checks for preexisting props of the same name before actually instantiating a new one, so we don't attempt to instantiate the prop more than once as a new child of the target bone.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to go further with this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Removing props with a script</h1>
                
            
            
                
<p>You can make a similar script to remove props. In this case, the <kbd>OnTriggerEnter(...)</kbd> method would invoke the following <kbd>RemoveProp()</kbd> method:</p>
<pre class="SourceCode">    private void RemoveProp() {<br/>         string propName = prop.name;<br/> <br/>         foreach(Transform child in targetBone){<br/>             if (child.name == propName)<br/>                 Destroy (child.gameObject);<br/>         }<br/>     }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting Active if there's only one type of Prop</h1>
                
            
            
                
<p>If there will only be one prop, then rather than having the code Instantiate a new GameObject, you could have the prop always in the Hierarchy but initially not active, and then when the pickup Trigger object is hit, you change the prop GameObject to be active.</p>
<p>Although less flexible, it's a much simpler script. Do the following:</p>
<ol>
<li>Drag the badge <strong>Prefab</strong> and make it a child of the <kbd>mixamorig:Spine2</kbd> Transform, then set <strong>Position</strong> and <strong>Rotation</strong> as you did in Step 4 of the previous recipe.</li>
<li>In the <strong>Inspector,</strong> uncheck the Active checkbox for the whole badge GameObject at the top.</li>
<li>Replace the content of the C# script-manager with the following code:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">using UnityEngine;<br/> <br/> public class PropManager : MonoBehaviour {<br/>      public GameObject propObject;<br/> <br/>     void OnTriggerEnter(Collider hit) {<br/>         if (hit.CompareTag("Player")) {<br/>             propObject.SetActive(true);<br/>             Destroy(gameObject);<br/>         }<br/>     }<br/> }</pre>
<ol start="4">
<li>With the Cube-pickup GameObject selected in the <strong>Hierarchy,</strong> in the Inspector drag the badge child of mixamorig:Spine2 into the public slot for the Prop Object variable of the Prop Manager (Script) component.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Animation Events to throw an object</h1>
                
            
            
                
<p>Now that your animated character is ready, you might want to coordinate some of her actions with her animation states. In this recipe, we will show this by making the character throw an object whenever the appropriate animation clip reaches a particular tie point in the animation. To do so, we will make use of <strong>Animation</strong> Events, which basically trigger a function from the animation clip's timeline. This feature, introduced in the Mecanism system, should feel familiar to those experienced with the Add Event feature of the classic <strong>Animation</strong> panel:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/523ca6f8-ee07-4f39-bf52-d5eec4e64100.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity Package named <strong>Throwing,</strong> containing a basic scene that features an animated character and a <strong>prefab</strong> named <strong>EasterEgg.</strong> The files can be found in the <kbd>09_07</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To make an animated character throw an object, follow these steps:</p>
<ol>
<li>Create a new 3D project and import the Props Unity Package and the <kbd>EasterEgg</kbd> Texture.</li>
<li>Open the <kbd>mecanimPlayground</kbd> level.</li>
<li>Play the level and press <em>F</em> on your keyboard. The character will move as if she is throwing something with her right hand.</li>
</ol>
<ol start="4">
<li>Create a new C# script-class named <kbd>ThrowObject,</kbd> and add an instance-object as a component to the character's <kbd>MsLaser</kbd> GameObject:</li>
</ol>
<pre class="SourceCode">    using UnityEngine;<br/>     using System.Collections;<br/> <br/>     public class ThrowObject : MonoBehaviour {<br/>       public GameObject prop;<br/>       private GameObject proj;<br/>       public Vector3 posOffset;<br/>       public Vector3 force;<br/>       public Transform hand;<br/>       public float compensationYAngle = 0f;<br/> <br/>       public void Prepare () {<br/> <br/>         proj = Instantiate(prop, hand.position, hand.rotation) as GameObject;<br/>         if(proj.GetComponent&lt;Rigidbody&gt;())<br/>           Destroy(proj.GetComponent&lt;Rigidbody&gt;());<br/>         proj.GetComponent&lt;SphereCollider&gt;().enabled = false;<br/>         proj.name = "projectile";<br/>         proj.transform.parent = hand;<br/>         proj.transform.localPosition = posOffset;<br/>         proj.transform.localEulerAngles = Vector3.zero;<br/>       }<br/> <br/>       public void Throw () {<br/> <br/>         Vector3 dir = transform.rotation.eulerAngles;<br/>         dir.y += compensationYAngle;<br/>         proj.transform.rotation = Quaternion.Euler(dir);<br/>         proj.transform.parent = null;<br/>         proj.GetComponent&lt;SphereCollider&gt;().enabled = true;<br/>         Rigidbody rig = proj.AddComponent&lt;Rigidbody&gt;();<br/>         Collider projCollider = proj.GetComponent&lt;Collider&gt; ();<br/>         Collider col = GetComponent&lt;Collider&gt; ();<br/>         Physics.IgnoreCollision(projCollider, col);<br/>         rig.AddRelativeForce(force);<br/>       }<br/>     }</pre>
<ol start="5">
<li>In the <strong>Hierarchy,</strong> ensure the <strong>MsLaser</strong> GameObject is selected. In the <strong>Inspector,</strong> examine its <strong>Throw Object (Script)</strong> component. Populate the following:
<ul>
<li>Prop: The <kbd>EasterEgg</kbd> prefab</li>
<li>Hand: <kbd>mixamorig:RightHand</kbd></li>
<li>Pos Offset: Set to (0; 0.07, 0.04)</li>
<li>Force: Set to (0; 200, 500)</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/eb4b94fa-7b65-42ee-9df4-7f0f625775ec.png"/></p>
<ol start="6">
<li>From the <strong>Project</strong> panel, select the <kbd>Swat@toss_grenade</kbd> asset file. In the <strong>Inspector,</strong> select the <strong>Animation</strong> section, scroll down to the <strong>Events</strong> section, and expand it.</li>
</ol>
<ol start="7">
<li>Explore the <strong>Animation</strong> preview panel and see how, as you drag the preview playhead along the preview <strong>Timeline,</strong> the playhead also moves correspondingly in the <strong>Events</strong> timeline. At the bottom of the <strong>Preview</strong> panel, the time, percentage, and Frame properties are displayed. When you click the add event button, a new <strong>Animation Event</strong> will be added in the <strong>Events Timeline</strong> at the current playhead position, so ensure you have the playhead at the correct frame before creating a new <strong>Animation</strong> Event:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1ddda731-39e9-48fd-bb67-63378d4d8d4a.png"/></p>
<p>You may view the contents of this panel by focussing on the avatar animation itself when moving the playhead, and visually choosing the appropriate frame when the character is the desired position for the event. Or, you may already know the time/percentage/frame number at which you wish the Animation Event to be created, and so be focussing on the numerical values at the bottom of the Preview panel.</p>
<ol start="9">
<li>Create two <strong>Animation Events</strong> in the Events section as follows:
<ul>
<li>017.9%: Set Function to Prepare</li>
<li>057.1%: Set Function to Throw</li>
<li>Then, click the Apply button:</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a763495-1ff1-435a-af2c-ceb19953071d.png"/></p>
<ol start="10">
<li>Play your <strong>Scene.</strong> Your character will now be able to throw an <strong>Easter Egg</strong> when you press the F key.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once the <kbd>toss_grenade</kbd> animation reaches the points to which we have set our <strong>Events,</strong> the <kbd>Prepare()</kbd> and <kbd>Throw()</kbd> methods are invoked.</p>
<p>The <kbd>Prepare()</kbd> method instantiates a prefab, now named projectile, in the character's hand (Projectile Offset values are used to fine-tune its position), also making it respect the character's hierarchy. Also, it disables the prefab's collider and destroys its Rigidbody component, provided it has one.</p>
<p>The <kbd>Throw()</kbd> method enables the projectile's collider and adds a Rigidbody component to it, making it independent from the character's hand. Finally, it adds a relative force to the projectile's Rigidbody component, so it will behave as if thrown by the character. The Compensation YAngle can be used to adjust the direction of the grenade, if necessary.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying Ragdoll physics to a character</h1>
                
            
            
                
<p>Action games often make use of Ragdoll physics to simulate the character's body's reaction to being affected by a hit or explosion. In this recipe, we will learn how to set up and activate Ragdoll physics for our character whenever she touches a spiky object. We will also use the opportunity to reset the character's position and animations a number of seconds after that event has occurred:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fce4514f-6356-4231-9ce9-28555981a8d5.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity Package named Ragdoll, containing a basic scene that features an animated character, and a prefab already placed in the scene named Spawnpoint. The files can be found in the <kbd>09_08</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To apply Ragdoll physics to your character, follow these steps:</p>
<ol start="1">
<li>Create a new 3D project and import the Ragdoll Unity Package.</li>
<li>Open the <kbd>mecanimPlayground</kbd> level.</li>
<li>You will see the animated MsLaser character and a disc, Spawnpoint.</li>
<li>First, let's create and set up our Ragdoll. Create a new 3D Ragdoll by choosing <strong>Create</strong> | <strong>3D Object</strong> | <strong>Ragdoll....</strong> The <strong>Ragdoll</strong> wizard should pop up.</li>
<li>Assign the transforms as follows:
<ul>
<li>Pelvis: <kbd>mixamorig:Hips</kbd></li>
<li>Left Hips: <kbd>mixamorig:LeftUpLeg</kbd></li>
<li>Left Knee: <kbd>mixamorig:LeftLeg</kbd></li>
<li>Left Foot: <kbd>mixamorig:LeftFoot</kbd></li>
<li>Right Hips: <kbd>mixamorig:RightUpLeg</kbd></li>
<li>Right Knee: <kbd>mixamorig:RightLeg</kbd></li>
<li>Right Foot: <kbd>mixamorig:RightFoot</kbd></li>
<li>Left Arm: <kbd>mixamorig:LeftArm</kbd></li>
<li>Left Elbow: <kbd>mixamorig:LeftForeArm</kbd></li>
<li>Right Arm: <kbd>mixamorig:RightArm</kbd></li>
<li>Right Elbow: <kbd>mixamorig:RightForeArm</kbd></li>
<li>Middle Spine: <kbd>mixamorig:Spine1</kbd></li>
<li>Head: mixamorig:Head</li>
<li>Total Mass: 20</li>
<li>Strength: 50</li>
</ul>
</li>
<li>See the screenshot for these settings:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/37968fc7-da9b-49cb-9c97-c3c97c67378e.png" style="width:29.58em;height:22.92em;"/></p>
<ol start="7">
<li>Select the <strong>MsLaser</strong> GameObject in the Hierarchy. In the <strong>Inspector,</strong> set its <strong>Tag</strong> to <strong>Player.</strong></li>
<li>Create a new C# script-class named <kbd>RagdollCharacter</kbd> and add an instance-object as a component to the <strong>MsLaser</strong> GameObject:</li>
</ol>
<pre class="SourceCode">    using UnityEngine;<br/>     using System.Collections;<br/> <br/>     public class RagdollCharacter : MonoBehaviour {<br/>         private Transform spawnPoint;<br/> <br/>         void Start () {<br/>             spawnPoint = GameObject.Find("Spawnpoint").transform;<br/>             DeactivateRagdoll();<br/>         }<br/> <br/>         public void ActivateRagdoll() {<br/>             gameObject.GetComponent&lt;CharacterController&gt; ().enabled = false;<br/>             SetActiveRagdoll(true);<br/>             StartCoroutine (Restore ());<br/>         }<br/> <br/>         public void DeactivateRagdoll() {<br/>             SetActiveRagdoll(false);<br/>             RespawnPlayer();<br/>             gameObject.GetComponent&lt;CharacterController&gt;().enabled = true;<br/>         }<br/> <br/>         IEnumerator Restore() {<br/>             yield return new WaitForSeconds(5);<br/>             DeactivateRagdoll();<br/>         }<br/> <br/>         public void SetActiveRagdoll(bool isActive) {<br/>             gameObject.GetComponent&lt;CharacterController&gt; ().enabled = !isActive;<br/>             gameObject.GetComponent&lt;BasicController&gt; ().enabled = !isActive;<br/>             gameObject.GetComponent&lt;Animator&gt; ().enabled = !isActive;<br/> <br/>             foreach (Rigidbody bone in GetComponentsInChildren&lt;Rigidbody&gt;()) {<br/>                 bone.isKinematic = !isActive;<br/>                 bone.detectCollisions = isActive;<br/>             }<br/> <br/>             foreach (CharacterJoint joint in GetComponentsInChildren&lt;CharacterJoint&gt;()) {<br/>                 joint.enableProjection = isActive;<br/>             }<br/> <br/>             foreach (Collider col in GetComponentsInChildren&lt;Collider&gt;()) {<br/>                 col.enabled = isActive;<br/>             }<br/>         }<br/> <br/>         private void RespawnPlayer() {<br/>             transform.position = spawnPoint.position;<br/>             transform.rotation = spawnPoint.rotation;<br/>         }<br/>     }</pre>
<ol start="9">
<li>This recipe needs something to collide with; create a GameObject named death-object. You could create a simple 3D Cube (menu: <strong>Create</strong> | 3D <strong>Object</strong> | <strong>Cube</strong><strong>).</strong> However, any 3D object with a Physics Collider will be fine for the player's character to interact with.</li>
</ol>
<p>It's more fun to have a visually interesting 3D model to interact with. When creating the screenshots for this recipe, we used the high-quality, low-poly, free Stilized Crystal assets from LowlyPoly in the Unity Asset Store as example objects you might use to cause a Ragdoll collision in a game:<br/>
<a href="https://assetstore.unity.com/packages/3d/props/stylized-crystal-77275" target="_blank">https://assetstore.unity.com/packages/3d/props/stylized-crystal-77275</a></p>
<div><img src="img/f53c0851-5482-4096-ab7b-fbbd077c6bc7.png" style="width:50.83em;height:19.17em;"/></div>
<ol start="10">
<li>Create a new C# script-class named <kbd>DeadlyObject,</kbd> and attach an instance-object as a component to the death-object GameObject:</li>
</ol>
<pre class="SourceCode">    using UnityEngine;<br/> <br/>     public class DeadlyObject : MonoBehaviour {<br/>         public float range = 2f;<br/>         public float force = 2f;<br/>         public float up = 4f;<br/> <br/>         void OnTriggerEnter(Collider hit) {<br/>             if (hit.CompareTag("Player")) {<br/>                 RagdollCharacter ragdollCharacter = hit.gameObject.GetComponent&lt;RagdollCharacter&gt;();<br/>                 ExplodePlayer(ragdollCharacter);<br/>                 Destroy(gameObject);<br/>             }<br/>         }<br/> <br/>         private void ExplodePlayer(RagdollCharacter ragdollCharacter) {<br/>             ragdollCharacter.ActivateRagdoll();<br/>             Vector3 explosionPos = transform.position;<br/>             Collider[] colliders = Physics.OverlapSphere(explosionPos, range);<br/> <br/>             foreach (Collider collider in colliders) {<br/>                 if (collider.GetComponent&lt;Rigidbody&gt;())<br/>                     collider.GetComponent&lt;Rigidbody&gt;().AddExplosionForce(force, explosionPos, range, up);<br/>             }<br/>         }<br/>     }</pre>
<ol start="11">
<li>Play the <strong>Scene.</strong> Using the WASD keyboard control scheme, direct the character to the death-object GameObject. Colliding with it will activate the character's Ragdoll physics and apply an explosion to it. As a result, the character will be thrown a considerable distance away and will no longer be in control of its body's movement, akin to a Ragdoll.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Unity's Ragdoll Wizard assigns the Collider, Rigidbody, and Character Joint components to selected transforms. In conjunction, those components make Ragdoll physics possible. However, they must be disabled whenever we want our character to be animated and controlled by the player. In our case, we switch those components on and off using the <kbd>RagdollCharacter</kbd> script and its two functions: <kbd>ActivateRagdoll()</kbd> and <kbd>DeactivateRagdoll().</kbd> The latter includes instructions to respawn our character in the appropriate place.</p>
<p>For testing purposes, we have also created the <kbd>DeadlyObject</kbd> script, which calls the <kbd>RagdollCharacter</kbd> script's function named <kbd>ActivateRagdoll().</kbd> It also applies an explosion to our ragdoll character, throwing it outside the range of the explosion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to go further with this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a new player GameObject rather than deactivating and moving to a respawn point</h1>
                
            
            
                
<p>Instead of resetting the character's transform settings, you could have destroyed its GameObject and instantiated a new one over the respawn point using Tags. For an example of how to do this, check out Unity's documentation: <a href="http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html" target="_blank">http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rotating the character's torso to aim a weapon</h1>
                
            
            
                
<p>When playing a Third-Person Character, you might want her to aim her weapon at a target that is not directly in front of her, without making her change direction. In this case, you will need to apply what is called a Procedural Animation, which does not rely on pre-made animation clips, but rather on the processing of other data, such as player input, to animate the character. In this recipe, we will use this technique to rotate the character's spine by moving the mouse, allowing for adjustments in the character's aim. We will also use this opportunity to cast a ray from the character's weapon and display a crosshair over the nearest target. Please note that this approach will only work with cameras standing behind the third-person controlled characters:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7b4e1c26-5a69-4201-8fe2-9a08f21ccc56.png" style="width:30.08em;height:10.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a Unity Package named <kbd>AimPointer,</kbd> containing a basic scene that features an animated character. The package, which also includes the <kbd>crossAim</kbd> sprite to be used as a crosshair for aiming, can be found inside the <kbd>09_09</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To rotate the character's torso to aim a weapon, do the following:</p>
<ol>
<li>Create a new project and import the <kbd>AimPointer</kbd> Unity Package.</li>
<li>Open the <kbd>mecanimPlayground</kbd> level. In the <strong>Inspector</strong> and <strong>Scene</strong> panels, you will see an animated character named <strong>MsLaser</strong> holding the <strong>pointerPrefab</strong> object.</li>
<li>Create a new C# script-class named <kbd>MouseAim,</kbd> and add an instance-object as a component to the <strong>MsLaser</strong> GameObject:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">    using UnityEngine;<br/>     using System.Collections;<br/> <br/>     public class MouseAim: MonoBehaviour  {<br/>         public Transform spine;<br/>         public Transform weapon;<br/>         public GameObject crosshairImage;<br/>         public Vector2 xLimit = new Vector2(-30f, 30f);<br/>         public Vector2 yLimit= new Vector2(-30f, 30f);<br/>         private float xAxis = 0f;<br/>         private float yAxis = 0f;<br/> <br/>         public void LateUpdate() {<br/>             RotateSpine();<br/>             ShowCrosshairIfRaycastHit();<br/>         }<br/> <br/>         private void RotateSpine() {<br/>             yAxis += Input.GetAxis("Mouse X");<br/>             yAxis = Mathf.Clamp(yAxis, yLimit.x, yLimit.y);<br/>             xAxis -= Input.GetAxis("Mouse Y");<br/>             xAxis = Mathf.Clamp(xAxis, xLimit.x, xLimit.y);<br/>             Vector3 newSpineRotation = new Vector3(xAxis, yAxis, spine.localEulerAngles.z);<br/>             spine.localEulerAngles = newSpineRotation;<br/>         }<br/> <br/>         private void ShowCrosshairIfRaycastHit() {<br/>             Vector3 weaponForwardDirection = weapon.TransformDirection(Vector3.forward);<br/>             RaycastHit hit;<br/>             Vector3 fromPosition = weapon.position + Vector3.one;<br/>             if (Physics.Raycast (fromPosition, weaponForwardDirection, out hit)) {<br/>                 Vector3 hitLocation =  Camera.main.WorldToScreenPoint(hit.point);<br/>                 DisplayPointerImage(hitLocation);<br/>             } else<br/>                 crosshairImage.SetActive(false);<br/>         }<br/> <br/>         private void DisplayPointerImage(Vector3 hitLocation) {<br/>             crosshairImage.transform.position = hitLocation;<br/>             crosshairImage.SetActive(true);<br/>         }<br/>     }</pre>
<ol start="4">
<li>In the <strong>Hierarchy,</strong> create a new UI Image named Image-crosshair by choosing <strong>Create</strong> | <strong>UI</strong> | <strong>Image</strong><strong>.</strong></li>
<li>In the <strong>Inspector</strong> for the Rect Transform component, set its Width and Height to 16 and populate the <strong>Source Image</strong> field with the <kbd>crossAim</kbd> sprite:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/86d601c1-1cc0-4eb1-b0a2-e38e039819f3.png"/></p>
<ol start="6">
<li>Select the <strong>MsLaser</strong> GameObject in the <strong>Hierarchy,</strong> and in the <strong>Inspector</strong> for the Mouse Aim component, populate the following:
<ul>
<li>Spine: <kbd>mixamorig:Spine</kbd> (in <strong>MsLaser</strong> | <strong>mixamorigHips</strong><strong>)</strong></li>
<li>Weapon: <kbd>pointerPrefab</kbd> (in <strong>MsLaser|Hips|Spine|Spine1|Spine2|RightShoulder|Arm|ForeArm|Hand</strong>)</li>
<li>Crosshair: Image-crosshair GameObject</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1d04192a-a3c9-4549-8a1f-993225b39756.png"/></p>
<ol start="7">
<li>Play the Scene. You will now be able to rotate the character's torso by moving the mouse. Even better, the Image-crosshair UI image will be displayed at the top of the object that is being aimed at by the pointer.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You might have noticed that all the code invoked for rotating the character's spine is inside the <kbd>LateUpdate()</kbd> method, as opposed to the more common <kbd>Update()</kbd> method. The reason for this is to make sure that all the transform manipulation will be executed after the original animation clip is played, overriding it.</p>
<p>Regarding the spine rotation, our script adds the horizontal and vertical speed of the mouse to the xAxis and yAxis float variables. These variables are then constrained within the specified limits, avoiding distortions to the character's model. Finally, the spine object transform rotations for the x and y axes are set to xAxis and yAxis respectively. The z axis is preserved from the original Animation Clip.</p>
<p>Additionally, our script uses a Raycast command to detect whether there is an object's collider in the direction of the weapon's aim, in which case, a crosshair will be drawn on the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to go further with this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic solution for Cameras other than the Main Camera</h1>
                
            
            
                
<p>Since this recipe's script was tailored for cameras standing behind third-person-controlled characters, we have included a more generic solution to the problem - in fact, a similar approach to the one presented in <em>Unity 4.x Cookbook, Packt Publishing</em>.</p>
<p>An alternate script named <kbd>MouseAimLookAt,</kbd> which can be found inside the <kbd>09_09</kbd> folder, starts by converting our bi-dimensional mouse cursor screen's coordinates to three-dimensional world space coordinates (stored in a point variable). Then, it rotates the character's torso towards the point location, using the <kbd>LookAt()</kbd> command to do so. Additionally, it makes sure that the spine does not extrapolate minY and maxY angles, which would otherwise causing distortions to the character model.</p>
<p>Also, we have included a Compensation <kbd>YAngle</kbd> variable, which makes it possible for us to fine-tune the character's alignment with the mouse cursor. Another addition is the option to freeze the X-axis rotation, in case you just want the character to rotate their torso laterally but not look up or down. Again, this script uses a <strong>Raycast</strong> command to detect objects in front of the weapon, drawing a crosshair on the screen when they are present.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating geometry with Probuilder</h1>
                
            
            
                
<p>A recent addition to the 3D Unity tools is <strong>Probuilder,</strong> which allows you to create and manipulate geometry inside the Unity Editor. Much more powerful than the existing <strong>Terrain</strong> editor, <strong>Probuilder</strong> allows you to create 3D Primitives and then manipulate them, such as by extruding or moving Vertices, Edges, or Faces, and then painting with colors or texturing with Materials.</p>
<p>In this recipe, we'll create some geometry that might be useful for an original game, or to add to a 3D Gamekit Scene (such as the Scene worked with in the following recipe).</p>
<p>If you've not used a 3D modeling package before (such as Blender, 3D Studio Max, or Maya), then it is well worth exploring the different features of <strong>Probuilder.</strong> You'll learn key concepts, including the following:</p>
<ul>
<li>Vertex: Point where lines touch—a corner where edges touch</li>
<li>Edges: Straight line between two vertices</li>
<li>Faces: Flat 2D surfaces, usually a rectangle or triangular</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe uses the free Unity Asset Store and Package Manager packages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create geometry with Probuilder, follow these steps:</p>
<ol>
<li>Create a new Unity 3D project.</li>
<li>Use the <strong>Package Manager</strong> to install the <strong>Probuilder</strong> package.</li>
</ol>
<ol start="3">
<li>Display the <strong>Probuilder</strong> panel with <strong>Tools</strong> | <strong>Probuilder</strong> | <strong>Window</strong><strong>.</strong></li>
<li>Dock the panel (next to the <strong>Hierarchy</strong> works well). Choose <strong>Text Mode</strong> or <strong>Icon Mode</strong>, as you prefer, via the right mouse button's context menu.</li>
<li>Create a new <strong>Probuilder</strong> Plane by clicking <strong>New Shape</strong> and choosing <strong>Plane</strong> from the <strong>Shape Tool</strong> window. Accept the default options and click the green <strong>Build Plane</strong> button.</li>
<li>With the new <strong>Probuilder</strong> Plane selected in the Hierarchy, you'll see the object selected in the Scene panel and its properties in the Inspector. We can see in the Inspector that, as well as its Transform, Mesh, and Mesh Renderer components, there are two special Probuilder components, <kbd>Pb_mesh_nnnnn</kbd> and <kbd>Pb_Object</kbd> (Script).</li>
</ol>
<div><kbd>Pb_mesh_nnnnn</kbd> is a special component that stores the data for the 3D object mesh of this GameObject; this data can be edited in the <strong>Scene</strong> panel at design time. At runtime, a Unity Mesh is created based on this data.</div>
<p class="CDPAlignCenter CDPAlign"><img src="img/bda71a43-8db9-43a3-97c7-b7d85f1181e7.png"/></p>
<ol start="7">
<li>Note that when a <strong>Probuilder</strong> GameObject is selected, there is a small <strong>Probuilder</strong> tool icon bar displayed in the Scene panel, allowing the Object, Vertex, Edge, and Face detection modes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/abae42b2-3862-4823-97c3-c76646b7b950.png" style="width:23.33em;height:5.08em;"/></p>
<ol start="8">
<li>Let's make a depression in the middle of our Plane. Choose Face selection (the rightmost of the four <strong>Probuilder</strong> section icons), and using the Shift key for multiple section, select the four inner faces (selected faces turn Yellow). Then, use the Y-axis arrow to move these four selected faces downwards:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8d0411fb-5bb8-47ed-81e3-10a4772de6fb.png"/></p>
<ol start="9">
<li>Let's Vertex Paint some color on the object. This is easier to do carefully when there are more faces. First, in the Probuilder panel, click the Subdivide tool.</li>
<li>Now, click Probuilder Vertex Colors +. The <strong>Probuilder</strong> Vertex Painter pop-up panel should be displayed. Click the red color and choose a darker red. Then, click the white square above your color to choose this dark red brush color. Make the brush size big (2 or 3), and paint all over the Plane to make it all dark red. Now, click the white square in the Vertex Painter panel to choose the yellow brush, and make the brush size smaller (say 1.5). Now, click on just the nine vertices in the middle of the depressed region of the Plane. Now, you should have a dark red Plane with yellow in the lower parts of it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/373b51c4-9452-4f43-8ba9-9d5ba284879a.png" style="width:29.83em;height:11.58em;"/></p>
<ol start="11">
<li>Save your Scene. Since the <strong>Probuilder</strong> Mesh data is stored in the Scene data, you'll lose all your Probuilder work if you forget to save your Scene.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You've added the Probuilder package to a new 3D project and used the <strong>Probuilder</strong> tools panel to add a <strong>Probuilder</strong> mesh object to the Scene. You've used the face selection tool to allow you to select and then move some of the faces to create a depression. You then subdivided the object to give you more faces to work with for final detailed working. Finally, you learned to Vertex Paint with difference colors and brush sizes.</p>
<p><strong>Probuilder</strong> offers many more features, including creating object by drawing a line-by-line polygon and Texturing surfaces rather than just simple Vertex Painting. Learn more about <strong>Probuilder</strong> here:</p>
<ul>
<li class="SourceCode">Unity Technology <strong>Probuilder</strong> documentation manual: <a href="https://docs.unity3d.com/Packages/com.unity.probuilder@3.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.probuilder@3.0/manual/index.html</a></li>
<li class="SourceCode">Unity Technology <strong>Probuilder</strong> videos: <a href="https://www.youtube.com/user/Unity3D/search?query=Probuilder">https://www.youtube.com/user/Unity3D/search?query=Probuilder</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a game with the 3D Gamekit</h1>
                
            
            
                
<p>A collection of Unity 3D tools has been combined to become the Unity 3D <strong>GameKit</strong>. In this recipe, we'll create a new <strong>Scene</strong> and make use of some of the kit's Prefabs and Scripts to illustrate how characters can interact with objects such as doors and pickups:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c41cfef5-dfc9-4a95-b2d9-fdb64a8c96aa.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe uses the free <strong>Unity Asset Store</strong> and <strong>Package Manager</strong> packages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a game with the 3D Gamekit, follow these steps:</p>
<ol>
<li>Create a new Unity 3D project.</li>
<li>Use the Package Manager to install the following packages (required by the 3D GameKit):
<ul>
<li>Cinemachine</li>
<li>Post Processing (agree to the Quality Settings pop-up diaglog)</li>
<li>Probuilder</li>
</ul>
</li>
<li>Import the <strong>3D GameKit</strong> (free from Unity Technologies) from the Asset Store:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a82197e1-10a8-46fe-87bf-ee8e0f187c4a.png" style="width:32.08em;height:5.08em;"/></p>
<ol start="4">
<li>Agree to the Quality Settings pop-up diaglog. After a few minutes (in which it is setting up a project with lots of assets), you'll see a new folder in the Project panel named 3DGamekit.</li>
<li>Close and then reopen the Unity Editor.</li>
<li>First, open the example <strong>Scene</strong> provided and explore the 3D world by controlling the 3D Ellen character.</li>
</ol>
<p>Movement is standard <em>WASD-SPACE</em>/arrow keys. Camera control is via the mouse pointer. Click the left mouse button to use a weapon.</p>
<ol start="7">
<li>Create a new 3D <strong>GameKit</strong> Scene by choosing Kit Tools | Create New Scene. You'll then be asked to name the <strong>Scene</strong>, and a new <strong>Scene</strong> asset file will be created in your Project | Assets folder. You'll see there are quite a few special GameObjects in the Hierarchy of your new <strong>Scene</strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d0ce5460-ef14-4600-b9e9-6682ec9d54e2.png"/></p>
<ol start="8">
<li>As you can see, the new <strong>Scene</strong> starts off containing an animated 3D character (Ellen) on a ProBuilder 3D Plane that forms the ground she is standing on.</li>
<li>Add a small door in the Scene. Drag a clone of the DoorSmall Prefab from the Project panel (Assets | 3DGamekit | Prefabs | Interactables) into the middle of the 3D Plane <strong>Scene</strong>.</li>
<li>Add a Crystal in the <strong>Scene</strong>, on the opposite side of the door from where the Ellen character starts. Drag a clone of the Crystal Prefab from the Project panel (Assets | 3DGamekit | Prefabs | Interactables) into the <strong>Scene</strong> behind the door.</li>
<li>Now, add some walls on either side of the door, so the door must be opened in order for Ellen to reach the Crystal. Drag two clones of Prefab Wall2x from the Project panel (Assets | 3DGamekit | Prefabs | Interactables) into the <strong>Scene</strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1224aa6b-91a4-4692-9184-2f984cc1f317.png"/></p>
<ol start="12">
<li>We now need to connect the PressurePad to the Door, so when Ellen steps on the PressurePad it sends a message to open the door. This is very straightforward, since the Door has a GameCommandReceiver component, which can be linked to the PressurePad's Send on Trigger Enter (Script) component. Select the PressurePad GameObject in the Hierarchy and drag DoorSmall into the public Interactive Object slot of its Send on Trigger Enter (Script) component:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/04421538-cb59-41b5-ba19-7f99f4658a55.png"/></p>
<ol start="13">
<li>Run the <strong>Scene</strong>. When Ellen steps onto the PressurePad, the Door should open.</li>
<li>We now need to make the Crystal collidable by adding a Box Collider. Add a Box Collider component to GameObject Crystal and check its On Trigger option.</li>
<li>The <strong>3D Gamekit</strong> has inventory features. Let's make the Crystal collectable by the player by adding an Inventory Item (Script) component. In the <strong>Inspector</strong>, click Add Component, then type inven and choose the Inventory Item scripted component. For that component, type Crystal as the name of the Inventory Key:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cd5e7d90-f9fa-4f87-824d-9544e5c5d6cb.png"/></p>
<p>The Inventory Key names must match between the Inventory Object and the Inventory slot.</p>
<ol start="16">
<li>Now, we can add an Inventory Controller (Script) component to Ellen, with a slot for a Crystal. In the Hierarchy, select the Ellen GameObject. In the <strong>Inspector</strong>, click Add Component, then type inven and choose the Inventory Item scripted component.</li>
<li>In the <strong>Inspector</strong>, we now need to configure the properties of the Inventory Controller (Script) component as follows:
<ul>
<li>Change the Size from <kbd>0</kbd> to <kbd>1</kbd></li>
<li>For its Key, type Crystal</li>
<li>For the On Add() events, click the plus sign, +, to create a new event.</li>
<li>Drag Ellen into the Object slot for the new event (below Runtime Only).</li>
<li>Change the function from No Function to InventoryController Add Item.</li>
<li>Finally, type the name of this item in the Inventory as Crystal:</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e3770da-70b6-4b32-8fda-ec00df5d6dad.png" style="width:38.83em;height:17.33em;"/></p>
<ol start="18">
<li>Run the <strong>Scene</strong>. Ellen can now open the Door via the <strong>PressurePad</strong> and walk into the Crystal, which is added to her inventory.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have dipped our toes into the wide range of features of the <strong>3D GameKit</strong>. Hopefully, this recipe gave you an idea of how to work with the provided <strong>Prefabs,</strong> and how <strong>3D Gamekit</strong> components could be added to custom GameObjects.</p>
<p>Check out these links to learn more:</p>
<ul>
<li>The 3DGamekit reference guide: <a href="https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-3d-reference-guide?playlist=51061">https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-3d-reference-guide?playlist=51061</a></li>
<li class="SourceCode">The Unity 3DGamekit walkthrough pages: <a href="https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-walkthrough?playlist=51061">https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-walkthrough?playlist=51061</a></li>
<li class="SourceCode">Download the 3DGameKit, including a sample Scene, from the Asset Store: <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/3d-game-kit-beta-115747?_ga=2.127077645.1823824032.1533576706-1834737598.1481552646">https://assetstore.unity.com/packages/essentials/tutorial-projects/3d-game-kit-beta-115747?_ga=2.127077645.1823824032.1533576706-1834737598.1481552646</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Importing third-party 3D models and animations from Mixamo</h1>
                
            
            
                
<p>While there are many <strong>3D models</strong> and animations available and ready to use in Unity from the Asset Store, there are many more sources of 3D assets from third-party organisations. Mixamo (now part of Adobe) offers a fantastic range of characters and animations via their web-based system.</p>
<p class="CDPAlignLeft CDPAlign">In this recipe, we'll select and download a character and some animations, formatting them for use with Unity and controlling the animations with an Animation Controller State Chart:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f4718f36-a89d-4b84-854d-a9457d4759cf.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe uses the free Adobe Mixamo system, so you'll need to sign up for an account with them if you don't have one already.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To import third-party <strong>3D models</strong> and animations from Mixamo, follow these steps:</p>
<ol>
<li>Open a web browser and visit <a href="http://Mixamo.com">Mixamo.com</a>.</li>
<li>Sign up/log in with your Mixamo/Adobe account.</li>
<li>Select the Characters section (from navigation bar at top-left of web page)</li>
<li>Select your character, such as Lola B Styperek. You'll see this character appear in the right-hand preview panel.</li>
<li>Download your character, choosing FBX For Unity (.fbx) and T-pose:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/397a60b1-597c-4d9b-af3f-d5f1e83f9158.png"/></p>
<ol start="6">
<li>Create a new 3D Unity project, and in the Project panel create a folder named <kbd>Models</kbd>.</li>
<li>Import the downloaded FBX file into the <kbd>Models</kbd> folder.</li>
<li>Select the asset file in the Project panel, and in the <strong>Inspector</strong> select the Materials section.</li>
<li>Click the Extract Textures... button and extract the model's Textures into your <kbd>Models</kbd> folder. If asked to fix an issue with a Material using a Texture as a Normal Map, choose Fix Now:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/77520cdc-deb0-4abd-8235-2fd285ef3ccd.png"/></p>
<ol start="10">
<li>Drag the clone of the character from the Project panel into the <strong>Scene</strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/68886c91-6df0-4d83-a425-af2e3c470839.png"/></p>
<ol start="11">
<li>We need an Animator Controller to manage animations. Create a new <strong>Animator</strong> Controller file in the Project panel named Lola-Animator-Controller.</li>
<li>Select Lola B Styperek in the Hierarchy. In the <strong>Inspector</strong>, you'll see a Controller slot for the <strong>Animator</strong> component. Drag the Lola-Animator-Controller file from the Project panel into the Animator | Controller slot.</li>
<li>Now, let's animate this model. Go back to the <a href="http://Mixamo.com">Mixamo.com</a> webpage and select an animation, such as Golf Drive. Click the Download button and choose these options:
<ul>
<li>Format: FBX for Unity (.fbx)</li>
<li>Frames per second: 30</li>
<li>Skin: Without skin</li>
<li>Keyframe reduction: none</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3aa7162c-1935-448b-9c91-9cca66f9a239.png" style="width:32.58em;height:13.17em;"/></p>
<ol start="14">
<li>Import the Animation Clip FBX file (lola_b_styperek@Golf Drive.fbx in this case) into the Animation folder of your Unity project.</li>
<li>Double-click the Lola-Animator-Controller file to open the Animator (state machine) editor panel.</li>
<li>Drag the Golf Drive Animation Clip into the <strong>Animator</strong> panel; it should appear as an orange state, with a Transition from Entry to it (that is, this one state becomes the default state):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1b2d65df-90ed-454c-a685-aedddadfbdaf.png"/></p>
<ol start="17">
<li>Run the <strong>Scene</strong>. You should now see Lola practicing her golf swing. If you have the character selected in the Hierarchy and can view the <strong>Animator</strong> panel, you'll see that the Golf Swing Animation Clip (State) is playing:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6727d629-0207-4e43-874e-80cba29a5418.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Mixamo exports 3D rigged character models and <strong>Animation Clips</strong> in FBX format. The <strong>Materials</strong> for models are embedded in the FBX file, so we had to extract them once the model was imported into Unity.</p>
<p>Unity controls the animation of models with an Animator Controller, so we had to create one for our character model and then drag in the Animation Clip we wished to use to animate our model.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to go further with this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Looping the animation</h1>
                
            
            
                
<p>Select the Animation Clip in the Project panel, and in the <strong>Inspector</strong> check its Loop Time option, then click the Apply button to make the change to this asset file. When you run the <strong>Scene</strong>, Lola will now repeat the animation indefinitely.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scripting events to control when Animation Clips are played</h1>
                
            
            
                
<p>Additional Animation Clips can be added to the State Chart in the character's Animator Controller. You can then define variables and Triggers, to define when Animations Transition from one clip to another. Many of the recipes in this chapter illustrate ways to allow scripts to influence the Transition from one Animation Clip (State) to another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Information sources about importing models and animations into Unity</h1>
                
            
            
                
<p>Learn more about model and animation importing from the following:</p>
<ul>
<li class="SourceCode">Unity docs on importing <strong>3D Models</strong>: <a href="https://docs.unity3d.com/Manual/HOWTO-importObject.html">https://docs.unity3d.com/Manual/HOWTO-importObject.html</a></li>
<li class="SourceCode">Unity docs about the <strong>Model Import Settings</strong> window: <a href="https://docs.unity3d.com/Manual/class-FBXImporter.html">https://docs.unity3d.com/Manual/class-FBXImporter.html</a></li>
<li class="SourceCode">Unity docs about the <strong>Model</strong> tab: <a href="https://docs.unity3d.com/Manual/FBXImporter-Model.html">https://docs.unity3d.com/Manual/FBXImporter-Model.html</a></li>
<li class="SourceCode">Unity docs about <strong>Model</strong> file formats: <a href="https://docs.unity3d.com/Manual/3D-formats.html">https://docs.unity3d.com/Manual/3D-formats.html</a></li>
<li class="SourceCode">Samples of <strong>Mixamo</strong> free assets in the <strong>Asset Store</strong>:
<ul>
<li class="SourceCode"><a href="https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320">https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320</a></li>
<li class="SourceCode"><a href="https://assetstore.unity.com/packages/3d/animations/magic-pack-36269">https://assetstore.unity.com/packages/3d/animations/magic-pack-36269</a></li>
</ul>
</li>
</ul>


            

            
        
    </body></html>