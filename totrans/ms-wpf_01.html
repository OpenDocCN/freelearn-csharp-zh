<html><head></head><body>
        

                            
                    <h1 class="header-title">A Smarter Way of Working with WPF</h1>
                
            
            
                
<p>When <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) was first released as part of the .NET Framework Version 3.0 in 2006, it was billed as the future of desktop application <strong>Graphical User Interface</strong> (<strong>GUI</strong>) languages and supporters claimed that it would put an end to the previous GUI technology, Windows Forms. However, as time passed, it has fallen far short of this claim.</p>
<p>There are three main reasons that WPF has not taken off as widely as previously expected. The first reason has nothing to do with WPF and stems from the recent push to host everything in the cloud and having web interfaces rather than desktop applications. The second reason relates to the very steep learning curve and a very different way of working that is required to master WPF.</p>
<p>The last reason is that it is not a very efficient language and if a WPF application has lots of 'bells and whistles' in, then either the client computers will need to have additional RAM and/or graphics cards installed, or they could face a slow and stuttering user experience.</p>
<p>This explains why many companies that make use of WPF today are in the finance industry, where they can afford to upgrade all users' computers to be able to run their applications optimally. This book will aim to make WPF more accessible to the rest of us by providing practical tips and tricks to help build our real-world applications more easily and more efficiently.</p>
<p>One of the simplest changes with the biggest workflow improvements that we can make to improve the way we work with WPF is to follow the MVVM software architectural pattern. It describes how we can organize our classes to make our applications more maintainable, testable, and generally simpler to understand. In this chapter, we will take a closer look at this pattern and discover how it can help us to improve our applications.</p>
<p>After discovering what MVVM is and what its benefits are, we'll learn several new ways to communicate between the various components in this new environment. We'll then focus on the physical structure of the code base in a typical MVVM application and investigate a variety of alternative arrangements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is MVVM and how does it help?</h1>
                
            
            
                
<p><strong>Model-View-View Model</strong> (<strong>MVVM</strong>) is a software architectural pattern that was famously introduced by John Gossman on his blog back in 2005 and is now commonly used when developing WPF applications. Its main purpose is to provide a <em>Separation of Concerns</em> between the business model, the <strong>User Interface</strong> (<strong>UI</strong>), and the business logic. It does this by dividing them into three distinct types of core components: Models, Views, and View Models. Let's take a look at how they are arranged and what each of these components represent:</p>
<div><img class="alignnone size-full wp-image-1985 image-border" src="img/98dd5eb7-7c66-4c06-ae58-b093dafc0a60.png" style="width:31.83em;height:8.08em;"/></div>
<p>As we can see here, the <strong>View Models</strong> component sits between the <strong>Models</strong> and the <strong>Views</strong> and provides two-way access to each of them. It should be noted at this point that there should be no direct relationship between the <strong>Views</strong> and <strong>Models</strong> components and only loose connections between the other components. Let's now take a closer look at what each of these components represent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Models</h1>
                
            
            
                
<p>Unlike the other MVVM components, the Model constituent comprises of a number of elements. It encompasses the business data model along with its related validation logic and also the <strong>Data Access Layer</strong> (<strong>DAL</strong>), or data repositories, that provide the application with data access and persistence.</p>
<p>The data model represents the classes that hold the data in the application. They typically mirror the columns in the database more or less, although it is common that they are hierarchical in form, and so may require joins to be performed in the data source in order to fully populate them.</p>
<p>One alternative would be to design the data model classes to fit the requirements in the UI, but either way, the business logic or validation rules will typically reside in the same project as the data model.</p>
<p>The code that is used to interface with whatever data persistence technology is used in our application is also included within the Models component of the pattern. Care should be taken when it comes to organizing this component in the code base, as there are a number of issues to take into consideration. We'll investigate this further in a while, but for now, let's continue to find out more about the components in this pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">View Models</h1>
                
            
            
                
<p>The View Models can be explained easily; each View Model provides its associated View with all of the data and functionality that it requires. In some ways, they can be considered to be similar to the old Windows Forms code behind files, except that they have no direct relationship with the View that they are serving. A better analogy, if you're familiar with MVC, would be that they are similar to the Controllers in the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) software architectural pattern. In fact, in his blog, John describes the MVVM pattern as being a variation of the MVC pattern.</p>
<p>They have two-way connections with the Model component in order to access and update the data that the Views require, and often, they transform that data in some way to make it easier to display and interact within the UI. They also have two-way connections with the Views through data binding and property change notification. In short, View Models form the bridge between the Model and the View, which otherwise have no connection to each other.</p>
<p>However, it should be noted that the View Models are only loosely connected to the Views and Model components through their data binding and interfaces. The beauty of this pattern enables each element to be able to function independently from each other.</p>
<p>To maintain the separation between the View Models and the View, we avoid declaring any properties of UI-related types in the View Model. We don't want any references to UI-related DLLs in our View Models project, and so we make use of custom <kbd>IValueConverter</kbd> implementations to convert them to primitive types. For example, we might convert <kbd>Visibility</kbd> objects from the UI to plain <kbd>bool</kbd> values or convert the selection of some colored <kbd>Brush</kbd> objects to an <kbd>Enum</kbd> instance that is safe to use in the View Model. We will see several examples of converters throughout this book, but for now, let's continue.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Views</h1>
                
            
            
                
<p>The Views define the appearance and layout of the UI. They typically connect with a View Model through the use of their <kbd>DataContext</kbd> property and display the data that it supplies. They expose the functionality provided by the View Model by connecting its commands to the UI controls that the users interact with.</p>
<p>In general, the basic rule of thumb is that each View has one associated View Model. This does not mean that a View cannot data bind to more than one data source or that we cannot reuse View Models. It simply means that, in general, if we have a class called <kbd>SecurityView</kbd>, it is more than likely that we'll also have an instance of a class named <kbd>SecurityViewModel</kbd> that will be set as the value of that View's <kbd>DataContext</kbd> property.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data binding</h1>
                
            
            
                
<p>One often overlooked aspect of the MVVM pattern is its requirement for data binding. We could not have the full <strong>Separation of Concerns</strong> without it, as there would be no easy way of communicating between the Views and View Models. The XAML markup, data binding classes, and <kbd>ICommand</kbd> and <kbd>INotifyPropertyChanged</kbd> interfaces are the main tools in WPF that provide this functionality.</p>
<p>The <kbd>ICommand</kbd> interface is how commanding is implemented in the .NET Framework. It provides behavior that implements and even extends the ever useful Command pattern, in which an object encapsulates everything needed to perform an action. Most of the UI controls in WPF have <kbd>Command</kbd> properties that we can use to connect them to the functionality that the commands provide.</p>
<p>The <kbd>INotifyPropertyChanged</kbd> interface is used to notify binding clients that property values have been changed. For example, if we had a <kbd>User</kbd> object and it had a <kbd>Name</kbd> property, then our <kbd>User</kbd> class would be responsible for raising the <kbd>PropertyChanged</kbd> event of the <kbd>INotifyPropertyChanged</kbd> interface, specifying the name of the property each time its value was changed. We'll look much deeper into all of this later, but now let's see how the arrangement of these components help us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">So how does MVVM help?</h1>
                
            
            
                
<p>One major benefit of adopting MVVM is that it provides the crucial Separation of Concerns between the business model, the UI, and the business logic. This enables us to do several things. It frees the View Models from the Models, both the business model and the data persistence technology.</p>
<p>This in turn enables us to reuse the business model in other applications and swap out the DAL and replace it with a mock data layer so that we can effectively test the functionality in our view models without requiring any kind of real data connection.</p>
<p>It also disconnects the Views from the View logic that they require, as this is provided by the View Models. This allows us to run each component independently, which has the advantage of enabling one team to work on designing the Views, while another team works on the View Models. Having parallel work streams enables companies to benefit from vastly reduced production times.</p>
<p>Furthermore, this separation also makes it easier for us to swap the Views for a different technology without needing to change our Model code. We may well need to change some aspects of the View Models, for example, the new technology used for the Views may not support the <kbd>ICommand</kbd> interface, but in principle, the amount of code that we would need to change would be fairly minimal.</p>
<p>The simplicity of the MVVM pattern also makes WPF easier to comprehend. Knowing that each View has a View Model that provides it with all the data and functionality that it requires means that we always know where to look when we want to find where our data bound properties have been declared.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Is there a downside?</h1>
                
            
            
                
<p>There are, however, a few drawbacks to using MVVM, and it will not help us in every situation. The main downside to implementing MVVM is that it adds a certain level of complexity to our applications. First, there's the data binding, which can take some time to master. Also, depending on your version of Visual Studio, data binding errors may only appear at runtime and can be very tricky to track down. We will however look into solutions for this in the next chapter.</p>
<p>Then, there are different ways to communicate between the Views and View Models that we need to understand. Commanding and handling events in an unusual way takes a while to get used to. Having to discover the optimal arrangement of all the required components in the code base also takes time. So, there is a steep learning curve to climb before we can become competent at implementing MVVM for sure. This book will cover all of these areas in detail and attempt to lessen the gradient of that learning curve.</p>
<p>However, even when we are well practiced at the pattern, there are still occasional situations when it wouldn't make sense to implement MVVM. One example would be if our application was going to be very small, it would be unlikely that we would want to have unit tests for it or swap out any of its components. It would, therefore, be impractical to go through the added complexity of implementing the pattern when the benefits of the Separation of Concerns that it provides, were not required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debunking the myth about code behind</h1>
                
            
            
                
<p>One of the great misconceptions about MVVM is that we should avoid putting any code into the code behind files of our Views. While there is some truth to this, it is certainly not true in all situations. If we think logically for a moment, we already know that the main reason to use MVVM is to take advantage of the Separation of Concerns that its architecture provides. Part of this separates the business functionality in the View Model from the user interface-related code in the Views. Therefore, the rule should really be that <em>we should avoid putting any business logic into the code behind files of our Views</em>.</p>
<p>Keeping this in mind, let's look at what code we might want to put into the code behind file of a View. The most likely suspects would be some UI-related code, maybe handling a particular event, or launching a child window of some kind. In these cases, using the code behind the file would be absolutely fine. We have no business-related code here, and so we have no need to separate it from the other UI-related code.</p>
<p>On the other hand, if we had written some business-related code in a View's code behind file, then how could we test it? In this case, we would have no way to separate this from the View, no longer have our Separation of Concerns and, therefore, would have broken our implementation of MVVM. So in cases like this, the myth is no longer a myth... it is good advice.</p>
<p>However, even in cases like this where we want to call some business-related code from a View, it <em>is</em> possible to achieve without breaking any rules. As long as our business code resides in a View Model, it can be tested through that View Model, so it's not so important where it is called from during runtime. Understanding that we can always access the View Model that is data bound to a View's <kbd>DataContext</kbd> property, let's look at this simple example:</p>
<pre>private void Button_Click(object sender, RoutedEventArgs e) 
{ 
  UserViewModel viewModel = (UserViewModel)DataContext; 
  viewModel.PerformSomeAction(); 
} </pre>
<p>Now, there are some who would balk at this code example, as they correctly believe that Views should not know anything about their related View Models. This code effectively ties this View Model to this View. If we wanted to change the UI layer in our application at some point or have designers work on the View, then this code would cause us a problem. However, we need to be realistic... what is the likelihood that we will really need to do that?</p>
<p>If it is likely, then we really shouldn't put this code into the code behind file and instead handle the event by wrapping it in an Attached Property, and we'll see an example of this in the next section. However, if it is not at all likely, then there is really no problem with putting it there.</p>
<p>For example, if we have a <kbd>UserView</kbd>, that has one accompanying <kbd>UserViewModel</kbd> class and we are certain that we will not need to change it, then in this case, we can safely use the above code, without fear that direct cast will cause an Exception to be thrown. Let's follow rules when they make sense for us to follow them, rather than blindly sticking to them because somebody in a different scenario said they were a good idea.</p>
<p>One other situation when we can ignore this 'No code behind' rule is when writing self-contained controls based on the <kbd>UserControl</kbd> class. In these cases, the code behind files are often used for defining Dependency Properties and/or handling UI events and for implementing general UI functionality. Remember though, if these controls are implementing some business-related functionality, we should write that into a View Model and call it from the control so that it can still be tested.</p>
<p>There is definitely a perfect sense in the general idea of avoiding writing business-related code in the code behind files of our Views and we should always try to do so. However, we now hopefully understand the reasoning behind this idea and can use our logic to determine whether it is Okay to do it or not in each particular case that may arise.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning how to communicate again</h1>
                
            
            
                
<p>As we tend not to handle UI events directly, when using MVVM, we need alternative ways to implement the same functionality that they provide. Different methods are required to reproduce the functionality of different events. For example, the functionality of the <kbd>SelectionChanged</kbd> event of a collection control is typically reproduced by data binding a View Model property to the <kbd>SelectedItem</kbd> property of the collection control:</p>
<pre>&lt;ListBox ItemsSource="{Binding Items}" 
  SelectedItem="{Binding CurrentItem}" /&gt; </pre>
<p>In this example, the setter of the <kbd>CurrentItem</kbd> property will get called by the WPF Framework each time a new item is selected from the <kbd>ListBox</kbd>. Therefore, instead of handling the <kbd>SelectionChanged</kbd> event in the code behind, we can call any method directly from the property setter in the View Model:</p>
<pre>public TypeOfObject CurrentItem 
{ 
  get { return currentItem; } 
  set 
  { 
    currentItem = value; 
    DoSomethingWithTheNewlySelectedItem(currentItem); 
  } 
} </pre>
<p>Note that we need to keep any methods that we call from data bound property setters from doing too much, as the time that it takes to execute them could negatively affect the performance when entering data. However, in this example, we would typically use this method to start an asynchronous data access function using a value from the current item or alter the value of another property in the View Model.</p>
<p>Many other UI events can be replaced with some form of <kbd>Trigger</kbd> in the XAML markup directly. For example, imagine that we had an <kbd>Image</kbd> element that was set as the <kbd>Content</kbd> property value of a <kbd>Button</kbd> control and that we wanted the <kbd>Image</kbd> element to be semi-transparent when the <kbd>Button</kbd> was disabled. Instead of handling the <kbd>UIElement.IsEnabledChanged</kbd> event in the code behind file, we could write a <kbd>DataTrigger</kbd> in a <kbd>Style</kbd> that we could apply to the <kbd>Image</kbd> element:</p>
<pre>&lt;Style x:Key="ImageInButtonStyle" TargetType="{x:Type Image}"&gt; 
  &lt;Setter Property="Opacity" Value="1.0" /&gt; 
  &lt;Style.Triggers&gt; 
    &lt;DataTrigger Binding="{Binding IsEnabled,       
      RelativeSource={RelativeSource FindAncestor, 
      AncestorType={x:Type Button}}, FallbackValue=False}" 
      Value="False"&gt; 
      &lt;Setter Property="Opacity" Value="0.5" /&gt; 
    &lt;/DataTrigger&gt; 
  &lt;/Style.Triggers&gt; 
&lt;/Style&gt; </pre>
<p>Binding syntax will be covered in detail in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient With Data Binding</em>, but in short, the binding in this <kbd>DataTrigger</kbd> is specifying the target as the <kbd>IsEnabled</kbd> property of the ancestor (or parent) of the <kbd>Image</kbd> element with a type of <kbd>Button</kbd>. When this binding target has a value of <kbd>False</kbd>, the <kbd>Opacity</kbd> property of the <kbd>Image</kbd> will be set to <kbd>0.5</kbd> and set back to its original value when the target property value is <kbd>True</kbd>. Therefore, the <kbd>Image</kbd> element in our <kbd>Button</kbd> will become semi-transparent when the <kbd>Button</kbd> is disabled.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing the ICommand interface</h1>
                
            
            
                
<p>When it comes to button clicks in WPF and MVVM, instead of handling the well-known <kbd>Click</kbd> event, we typically use some form of command that implements the <kbd>ICommand</kbd> interface. Let's take a look at an example of a basic standard command:</p>
<pre>using System; 
using System.Windows.Forms; 
using System.Windows.Input; 
 
public class TestCommand : ICommand 
{ 
  public event EventHandler CanExecuteChanged; 
 
  public void Execute(object parameter) 
  { 
    MessageBox.Show("You executed a command"); 
  } 
 
  public bool CanExecute(object parameter) 
  { 
    return true; 
  } 
}</pre>
<p>Please note that in this book, we will display code with two-space tabs, instead of the more commonly used four-space tabs, in order to enable more characters of each code snippet to fit onto each line.</p>
<p>We can see that it has an <kbd>Execute</kbd> method, where the functionality that the command provides is performed. The <kbd>CanExecute</kbd> method is called by the <kbd>CommandManager</kbd> at various points over time, when it believes that the output value may have changed. We'll cover this in more detail later, but basically, raising the <kbd>CanExecuteChanged</kbd> event is one of the ways to trigger the <kbd>CommandManager</kbd> to do this. The output of the <kbd>CanExecute</kbd> method specifies whether the <kbd>Execute</kbd> method can be called or not.</p>
<p>You can imagine how cumbersome it would be if we had to create one of these classes for every action that we needed to implement. Furthermore, there is no context of where the command was called from other than the single command parameter. This means that if we wanted the command to add an item into a collection, we would have to put both the collection and the item to add into another object so that they could both be passed through the single input parameter.</p>
<p>When using MVVM, rather than implementing the commands in the standard way, we tend to use a single, reusable implementation that allows us to handle actions with standard methods directly in the View Model. This enables us to use commands without having to create a separate class for each one. There are a number of variations of this command, but its simplest form is shown here:</p>
<pre>using System; 
using System.Windows.Input; 
 
public class ActionCommand : ICommand 
{ 
  private readonly Action&lt;object&gt; action; 
  private readonly Predicate&lt;object&gt; canExecute; 
 
  public ActionCommand(Action&lt;object&gt; action) : this(action, null) { } 
 
  public ActionCommand(Action&lt;object&gt; action, 
    Predicate&lt;object&gt; canExecute) 
  { 
    this.action = action; 
    this.canExecute = canExecute; 
  } 
 
  public event EventHandler CanExecuteChanged 
  { 
    add { CommandManager.RequerySuggested += value; } 
    remove { CommandManager.RequerySuggested -= value; } 
  } 
 
  public bool CanExecute(object parameter) 
  { 
    return canExecute == null ? true : canExecute(parameter); 
  } 
 
  public void Execute(object parameter) 
  { 
    action(parameter); 
  } 
} </pre>
<p>The <kbd>action</kbd> parameter of type <kbd>Action&lt;object&gt;</kbd> will hold the reference to the method that will be called when the command is executed and the <kbd>object</kbd> generic parameter relates to the optionally used command parameter. The <kbd>canExecute</kbd> parameter of type <kbd>Predicate&lt;object&gt;</kbd> will hold the reference to the method that will be called to verify whether the command can be executed or not and its <kbd>object</kbd> generic parameter relates to the optionally used command parameter again.</p>
<p>The <kbd>CanExecuteChanged</kbd> event should be raised whenever the <kbd>canExecute</kbd> parameter value changes. It is typically handled by command sources, such as the <kbd>Button</kbd> control, to set their <kbd>IsEnabled</kbd> property value appropriately. When a command source receives a notification that this event has been raised, it will call the <kbd>ICommand.CanExecute</kbd> method to check the new value. Therefore, when a command can execute, its data bound control will be enabled and when it can't, its data bound control will be disabled.</p>
<p>The <kbd>CommandManager.RequerySuggested</kbd> event will be raised when the <kbd>CommandManager</kbd> detects a change in the UI that could reflect on whether a command could execute or not. For example, this could be due to a user interaction, such as the selection of an item in a collection or some other change in focus. Therefore, connecting one to the other seems to be a logical thing to do. In fact, an example of this is actually found in the source code of the .NET <kbd>RoutedCommand</kbd> class.</p>
<p>This command class is typically used in the View Model classes, as shown in the following example, where the command functionality comes from the <kbd>Save</kbd> method and the <kbd>bool</kbd> return value of the <kbd>CanSave</kbd> method determines whether the command can execute or not:</p>
<pre>public ICommand SaveCommand 
{ 
  get { return new ActionCommand(action =&gt; Save(), 
    canExecute =&gt; CanSave()); } 
} </pre>
<p>A safer way to ensure that the command is never called <em>by code</em> when the <kbd>CanExecute</kbd> condition is not satisfied would be to make this alteration; however, note that the <kbd>CommandManager</kbd> class will always perform this check before calling any commands anyway:</p>
<pre>public void Execute(object parameter) 
{ 
  if (CanExecute(parameter)) action(parameter); 
} </pre>
<p>Full credit for this custom command should go to Josh Smith, as his <kbd>RelayCommand</kbd> class was the first implementation like this that I came across, although there are several variations to be found online. The beauty of this particular implementation should not be underestimated. Not only is it simple, elegant, and saves us from writing large amounts of code, but it also makes testing our functionality much easier, as our command code can now be defined right in our View Models.</p>
<p>We'll look at this <kbd>ActionCommand</kbd> again and in more detail in <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml">Chapter 3</a>, <em>Writing Custom Application Frameworks</em>, but for now, let's move on to the next method of communication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling events in Attached Properties</h1>
                
            
            
                
<p>There is one way to handle events in WPF without having to resort to writing code in the code behind file of a View. Using Attached Properties, we can encapsulate the handling of events and effectively expose their behavior using properties that we can data bind to in our Views. Let's take a look at a simple example using the <kbd>PreviewKeyDown</kbd> event:</p>
<pre>public static DependencyProperty OnEnterKeyDownProperty =  
  DependencyProperty.RegisterAttached("OnEnterKeyDown", 
  typeof(ICommand), typeof(TextBoxProperties), 
  new PropertyMetadata(OnOnEnterKeyDownChanged)); 
 
public static ICommand GetOnEnterKeyDown(DependencyObject dependencyObject) 
{ 
  return (ICommand)dependencyObject.GetValue(OnEnterKeyDownProperty); 
} 
 
public static void SetOnEnterKeyDown(DependencyObject dependencyObject, 
  ICommand value) 
{ 
  dependencyObject.SetValue(OnEnterKeyDownProperty, value); 
} 
 
private static void OnOnEnterKeyDownChanged( 
  DependencyObject dependencyObject, 
  DependencyPropertyChangedEventArgs e) 
{ 
  TextBox textBox = (TextBox)dependencyObject; 
  if (e.OldValue == null &amp;&amp; e.NewValue != null)  
    textBox.PreviewKeyDown += TextBox_OnEnterKeyDown; 
  else if (e.OldValue != null &amp;&amp; e.NewValue == null)  
    textBox.PreviewKeyDown -= TextBox_OnEnterKeyDown; 
} 
 
private static void TextBox_OnEnterKeyDown(object sender, KeyEventArgs e) 
{ 
  if (e.Key == Key.Enter || e.Key == Key.Return) 
  { 
    TextBox textBox = sender as TextBox; 
    ICommand command = GetOnEnterKeyDown(textBox); 
    if (command != null &amp;&amp; command.CanExecute(textBox))  
      command.Execute(textBox); 
  } 
} </pre>
<p>As can be seen in this example, the event is handled by attaching an event handler in the normal way, except that all relating code is encapsulated within the class that declares the Attached Property. Let's take a closer look. First, we declare an Attached Property named <kbd>OnEnterKeyDown</kbd> of type <kbd>ICommand</kbd> in a class named <kbd>TextBoxProperties</kbd>, and we pass a reference of our handling method to the <kbd>PropertyChangedCallback</kbd> delegate parameter of the <kbd>PropertyMetadata</kbd> constructor.</p>
<p>The <kbd>GetOnEnterKeyDown</kbd> and <kbd>SetOnEnterKeyDown</kbd> methods represent the normal way to get and set Attached Property values. In the unfortunately named <kbd>OnOnEnterKeyDownChanged</kbd> method, which will be called when the property value changes, we look at the <kbd>NewValue</kbd> and <kbd>OldValue</kbd> values of the <kbd>DependencyPropertyChangedEventArgs</kbd> input parameter in order to decide whether we need to attach or detach the event handler to the <kbd>PreviewKeyDown</kbd> event of the relevant <kbd>TextBox</kbd>.</p>
<p>If the <kbd>OldValue</kbd> value is <kbd>null</kbd> and the <kbd>NewValue</kbd> value is not <kbd>null</kbd>, it means that there was no previous value, and so the property is being set for the first time. In this case, we want to attach the event handler. Conversely, when the <kbd>OldValue</kbd> value is not <kbd>null</kbd> and the <kbd>NewValue</kbd> value is <kbd>null</kbd>, it means that there previously was a value, which has been removed, so we should detach the event handler.</p>
<p>Finally, the <kbd>TextBox_OnEnterKeyDown</kbd> event handling method first detects whether either the <em>Enter</em> key or the <em>Return</em> key were pressed. If one was pressed, the data bound <kbd>ICommand</kbd> instance is checked for <kbd>null</kbd> and if the command can execute, it is then executed. Therefore, we have effectively wrapped a <kbd>PreviewKeyDown</kbd> event in an Attached Property and can now execute any command that has been data bound to it when the user presses <em>Enter</em> on their keyboard.</p>
<p>In order to use this Attached Property, we must first add a XAML namespace prefix for our <kbd>Attached</kbd> folder in the XAML file of the View that this functionality is required in. Note that the <kbd>TextBoxProperties</kbd> class will be declared in the <kbd>Attached</kbd> folder of the Views project and so, its namespace will be as follows:</p>
<pre>xmlns:Attached="clr-namespace:CompanyName.ApplicationName.Views.Attached;  
  assembly=CompanyName.ApplicationName.Views" </pre>
<p>Microsoft's convention for naming these prefixes is for the first character to be a lowercase letter, but it has always made more sense to me to simply use the last segment of the declared namespace, which will start with a capital letter. Once you have defined the prefix, you can use the Attached Property, as shown in the following example:</p>
<pre>&lt;TextBox Attached:TextBoxProperties.OnEnterKeyDown="{Binding Command}" /&gt; </pre>
<p>Any UI events that we might need to handle in our applications can be encapsulated in Attached Properties in this same way. At first, this might seem to be a complicated way to handle events, compared with having a simple handler in a code behind file, but once we have a collection of these properties declared, we will find ourselves having to create fewer and fewer new ones. Think of them as simply being a reusable way of converting events into properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making use of delegates</h1>
                
            
            
                
<p>Delegates are very similar to events and, in fact, events can be thought of as a particular kind of delegate. They are a very simple tool to use to pass a signal or message from one place to another in the program. Unlike when creating custom events, we are not forced to use particular input parameters, for example, some form of the <kbd>EventArgs</kbd> class. We are totally unconstrained when creating custom delegates and are able to define our own method signatures, including both input and output parameter types.</p>
<p>As most of you will already be familiar with events and event handling, you'll already inadvertently know how to use delegates too. Let's look at a simple example. Imagine that we have a parent View Model that spawns child View Models and that one of these child View Models is paired with a View that enables administrative users to select security permissions. Now, let's imagine that the parent View that relates to the parent View Model has a menu that needs to be updated depending on the user's selection in the child View. How do we notify the parent View Model upon selection?</p>
<p>This is where delegates save the day. Keeping this example simple initially, let's say that we just need to notify the parent View Model that a particular change has been made so that it can refresh the current user's security permissions from a database. In this case, we only need to pass a signal, so we can create a delegate with no input or output parameters. We can declare it in the View Model that will be sending the signal, in this case, the child View Model:</p>
<pre>public delegate void Signal(); </pre>
<p>Note that we define it in the same way that we define an abstract method, except that the <kbd>abstract</kbd> keyword is replaced with the <kbd>delegate</kbd> keyword after the access modifier. In short, a delegate defines a type that references a method with a particular signature. Now that we have defined our signaling delegate, we need to create a way for elements outside the View Model to use it. For this, we can simply create a property of the type of our new delegate <em>in the same View Model</em>:</p>
<pre>public Signal OnSecurityPermissionChanged { get; set; }  </pre>
<p>As we don't need any property change notifications for this property, we can save ourselves some typing and take advantage of the .NET Auto-Implemented Property syntax. Bear in mind that delegates work in a multicast way like events, meaning that we can attach more than one handler to each one. In order to do this, we need to use the <kbd>+=</kbd> operator to add handlers for the delegate, and in this example, we would want to do that in the parent View Model when the child View is instantiated:</p>
<pre>ChildViewModel viewModel = new ChildViewModel(); 
viewModel.OnSecurityPermissionChanged += RefreshSecurityPermissions; </pre>
<p>Here, we have assigned the <kbd>RefreshSecurityPermissions</kbd> method in the parent View Model to be the handler for this delegate. Note that we omit the parenthesis and the input parameters if there were any when attaching the handler. Now, you may be wondering, "<em>What does the method signature of this handler look like?</em>", but you already have the answer to this. If you remember, we declared the delegate with the signature of the method that we want to handle it. Therefore, any method that shares this signature can be a handler for this type of delegate:</p>
<pre>private void RefreshSecurityPermissions() 
{ 
  // Refresh user's security permissions when alerted by the signal 
} </pre>
<p>Note that the name used is irrelevant and all that matters when matching the delegate signature are the input and output parameters. So, we now have our delegate declared and hooked up to a handler in the parent View Model, but it's still not going to do anything because we haven't actually called it yet. In our example, it's the child View Model that is going to call the delegate because that's the object that needs to send out the information or signal in this case.</p>
<p>When calling delegates, we must always remember to check for <kbd>null</kbd> before trying to use them because there may be no handlers attached. In our example, we'd call our <kbd>Signal</kbd> delegate via the <kbd>OnSecurityPermissionChanged</kbd> property at the point that we need to send the signal from the child View Model, let's say in reaction to a user changing their own security permissions:</p>
<pre>if (OnSecurityPermissionChanged != null) OnSecurityPermissionChanged(); </pre>
<p>Alternatively, we could do so using the more concise null conditional operator in C# Version 6.0, which calls the delegate's <kbd>Invoke</kbd> method if it is not <kbd>null</kbd>:</p>
<pre>OnSecurityPermissionChanged?.Invoke(); </pre>
<p>Note that we do need to include the parenthesis when calling the delegate in the first example even though <kbd>OnSecurityPermissionChanged</kbd> is a property. This is because the delegate type of the property relates to a method and it is that method that we are calling. Please bear in mind that the first of these methods is not thread safe, so if thread safety is important for your application, then you will need to use the latter way.</p>
<p>We now have the complete picture, but while it is common to have a signal-sending delegate such as this, it is not overly useful because it only passes a signal with no other information. In many real-world scenarios, we would typically want to have some sort of input parameter so that we could pass some information, rather than just a signal.</p>
<p>For example, if we wanted to be notified with details each time a user selected a different item from a collection control in the UI, we could add a <kbd>CurrentItem</kbd> property into a generic <kbd>BaseCollection</kbd> class in our application and data bind it to the data bound collection control's <kbd>SelectedItem</kbd> property. This <kbd>CurrentItem</kbd> property would then be called by the WPF Framework each time a user makes a new selection, and so we can call our new delegate from its property setter:</p>
<pre>protected T currentItem; 
 
public virtual CurrentItemChange CurrentItemChanged { get; set; }  
 
public virtual T CurrentItem 
{ 
  get { return currentItem; } 
  set 
  { 
    T oldCurrentItem = currentItem; 
    currentItem = value; 
    CurrentItemChanged?.Invoke(oldCurrentItem, currentItem); 
    NotifyPropertyChanged(); 
  } 
} </pre>
<p>Delegates can be used to communicate between any related classes as long as they have access to the class that exposes the delegate so that they can attach a handler. They are commonly used to send information between child Views or View Models and their parents, or even between Views and View Models, but they can also be used to pass data between any two connected parts of the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Structuring the application code base</h1>
                
            
            
                
<p>Now that we have a better understanding of the MVVM pattern, let's look at how we might implement it in a WPF application. What should the folder structure of our application be like? Clearly, we'll need somewhere to put our Models, Views, and View Models; however, how we arrange them will somewhat depend on the overall size of our application.</p>
<p>As we have heard, very small projects do not really suit MVVM because implementing it can involve a lot of preparation and often, the benefits do not apply. For small WPF applications, we would typically have just one project in our WPF application. In these cases, our classes would be separated into different folders within the single project.</p>
<p>With larger scale applications, we arrange our classes in the same basic structure, but as there are more classes and more chance that we want to reuse some of this code, it makes sense to use separate projects instead of folders. Either way, our classes should end up with the same CLR namespaces, as they tend to follow the structure of the application, regardless of whether those classes were separated using folders or projects.</p>
<p>While the CLR namespace in our startup project might be something along the lines of <kbd>CompanyName.ApplicationName</kbd>, the namespace of the classes in the Models component would be, or start with, <kbd>CompanyName.ApplicationName.Models</kbd>. For the purpose of the remainder of this book, we will assume that we are dealing with a large-scale WPF application and using projects for the separation of our classes.</p>
<p>There is nothing in the MVVM pattern that dictates what structure our code base should have, although there are clues. We will clearly need <kbd>Views</kbd> and <kbd>ViewModels</kbd> projects, but the <kbd>Models</kbd> project is less clearly defined. There are several elements within the Models component of MVVM, but we don't necessarily want to group them all into a single project in our code base. There are other projects that will be required too. Let's visualize some possible structures so that we can get started with building our application:</p>
<div><img class="image-border" src="img/0faeb42c-346d-4736-a08d-6c26003769a3.png" style="padding: 30px;background-color: white;width:24.67em;height:41.00em;"/></div>
<div><img class="image-border" src="img/26ebd2db-8063-469d-9f44-f7822aa24234.png" style="padding: 30px;background-color: white;width:28.58em;height:48.50em;"/> </div>
<div><p>These examples offer an insight into what the project structure of an MVVM-based WPF application might look like. However, nothing is set in stone and we are free to rename and to reorganize our application projects as we see fit. The important thing is how the components are connected together rather than the arrangement of the application files.</p>
<p>After we have developed a number of WPF applications, we get a feel for which project names and which structure we prefer, so I'd suggest trying a few variations and seeing which you feel more comfortable working with. Of course, some of us may not have the luxury of being able to create or alter the structure of the application that we work on. Let's first focus on the projects common to both example structures.</p>
<p>We see that the <kbd>Images</kbd> and <kbd>Resources</kbd> folders reside in the startup project. While this is customary, they <em>can</em> technically reside in any project or even in their own project. However, I prefer to keep them in this project because it provides a marginal performance benefit. Typically, when using MVVM, the only other files in the startup project will be the <kbd>MainWindow.xaml</kbd> and <kbd>MainWindow.xaml.cs</kbd> files, unless they reside with the other views, and the <kbd>App.xaml</kbd> (possibly with its code behind file) and <kbd>app.config</kbd> files.</p>
<p>The <kbd>Images</kbd> folder contains the images and icons that are displayed in the UI controls, whereas the <kbd>Resources</kbd> folder normally contains any resource files, such as XML schemas or text or data files that are used by the application.</p>
<p>The next project is named <kbd>Converters</kbd> and is fairly self-explanatory. It only contains classes that have implemented the <kbd>IValueConverter</kbd> or <kbd>IMultiValueConverter</kbd> interfaces and are used for converting data-bound values in the Views. These classes are all reusable and the DLL from this project should be kept up to date and shared among our other applications.</p>
<p>Both examples show an <kbd>Extensions</kbd> project, but this is entirely optional and not a requirement of the MVVM pattern. I just happen to find Extension Methods to be an essential part of .NET development, having built up a large collection of invaluable helper methods. After getting used to being able to call <kbd>Add</kbd> on an <kbd>IEnumerable</kbd> instance or <kbd>ToObservableCollection</kbd> on a query result, for example, I now reuse them in every application. We'll see some examples of these in <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml">Chapter 3</a>, <em>Writing Custom Application Frameworks</em>, <a href="549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml">Chapter 9</a>, <em>Implementing Responsive Data Validation</em>, and <a href="506906a3-83cb-4b51-9ac5-3c00e650198a.xhtml">Chapter 10</a>, <em>Completing That Great User Experience</em>.</p>
<p>The next common project that we can see is a project called <kbd>Managers</kbd>. Others may prefer to call this <kbd>Engines</kbd>, <kbd>Services</kbd>, or something similar, but that is just a personal preference, and either way, the content will be the same. In this project, we typically find a number of classes that together provide a wide variety of functionality to the View Models.</p>
<p>For example, in this project, we might find classes named <kbd>ExportManager</kbd>, <kbd>FeedbackManager</kbd>, <kbd>HardDriveManager</kbd>, <kbd>WindowManager</kbd>, and so on.</p>
<p>It is important to have a project like this, where we have one common place to provide all of the required specialized functionality for our application, rather than having to repeat the code in each View Model that requires that certain functionality. These classes are totally reusable between applications and this arrangement also promotes behavioral consistency throughout the application.</p>
<p>For example, without consolidating all of our functionality in this project, we might be tempted to copy and paste certain bits of code from one View Model to another. If the code then requires a change in the future, we may not remember that it has been copied and only update it in one View Model, thereby breaking the consistency of the application.</p>
<p>Another benefit of utilizing a project like this is that it reduces the number of references that the other projects need. The <kbd>Managers</kbd> project will typically require many references to be added, whereas the View Model and other classes that make use of its functionality will only need to add a single reference to this project.</p>
<p>Some or all of the functionality from these classes can be exposed through a <kbd>BaseViewModel</kbd> class and can therefore be made available to every View Model. We'll see more about this in <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml">Chapter 3</a>, <em>Writing Custom Application Frameworks</em>, but for now, let's start to look at the differences between the two structures.</p>
<p>In the first structure example, the <kbd>Business</kbd> folder within the <kbd>Models</kbd> project simply represents the business data models of the application. There's no real need to have these classes in a separate <kbd>Business</kbd> folder other than the fact that it highlights that they are connected with the <kbd>ViewModels.Business</kbd> View Models and the <kbd>Views.Business</kbd> Views.</p>
<p>Technically, the data model classes in our application should represent our business objects and not contain any properties that bear no relevance to the business model, such as properties named <kbd>CurrentItem</kbd> or <kbd>IsSelected</kbd>. If this were the case and they were defined in their own project, as shown in the first example, then we could reuse their DLL in our other business applications. Alternatively, perhaps we already have a DLL representing the business model from another application that we will be reusing in the next application.</p>
<p>In either of these cases, we would need to add other folders into the <kbd>ViewModels</kbd> project in which we would implement an additional View Model class for each business model class to be displayed. This arrangement is shown in the <kbd>ViewModels</kbd>. Business folder of the first example and demonstrates the separation of the data model from the Views.</p>
<p>In these classes, we would encapsulate each public business model property in a new property that raised change notification and add any further properties required by the UI. It would look similar to the following example, where the <kbd>BaseBusinessViewModel</kbd> class simply implements the <kbd>INotifyPropertyChanged</kbd> interface:</p>
<pre>using System;

namespace CompanyName.ApplicationName.Models.Business
{
  public class User
  {
    public User(Guid id, string name, int age)
    {
      Id = id;
      Name = name;
      Age = age;
    }

    public Guid Id { get; set; }

    public string Name { get; set; }

    public int Age { get; set; }
  }
}

using System;
using CompanyName.ApplicationName.Models.Business;

namespace CompanyName.ApplicationName.ViewModels.Business
{
  public class UserViewModel : BaseBusinessViewModel
  {
    private User model;
    private bool isSelected = false;

    public UserViewModel(User model)
    {
      Model = model;
    }

    public User Model
    {
      get { return model; }
      set { model = value; NotifyPropertyChanged(); }
    }

    public Guid Id
    {
      get { return Model.Id; }
      set { Model.Id = value; NotifyPropertyChanged(); }
    }

    public string Name
    {
      get { return Model.Name; }
      set { Model.Name = value; NotifyPropertyChanged(); }
    }

    public int Age
    {
      get { return Model.Age; }
      set { Model.Age = value; NotifyPropertyChanged(); }
    }

    public bool IsSelected
    {
      get { return isSelected; }
      set { isSelected = value; NotifyPropertyChanged(); }
    }
  }  
} </pre>
<p>When implementing this pattern, after each data object was loaded from the data source, it would need to be wrapped in one of these View Model classes before being displayed in the UI:</p>
<pre>User user = new User(Guid.NewGuid(), "James Smith", 25);
UserViewModel userViewModel = new UserViewModel(user); </pre>
<p>Following the pattern in the first example structure through to the <kbd>Views</kbd> project, we see that it also contains a <kbd>Business</kbd> folder. Typically, we could find a small, individual object-sized View there for each of these business model-related View Models. However, in the vast majority of applications, this additional level of separation between the business model and the UI is simply unrequired. Also, following this pattern adds a small overhead to all implementation and data access times.</p>
<p>For some, a viable alternative would be to simply add the properties and property change notification required by the UI straight into the data model classes. If we don't need this separation, then there is little point in writing all of the extra code.</p>
<p>I am a great fan of Agile practices and one of the twelve principles from the <em>Manifesto for Agile Software Development</em> summarizes this point perfectly:</p>
<p>"Simplicity--the art of maximizing the amount of work not done--is essential"</p>
<p>This simpler, alternative implementation is shown in the <kbd>DataModels</kbd> project of the second example, where the business model classes are combined with the UI-related properties, along with the business rules or validation logic.</p>
<p>In other types of applications, you may find a separate validation layer that sits between the DAL and the code behind the UI layer. But as we'll see in <a href="549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml">Chapter 9</a>, <em>Implementing Responsive Data Validation</em>, with WPF, we can build validation right into the business classes, along with the properties that they are validating.</p>
<p>This <kbd>DataModels</kbd> project contains a number of sub-folders, grouping similar types of classes together. The <kbd>Collections</kbd> folder typically contains an extension of the <kbd>ObservableCollection&lt;T&gt;</kbd> class for each data model class in the application. The <kbd>Enums</kbd> folder is also often well used in most WPF applications, as enumerations are great to use when data bound to either radio buttons or checkboxes.</p>
<p>The interfaces found in the <kbd>Interfaces</kbd> folder are essential to enable the functionality of the base classes, as we'll see in <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml">Chapter 3</a>, <em>Writing Custom Application Frameworks</em>. If we're likely to use a large number of delegates in our application, then it also makes sense to organize them into a separate <kbd>Delegates</kbd> folder as well. Otherwise, if a delegate is strongly tied to a particular class, they can just be declared locally in the classes that will be raising them.</p>
<p>One other alternative would be to have a single class in the <kbd>Models</kbd> project that encapsulates all of the application delegates, although this would require prefixing the name of this class to the delegate names when using them, for example, <kbd>Delegates.CloseRequest</kbd>. Declaring each delegate in the class that uses them enables us to reference them directly, for example, <kbd>CloseRequest</kbd>.</p>
<p>The data model classes in this project could be thought of as View Models too, although View Models that only serve the display of individual objects, as opposed to those that serve the main application Views. They would have a base class that implements the <kbd>INotifyPropertyChanged</kbd> interface like the main View Models, but then it would also typically implement a validation error interface too.</p>
<p>They also differ from the main application View Models because they generally provide no functionality other than validation to their associated Views. We can think of these classes as mere data containers with a few extra properties to enable effective communication with the UI.</p>
<p>When following this structure, we can render these individual object-sized View Models in the UI using data templates, so we generally don't need to declare a separate View for each of them. Furthermore, we may want to display the same objects differently in different parts of the application, or even switch their display in response to some user action and that is also easier to accomplish with data templates.</p>
<p>This explains why these objects do not reside in the View Models project along with the main application View Models. If you remember, each View Model should only have one associated View. For the purpose of this book, this simpler, alternative implementation is the pattern that we will be following. Now, let's continue by investigating the DAL of the application.</p>
<p>The <kbd>DataProviders</kbd> project from the first example is responsible for providing access to the persisted data source of the application. Another commonly used name is <kbd>Repositories</kbd>, but again, you can call it what you like. The important thing is that it has an essential <kbd>Interfaces</kbd> folder that contains one or more interfaces that form the connection between the data source(s) and the rest of the application.</p>
<p>The <kbd>DataProviders</kbd> and <kbd>Interfaces</kbd> folders in the second example appear within the <kbd>Models</kbd> project, but they have the same responsibilities. Either way, it is through the use of these interfaces that we are able to disconnect the data source and replace it with a mock source of some kind when testing. We will look at an example of this in <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml">Chapter 3</a>, <em>Writing Custom Application Frameworks</em>, but for now, let's continue.</p>
<p>The <kbd>ViewModels</kbd> project is fairly easy to understand, as it just contains View Models. You may be wondering why there is a <kbd>Commands</kbd> folder inside it. If we were using commands in the old fashioned way, writing a separate class for each command, then we could end up with a great many classes and that would probably warrant putting them into their own project.</p>
<p>However, if you remember, we will be using only one single command, the <kbd>ActionCommand</kbd>. As this will be used by the View Model classes alone, it makes sense to include it in their project. We've already covered the differences in the View Models and Views projects between the two example structures, so let's finish off looking at the remaining common parts.</p>
<p>We often find an <kbd>Attached</kbd> folder in the <kbd>Views</kbd> project that contains the Attached Properties that are used in the application. As these classes contain View-related code and are only used by the Views, it is logical that they should reside here. Alongside that, we see the <kbd>Controls</kbd> folder where we find reusable user controls and/or custom controls, such as a custom textbox that spawns a child window to help with editing when clicked or a custom clock face that can be used to enter a time.</p>
<p>At the bottom of both example structures, we see the test projects that contain the code that tests our application. If your application needs testing, this is a good pattern to follow. By prefixing the name of the projects that we will be testing with a <kbd>Test</kbd> domain, they will all appear in the Visual Studio Solution Explorer in one group, either above or below the other projects, and in the same order as the projects being tested.</p>
<p>The <kbd>Mocks</kbd> project typically hosts the application objects to be used while testing the application. This would normally include any mock data generation or provider classes and mock <kbd>Manager</kbd> classes. We may need to create these mock <kbd>Manager</kbd> classes if we don't want to use expensive resources while testing, or in case they access any UI elements that we also want to avoid when testing. Let's take a look at an example of one possible method of a <kbd>UiThreadManager</kbd> class:</p>
<pre>public Task RunAsynchronously(Action method) 
{ 
  return Task.Run(method); 
} </pre>
<p>This method is fairly straightforward and enables us to pass a reference to any method that we want to run asynchronously. It simply passes the method reference to the <kbd>Task.Run</kbd> method and lets it do its thing. It can be called like this:</p>
<pre>UiThreadManager.RunAsynchronously(() =&gt; GenerateReports()); </pre>
<p>However, running code asynchronously in unit tests can have unpredictable results that may make them fail. Therefore, when testing, we need to use a <kbd>MockUiThreadManager</kbd> class and implement its <kbd>RunAsynchronously</kbd> method, as follows:</p>
<pre>public Task RunAsynchronously(Action method) 
{ 
  Task task = new Task(method); 
  task.RunSynchronously(); 
  return task; 
} </pre>
<p>In this method, we can see that we use the <kbd>RunSynchronously</kbd> method of the <kbd>Task</kbd> class to run the referenced method synchronously, or in other words, immediately and on the same thread. In effect, this simply bypasses the functionality of the original method. Using these mock objects enable us to run different code while testing than we do at runtime. We'll see more examples of these mock objects in <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml">Chapter 3</a>, <em>Writing Custom Application Frameworks</em>, but let's first take a look back at what we have covered so far.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have discovered what the MVVM architectural pattern is and the benefits of using it when developing WPF applications. We're now in a better position to decide which applications to use it with and which not to. We started looking into the various new ways of communicating between the various components of this pattern and also investigated the most common ways of organizing our source code. We are now ready to start setting out our own application structures.</p>
<p>In the next chapter, before we properly get started building our application, we'll look at several methods of the sometimes tricky task of debugging our data bound values. We'll discover other useful tips and tricks that we can use to help us to iron out any problems that may occur in our applications so that once we start building, we'll be able to avoid wasting time with problems that may arise.</p>


            

            
        
    </body></html>