- en: Chapter 6. Networking and Multiplayer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 网络和多玩家
- en: In previous chapters you learned how to use Unity's interface, manipulate objects,
    and add components and behaviors to them. You created gameplay using Playmaker
    actions and Unity scripting. We also looked at making custom actions from C# scripts.
    You made a fully playable air hockey game with an AI opponent using all these
    tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用Unity的界面，操作对象，以及向它们添加组件和行为。你使用Playmaker动作和Unity脚本创建了游戏玩法。我们还探讨了从C#脚本中创建自定义动作。你使用所有这些工具制作了一个完全可玩的双打冰球游戏，并使用人工智能对手。
- en: In this chapter, we are going to talk about networking. You will make a multiplayer
    mode for the game using **Photon Unity Networking** (**PUN**), which is a helpful
    plugin that comes with Playmaker and lets you make multiplayer games almost effortlessly.
    We will also talk about the theory of networking in games and discuss Unity native
    networking as an alternative to Photon.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论网络。你将使用**Photon Unity Networking**（**PUN**）为游戏创建多玩家模式，这是一个有用的插件，与Playmaker一起提供，让你几乎可以毫不费力地制作多玩家游戏。我们还将讨论游戏网络理论，并讨论Unity原生网络作为Photon的替代方案。
- en: 'In this chapter, you will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将涵盖：
- en: Understanding networking and multiplayer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网络和多玩家
- en: Setting up Photon Unity Networking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Photon Unity Networking
- en: Making a multiplayer game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作多玩家游戏
- en: Understanding networking and multiplayer
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网络和多玩家
- en: Explaining things like TCP/IP and other low-level networking concepts is beyond
    the scope of this book, and we are going to try and keep everything as close to
    practical application as possible. On the other hand, it will be much easier for
    you to build multiplayer if you are familiar with at least some theory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 解释像TCP/IP和其他低级网络概念超出了本书的范围，我们将尽量使一切尽可能接近实际应用。另一方面，如果你至少熟悉一些理论，那么构建多玩家游戏会容易得多。
- en: The first thing that you need to know is what servers and clients are. In simple
    terms, a server is a computer that responds to network requests from other computers,
    or more precisely, a system that responds to network requests from other systems,
    because you may have multiple servers and multiple clients on the same computer.
    This means that clients communicate with each other through a server. Typically,
    player systems are clients in multiplayer games, while servers are on computers
    that are accessed remotely. Sometimes, a player can *host* a game, in which case
    the player either acts as a server or simply tells the server to reserve its resources
    for the game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的第一件事是服务器和客户端是什么。简单来说，服务器是一台响应来自其他计算机网络请求的计算机，或者更精确地说，是一个响应来自其他系统网络请求的系统，因为你在同一台计算机上可能有多个服务器和多个客户端。这意味着客户端通过服务器相互通信。通常，玩家系统是多玩家游戏中的客户端，而服务器位于远程访问的计算机上。有时，玩家可以*托管*游戏，在这种情况下，玩家要么充当服务器，要么简单地告诉服务器为游戏保留其资源。
- en: You may have heard about network architectures before. In games, the most popular
    architectures are arguably client-server and peer-to-peer. The former means that
    all the clients subscribe to a single server. The server hosts most of the important
    information about the game and distributes it between the players. The latter
    is about peers (players) connecting to one another directly, so all the clients
    are connected to each other, and the network workload is distributed evenly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过网络架构。在游戏中，最流行的架构可能是客户端-服务器和对等网络。前者意味着所有客户端都订阅一个单一的服务器。服务器托管关于游戏的大部分重要信息，并在玩家之间分配。后者是关于对等方（玩家）直接连接到彼此，因此所有客户端都相互连接，网络负载均匀分布。
- en: The advantage of client-server is that it allows creating a more stable system
    that ensures that cheating is either impossible or very hard, as well as makes
    it easier for the developer to monitor everything and make changes to the game
    on the fly. This method, however, is generally expensive and relatively hard to
    implement yourself if you are just a solo developer who is learning to make his/her
    first multiplayer game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器的好处是它允许创建一个更稳定的系统，确保作弊要么不可能，要么非常困难，同时也使得开发者更容易监控一切，并在游戏中即时做出更改。然而，这种方法通常成本较高，如果你是一个正在学习制作第一个多玩家游戏的独立开发者，那么自己实现起来相对较难。
- en: Peer-to-peer does not require having a powerful server hosting multiple game
    sessions at the same time, allowing players to connect to each other, distributing
    the network workload between them. The drawback of peer-to-peer is that it tends
    to be less stable, and it is relatively hard to monitor. On top of that, you still
    need a server if you want to keep track of game sessions, perform matchmaking,
    and let your players play on the Internet instead of just a local network.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点不需要拥有一个强大的服务器同时托管多个游戏会话，允许玩家相互连接，在他们之间分配网络负载。点对点的缺点是它通常不太稳定，而且相对难以监控。此外，如果你想跟踪游戏会话、执行匹配和让玩家在互联网上而不是仅在本地网络中玩游戏，你仍然需要一个服务器。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is hard to connect to the Internet without having a server, because of something
    called **Native Address Translation** (**NAT**). Without getting into much detail,
    it should be noted that it is something that network routers do, and most of us
    have routers these days. A process commonly called **NAT punchthrough** is used
    in order to connect one computer to another, and this process requires a server
    acting as a mediator for the first connection between two computers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有服务器很难连接到互联网，这是因为有一种叫做**原生地址转换**（**NAT**）的东西。不深入细节的话，应该注意的是，这是网络路由器做的事情，我们大多数人现在都有路由器。一个常用的过程叫做**NAT穿透**，用于连接一台计算机到另一台计算机，这个过程需要一个服务器作为两台计算机之间第一次连接的中介。
- en: In Unity, it is relatively easy to set up a **Local Area Network** (**LAN**),
    peer-to-peer connection, or client-server connection with one of the players hosting
    the game without using any external plugins. A LAN connection means that all the
    players are connected to the same local computer network. Unfortunately, whatever
    you do, you will need a server to make sure that players can always connect to
    each other over the Internet, which is what we want to do. Photon takes client-server
    and wraps it in an extremely easy to use interface that allows anyone to create
    multiplayer games without any prior experience. On top of that, it is very affordable
    for what it is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，设置**本地局域网**（**LAN**）、对等连接或客户端-服务器连接相对简单，无需使用任何外部插件，只需让一位玩家作为游戏主机即可。LAN连接意味着所有玩家都连接到同一个本地计算机网络。不幸的是，无论你做什么，你都需要一个服务器来确保玩家可以始终通过互联网相互连接，这正是我们想要做的。Photon采用了客户端-服务器架构，并将其封装在一个极其易于使用的界面中，使得任何人都可以在没有先前经验的情况下创建多人游戏。而且，它的价格也非常实惠。
- en: Some of the Photon services allow players to host their own servers, but those
    take some time to set up. What we are going to use in this book is Photon Cloud.
    As the name implies, all the game sessions happen in the cloud, thus on remote
    Photon servers. All you need to do is synchronize your game's data through them
    and make sure that players can find each other. You do not need to set up a server,
    and you do not have to worry about the problems involved in making peer-to-peer
    multiplayer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Photon服务允许玩家自己托管服务器，但这需要一些时间来设置。在这本书中，我们将使用Photon Cloud。正如其名所示，所有的游戏会话都在云端进行，即在远程Photon服务器上。你所需做的就是通过它们同步你的游戏数据，并确保玩家可以找到彼此。你不需要设置服务器，也不必担心涉及点对点多人游戏的问题。
- en: The way the synchronization works is that there is something called **Network
    View** (**Photon View** in Photon), which is a component that makes one or more
    game object's properties synchronized over the network. When such a property changes
    in one client, it changes in all the clients, with the server keeping track of
    everything and sending commands to clients. For example, mallet's position can
    be such a property. This way, when player 1 moves their mallet, player 2 sees
    them move it and vice versa. The same goes for almost any other property.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同步工作的方式是这样的，有一个叫做**网络视图**（在Photon中称为**Photon视图**）的东西，这是一个组件，它使得一个或多个游戏对象的属性在网络中同步。当某个属性在一个客户端发生变化时，它会在所有客户端中发生变化，服务器会跟踪所有变化并向客户端发送命令。例如，球槌的位置可以是一个这样的属性。这样，当玩家1移动他们的球槌时，玩家2会看到他们移动它，反之亦然。几乎任何其他属性都是如此。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As we will show in this chapter's example, synchronizing positions can be okay
    for player objects (such as mallets in air hockey or characters in first person
    shooters), but objects that have physical behaviors (such as the puck), can experience
    serious network delays on remote computers. There is currently no easy solution
    for this problem apart from using Unity native networking.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的示例中将要展示的，同步位置对于玩家对象（如冰球桌中的球槌或第一人称射击游戏中的角色）是可以接受的，但对于具有物理行为的对象（如冰球），在远程计算机上可能会出现严重的网络延迟。目前，除了使用Unity原生网络之外，还没有简单的解决方案来解决这个问题。
- en: There are objects that can belong to the scene (like the walls and the background)
    and so are exactly the same and unchangeable throughout all clients, and then
    there are objects that belong to different clients, such as the mallets. Generally,
    you want to synchronize as little data over the network as possible in order to
    avoid high response times. Scene objects do not have to get synchronized since
    they do not change. Moreover, this way each player's mallet responds only to that
    player's input, which makes perfect sense gameplay-wise.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些对象可以属于场景（如墙壁和背景），因此在整个客户端中都是完全相同且不可更改的，然后还有属于不同客户端的对象，例如球槌。通常，您希望尽可能少地在网络上同步数据，以避免高响应时间。场景对象不需要同步，因为它们不会改变。此外，这样每个玩家的球槌只响应那个玩家的输入，这在游戏玩法上是非常合理的。
- en: You are now ready to start setting up Photon. All this theory may sound complicated,
    but it really comes down to synchronizing variables over the network using a special
    Photon component called Photon View.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好开始设置Photon了。所有这些理论可能听起来很复杂，但实际上它归结为使用一个名为Photon View的特殊Photon组件在网络中同步变量。
- en: Setting up Photon Unity Networking
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Photon Unity Networking
- en: Photon Unity Networking is a free Unity plugin with an optional paid subscription
    that allows you to outsource most of the heavy lifting for building multiplayer
    games. The free version has full functionality but is limited by the number of
    players that can be online at the same time. This is not a problem, because all
    you need for testing is to be able to connect as many players as your game requires
    for being playable (so two for air hockey).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Photon Unity Networking是一个免费的Unity插件，可选的付费订阅允许您将构建多人游戏的大部分繁重工作外包出去。免费版本具有完整的功能，但受同时在线玩家数量的限制。这不是问题，因为您只需要能够连接到足够多的玩家，以便您的游戏可以玩（例如，冰球桌游戏需要两个玩家）。
- en: First of all, we will need to set up PUN. In the main menu, navigate to **PlayMaker**
    | **Addons** | **Photon Networking** | **Set up Photon Networking**. This should
    open the **Photon Setup Wizard** window. Click on the orange **Setup** button.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要设置PUN。在主菜单中，导航到**PlayMaker** | **插件** | **Photon Networking** | **设置Photon
    Networking**。这应该会打开**Photon设置向导**窗口。点击橙色**设置**按钮。
- en: If this is the first time you are using Photon, you are going to need an account,
    so enter your e-mail in the appropriate field and click on the **Send** button.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用Photon，您将需要一个账户，因此请在相应的字段中输入您的电子邮件，然后点击**发送**按钮。
- en: After that you can finish the registration process by clicking on the link that
    you will have received by e-mail. Sign in to your account on [http://cloud.exitgames.com/](http://cloud.exitgames.com/),
    click on the **New App** button on your account page, enter the game's name and
    description, and then click on **Create**. You should be redirected back to your
    account page. In the **Details** section, copy the code under **AppID** and go
    back to Unity.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以通过点击通过电子邮件收到的链接来完成注册过程。登录到您的[http://cloud.exitgames.com/](http://cloud.exitgames.com/)账户，点击账户页面上的**新建应用**按钮，输入游戏名称和描述，然后点击**创建**。您应该会被重定向回您的账户页面。在**详情**部分，复制**AppID**下的代码，然后返回Unity。
- en: In the **Photon Setup Wizard**, click on the **Setup** button, paste your AppID
    into the **Your AppId** text field, and choose your region by pressing one of
    the **Cloud Region** buttons. Make sure you choose the region that is closer to
    you geographically as this will affect the connection speed of your game's multiplayer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Photon设置向导**中，点击**设置**按钮，将您的AppID粘贴到**您的AppId**文本字段中，并通过按下一个**云区域**按钮选择您的区域。请确保您选择地理位置上离您更近的区域，因为这会影响您游戏多人连接的速度。
- en: Once you have pasted the AppID and chosen the region, click on the **Save**
    button below. A window should pop up saying that your settings have been saved.
    Click on **OK**. The following screenshot shows what the setup window is supposed
    to look like once you do:![Setting up Photon Unity Networking](img/8108OT_06_01.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您粘贴了 AppID 并选择了区域，点击下面的**保存**按钮。应该会弹出一个窗口，表示您的设置已保存。点击**确定**。以下截图显示了您完成设置后设置窗口应有的样子：![设置
    Photon Unity Networking](img/8108OT_06_01.jpg)
- en: Make sure that the green label saying **Photon server is set up properly** appears
    near the top of the window. Press the **Main Menu** button right below it. It
    should take you back to the first screen of **Photon Setup Wizard**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保绿色标签**Photon 服务器已正确设置**出现在窗口的顶部附近。按下其下方的**主菜单**按钮。它应该带您回到**Photon 设置向导**的第一个屏幕。
- en: Make a copy of your main game scene and call it `Multiplayer`, load it by double-clicking
    it in the **Project** panel, and then go back to **Photon Setup Wizard** window
    and click on **Add Photon System to the scene**. The button should disappear,
    and you should see the second green label saying **The scene is set up properly**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制您的游戏主场景并命名为 `Multiplayer`，通过在**项目**面板中双击它来加载它，然后返回到**Photon 设置向导**窗口并点击**将
    Photon 系统添加到场景**。按钮应该消失，您应该看到第二个绿色标签，上面写着**场景已正确设置**。
- en: At this point Photon Cloud is set up, and you can feel free to close the wizard
    window. Save the **Multiplayer** scene, making sure that the **PlayMaker Photon
    Proxy** game object was added to **Hierarchy**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到此为止，Photon Cloud 已设置完成，您可以自由地关闭向导窗口。保存**多人游戏**场景，确保**PlayMaker Photon 代理**游戏对象已被添加到**层次结构**中。
- en: You can modify the settings any time you want. You can also change your AppID
    if you choose to do so.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时修改设置。如果您选择这样做，您还可以更改您的 AppID。
- en: Now that we have added Photon to the project and made a scene dedicated to multiplayer,
    it is time to synchronize objects over the network and set up matchmaking.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 Photon 添加到项目中并创建了一个专门用于多人游戏的场景，是时候在网络中同步对象并设置匹配了。
- en: Making multiplayer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作多人游戏
- en: There are a few game objects that have to be synchronized in our game, including
    the goals, the puck, and the mallets. We also need to make a few adjustments to
    the scene and set up matchmaking.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，有一些游戏对象需要同步，包括目标、冰球和球槌。我们还需要对场景进行一些调整并设置匹配。
- en: We are going to use the Photon Playmaker example as a template for our game,
    using the scenes from there and modifying them to suit our purposes. This is generally
    a good idea if you want to set up multiplayer quickly, because these examples
    feature numerous and complex FSMs that would take quite a lot of time to set up,
    while most of the things you will need have already been implemented.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Photon Playmaker 示例作为我们游戏的模板，使用那里的场景并对其进行修改以适应我们的目的。如果您想快速设置多人游戏，这通常是一个好主意，因为这些示例具有众多且复杂的有限状态机（FSM），设置起来会花费相当多的时间，而您需要的许多东西已经实现。
- en: 'You can download the demo scenes here: [http://www.hutonggames.com/samples.php](http://www.hutonggames.com/samples.php).
    Simply click on the link **Download PlayMaker Photon Demo** (requires Unity 3.5+
    Playmaker 1.6.1+). Then you will need to find the downloaded `unitypackage` file
    on your computer and double-click on it. This will prompt the import window. Click
    on the **Import** button in the bottom-right corner of it.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处下载演示场景：[http://www.hutonggames.com/samples.php](http://www.hutonggames.com/samples.php)。只需点击链接**下载
    PlayMaker Photon 演示版**（需要 Unity 3.5+ Playmaker 1.6.1+）。然后您需要在您的计算机上找到下载的 `unitypackage`
    文件并双击它。这将弹出导入窗口。点击窗口右下角的**导入**按钮。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The warning on the example download page advises against importing the example
    into existing projects. We can ignore this warning, because none of our files
    are named in the same way the ones in the example are. As a general rule, you
    should always make sure that this is the case before importing new packages into
    new empty projects. Otherwise you might find yourself losing important assets
    in your projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例下载页面上的警告建议不要将示例导入到现有项目中。我们可以忽略这个警告，因为我们没有任何文件与示例中的文件同名。作为一般规则，在将新包导入新空项目之前，您应该始终确保这一点。否则，您可能会发现自己丢失了项目中的重要资产。
- en: Save the **Multiplayer** scene, and let us add the demo scenes to our project.
    They should be under `Photon Unity Networking/PlayMaker/Demo/Separated Scenes
    Demo`. Open the **demo_lobby** scene by double-clicking on its file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 保存**多人游戏**场景，然后让我们将演示场景添加到我们的项目中。它们应该在`Photon Unity Networking/PlayMaker/Demo/Separated
    Scenes Demo`下。通过双击其文件打开**demo_lobby**场景。
- en: The first thing we need to do is add the new scenes to our project. Open **Build
    Settings** by pressing *Shift* + *command* + *B* (*Shift* + *Ctrl* + *B* in Windows),
    then click on the **Add Current** button shown in the following screenshot. This
    will add the currently open scene to the project. Do this for **demo_lobby** and
    **demo_room**. Then close **Build Settings**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将新场景添加到我们的项目中。通过按*Shift* + *command* + *B*（在Windows上为*Shift* + *Ctrl*
    + *B*）打开**构建设置**，然后点击以下截图所示的**添加当前**按钮。这将把当前打开的场景添加到项目中。为**demo_lobby**和**demo_room**都这样做。然后关闭**构建设置**。
- en: '![Making multiplayer](img/8108OT_06_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![制作多人游戏](img/8108OT_06_02.jpg)'
- en: 'These two scenes are going to be responsible for two states of the game: the
    matchmaking state where players can find and create servers and the match state
    where the game itself takes place. You can test how it works by opening two instances
    of your game at once: one in the Unity Editor, one in your web browser.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个场景将负责游戏的两种状态：玩家可以找到和创建服务器的匹配状态，以及游戏本身进行的匹配状态。你可以通过同时打开两个游戏实例来测试其工作方式：一个在Unity编辑器中，一个在你的网络浏览器中。
- en: To make a browser build, select **File** | **Build & Run** from the main menu
    and save the build files wherever you want on your computer when the file browser
    appears. You might want to create a special `Build` folder to make sure that you
    can always find your build. This should automatically open the game in your browser.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建浏览器构建，从主菜单中选择**文件** | **构建与运行**，并在文件浏览器出现时将构建文件保存在你电脑上的任何位置。你可能想要创建一个特殊的**构建**文件夹，以确保你总能找到你的构建。这应该会自动在浏览器中打开游戏。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please note that your platform has to be set to Web Player as described in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Unity and Playmaker"), *Getting
    Started with Unity and Playmaker*. If it is not, open **Build Settings**, select
    **Web Player** from the list on the left, and click on the **Switch Platform**
    button. Then close the **Build Settings** window.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，你的平台必须设置为Web Player，如[第1章](ch01.html "第1章。Unity和Playmaker入门")中所述，*Unity和Playmaker入门*。如果不是，打开**构建设置**，从左侧列表中选择**Web
    Player**，然后点击**切换平台**按钮。然后关闭**构建设置**窗口。
- en: Specify your nickname, and the name of the room next to **CREATE ROOM**, then
    click on **GO** on the right from the room name text field.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建房间**旁边指定你的昵称和房间名称，然后点击房间名称文本字段右侧的**GO**按钮。
- en: A new scene should load, where you control a construction worker that can walk
    around on a plane.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该会加载一个新的场景，在那里你可以控制一个可以在平面上四处走动的建筑工人。
- en: Keeping the game open in your web browser, go back to the Unity Editor; make
    sure that **demo_scene** is open and click on play.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中保持游戏打开，回到Unity编辑器；确保**demo_scene**已打开，然后点击播放。
- en: Click on the **GO** button next to **EXISTING ROOMS**. This will join a random
    exiting room. Since we only created one room, both of the game instances will
    now be connected to the same game session. This way you can test how networking
    works by looking at your scene from the points of view of two players.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**现有房间**旁边的**GO**按钮。这将加入一个随机存在的房间。由于我们只创建了一个房间，现在两个游戏实例都将连接到同一个游戏会话。这样，你可以通过查看两个玩家的视角来测试网络功能。
- en: Now that you have seen how multiplayer works in the example project, it is time
    to modify its scenes to work with our game. We are going to keep the matchmaking
    intact (in fact, it can be kept this way for almost any multiplayer game). The
    only thing that needs changing is the maximum number of players that can join
    a single room. You may have noticed that the example project allows for 100 players.
    We need to change it to `2`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了示例项目中多人游戏的工作方式，是时候修改其场景以配合我们的游戏了。我们将保持匹配功能不变（实际上，几乎可以以这种方式保持任何多人游戏）。唯一需要更改的是可以加入单个房间的最大玩家数量。你可能已经注意到示例项目允许100名玩家。我们需要将其更改为`2`。
- en: In the **demo_lobby** scene, select the **Menu** game object.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**demo_lobby**场景中，选择**菜单**游戏对象。
- en: Open the **Create Room** FSM from the second drop-down list from the left in
    the menu on top of the **playMaker** FSM view.![Making multiplayer](img/8108OT_06_03.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**playMaker** FSM视图顶部的菜单中，从左侧第二个下拉列表打开**创建房间**FSM。![制作多人游戏](img/8108OT_06_03.jpg)
- en: In the Photon Network **Create Room** action of the create room state, set the
    **Max Number Of Players** property to `2`. Now up to two players will be able
    to join one room.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建房间状态的**Photon Network Create Room**动作中，将**最大玩家数**属性设置为`2`。现在最多有两个玩家可以加入一个房间。
- en: Save the scene.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: Now that the lobby is all set, it is time to set up the game itself to work
    via the network.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在休息室已经设置好了，是时候设置游戏本身通过网络工作了。
- en: Make a copy of the **demo_room** scene as backup to be able to go back to if
    something goes wrong. Open the original **demo_room** scene. You should have an
    unnamed game object with four children as well as **Chat**, **Game**, and the
    **PlayMaker Photon Proxy** game objects.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**demo_room**场景复制一份作为备份，以便在出现问题时可以返回。打开原始的**demo_room**场景。你应该有一个未命名的游戏对象，它有四个子对象，以及**Chat**、**Game**和**PlayMaker
    Photon Proxy**游戏对象。
- en: You can delete everything except the **Game** game object. This is where most
    of the initial multiplayer logic (such as instantiating players) takes place.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除除**Game**游戏对象之外的所有内容。这里是大多数初始多人逻辑（例如实例化玩家）发生的地方。
- en: Save the scene and go back to the **Multiplayer** scene.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并返回到**Multiplayer**场景。
- en: Select all the objects in this scene's **Hierarchy** by either pressing *command*
    + *A* (*Ctrl* + *A* in Windows) or clicking on the first item in the list and
    then *Shift*-clicking on the last one.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*command* + *A* (*Ctrl* + *A*在Windows中)或点击列表中的第一个项目然后*Shift*-点击最后一个项目来选择场景中**Hierarchy**中的所有对象。
- en: Copy the selected objects by pressing *command* + *C* (*Ctrl* + *C* in Windows),
    then open the **demo_room** scene again and press *command* + *V* (*Ctrl* + *V*
    in Windows) to paste them.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*command* + *C* (*Ctrl* + *C*在Windows中)复制选定的对象，然后再次打开**demo_room**场景并按*command*
    + *V* (*Ctrl* + *V*在Windows中)粘贴它们。
- en: Create empty prefabs called `Goal`, `Mallet`, and `Puck` under **Prefabs**/**Resources**.
    Create the folders if you don't have them yet.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Prefab**/**Resources**下创建名为`Goal`、`Mallet`和`Puck`的空预制件。如果你还没有创建这些文件夹，请先创建它们。
- en: Drag the **GoalLeft** game object into the `Goal` prefab, **MalletLeft** game
    object into the `Mallet` prefab, and **Puck** game object into the `Puck` prefab.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**GoalLeft**游戏对象拖入`Goal`预制件，将**MalletLeft**游戏对象拖入`Mallet`预制件，将**Puck**游戏对象拖入`Puck`预制件。
- en: 'Delete the following objects from the scene: **MalletLeft**, **MalletRight**,
    and **Puck**. They are going to be instantiated from prefabs that you just created
    when players join the room.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除以下对象：**MalletLeft**、**MalletRight**和**Puck**。当玩家加入房间时，它们将从你刚刚创建的预制件中实例化。
- en: Make **GoalLeft** and **GoalRight** invisible by deactivating their **Mesh Renderer**
    components. These objects will be instantiated from prefabs as well, but not right
    away, so we need to keep them in the scene for their colliders to make sure that
    no mallets can get out of the table. You can also rename both of them `Blocker`,
    since they are needed to block the mallets.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过禁用它们的**Mesh Renderer**组件使**GoalLeft**和**GoalRight**不可见。这些对象也将从预制件中实例化，但不是立即实例化，因此我们需要将它们保留在场景中以确保没有球槌可以离开桌子。你也可以将它们都重命名为`Blocker`，因为它们需要用来阻挡球槌。
- en: Select the **Game** game object and open its **Game Manager** FSM in the **playMaker**
    panel.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Game**游戏对象，并在**playMaker**面板中打开其**Game Manager**FSM。
- en: 'In the **Variables** tab, make sure you have three **GameObject** variables:
    **goalRef**, **player prefab**, and **puck prefab**, as well as an **Int** variable
    **player count**. Drag the `Mallet` prefab into the **GameObject** slot of **player
    prefab** and the `Puck` into the the **GameObject** slot of **puck prefab**.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**变量**选项卡中，确保你有三个**GameObject**变量：**goalRef**、**player prefab**和**puck prefab**，以及一个**Int**变量**player
    count**。将`Mallet`预制件拖入**player prefab**的**GameObject**槽中，将`Puck`拖入**puck prefab**的**GameObject**槽中。
- en: In the **Events** tab, create a new event called `Two Players`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**事件**选项卡中，创建一个名为`Two Players`的新事件。
- en: In the **Photon Network Instantiate** action of the **instantiate player** state,
    make sure that **Rotation** is set to (`0`, `0`, `0`).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**instantiate player**状态的**Photon Network Instantiate**动作中，确保**旋转**设置为(`0`,
    `0`, `0`)。
- en: Add another **Photon Network Instantiate** action to the same state. Set its
    **Game Object** property to **Goal** by dragging the `Goal` prefab from the **Project**
    panel. Set the **Position** property to `(-7.98`, `2`, `0`) and the **Rotation**
    property to (`0`, `90`, `0`). Set **Store Object** to **goalRef**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的状态下添加另一个**Photon Network Instantiate**动作。通过从**项目**面板拖动`Goal`预制件将其**游戏对象**属性设置为**Goal**。将**位置**属性设置为`(-7.98`,
    `2`, `0`)，将**旋转**属性设置为(`0`, `90`, `0`)。将**存储对象**设置为**goalRef**。
- en: Make a new state called `How many players?` and add **Photon Network Get Room
    Properties** and the **Int Compare** actions to it. Make sure the former is before
    the latter in the list. If an error saying that PlayMakerPhotonGameObjectProxy
    component is required appears, click on it, and the component in question will
    be added automatically.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`How many players?`的新状态，并向它添加**Photon Network Get Room Properties**和**整数比较**动作。确保前者在列表中位于后者之前。如果出现一个错误，说需要一个PlayMakerPhotonGameObjectProxy组件，点击它，相关的组件将被自动添加。
- en: Set the **Player Count** property of the **Photon Network Get Room Properties**
    action to the **player count** variable.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Photon Network Get Room Properties**动作的**玩家数量**属性设置为**玩家数量**变量。
- en: In the **Int Compare** action, set the **Integer 1** property to the **player
    count** variable and the **Integer 2** property to `2`. Set **Equal** to **Two
    Players**. Check the **Every Frame** box. If you see an error about an event,
    ignore it for now; it will be fixed later on.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**整数比较**动作中，将**整数1**属性设置为**玩家数量**变量，将**整数2**属性设置为`2`。将**等于**设置为**两位玩家**。检查**每帧**框。如果你看到一个关于事件的错误，现在忽略它；稍后会修复。
- en: Make a new state called `Create Puck`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Create Puck`的新状态。
- en: Add a **FINISHED** event to the **instantiate player** state. Drag a transition
    from it to **How many players?**
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**实例化玩家**状态中添加一个**完成**事件。从它拖动一个过渡到**有多少玩家**？
- en: Add a **Two Players** event to **How many players?** and drag a transition from
    it to **Create Puck**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**How many players?**添加一个**两位玩家**事件，并从它拖动一个过渡到**创建冰球**。
- en: 'In the **Create Puck** state, add two actions: **Photon Network Instantiate**
    and **Set Position**. Make sure that **Set Position** is the last in the list.
    If an error saying that a PlayMakerPhotonGameObjectProxy component is required
    appears, click on it, and the component in question will be added automatically.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建冰球**状态中，添加两个动作：**光子网络实例化**和**设置位置**。确保**设置位置**是列表中的最后一个。如果出现一个错误，说需要一个PlayMakerPhotonGameObjectProxy组件，点击它，相关的组件将被自动添加。
- en: Set the **Game Object** property of **Photon Network Instantiate** to the `Puck`
    prefab variable. Set **Position** to (`0`, `0.3`, `0`) and **Rotation** to (`0`,
    `0`, `0`).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Photon Network Instantiate**动作的**游戏对象**属性设置为`Puck`预制件变量。将**位置**设置为(`0`, `0.3`,
    `0`)和**旋转**设置为(`0`, `0`, `0`)。
- en: In the **Set Position** action, set **Game Object** to **Specify Game Object**
    and select the **goalRef** variable from the drop-down list. Make sure that **Vector**
    is **None**, **X** is `7.98`, and **Y** and **Z** are **None**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置位置**动作中，将**游戏对象**设置为**指定游戏对象**，并从下拉列表中选择**goalRef**变量。确保**向量**是**无**，**X**是`7.98`，而**Y**和**Z**是**无**。
- en: Save your scene.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景。
- en: 'This state machine is responsible for spawning objects that should be unique
    to different players: players'' mallets and goals are spawned as soon as the players
    connect to the room, while the puck is spawned once the second player connects
    to make sure that player 1 does not win while alone in the room.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态机负责生成应该对不同玩家独特的对象：当玩家连接到房间时，玩家的球槌和目标被生成，而冰球在第二个玩家连接时生成，以确保玩家1不会在房间里独自获胜。
- en: Now we are going to set the individual parameters and synchronization of each
    of the prefabs we created, starting with `Goal`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置我们创建的每个预制件的个别参数和同步，从`Goal`开始。
- en: 'Select the `Goal` prefab in the **Project** panel and add three components
    to it using the **Inspector** panel: **PlayMaker FSM** (**Script**), **Photon
    View**, and **Play Maker Photon Game Object Proxy**. You can find these components
    by clicking on the **Add Component** button in **Inspector** and typing their
    names in the search field.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中选择`Goal`预制件，并使用**检查器**面板添加三个组件：**PlayMaker FSM**（**脚本**）、**Photon
    View**和**Play Maker Photon Game Object Proxy**。你可以通过在**检查器**中点击**添加组件**按钮并输入它们的名称来找到这些组件。
- en: Drag the **Transform** component of `Goal` prefab into the **Photon View** component's
    **Observe** property.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Goal`预制件的**Transform**组件拖动到**Photon View**组件的**观察**属性中。
- en: Name the state machine `ColorSync` using the **FSM** tab of the **playMaker**
    panel.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**playMaker**面板的**FSM**选项卡将状态机命名为`ColorSync`。
- en: 'Rename the starting state to `is mine?` and add two events to it: **YES** and
    **NO**.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将起始状态重命名为`是我的吗？`并向它添加两个事件：**是**和**否**。
- en: 'Create two new states: **Green** and **Red**. Then make transitions from **YES**
    to **Green** and from **NO** to **Red**.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个新状态：**绿色**和**红色**。然后从**是**到**绿色**和从**否**到**红色**创建过渡。
- en: In the **is mine?** state, add a **Photon View Get Is Mine** action. Set **Is
    Mine Event** to **YES** and **Is Not Mine Event** to **NO**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**是我的吗？**状态下，添加一个**Photon View Get Is Mine**动作。将**是事件**设置为**YES**，将**不是事件**设置为**NO**。
- en: In the **Green** state, add a **Set Material** action. Set **Material** to the
    material you created for the green goal.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**绿色**状态下，添加一个**设置材质**动作。将**材质**设置为为绿色目标创建的材质。
- en: Do the same for the **Red** state, but choose the red material instead.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**红色**状态做同样的操作，但选择红色材质。
- en: This state machine makes sure that goals change color in the beginning of the
    game. Verify that you still have the **PlayMaker Photon Proxy** game object in
    the scene. If you don't copy it from the **Multiplayer** scene. At this point
    you may want to build and launch two instances of the game to test that everything
    works well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态机确保游戏开始时目标会改变颜色。请确认场景中仍然有**PlayMaker Photon Proxy**游戏对象。如果你没有从**多人游戏**场景中复制它。在这个时候，你可能想要构建并启动两个游戏实例来测试一切是否运行良好。
- en: Now let us change the color of the mallets to match the goals' colors. We will
    also make sure that only the owner of the Mallet can move it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将改变Mallet的颜色以匹配目标颜色。我们还将确保只有Mallet的所有者才能移动它。
- en: Find the `Fsm Photon player` prefab under `Photon Unity Networking/PlayMaker/Demo/Resources`
    in the **Project** panel and select it.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中找到`Photon Unity Networking/PlayMaker/Demo/Resources`下的`Fsm Photon
    player`预制件，并选择它。
- en: Copy **Play Maker Photon Game Object Proxy** and the **Photon View** components
    over to the `Mallet` prefab by right-clicking the components' headers of `Fsm
    Photon player` and selecting **Copy Component** from the drop-down menu and then
    right-clicking one of the components' headers in the `Mallet` prefab and selecting
    **Paste Component As New** from the drop-down menu.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击`Fsm Photon player`组件的标题并从下拉菜单中选择**复制组件**，然后将组件复制到`Mallet`预制件中。然后右键单击`Mallet`预制件中的一个组件标题，并从下拉菜单中选择**粘贴组件为新的**。
- en: 'Do the same for three of the `Fsm Photon player` prefab''s **Play Maker FSM**
    components: the ones called **GameObject naming**, **Position synch**, and **variable
    synch repository**.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Fsm Photon player`预制件的三个**Play Maker FSM**组件做同样的操作：名为**GameObject命名**、**位置同步**和**variable
    synch repository**的组件。
- en: Now the Mallet should have four FSMs. Rename the one called **FSM** to `Movement`
    to make sure we remember what it does.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Mallet应该有四个FSM。将名为**FSM**的一个重命名为`Movement`，以确保我们记得它做什么。
- en: Drag the **Play Maker FSM** called **variable synch repository** into the **Observe**
    slot of **Photon View**. Set the **Observe option** property to **Reliable Data
    Compressed**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为**Play Maker FSM**的**variable synch repository**拖放到**Photon View**的**观察**槽中。将**观察选项**属性设置为**可靠数据压缩**。
- en: In the **playMaker** panel, open the **Movement** FSM and add a `Bool` variable
    to it called **isMine**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**playMaker**面板中，打开**Movement** FSM，并向其中添加一个名为**isMine**的`Bool`变量。
- en: Set up the FSM as shown in the following screenshot, making sure that both the
    **Move** and **Push Puck** states stay unchanged. If you don't have the **Push
    Puck** state (you probably have it) confirm that the **Move** state has the **Push
    Puck** action attached to it. In order to set a state as a start state, right
    click on it and select **Set as Start State** from the contextual menu.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图设置FSM，确保**移动**和**推杆**状态保持不变。如果你没有**推杆**状态（你可能有）确认**移动**状态已附加**推杆**动作。为了设置一个状态为起始状态，右键单击它并从上下文菜单中选择**设置为起始状态**。
- en: Select the **Is mine?** state and add the **Photon View Get Is Mine** action
    to it. Set its parameters as shown in the following screenshot, then add a transition
    from the **Yes** event to the **Move** state:![Making multiplayer](img/8108OT_06_04.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**是我的吗？**状态，并向其中添加**Photon View Get Is Mine**动作。设置其参数如以下截图所示，然后从**是**事件添加到**移动**状态的转换：![制作多人游戏](img/8108OT_06_04.jpg)
- en: Switch to the **GameObject naming** FSM.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**GameObject命名** FSM。
- en: In the **add "me" to the gameObject name** state, add a **Set Material** action
    and set its **Material** property to the green material you created for one of
    the mallets. Don't worry if it is no longer green, just make sure that each player's
    **Goal** material matches his/her **Mallet** material.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**将"我"添加到游戏对象名称**状态下，添加一个**设置材质**动作，并将其**材质**属性设置为为其中一个Mallet创建的绿色材质。不用担心它不再是绿色的，只需确保每个玩家的**目标**材质与他的**Mallet**材质匹配。
- en: In the **add player to gameObject name** state, add a **SetMaterial** action
    as well. This time set the **Material** property to the material that matches
    the red goal's material.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加玩家到游戏对象名称**状态中，同时添加一个**设置材质**动作。这次将**材质**属性设置为与红色目标材质相匹配的材质。
- en: Switch to the **Position synch** FSM, and select the **Set player position with
    lerp** state.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**位置同步**状态机，并选择**使用lerp设置玩家位置**状态。
- en: In the **Set Position** action, set **X** to **None**, **Y** to `0.85`, and
    **Z** to **None**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置位置**动作中，将**X**设置为**None**，**Y**设置为`0.85`，将**Z**设置为**None**。
- en: Now the mallets should be good to go, their positions synched over the network
    and colors set on startup. Save your scene and confirm that mallets' positions
    are synced by building the game and launching two instances of it while connecting
    to the same match.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，球槌应该可以正常使用了，它们的网络位置同步，并在启动时设置了颜色。保存你的场景，并通过构建游戏并启动两个实例同时连接到相同的比赛来确认球槌的位置已同步。
- en: All that is left is to sync the Puck's position over the network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是通过网络同步Puck的位置。
- en: Select the `Puck` prefab and add the **Photon View** and **Play Maker Photon
    Game Object Proxy** components to it.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Puck**预制体，并向其添加**Photon View**和**Play Maker Photon Game Object Proxy**组件。
- en: Copy the **Position synch** and **variable synch repository** FSMs to it from
    the `Fsm Photon player` prefab.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Fsm Photon player`预制体中将**位置同步**和**变量同步仓库**状态机复制到它上面。
- en: Drag the **variable synch repository** component of **Play Maker FSM** into
    the **Observe** slot of **Photon View** and set its **Observer** option to **Reliable
    Data Compressed**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Play Maker FSM**的**变量同步仓库**组件拖放到**Photon View**的**观察**槽中，并将其**观察者**选项设置为**可靠数据压缩**。
- en: Switch to the **Position synch** FSM and select the **Set player position with
    lerp** state.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**位置同步**状态机并选择**使用lerp设置玩家位置**状态。
- en: In the **Set Position** action, set **X** to **None**, **Y** to `0.3`, and **Z**
    to **None**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置位置**动作中，将**X**设置为**None**，**Y**设置为`0.3`，将**Z**设置为**None**。
- en: Save your scene.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景。
- en: The last thing that you need to do is make sure that one of the players leaves
    the room instead of just reloading the level once the puck hits a goal. To do
    that, select the **GoalTriggerLeft** game object and, in the **LoadLevel** state
    of its FSM, replace the **Load Level** action with **Photon Network Leave Room**.
    Do the same for **GoalTriggerRight**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是确保当球击中球门时，其中一个玩家离开房间而不是仅仅重新加载关卡。要做到这一点，选择**GoalTriggerLeft**游戏对象，并在其状态机的**LoadLevel**状态中，将**加载关卡**动作替换为**Photon
    Network Leave Room**。对**GoalTriggerRight**也做同样的操作。
- en: Now your multiplayer should be set up. Before testing everything, confirm that
    you have copied all of the files over from the **Multiplayer** scene correctly.
    Make sure that there is a game object called **PlayMakerPhotonProxy** in both
    **demo_lobby** and **demo_room** scenes. If it is missing in one of the scenes,
    add it by going to **PlayMaker** | **Addons** | **Photon Networking** | **Components**
    | **Add Photon proxy to scene** from the main menu, then save the scene.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的多人游戏应该已经设置好了。在测试一切之前，确认你已经正确地从**Multiplayer**场景复制了所有文件。确保在**demo_lobby**和**demo_room**场景中都有一个名为**PlayMakerPhotonProxy**的游戏对象。如果其中一个场景中缺少它，可以通过从主菜单进入**PlayMaker**
    | **Addons** | **Photon Networking** | **Components** | **Add Photon proxy to
    scene**来添加它，然后保存场景。
- en: You can test it by making a build and opening it in your browser while launching
    the game in the Editor. Make sure you always start from the **demo_lobby** scene,
    because otherwise the matchmaking will not work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过构建游戏并在浏览器中打开它来测试它，同时启动编辑器中的游戏。确保你始终从**demo_lobby**场景开始，否则匹配将不会工作。
- en: You will see that the mallets' and the puck's positions are synched over the
    network. That is, they move simultaneously in both Editor and web browser. You
    will also notice that the movement of the remote object is somewhat jerky and
    imprecise (especially the puck on the host's client). This is due to the inevitable
    network delay and physics data being calculated more often than Photon packages
    are being sent. At the moment the only real solution to this problem is switching
    to Unity native networking, which, however, requires that you have your own server
    if you want the game to work over the Internet.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到球槌和Puck的位置通过网络同步。也就是说，它们在编辑器和网页浏览器中同时移动。你还会注意到远程对象的移动有些生硬和不精确（尤其是在主机的客户端上的Puck）。这是由于不可避免的网络延迟和物理数据计算频率高于Photon包发送频率所导致的。目前解决这个问题的唯一真正方法是切换到Unity原生网络，但这需要你有自己的服务器，如果你想在互联网上运行游戏的话。
- en: The place where the objects' movement is smoothed out is the **Position synch**
    FSM of `Puck` and `Mallet` prefabs. If you look at the **get player position**
    and **Set player position with lerp states** of these state machines, you will
    see that, if the object was first created on the local machine, its position gets
    saved in a variable every frame and synched over the network. If the object does
    not belong to the player's client, the variable is read, and then the position
    of the local copy of the object is interpolated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对象运动平滑处理的地方是`Puck`和`Mallet`预制体的**Position synch**状态机。如果您查看这些状态机的**get player
    position**和**Set player position with lerp states**，您会看到，如果对象最初是在本地机器上创建的，其位置会在每一帧保存到一个变量中并通过网络同步。如果对象不属于玩家的客户端，则读取该变量，然后对对象的本地副本的位置进行插值。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You could try changing the **Amount** property of the **Vector3 Lerp 2** action
    in the **Set player position with lerp** state. This variable determines the precision
    of the interpolation. If you want to know more about the way PUN works under the
    hood, make sure you consult its online documentation that explains every state
    machine in the demo scenes in great detail: [https://hutonggames.fogbugz.com/default.asp?W927](https://hutonggames.fogbugz.com/default.asp?W927)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试更改**Set player position with lerp**状态中**Vector3 Lerp 2**动作的**Amount**属性。这个变量决定了插值的精度。如果您想了解更多关于PUN内部工作方式的信息，请确保查阅其在线文档，该文档详细解释了演示场景中的每个状态机：[https://hutonggames.fogbugz.com/default.asp?W927](https://hutonggames.fogbugz.com/default.asp?W927)
- en: 'As you can see, Photon networking is quite easy to set up, but is not a very
    good solution for games that require physics simulation. This is mostly due to
    cloud server limitations and limited integration with the Unity engine. Most simple
    games that don''t rely on physics so heavily can benefit from Photon greatly.
    In other cases, Unity native networking should be used. More information about
    it can be found in the Network Reference Guide section of the Unity documentation:
    [http://docs.unity3d.com/Documentation/Components/NetworkReferenceGuide.html](http://docs.unity3d.com/Documentation/Components/NetworkReferenceGuide.html)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，光子网络设置起来相当简单，但并不是非常适合需要物理模拟的游戏。这主要是因为云服务器的限制以及与Unity引擎的集成有限。大多数不重度依赖物理的简单游戏可以从光子网络中受益。在其他情况下，应使用Unity原生网络。更多关于它的信息可以在Unity文档的“网络参考指南”部分找到：[http://docs.unity3d.com/Documentation/Components/NetworkReferenceGuide.html](http://docs.unity3d.com/Documentation/Components/NetworkReferenceGuide.html)
- en: Playmaker is capable of working with native Unity networking as well. You can
    check the **Network** section of the **Actions** panel for the list of available
    Playmaker actions and compare them with the actions described in the reference
    material.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Playmaker也能够与原生Unity网络协同工作。您可以在**动作**面板的**网络**部分查看可用的Playmaker动作列表，并将它们与参考材料中描述的动作进行比较。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basics of networking in games, set up the Photon
    Unity Networking plugin to work with Playmaker, and added PUN multiplayer to your
    game. We also examined the advantages and disadvantages of Photon and showed that
    it may not be suitable for physics games such as air hockey, because of the network
    delay.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了游戏网络的基础知识，设置了Photon Unity Networking插件以与Playmaker协同工作，并将PUN多人游戏功能添加到您的游戏中。我们还探讨了Photon的优缺点，并指出它可能不适合像冰球这样的物理游戏，因为网络延迟的原因。
- en: The next chapter will show how to put your game on the Web and add Kongregate
    API to save game scores in an online leaderboard.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将展示如何将您的游戏放到网上，并添加Kongregate API以保存游戏分数到在线排行榜。
