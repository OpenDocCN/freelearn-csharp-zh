<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer198">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 class="chapterTitle" id="_idParaDest-179"><span class="koboSpan" id="kobo.2.1">Testing Your Enterprise Application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">When developing software, it is essential to ensure that an application is as bug-free as possible and that it satisfies all requirements. </span><span class="koboSpan" id="kobo.3.2">This can be done by testing all the modules while they are being developed or when the overall application has been either completely or partially implemented. </span><span class="koboSpan" id="kobo.3.3">This need has become more and more compelling in today’s agile and DevOps-driven software development landscape, where integrating testing at every stage of the development process is essential for the continuous delivery of reliable software. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">While most of the key concepts covered by this chapter apply to a wide range of applications and environments, this chapter focuses on essential testing strategies for enterprise-level applications in C# and .NET environments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">Performing all the tests manually is not a feasible option since most of the tests must be executed each time the application is modified, and, as explained throughout this book, modern software is continuously being modified to adapt applications to the needs of a fast-changing market. </span><span class="koboSpan" id="kobo.5.2">Therefore, automated tests are indispensable in today’s fast-paced environment of continuous development. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">This chapter discusses the most common types of tests needed to deliver reliable software and how to organize and automate them. </span><span class="koboSpan" id="kobo.6.2">More specifically, this chapter covers the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Understanding unit and integration tests and their usage, which are the main tools to ensure software reliability and stability</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Understanding the basics of </span><strong class="keyWord"><span class="koboSpan" id="kobo.9.1">test-driven development</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.11.1">TDD</span></strong><span class="koboSpan" id="kobo.12.1">) and how and why it can dramatically reduce the probability of undiscovered bugs</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Functional tests, which are the main tool for enforcing software specifications</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Defining C# test-specific projects in Visual Studio to take full advantage of the testing tools available in the .NET ecosystem</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Automating functional tests in C#</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.16.1">This chapter will not only teach you the different types of tests and how to implement them but also how to effectively apply these techniques in your role as a .NET software architect to build robust, scalable enterprise applications.</span></p>
<h1 class="heading-1" id="_idParaDest-180"><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.18.1">This chapter requires the Visual Studio 2022 free Community Edition or better, with all database tools installed. </span><span class="koboSpan" id="kobo.18.2">The code for this chapter is available at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.20.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-181"><span class="koboSpan" id="kobo.21.1">Understanding unit and integration tests</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.22.1">Testing is an essential part of software development since it verifies both that the software is bug-free and that it conforms to the agreed specification. </span><span class="koboSpan" id="kobo.22.2">Delaying application testing until immediately</span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.23.1"> after most of the application’s functionalities have been implemented in their </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.24.1">entirety must be avoided for the following reasons:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">If a class or module has been incorrectly designed or implemented, it might have already influenced the way other modules were implemented. </span><span class="koboSpan" id="kobo.25.2">Therefore, at this point, fixing the problem might have a very high cost.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">The possible combination of input that is needed to test all possible paths that execution can take grows exponentially with the number of modules or classes that are tested together. </span><span class="koboSpan" id="kobo.26.2">Thus, for instance, if the execution of a class method </span><code class="inlineCode"><span class="koboSpan" id="kobo.27.1">A</span></code><span class="koboSpan" id="kobo.28.1"> can take three different paths, while the execution of another method </span><code class="inlineCode"><span class="koboSpan" id="kobo.29.1">B</span></code><span class="koboSpan" id="kobo.30.1"> can take four paths, then testing </span><code class="inlineCode"><span class="koboSpan" id="kobo.31.1">A</span></code><span class="koboSpan" id="kobo.32.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">B</span></code><span class="koboSpan" id="kobo.34.1"> together would require 3 x 4 different inputs. </span><span class="koboSpan" id="kobo.34.2">In general, if we test several modules together, the total number of paths to test is the product of the number of paths to test in each module. </span><span class="koboSpan" id="kobo.34.3">If modules are tested separately, instead, the number of inputs required is just the sum of the paths needed to test each module. </span><span class="koboSpan" id="kobo.34.4">That’s why so-called unit tests verify each class method separately in an exhaustive way as soon as each class is designed. </span><span class="koboSpan" id="kobo.34.5">After that, the overall behavior correctness can be verified with an acceptably small number of so-called </span><em class="italic"><span class="koboSpan" id="kobo.35.1">integration tests</span></em><span class="koboSpan" id="kobo.36.1">,</span><em class="italic"><span class="koboSpan" id="kobo.37.1"> because integration tests</span></em><span class="koboSpan" id="kobo.38.1"> just need to verify the various</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.39.1"> classes’ interaction patterns without analyzing all methods’ execution paths.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.40.1">If a test of an aggregate made of </span><em class="italic"><span class="koboSpan" id="kobo.41.1">N</span></em><span class="koboSpan" id="kobo.42.1"> modules fails, then locating the origin of the bug among the </span><em class="italic"><span class="koboSpan" id="kobo.43.1">N</span></em><span class="koboSpan" id="kobo.44.1"> modules is usually a very time-consuming activity.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.45.1">When </span><em class="italic"><span class="koboSpan" id="kobo.46.1">N</span></em><span class="koboSpan" id="kobo.47.1"> modules are tested together, we have to redefine all tests involving the </span><em class="italic"><span class="koboSpan" id="kobo.48.1">N</span></em><span class="koboSpan" id="kobo.49.1"> modules, even if just one of the </span><em class="italic"><span class="koboSpan" id="kobo.50.1">N</span></em><span class="koboSpan" id="kobo.51.1"> modules changes during the application’s life cycle.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.52.1">These considerations show that we need both to test each class method separately as soon as possible and to test for correct module integration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.53.1">That is why tests are organized into three stages, as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.54.1">Unit tests</span></strong><span class="koboSpan" id="kobo.55.1">: These verify that all</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.56.1"> or almost all execution paths of each method behave properly. </span><span class="koboSpan" id="kobo.56.2">They should be free from external dependencies, such as storage and databases, and should be quite complete; that is, they should cover most of the possible paths. </span><span class="koboSpan" id="kobo.56.3">This is usually feasible at an acceptable time cost because there are not too many possible execution paths for each method as compared to the possible execution paths of the whole application.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.57.1">Integration tests</span></strong><span class="koboSpan" id="kobo.58.1">: These are executed once the software passes all its unit tests. </span><span class="koboSpan" id="kobo.58.2">Integration tests verify that all modules interact properly to get the expected results. </span><span class="koboSpan" id="kobo.58.3">Integration tests do not need to be complete since unit tests will have already </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.59.1">verified that all the execution paths of each module work properly. </span><span class="koboSpan" id="kobo.59.2">They need to verify as many patterns of interaction as possible, that is, as many ways in which the various modules may cooperate.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.60.1">Acceptance tests</span></strong><span class="koboSpan" id="kobo.61.1">: These are executed at the end of each sprint and/or before releasing the application. </span><span class="koboSpan" id="kobo.61.2">They </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.62.1">verify that the output of a sprint or the final application satisfies both functional and non-functional requirements. </span><span class="koboSpan" id="kobo.62.2">Tests that verify functional requirements are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.63.1">functional tests</span></strong><span class="koboSpan" id="kobo.64.1">, while</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.65.1"> tests that verify performance</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.66.1"> requirements are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.67.1">performance tests</span></strong><span class="koboSpan" id="kobo.68.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.69.1">Usually, each interaction pattern has more than one test associated with it: a typical activation of a pattern and some extreme cases of activation. </span><span class="koboSpan" id="kobo.69.2">For instance, if a whole pattern of interaction receives an array as input, we will write a test for the typical size of the array, a test with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">null</span></code><span class="koboSpan" id="kobo.71.1"> array, a test with an empty array, and a test with a very big array. </span><span class="koboSpan" id="kobo.71.2">This way, we verify that the way the single module was designed is compatible with the needs of the whole interaction pattern. </span><span class="koboSpan" id="kobo.71.3">It is worth pointing out that, in our array example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">null</span></code><span class="koboSpan" id="kobo.73.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">0</span></code><span class="koboSpan" id="kobo.75.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">1</span></code><span class="koboSpan" id="kobo.77.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.78.1">many</span></em><span class="koboSpan" id="kobo.79.1"> are equivalence classes that represent the whole universe of array values in an efficacious way.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">With the preceding strategy in place, if we modify a single module without changing its public interface, we need to change the unit tests for that module.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.81.1">If, instead, the change involves the way some modules interact, then we also have to add new integration tests or modify existing ones. </span><span class="koboSpan" id="kobo.81.2">However, usually, this is not a big problem since most of the tests are unit tests, so rewriting a large percentage of all integration tests does not require too much effort. </span><span class="koboSpan" id="kobo.81.3">Moreover, if the application was designed according to the </span><strong class="keyWord"><span class="koboSpan" id="kobo.82.1">Single Responsibility</span></strong><span class="koboSpan" id="kobo.83.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.84.1">Open/Closed</span></strong><span class="koboSpan" id="kobo.85.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.86.1">Liskov Substitution</span></strong><span class="koboSpan" id="kobo.87.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.88.1">Interface Segregation</span></strong><span class="koboSpan" id="kobo.89.1">, or </span><strong class="keyWord"><span class="koboSpan" id="kobo.90.1">Dependency Inversion</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.92.1">SOLID</span></strong><span class="koboSpan" id="kobo.93.1">) principles, the number of integration tests that must be</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.94.1"> changed after a single code modification should be small since the modification should affect just a few classes that interact directly with the modified method or class.</span></p>
<h2 class="heading-2" id="_idParaDest-182"><span class="koboSpan" id="kobo.95.1">Automating unit and integration tests</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.96.1">At this point, it should be clear that </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.97.1">both unit tests and integration tests will be reused </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.98.1">during the entire lifetime of the software. </span><span class="koboSpan" id="kobo.98.2">That is why it is worth automating them. </span><span class="koboSpan" id="kobo.98.3">The automation of unit and integration tests avoids the possible errors of manual test execution and saves time. </span><span class="koboSpan" id="kobo.98.4">A whole battery of several thousand automated tests can verify software integrity following each small modification in a few minutes, thereby enabling the frequent changes needed in the CI/CD cycles of modern software.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.99.1">As new bugs are found, new tests are added to discover them so that they cannot reappear in future versions of the software. </span><span class="koboSpan" id="kobo.99.2">This way, automated tests always become more reliable and protect the software more from bugs added as a result of new changes. </span><span class="koboSpan" id="kobo.99.3">Thus, the probability of adding new bugs (that are not immediately discovered) is greatly reduced.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.100.1">The next subsection will give us the basics for organizing and designing automated unit and integration tests, as well </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.101.1">as practical details</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.102.1"> on how to write a test in C# in the </span><em class="italic"><span class="koboSpan" id="kobo.103.1">Defining C# test projects in Visual Studio</span></em><span class="koboSpan" id="kobo.104.1"> section.</span></p>
<h2 class="heading-2" id="_idParaDest-183"><span class="koboSpan" id="kobo.105.1">Writing automated (unit and integration) tests</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.106.1">Tests are not written from scratch; all software development platforms have tools that help us to both write tests and launch them (or some of them). </span><span class="koboSpan" id="kobo.106.2">Once the selected tests have been executed, these tools </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.107.1">usually show a report and offer the possibility to debug the code of all failed tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.108.1">More specifically, by and large, all unit and integration test frameworks are composed of three important parts:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.109.1">Facilities for defining all tests</span></strong><span class="koboSpan" id="kobo.110.1">: They verify whether the actual results correspond to the expected results. </span><span class="koboSpan" id="kobo.110.2">Usually, a test is organized into test classes, where each test call tests either a single application class or a single class method. </span><span class="koboSpan" id="kobo.110.3">Each test is split into three stages:</span><ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.111.1">Test preparation (</span></strong><em class="italic"><span class="koboSpan" id="kobo.112.1">Arrange</span></em><strong class="keyWord"><span class="koboSpan" id="kobo.113.1">)</span></strong><span class="koboSpan" id="kobo.114.1">: The general environment needed by the test is prepared. </span><span class="koboSpan" id="kobo.114.2">This stage</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.115.1"> only prepares the global environment for tests, such as objects to inject into class constructors or simulations of database tables; it doesn’t prepare the individual inputs for each of the methods we’re going to test. </span><span class="koboSpan" id="kobo.115.2">Usually, the same preparation procedure is used in several tests, so test preparations are factored out into dedicated modules.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.116.1">Test execution (</span></strong><em class="italic"><span class="koboSpan" id="kobo.117.1">Act</span></em><strong class="keyWord"><span class="koboSpan" id="kobo.118.1">/</span></strong><em class="italic"><span class="koboSpan" id="kobo.119.1">Assert</span></em><strong class="keyWord"><span class="koboSpan" id="kobo.120.1">)</span></strong><span class="koboSpan" id="kobo.121.1">: The</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.122.1"> methods to test are invoked with adequate input (</span><em class="italic"><span class="koboSpan" id="kobo.123.1">Act</span></em><span class="koboSpan" id="kobo.124.1">), and all results of their executions are compared with expected results (</span><em class="italic"><span class="koboSpan" id="kobo.125.1">Assert</span></em><span class="koboSpan" id="kobo.126.1">) with constructs such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">Assert.Equal(x,y)</span></code><span class="koboSpan" id="kobo.128.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">Assert.NotNull(x)</span></code><span class="koboSpan" id="kobo.130.1">.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.131.1">Tear-down</span></strong><span class="koboSpan" id="kobo.132.1">: The whole</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.133.1"> environment is cleaned up to avoid the execution of a test influencing other tests. </span><span class="koboSpan" id="kobo.133.2">This step is the converse of </span><em class="italic"><span class="koboSpan" id="kobo.134.1">step 1</span></em><span class="koboSpan" id="kobo.135.1">.</span></li>
</ol>
</li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.136.1">Mock facilities</span></strong><span class="koboSpan" id="kobo.137.1">: While integration tests use all (or almost all) classes involved in a pattern of object cooperation, in unit tests, the use of other application classes should be avoided because their purpose is to test each isolated method. </span><span class="koboSpan" id="kobo.137.2">Thus, if a class under test, say, </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">A</span></code><span class="koboSpan" id="kobo.139.1">, uses a method of another application class, </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">B</span></code><span class="koboSpan" id="kobo.141.1">, that is injected into its constructor in one of its methods, </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">M</span></code><span class="koboSpan" id="kobo.143.1">, and then, in order to test </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">M</span></code><span class="koboSpan" id="kobo.145.1">, we must inject a fake implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">B</span></code><span class="koboSpan" id="kobo.147.1">. </span><span class="koboSpan" id="kobo.147.2">It is worth pointing out that only classes that do some processing cannot be used by other classes being unit tested, while pure data classes can. </span><span class="koboSpan" id="kobo.147.3">Mock frameworks contain facilities to define implementations of interfaces and interface methods that return data that can be defined by the test designer. </span><span class="koboSpan" id="kobo.147.4">Typically, mock implementations are also able to report information on all mock method calls. </span><span class="koboSpan" id="kobo.147.5">Such mock implementations do not require the definition of actual class files but are done online in the test code by calling methods such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">new Mock&lt;IMyInterface&gt;()</span></code><span class="koboSpan" id="kobo.149.1">.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.150.1">Execution and reporting tool</span></strong><span class="koboSpan" id="kobo.151.1">: This is a visual configuration-based tool that the developer may use to decide which tests to launch and when to launch them. </span><span class="koboSpan" id="kobo.151.2">Moreover, it also</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.152.1"> shows the final outcome of the tests as a report containing all successful tests, all failed tests, each test’s execution time, and other information that depends on the specific tool and how it was configured. </span><span class="koboSpan" id="kobo.152.2">Usually, execution and reporting tools that are executed in development IDEs, such as Visual Studio, also give you the possibility of launching a debug session on each failed test.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.153.1">Since only interfaces allow a complete mock definition of all their methods, we should inject interfaces or pure data classes (that don’t need to be mocked) in class constructors and methods if we want to mock all dependencies in our unit tests. </span><span class="koboSpan" id="kobo.153.2">Therefore, for each cooperating class that we want to inject into another class and that we want to mock, we must define a corresponding interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.154.1">Moreover, classes should use instances that are injected in their constructors or methods and not class instances available in the public static fields of other classes; otherwise, the results of the unit tests might appear not to be deterministic since these static values might not be set properly during the tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.155.1">The subsection that follows focuses on functional and performance tests.</span></p>
<h2 class="heading-2" id="_idParaDest-184"><span class="koboSpan" id="kobo.156.1">Acceptance tests: writing functional and performance tests</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.157.1">Acceptance tests define the contract </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.158.1">between the project stakeholders and the development team. </span><span class="koboSpan" id="kobo.158.2">They are used to verify that the software developed actually behaves as it was agreed it would. </span><span class="koboSpan" id="kobo.158.3">Acceptance tests verify not only functional specifications but also constraints on the software usability and </span><strong class="keyWord"><span class="koboSpan" id="kobo.159.1">user interface</span></strong><span class="koboSpan" id="kobo.160.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.161.1">UI</span></strong><span class="koboSpan" id="kobo.162.1">). </span><span class="koboSpan" id="kobo.162.2">Since they also have the purpose of </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.163.1">showing how the software appears and behaves on actual computer monitors and displays, they are never completely automatic but consist mainly of lists of recipes and verifications that must be followed by an operator.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.164.1">Sometimes, automatic </span><strong class="keyWord"><span class="koboSpan" id="kobo.165.1">functional tests</span></strong><span class="koboSpan" id="kobo.166.1"> are developed to verify just functional requirements, but </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.167.1">some of these tests </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.168.1">may also bypass the UI and inject the test input directly into the logic that is immediately behind the user interface. </span><span class="koboSpan" id="kobo.168.2">For instance, in the case of an ASP.NET Core MVC application (see </span><em class="chapterRef"><span class="koboSpan" id="kobo.169.1">Chapter 17</span></em><span class="koboSpan" id="kobo.170.1">, </span><em class="italic"><span class="koboSpan" id="kobo.171.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.172.1">), the whole website can be run in a complete environment that includes all the necessary storage filled with test data. </span><span class="koboSpan" id="kobo.172.2">Input is not provided to HTML pages but is injected directly into the ASP.NET Core controllers. </span><span class="koboSpan" id="kobo.172.3">Tests that bypass the user interface are called subcutaneous tests. </span><span class="koboSpan" id="kobo.172.4">ASP.NET </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.173.1">Core supplies various tools to perform subcutaneous tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.174.1">If possible, most automated acceptance tests should be defined as subcutaneous tests for the following reasons:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.175.1">Automating the actual interaction with the user interface is a very time-consuming task.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.176.1">User interfaces are changed frequently to improve their usability and to add new features, and small changes in a single application screen may force a complete rewrite of all tests that operate on that screen.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.177.1">In a few words, user interface tests are very expansive and have low reusability, so usually, complete adherence to specifications is tested with subcutaneous tests, and full tests involving the whole user interface are performed just to test the more common and/or more error-prone scenarios.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.178.1">A common approach for testing the user interface is the usage of playback tools like </span><strong class="keyWord"><span class="koboSpan" id="kobo.179.1">Selenium IDE</span></strong><span class="koboSpan" id="kobo.180.1"> (</span><a href="https://www.selenium.dev/selenium-ide/"><span class="url"><span class="koboSpan" id="kobo.181.1">https://www.selenium.dev/selenium-ide/</span></span></a><span class="koboSpan" id="kobo.182.1">) during </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.183.1">manual tests so that each manual test can be repeated automatically. </span><span class="koboSpan" id="kobo.183.2">It’s likely that the code generated automatically by such tools is not robust enough to resist non-trivial changes in the HTML. </span><span class="koboSpan" id="kobo.183.3">The Selenium IDE playback code tries to resist HTML changes by attempting several selectors to identify each HTML element, but this only helps with small changes. </span><span class="koboSpan" id="kobo.183.4">Therefore, in general, playback code can be reused only for the parts of the application UI that are not affected by changes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.184.1">The Selenium software may also be used programmatically, that is, by describing user interface tests directly in the code. </span><span class="koboSpan" id="kobo.184.2">Selenium will be discussed in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.185.1">Automating functional tests in C#</span></em><span class="koboSpan" id="kobo.186.1"> section, while functional tests, in general, are discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.187.1">Functional tests</span></em><span class="koboSpan" id="kobo.188.1"> section.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.189.1">Performance tests</span></strong><span class="koboSpan" id="kobo.190.1"> apply a</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.191.1"> fake load to an application to see whether it can handle the typical production load, discover</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.192.1"> its load limits, and locate bottlenecks. </span><span class="koboSpan" id="kobo.192.2">The application is deployed in a staging environment that is a copy of the actual production environment in terms of hardware resources.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">Then, fake requests are created and applied to the system, and response times and other metrics are collected. </span><span class="koboSpan" id="kobo.193.2">Fake request batches should have the same composition as the actual production batches. </span><span class="koboSpan" id="kobo.193.3">They can be generated from the actual production request logs if they are available.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.194.1">If response times are not satisfactory, other metrics are collected to discover possible bottlenecks (low memory, slow storage, or slow software modules). </span><span class="koboSpan" id="kobo.194.2">Once located, a software component that is responsible for the problem can be analyzed in the debugger to measure the execution time of the various method calls involved in a typical request.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.195.1">Failures in the performance tests may lead either to a redefinition of the hardware needed by the application or to the optimization of some software modules, classes, or methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.196.1">Both Azure and Visual Studio offer tools to create fake loads and to report execution metrics. </span><span class="koboSpan" id="kobo.196.2">However, they have been declared obsolete and will be discontinued, so we will not describe them. </span><span class="koboSpan" id="kobo.196.3">As an alternative, there are both open-source and third-party tools that can be used. </span><span class="koboSpan" id="kobo.196.4">Some of them are listed in the </span><em class="italic"><span class="koboSpan" id="kobo.197.1">Further reading</span></em><span class="koboSpan" id="kobo.198.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.199.1">The next section describes a software development methodology that plays a central role in tests.</span></p>
<h1 class="heading-1" id="_idParaDest-185"><span class="koboSpan" id="kobo.200.1">Understanding the basics of test-driven development</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.201.1">Test-driven development</span></strong><span class="koboSpan" id="kobo.202.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.203.1">TDD</span></strong><span class="koboSpan" id="kobo.204.1">) is a </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.205.1">software development methodology that gives a central role to unit tests. </span><span class="koboSpan" id="kobo.205.2">According to this methodology, unit tests are a formalization of the specifications of each class, so they must be written before the code of the class. </span><span class="koboSpan" id="kobo.205.3">Actually, a full test that covers all code paths univocally defines the code behavior, so it can be considered a specification for the code. </span><span class="koboSpan" id="kobo.205.4">It is not a formal specification that defines the code behavior through some formal language but a specification based on examples of behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.206.1">The ideal way to test software would be to write formal specifications of the whole software behavior and to verify with some wholly automatic tools whether the software that was actually produced conforms to them. </span><span class="koboSpan" id="kobo.206.2">In the past, some research effort was spent defining formal languages for describing code specifications, but expressing the behavior the developer has in mind with similar languages was a very difficult and error-prone task. </span><span class="koboSpan" id="kobo.206.3">Therefore, these attempts were quickly abandoned in favor of approaches based on examples. </span><span class="koboSpan" id="kobo.206.4">At that time, the main purpose was the automatic generation of code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.207.1">Nowadays, automatic code</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.208.1"> generation has been largely abandoned and survives in small application areas, such as the creation of device drivers. </span><span class="koboSpan" id="kobo.208.2">In these areas, the effort of formalizing the behavior in a formal language is worth the time saved in trying to test difficult-to-reproduce behaviors of parallel threads.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.209.1">Unit tests were initially conceived as a way to encode example-based specifications in a completely independent way as part of a specific agile development methodology called </span><strong class="keyWord"><span class="koboSpan" id="kobo.210.1">extreme programming</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">However, since</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.212.1"> TDD proved to be very efficacious in preventing bugs, nowadays, TDD is used independently of extreme programming and is included as an obligatory prescription in other agile methodologies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.213.1">The practice of TDD proved that well-designed initial unit tests are enough to ensure an acceptable level of software stability, despite the fact that, usually, initial tests are not a “perfect” specification of the code. </span><span class="koboSpan" id="kobo.213.2">However, it is undoubtedly true that unit tests refined after finding hundreds of bugs act as reliable and substantially perfect code specifications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.214.1">Well-designed unit tests can’t be based on random inputs since you might need an infinite or at least an immense number of examples to define a code’s behavior this way univocally. </span><span class="koboSpan" id="kobo.214.2">However, the behavior can be defined with an acceptable number of inputs if you have all possible execution paths in mind. </span><span class="koboSpan" id="kobo.214.3">In fact, at this point, it is enough to select a typical example for each execution path.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.215.1">That’s why writing a unit test for a method after that method has been completely coded is easy: it simply requires the selection of a typical instance for each execution path of the already-existing code. </span><span class="koboSpan" id="kobo.215.2">However, writing unit tests this way does not protect from errors in the design of the execution paths themselves.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.216.1">Therefore, a unit test must be written before a method has been completely coded, but while writing unit tests, the developer must somehow forecast all execution paths by looking for extreme cases and by possibly adding more examples than are strictly needed.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.217.1">For instance, while writing the code that sorts an array, we might start considering all possible extreme cases we</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.218.1"> are able to forecast before any line of useful method code has been written, that is:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.219.1">An empty array</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.220.1">A null array</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.221.1">A single-element array</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.222.1">An array with a few elements</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.223.1">An array with several elements</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.224.1">An already-ordered array</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.225.1">A partially ordered array</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.226.1">An extremely unordered array</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.227.1">After the first version of the algorithm has been written and passes all of the above tests, other inputs that might cause different execution paths might be discovered by analyzing all execution paths. </span><span class="koboSpan" id="kobo.227.2">If this is the case, we add a new unit test for each different execution path discovered.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">For instance, in the case of the array sorting method, suppose that we use a divide-and-conquer algorithm, like merge-sort, that recursively splits the array into two halves to recursively reduce the problem to a simpler one. </span><span class="koboSpan" id="kobo.228.2">For sure, the way that arrays with even or odd lengths are processed will be different, so we must add at least two new tests, one with an even-length array and the other with an odd-length array.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.229.1">However, as developers can make mistakes while writing application code, they can also make mistakes in forecasting all possible execution paths while designing unit tests!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.230.1">It seems we have identified a possible drawback of TDD: unit tests themselves may be wrong. </span><span class="koboSpan" id="kobo.230.2">That is, not only application code but also its associated TDD unit tests may be inconsistent with the behavior the developer has in mind. </span><span class="koboSpan" id="kobo.230.3">Therefore, in the beginning, unit tests can’t be considered software specifications but rather a possibly incorrect and incomplete description of the software behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.231.1">Therefore, we have two descriptions of the behavior we have in mind: the application code itself and its TDD unit tests that were written before the application code. </span><span class="koboSpan" id="kobo.231.2">However, this is not an issue because the theory of probability helps us!</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.232.1">What makes TDD work well in practice is the fact that the probability of making exactly the same error while writing the tests and while writing the code is very low. </span><span class="koboSpan" id="kobo.232.2">Therefore, whenever a test fails, there is an error either in the tests or in the application code, and conversely, if there is an error either in the application code or in the test, there is a very high probability that a test will fail. </span><span class="koboSpan" id="kobo.232.3">That is, the use of TDD ensures that most bugs are found immediately!</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.233.1">Now that we have </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.234.1">understood why TDD is efficacious in preventing bugs and have learned how to select the inputs for our unit tests, we can move to the description of the TDD-based code-writing process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.235.1">Writing a class method or a chunk of code, say for finding the maximum of an array of integers with TDD, is a loop composed of three stages:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.236.1">Red stage</span></strong><span class="koboSpan" id="kobo.237.1">: At this stage, the developer </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.238.1">writes an empty method, say </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">MaximumGrade</span></code><span class="koboSpan" id="kobo.240.1">, that throws </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">NotImplementedException</span></code><span class="koboSpan" id="kobo.242.1">, and also writes new unit tests for this method. </span><span class="koboSpan" id="kobo.242.2">These tests must necessarily fail because, at this time, no code implements the behavior they describe:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.243.1">public</span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.244.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.245.1">MaximumGrade</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.246.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.247.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.248.1">[] grades</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.249.1">)</span></span><span class="koboSpan" id="kobo.250.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.251.1">throw</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.252.1">new</span></span><span class="koboSpan" id="kobo.253.1"> NotImplementedException();
}
</span></code></pre>
</li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.254.1">Green stage</span></strong><span class="koboSpan" id="kobo.255.1">: In this stage, the </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.256.1">developer writes the minimum code or makes the minimum modifications to existing code necessary to make all unit tests pass. </span><span class="koboSpan" id="kobo.256.2">Say we test </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">MaximumGrade</span></code><span class="koboSpan" id="kobo.258.1"> with a null array, an array with </span><code class="inlineCode"><span class="koboSpan" id="kobo.259.1">0</span></code><span class="koboSpan" id="kobo.260.1"> elements, an array with just one element, and an array with several elements; the code that passes all tests might be:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.261.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.262.1">MaximumGrade</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.263.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.264.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.265.1">[] grades</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.266.1">)</span></span><span class="koboSpan" id="kobo.267.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.268.1">if</span></span><span class="koboSpan" id="kobo.269.1">(grades == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.270.1">null</span></span><span class="koboSpan" id="kobo.271.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.272.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.273.1">0</span></span><span class="koboSpan" id="kobo.274.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.275.1">int</span></span><span class="koboSpan" id="kobo.276.1"> result= </span><span class="hljs-number"><span class="koboSpan" id="kobo.277.1">0</span></span><span class="koboSpan" id="kobo.278.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.279.1">for</span></span><span class="koboSpan" id="kobo.280.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.281.1">int</span></span><span class="koboSpan" id="kobo.282.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.283.1">0</span></span><span class="koboSpan" id="kobo.284.1">; i &lt; grades.Length; i++)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.285.1">if</span></span><span class="koboSpan" id="kobo.286.1"> (grades[i]&gt; result) result= grades[i];
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.287.1">return</span></span><span class="koboSpan" id="kobo.288.1"> result;
}
</span></code></pre>
</li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.289.1">Refactoring stage</span></strong><span class="koboSpan" id="kobo.290.1">: Once the test is passed, the code is refactored to ensure good code quality and the </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.291.1">application of best practices and patterns. </span><span class="koboSpan" id="kobo.291.2">In particular, in this stage, some code can be factored out in other methods or other classes. </span><span class="koboSpan" id="kobo.291.3">During this stage, we may also discover the need for other unit tests because new execution paths or new extreme cases are discovered or created. </span><span class="koboSpan" id="kobo.291.4">In the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">MaximumGrade</span></code><span class="koboSpan" id="kobo.293.1">, at this stage, we might notice the following:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.294.1">Instead of returning 0 when the array is </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">null</span></code><span class="koboSpan" id="kobo.296.1">, it would be better to define a new exception and throw it.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">foreach</span></code><span class="koboSpan" id="kobo.298.1"> is more efficient and more readable than </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">for</span></code><span class="koboSpan" id="kobo.300.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.301.1">What if all numbers are negative? </span><span class="koboSpan" id="kobo.301.2">We must create a new test with an array of negative numbers:</span></li>
</ul>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.302.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.303.1">MaximumGrade</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.304.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.305.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.306.1">[] grades</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.307.1">)</span></span><span class="koboSpan" id="kobo.308.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">if</span></span><span class="koboSpan" id="kobo.310.1">(grades == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.311.1">null</span></span><span class="koboSpan" id="kobo.312.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.313.1">throw</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.314.1">new</span></span><span class="koboSpan" id="kobo.315.1"> ArgumentException();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.316.1">int</span></span><span class="koboSpan" id="kobo.317.1"> result= </span><span class="hljs-number"><span class="koboSpan" id="kobo.318.1">0</span></span><span class="koboSpan" id="kobo.319.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.320.1">foreach</span></span><span class="koboSpan" id="kobo.321.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.322.1">int</span></span><span class="koboSpan" id="kobo.323.1"> grade </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.324.1">in</span></span><span class="koboSpan" id="kobo.325.1"> grades)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.326.1">if</span></span><span class="koboSpan" id="kobo.327.1"> (grade &gt; result) result= grade;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.328.1">return</span></span><span class="koboSpan" id="kobo.329.1"> result;
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.330.1">The loop stops as soon as all tests pass without writing new code or modifying the existing code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.331.1">When we repeat the red stage, the newly added test for the negative array will fail because of our inadequate initialization:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.332.1">int</span></span><span class="koboSpan" id="kobo.333.1"> result=</span><span class="hljs-number"><span class="koboSpan" id="kobo.334.1">0</span></span><span class="koboSpan" id="kobo.335.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.336.1">So, we need to replace it with:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.337.1">int</span></span><span class="koboSpan" id="kobo.338.1"> result= </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.339.1">int</span></span><span class="koboSpan" id="kobo.340.1">.MinValue;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.341.1">At this point, all tests pass again, and we move to the green stage again. </span><span class="koboSpan" id="kobo.341.2">There is no need for further refactoring, so the refactoring stage doesn’t modify our code, meaning we can exit the test loop: we are done!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.342.1">Sometimes, it is very difficult to design the initial unit tests because it is quite difficult to imagine how the code might work and the execution paths it might take. </span><span class="koboSpan" id="kobo.342.2">In this case, you can get a better understanding </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.343.1">of the specific algorithm to use by writing an initial sketch of the method code. </span><span class="koboSpan" id="kobo.343.2">In this initial stage, we need to focus just on the main execution path, completely ignoring extreme cases and input verifications. </span><span class="koboSpan" id="kobo.343.3">Once we get a clear picture of the main ideas behind an algorithm that should work, we can enter the standard three-stage TDD loop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.344.1">The next section discusses functional tests in detail.</span></p>
<h1 class="heading-1" id="_idParaDest-186"><span class="koboSpan" id="kobo.345.1">Functional tests</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.346.1">These tests use the same techniques and tools as unit and integration tests but differ from them in that they are</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.347.1"> run only at the end of each sprint. </span><span class="koboSpan" id="kobo.347.2">They have the fundamental role of verifying that the current version of the entire software complies with its specifications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.348.1">Since functional tests also involve the UI, they </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.349.1">need further tools to simulate, somehow, how the user acts in the UI. </span><span class="koboSpan" id="kobo.349.2">The need for extra tools is not the only challenge the UI brings with it because UIs also see frequent and major changes. </span><span class="koboSpan" id="kobo.349.3">Thus, we mustn’t design tests that depend on the UI’s graphical details, or we might be forced to rewrite all the tests completely at each UI change. </span><span class="koboSpan" id="kobo.349.4">We will discuss both the tools and the best practices for optimizing UI tests in the </span><em class="italic"><span class="koboSpan" id="kobo.350.1">Automating functional tests in C#</span></em><span class="koboSpan" id="kobo.351.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.352.1">Anyway, it is worth pointing out that sometimes it is better to renounce automated testing for some UI-related features and fall back to manual tests because the time investment is not justified by the short life of the UI code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">Whether automatic or manual, functional testing must be a formal process that is performed for the following purposes:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.354.1">Functional tests represent the most important part of the contract between stakeholders and the development team, the other part being the verification of non-functional specifications. </span><span class="koboSpan" id="kobo.354.2">The way this contract is formalized depends on the nature of the relationship between the development team and stakeholders.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.355.1">In the case of a supplier-customer relationship, the functional tests become part of the supplier-customer business contract for each sprint, and a team that works for the customer writes them. </span><span class="koboSpan" id="kobo.355.2">If the tests fail, then the sprint is rejected, and the supplier must run a supplementary sprint to fix all problems.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.356.1">If there is no supplier-customer business relationship because the development team and the stakeholder belong to the same company, there is no business contract. </span><span class="koboSpan" id="kobo.356.2">In this case, the stakeholder, together with the team, writes an internal document that formalizes the requirements of the sprint. </span><span class="koboSpan" id="kobo.356.3">If the tests fail, usually, the sprint is not rejected, but the results of the tests are used to drive the specifications for the next sprints. </span><span class="koboSpan" id="kobo.356.4">Of course, if the failure percentage is high, the sprint may be rejected and should be repeated.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.357.1">Formalized functional tests that run at the end of each sprint prevent any results achieved in previous sprints from being destroyed by new code.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.358.1">When using an agile development methodology, maintaining an updated battery of functional tests is the best way to get a formal representation of the final system specifications since, during agile development, the specifications of the final system are not decided before development starts but are the result of the system’s evolution. </span><span class="koboSpan" id="kobo.358.2">Agile development and sprints are discussed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.359.1">Chapter 1</span></em><span class="koboSpan" id="kobo.360.1">, </span><em class="italic"><span class="koboSpan" id="kobo.361.1">Understanding the Importance of Software Architecture</span></em><span class="koboSpan" id="kobo.362.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.363.1">Since the output of the first sprints may differ a lot from the final system in these early stages, it is not worth spending</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.364.1"> too much time writing detailed manual tests and/or automatized tests. </span><span class="koboSpan" id="kobo.364.2">Therefore, you may limit the user stories to just a few examples that will be used both as inputs for software development and as manual tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.365.1">As system functionalities become more stable, it is worth investing time in writing detailed and formal functional tests for them. </span><span class="koboSpan" id="kobo.365.2">For each functional specification, we must write tests that verify their operation in extreme cases. </span><span class="koboSpan" id="kobo.365.3">For instance, in a cash withdrawal use case, we must write tests that verify all possibilities:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.366.1">Not enough funds</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.367.1">Card expired</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.368.1">Wrong credentials</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.369.1">Repeated wrong credentials</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.370.1">The following diagram sketches the whole process with all possible outcomes:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.371.1"><img alt="Descrizione: Diagram  Description automatically generated" src="../Images/B19820_09_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.372.1">Figure 9.1: Withdrawal example</span></p>
<p class="normal"><span class="koboSpan" id="kobo.373.1">The user inserts their card, and </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.374.1">the card may be accepted or rejected because it has expired. </span><span class="koboSpan" id="kobo.374.2">Then, the user tries their PIN with possible errors, so they might repeat the PIN entry till either they succeed or they reach a maximum number of attempts. </span><span class="koboSpan" id="kobo.374.3">Finally, the user enters the amount to withdraw and may get their money or a “Not enough funds” error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.375.1">In the case of manual tests, for each of the preceding scenarios, we must give all the details of all the steps involved in each operation and, for each step, the expected result.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.376.1">An important decision is whether you want to automate all or a part of the functional tests since it is very expensive to write automated tests that simulate a human operator that interacts with a system’s UI. </span><span class="koboSpan" id="kobo.376.2">The final decision depends on the cost of the test implementation divided by the expected number of times it will be used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.377.1">In the case of CI/CD, the same functional test can be executed several times, but unluckily, functional tests are strictly tied to the way the UI is implemented, and, in modern systems, the UI is changed frequently. </span><span class="koboSpan" id="kobo.377.2">Therefore, in this case, a test is executed with exactly the same UI no more than a couple of times.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.378.1">In order to overcome most of the problems related to the UI, some functional tests can be implemented as </span><strong class="keyWord"><span class="koboSpan" id="kobo.379.1">subcutaneous tests</span></strong><span class="koboSpan" id="kobo.380.1">. </span><span class="koboSpan" id="kobo.380.2">Subcutaneous </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.381.1">tests are a specific type of functional test designed to bypass the UI layer of an application. </span><span class="koboSpan" id="kobo.381.2">Instead of interacting with the application through its UI, like a user would, these tests directly interact with the application’s underlying</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.382.1"> logic. </span><span class="koboSpan" id="kobo.382.2">For example, in an ASP.NET Core application, a subcutaneous test might directly invoke the methods of a controller – the part of the application that handles incoming requests – rather than going through the process of sending these requests via a browser. </span><span class="koboSpan" id="kobo.382.3">This approach helps us focus on testing the core functionality of the application without the complexities of the UI.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.383.1">In the user case in </span><em class="chapterRef"><span class="koboSpan" id="kobo.384.1">Chapter 21</span></em><span class="koboSpan" id="kobo.385.1">, </span><em class="italic"><span class="koboSpan" id="kobo.386.1">Case Study</span></em><span class="koboSpan" id="kobo.387.1">, we will see in practice how to design subcutaneous tests for an ASP.NET Core application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.388.1">Unfortunately, subcutaneous tests can’t verify all possible implementation errors since they can’t detect errors in the UI itself. </span><span class="koboSpan" id="kobo.388.2">Moreover, in the case of a web application, subcutaneous tests usually suffer from other limitations because they bypass the whole HTTP protocol.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.389.1">In particular, in the case of ASP.NET Core applications, which will be described in </span><em class="chapterRef"><span class="koboSpan" id="kobo.390.1">Chapter 17</span></em><span class="koboSpan" id="kobo.391.1">, </span><em class="italic"><span class="koboSpan" id="kobo.392.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.393.1">, if we call controller action methods directly, we bypass the whole ASP.NET Core pipeline that processes each request before passing it to the right action method. </span><span class="koboSpan" id="kobo.393.2">Therefore, authentication, authorization, CORS, and the behavior of other middleware in the ASP.NET Core pipeline will not be analyzed by the tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.394.1">A complete automated functional test of a web application should do the following things:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.395.1">Start an actual browser on the URL to be tested.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.396.1">Wait so that any JavaScript on the page completes its execution.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.397.1">Then, send commands to the browser that simulate the behavior of a human operator.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.398.1">Finally, after each interaction with the browser, automatic tests should wait so that any JavaScript that was triggered by the interaction completes.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.399.1">Such tests can be executed using browser automatization </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.400.1">tools like </span><strong class="keyWord"><span class="koboSpan" id="kobo.401.1">Selenium,</span></strong><span class="koboSpan" id="kobo.402.1"> which will be discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.403.1">Automating functional tests in C#</span></em><span class="koboSpan" id="kobo.404.1"> section of this chapter.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.405.1">It is worth pointing out that not all user interface tests can be automated since no automatic test can verify how the user interface appears and how usable it is.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.406.1">As we’ve explored the intricacies of functional and subcutaneous testing, it’s become clear that a comprehensive testing strategy must encompass not only how the tests are performed but also how they</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.407.1"> are conceptualized and communicated. </span><span class="koboSpan" id="kobo.407.2">This brings us </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.408.1">to </span><strong class="keyWord"><span class="koboSpan" id="kobo.409.1">Behavior-Driven Development </span></strong><span class="koboSpan" id="kobo.410.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.411.1">BDD</span></strong><span class="koboSpan" id="kobo.412.1">), a methodology that builds upon the principles of functional testing by emphasizing business value and client-side behavior. </span><span class="koboSpan" id="kobo.412.2">BDD offers a structured approach to creating tests that are more closely aligned with user requirements and business objectives.</span></p>
<h1 class="heading-1" id="_idParaDest-187"><span class="koboSpan" id="kobo.413.1">Behavior-Driven Development (BDD)</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.414.1">BDD conforms to the rules of TDD we already described but focuses mainly on business value and client-side behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.415.1">We discussed that the strength of unit tests is </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.416.1">as follows: “It is very unlikely that when describing a behavior in two completely different ways, that is, with code and with examples, we might make exactly the same errors, so errors are discovered with a probability that is close to 100%.”</span></p>
<p class="normal"><span class="koboSpan" id="kobo.417.1">BDD uses the same approach, but the examples used in TDD must not depend on the specific way the functionality might be implemented. </span><span class="koboSpan" id="kobo.417.2">That is, examples must be as close as possible to pure specifications. </span><span class="koboSpan" id="kobo.417.3">This way, we are sure tests can’t influence the way functionality is implemented and vice versa; we are not influenced by pure technical facilities or constraints when writing specifications but focus mainly on the user needs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.418.1">Moreover, tests should use a vocabulary that can be understood by stakeholders. </span><span class="koboSpan" id="kobo.418.2">For these reasons, tests are described by a Given-When-Then syntax. </span><span class="koboSpan" id="kobo.418.3">The following is an example:</span></p>
<pre class="programlisting gen"><code class="hljs"><span class="koboSpan" id="kobo.419.1">Given the first number is 50
And the second number is 70
When the two numbers are added
Then the result should be 120
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">Given</span></code><span class="koboSpan" id="kobo.421.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">And</span></code><span class="koboSpan" id="kobo.423.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">When</span></code><span class="koboSpan" id="kobo.425.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">Then</span></code><span class="koboSpan" id="kobo.427.1"> are keywords, while the remaining text is just natural language containing the example data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.428.1">The Given-When-Then formal</span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.429.1"> language is called Gherkin. </span><span class="koboSpan" id="kobo.429.2">It can be translated into code either manually or with tools that are part of toolsets like Cucumber (</span><a href="https://cucumber.io/"><span class="url"><span class="koboSpan" id="kobo.430.1">https://cucumber.io/</span></span></a><span class="koboSpan" id="kobo.431.1">) or SpecFlow in the </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.432.1">case of .NET projects. </span><span class="koboSpan" id="kobo.432.2">SpecFlow is a Visual Studio extension that can be installed from the Visual Studio </span><strong class="keyWord"><span class="koboSpan" id="kobo.433.1">Extensions</span></strong><span class="koboSpan" id="kobo.434.1"> menu. </span><span class="koboSpan" id="kobo.434.2">Once installed, it adds a new kind of test project, a SpecFlow project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.435.1">In SpecFlow, Given-When-Then</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.436.1"> tests are defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">.feature</span></code><span class="koboSpan" id="kobo.438.1"> files, while natural language clauses contained in the description are transformed into code in the so-called step files. </span><span class="koboSpan" id="kobo.438.2">Step files are automatically created, but the code inside of them must be written by the developer. </span><span class="koboSpan" id="kobo.438.3">Below is the method that is in charge of translating into code the </span><code class="inlineCode"><span class="koboSpan" id="kobo.439.1">"Given the first number is 50"</span></code><span class="koboSpan" id="kobo.440.1"> clause:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.441.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.442.1">Given(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.443.1">"the first number is (.*)"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.444.1">)</span></span><span class="koboSpan" id="kobo.445.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.446.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.448.1">GivenTheFirstNumberIs</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.449.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.450.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.451.1"> number</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.452.1">)</span></span><span class="koboSpan" id="kobo.453.1">
{
     _calculator.FirstNumber = number;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.454.1">The attribute on top of the method is automatically created by SpecFlow, but the (.*) regular expression that extracts the datum from the natural language clause must be written by the developer.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.455.1">_calculator</span></code><span class="koboSpan" id="kobo.456.1"> is a variable that must be created by the developer and that contains a class to test:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.457.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.458.1">readonly</span></span><span class="koboSpan" id="kobo.459.1"> Calculator _calculator = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.460.1">new</span></span><span class="koboSpan" id="kobo.461.1"> Calculator();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.462.1">Once completely defined, SpecFlow tests are run by exploiting an underlying test framework supported by .NET. </span><span class="koboSpan" id="kobo.462.2">The underlying test framework to use is specified when the SpecFlow project is created.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.463.1">While BDD and the Gherkin syntax can be used in unit, integration, and functional tests, the effort of writing tests in natural language and turning them into code is worth it only for functional tests because functional tests must be easily understood by stakeholders.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.464.1">When writing unit tests, the BDD rule of the independence of tests from the implementation improves the tests’ quality and lifetime (fewer tests depend on implementation. </span><span class="koboSpan" id="kobo.464.2">Thus, they need to be updated less frequently). </span><span class="koboSpan" id="kobo.464.3">However, keep in mind that the classes that we are unit testing are themselves the result of implementation choices, so an excessive obsession with test independence might result in a waste of time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.465.1">After having described the theory behind testing, we are ready to move to practical implementations in C#. </span><span class="koboSpan" id="kobo.465.2">In the</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.466.1"> next section, we will list all test projects available in Visual Studio and describe xUnit in detail.</span></p>
<h1 class="heading-1" id="_idParaDest-188"><span class="koboSpan" id="kobo.467.1">Defining C# test projects in Visual Studio</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.468.1">The .NET SDK contains project templates for three types of unit testing frameworks: MSTest, xUnit, and NUnit. </span><span class="koboSpan" id="kobo.468.2">When</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.469.1"> starting the new project wizard in Visual Studio, if you </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.470.1">want to see the compatible versions of these testing frameworks for .NET C# applications, set the </span><strong class="keyWord"><span class="koboSpan" id="kobo.471.1">Project type</span></strong><span class="koboSpan" id="kobo.472.1"> to </span><strong class="keyWord"><span class="koboSpan" id="kobo.473.1">Test</span></strong><span class="koboSpan" id="kobo.474.1">, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.475.1">Language</span></strong><span class="koboSpan" id="kobo.476.1"> to </span><strong class="keyWord"><span class="koboSpan" id="kobo.477.1">C#</span></strong><span class="koboSpan" id="kobo.478.1">, and the </span><strong class="keyWord"><span class="koboSpan" id="kobo.479.1">Platform</span></strong><span class="koboSpan" id="kobo.480.1"> as </span><strong class="keyWord"><span class="koboSpan" id="kobo.481.1">Linux</span></strong><span class="koboSpan" id="kobo.482.1">. </span><span class="koboSpan" id="kobo.482.2">This configuration will allow you to identify and select the appropriate versions of MSTest, xUnit, and NUnit for your project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.483.1">The following screenshot shows the selection that should appear:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.484.1"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="../Images/B19820_09_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.485.1">Figure 9.2: Adding a test project</span></p>
<p class="normal"><span class="koboSpan" id="kobo.486.1">All the preceding projects automatically include the NuGet package for running all the tests in the Visual Studio test user interface (Visual Studio test runner). </span><span class="koboSpan" id="kobo.486.2">However, they do not include any facility for </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.487.1">mocking interfaces, so you need to add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">Moq</span></code><span class="koboSpan" id="kobo.489.1"> NuGet package, which contains a popular mocking framework.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.490.1">All these test projects</span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.491.1"> must contain a reference to the project to be tested.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.492.1">In the next subsection, we will </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.493.1">describe </span><strong class="keyWord"><span class="koboSpan" id="kobo.494.1">xUnit</span></strong><span class="koboSpan" id="kobo.495.1">, but all three frameworks are quite similar and differ mainly in the names of the assert methods and the names of the attributes used to decorate various testing classes and methods.</span></p>
<h2 class="heading-2" id="_idParaDest-189"><span class="koboSpan" id="kobo.496.1">Using the xUnit test framework</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.497.1">In xUnit, tests are methods </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.498.1">decorated with either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">[Fact]</span></code><span class="koboSpan" id="kobo.500.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.501.1">[Theory]</span></code><span class="koboSpan" id="kobo.502.1"> attributes. </span><span class="koboSpan" id="kobo.502.2">Tests are automatically discovered by the test runner, which lists all of them in the user interface so the user can run either all of them or just a selection of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.503.1">A new instance of the test class is created before running each test, so the </span><em class="italic"><span class="koboSpan" id="kobo.504.1">test preparation</span></em><span class="koboSpan" id="kobo.505.1"> code contained in the class constructor is executed before each test of the class. </span><span class="koboSpan" id="kobo.505.2">If you also require </span><em class="italic"><span class="koboSpan" id="kobo.506.1">tear-down code</span></em><span class="koboSpan" id="kobo.507.1">, the test class must implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">IDisposable</span></code><span class="koboSpan" id="kobo.509.1"> interface so that the tear-down code can be included in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">IDisposable.Dispose</span></code><span class="koboSpan" id="kobo.511.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.512.1">The test code invokes the methods to be tested and then tests the results with methods from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">Assert</span></code><span class="koboSpan" id="kobo.514.1"> static class, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">Assert.NotNull(x)</span></code><span class="koboSpan" id="kobo.516.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">Assert.Equal(x, y)</span></code><span class="koboSpan" id="kobo.518.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">Assert.NotEmpty(IEnumerable x)</span></code><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">Some methods verify whether a call throws an exception of a specific type, for instance:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.521.1"> Assert.Throws&lt;MyException&gt;(() =&gt; {</span><span class="hljs-comment"><span class="koboSpan" id="kobo.522.1">/* test code */</span></span><span class="koboSpan" id="kobo.523.1"> ...}).
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.524.1">When an assertion fails, an </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.525.1">exception is thrown. </span><span class="koboSpan" id="kobo.525.2">A test fails if a not-intercepted exception is thrown either by the test code or by an assertion.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.526.1">The following is an example of a method that defines a single test:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.527.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.528.1">Fact</span></span><span class="koboSpan" id="kobo.529.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.530.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.531.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.532.1">Test1</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.533.1">()</span></span><span class="koboSpan" id="kobo.534.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.535.1">var</span></span><span class="koboSpan" id="kobo.536.1"> myInstanceToTest = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.537.1">new</span></span><span class="koboSpan" id="kobo.538.1"> ClassToTest();
    Assert.Equal(</span><span class="hljs-number"><span class="koboSpan" id="kobo.539.1">5</span></span><span class="koboSpan" id="kobo.540.1">, myInstanceToTest.MethodToTest(</span><span class="hljs-number"><span class="koboSpan" id="kobo.541.1">1</span></span><span class="koboSpan" id="kobo.542.1">));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.543.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.544.1">[Fact]</span></code><span class="koboSpan" id="kobo.545.1"> attribute is used when a method defines just one test, while the </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">[Theory]</span></code><span class="koboSpan" id="kobo.547.1"> attribute is used when the same method defines several tests, each on a different tuple of data. </span><span class="koboSpan" id="kobo.547.2">Tuples of data can be specified in several ways and are injected into the test as method parameters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.548.1">The previous code can be modified to test </span><code class="inlineCode"><span class="koboSpan" id="kobo.549.1">MethodToTest</span></code><span class="koboSpan" id="kobo.550.1"> on several inputs as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.551.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.552.1">Theory</span></span><span class="koboSpan" id="kobo.553.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.554.1">InlineData(1, 5)</span></span><span class="koboSpan" id="kobo.555.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.556.1">InlineData(3, 10)</span></span><span class="koboSpan" id="kobo.557.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.558.1">InlineData(5, 20)</span></span><span class="koboSpan" id="kobo.559.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.560.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.561.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.562.1">Test1</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.563.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.564.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.565.1"> testInput, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.566.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.567.1"> testOutput</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.568.1">)</span></span><span class="koboSpan" id="kobo.569.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.570.1">var</span></span><span class="koboSpan" id="kobo.571.1"> myInstanceToTest = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.572.1">new</span></span><span class="koboSpan" id="kobo.573.1"> ClassToTest();
    	 Assert.Equal(testOutput,
        myInstanceToTest.MethodToTest(testInput));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.574.1">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.575.1">InlineData</span></code><span class="koboSpan" id="kobo.576.1"> attribute specifies a tuple to be injected into the method parameters. </span><span class="koboSpan" id="kobo.576.2">Since just simple constant data can be included as attribute arguments, xUnit also gives you the possibility to take all </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.577.1">data tuples from a class that implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">IEnumerable</span></code><span class="koboSpan" id="kobo.579.1">, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.580.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.581.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.582.1">Test1Data</span></span><span class="koboSpan" id="kobo.583.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.584.1">IEnumerable</span></span><span class="koboSpan" id="kobo.585.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.586.1">object</span></span><span class="koboSpan" id="kobo.587.1">[]&gt;
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">public</span></span><span class="koboSpan" id="kobo.589.1"> IEnumerator&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.590.1">object</span></span><span class="koboSpan" id="kobo.591.1">[]&gt; GetEnumerator()
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.592.1">yield</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.593.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.594.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.595.1">object</span></span><span class="koboSpan" id="kobo.596.1">[] { </span><span class="hljs-number"><span class="koboSpan" id="kobo.597.1">1</span></span><span class="koboSpan" id="kobo.598.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.599.1">5</span></span><span class="koboSpan" id="kobo.600.1">};
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">yield</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.602.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.603.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.604.1">object</span></span><span class="koboSpan" id="kobo.605.1">[] { </span><span class="hljs-number"><span class="koboSpan" id="kobo.606.1">3</span></span><span class="koboSpan" id="kobo.607.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.608.1">10</span></span><span class="koboSpan" id="kobo.609.1"> };
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.610.1">yield</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.611.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.612.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.613.1">object</span></span><span class="koboSpan" id="kobo.614.1">[] { </span><span class="hljs-number"><span class="koboSpan" id="kobo.615.1">5</span></span><span class="koboSpan" id="kobo.616.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.617.1">20</span></span><span class="koboSpan" id="kobo.618.1"> };
    }
    IEnumerator IEnumerable.GetEnumerator()=&gt;GetEnumerator();  
}
...
</span><span class="koboSpan" id="kobo.618.2">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.619.1">Theory</span></span><span class="koboSpan" id="kobo.620.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.621.1">ClassData(typeof(Test1Data))</span></span><span class="koboSpan" id="kobo.622.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.623.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.625.1">Test1</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.626.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.627.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.628.1"> testInput, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.629.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.630.1"> testOutput</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.631.1">)</span></span><span class="koboSpan" id="kobo.632.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.633.1">var</span></span><span class="koboSpan" id="kobo.634.1"> myInstanceToTest = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.635.1">new</span></span><span class="koboSpan" id="kobo.636.1"> ClassToTest();
    Assert.Equal(testOutput,
    myInstanceToTest.MethodToTest(testInput));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.637.1">The type of class that provides the test data is specified with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.638.1">ClassData</span></code><span class="koboSpan" id="kobo.639.1"> attribute.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.640.1">It is also possible to take data from a static method of a class that returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.641.1">IEnumerable</span></code><span class="koboSpan" id="kobo.642.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.643.1">MemberData</span></code><span class="koboSpan" id="kobo.644.1"> attribute, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.645.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.646.1">Theory</span></span><span class="koboSpan" id="kobo.647.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.648.1">MemberData(nameof(MyStaticClass.Data),</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.649.1">    MemberType= typeof(MyStaticClass))</span></span><span class="koboSpan" id="kobo.650.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.651.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.652.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.653.1">Test1</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.654.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.655.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.656.1"> testInput, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.657.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.658.1"> testOutput</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.659.1">)</span></span><span class="koboSpan" id="kobo.660.1">
{
    ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.661.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">MemberData</span></code><span class="koboSpan" id="kobo.663.1"> attribute is passed the method name as the first parameter, and the class type in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.664.1">MemberType</span></code><span class="koboSpan" id="kobo.665.1"> named parameter. </span><span class="koboSpan" id="kobo.665.2">If the static method is part of the same test class, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">MemberType</span></code><span class="koboSpan" id="kobo.667.1"> parameter can be omitted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.668.1">The next subsection shows how</span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.669.1"> to deal with some advanced preparation and tear-down scenarios.</span></p>
<h2 class="heading-2" id="_idParaDest-190"><span class="koboSpan" id="kobo.670.1">Advanced test preparation and tear-down scenarios</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.671.1">Sometimes, the preparation </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.672.1">code contains very time-consuming operations, such as opening a connection with a database that doesn’t need to be repeated before each test but that can be executed once before all the tests contained in the same class. </span><span class="koboSpan" id="kobo.672.2">In xUnit, this kind of test preparation code can’t be included in the test class constructor; since a different instance of the test class is created before every single test, it must be factored out in a separate class called a fixture class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.673.1">If we also need corresponding tear-down code, the fixture class must implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">IDisposable</span></code><span class="koboSpan" id="kobo.675.1">. </span><span class="koboSpan" id="kobo.675.2">In other test frameworks, such as NUnit, the test class instances are created just once instead, so they don’t need the fixture code to be factored out in other classes. </span><span class="koboSpan" id="kobo.675.3">However, test frameworks </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.676.1">such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.677.1">NUnit</span></strong><span class="koboSpan" id="kobo.678.1">, which do not create a new instance before each test, may suffer from bugs because of unwanted interactions between test methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.679.1">The following is an example of an xUnit fixture class that opens and closes a database connection:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.680.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.681.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.682.1">DatabaseFixture</span></span><span class="koboSpan" id="kobo.683.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.684.1">IDisposable</span></span><span class="koboSpan" id="kobo.685.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.686.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.687.1">DatabaseFixture</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.688.1">()</span></span><span class="koboSpan" id="kobo.689.1">
    {
        Db = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.690.1">new</span></span><span class="koboSpan" id="kobo.691.1"> SqlConnection(</span><span class="hljs-string"><span class="koboSpan" id="kobo.692.1">"MyConnectionString"</span></span><span class="koboSpan" id="kobo.693.1">);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.694.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.695.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.696.1">Dispose</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.697.1">()</span></span><span class="koboSpan" id="kobo.698.1">
    {
        Db.Close()
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.699.1">public</span></span><span class="koboSpan" id="kobo.700.1"> SqlConnection Db { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.701.1">get</span></span><span class="koboSpan" id="kobo.702.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.703.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.704.1">set</span></span><span class="koboSpan" id="kobo.705.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.706.1">Since a fixture class instance is created just once before all tests associated with the fixture are executed and the same instance is disposed of immediately after the tests, then the database connection is created just once when the fixture class is created and is disposed of immediately after the</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.707.1"> tests when the fixture object is disposed of.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.708.1">The fixture class is associated with each test class by letting the test class implement the empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">IClassFixture&lt;T&gt;</span></code><span class="koboSpan" id="kobo.710.1"> interface as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.711.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.712.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.713.1">MyTestsClass</span></span><span class="koboSpan" id="kobo.714.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.715.1">IClassFixture</span></span><span class="koboSpan" id="kobo.716.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.717.1">DatabaseFixture</span></span><span class="koboSpan" id="kobo.718.1">&gt;
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.719.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.720.1">readonly</span></span><span class="koboSpan" id="kobo.721.1"> DatabaseFixture fixture;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.722.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.723.1">MyDatabaseTests</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.724.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.725.1">DatabaseFixture fixture</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.726.1">)</span></span><span class="koboSpan" id="kobo.727.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.728.1">this</span></span><span class="koboSpan" id="kobo.729.1">.fixture = fixture;
    }
    ...
</span><span class="koboSpan" id="kobo.729.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.730.1">A fixture class instance is automatically injected into the test class constructor in order to make all data computed in the fixture test preparation available for the tests. </span><span class="koboSpan" id="kobo.730.2">This way, for instance, in our previous example, we can get the database connection instance so that all test methods of the class can use it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.731.1">If we want to execute some test preparation code on all tests contained in a collection of test classes instead of a single test class, we must associate the fixture class with an empty class that represents the collection of test classes, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.732.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.733.1">CollectionDefinition(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.734.1">"My Database collection"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.735.1">)</span></span><span class="koboSpan" id="kobo.736.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.738.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.739.1">DatabaseCollection</span></span><span class="koboSpan" id="kobo.740.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.741.1">ICollectionFixture</span></span><span class="koboSpan" id="kobo.742.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.743.1">DatabaseFixture</span></span><span class="koboSpan" id="kobo.744.1">&gt;
{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.745.1">// this class is empty, since it is just a placeholder</span></span><span class="koboSpan" id="kobo.746.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.747.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">CollectionDefinition</span></code><span class="koboSpan" id="kobo.749.1"> attribute declares the name of the collection, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">IClassFixture&lt;T&gt;</span></code><span class="koboSpan" id="kobo.751.1"> interface has been replaced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">ICollectionFixture&lt;T&gt;</span></code><span class="koboSpan" id="kobo.753.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.754.1">Then, we declare that a test class </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.755.1">belongs to the previously defined collection by applying it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">Collection</span></code><span class="koboSpan" id="kobo.757.1"> attribute with the name of the collection, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.758.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.759.1">Collection(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.760.1">"My Database collection"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.761.1">)</span></span><span class="koboSpan" id="kobo.762.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.763.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.764.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.765.1">MyTestsClass</span></span><span class="koboSpan" id="kobo.766.1">
{
    DatabaseFixture fixture;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.768.1">MyDatabaseTests</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.769.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.770.1">DatabaseFixture fixture</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.771.1">)</span></span><span class="koboSpan" id="kobo.772.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.773.1">this</span></span><span class="koboSpan" id="kobo.774.1">.fixture = fixture;
    }
    ...
</span><span class="koboSpan" id="kobo.774.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.775.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">Collection</span></code><span class="koboSpan" id="kobo.777.1"> attribute declares which collection to use, while the </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">DataBaseFixture</span></code><span class="koboSpan" id="kobo.779.1"> argument in the test class constructor provides an actual fixture class instance, so it can be used in all class tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.780.1">Now that we have seen how to leverage fixture classes to share setup and cleanup code across multiple tests, enhancing our test organization and efficiency, we turn our attention to another powerful technique in our testing arsenal. </span><span class="koboSpan" id="kobo.780.2">The following section introduces the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">Moq</span></code><span class="koboSpan" id="kobo.782.1"> framework, a tool that allows us to simulate the behavior of complex dependencies in our tests through mocking. </span><span class="koboSpan" id="kobo.782.2">This approach is crucial for isolating the component we are testing and verifying its behavior under controlled conditions without the need for the actual implementations of its dependencies.</span></p>
<h2 class="heading-2" id="_idParaDest-191"><span class="koboSpan" id="kobo.783.1">Mocking interfaces with Moq</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.784.1">Mocking is a technique used in </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.785.1">both unit testing to isolate classes from dependencies they have on other classes, so we can impute each test failure to the class under test. </span><span class="koboSpan" id="kobo.785.2">Classes</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.786.1"> are isolated from their dependencies by creating a mock or a fake version of each dependency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.787.1">Mocking capabilities are not included in any of the test frameworks we listed in this section, as they are not included in xUnit, so we must add another library that offers mocking capability. </span><span class="koboSpan" id="kobo.787.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.788.1">Moq</span></code><span class="koboSpan" id="kobo.789.1"> framework, a popular tool in .NET, makes the mocking process super-easy.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.790.1">Let’s explore how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">Moq</span></code><span class="koboSpan" id="kobo.792.1"> to create mocks and set up our tests effectively. </span><span class="koboSpan" id="kobo.792.2">Here, we will discuss just how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.793.1">Moq</span></code><span class="koboSpan" id="kobo.794.1"> to create mock classes. </span><span class="koboSpan" id="kobo.794.2">A practical and complete example that shows how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.795.1">Moq</span></code><span class="koboSpan" id="kobo.796.1"> in </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.797.1">your tests in practice is in the </span><em class="italic"><span class="koboSpan" id="kobo.798.1">Testing the WWTravelClub application </span></em><span class="koboSpan" id="kobo.799.1">section of </span><em class="chapterRef"><span class="koboSpan" id="kobo.800.1">Chapter 21</span></em><span class="koboSpan" id="kobo.801.1">, </span><em class="italic"><span class="koboSpan" id="kobo.802.1">Case Study</span></em><span class="koboSpan" id="kobo.803.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.804.1">As a first step, we need to install the </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">Moq</span></code><span class="koboSpan" id="kobo.806.1"> NuGet package. </span><span class="koboSpan" id="kobo.806.2">Then, we need to add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">using Moq</span></code><span class="koboSpan" id="kobo.808.1"> statement to our test files. </span><span class="koboSpan" id="kobo.808.2">A mock implementation is easily defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.809.1">var</span></span><span class="koboSpan" id="kobo.810.1"> myMockDependency = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.811.1">new</span></span><span class="koboSpan" id="kobo.812.1"> Mock&lt;IMyInterface&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.813.1">The behavior of the mock dependency</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.814.1"> on specific inputs of the specific method can be defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.815.1">Setup/Return</span></code><span class="koboSpan" id="kobo.816.1"> method pair as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.817.1">myMockDependency.Setup(x=&gt;x.MyMethod(</span><span class="hljs-number"><span class="koboSpan" id="kobo.818.1">5</span></span><span class="koboSpan" id="kobo.819.1">)).Returns(</span><span class="hljs-number"><span class="koboSpan" id="kobo.820.1">10</span></span><span class="koboSpan" id="kobo.821.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.822.1">We can add several </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">Setup/Return</span></code><span class="koboSpan" id="kobo.824.1"> instructions for the same method. </span><span class="koboSpan" id="kobo.824.2">This way, we can specify an indefinite number of input/output behaviors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.825.1">Instead of specific input values, we may also use wildcards that match a specific type as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.826.1">myMockDependency.Setup(x =&gt; x.MyMethod(It.IsAny&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.827.1">int</span></span><span class="koboSpan" id="kobo.828.1">&gt;()))
                  .Returns(</span><span class="hljs-number"><span class="koboSpan" id="kobo.829.1">10</span></span><span class="koboSpan" id="kobo.830.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.831.1">Where we replaced </span><code class="inlineCode"><span class="koboSpan" id="kobo.832.1">5</span></code><span class="koboSpan" id="kobo.833.1"> with its type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.834.1">int</span></code><span class="koboSpan" id="kobo.835.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.836.1">Once we have configured the mock dependency, we may extract the mocked instance from its </span><code class="inlineCode"><span class="koboSpan" id="kobo.837.1">Object</span></code><span class="koboSpan" id="kobo.838.1"> property and use it as if it were an actual implementation, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.839.1">var</span></span><span class="koboSpan" id="kobo.840.1"> myMockedInstance=myMockDependency.Object;
...
</span><span class="koboSpan" id="kobo.840.2">myMockedInstance.MyMethod(</span><span class="hljs-number"><span class="koboSpan" id="kobo.841.1">10</span></span><span class="koboSpan" id="kobo.842.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.843.1">However, mocked methods are usually called by the code under test, so we just need to extract the mocked instance and use it as an input in our tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.844.1">We may also mock properties and </span><strong class="keyWord"><span class="koboSpan" id="kobo.845.1">async</span></strong><span class="koboSpan" id="kobo.846.1"> methods as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.847.1">myMockDependency.Setup(x =&gt; x.MyProperty)
                  .Returns(</span><span class="hljs-number"><span class="koboSpan" id="kobo.848.1">42</span></span><span class="koboSpan" id="kobo.849.1">);
...
</span><span class="koboSpan" id="kobo.849.2">myMockDependency.Setup(x =&gt; x.MyMethodAsync(</span><span class="hljs-number"><span class="koboSpan" id="kobo.850.1">1</span></span><span class="koboSpan" id="kobo.851.1">))
                    .ReturnsAsync(</span><span class="hljs-string"><span class="koboSpan" id="kobo.852.1">"aasas"</span></span><span class="koboSpan" id="kobo.853.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.854.1">var</span></span><span class="koboSpan" id="kobo.855.1"> res=</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.856.1">await</span></span><span class="koboSpan" id="kobo.857.1"> myMockDependency.Object
    .MyMethodAsync(</span><span class="hljs-number"><span class="koboSpan" id="kobo.858.1">1</span></span><span class="koboSpan" id="kobo.859.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.860.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">async</span></code><span class="koboSpan" id="kobo.862.1"> methods, </span><code class="inlineCode"><span class="koboSpan" id="kobo.863.1">Returns</span></code><span class="koboSpan" id="kobo.864.1"> must be replaced by </span><code class="inlineCode"><span class="koboSpan" id="kobo.865.1">ReturnsAsync</span></code><span class="koboSpan" id="kobo.866.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.867.1">Each mocked instance records all calls to its methods and properties, so we may use this information in our tests. </span><span class="koboSpan" id="kobo.867.2">The</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.868.1"> following code shows an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.869.1">myMockDependency.Verify(x =&gt; x.MyMethod(</span><span class="hljs-number"><span class="koboSpan" id="kobo.870.1">1</span></span><span class="koboSpan" id="kobo.871.1">), Times.AtLeast(</span><span class="hljs-number"><span class="koboSpan" id="kobo.872.1">2</span></span><span class="koboSpan" id="kobo.873.1">));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.874.1">The preceding statement asserts</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.875.1"> that </span><code class="inlineCode"><span class="koboSpan" id="kobo.876.1">MyMethod</span></code><span class="koboSpan" id="kobo.877.1"> has been invoked with the given arguments at least twice. </span><span class="koboSpan" id="kobo.877.2">There are also </span><code class="inlineCode"><span class="koboSpan" id="kobo.878.1">Times.Never</span></code><span class="koboSpan" id="kobo.879.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.880.1">Times.Once</span></code><span class="koboSpan" id="kobo.881.1"> (which asserts that the method was called just once), and more.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.882.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.883.1">Moq</span></code><span class="koboSpan" id="kobo.884.1"> documentation summarized up to now should cover 99% of the needs that may arise in your tests, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.885.1">Moq</span></code><span class="koboSpan" id="kobo.886.1"> also offers more complex options. </span><span class="koboSpan" id="kobo.886.2">The </span><em class="italic"><span class="koboSpan" id="kobo.887.1">Further reading</span></em><span class="koboSpan" id="kobo.888.1"> section contains the link to the complete documentation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.889.1">The </span><em class="italic"><span class="koboSpan" id="kobo.890.1">Testing the WWTravelClub application</span></em><span class="koboSpan" id="kobo.891.1"> section of </span><em class="chapterRef"><span class="koboSpan" id="kobo.892.1">Chapter 21</span></em><span class="koboSpan" id="kobo.893.1">, </span><em class="italic"><span class="koboSpan" id="kobo.894.1">Case Study</span></em><span class="koboSpan" id="kobo.895.1">, shows the practical usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.896.1">Moq</span></code><span class="koboSpan" id="kobo.897.1"> in a complex example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.898.1">After exploring the capabilities of </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">Moq</span></code><span class="koboSpan" id="kobo.900.1"> and how it enhances our unit testing with effective mock implementations, we now turn our attention to a different facet of C# application testing – automating functional tests in ASP.NET Core applications. </span><span class="koboSpan" id="kobo.900.2">In this next section, we’ll dive into how various testing tools and techniques, including some we’ve just discussed, are applied to ensure our ASP.NET Core applications function as intended, both in isolation and when integrated with other systems and interfaces.</span></p>
<h1 class="heading-1" id="_idParaDest-192"><span class="koboSpan" id="kobo.901.1">Automating functional tests in C#</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.902.1">Automated functional tests use</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.903.1"> the same test tools as unit and integration tests. </span><span class="koboSpan" id="kobo.903.2">That is, these tests can be embedded in the same xUnit, NUnit, or MSTest projects that we described in the previous section. </span><span class="koboSpan" id="kobo.903.3">However, in this case, we must add further tools that can</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.904.1"> interact with and inspect the UI.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.905.1">In the remainder of this chapter, we will focus on web applications since they are the main focus of this book. </span><span class="koboSpan" id="kobo.905.2">Accordingly, if we are testing web APIs, we just need </span><code class="inlineCode"><span class="koboSpan" id="kobo.906.1">HttpClient</span></code><span class="koboSpan" id="kobo.907.1"> instances since they can easily interact with web API endpoints in both XML and JSON.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.908.1">In the case of applications that return HTML pages, the interaction is more complex since we also need tools for parsing and interacting with the HTML page DOM tree.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.909.1">The </span><em class="italic"><span class="koboSpan" id="kobo.910.1">Selenium</span></em><span class="koboSpan" id="kobo.911.1"> toolset is a great solution since it has drivers for simulating user interaction in all mainstream </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.912.1">browsers and for programmatically accessing the browser DOM.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.913.1">There are two basic options for testing a web application with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">HttpClient</span></code><span class="koboSpan" id="kobo.915.1"> class:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.916.1">Staging application</span></strong><span class="koboSpan" id="kobo.917.1">: An </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">HttpClient</span></code><span class="koboSpan" id="kobo.919.1"> instance connects with the actual </span><em class="italic"><span class="koboSpan" id="kobo.920.1">staging</span></em><span class="koboSpan" id="kobo.921.1"> web application through the internet/intranet, together with all other humans who are beta-testing the software. </span><span class="koboSpan" id="kobo.921.2">The advantage of this approach is that you are testing the </span><em class="italic"><span class="koboSpan" id="kobo.922.1">real stuff</span></em><span class="koboSpan" id="kobo.923.1">, but tests</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.924.1"> are more difficult to conceive since you can’t control the initial state of the application before each test.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.925.1">Controlled application</span></strong><span class="koboSpan" id="kobo.926.1">: An </span><code class="inlineCode"><span class="koboSpan" id="kobo.927.1">HttpClient</span></code><span class="koboSpan" id="kobo.928.1"> instance connects with a local application that is configured, initialized, and launched before every single test. </span><span class="koboSpan" id="kobo.928.2">This scenario is completely analogous to the unit test scenario. </span><span class="koboSpan" id="kobo.928.3">Test results are reproducible, the initial state before each test is fixed, tests are easier to design, and the actual database can be</span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.929.1"> replaced by a faster and easier-to-initialize in-memory database. </span><span class="koboSpan" id="kobo.929.2">However, in this</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.930.1"> case, you are far from the actual system’s operation.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.931.1">A good strategy is to use a </span><strong class="keyWord"><span class="koboSpan" id="kobo.932.1">controlled application</span></strong><span class="koboSpan" id="kobo.933.1">, where you have full control of the initial state, for testing the extreme cases, and then use a </span><strong class="keyWord"><span class="koboSpan" id="kobo.934.1">staging application</span></strong><span class="koboSpan" id="kobo.935.1"> for testing random average cases on the </span><em class="italic"><span class="koboSpan" id="kobo.936.1">real stuff</span></em><span class="koboSpan" id="kobo.937.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.938.1">The two subsections that follow describe both approaches. </span><span class="koboSpan" id="kobo.938.2">The two approaches differ only in the way that you define the fixtures of your tests.</span></p>
<h2 class="heading-2" id="_idParaDest-193"><span class="koboSpan" id="kobo.939.1">Testing the staging application</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.940.1">In the case of staging </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.941.1">applications, your tests just need a class that can issue HTTP requests, which in the case of .NET is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.942.1">HttpClient</span></code><span class="koboSpan" id="kobo.943.1"> class. </span><span class="koboSpan" id="kobo.943.2">It is enough to define an efficient fixture that supplies the needed </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">HttpClient</span></code><span class="koboSpan" id="kobo.945.1"> instances, avoiding the risk of running out of operating system connections. </span><span class="koboSpan" id="kobo.945.2">Efficient management of the underlying operating system connections can be achieved through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">IHttpClientFactory</span></code><span class="koboSpan" id="kobo.947.1"> interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.948.1">It is enough to add an </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">HttpClient</span></code><span class="koboSpan" id="kobo.950.1"> management factory to a dependency injection container that will be used by the tests with:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.951.1">services.AddHttpClient(),
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.952.1">where the </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">AddHttpClient</span></code><span class="koboSpan" id="kobo.954.1"> extension belongs to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">Microsoft.Extensions.DependencyInjection</span></code><span class="koboSpan" id="kobo.956.1"> namespace and is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">Microsoft.Extensions.Http</span></code><span class="koboSpan" id="kobo.958.1"> NuGet package. </span><span class="koboSpan" id="kobo.958.2">Therefore, our test fixture must create a dependency injection container, call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.959.1">AddHttpClient</span></code><span class="koboSpan" id="kobo.960.1"> extension method, and finally build the container. </span><span class="koboSpan" id="kobo.960.2">The </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.961.1">following fixture class does this job:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.962.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.963.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.964.1">HttpClientFixture</span></span><span class="koboSpan" id="kobo.965.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.966.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.967.1">HttpClientFixture</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.968.1">()</span></span><span class="koboSpan" id="kobo.969.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.970.1">var</span></span><span class="koboSpan" id="kobo.971.1"> serviceCollection = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.972.1">new</span></span><span class="koboSpan" id="kobo.973.1"> ServiceCollection();
        serviceCollection
            .AddHttpClient();
         ServiceProvider = serviceCollection.BuildServiceProvider();
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.974.1">public</span></span><span class="koboSpan" id="kobo.975.1"> ServiceProvider ServiceProvider { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.976.1">get</span></span><span class="koboSpan" id="kobo.977.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.978.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.979.1">set</span></span><span class="koboSpan" id="kobo.980.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.981.1">After the preceding definition, your tests should look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.982.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.983.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.984.1">MyUnitTestClass</span></span><span class="koboSpan" id="kobo.985.1">:</span><span class="hljs-title"><span class="koboSpan" id="kobo.986.1">IClassFixture</span></span><span class="koboSpan" id="kobo.987.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.988.1">HttpClientFixture</span></span><span class="koboSpan" id="kobo.989.1">&gt;
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.990.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">readonly</span></span><span class="koboSpan" id="kobo.992.1"> ServiceProvider _serviceProvider;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.993.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.994.1">UnitTest1</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.995.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.996.1">HttpClientFixture fixture</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.997.1">)</span></span><span class="koboSpan" id="kobo.998.1">
    {
        _serviceProvider = fixture.ServiceProvider;
    }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.999.1">Fact</span></span><span class="koboSpan" id="kobo.1000.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1001.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1002.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1003.1">MyTest</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1004.1">()</span></span><span class="koboSpan" id="kobo.1005.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1006.1">var</span></span><span class="koboSpan" id="kobo.1007.1"> factory =
            _serviceProvider.GetService&lt;IHttpClientFactory&gt;())
       
            HttpClient client = factory.CreateClient();
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1008.1">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">Test1</span></code><span class="koboSpan" id="kobo.1010.1">, once you get an HTTP client, you can test the application by issuing an HTTP request and then by analyzing the response returned by the application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1011.1">The approach described above is adequate when the HTTP endpoints return data, for instance, in JSON format that can be turned into .NET data by a data serializer/deserializer and </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.1012.1">then compared with the expected data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1013.1">The next subsection describes how to test endpoints that return HTML.</span></p>
<h2 class="heading-2" id="_idParaDest-194"><span class="koboSpan" id="kobo.1014.1">Testing the staging application with Selenium</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1015.1">Most endpoints that return HTML are tested either</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.1016.1"> manually or with playback tools, like Selenium IDE, on various browsers. </span><span class="koboSpan" id="kobo.1016.2">Playback tools record all user actions</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.1017.1"> performed on an actual browser and generate code that repeats the same action sequences with the help of browser drivers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1018.1">However, the code generated by playback tools is too sensitive to the DOM structure of each page, so most of the tests must be replaced after each relevant change in the user interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1019.1">Therefore, the code of important and stable UI tests is better created manually in a way that is more robust to DOM changes. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1020.1">For this purpose, the Selenium toolset contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1021.1">Selenium.WebDriver</span></code><span class="koboSpan" id="kobo.1022.1"> NuGet package and a driver for each browser that you would like to adopt, such as, for instance, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1023.1">Selenium.WebDriver.ChromeDriver</span></code><span class="koboSpan" id="kobo.1024.1"> NuGet package for the Chrome browser.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1025.1">Manual tests based on Selenium WebDriver look like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1026.1">using</span></span><span class="koboSpan" id="kobo.1027.1"> OpenQA.Selenium;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1028.1">using</span></span><span class="koboSpan" id="kobo.1029.1"> OpenQA.Selenium.ChromeDriver;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1030.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1031.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1032.1">MyUnitTestClass</span></span><span class="koboSpan" id="kobo.1033.1">:</span><span class="hljs-title"><span class="koboSpan" id="kobo.1034.1">IClassFixture</span></span><span class="koboSpan" id="kobo.1035.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1036.1">HttpClientFixture</span></span><span class="koboSpan" id="kobo.1037.1">&gt;
{
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1038.1">Fact</span></span><span class="koboSpan" id="kobo.1039.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1040.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1041.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1042.1">MyTest</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1043.1">()</span></span><span class="koboSpan" id="kobo.1044.1">
    {
        Using (IWebDriver driver = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1045.1">new</span></span><span class="koboSpan" id="kobo.1046.1"> ChromeDriver())
        {
            driver.Navigate().GoToUrl(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1047.1">"https://localhost:5001/mypage"</span></span><span class="koboSpan" id="kobo.1048.1">);
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1049.1">//use driver to interact with the loaded page here</span></span><span class="koboSpan" id="kobo.1050.1">
            ...
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1051.1">var</span></span><span class="koboSpan" id="kobo.1052.1"> title = driver.Title;
           Assert().Equal(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1053.1">"My Application – My Page"</span></span><span class="koboSpan" id="kobo.1054.1">, title);
           ...
	   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1055.1">var</span></span><span class="koboSpan" id="kobo.1056.1"> submitButton =
		driver.FindElement(By.ClassName(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1057.1">"confirm-changes"</span></span><span class="koboSpan" id="kobo.1058.1">));
 	   submitButton.Clikck();
 	   ...
       </span><span class="koboSpan" id="kobo.1058.2">}
       
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1059.1">Once the page to test has been loaded, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">driver</span></code><span class="koboSpan" id="kobo.1061.1"> is used to explore the page content and to interact with page elements, like buttons, links, and input fields. </span><span class="koboSpan" id="kobo.1061.2">As shown in the preceding code, the syntax for </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.1062.1">interacting with the browser is quite simple and intuitive. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1063.1">driver.FindElement</span></code><span class="koboSpan" id="kobo.1064.1"> can find </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.1065.1">elements by CSS class name, by ID, and also through generic CSS selectors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1066.1">Adding CSS classes that characterize their role with HTML elements is a good technique for building robust UI tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1067.1">The next subsection explains how to test an application that runs in a controlled environment.</span></p>
<h2 class="heading-2" id="_idParaDest-195"><span class="koboSpan" id="kobo.1068.1">Testing a controlled application</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1069.1">In this case, we create an ASP.NET Core server </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.1070.1">within the test application and test it with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">HttpClient</span></code><span class="koboSpan" id="kobo.1072.1"> instance. </span><span class="koboSpan" id="kobo.1072.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">Microsoft.AspNetCore.Mvc.Testing</span></code><span class="koboSpan" id="kobo.1074.1"> NuGet package contains all that we need to create both an HTTP client and the server running the application.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">Microsoft.AspNetCore.Mvc.Testing</span></code><span class="koboSpan" id="kobo.1076.1"> contains a fixture class that does the job of launching a local web server and furnishing a client to interact with it. </span><span class="koboSpan" id="kobo.1076.2">The predefined fixture class is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">WebApplicationFactory&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1078.1">. </span><span class="koboSpan" id="kobo.1078.2">The generic </span><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">T</span></code><span class="koboSpan" id="kobo.1080.1"> argument must be instantiated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1081.1">Program</span></code><span class="koboSpan" id="kobo.1082.1"> class of your web project, that is, with an entry point for the web application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1083.1">Tests look like the following class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1084.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1085.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1086.1">MynitTest</span></span><span class="koboSpan" id="kobo.1087.1">
    : </span><span class="hljs-title"><span class="koboSpan" id="kobo.1088.1">IClassFixture</span></span><span class="koboSpan" id="kobo.1089.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1090.1">WebApplicationFactory</span></span><span class="koboSpan" id="kobo.1091.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1092.1">MyProject.Program</span></span><span class="koboSpan" id="kobo.1093.1">&gt;&gt;
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1094.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1095.1">readonly</span></span><span class="koboSpan" id="kobo.1096.1">
        WebApplicationFactory&lt;MyProject.Program&gt; _factory;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1097.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1098.1">UnitTest1</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1099.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1100.1">WebApplicationFactory&lt;MyProject.Program&gt; factory</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1101.1">)</span></span><span class="koboSpan" id="kobo.1102.1">
    {
        _factory = factory;
    }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1103.1">Theory</span></span><span class="koboSpan" id="kobo.1104.1">]
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1105.1">InlineData(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1106.1">"/"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1107.1">)</span></span><span class="koboSpan" id="kobo.1108.1">]
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1109.1">InlineData(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1110.1">"/Index"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1111.1">)</span></span><span class="koboSpan" id="kobo.1112.1">]
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1113.1">InlineData(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1114.1">"/About"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1115.1">)</span></span><span class="koboSpan" id="kobo.1116.1">]
    ....
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1117.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1118.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1119.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1120.1">MustReturnOK</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1121.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1122.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1123.1"> url</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1124.1">)</span></span><span class="koboSpan" id="kobo.1125.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1126.1">var</span></span><span class="koboSpan" id="kobo.1127.1"> client = _factory.CreateClient();
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1128.1">// here both client and server are ready</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1129.1">var</span></span><span class="koboSpan" id="kobo.1130.1"> response = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1131.1">await</span></span><span class="koboSpan" id="kobo.1132.1"> client.GetAsync(url);
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1133.1">//get the response</span></span><span class="koboSpan" id="kobo.1134.1">
        response.EnsureSuccessStatusCode();
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1135.1">// verify we got a success return code.</span></span><span class="koboSpan" id="kobo.1136.1">
    }
    ...
    </span><span class="koboSpan" id="kobo.1136.2">---
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1137.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1138.1">Program</span></code><span class="koboSpan" id="kobo.1139.1"> class must exist and</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.1140.1"> must be defined as public. </span><span class="koboSpan" id="kobo.1140.2">Otherwise, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1141.1">WebApplicationFactory</span></code><span class="koboSpan" id="kobo.1142.1"> has no entry point for starting the application. </span><span class="koboSpan" id="kobo.1142.2">Therefore, if the code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1143.1">Program.cs</span></code><span class="koboSpan" id="kobo.1144.1"> is not enclosed in a public class, as in the default project scaffolded by Visual Studio, you must turn the internal </span><code class="inlineCode"><span class="koboSpan" id="kobo.1145.1">Program</span></code><span class="koboSpan" id="kobo.1146.1"> class automatically generated by the C# compile into a public class. </span><span class="koboSpan" id="kobo.1146.2">This is easily achieved by adding the following code at the end of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1147.1">Program.cs</span></code><span class="koboSpan" id="kobo.1148.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1149.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1150.1">partial</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1151.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1152.1">Program</span></span><span class="koboSpan" id="kobo.1153.1"> { }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1154.1">If you want to analyze the HTML of the returned pages, you must also reference </span><strong class="keyWord"><span class="koboSpan" id="kobo.1155.1">Selenium</span></strong><span class="koboSpan" id="kobo.1156.1"> NuGet packages, as shown in the previous subsection. </span><span class="koboSpan" id="kobo.1156.2">We will see how to use them in the example in the next section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1157.1">The simplest way to cope with databases in this type of test is to replace them with in-memory databases that are faster and automatically cleared whenever the local server is shut down and restarted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1158.1">Unfortunately, in-memory databases are </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.1159.1">not 100% compatible with the actual database used, so some tests might fail. </span><span class="koboSpan" id="kobo.1159.2">Therefore, at least some of the tests might require the actual database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1160.1">When performing tests with actual databases, we must also add all the required instructions to clear or recreate from scratch a standard database in the constructor of a custom fixture that inherits from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1161.1">WebApplicationFactory&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1162.1">. </span><span class="koboSpan" id="kobo.1162.2">Note that deleting all database data is not as easy as it might appear, owing to integrity constraints. </span><span class="koboSpan" id="kobo.1162.3">You have various options, but none is the best for all cases:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1163.1">Delete the whole database and recreate it using SQL scripts or Entity Framework Core migrations, which will be analyzed in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1164.1">Chapter 13</span></em><span class="koboSpan" id="kobo.1165.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1166.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.1167.1">. </span><span class="koboSpan" id="kobo.1167.2">This always works, but it is slow and requires a database user with high privileges.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1168.1">Enclose a test database in a Docker image and recreate a new container at each new test (Docker will be discussed in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1169.1">Chapter 11</span></em><span class="koboSpan" id="kobo.1170.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1171.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.1172.1">). </span><span class="koboSpan" id="kobo.1172.2">This is faster than recreating a new database from scratch but still slow.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1173.1">Disable the database constraints and then clear all tables in any order. </span><span class="koboSpan" id="kobo.1173.2">This technique sometimes doesn’t work and requires a database user with high privileges.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1174.1">Delete all data in the right order, thus without violating all database constraints. </span><span class="koboSpan" id="kobo.1174.2">This is not difficult if you keep an ordered delete list of all tables while the database grows and you add tables to the database. </span><span class="koboSpan" id="kobo.1174.3">This delete list is a useful resource that you may also use to fix issues in database update operations and to remove old entries during production database maintenance. </span><span class="koboSpan" id="kobo.1174.4">Unfortunately, this method also fails in the rare case of circular dependencies, such as a table that has a foreign key referring to itself.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1175.1">I prefer method 4 and revert to method 3 only in the rare case of difficulties due to circular dependencies.</span></p>
<h2 class="heading-2" id="_idParaDest-196"><span class="koboSpan" id="kobo.1176.1">Recording tests with Selenium IDE</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1177.1">The Selenium toolset contains browser extensions for recording and replaying browser tests. </span><span class="koboSpan" id="kobo.1177.2">These are called Selenium IDE. </span><span class="koboSpan" id="kobo.1177.3">You can </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.1178.1">download the extensions for Chrome and Firefox from </span><a href="https://www.selenium.dev/selenium-ide/"><span class="url"><span class="koboSpan" id="kobo.1179.1">https://www.selenium.dev/selenium-ide/</span></span></a><span class="koboSpan" id="kobo.1180.1">, while the</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.1181.1"> extension for Microsoft Edge is available from </span><a href="https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp"><span class="url"><span class="koboSpan" id="kobo.1182.1">https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp</span></span></a><span class="koboSpan" id="kobo.1183.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1184.1">In Chrome, once installed, Selenium IDE can be run by clicking the extensions icon and then selecting the Selenium extension from the menu that appears, as shown in the screenshot below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1185.1"><img alt="" role="presentation" src="../Images/B19820_09_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1186.1">Figure 9.3: Running Selenium IDE</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1187.1">You are prompted for the action you would like to perform, whether to create a new project, access an existing project, etc.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1188.1">When you create a new project, you are prompted for the project name. </span><span class="koboSpan" id="kobo.1188.2">At this point, Selenium IDE opens, and you can insert the application URL.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1189.1">New tests can be created by clicking the plus button next to the tests list.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1190.1">In order to record a test, select the test name and then click the record icon. </span><span class="koboSpan" id="kobo.1190.2">A new browser window will open with the application URL. </span><span class="koboSpan" id="kobo.1190.3">From this point, every action you perform on the application and its results will be recorded.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1191.1">You can make assertions on the page content by right-clicking on a page element and selecting the appropriate action from</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.1192.1"> the </span><strong class="screenText"><span class="koboSpan" id="kobo.1193.1">Selenium</span></strong> <strong class="screenText"><span class="koboSpan" id="kobo.1194.1">IDE &gt; Assert</span></strong><span class="koboSpan" id="kobo.1195.1"> submenu. </span><span class="koboSpan" id="kobo.1195.2">For instance, if you select the </span><strong class="screenText"><span class="koboSpan" id="kobo.1196.1">Selenium IDE &gt; Assert &gt; Text</span></strong><span class="koboSpan" id="kobo.1197.1"> command on a text element, the text value will be stored. </span><span class="koboSpan" id="kobo.1197.2">When the test is executed, the content of the same text element will be compared with the previously stored value, and the test will fail if the two values are different.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1198.1">Once all desired actions and assertions have been performed, return to the Selenium IDE window, click the stop recording button, and save the project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1199.1">Selenium IDE offers the option to run either a selected test or all tests.</span></p>
<h1 class="heading-1" id="_idParaDest-197"><span class="koboSpan" id="kobo.1200.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1201.1">In this chapter, we explained why it is worth automating software tests, and then we focused on the importance of unit tests. </span><span class="koboSpan" id="kobo.1201.2">We also listed the various types of tests and their main features, focusing mainly on unit tests and functional tests. </span><span class="koboSpan" id="kobo.1201.3">We analyzed the advantages of </span><strong class="keyWord"><span class="koboSpan" id="kobo.1202.1">TDD</span></strong><span class="koboSpan" id="kobo.1203.1"> and how to use it in practice. </span><span class="koboSpan" id="kobo.1203.2">With this knowledge, you should be able to produce software that is both reliable and easy to modify.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1204.1">Then, this chapter analyzed when it is worth automating some or all functional tests and described how to automate them in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1205.1">ASP.NET </span></code><span class="koboSpan" id="kobo.1206.1">Core applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1207.1">Finally, we analyzed the main test tools available for .NET projects, focusing on xUnit, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1208.1">Moq</span></code><span class="koboSpan" id="kobo.1209.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1210.1">Microsoft.AspNetCore.Mvc.Testing</span></code><span class="koboSpan" id="kobo.1211.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.1212.1">Selenium</span></em><span class="koboSpan" id="kobo.1213.1">, and showed how to use them in practice with the help of the book’s use case.</span></p>
<p class="normal"><em class="chapterRef"><span class="koboSpan" id="kobo.1214.1">Chapter 21</span></em><span class="koboSpan" id="kobo.1215.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1216.1">Case Study</span></em><span class="koboSpan" id="kobo.1217.1">, applies all the test concepts described in this chapter to the book’s case study.</span></p>
<h1 class="heading-1" id="_idParaDest-198"><span class="koboSpan" id="kobo.1218.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1219.1">Why is it worth automating unit tests?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1220.1">What is the main reason why TDD is able to discover most bugs immediately?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1221.1">What is the difference between the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1222.1">[Theory]</span></code><span class="koboSpan" id="kobo.1223.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1224.1">[Fact]</span></code><span class="koboSpan" id="kobo.1225.1"> attributes of xUnit?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1226.1">Which xUnit static class is used in test assertions?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1227.1">Which methods allow the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1228.1">Moq</span></code><span class="koboSpan" id="kobo.1229.1"> mocked dependencies?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1230.1">Is it possible to mock </span><code class="inlineCode"><span class="koboSpan" id="kobo.1231.1">async</span></code><span class="koboSpan" id="kobo.1232.1"> methods with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1233.1">Moq</span></code><span class="koboSpan" id="kobo.1234.1">? </span><span class="koboSpan" id="kobo.1234.2">If so, how?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1235.1">Is it always worth automating UI functional tests in the case of quick CI/CD cycles?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1236.1">What is the disadvantage of subcutaneous tests for ASP.NET Core applications?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1237.1">What is the suggested technique for writing code-driven ASP.NET Core functional tests?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1238.1">What is the suggested way of inspecting the HTML returned by a server?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-199"><span class="koboSpan" id="kobo.1239.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1240.1">While the documentation on xUnit included in this chapter is quite complete, it doesn’t include a few configuration options offered by xUnit. </span><span class="koboSpan" id="kobo.1240.2">The full xUnit documentation is available at </span><a href="https://xunit.net/"><span class="url"><span class="koboSpan" id="kobo.1241.1">https://xunit.net/</span></span></a><span class="koboSpan" id="kobo.1242.1">. </span><span class="koboSpan" id="kobo.1242.2">Documentation for MSTest and NUnit can be found at </span><a href="https://github.com/microsoft/testfx"><span class="url"><span class="koboSpan" id="kobo.1243.1">https://github.com/microsoft/testfx</span></span></a><span class="koboSpan" id="kobo.1244.1"> and </span><a href="https://docs.nunit.org/"><span class="url"><span class="koboSpan" id="kobo.1245.1">https://docs.nunit.org/</span></span></a><span class="koboSpan" id="kobo.1246.1">, respectively.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1247.1">For more information on BDD and SpecFlow, refer to the Cucumber official website at </span><a href="https://cucumber.io/"><span class="url"><span class="koboSpan" id="kobo.1248.1">https://cucumber.io/</span></span></a><span class="koboSpan" id="kobo.1249.1"> and to the SpecFlow documentation at </span><a href="https://docs.specflow.org/"><span class="url"><span class="koboSpan" id="kobo.1250.1">https://docs.specflow.org/</span></span></a><span class="koboSpan" id="kobo.1251.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1252.1">The full Moq documentation is available at </span><a href="https://github.com/moq/moq4/wiki/Quickstart"><span class="url"><span class="koboSpan" id="kobo.1253.1">https://github.com/moq/moq4/wiki/Quickstart</span></span></a><span class="koboSpan" id="kobo.1254.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1255.1">Here are some links to performance test frameworks for web applications:</span><ul>
<li class="bulletList"><a href="https://jmeter.apache.org/"><span class="url"><span class="koboSpan" id="kobo.1256.1">https://jmeter.apache.org/ (free and open source)</span></span></a></li>
<li class="bulletList"><a href="https://www.neotys.com/neoload/overview"><span class="url"><span class="koboSpan" id="kobo.1257.1">https://www.neotys.com/neoload/overview</span></span></a></li>
<li class="bulletList"><a href="https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview"><span class="url"><span class="koboSpan" id="kobo.1258.1">https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview</span></span></a></li>
</ul>
</li>
<li class="bulletList"><a href="https://www.microfocus.com/en-us/products/silk-performer/overview"><span class="url"><span class="koboSpan" id="kobo.1259.1">https://www.microfocus.com/en-us/products/silk-performer/overview</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1260.1">More details on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1261.1">Microsoft.AspNetCore.Mvc.Testing NuGet</span></code><span class="koboSpan" id="kobo.1262.1"> package can be found in the official documentation at </span><a href="https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests"><span class="url"><span class="koboSpan" id="kobo.1263.1">https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests</span></span></a><span class="koboSpan" id="kobo.1264.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1265.1">More information on Selenium IDE can be found on the official website: </span><a href="https://www.selenium.dev/selenium-ide/"><span class="url"><span class="koboSpan" id="kobo.1266.1">https://www.selenium.dev/selenium-ide/</span></span></a><span class="koboSpan" id="kobo.1267.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1268.1">More information on Selenium WebDriver can be found on the official website: </span><a href="https://www.selenium.dev/documentation/webdriver/"><span class="url"><span class="koboSpan" id="kobo.1269.1">https://www.selenium.dev/documentation/webdriver/</span></span></a><span class="koboSpan" id="kobo.1270.1">.</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1271.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1272.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.1273.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1274.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>