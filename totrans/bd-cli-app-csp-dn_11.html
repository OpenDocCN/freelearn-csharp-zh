<html><head></head><body>
		<div id="_idContainer157">
			<h1 id="_idParaDest-182" class="chapter-number"><a id="_idTextAnchor185"/>11</h1>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor186"/>Packaging and Deployment</h1>
			<p>Now that we have completed the development and testing of our application, it is time to release it to the world! We will need to package and deploy it in order to distribute it to (millions of) <span class="No-Break">users worldwide.</span></p>
			<p>Each platform (such as Windows, macOS, and Linux) has its own approach to distributing applications. Since .NET 8 is cross-platform, we can distribute Bookmarkr to even more users, no matter what platform they <span class="No-Break">are using.</span></p>
			<p>However, before we package and distribute the application, it is important that we test it on every <span class="No-Break">target platform.</span></p>
			<p>In this chapter, we will explore different packaging and deployment techniques that will help us achieve this goal. More specifically, we will do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Explore the different options when it comes to packaging and distributing a <span class="No-Break">CLI application</span></li>
				<li>Learn how to package and distribute a cross-platform <span class="No-Break">CLI application</span></li>
				<li>Learn how to deploy that CLI application to <span class="No-Break">multiple platforms</span></li>
				<li>Learn how to manage versions of a <span class="No-Break">distributed application</span></li>
			</ul>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor187"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor188"/>A bit of terminology</h1>
			<p>Throughout this chapter, you will come across the terms “packaging,” “distribution,” and “deployment.” For those of you who are not familiar with these terms, here is a brief definition <span class="No-Break">of each:</span></p>
			<ul>
				<li><strong class="bold">Packaging</strong>: Packaging <a id="_idIndexMarker401"/>refers to the process of preparing the application for release. This includes bundling all necessary files, libraries, and resources into a single unit that can be easily installed or executed by our users. Effective packaging ensures that the application is compatible with various environments and simplifies the installation process. It often involves creating installers or archives that streamline the deployment of <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Distribution</strong>: Distribution is<a id="_idIndexMarker402"/> the method by which a packaged application is delivered to users. This can involve various channels, including online downloads, physical media (such as USB drives), or cloud-based services (such as NuGet, NPM, WinGet, and <strong class="source-inline">apt-get</strong> repositories). The goal of distribution is to make the application accessible to its intended audience while ensuring that it reaches them in a secure and <span class="No-Break">efficient manner.</span></li>
				<li><strong class="bold">Deployment</strong>: Deployment is <a id="_idIndexMarker403"/>the mechanism by which the distributed application is installed and made operational on the user’s computer. This can involve configuring settings, integrating with existing systems, and ensuring that all components work appropriately. Deployment can be done manually or can be automated through various tools and scripts. The aim is to allow users to access and utilize the <span class="No-Break">application effectively.</span></li>
			</ul>
			<p>As you may have figured out, making an application (including a CLI application) available to a user is a three-step process that can be summarized by <span class="No-Break">this diagram:</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B22400_11_01.jpg" alt="Figure 11.1 – The process of making an application available to users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The process of making an application available to users</p>
			<p>Now that we understand the terminology, let’s start by exploring the available options when it comes to the packaging, distribution, and deployment of a <span class="No-Break">CLI application.</span></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor189"/>Packaging and distribution options for CLI applications</h1>
			<p>When it comes to packaging a CLI application, several methods exist, and choosing the most appropriate one depends on the way we intend to <span class="No-Break">distribute it.</span></p>
			<p>The most common options are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">MSI installer</strong>: This<a id="_idIndexMarker404"/> option allows for a more traditional installation experience and can be achieved using tools such as WiX or Visual Studio Installer Projects. Keep in mind that this option only works for Windows. Hence, if we intend to distribute our CLI application to multiple platforms, this option may not be the <span class="No-Break">best one.</span></li>
				<li><strong class="bold">.NET tool</strong>: We <a id="_idIndexMarker405"/>can distribute our application as a library or tool by packaging it as a NuGet package. This allows users to install it through the <strong class="source-inline">dotnet tool install</strong> command. Since our CLI application is built using a version of .NET that is cross-platform, we can distribute it as a .NET tool to various platforms. The downside of this approach is in the installation mechanism: it requires the .NET CLI. This is great if our audience is developers or IT professionals but not that appropriate otherwise. We should only consider this approach if our CLI application is a developer or IT administrator tool, which is not the case with our bookmark <span class="No-Break">management application.</span></li>
				<li><strong class="bold">Docker container</strong>: This<a id="_idIndexMarker406"/> is also a great option for multiplatform distribution. A noticeable advantage of a Docker container is that it has a lower footprint on the local machine since no local installation is performed and limited access to the system is required. A Docker container is a self-contained file. However, as with the .NET tool option, this option mainly targets developers or IT administrators since users need to have knowledge of using Docker in order to deploy <span class="No-Break">our application.</span></li>
				<li><strong class="bold">Platform-specific packaging</strong>: All the major platforms provide a package management<a id="_idIndexMarker407"/> system. Linux is famous for its <strong class="source-inline">apt-get</strong> package manager, while macOS provides Homebrew and Windows provides WinGet. These options are great since users of each platform are familiar with them no matter their technical knowledge. This means that these distribution mechanisms don’t just target developers and IT administrators but everyone! Once again, since our CLI application is built with cross-platform technology (.NET), we can use the same code and package it for distribution on each of <span class="No-Break">these platforms.</span></li>
			</ul>
			<p>As you can see, several packaging and distribution options are provided to us, and you can use whichever best suits your situation. In this chapter, we will explore the last three packaging and distribution options: .NET tool, Docker container, and WinGet (as a platform-specific <span class="No-Break">packaging option).</span></p>
			<p>Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor190"/>Packaging and distributing a CLI application</h1>
			<p>In this section, we will explore the subtleties of packaging and distributing our application, Bookmarkr, using three different options. We will take this opportunity to explain when each approach is <span class="No-Break">most appropriate.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor191"/>Option #1 – as a .NET tool</h2>
			<p>By packaging and<a id="_idIndexMarker408"/> distributing our application as a .NET tool, our users will be able to install it using the .NET CLI. It is, however, important that users ensure they have the appropriate .NET version installed to avoid version mismatches, which may cause unexpected behaviors in <span class="No-Break">the application.</span></p>
			<h3>Step 1 – packaging</h3>
			<p>The first step is to<a id="_idIndexMarker409"/> modify the <strong class="source-inline">.csproj</strong> file to add properties that indicate that it should be packaged as a tool. These properties should be added to the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">PropertyGroup&gt;</strong></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
&lt;PackageId&gt;bookmarkr&lt;/PackageId&gt;
&lt;Version&gt;1.0.0&lt;/Version&gt;
&lt;Authors&gt;Tidjani Belmansour&lt;/Authors&gt;
&lt;Description&gt;Bookmarkr is a bookmarks manager provided as a CLI application.&lt;/Description&gt;
&lt;PackAsTool&gt;true&lt;/PackAsTool&gt;
&lt;ToolCommandName&gt;bookmarkr&lt;/ToolCommandName&gt;
&lt;PackageOutputPath&gt;./nupkg&lt;/PackageOutputPath&gt;
&lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;
&lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;
&lt;Copyright&gt;Tidjani Belmansour. All rights reserved.&lt;/Copyright&gt;
&lt;PackageProjectUrl&gt;https://github.com/PacktPublishing/Building-CLI-Applications-with-C#-and-.NET&lt;/PackageProjectUrl&gt;
&lt;RepositoryUrl&gt;https://github.com/PacktPublishing/Building-CLI-Applications-with-C#-and-.NET&lt;/RepositoryUrl&gt;
&lt;PackageTags&gt;.net cli;bookmark manager;.net 8&lt;/PackageTags&gt;</pre>			<p>Let’s explain what we have just <span class="No-Break">added here:</span></p>
			<ul>
				<li><strong class="source-inline">PackageId</strong>: This represents the unique identifier for <span class="No-Break">our package.</span></li>
				<li><strong class="source-inline">Version</strong>: This indicates the version of our package. We will need to change this value when we need to package a <span class="No-Break">newer version.</span></li>
				<li><strong class="source-inline">Authors</strong>: This represents the author (or the list of authors) of <span class="No-Break">a package.</span></li>
				<li><strong class="source-inline">Description</strong>: This provides a brief description of what the <span class="No-Break">application does.</span></li>
				<li><strong class="source-inline">PackAsTool</strong>: Set to <strong class="source-inline">true</strong>, this indicates that the application should be packaged as a .<span class="No-Break">NET tool.</span></li>
				<li><strong class="source-inline">ToolCommandName</strong>: This<a id="_idIndexMarker410"/> is the name of the command users will type into their terminal to execute <span class="No-Break">our application.</span></li>
				<li><strong class="source-inline">PackageOutputPath</strong>: Since a .NET tool is packaged as a NuGet package, an <strong class="source-inline">.nupkg</strong> file is then generated. This property indicates where this file will <span class="No-Break">be generated.</span></li>
				<li><strong class="source-inline">PackageLicenseExpression</strong>: I chose to provide the code as an MIT license since it is a permissive license that allows for the reuse of the code in any project as long as the original copyright notice and license are included in all copies or substantial portions of <span class="No-Break">the software.</span></li>
				<li><strong class="source-inline">PackageReadmeFile</strong>: This points to a Markdown file in which we explain the purpose of the application, how to get started using it, and a link to its documentation, among other things. The content of this Markdown file will be displayed on the package page on the NuGet site for the user to read. You will find that file in the <span class="No-Break">code repository.</span></li>
				<li><strong class="source-inline">Copyright</strong>: This presents the copyright details of <span class="No-Break">the application.</span></li>
				<li><strong class="source-inline">PackageProjectUrl</strong>: This points to the home page of the <span class="No-Break">project’s website.</span></li>
				<li><strong class="source-inline">RepositoryUrl</strong>: This points to the repository where the application’s <span class="No-Break">code resides.</span></li>
				<li><strong class="source-inline">PackageTags</strong>: This presents a semicolon-delimited list of keywords that can be used when searching <span class="No-Break">for packages.</span></li>
			</ul>
			<p>To specify<a id="_idIndexMarker411"/> the location and how to treat the <strong class="source-inline">README.md</strong> file, we need to add the following XML code to the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">csproj</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;None Include="README.md" Pack="true" PackagePath="\"/&gt;
&lt;/ItemGroup&gt;</pre>			<p>The second step is to package the application. This is achieved by running <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet pack --configuration Release</pre>			<p>Remember that it will be generated at the location indicated by the value of the <span class="No-Break"><strong class="source-inline">PackageOutputPath</strong></span><span class="No-Break"> property.</span></p>
			<p>Our package is now ready <span class="No-Break">for distribution.</span></p>
			<h3>Step 2 – distribution</h3>
			<p>The <a id="_idIndexMarker412"/>most common way to distribute a .NET tool is to provide it through the NuGet site, located <span class="No-Break">at </span><a href="https://www.nuget.org"><span class="No-Break">https://www.nuget.org</span></a><span class="No-Break">.</span></p>
			<p>So, let’s head to the NuGet site and click on the <strong class="bold">Sign in</strong> link in the top-right corner of <span class="No-Break">the page:</span></p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B22400_11_02.jpg" alt="Figure 11.2 – Signing in to the NuGet site"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Signing in to the NuGet site</p>
			<p>I will be signing in with my personal account and granting the required permissions to the NuGet site, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B22400_11_03.jpg" alt="Figure 11.3 – Granting required permissions to the NuGet site"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Granting required permissions to the NuGet site</p>
			<p>Since this is<a id="_idIndexMarker413"/> the first time I have signed in with this account, the NuGet site asks me to provide <span class="No-Break">a username:</span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B22400_11_04.jpg" alt="Figure 11.4 – Choosing a username for the NuGet site"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Choosing a username for the NuGet site</p>
			<p>And that’s it! As a publisher of NuGet packages, I am now all set, and I can start uploading <span class="No-Break">my packages:</span></p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B22400_11_05.jpg" alt="Figure 11.5 – All set as a NuGet package publisher"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – All set as a NuGet package publisher</p>
			<p>Let’s now upload <span class="No-Break">our package!</span></p>
			<p>All we <a id="_idIndexMarker414"/>need to do is to click on <strong class="bold">Upload</strong> and browse to the <strong class="source-inline">.nupkg</strong> file we generated earlier. The package is then analyzed and the validation results <span class="No-Break">are presented:</span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B22400_11_06.jpg" alt="Figure 11.6 – Uploading a package to the NuGet website"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Uploading a package to the NuGet website</p>
			<p>Since <a id="_idIndexMarker415"/>our package is valid, we can submit it by clicking the <strong class="bold">Submit</strong> button at the bottom of <span class="No-Break">the page.</span></p>
			<p>Once uploaded, it usually takes around 15 minutes (but can sometimes take up to an hour) for the package to be validated and indexed before it appears in <span class="No-Break">search results:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B22400_11_07.jpg" alt="Figure 11.7 – Package awaiting validation and indexing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Package awaiting validation and indexing</p>
			<p>Once the <a id="_idIndexMarker416"/>package validation and indexing have been completed, it will appear on the NuGet website just as any other <span class="No-Break">NuGet package:</span></p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B22400_11_08.jpg" alt="Figure 11.8 – Bookmarkr is available on the NuGet website!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Bookmarkr is available on the NuGet website!</p>
			<p>Now that <a id="_idIndexMarker417"/>our application can be found by users, let’s see how it can <span class="No-Break">be deployed.</span></p>
			<h3>Step 3 – deployment</h3>
			<p>A user <a id="_idIndexMarker418"/>can deploy (that is, install) our application on their machine very easily by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet tool install --global bookrmarkr</pre>			<p>After the installation is complete, the user can execute our application by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
bookrmarkr</pre>			<p>And that’s it! We’ve <a id="_idIndexMarker419"/>packaged, distributed, and deployed Bookmarkr as a .<span class="No-Break">NET tool.</span></p>
			<p>Let’s now see how we can deliver Bookmarkr to our users as a <span class="No-Break">Docker container.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor192"/>Option #2 – as a Docker container</h2>
			<p>Packaging and distributing our application as a Docker container allows our users to install and use our application by reducing the footprint of the application on their environment (i.e., operating system <span class="No-Break">and data).</span></p>
			<h3>Step 1 – packaging</h3>
			<p>If you are<a id="_idIndexMarker420"/> familiar with containers, you may already know that in order to create a container image, a Dockerfile <span class="No-Break">is required.</span></p>
			<p>A Dockerfile is a file with no extension that should be located at the root of the project directory. For our application, its content is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /app
COPY *.csproj ./
RUN dotnet restore
COPY . ./
RUN dotnet publish -c Release -o out
FROM mcr.microsoft.com/dotnet/runtime:8.0
WORKDIR /app
COPY --from=build /app/out .
ENTRYPOINT [«dotnet», «bookmarkr.dll»]</pre>			<p>In essence, this file instructs Docker to build and publish the application (the first six lines of it), and then to build a container image out of the published application (the remaining <span class="No-Break">five lines).</span></p>
			<p>Before<a id="_idIndexMarker421"/> we run the command to actually build the image, we need to ensure that both Docker Desktop and <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) are<a id="_idIndexMarker422"/> installed and running. Note that Docker Desktop requires administrator privileges on the <span class="No-Break">local machine.</span></p>
			<p>Docker Desktop can be installed using the <span class="No-Break">following command:</span></p>
			<pre class="console">
winget install Docker.DockerDesktop</pre>			<p>WSL can be installed using the following command (Windows needs to be rebooted after WSL <span class="No-Break">is installed):</span></p>
			<pre class="console">
<a id="_idTextAnchor193"/>wsl --install</pre>			<p>The command for building a Docker image is <span class="No-Break">as follows:</span></p>
			<pre class="console">
docker build -t bookmarkr .</pre>			<p>The <strong class="source-inline">-t bookmarkr</strong> parameter is used to tag the Docker image to be generated with a name and an optional version number (more on <span class="No-Break">that later).</span></p>
			<p>The last dot character is<a id="_idIndexMarker423"/> neither a typo nor is it optional. It refers to what we call the <strong class="bold">build context</strong>. More specifically, it instructs Docker where to look for the Dockerfile, which, in this case, is the <span class="No-Break">current directory.</span></p>
			<p>The operation should take about five minutes, and once it is complete, the Docker image will be created, and it can be retrieved by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
docker images</pre>			<p>Note that the container image has been generated on our local machine. We should, however, distribute it through a location that everyone can <span class="No-Break">easily find.</span></p>
			<h3>Step 2 – distribution</h3>
			<p>The most <a id="_idIndexMarker424"/>common way to distribute Docker images is through <span class="No-Break">Docker Hub.</span></p>
			<p>To do that, we need to head<a id="_idIndexMarker425"/> to the Docker Hub portal, located at <a href="https://hub.docker.com">https://hub.docker.com</a>. If you don’t already have a Docker Hub account, you can create one from there. I already have such an account, and my username <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">theAzurian</strong></span><span class="No-Break">.</span></p>
			<p>So, let’s follow the steps to push our local Docker image to <span class="No-Break">Docker Hub.</span></p>
			<p>First, let’s log in to our Docker Hub account using <span class="No-Break">this command:</span></p>
			<pre class="console">
docker login -u theazurian -p ****</pre>			<p>I’m passing<a id="_idIndexMarker426"/> my <strong class="bold">Personal Access Token</strong> (<strong class="bold">PAT</strong>) to the <strong class="source-inline">-p</strong> parameter. This PAT was created through the Docker <span class="No-Break">Hub portal.</span></p>
			<p>Next, we need<a id="_idIndexMarker427"/> to tag the image to include the Docker Hub username of its author, the name of the application, and its version, such as <span class="No-Break">the following:</span></p>
			<pre class="console">
docker tag bookmarkr theazurian/bookmarkr:1.0.0</pre>			<p>Finally, we need to push the tagged image to Docker Hub using <span class="No-Break">this command:</span></p>
			<pre class="console">
docker push theazurian/bookmarkr:1.0.0</pre>			<p>We can ensure that the image has effectively been pushed to Docker Hub by heading to the portal and looking for it in our Docker <span class="No-Break">Hub profile:</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B22400_11_09.jpg" alt="Figure 11.9 – Bookmarkr is available in the Docker Hub portal!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Bookmarkr is available in the Docker Hub portal!</p>
			<p>We can also perform a search for it in the Docker <span class="No-Break">Hub portal:</span></p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B22400_11_10.jpg" alt="Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal</p>
			<p>Our application <a id="_idIndexMarker428"/>can now be found by our users. Let’s see how it can <span class="No-Break">be deployed.</span></p>
			<h3>Step 3 – deployment</h3>
			<p>In <a id="_idIndexMarker429"/>order for a user to run Docker on a Windows machine, they also need to have both Docker Desktop and <span class="No-Break">WSL installed.</span></p>
			<p>Docker Desktop can be installed using the <span class="No-Break">following command:</span></p>
			<pre class="console">
winget install Docker.DockerDesktop</pre>			<p>WSL can be installed using the following command (Windows needs to be rebooted after WSL <span class="No-Break">is installed):</span></p>
			<pre class="console">
wsl --install</pre>			<p>Now, our user can obtain the application from Docker Hub by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
docker pull theazurian/bookmarkr:1.0.0</pre>			<p>They can execute it by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
docker run theazurian/bookmarkr:1.0.0</pre>			<p>Bookmarkr can then be run on the user’s computer as a <span class="No-Break">Docker container:</span></p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B22400_11_11.jpg" alt="Figure 11.11 – Bookmarkr running as a Docker container"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Bookmarkr running as a Docker container</p>
			<p>And that’s it! We<a id="_idIndexMarker430"/> packaged, distributed, and deployed Bookmarkr as a <span class="No-Break">Docker container.</span></p>
			<p>Let’s now see how we can deliver Bookmarkr to our users as a <span class="No-Break">WinGet package.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor194"/>Option #3 – as a WinGet package</h2>
			<p>By <a id="_idIndexMarker431"/>packaging and distributing our application as a WinGet package, we allow our users to install it as any other application they have installed using WinGet, Microsoft’s <span class="No-Break">package manager.</span></p>
			<h3>Packaging</h3>
			<p>To<a id="_idIndexMarker432"/> package a .NET CLI application for distribution through WinGet (the official Windows package manager), we first need to create a <span class="No-Break">manifest file.</span></p>
			<p>Although it is possible to manually create and submit the manifest to the WinGet package repository on GitHub (<a href="https://github.com/microsoft/winget-pkgs">https://github.com/microsoft/winget-pkgs</a>), the easiest way to do so is using the <span class="No-Break"><strong class="source-inline">WingetCreate</strong></span><span class="No-Break"> CLI.</span></p>
			<p>Let’s first install it using <span class="No-Break">this command:</span></p>
			<pre class="console">
winget install wingetcreate</pre>			<p>Before we create the new manifest, we first need to build our CLI application as a self-contained .NET application using <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet publish -c Release -r win-x64 -p:selfcontained=true -p:IncludeNativeLibrariesForSelfExtract=true -p:PublishSingleFile=true</pre>			<p>Let’s take a closer look at <span class="No-Break">this command:</span></p>
			<ul>
				<li><strong class="source-inline">-c Release</strong>: Since this is a production-ready version of the application, we want to publish it using the Release configuration to ensure that it is optimized <span class="No-Break">for performance.</span></li>
				<li><strong class="source-inline">-r win-x64</strong>: Since WinGet is the package manager for Windows (and Windows only), we specify the target runtime to be the 64-bit version <span class="No-Break">of Windows.</span></li>
				<li><strong class="source-inline">-p:selfcontained=true</strong>: A self-contained application already includes the .NET runtime, so the user’s machine doesn’t need to have it installed. The application will then carry everything it needs to run, including the runtime, libraries, <span class="No-Break">and dependencies.</span></li>
				<li><strong class="source-inline">-p:IncludeNativeLibrariesForSelfExtract=true</strong>: This ensures that platform-specific libraries, along with unmanaged native libraries, are included in<a id="_idIndexMarker433"/> the published application. This is useful if we use some specific Serilog sinks and for the <span class="No-Break">SQLite library.</span></li>
				<li><strong class="source-inline">-p:PublishSingleFile=true</strong>: This instructs .NET to bundle everything (including the application code, the .NET runtime, and the dependencies) into a single executable file. While this makes it more convenient for distribution (because we are distributing a single file), it results in a file that is larger in size than <span class="No-Break">framework-dependent publishing.</span></li>
			</ul>
			<p>The application will be generated in the <span class="No-Break"><strong class="source-inline">bin\Release\net8.0\win-x64\publish</strong></span><span class="No-Break"> directory.</span></p>
			<p>Next, we will <a id="_idIndexMarker434"/>upload it to a location that should be accessible to the WinGet tool. It is common to pick a remote, publicly accessible, read-only location. I decided to use an Azure Storage account. Hence, the location of the executable will <span class="No-Break">be </span><a href="https://bookmarkr.blob.core.windows.net/releases/1.0.0/"><span class="No-Break">https://bookmarkr.blob.core.windows.net/releases/1.0.0/</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">About GitHub releases</p>
			<p class="callout">If your application is built as an open source project on GitHub, you will likely make your executable versions available as releases. However, releases on GitHub follow certain guidelines that go way beyond the scope of this book. If this is a topic you are interested in, I recommend that you explore these guidelines by <span class="No-Break">visiting </span><a href="https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md"><span class="No-Break">https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md</span></a><span class="No-Break">.</span></p>
			<p>Let’s now create our manifest files! We can do so using <span class="No-Break">this command:</span></p>
			<pre class="console">
wingetcreate new https://bookmarkr.blob.core.windows.net/releases/1.0.0/bookmarkr.exe</pre>			<p>The tool will ask a series of questions required to generate the manifest files. Here is an example of what it <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B22400_11_12.jpg" alt="Figure 11.12 – Generating the WinGet manifest files"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Generating the WinGet manifest files</p>
			<p>There <a id="_idIndexMarker435"/>will be three <span class="No-Break">files generated:</span></p>
			<ul>
				<li><strong class="bold">Version manifest (theAzurian.bookmarkr.yaml)</strong>: Contains metadata about the specific version of the application <span class="No-Break">being packaged.</span></li>
				<li><strong class="bold">Installer manifest (theAzurian.bookmarkr.installer.yaml)</strong>: Details the installation specifics of <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Default locale manifest (theAzurian.bookmarkr.locale.en-CA.yaml)</strong>: Defines localization settings for the application. It ensures that users receive a version of the application that is appropriately localized, enhancing user experience by presenting information in their <span class="No-Break">preferred language.</span></li>
			</ul>
			<p>I personally like to keep these files inside my Visual Studio project, inside the following folder structure that I create at the root of <span class="No-Break">the project:</span></p>
			<pre class="source-code">
/manifests/ApplicationName/Version</pre>			<p>So, in our case, this folder structure will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
/manifests/Bookmarkr/1.0.0</pre>			<p>Before we <a id="_idIndexMarker436"/>submit our manifest to the WinGet team, it is recommended that we test it locally to ensure that it works as expected. This is important as submitting our package could lead to a delay during the WinGet approval process if the manifest <span class="No-Break">contains issues.</span></p>
			<p>To do this, we first need to activate the ability to install applications from local manifests. This can be done by executing the following command in a terminal running <span class="No-Break">as administrator:</span></p>
			<pre class="console">
winget settings --enable LocalManifestFiles</pre>			<p>Next, we run this command, providing the path to the <span class="No-Break"><strong class="source-inline">manifests.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
winget install --manifest "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.0\"</pre>			<p>As we can see, the application is installed and runs <span class="No-Break">as expected:</span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B22400_11_13.jpg" alt="Figure 11.13 – Testing the WinGet package locally before submission"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Testing the WinGet package locally before submission</p>
			<p>We are now ready to submit our manifest to the <span class="No-Break">WinGet team!</span></p>
			<p>Submitting our manifest to the WinGet package repository requires us to generate a PAT for our GitHub account. We can do this using the <strong class="source-inline">wingetcreate token</strong> command, or we can skip this step and, when submitting the manifest, <strong class="source-inline">wingetcreate</strong> will prompt us to authenticate to our GitHub account. Let’s do it <span class="No-Break">this way!</span></p>
			<p>Let’s run the <span class="No-Break">following command:</span></p>
			<pre class="console">
wingetcreate submit "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.0\"</pre>			<p>This will open the browser and take us to the GitHub sign-in page. We will have to log on to our account. Once done, we will need to provide the <span class="No-Break">required authorization:</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B22400_11_14.jpg" alt="Figure 11.14 – Authorizing WingetCreate for our GitHub account"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Authorizing WingetCreate for our GitHub account</p>
			<p>It will then<a id="_idIndexMarker437"/> take us to the Pull Request page where we can follow its progress. After about 30 minutes, the pull request is completed, and the package is available for our users <span class="No-Break">to install.</span></p>
			<p>Users can then install Bookmarkr using WinGet by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
winget install --id theAzurian.Bookmarkr</pre>			<p>And voilà! We have packaged, distributed, and deployed Bookmarkr as a <span class="No-Break">WinGet package.</span></p>
			<p>So, we have seen three different approaches to packaging, distributing, and deploying our application. But how do we manage multiple versions of that application? That’s what we are going to explore in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor195"/>Managing versions of the application</h1>
			<p>All the options<a id="_idIndexMarker438"/> that we presented earlier provide version management mechanisms. Version management is as important as the packaging and distribution mechanism that <span class="No-Break">we select.</span></p>
			<p>As our <a id="_idIndexMarker439"/>application evolves and new features are added, modified, or removed, we want to offer a way for our users to consume these updates at their convenience. That is where versioning comes <span class="No-Break">into play.</span></p>
			<p>Currently, only a single version of our application is distributed. We can hence install it by either omitting its version number or explicitly <span class="No-Break">indicating it.</span></p>
			<p>But what if we update the application? How can we distribute the new version? And what if the new version introduces a bug and we need to roll back to the <span class="No-Break">previous version?</span></p>
			<p>Let’s explore how we can achieve this for each of the distribution methods that we <span class="No-Break">covered earlier.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor196"/>Semantic versioning primer</h2>
			<p>Before <a id="_idIndexMarker440"/>we dive into managing different versions of an application, let us start by introducing <span class="No-Break"><strong class="bold">semantic versioning</strong></span><span class="No-Break">.</span></p>
			<p>If you are familiar with this approach to versioning applications, you know that it is probably the most common and widely adopted approach in the industry. If you haven’t heard about it before, let me give you a quick introduction. If you want to go deeper in your exploration of semantic versioning, I recommend that you visit its official website <span class="No-Break">at </span><a href="https://semver.org"><span class="No-Break">https://semver.org</span></a><span class="No-Break">.</span></p>
			<p>In essence, semantic versioning expresses a version number using <span class="No-Break">this format:</span></p>
			<pre class="source-code">
Major.Minor.Patch</pre>			<p>Here, we have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Major</strong>: Indicates that this version of the application contains breaking changes that are incompatible with the previous <span class="No-Break">major version</span></li>
				<li><strong class="bold">Minor</strong>: Indicates that this version of the application only adds new functionalities that are backward compatible with the previous versions of the same <span class="No-Break">major version</span></li>
				<li><strong class="bold">Patch</strong>: Indicates that this version of the application contains bug fixes that are backward compatible with the previous versions of the same <span class="No-Break">major version</span></li>
			</ul>
			<p>Each part is<a id="_idIndexMarker441"/> represented as a number that is incremented with each <span class="No-Break">new version.</span></p>
			<p>Now that we understand semantic versioning, let’s use it to manage different versions of <span class="No-Break">our application.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor197"/>Managing versions of a .NET tool</h2>
			<p>If you <a id="_idIndexMarker442"/>ran the version of Bookmarkr that we provided as a .NET tool, you will certainly have noticed that it returns the following <span class="No-Break">error message:</span></p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B22400_11_15.jpg" alt="Figure 11.15 – Bookmarkr as a .NET tool fails to execute"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Bookmarkr as a .NET tool fails to execute</p>
			<p>Let’s then fix the problem and distribute a <span class="No-Break">new version.</span></p>
			<p>The error comes from the fact that the <strong class="source-inline">appsettings.json</strong> file is not being made part of the package when the <strong class="source-inline">dotnet pack</strong> command <span class="No-Break">is executed.</span></p>
			<p>Fortunately, fixing this problem is straightforward. Locate the following entry in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">csproj</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;None Update="appsettings.json"&gt;</pre>			<p>Replace it with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;None Update="appsettings.json" Pack="true" PackagePath="\"&gt;</pre>			<p>Now, since<a id="_idIndexMarker443"/> the new version we are about to package and distribute only provides a bug fix, we shall increment the patch number, so the version number looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;Version&gt;1.0.3&lt;/Version&gt;</pre>			<p>We can now package and distribute the new version by following the same steps that we <span class="No-Break">described earlier.</span></p>
			<p>However, before we distribute it, it is recommended to test it locally using the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet tool install --global bookmarkr --version 1.0.3 --add-source "C:\code\Chap11\bookmarkr\nupkg"</pre>			<p>The <strong class="source-inline">--add-source</strong> parameter allows us to specify a location from which the package will be deployed. Here, I am specifying the path where the NuGet package was generated on my <span class="No-Break">local machine.</span></p>
			<p>After ensuring that this new version works successfully on the local machine, we can proceed with pushing it to the <span class="No-Break">NuGet website.</span></p>
			<p>Users can get a specific version of the tool by providing its version number as a parameter. In this case, this could be achieved by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet tool install --global bookmarkr --version 1.0.3</pre>			<p>Or, they can simply type the following command to get the <span class="No-Break">latest version:</span></p>
			<pre class="console">
dotnet tool install --global bookmarkr</pre>			<p>Once this command is executed, the previous version of the tool will be replaced by the <span class="No-Break">new one.</span></p>
			<p>By running the new version of the application, we can now see that the error <span class="No-Break">is resolved:</span></p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B22400_11_16.jpg" alt="Figure 11.16 – Bookmarkr as a .NET tool running successfully"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Bookmarkr as a .NET tool running successfully</p>
			<p>And that’s it! We <a id="_idIndexMarker444"/>now know how to manage versions of a .<span class="No-Break">NET tool.</span></p>
			<p>Let’s see how we manage versions of a <span class="No-Break">Docker container.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor198"/>Managing versions of a Docker container</h2>
			<p>As you <a id="_idIndexMarker445"/>may have noticed, when we pushed the Docker image to Docker Hub, we tagged it with a version number. Hence, if we want to distribute a new version, we can tag the new image with a different <span class="No-Break">version number.</span></p>
			<p>However, if you are familiar with Docker, you may know about working with containers without providing their version number or using the <span class="No-Break"><strong class="source-inline">latest</strong></span><span class="No-Break"> tag.</span></p>
			<p>When distributing multiple versions of a container, it is important to indicate which one of these is the latest version, by tagging that version using the <span class="No-Break"><strong class="source-inline">latest</strong></span><span class="No-Break"> tag.</span></p>
			<p>So, let’s assume that we are distributing a new version of Bookmarkr and that we want to indicate that this new version is the latest one. We can achieve this <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
docker build -t theazurian/bookmarkr:2.0.0 .
docker tag theazurian/bookmarkr:2.0.0 theazurian/bookmarkr:latest
docker push theazurian/bookmarkr:2.0.0
docker push theazurian/bookmarkr:latest</pre>			<p>Let’s explain <span class="No-Break">these commands:</span></p>
			<ul>
				<li>The first one creates a new Docker image that is tagged with <span class="No-Break">version 2.0.0</span></li>
				<li>The second one tags version 2.0.0 as the <span class="No-Break">latest version</span></li>
				<li>The third command pushes the image tagged with version 2.0.0 to <span class="No-Break">Docker Hub</span></li>
				<li>The fourth one pushes the image tagged with the latest version to <span class="No-Break">Docker Hub</span></li>
			</ul>
			<p>The <a id="_idIndexMarker446"/>fact that we push the same image using two different tags allows our users to get it (using the <strong class="source-inline">docker pull</strong> command) with or without specifying its version number. Hence, as we keep updating the application and pushing new Docker images, we will tag the newest version with the <strong class="source-inline">latest</strong> tag. Should that version contain a bug, we can direct our users to a previous version by tagging it with the <span class="No-Break"><strong class="source-inline">latest</strong></span><span class="No-Break"> tag.</span></p>
			<p>If we head to the Docker Hub portal, we will see that the new version has been successfully pushed. Notice that there are two versions of the same image: one with version number 2.0.0 as a tag, and the other with the <span class="No-Break"><strong class="source-inline">latest</strong></span><span class="No-Break"> tag.</span></p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B22400_11_17.jpg" alt="Figure 11.17 – New version of the Docker image pushed to Docker Hub"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – New version of the Docker image pushed to Docker Hub</p>
			<p>On the <a id="_idIndexMarker447"/>user’s side, they can get a specific version by explicitly mentioning its tag, <span class="No-Break">as follows:</span></p>
			<pre class="console">
docker pull theazurian/bookmarkr:2.0.0</pre>			<p>Or, they can get the latest version (i.e., the version tagged as <strong class="source-inline">latest</strong>) by omitting the tag, <span class="No-Break">as follows:</span></p>
			<pre class="console">
docker pull theazurian/bookmarkr</pre>			<p>The user will then <span class="No-Break">see this:</span></p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B22400_11_18.jpg" alt="Figure 11.18 – Running the new version of the Docker container"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Running the new version of the Docker container</p>
			<p>And that’s it! We <a id="_idIndexMarker448"/>now know how to manage versions of a <span class="No-Break">Docker image.</span></p>
			<p>Let’s see how we manage versions of a <span class="No-Break">WinGet package.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor199"/>Managing versions of a WinGet package</h2>
			<p>In order to <a id="_idIndexMarker449"/>submit a new version of the application, following an update to the application’s code or functionalities, we first need to update the version number in the <strong class="source-inline">.csproj</strong> file (the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Version&gt;</strong></span><span class="No-Break"> element).</span></p>
			<p>Next, we need to publish the application again using the same command we <span class="No-Break">saw earlier:</span></p>
			<pre class="console">
dotnet publish -c Release -r win-x64 -p:selfcontained=true -p:IncludeNativeLibrariesForSelfExtract=true -p:PublishSingleFile=true</pre>			<p>We then<a id="_idIndexMarker450"/> need to upload the resulting binaries to our distribution location, which is our Azure Storage account, keeping in mind that we should create a new directory for the new version. The path will then look like this for <span class="No-Break">version 1.0.3:</span></p>
			<pre class="source-code">
https://bookmarkr.blob.core.windows.net/releases/1.0.3/bookmarkr.exe</pre>			<p>The next step is to update the manifest using <span class="No-Break">this command:</span></p>
			<pre class="console">
wingetcreate update theAzurian.Bookmarkr --version 1.0.3 https://bookmarkr.blob.core.windows.net/releases/1.0.3/bookmarkr.exe</pre>			<p>The new manifest is then generated and is ready <span class="No-Break">for submission.</span></p>
			<p>However, as we previously learned, it is always good practice to test the new version locally before submitting it. To do that, we will execute the same command as we <span class="No-Break">did previously:</span></p>
			<pre class="console">
winget install --manifest "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.3\"</pre>			<p>Once the tests are successful, we submit the new version using <span class="No-Break">this command:</span></p>
			<pre class="console">
wingetcreate submit "C:\code\Chap11\bookmarkr\manifests\Bookmarkr\1.0.3\"</pre>			<p>The remaining steps are similar to those we followed when submitting the initial version of <span class="No-Break">the application.</span></p>
			<p>Once the new version has been approved and added to the WinGet package repository, users can find it and install it. They can install the latest version using <span class="No-Break">this command:</span></p>
			<pre class="console">
winget install --id theAzurian.Bookmarkr</pre>			<p>Or, they can install a specific version by passing the desired version number as a parameter to the command, <span class="No-Break">as follows:</span></p>
			<pre class="console">
winget install --id theAzurian.Bookmarkr --version 1.0.3</pre>			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B22400_11_19.jpg" alt="Figure 11.19 – The updated version of Bookmarkr is available in WinGet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – The updated version of Bookmarkr is available in WinGet</p>
			<p>And that’s it! This is<a id="_idIndexMarker451"/> how we manage multiple versions of a <span class="No-Break">WinGet package.</span></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor200"/>Summary</h1>
			<p>In this chapter, we learned how to package and deploy Bookmarkr onto different platforms in order to distribute it to users all around the world, no matter their platform of choice, be it Windows, Linux, <span class="No-Break">or macOS.</span></p>
			<p>This is quite a milestone we achieved, from the inception of the idea of our CLI application all the way to getting it into the hands of millions of users worldwide. Let’s take a moment to celebrate this achievement and be proud of ourselves. <span class="No-Break">Congratulations! </span><span class="No-Break">🎉</span></p>
			<p>However, some users are telling us that the application is sometimes slow. We haven’t experienced these performance issues since we are running on fast and powerful computers, but that is not the case with all our users. Although we could simply specify the minimum requirements to run Bookmarkr, we don’t want to limit the number of users that can benefit from and be able to use it. So, we have decided to see whether there is something we <span class="No-Break">can do.</span></p>
			<p>In the next chapter, we will explore different techniques that will allow us to optimize the performance of <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor201"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>An even better way is by challenging yourself to complete tasks. Hence, I challenge you to improve the Bookmarkr application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor202"/>Task #1 – allowing Linux users to install Bookmarkr using apt-get</h2>
			<p>Currently, Bookmarkr can be deployed to Windows using WinGet. However, this doesn’t work on Linux, where Linux users typically use <strong class="source-inline">apt-get</strong> for deploying applications. You are thus challenged to distribute Bookmarkr as an <strong class="source-inline">apt-get</strong> package so Linux users can also enjoy <span class="No-Break">using it.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor203"/>Task #2 – allowing macOS users to install Bookmarkr using Homebrew</h2>
			<p>The same applies to macOS users: they typically install their applications using the <strong class="source-inline">brew</strong> command. You are thus challenged to distribute Bookmarkr as a <span class="No-Break">Homebrew formula.</span></p>
		</div>
	

		<div id="_idContainer158" class="Content">
			<h1 id="_idParaDest-200" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor204"/>Part 5: Advanced Techniques and Best Practices</h1>
			<p>In this part, you will explore crucial aspects of CLI application development that enhance performance, security, and functionality. You'll delve into performance optimization and tuning techniques, learning how to profile your CLI applications, identify bottlenecks, and implement efficient algorithms and data structures. This includes strategies like caching, load balancing, and code refactoring to improve execution speed and resource utilization. Next, you'll focus on security considerations specific to CLI applications, covering best practices and protection against common vulnerabilities. You'll learn how to implement strong authentication mechanisms, use encryption for sensitive data, and follow the principle of least privilege in your CLI tools. Finally, you'll explore additional resources and libraries that will allow you to dive deeper into the various concepts and techniques presented in <span class="No-Break">this book.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B22400_12.xhtml#_idTextAnchor205"><em class="italic">Chapter 12</em></a><em class="italic">, Performance Optimization and Tuning</em></li>
				<li><a href="B22400_13.xhtml#_idTextAnchor220"><em class="italic">Chapter 13</em></a><em class="italic">, Security Considerations for CLI Applications</em></li>
				<li><a href="B22400_14.xhtml#_idTextAnchor236"><em class="italic">Chapter 14</em></a><em class="italic">, Additional Resources and Libraries</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer159">
			</div>
		</div>
		<div>
			<div id="_idContainer160">
			</div>
		</div>
		<div>
			<div id="_idContainer161">
			</div>
		</div>
		<div>
			<div id="_idContainer162">
			</div>
		</div>
		<div>
			<div id="_idContainer163">
			</div>
		</div>
		<div>
			<div id="_idContainer164" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer165" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer166">
			</div>
		</div>
		<div>
			<div id="_idContainer167">
			</div>
		</div>
		<div>
			<div id="_idContainer168" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>