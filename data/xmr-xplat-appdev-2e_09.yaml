- en: Chapter 9. Third-party Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 第三方库
- en: Xamarin supports a subset of the .NET framework, but for the most part, it includes
    all the standard APIs you would expect in the .NET base class libraries. Because
    of this, a large portion of C#'s open source libraries can be used directly in
    Xamarin projects. Additionally, if an open source project doesn't have a Xamarin
    or portable class library version, porting the code to be used in a Xamarin project
    can often be very straightforward. Xamarin also supports calling native Objective-C
    and Java libraries, so we will explore these as additional means of reusing existing
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin支持.NET框架的一个子集，但就大部分而言，它包括了您在.NET基类库中期望的所有标准API。因此，大量C#的开源库可以直接在Xamarin项目中使用。此外，如果一个开源项目没有Xamarin或可移植类库版本，将代码移植到Xamarin项目中通常非常直接。Xamarin还支持调用原生Objective-C和Java库，因此我们将探讨这些作为重用现有代码的额外手段。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: The Xamarin Component Store
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin组件商店
- en: NuGet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet
- en: Porting existing C# libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口现有C#库
- en: Objective-C bindings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C绑定
- en: Java bindings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java绑定
- en: The Xamarin Component Store
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin组件商店
- en: The primary and obvious way to add third-party components to your project is
    via the Xamarin Component Store. The Component Store is fairly similar to **NuGet**,
    which we will cover later, except that the Component Store also contains premium
    components that are not free. All Xamarin components are required to include full
    sample projects and a getting started guide, while NuGet does not inherently provide
    documentation in its packages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的项目添加第三方组件的主要和明显方式是通过Xamarin组件商店。组件商店与稍后我们将要介绍的**NuGet**相当类似，但组件商店还包含了一些非免费的付费组件。所有Xamarin组件都必须包括完整的示例项目和入门指南，而NuGet包本身并不提供文档。
- en: 'All the `Xamarin.iOS` and `Xamarin.Android` projects come with a `Components`
    folder. To get started, simply right-click on the folder and select **Get More
    Components** to launch the store dialog, as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Xamarin.iOS`和`Xamarin.Android`项目都包含一个`Components`文件夹。要开始，只需右键单击文件夹并选择**获取更多组件**以启动商店对话框，如图下截图所示：
- en: '![The Xamarin Component Store](img/00070.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin组件商店](img/00070.jpeg)'
- en: At the time of writing this book, there are well over 200 components available
    to enhance your iOS and Android applications. This is a great place to find the
    most common components to use within your Xamarin applications. Each component
    is complete with artwork. You might possibly need a demonstration video, reviews,
    and other information before purchasing a premium component.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，有超过200个组件可供增强您的iOS和Android应用程序。这是一个寻找在Xamarin应用程序中使用最常见组件的好地方。每个组件都附带完整的艺术作品。在购买高级组件之前，您可能需要演示视频、评论和其他信息。
- en: The most common components
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最常见的组件
- en: 'The most well-known and useful components are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最知名和最有用的组件如下：
- en: '**Json.NET**: This is the de facto standard for parsing and serializing JSON
    with C#'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Json.NET**: 这是使用C#解析和序列化JSON的事实标准'
- en: '**RestSharp**: This is a commonly used simple REST client for .NET'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RestSharp**: 这是一个常用的简单REST客户端，用于.NET'
- en: '**SQLite.NET**: This is a simple **Object** **Relational Mapping** (**ORM**)
    to use when working with local SQLite databases in your mobile applications'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite.NET**: 这是一个简单的**对象关系映射**（ORM），用于在移动应用程序中处理本地SQLite数据库'
- en: '**Facebook SDK**: This is the standard SDK provided by Facebook to integrate
    its services into your apps'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Facebook SDK**: 这是Facebook提供的标准SDK，用于将其服务集成到您的应用程序中'
- en: '**Xamarin.Mobile**: This is a cross-platform library to access your device''s
    contacts, GPS, photo library, and camera with a common API'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xamarin.Mobile**: 这是一个跨平台库，使用通用API访问您的设备联系人、GPS、照片库和相机'
- en: '**ActionBarSherlock**: This is a powerful `ActionBar` replacement for Android'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ActionBarSherlock**: 这是一个强大的Android `ActionBar`替代品'
- en: Note that some of these libraries are native Java or Objective-C libraries,
    while some are plain C#. Xamarin is built from the ground up to support calling
    native libraries, so the Component Store offers many of the common libraries that
    Objective-C or Java developers would leverage when developing mobile applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其中一些库是原生Java或Objective-C库，而另一些则是纯C#。Xamarin从头开始构建以支持调用原生库，因此组件商店提供了许多Objective-C或Java开发者在开发移动应用程序时可能会使用的常见库。
- en: 'You can also submit your own components to the Component Store. If you have
    a useful open source project or just want to earn some extra cash, creating a
    component is simple. We won''t be covering it in this book, but you can navigate
    to [http://components.xamarin.com/submit](http://components.xamarin.com/submit)
    for full documentation on the subject, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将你自己的组件提交到组件商店。如果你有一个有用的开源项目或者只是想赚一些额外的钱，创建一个组件很简单。我们不会在本书中介绍它，但你可以在[http://components.xamarin.com/submit](http://components.xamarin.com/submit)找到有关此主题的完整文档，如下面的截图所示：
- en: '![The most common components](img/00071.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![最常见的组件](img/00071.jpeg)'
- en: Porting existing C# libraries
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口现有C#库
- en: Even though Xamarin is becoming a popular platform, many open source .NET libraries
    are simply not up to speed with supporting `Xamarin.iOS` and `Xamarin.Android`.
    However, in these cases, you are definitely not out of luck. Often, if there is
    a Silverlight or Windows Phone version of the library, you can simply create an
    iOS or Android class library and add the files with no code changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Xamarin正变得越来越受欢迎，但许多开源.NET库在支持`Xamarin.iOS`和`Xamarin.Android`方面显然还跟不上。然而，在这些情况下，你绝对不会失望。通常，如果库有Silverlight或Windows
    Phone版本，你只需创建一个iOS或Android类库，并添加文件，无需进行代码更改。
- en: 'To help with this process, Xamarin has created an online service tool to scan
    your existing code and determine how far off a library is from being portable.
    Navigate to [http://scan.xamarin.com](http://scan.xamarin.com) and upload any
    `*.exe` or `*.dll` file to have its methods analyzed for cross-platform development.
    After the scanning process, you''ll get a report of the porting percentage (how
    much your component / application is portable to all platforms: Android, iOS,
    Windows Phone, and Windows Store).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助这个过程，Xamarin创建了一个在线服务工具，用于扫描你的现有代码并确定库距离可移植性的程度。导航到[http://scan.xamarin.com](http://scan.xamarin.com)，上传任何`*.exe`或`*.dll`文件以分析其方法进行跨平台开发。扫描过程完成后，你将获得一个端口百分比报告（你的组件/应用程序可以移植到所有平台：Android、iOS、Windows
    Phone和Windows Store）。
- en: 'The following screenshot is a sample report of the **Lucene** .NET client library:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是**Lucene** .NET客户端库的示例报告：
- en: '![Porting existing C# libraries](img/00072.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![端口现有C#库](img/00072.jpeg)'
- en: If the library is running a high percentage on portability, you should have
    a relatively easy time porting it to Android or iOS. In most cases, it can even
    be easier to port the library to Xamarin than Windows Phone or WinRT.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库的可移植性运行在较高比例，那么将库端口到Android或iOS应该相对容易。在大多数情况下，将库端口到Xamarin甚至可能比Windows Phone或WinRT更容易。
- en: To illustrate this process, let's port an open source project that doesn't have
    Xamarin or a portable class library support. I have selected a dependency injection
    library called **Ninject** due to its usefulness and relationship to ninjas. You
    can find out more about the library at [http://www.ninject.org](http://www.ninject.org).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个过程，让我们将一个没有Xamarin或可移植类库支持的开放源代码项目进行端口。我选择了一个名为**Ninject**的依赖注入库，因为它很有用，并且与忍者有关。你可以在[http://www.ninject.org](http://www.ninject.org)了解更多关于这个库的信息。
- en: 'Let''s begin setting up the library to work with Xamarin projects as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置库以与Xamarin项目一起使用，如下所示：
- en: First, download the source code for Ninject from [https://github.com/ninject/Ninject](https://github.com/ninject/Ninject).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从[https://github.com/ninject/Ninject](https://github.com/ninject/Ninject)下载Ninject的源代码。
- en: Open `Ninject.sln` in Xamarin Studio.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中打开`Ninject.sln`。
- en: Add a new **iOS Library Project** named `Ninject.iOS`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Ninject.iOS`的新**iOS库项目**。
- en: Link all the files from the `Ninject` main project. Make sure you use the **Add
    Existing Folder** dialog to speed up this process.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Ninject`主项目中的所有文件链接起来。确保你使用**添加现有文件夹**对话框来加快这个过程。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you aren't familiar with GitHub, I recommend that you download the desktop
    client for Mac found at [http://mac.github.com](http://mac.github.com).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉GitHub，我建议你下载位于[http://mac.github.com](http://mac.github.com)的Mac桌面客户端。
- en: 'Now try to build the `Ninject.iOS` project; you will get several compiler errors
    in a file named `DynamicMethodFactory.cs`, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试构建`Ninject.iOS`项目；你将在名为`DynamicMethodFactory.cs`的文件中遇到几个编译错误，如下面的截图所示：
- en: '![Porting existing C# libraries](img/00073.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![端口现有C#库](img/00073.jpeg)'
- en: 'Open `DynamicMethodFactory.cs` and notice the following code at the top of
    the file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`DynamicMethodFactory.cs`并注意文件顶部的以下代码：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is not possible to use `System.Reflection.Emit` on iOS due to Apple's platform
    restrictions. Luckily, the library writers have created a preprocessor directive
    called `NO_LCG` (which stands for **Lightweight Code Generation**) to allow the
    library to run on platforms that do not support `System.Reflection.Emit`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于苹果平台限制，无法在 iOS 上使用 `System.Reflection.Emit`。幸运的是，库编写者创建了一个名为 `NO_LCG`（代表**轻量级代码生成**）的预处理器指令，以允许库在不支持
    `System.Reflection.Emit` 的平台上运行。
- en: To fix our iOS project, open the project options and navigate to the **Build**
    | **Compiler** section. Add `NO_LCG` to the **Define Symbols** field for both
    **Debug** and **Release** in the **Configuration** drop-down menu. Click on **OK**
    to save your changes. Notice how the entire file is now highlighted with a light
    gray color in Xamarin Studio, as shown in the following screenshot. This means
    that the code will be omitted from being compiled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复我们的 iOS 项目，请打开项目选项并导航到**构建** | **编译器**部分。在**配置**下拉菜单中，将 `NO_LCG` 添加到**定义符号**字段中的**调试**和**发布**。点击**确定**以保存您的更改。注意，现在整个文件在
    Xamarin Studio 中以浅灰色突出显示，如以下截图所示。这意味着代码将不会被编译。
- en: '![Porting existing C# libraries](img/00074.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![现有 C# 库迁移](img/00074.jpeg)'
- en: If you compile the project now, it will be completed successfully and a `Ninject.iOS.dll`
    file will be created, which you can reference from any `Xamarin.iOS` project.
    You can also reference the `Ninject.iOS` project directly instead of using the
    `*.dll` file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在编译项目，它将成功完成，并创建一个`Ninject.iOS.dll`文件，你可以从任何`Xamarin.iOS`项目中引用它。你也可以直接引用`Ninject.iOS`项目，而不是使用`*.dll`文件。
- en: At this point, you might wish to repeat the process to create a `Xamarin.Android`
    class library project. Luckily, `Xamarin.Android` supports `System.Reflection.Emit`,
    so you can skip adding the additional preprocessor directive if you wish.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能希望重复此过程以创建一个`Xamarin.Android`类库项目。幸运的是，`Xamarin.Android`支持`System.Reflection.Emit`，因此如果你愿意，可以跳过添加额外的预处理器指令。
- en: Objective-C bindings
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C 绑定
- en: Xamarin has developed a sophisticated system to call native Objective-C libraries
    from C# in iOS projects. The core of `Xamarin.iOS` uses the same technology to
    call native Apple APIs in **UIKit**, **CoreGraphics**, and other iOS frameworks.
    Developers can create iOS binding projects to expose the Objective-C classes and
    methods to C# using simple interfaces and attributes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin 开发了一个复杂的系统，可以在 iOS 项目中从 C# 调用原生 Objective-C 库。`Xamarin.iOS` 的核心使用相同的技术调用
    **UIKit**、**CoreGraphics** 和其他 iOS 框架中的原生 Apple API。开发者可以创建 iOS 绑定项目，通过简单的接口和属性将
    Objective-C 类和方法暴露给 C#。
- en: To aid in creating Objective-C bindings, Xamarin has created a small tool named
    **Objective Sharpie** that can process Objective-C header files for you and export
    the valid C# definitions to add to a binding project. This tool is a great starting
    point for most bindings that will get your binding three-fourths of the way complete,
    and you will want to hand-edit and fine-tune things to be more C#-friendly in
    a lot of cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助创建 Objective-C 绑定，Xamarin 创建了一个名为 **Objective Sharpie** 的小工具，可以为你处理 Objective-C
    头文件，并将有效的 C# 定义导出到绑定项目中。这个工具是大多数绑定的一个很好的起点，它将你的绑定完成到三分之四，在许多情况下，你将需要手动编辑和微调以使其更符合
    C#。
- en: As an example, we will write a binding for the Google Analytics library for
    iOS. It is a simple and useful library that can track the user activities in your
    iOS or Android applications. At the time of writing, the version of the Google
    Analytics SDK was 3.10, so some of these instructions might change as new versions
    are released.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将为 iOS 的 Google Analytics 库编写一个绑定。这是一个简单而有用的库，可以跟踪你的 iOS 或 Android 应用程序中的用户活动。在撰写本文时，Google
    Analytics SDK 的版本为 3.10，因此随着新版本的发布，一些这些说明可能会发生变化。
- en: Working with Objective Sharpie
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Objective Sharpie
- en: 'First, download and install Objective Sharpie from [http://tinyurl.com/ObjectiveSharpie](http://tinyurl.com/ObjectiveSharpie),
    then perform the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 [http://tinyurl.com/ObjectiveSharpie](http://tinyurl.com/ObjectiveSharpie)
    下载并安装 Objective Sharpie，然后执行以下步骤：
- en: Download the latest Google Analytics SDK for iOS available at [https://tinyurl.com/GoogleAnalyticsForiOS](https://tinyurl.com/GoogleAnalyticsForiOS).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 iOS 可用的最新 Google Analytics SDK，链接为 [https://tinyurl.com/GoogleAnalyticsForiOS](https://tinyurl.com/GoogleAnalyticsForiOS)。
- en: Create a new **iOS Binding Project** named `GoogleAnalytics.iOS`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GoogleAnalytics.iOS` 的新 **iOS 绑定项目**。
- en: Run **Objective Sharpie**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 **Objective Sharpie**。
- en: Select **iOS 7.1** as **Target SDK** and click on **Next**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **目标 SDK** 设置为 **iOS 7.1** 并点击 **下一步**。
- en: Add all of the header (`*.h`) files included with the Google Analytics SDK;
    you can find these in the `Library` folder of the download. Click on **Next**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Google Analytics SDK中包含的所有头文件（`*.h`）；您可以在下载的`Library`文件夹中找到这些文件。点击**下一步**。
- en: Pick a suitable namespace such as `GoogleAnalytics` and click on **Generate**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个合适的命名空间，例如`GoogleAnalytics`，然后点击**生成**。
- en: Copy the resulting `ApiDefinition.cs` file that was generated into your iOS
    binding project.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的`ApiDefinition.cs`文件复制到您的iOS绑定项目中。
- en: After a few seconds, your C# file will be generated. Click on **Quit**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，您的C#文件将被生成。点击**退出**。
- en: 'You should have not received any error messages from Objective Sharpie during
    the process, and when finished, your screen should look like the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，您不应该从Objective Sharpie收到任何错误消息，完成之后，您的屏幕应该看起来像下面的截图：
- en: '![Working with Objective Sharpie](img/00075.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用Objective Sharpie](img/00075.jpeg)'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of writing this book, Objective Sharpie does not work properly with
    Xcode 6.0 and higher. I recommend that you download Xcode 5.1.1 if you run into
    this issue. You can install two versions of Xcode side by side by renaming an
    existing one in Finder and installing a second one. You can find older Xcode downloads
    at [https://developer.apple.com/downloads/index.action](https://developer.apple.com/downloads/index.action).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这本书的时候，Objective Sharpie与Xcode 6.0及以上版本不兼容。如果您遇到这个问题，我建议您下载Xcode 5.1.1。您可以通过在Finder中重命名现有版本并安装第二个版本来并排安装两个版本的Xcode。您可以在[https://developer.apple.com/downloads/index.action](https://developer.apple.com/downloads/index.action)找到旧的Xcode下载。
- en: Now if you return to your binding project, you'll notice that Objective Sharpie
    has generated an interface definition for every class discovered in the header
    files of the library. It has also generated many `enum` values that the library
    uses and changed casing and naming conventions to follow C# more closely where
    possible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您回到您的绑定项目中，您会注意到Objective Sharpie已经为库的头文件中发现的每个类生成了一个接口定义。它还生成了许多库使用的`enum`值，并在可能的情况下更改了大小写和命名约定以更接近C#。
- en: 'As you read through the binding, you''ll notice several C# attributes that
    define different aspects about the Objective-C library such as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读绑定时，您会注意到几个C#属性，它们定义了Objective-C库的不同方面，如下所示：
- en: '`BaseType`: This declares an interface as an Objective-C class. The base class
    (also called superclass) is passed in to the attribute. If it has no base class,
    `NSObject` should be used.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseType`：这声明了一个接口作为Objective-C类。将基类（也称为超类）传递给属性。如果没有基类，应使用`NSObject`。'
- en: '`Export`: This declares a method or property on an Objective-C class. A string
    that maps the Objective-C name to the C# name is passed in. Objective-C method
    names are generally in the following form: `myMethod:someParam:someOtherParam`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Export`：这声明了一个Objective-C类上的方法或属性。传递一个字符串，将Objective-C名称映射到C#名称。Objective-C方法名称通常以下列形式：`myMethod:someParam:someOtherParam`。'
- en: '`Static`: This marks a method or property as `static` in C#.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Static`：这标记一个方法或属性在C#中为`static`。'
- en: '`Bind`: This is used on properties to map a getter or setter to a different
    Objective-C method. Objective-C properties can rename a getter or setter for a
    property.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bind`：这用于属性，将获取器或设置器映射到不同的Objective-C方法。Objective-C属性可以重命名属性的获取器或设置器。'
- en: '`NullAllowed`: This allows `null` to be passed to a method or property. By
    default, an exception is thrown if this occurs.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullAllowed`：这允许将`null`传递给方法或属性。默认情况下，如果发生这种情况，会抛出异常。'
- en: '`Field`: This declares an Objective-C field that is exposed as a public variable
    in C#.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Field`：这声明了一个Objective-C字段，在C#中作为公共变量公开。'
- en: '`Model`: This identifies a class to `Xamarin.iOS` to have methods that can
    be optionally overridden. This is generally used on Objective-C delegates.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model`：这标识了一个类，让`Xamarin.iOS`有可选项覆盖的方法。这通常用于Objective-C的代理。'
- en: '`Internal`: This flags the generated member with the C# internal keyword. It
    can be used to hide certain members that you don''t want to expose to the outside
    world.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Internal`：这使用C#的`internal`关键字标记生成的成员。它可以用来隐藏您不想公开给外部世界的某些成员。'
- en: '`Abstract`: This identifies an Objective-C method as required, which goes hand
    in hand with `Model`. In C#, it will generate an abstract method.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abstract`：这标识了一个Objective-C方法为必需的，与`Model`一起使用。在C#中，它将生成一个抽象方法。'
- en: The only other rule to know is how to define constructors. Xamarin had to invent
    a convention for this since C# interfaces do not support constructors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要知道的其他规则是如何定义构造函数。由于 C# 接口不支持构造函数，Xamarin 必须发明一个约定。
- en: 'To define a constructor besides the default one, use the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义除了默认构造函数之外的构造函数，请使用以下代码：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would define a constructor on the class that takes in `RectangleF` as a
    parameter. The method name `Constructor` and the return type `IntPtr` signal the
    Xamarin compiler to generate a constructor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为类定义一个接受 `RectangleF` 作为参数的构造函数。方法名 `Constructor` 和返回类型 `IntPtr` 会让 Xamarin
    编译器生成一个构造函数。
- en: 'Now, let''s return to our binding project to finish setting up everything.
    If you compile the project at this point, you''ll get a few compiler errors. Let''s
    fix them one by one as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的绑定项目，完成所有设置。如果你现在编译项目，你会得到一些编译错误。让我们逐一修复它们，如下所示：
- en: Change the default namespace of the project to `GoogleAnalytics`. This setting
    is found in the project options by navigating to **General** | **Main Settings**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目的默认命名空间更改为 `GoogleAnalytics`。此设置在项目选项中，通过导航到 **General** | **Main Settings**
    可以找到。
- en: Add `libGoogleAnalyticsServices.a` from the SDK download to the project.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SDK 下载中的 `libGoogleAnalyticsServices.a` 添加到项目中。
- en: Add `using` statements for `MonoTouch.Foundation`, `MonoTouch.UIKit`, and `MonoTouch.ObjCRuntime`
    at the top of the `ApiDefinition.cs` file.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ApiDefinition.cs` 文件顶部添加 `using` 语句，包括 `MonoTouch.Foundation`、`MonoTouch.UIKit`
    和 `MonoTouch.ObjCRuntime`。
- en: Remove the multiple duplicate declarations of `GAILogLevel`. You might also
    wish to move enumerations to the `StructsAndEnums.cs` file.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `GAILogLevel` 的多重重复声明。你可能还希望将枚举移动到 `StructsAndEnums.cs` 文件中。
- en: Remove the declaration for `GAIErrorCode`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `GAIErrorCode` 的声明。
- en: In the `SetAll` method of `GAIDictionaryBuilder`, rename the `params` parameter
    to `parameters`, as `params` is a reserved word in C#.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GAIDictionaryBuilder` 的 `SetAll` 方法中，将 `params` 参数重命名为 `parameters`，因为 `params`
    是 C# 中的一个保留字。
- en: Remove the duplicate declarations for `GAILogger`, `GAITracker`, `GAITrackedViewController`,
    and any other duplicate classes you find.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `GAILogger`、`GAITracker`、`GAITrackedViewController` 和你找到的任何其他重复类。
- en: Go through any `Field` declarations and change `[Field("Foobar")]` to `[Field("Foobar",
    "__Internal")]`. This tells the compiler where the field resides; in this case,
    it will be included internally in our binding project.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查任何 `Field` 声明，并将 `[Field("Foobar")]` 改为 `[Field("Foobar", "__Internal")]`。这告诉编译器字段的位置；在这种情况下，它将包含在我们的绑定项目中。
- en: Remove all the `Verify` attributes. These are spots where Objective Sharpie
    was unsure of the operation it performed. In our example, all of them are fine
    so it is safe to remove them.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有 `Verify` 属性。这些是 Objective Sharpie 在执行操作时不确定的地方。在我们的例子中，它们都很好，所以可以安全地删除它们。
- en: 'One more error remains regarding Objective Sharpie not being able to generate
    C# delegates for methods that have callbacks. Navigate to the GAI interface and
    change the following method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个错误是关于 Objective Sharpie 无法为具有回调的方法生成 C# 委托。导航到 GAI 接口并更改以下方法：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will also need to define the following delegate at the top of this file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在文件顶部定义以下委托：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After going through these issues, you should be able to compile the binding
    and get no errors. You could have read the Objective-C header files and written
    the definitions yourself by hand; however, using Objective Sharpie generally means
    a lot less work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些问题后，你应该能够编译绑定并得到没有错误。你可以阅读 Objective-C 头文件并手动编写定义；然而，使用 Objective Sharpie
    通常意味着工作量会少很多。
- en: 'At this point, if you try to use the library in an iOS project, you would get
    an error such as the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你尝试在一个 iOS 项目中使用库，你会得到如下错误：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to define the other frameworks and libraries that the Objective-C library
    uses. This is very similar to how references work in C#. If we review the Google
    Analytics documentation, it says that you must add `CoreData`, `SystemConfiguration`,
    and `libz.dylib`. Additionally, you must add a weak reference to `AdSupport`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义 Objective-C 库使用的其他框架和库。这与 C# 中的引用工作非常相似。如果我们审查 Google Analytics 文档，它说必须添加
    `CoreData`、`SystemConfiguration` 和 `libz.dylib`。此外，你必须添加对 `AdSupport` 的弱引用。
- en: 'Open `libGoogleAnalyticsServices.linkwith.cs` that was created automatically
    nested underneath the `*.a` file and make the following changes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 打开自动创建在 `*.a` 文件下嵌套的 `libGoogleAnalyticsServices.linkwith.cs`，并做出以下更改：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We added references to frameworks in the following ways:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式添加了对框架的引用：
- en: '**Frameworks**: Add them to the `Frameworks` value on the `LinkWith` attribute,
    delimited by spaces.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架**：将它们添加到`LinkWith`属性的`Frameworks`值中，用空格分隔。'
- en: '**Weak Frameworks**: Add them to the `WeakFrameworks` property on the `LinkWith`
    attribute in the same manner. Weak frameworks are libraries that can be ignored
    if they are not found. In this case, `AdSupport` was added in iOS 6; however,
    this library will still work on older versions of iOS.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱框架**：以相同的方式将它们添加到`LinkWith`属性的`WeakFrameworks`属性中。弱框架是如果找不到可以忽略的库。在这种情况下，`AdSupport`是在iOS
    6中添加的；然而，这个库仍然可以在旧版本的iOS上工作。'
- en: '**Dynamic Libraries**: Libraries such as `libz.dylib` can be declared in `LinkerFlags`.
    Generally, you drop the `.dylib` extension and replace `lib` with `–l`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态库**：例如`libz.dylib`这样的库可以在`LinkerFlags`中声明。通常，你删除`.dylib`扩展名，并将`lib`替换为`–l`。'
- en: After these changes are implemented, you will be able to successfully use the
    library from iOS projects. For complete documentation on Objective-C bindings,
    visit the Xamarin documentation site at [http://docs.xamarin.com/ios](http://docs.xamarin.com/ios).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些更改后，你将能够从iOS项目中成功使用库。有关Objective-C绑定的完整文档，请访问Xamarin文档网站[http://docs.xamarin.com/ios](http://docs.xamarin.com/ios)。
- en: Java bindings
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java绑定
- en: In the same manner as iOS, Xamarin has provided full support for calling into
    Java libraries from C# with `Xamarin.Android`. The native Android SDKs function
    in this way and developers can leverage the `Android Java Bindings` project to
    take advantage of other native Java libraries in C#. The main difference here
    is that not a lot has to be done by hand in comparison to Objective-C bindings.
    The Java syntax is very similar to that of C#, so many mappings are exactly one-to-one.
    In addition, Java has metadata information included with its libraries, which
    Xamarin uses to automatically generate the C# code required for calling into Java.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS类似，Xamarin通过`Xamarin.Android`提供了对从C#调用Java库的全面支持。原生Android SDKs以这种方式运行，开发者可以利用`Android
    Java Bindings`项目在C#中利用其他原生Java库。这里的主要区别是，与Objective-C绑定相比，手动要做的事情很少。Java语法与C#非常相似，因此许多映射是一对一的。此外，Java在其库中包含元数据信息，Xamarin使用这些信息自动生成调用Java所需的C#代码。
- en: As an example, let's make a binding for the Android version of the Google Analytics
    SDK. Before we begin, download the SDK from [http://tinyurl.com/GoogleAnalyticsForAndroid](http://tinyurl.com/GoogleAnalyticsForAndroid).
    At the time of writing, the version of the Android SDK 3.01, so some of these
    instructions might change over time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，让我们为Google Analytics SDK的Android版本创建一个绑定。在我们开始之前，从[http://tinyurl.com/GoogleAnalyticsForAndroid](http://tinyurl.com/GoogleAnalyticsForAndroid)下载SDK。在撰写本文时，Android
    SDK的版本是3.01，因此这些说明可能会随着时间的推移而改变。
- en: 'Let''s begin creating a Java binding as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始创建Java绑定：
- en: Start a new `Android Java Bindings Library` project in Xamarin Studio. You can
    use the same solution as we did for iOS if you wish.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中启动一个新的`Android Java Bindings Library`项目。如果你愿意，可以使用我们为iOS所做的相同解决方案。
- en: Name the project `GoogleAnalytics.Droid`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`GoogleAnalytics.Droid`。
- en: Add `libGoogleAnalyticsServices.jar` from the Android SDK to the project under
    the `Jars` folder. By default, the build action for the file will be `EmbeddedJar`.
    This packs the jar file into the DLL, which is the best option for ease of use.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Android SDK中的`libGoogleAnalyticsServices.jar`添加到项目的`Jars`文件夹下。默认情况下，文件的构建操作将是`EmbeddedJar`。这会将jar文件打包到DLL中，这是使用最方便的选项。
- en: Build the project. You will get a few errors, which we'll address in a moment.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。你将得到一些错误，我们将在稍后解决。
- en: Most of the time you spend working on Java bindings will be to fix small issues
    that prevent the generated C# code from compiling. Don't fret; a lot of libraries
    will work on the first try without having to make any changes at all. Generally,
    the larger the Java library is, the more work you have to do to get it working
    from C#.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分时间你花费在Java绑定上的工作将是修复那些阻止生成的C#代码编译的小问题。不要担心；许多库在第一次尝试时无需任何更改即可正常工作。一般来说，Java库越大，你需要做的工作就越多，才能从C#中使其正常工作。
- en: 'The following are the types of issues you might run into:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可能会遇到的问题类型：
- en: '**Java obfuscation**: If the library is run through an obfuscation tool such
    as **ProGuard**, the class and method names might not be valid C# names.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java混淆**：如果库通过混淆工具（如**ProGuard**）运行，类和方法名称可能不是有效的C#名称。'
- en: '**Covariant return types**: Java has different rules for return types in overridden
    virtual methods than C# does. For this reason, you might need to modify the return
    type for the generated C# code to compile.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协变返回类型**：Java在重写虚拟方法中的返回类型规则与C#不同。因此，你可能需要修改生成的C#代码的返回类型才能编译。'
- en: '**Visibility**: The rules that Java has for accessibility are different from
    those of C#; the visibility of methods in subclasses can be changed. Sometimes,
    you will have to change visibility in C# to get it to compile.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性**：Java的可访问性规则与C#不同；子类中方法的可见性可以改变。有时，你可能需要更改C#中的可见性才能使其编译。'
- en: '**Naming collisions**: Sometimes, the C# code generator can get things a bit
    wrong and generate two members or classes with the same name.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名冲突**：有时，C#代码生成器可能会出错，生成具有相同名称的两个成员或类。'
- en: '**Java generics**: The use of generic classes in Java can often cause issues
    in C#.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java泛型**：Java中泛型类的使用往往会在C#中引起问题。'
- en: 'So before we get started on solving these issues in our Java binding, let''s
    first clean up the namespaces in the project. Java namespaces are of the form
    `com.mycompany.mylibrary` by default, so let''s change the definition to match
    C# more closely. In the `Transforms` directory of the project, open `Metadata.xml`
    and add the following XML tag inside the root metadata node:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们开始解决Java绑定中的这些问题之前，让我们首先清理项目中的命名空间。Java命名空间默认为`com.mycompany.mylibrary`，所以让我们将定义更改为更接近C#。在项目的`Transforms`目录中，打开`Metadata.xml`并在根元数据节点内添加以下XML标签：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `attr` node tells the Xamarin compiler what needs to be replaced in the
    Java definition with another value. In this case, we are replacing `managedName`
    of the package with `GoogleAnalytics.Tracking` because it will make much more
    sense in C#. The path value might look a bit strange, which is because it uses
    an XML matching query language named **XPath**. In general, just think of it as
    a pattern matching query for XML. For full documentation on XPath syntax, check
    out some of the many resources online such as [http://w3schools.com/xpath](http://w3schools.com/xpath).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr`节点告诉Xamarin编译器需要在Java定义中替换什么值。在这种情况下，我们正在将包的`managedName`替换为`GoogleAnalytics.Tracking`，因为它在C#中会更有意义。路径值可能看起来有点奇怪，这是因为它使用了一个名为**XPath**的XML匹配查询语言。一般来说，只需将其视为XML的模式匹配查询即可。有关XPath语法的完整文档，请查看网上许多资源，例如[http://w3schools.com/xpath](http://w3schools.com/xpath)。'
- en: You might be asking yourself at this point, what is the XPath expression matching
    against? Return to Xamarin Studio and right-click on the solution at the top.
    Navigate to **Display Options** | **Show All Files**. Open `api.xml` under the
    `obj/Debug` folder. This is the Java definition file that describes all the types
    and methods within the Java library. If you notice, the XML here directly correlates
    to the XPath expressions we'll be writing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能正在问自己，XPath表达式是在匹配什么？回到Xamarin Studio，在顶部的解决方案上右键单击。导航到**显示选项** | **显示所有文件**。在`obj/Debug`文件夹下打开`api.xml`。这是描述Java库中所有类型和方法的Java定义文件。如果你注意到，这里的XML直接关联到我们将要编写的XPath表达式。
- en: In our next step, let's remove all the packages (or namespaces) we don't plan
    on using in this library. This is generally a good idea for large libraries since
    you don't want to waste time fixing issues with parts of the library you won't
    even be calling from C#. Note that it doesn't actually remove the Java code; it
    just prevents the generation of any C# declarations for calling it from C#.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一步中，让我们删除所有我们在这个库中不打算使用的包（或命名空间）。对于大型库来说，这通常是一个好主意，因为你不想浪费时间修复你甚至不会从C#中调用的库的部分问题。请注意，这实际上并不会删除Java代码；它只是阻止从C#生成任何调用它的C#声明。
- en: 'Add the following declarations in `Metadata.xml`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Metadata.xml`中添加以下声明：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now when you build the library, we can start resolving issues. The first error
    you will receive will be something like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你构建库时，我们可以开始解决这些问题。你将收到的第一个错误可能如下所示：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we locate `TrackerHandler` within the `api.xml` file, we''ll see the following
    class declaration:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`api.xml`文件中定位到`TrackerHandler`，我们将看到以下类声明：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, can you spot the problem? We need to fill out the `visibility` XML attribute,
    which for some reason is blank. Add the following line to `Metadata.xml`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你能找到问题吗？我们需要填写`visibility` XML属性，但不知何故它是空的。将以下行添加到`Metadata.xml`中：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This XPath expression will locate the `TrackerHandler` class inside the `com.google.analytics.tracking.android`
    package and change `visibility` to `public`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个XPath表达式将在`com.google.analytics.tracking.android`包内找到`TrackerHandler`类，并将`visibility`改为`public`。
- en: 'If you build the project now, it will complete successfully with one warning.
    In Java binding projects, it is a good idea to fix warnings since they generally
    indicate that a class or method is being omitted from the binding. Notice the
    following warning:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建项目，它将成功完成，但有一个警告。在Java绑定项目中，修复警告是一个好主意，因为它们通常表明某个类或方法被省略了。注意以下警告：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To fix this issue, locate the type definition for `CampaignTrackingService`
    in `api.xml`, which is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，找到`api.xml`中`CampaignTrackingService`的类型定义，如下所示：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The way to fix the issue here is to change the base class to the `Xamarin.Android`
    definition for `IntentService`. Add the following code to `Metadata.xml`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将基类改为`Xamarin.Android`定义的`IntentService`。将以下代码添加到`Metadata.xml`中：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This changes the `extends` attribute to use the `IntentService` found in `Mono.Android.dll`.
    I located the Java name for this class by opening `Mono.Android.dll` in Xamarin
    Studio''s **Assembly Browser**. Let''s take a look at the `Register` attribute,
    as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`extends`属性更改为使用`Mono.Android.dll`中找到的`IntentService`。我通过在Xamarin Studio的**Assembly
    Browser**中打开`Mono.Android.dll`来找到这个类的Java名称。让我们看一下下面的截图中的`Register`属性：
- en: '![Java bindings](img/00076.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Java绑定](img/00076.jpeg)'
- en: To inspect the `*.dll` files in Xamarin Studio, you merely have to open them.
    You can also double-click on any assembly in the `References` folder in your project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查Xamarin Studio中的`*.dll`文件，你只需打开它们。你还可以在你的项目中的`References`文件夹中双击任何程序集。
- en: 'If you build the binding project now, we''re left with one last error, which
    is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建绑定项目，我们将剩下最后一个错误，如下所示：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you navigate to the `api.xml` file, you can see the definition for `OnHandleIntent`
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到`api.xml`文件，你可以看到`OnHandleIntent`的定义如下：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see here that the Java method for this class is `public`, but the base
    class is `protected`. So, the best way to fix this is to change the C# version
    to `protected` as well. Writing an XPath expression to match this is a bit more
    complicated, but luckily Xamarin has an easy way to retrieve it. If you double-click
    on the error message in the **Errors** pad of Xamarin Studio, you''ll see the
    following comment in the generated C# code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个类的Java方法是`public`的，但基类是`protected`。因此，最好的办法是将C#版本也改为`protected`。编写一个匹配这个的XPath表达式稍微复杂一些，但幸运的是，Xamarin有一个简单的方法来检索它。如果你在Xamarin
    Studio的**Errors**面板中双击错误消息，你将在生成的C#代码中看到以下注释：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Copy this value to `path` and add the following to `Metadata.xml`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将此值复制到`path`，并在`Metadata.xml`中添加以下内容：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we can build the project and get zero errors and zero warnings. The library
    is now ready for use within your `Xamarin.Android` projects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建项目，得到零错误和零警告。库现在可以在你的`Xamarin.Android`项目中使用了。
- en: 'However, if you start working with the library, notice how the parameter names
    for the methods are `p0`, `p1`, `p2`, and so on. Here are a few method definitions
    of the `EasyTracker` class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你开始使用这个库，请注意方法参数的名称是`p0`、`p1`、`p2`等等。以下是`EasyTracker`类的一些方法定义：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can imagine how difficult it would be to consume a Java library without
    knowing the proper parameter names. The reason the parameters are named this way
    is because the Java metadata for its libraries does not include the information
    to set the correct name for each parameter. So, `Xamarin.Android` does the best
    thing it can and autonames each parameter sequentially.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，如果不了解正确的参数名称，消费Java库会有多困难。参数被这样命名的原因是，Java库的元数据不包括设置每个参数正确名称的信息。因此，`Xamarin.Android`做了它能做的最好的事情，并为每个参数按顺序自动命名。
- en: 'To rename the parameters in this class, we can add the following to `Metadata.xml`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名这个类中的参数，我们可以在`Metadata.xml`中添加以下内容：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On rebuilding the binding project, this will effectively rename the parameters
    for these four methods in the `EasyTracker` class. At this time, I would recommend
    that you go through the classes you plan on using in your application and rename
    the parameters so that it will make more sense to you. You might need to refer
    to the Google Analytics documentation to get the naming correct. Luckily, there
    is a `javadocs.zip` file included in the SDK that provides HTML reference for
    the library.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在重建绑定项目时，这将有效地重命名`EasyTracker`类中这四个方法的参数。此时，我建议您检查您计划在应用程序中使用的类，并重命名参数，这样对您来说会更有意义。您可能需要参考谷歌分析文档以获取正确的命名。幸运的是，SDK中包含一个`javadocs.zip`文件，它为库提供了HTML参考。
- en: For a full reference on implementing Java bindings, make sure you check out
    Xamarin's documentation site at [http://docs.xamarin.com/android](http://docs.xamarin.com/android).
    There are certainly more complicated scenarios than what we ran into when creating
    a binding for the Google Analytics library.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解实现Java绑定的信息，请确保查看Xamarin的文档网站[http://docs.xamarin.com/android](http://docs.xamarin.com/android)。在为谷歌分析库创建绑定时，我们遇到的场景肯定比我们遇到的更复杂。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added libraries from the Xamarin Component Store to Xamarin
    projects and ported an existing C# library, Ninject, to both `Xamarin.iOS` and
    `Xamarin.Android`. Next, we installed Objective Sharpie and explored its usage
    to generate Objective-C bindings. Finally, we wrote a functional Objective-C binding
    for the Google Analytics SDK for iOS and a Java binding for the Google Analytics
    SDK for Android. We also wrote several XPath expressions to clean up the Java
    binding.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将Xamarin组件商店的库添加到Xamarin项目中，并将现有的C#库Ninject移植到`Xamarin.iOS`和`Xamarin.Android`。接下来，我们安装了Objective
    Sharpie并探讨了其使用方法以生成Objective-C绑定。最后，我们为iOS的谷歌分析SDK编写了一个功能性的Objective-C绑定，为Android的谷歌分析SDK编写了一个Java绑定。我们还编写了几个XPath表达式来清理Java绑定。
- en: There are several available options to use the existing third-party libraries
    from your `Xamarin.iOS` and `Xamarin.Android` applications. We looked at everything
    from using the Xamarin Component Store, porting existing code and setting up Java
    and Objective-C libraries to be used from C#. In the next chapter, we will cover
    the `Xamarin.Mobile` library as a way to access a user's contacts, camera, and
    GPS location.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从您的`Xamarin.iOS`和`Xamarin.Android`应用程序中使用现有的第三方库。我们探讨了从使用Xamarin组件商店、移植现有代码到设置Java和Objective-C库以便从C#中使用的一切。在下一章中，我们将介绍`Xamarin.Mobile`库，作为访问用户联系人、相机和GPS位置的方式。
