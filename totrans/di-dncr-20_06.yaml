- en: Object Lifetime
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: Object Lifetime is the time duration between an object's creation and destruction.
    In Functional Programming Languages, data stored in constant variables have a
    scope defined which is immutable in nature. This means that their lifetimes have
    a functional scope (no destruction) as long as the app is not stopped. On the
    other hand, the objects in Object Oriented Programming are mutable and have different
    types of scope which leads to different lifestyles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生命周期是指对象从创建到销毁的时间段。在函数式编程语言中，存储在常量变量中的数据有一个定义的范围，其本质上是不可变的。这意味着只要应用程序没有停止，它们的生命周期就具有功能范围（没有销毁）。另一方面，面向对象编程中的对象是可变的，具有不同类型的范围，这导致了不同的生活方式。
- en: Memory plays a vital role in application life cycle. All objects and variables
    use memory space. Therefore, it is important to learn the concepts which deal
    with an object's flow during application execution. Unless we know how to free
    up space by using proper codes or patterns, it would result in **Memory Leaks**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内存在应用程序生命周期中起着至关重要的作用。所有对象和变量都使用内存空间。因此，了解在应用程序执行期间对象流动的概念非常重要。除非我们知道如何通过适当的代码或模式释放空间，否则会导致**内存泄漏**。
- en: If a computer program exposes bugs and erroneously manages the memory allocations,
    then resources become unavailable. This condition is called Memory Leaks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机程序暴露了错误并错误地管理内存分配，那么资源将变得不可用。这种情况被称为内存泄漏。
- en: To avoid Memory Leaks, we should take proper care while designing our classes,
    so that the resources are available when needed. That would only happen if and
    only if resources attached to objects are released by the program as soon as objects
    go out of scope. Thus, the app runs seamlessly as unused space is regularly cleared.
    However, this process is not automatic in all scenarios. The reason, we are going
    to explore this topic, is to understand how exactly the DI technique manages the
    lifetime of objects differently in different scenarios, which in return helps
    us take appropriate decisions while designing our classes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免内存泄漏，我们在设计类时应该采取适当的注意，以确保在需要时资源可用。这只会发生在程序在对象超出作用域时立即释放与对象关联的资源的情况下。因此，应用程序可以无缝运行，因为未使用的空间会定期清理。然而，这个过程并不是在所有情况下都是自动的。我们要探讨这个主题的原因是了解DI技术在不同场景下如何管理对象的生命周期不同，这反过来又帮助我们设计类时做出适当的决策。
- en: An object is born when it's related class is instantiated. The newly born object
    stays around for a limited period of time as long as the application keeps a reference
    of that and continues to use that. If your application is closed or the reference
    of the object goes out of scope in the code, then .NET Framework will flag that
    object to be removed from memory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当相关类被实例化时，对象就诞生了。新生的对象会存在一段时间，只要应用程序保持对该对象的引用并继续使用它。如果你的应用程序关闭或对象的引用在代码中超出作用域，那么.NET
    Framework将标记该对象从内存中删除。
- en: In this particular chapter, we will learn how objects are managed by .NET Core.
    Also, we will look into techniques to determine when an object is disposable and
    how to work with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的章节中，我们将学习.NET Core如何管理对象。此外，我们还将探讨确定对象何时可回收以及如何与之交互的技术。
- en: 'Topics we will cover in this chapter are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Managed and unmanaged resources.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和非管理资源。
- en: Object's creation and destruction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的创建和销毁
- en: '`IDisposal` interface'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDisposal`接口'
- en: Object lifetime management in .NET Core
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core中的对象生命周期管理
- en: Manage the object life cycle
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象生命周期
- en: There are two basic places in the memory--stack and heap.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中有两个基本的地方——栈和堆。
- en: Stack versus heap
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈与堆的比较
- en: Let's learn a little bit about these memory space types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要了解一下这些内存空间类型。
- en: '| **Stack** | **Heap** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **栈** | **堆** |'
- en: '| Static memory: Fixed memory space allocated for the app. | Dynamic memory:
    No fixed space. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 静态内存：为应用程序分配的固定内存空间。 | 动态内存：没有固定空间。 |'
- en: '| When a method is called, a chunk of stack is reserved to store the method''s
    information like a method name, local variables, return type, and so on. | Can
    store anything. The developer has the flexibility to manage this space. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 当一个方法被调用时，会预留一块栈空间来存储方法信息，如方法名、局部变量、返回类型等。 | 可以存储任何东西。开发者有灵活性来管理这个空间。 |'
- en: '| Memory allocation has a pattern in **LIFO** (**Last In First Out**) order.
    So, when the `Main` function calls method `A()` and then `A()` calls `B()`, `B()`
    will be stored at the top and executes first. Refer to the following diagram:
    | No such pattern to store data. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 内存分配遵循**后进先出**（**LIFO**）的顺序。所以，当 `Main` 函数调用方法 `A()`，然后 `A()` 调用 `B()` 时，`B()`
    将被存储在顶部并首先执行。参见图表：| 没有这样的模式来存储数据。|'
- en: 'The following diagram shows how the data gets stored in stack and heap for
    one program:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了数据在一个程序中如何存储在栈和堆中：
- en: '![](img/dff1fbbb-ae31-446a-87ba-1c011ddfec81.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dff1fbbb-ae31-446a-87ba-1c011ddfec81.png)'
- en: '`Main()` calls `A()` which then calls `B()` method. According to stack properties,
    it first moves the last one out, which is `B()`. So, `B()` executes first. Then `B()` is
    removed from the stack and then `A()` is processed and removed from memory. After
    that, the `Main()` method executes and removed. The reference type variable named
    as `foo` inside `Main()` is stored in stack, but the actual object is allocated
    memory in heap.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main()` 调用 `A()`，然后 `A()` 调用 `B()` 方法。根据栈的特性，它首先移除最后一个，即 `B()`。所以， `B()` 首先执行。然后 `B()`
    从栈中移除，然后处理并从内存中移除 `A()`。之后， `Main()` 方法执行并移除。在 `Main()` 中名为 `foo` 的引用类型变量存储在栈上，但实际的对象是在堆上分配内存的。'
- en: 'Consider the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variable `name` is a value type, which is directly stored on the stack.
    But, when we write `SomeClass sc = new SomeClass()`, it actually tells the framework
    to store the object in heap. In addition to this, it also allocates a memory space
    for a variable `sc` in the stack, which holds the reference to this object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `name` 是一个值类型，它直接存储在栈上。但是，当我们编写 `SomeClass sc = new SomeClass()` 时，实际上是在告诉框架将对象存储在堆上。除此之外，它还在栈上为变量
    `sc` 分配了一块内存空间，该空间持有对这个对象的引用。
- en: Now, when the `Main` method execution is completed, the variables `name` and
    `sc` will be released and memory space becomes free. Here is the catch though.
    The variable `sc` (reference type) is released from the stack, but the actual
    object is still on the heap. It's just the reference, which is removed. As the
    reference is removed from the stack, so there is no way to actually know if there
    is an object existing on the heap., related to it. We have ended up with a management
    problem now.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 `Main` 方法执行完成后，变量 `name` 和 `sc` 将被释放，内存空间变为空闲。但是这里有一个问题。变量 `sc`（引用类型）从栈上释放，但实际的对象仍然在堆上。只是引用被移除了。由于引用从栈上移除，所以实际上无法知道堆上是否存在与之相关的对象。我们现在遇到了一个管理问题。
- en: To get rid of this (in C++), we could have done something like this `delete
    sc;`. However, in C#, which is a managed language, there is a service known as
    **Garbage Collector** (**GC**), which automatically cleans up the unused memory
    by analyzing all those flagged *out of scoped* objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题（在 C++ 中），我们可能已经做了如下操作 `delete sc;`。然而，在 C# 这种托管语言中，有一个名为**垃圾回收器**（**GC**）的服务，它会通过分析所有那些标记为**超出作用域**的对象来自动清理未使用的内存。
- en: '**Managed Language** is a high-level language that depends on services provided
    by a runtime environment to execute, such as Garbage Collection service, Security
    Service, Exception Handling, and more. It uses Common Language Runtime (CLR) to
    execute in .Net languages or **Java Virtual Machine** (**JVM**) in Java.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**托管语言**是一种高级语言，它依赖于运行时环境提供的服务来执行，例如垃圾回收服务、安全服务、异常处理等等。它使用公共语言运行时（CLR）在 .Net
    语言中执行或在 Java 中使用**Java 虚拟机**（**JVM**）。'
- en: Managed and unmanaged resources
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管和非托管资源
- en: Pure .NET code is called **managed resources** as that can be directly managed
    by the runtime environment. On the other hand, unmanaged resources are those that
    are not in direct control of the runtime such as, file handles, COM objects, database
    connections, and so on. For example, if you open a connection to a database server
    this will use resources on the server (for maintaining the connection) and possibly
    other non .NET resources.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 .NET 代码被称为**托管资源**，因为它们可以直接由运行时环境管理。另一方面，非托管资源是指那些不在运行时直接控制之下的资源，例如文件句柄、COM
    对象、数据库连接等等。例如，如果你打开到数据库服务器的连接，这将使用服务器上的资源（用于维护连接）以及可能的其他非 .NET 资源。
- en: The managed resources are targeted directly by CLR, therefore, Garbage Collector
    cleans them up, which is an automatic process. As a developer, you don't usually
    need to explicitly call GC. However, there is a catch, when we consider the unmanaged
    resources like database connections. We have to deal with them ourselves as the
    CLR can't. We have to release them manually using the `Finalize` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 管理资源直接由CLR（公共语言运行时）针对，因此垃圾收集器会清理它们，这是一个自动的过程。作为开发者，你通常不需要显式调用GC。然而，有一个问题，当我们考虑非托管资源，如数据库连接时。我们必须自己处理它们，因为CLR无法处理。我们必须使用`Finalize`方法手动释放它们。
- en: Generations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数
- en: The heap is categorized into three generations so it can handle long-lived and
    short-lived objects. Garbage collection basically reclaims short-lived objects
    that typically occupy only a small part of the heap.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 堆被分为三代，以便它可以处理长期和短期对象。垃圾收集基本上回收了通常只占用堆一小部分空间的短暂对象。
- en: 'There are the following three generations of objects on the heap:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 堆上有以下三代对象：
- en: '**Generation 0**: When an object is initialized, it''s generation gets started.
    It first falls into Generation 0\. This generation''s objects are usually short-lived.
    These objects are more prone to GC for destruction. GC collects these short-lived
    objects so that they can be released to free up memory space. If the objects survive
    from being collected by GC, that means they are going to stay for a longer time,
    thereby being promoted to the next generation.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第0代**：当一个对象被初始化时，它的代数开始。它首先落入第0代。这个代的对象通常是短暂的。这些对象更容易被GC销毁。GC收集这些短暂的对象，以便它们可以被释放出来，从而释放内存空间。如果对象在GC收集后仍然存活，这意味着它们将停留更长的时间，因此被提升到下一代。'
- en: '**Generation 1**: This generation objects live for a longer duration than Generation
    0 objects. GC does collect the objects from this generation, but not so regularly
    as it does for Generation 0 because their existence is extended by the application
    for more operations. Survivors of this generation go to Generation 2.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1代**：这个代的对象比第0代对象存在的时间更长。GC确实会从这个代收集对象，但不像第0代那样频繁，因为它们的生存期被应用程序扩展以进行更多操作。这个代幸存下来的对象将进入第2代。'
- en: '**Generation 2**: These are the longest existing objects in the application.
    Prolonged objects which successfully pass through the previous two generations
    are automatically considered for Generation 2\. GC rarely comes into the picture
    when it comes to releasing these objects.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2代**：这些是在应用程序中存在时间最长的对象。成功通过前两代的对象被认为是第2代。GC在释放这些对象时很少介入。'
- en: Object creation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象创建
- en: Constructors are responsible for giving birth to the object of a particular
    class. If we create any class without a constructor, the compiler will automatically
    create a one default constructor for that class. At least one constructor is present
    in every class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数负责创建特定类的对象。如果我们创建任何没有构造函数的类，编译器将自动为该类创建一个默认构造函数。每个类至少有一个构造函数。
- en: The constructors can be overloaded too which provide a convenient way to build
    the object with different attributes, meaning, it can instantiate the object by
    taking certain parameters (like a normal method) and assign them to its properties
    inside its body (also called as a parameterized constructor). A constructor should
    have the same name as the class name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数也可以重载，这提供了一种方便的方式来使用不同的属性构建对象，这意味着它可以通过接受某些参数（就像一个普通方法一样）并在其体内将其属性赋值（也称为参数化构造函数）来实例化对象。构造函数应该与类名具有相同的名称。
- en: The Copy constructor
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制构造函数
- en: There is another type of constructor called the **Copy constructor**. As the
    name suggests, it can copy one object to the new object (of the same class) which
    is going to be instantiated. In other words, it is a parameterized constructor
    that contains a parameter of same class type. The main purpose of a copy constructor
    is to initialize a new instance to the values of an existing instance. We will
    see how this can be done with an example in a while.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的构造函数称为**复制构造函数**。正如其名所示，它可以复制一个对象到新的对象（同一类的对象）中，该对象将被实例化。换句话说，它是一个包含相同类型参数的参数化构造函数。复制构造函数的主要目的是将新实例初始化为现有实例的值。我们将在稍后的示例中看到如何实现这一点。
- en: Object destruction
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象销毁
- en: We have different ways to destroy an object. Let's explore them one by one.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同的方式来销毁一个对象。让我们逐一探索。
- en: Finalize
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终化
- en: 'Finalizers are used to destroy the objects. We can design Finalizers using
    destructor methods using the tilde (`~`) sign with the class name. We will see
    it in action soon:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器用于销毁对象。我们可以使用带有类名波浪号 (`~`) 符号的析构方法来设计终结器。我们很快就会看到它的实际应用：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Garbage Collector has full control on the finalization process as it internally
    calls this method when objects go out of scope. We can, however, write codes inside
    the destructor to customize our requirements, but we can't just say to someone
    to call the destructor. Even if you are very sure that the object is not required
    anymore and decide to release it, you can't explicitly execute destructor in order
    to free up space. You have to wait until GC collects the object for destruction.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器完全控制着终结过程，因为它在对象超出作用域时内部调用此方法。然而，我们可以在析构函数中编写代码以自定义我们的需求，但我们不能只是告诉某人调用析构函数。即使你非常确定对象不再需要并决定释放它，你也不能显式执行析构函数以释放空间。你必须等待垃圾回收器收集对象以进行销毁。
- en: The finalization process has two collection cycles. In the first cycle, short-lived
    objects are flagged for finalization. In the next cycle, it calls the finalizers
    to release them completely from memory space.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 终结过程有两个收集周期。在第一个周期中，短生命周期的对象被标记为需要终结。在下一个周期中，它调用终结器以完全从内存空间中释放它们。
- en: The IDisposable interface
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`IDisposable` 接口'
- en: Unmanaged resources, as we discussed, are not in direct control of the framework.
    We can easily reclaim these resources inside Finalizers, as we discussed. That
    means, they will be released when the objects are destroyed by the garbage collector.
    However, the GC destroys the objects only when the CLR demands more free memory.
    So, resources may still exist even long even after the object goes out of scope.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，未托管资源不在框架的直接控制之下。我们可以在终结器中轻松回收这些资源，正如我们之前讨论的那样。这意味着，当对象被垃圾回收器销毁时，它们将被释放。然而，垃圾回收器仅在
    CLR 需要更多空闲内存时才会销毁对象。因此，即使对象超出作用域很长时间，资源仍然可能存在。
- en: Thus, there is a need to free up resources as soon as we are done with them.
    Your classes can provide a mechanism to actively manage system resources if they
    implement the `IDisposable` interface. This interface exposes one method, `Dispose()`,
    which clients should call when they finish using an object. You can use the `Dispose`
    method to immediately release resources to perform tasks such as closing files
    and database connections etc. Unlike the `Finalize` destructor, the `Dispose`
    method is not called automatically. Objects must explicitly call `Dispose` when
    they want to release the resources.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要在完成使用资源后立即释放资源。如果你的类实现了 `IDisposable` 接口，它们可以提供一种机制来主动管理系统资源。此接口公开了一个方法，`Dispose()`，当客户端完成对一个对象的使用时应该调用它。你可以使用
    `Dispose` 方法立即释放资源以执行诸如关闭文件和数据库连接等任务。与 `Finalize` 析构函数不同，`Dispose` 方法不是自动调用的。对象必须显式调用
    `Dispose` 以释放资源。
- en: This method is the single method in an `IDisposable` interface and can be used
    to release unmanaged resources manually.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是 `IDisposable` 接口中的唯一方法，可以用来手动释放未托管资源。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now it's just a matter of calling the `Dispose()`. But wait. You can only call
    this method from an object of a class which have implemented this interface and
    defined the `Dispose()` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需调用 `Dispose()` 方法即可。但等等。你只能从实现了此接口并定义了 `Dispose()` 方法的类对象中调用此方法。
- en: 'For example, the `SqlConnection` class has implemented this interface and provided
    us with the `Dispose()` method, which can be used as follows. As soon as you are
    finished using the connection object, call `Dispose`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`SqlConnection` 类实现了此接口，并为我们提供了 `Dispose()` 方法，可以使用如下方式使用它。一旦你完成对连接对象的操作，就调用
    `Dispose`：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is another beautiful way to deal with the disposal of objects in .NET.
    Instead of calling `Dispose` directly, we can use the `using` block. The same
    statement can be decorated with the `using` block coded as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中处理对象销毁的另一种优雅方法是，而不是直接调用 `Dispose`，我们可以使用 `using` 块。相同的语句可以用以下方式用 `using`
    块装饰：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we do this, it converts the code to `try...finally` intermediate code.
    It disposes the connection object inside the `finally` block, which we created.
    Unless you do this, the connection object stays in memory. In due course, when
    we get a huge number of connections, memory starts to leak.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，它将代码转换为 `try...finally` 中间代码。在 `finally` 块中销毁连接对象，这是我们创建的。除非你这样做，否则连接对象将保留在内存中。随着时间的推移，当我们获得大量连接时，内存开始泄漏。
- en: If you are using the finalizer (destructor) method, then make sure to call `Dispose()` inside
    it for the resources you want to deallocate. Thus, you will be doubly sure that
    your resources will be cleaned by GC even if someone forgets to release them in
    their code while using your class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用终结器（析构函数）方法，请确保在其中调用 `Dispose()` 以释放您想要释放的资源。这样，您将确保即使有人在使用您的类时忘记释放它们，资源也会被垃圾回收器清理。
- en: 'Out of curiosity, you must be asking yourself, what would happen if some exception
    occurs before `Dispose()` is called? Will that object be disposed of? The solution
    to this is to wrap that with a `try...finally` block, so that no matter what happens
    to the program, finally will be called and you can dispose of objects inside that.
    To make it simple, the framework has a beautiful thing called the `using` block
    which can be used as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，您可能想知道，如果在调用 `Dispose()` 之前发生了一些异常，会发生什么？那个对象会被释放吗？这个问题的解决方案是将它包裹在一个 `try...finally`
    块中，这样无论程序发生什么情况，`finally` 都会被调用，您可以在其中释放对象。为了简单起见，框架有一个叫做 `using` 块的漂亮功能，可以如下使用：
- en: '`Dispose()` versus `Close()`: Are you confused which one to call for an `SqlConnection`
    object? They are two different methods which solve different problems. `Close()`
    just closes the connection. You can reopen the connection using the same object.
    However, `Dispose()` closes the connection (calls `Close()` under the hood) and
    then deallocates the object from memory. You can''t use the object anymore.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispose()` 与 `Close()`: 对于 `SqlConnection` 对象，您是否感到困惑应该调用哪一个？它们是两种不同的方法，用于解决不同的问题。`Close()`
    仅关闭连接。您可以使用相同的对象重新打开连接。然而，`Dispose()` 关闭连接（在底层调用 `Close()`）然后从内存中释放对象。您不能再使用该对象了。'
- en: You can find out more about Garbage Collector at [https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/)
    上了解更多关于垃圾回收器的信息。
- en: Consider an example
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑一个例子
- en: 'A simple `Order` class can have a default, parameterized, copy constructor
    along with a destructor (to destroy the object):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 `Order` 类可以有一个默认的、参数化的、复制构造函数以及一个析构函数（用于销毁对象）：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see how the constructors are formed using and without the parameters.
    Notice the copy constructor, which takes an object of the same class as an argument
    and inside the body, assigns it's properties to the object in making.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到构造函数是如何使用和不使用参数形成的。注意复制构造函数，它接受一个与同一类相同的对象作为参数，并在体内将它的属性赋值给正在创建的对象。
- en: 'The finalizer implicitly calls `Finalize` on the base class of the object.
    Therefore, when GC calls the Finalizer, that might call a method something like
    shown in the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器隐式地调用对象的基类的 `Finalize` 方法。因此，当垃圾回收器调用终结器时，可能会调用如下所示的方法：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s verify this behavior with a code snippet inside a console app using
    .NET Core 2.0:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 .NET Core 2.0 的控制台应用程序中使用代码片段来验证这种行为：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `DeriveClass2` object is created first which logs the constructor messages.
    Then the `DeriveClass2` destructor is executed. Thus, it is destroyed first when
    the `Main` function execution completes. Additionally, the parent classes have
    destructors. As the child class (`DeriveClass2`) object is already destroyed,
    it runs the parent class destructors too. The following screenshot is taken from
    the output window of visual studio. Make sure you run the app in Release mode:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建 `DeriveClass2` 对象，它记录构造函数消息。然后执行 `DeriveClass2` 的析构函数。因此，当 `Main` 函数执行完成后，它首先被销毁。此外，父类也有析构函数。因为子类
    (`DeriveClass2`) 对象已经被销毁，它也会运行父类的析构函数。以下截图来自 Visual Studio 的输出窗口。请确保以发布模式运行应用程序：
- en: '![](img/ffc917d6-732d-47c0-b688-4056666c2f2e.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffc917d6-732d-47c0-b688-4056666c2f2e.png)'
- en: Implementing the IDisposable Interface
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `IDisposable` 接口
- en: It's important to learn how to implement `IDisposable` interface as you might
    work with a user-defined class in your project which will deal with unmanaged
    resources. The system defines classes using unmanaged resources implement `IDisposable`
    and expose Dispose so that we can easily call that method to dispose of the object
    like we saw in the code snippet for `SqlConnection` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何实现 `IDisposable` 接口很重要，因为您可能在项目中使用用户定义的类来处理非托管资源。系统定义使用非托管资源的类实现 `IDisposable`
    并公开 `Dispose`，这样我们就可以轻松地调用该方法来释放对象，就像我们在 `SqlConnection` 类的代码片段中看到的那样。
- en: There is a pattern called **Dispose Pattern**, which the developers must follow
    while implementing `IDisposable`. Let's explore that. I will go through it step
    by step.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 **Dispose 模式** 的模式，开发者在实现 `IDisposable` 时必须遵循。让我们来探索一下。我会一步一步地讲解。
- en: Step1 -  Basic structure of class
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Step1 - 类的基本结构
- en: We will have an `ExampleIDisposable` class which implements the `IDisposable`
    interface. I am not going to demonstrate usage of unmanaged resources, as our
    intention is to learn the pattern. I just have a console line inside the constructor
    telling that we are acquiring unmanaged resources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个 `ExampleIDisposable` 类，它实现了 `IDisposable` 接口。我不会演示非托管资源的用法，因为我们的目的是学习这个模式。我只是在构造函数中有一个控制台行，说明我们正在获取非托管资源。
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the class contains one managed property which is initialized
    inside the constructor. We will print a line for it. Likewise, we might have some
    property using unmanaged resources declared in the class and given life by the
    constructor. Since we implemented `IDisposable`, we are bound to define the only
    method `Dispose()`. For now, we just have a console line inside this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个类包含一个托管属性，它在构造函数中被初始化。我们将为它打印一行。同样，我们可能有一些在类中声明并由构造函数赋予生命的非托管资源属性。由于我们实现了
    `IDisposable`，我们被迫定义唯一的方法 `Dispose()`。目前，我们只是在其中有一个控制台行。
- en: 'Let''s try it out:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This produces the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/af3d32ed-b02a-4594-b70c-2984ed113c4d.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af3d32ed-b02a-4594-b70c-2984ed113c4d.png)'
- en: We need to understand two important points before moving forward.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们需要理解两个重要的观点。
- en: '**What happens when Finalizer is called by GC? **When an object goes out of
    scope, that will be added to the Finalizer queue for Garbage Collector to take
    action on them to release it from memory. And we don''t know when that will happen.
    If you kill the managed resources inside `Dispose()`, then we need to restrict
    the objects going into the finalizer queue thereby informing GC not to take action
    on them as they don''t exist anymore. Also, that is an overhead for GC.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**当 GC 调用 Finalizer 时会发生什么？**当一个对象超出作用域时，它将被添加到 Finalizer 队列中，垃圾回收器将对其采取行动以从内存中释放它。我们不知道这会发生什么时间。如果你在
    `Dispose()` 中杀死了托管资源，那么我们需要限制进入 Finalizer 队列的对象，从而通知 GC 不要对它们采取行动，因为它们已经不存在了。此外，这对
    GC 来说也是一个开销。'
- en: '**What if the developer forgets to call Dispose? **Suppose, the developer who
    is using our class does not dispose of it. Still, we need to handle this situation.
    We can easily do that by calling `Dispose()` inside Finalizer, but wait! We need
    to ask the `Dispose()` method to kill unmanaged resources only, not managed ones
    because GC is there to automatically deal with them.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果开发者忘记调用 Dispose 会怎样？**假设，使用我们类的开发者没有销毁它。我们仍然需要处理这种情况。我们可以通过在 Finalizer
    中调用 `Dispose()` 来轻松地做到这一点，但是等等！我们需要要求 `Dispose()` 方法只杀死非托管资源，而不是托管资源，因为 GC 会自动处理它们。'
- en: This is where another method comes into the picture.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是另一个方法出现的地方。
- en: Step2 - Defining a Dispose Overload method
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Step2 - 定义一个 Dispose 重载方法
- en: The `Dispose()` method we defined inside the class is going to help us while
    calling it directly through the object of the class. However, we need another
    overload of `Dispose()` inside the class which would answer the questions we previously
    discussed. Let's introduce that to our class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类内部定义的 `Dispose()` 方法将在我们直接通过类的对象调用它时帮助我们。然而，我们还需要在类内部定义另一个 `Dispose()` 重载，这将回答我们之前讨论过的问题。让我们将这个方法引入到我们的类中。
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Modifications done to the `Dispose` methods are explained as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Dispose` 方法所做的修改如下所述：
- en: '`public void Dispose()`: Now, we are asking the `Dispose(bool)` method to release
    all type of resources. `public void Dispose(). GC.SuppressFinalize(this)`; suppresses
    the GC finalizer call, as we have already disposed of everything inside the `Dispose(bool)`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Dispose()`: 现在，我们要求 `Dispose(bool)` 方法释放所有类型的资源。`public void Dispose().
    GC.SuppressFinalize(this)`; 抑制了 GC Finalizer 的调用，因为我们已经在 `Dispose(bool)` 中处理了所有内容。'
- en: '`public void Dispose(bool)`: This method is the important part of this pattern.
    With the `bool` param, it decides whether there is a need to kill the managed
    resources or not'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Dispose(bool)`: 这个方法是这个模式的重要部分。通过 `bool` 参数，它决定是否需要杀死托管资源。'
- en: 'I have replaced the console lines with trace lines so that the `main` method
    ends and we can see the lines on the output screen. If you just remove `Console.ReadLine();`
    from the `Main` method and run the app again, the output produced will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将控制台行替换为跟踪行，这样`main`方法就会结束，我们可以在输出屏幕上看到这些行。如果您只是从`Main`方法中删除`Console.ReadLine();`并再次运行应用程序，生成的输出将如下所示：
- en: '![](img/fd4c2965-f338-4a83-96b1-6dca53511e7c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd4c2965-f338-4a83-96b1-6dca53511e7c.png)'
- en: 'Removal of the `Dispose()` calls from the `Main` method that is `disposable.Dispose();`,
    will result in something as follows. Note to call `GC.Collect();` at the end of
    `Main` method as we did in Step 1:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Main`方法中移除`Dispose()`调用，即`disposable.Dispose();`，将导致以下结果。注意在`Main`方法结束时调用`GC.Collect();`，就像我们在第一步中做的那样：
- en: '![](img/3ab0882c-c4b8-412a-a457-cc9b83b35a01.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ab0882c-c4b8-412a-a457-cc9b83b35a01.png)'
- en: That means whenever developer forgets to dispose, the finalizer is called where
    we have called `Dispose(false);`, which eventually released unmanaged resources.
    Of course, finalizer will remove the managed resources automatically. You can
    see that the lines Someone called Dispose and Managed Resources disposed are missing
    in the last case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论开发者是否忘记丢弃，最终都会调用最终化器，我们在其中调用了`Dispose(false);`，最终释放了非托管资源。当然，最终化器会自动删除托管资源。您可以看到，在最后一种情况下，缺少了“有人调用了Dispose”和“已丢弃托管资源”这两行。
- en: Step3 -Modifying the Dispose(bool) for Derived classes
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 - 修改派生类的Dispose(bool)
- en: As we have `Dispose(bool)` overload, it will be available directly on the object
    to call. There is no need to expose `Dispose(bool)` to the object for the direct
    call as we are internally calling it from `Dispose()` and Finalizer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有`Dispose(bool)`重载，它将直接在对象上可用以调用。我们没有必要将`Dispose(bool)`暴露给对象以进行直接调用，因为我们从`Dispose()`和最终化器内部调用它。
- en: The user should not pass boolean and decide what to dispose of and how. The
    only thing they will do is to call `Dispose()` which will release all type of
    resources. For that reason, we will restrict the call to `Dispose(bool)` by changing
    the access specifier from `public` to `protected`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不应该传递布尔值并决定丢弃什么以及如何丢弃。他们唯一要做的事情是调用`Dispose()`，这将释放所有类型的资源。因此，我们将通过将访问修饰符从`public`更改为`protected`来限制对`Dispose(bool)`的调用。
- en: The `Dispose(bool)` is a logical block for the class which is implementing `IDisposable`.
    Any class which is going to derive a base class implementing `IDisposable` might
    have their own custom logic for disposal. So, instead of adding another dispose
    method, they can just override the base class `Dispose(bool)`. To make that happen,
    we need to prepend a `virtual` keyword before the method name.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispose(bool)`是正在实现`IDisposable`的类的逻辑块。任何将要派生实现`IDisposable`的基类的类都可能有自己的自定义丢弃逻辑。因此，他们不需要添加另一个丢弃方法，只需覆盖基类的`Dispose(bool)`即可。为了实现这一点，我们需要在方法名前添加一个`virtual`关键字。'
- en: 'The preceding paragraphs call for a modification of our very well known method `Dispose(bool)`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的段落要求修改我们非常知名的方法`Dispose(bool)`：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Step 4 - Handling duplicate Dispose calls
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 - 处理重复的Dispose调用
- en: We should manage the scenario where the user might call Dispose more than once.
    If we don't tackle this situation, the subsequent calls will just be unnecessary
    executions for the runtime because the runtime will try to release an object which
    has been already disposed of.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该管理用户可能多次调用`Dispose()`的情况。如果我们不处理这种情况，后续的调用将只是对运行时来说不必要的执行，因为运行时将尝试释放已经被丢弃的对象。
- en: We can easily put a flag inside the class which will indicate whether the object
    was disposed or not.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类内部轻松地放置一个标志，该标志将指示对象是否已被丢弃。
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the `disposed` variable, which is used inside `Dispose(bool)`. We are
    checking if that is true inside the method. If true, then we return/exit from
    the method, otherwise execute the disposal codes. At last, we set it as true.
    So, for the first time `Dispose(bool)` is going to execute fully, after that,
    it will just return once called. This way, we are preventing disposing of the
    same object many times which is an overhead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`disposed`变量，它在`Dispose(bool)`内部使用。我们在方法内部检查它是否为真。如果是真的，那么我们就从方法中返回/退出，否则执行丢弃代码。最后，我们将它设置为真。因此，第一次`Dispose(bool)`将完全执行，之后，它将仅在调用一次后返回。这样，我们防止了多次丢弃同一个对象，这是一个开销。
- en: 'Let''s modify the code to call `Dispose()` multiple times:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改代码以多次调用`Dispose()`：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This would give us the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![](img/ac96fa07-23c1-4416-9e2f-fb32c5d50b49.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac96fa07-23c1-4416-9e2f-fb32c5d50b49.png)'
- en: You can see, for the first call, everything works as expected. The the next
    two subsequent Dispose() calls for the same object results in a simple return
    from the method. That is why we see two sets of Someone called Dispose and Dispose(bool)
    already called messages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，对于第一次调用，一切如预期进行。对于同一对象的下一个两个后续的Dispose()调用，结果只是方法的一个简单返回。这就是为什么我们看到两组“Someone
    called Dispose”和“Dispose(bool) already called”的消息。
- en: 'Alright, I would like to show you the final code after all these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想在所有这些步骤之后展示最终的代码：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Don''t forget that you can use the `using` statement with any class which implements
    `IDisposable`. For instance, let''s write that for `ExampleIDisposable`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你可以使用`using`语句与任何实现了`IDisposable`接口的类一起使用。例如，让我们为`ExampleIDisposable`编写代码：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run this, it would produce the same result as shown in the first screenshot
    under *Step 2: Defining a Dispose Overload method *section.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，它会产生与*步骤2：定义Dispose重载方法*部分下的第一个截图相同的结果。
- en: Object lifetime management in .NET Core
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的对象生命周期管理
- en: In previous chapters, we have already explored how Dependency Injection is built
    into .NET Core. Now that we learned how objects are managed by .NET Framework,
    let's shed some light on their lifestyle in .NET Core.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经探讨了依赖注入是如何集成到.NET Core中的。现在我们已经了解了对象是如何由.NET Framework管理的，让我们来看看它们在.NET
    Core中的生命周期。
- en: 'With just one line, I can say, in Startup, .NET Core takes one class, tags
    a lifetime to it as specified in code, then instantiates and stores it in the
    container or service collection. Consider the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 只用一行代码，我可以说，在启动时，.NET Core会取一个类，给它标记一个生命周期，然后实例化并存储在容器或服务集合中。考虑以下截图：
- en: '![](img/663079d7-0bb5-478d-a787-557867ec8ef7.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/663079d7-0bb5-478d-a787-557867ec8ef7.png)'
- en: 'We will be covering how the following is addressed in .NET Core:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨在.NET Core中如何处理以下内容：
- en: Object Creation.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象创建。
- en: Object's Lifestyles.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的生命周期。
- en: Object's Disposal after everything is done.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成所有工作后对象的处置。
- en: Object creation
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象创建
- en: 'Typically in ASP.NET Core 2.0, an injected type is called a **service**. For
    example, the injected interface is called as `IServiceCollection` and we can add
    services, as we need, by using the `AddSingleton` method here. We will learn more
    about it soon:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在ASP.NET Core 2.0中，注入的类型被称为**服务**。例如，注入的接口被称为`IServiceCollection`，我们可以通过使用这里的`AddSingleton`方法添加所需的服务。我们很快就会了解更多关于它的内容：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The built-in DI framework in ASP.NET Core performs two important steps when
    we perform the preceding code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的代码时，ASP.NET Core内置的DI框架执行两个重要的步骤：
- en: '**Instantiation:** The object of the provided service (example: `ExampleService`)
    is instantiated so that it can be made available to controllers when they are
    called. The object gets injected through constructor injection or property injection.
    `IExampleService` will be an argument to the controller. The implementer of this
    interface `ExampleService` can be instantiated and injected. We will see the constructor
    in a while.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例化**：提供的服务的对象（例如：`ExampleService`）被实例化，以便在调用控制器时可以使用。对象通过构造函数注入或属性注入获得。`IExampleService`将是控制器的参数。这个接口的实现者`ExampleService`可以被实例化和注入。我们稍后会看到构造函数。'
- en: '**Lifetime Management:** Then it decides the lifetime (creation and disposal)
    of the object injected to the controller. There are different types of lifestyles
    served by the framework, which we will learn next.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期管理**：然后它决定注入到控制器中的对象的生命周期（创建和处置）。框架提供了不同类型的生活周期，我们将在下一节学习。'
- en: 'Let''s explore the three-lifetime modes served by *ASP.NET Core* by default.
    The following is a quick reference table for these lifestyles:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索*ASP.NET Core*默认提供的三个生命周期模式。以下是一个关于这些生活周期的快速参考表：
- en: '| **Lifestyle** | **Description** | **Disposal** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **生命周期** | **描述** | **处置** |'
- en: '| Transient (temporary or short-lived) | A new instance will be created each
    time the service is requested. | Never |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 原型（临时或短期） | 每次请求服务时都会创建一个新的实例。 | 从不 |'
- en: '| Scoped (extent or ranged) | An instance will be created for a defined scope.
    When out of scope is reached, another instance will be created, if requested.
    A simple scope can be stated as one `Web Request`. Any resource, requesting the
    instance in a particular `Web Request` will be served the same from the container.
    | Disposed when the scope ends |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 作用域（范围或范围） | 为定义的作用域创建一个实例。当达到作用域结束时，如果需要，将创建另一个实例。一个简单的范围可以表述为一个`Web 请求`。任何请求特定`Web
    请求`实例的资源都将从容器中提供相同的实例。 | 作用域结束时被处置 |'
- en: '| Singleton (single or individual) | One instance created by the container
    which will be used/shared throughout the app for every request. | Disposed when
    the container is disposed |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 单例（单一或个体） | 容器创建一个实例，该实例将在整个应用程序的每个请求中用于/共享。 | 当容器被释放时被销毁 |'
- en: We will look at each concept in detail now. Don't worry, if you are confused
    after reading this. After a well-designed example, you will definitely get the
    concept.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将详细查看每个概念。不用担心，如果你在阅读后感到困惑。在精心设计的例子之后，你肯定会理解这个概念的。
- en: First of all, let's design our ASP.NET MVC Core app to use all these kinds of
    lifetimes. This example is similar to that given in the official documentation,
    which can be found at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设计我们的ASP.NET MVC Core应用程序以使用所有这些类型的生命周期。这个例子与官方文档中给出的例子相似，可以在[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)找到。
- en: 'The main goal here is to understand how the instances stay during the incoming
    requests. We will investigate the instances from two places: one from a controller
    and another from a class. Both these guys will use the same interfaces as dependencies
    injected to their constructors. Let''s go through things step by step.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的主要目标是理解实例在传入请求期间是如何保持的。我们将从两个地方调查这些实例：一个是从控制器，另一个是从一个类。这两个家伙都将使用相同的接口作为构造函数中注入的依赖项。让我们一步一步地来了解这些内容。
- en: Designing the interfaces
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计接口
- en: 'First code an interface `IExampleService` with a `Guid` type property `ExampleId`.
    Then write four interfaces implementing this interface. We have named them according
    to a different type of lifetimes so that we can easily recognize them afterward:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编写一个接口`IExampleService`，它有一个`Guid`类型的属性`ExampleId`。然后编写四个实现此接口的接口。我们根据不同的生命周期类型给它们命名，这样我们就可以在之后轻松地识别它们：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Concrete class
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体类
- en: Abstract which means something which can be conceptualized whereas concrete
    means something which exists in reality and not abstract. Suppose we consider
    three Shapes like a circle, a rectangle, and a square. The shape seems like a
    concept, doesn't it? On the other hand a circle, a rectangle, and a square actually
    have the behavior of shape to represent a concrete idea. An Abstract class is
    incomplete in nature and when a class takes (or inherits) its behavior, it becomes
    complete which is denoted as **Concrete**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象意味着可以概念化的东西，而具体则意味着存在于现实中的东西，而不是抽象的。假设我们考虑三个形状，比如圆形、矩形和正方形。形状看起来像是一个概念，不是吗？另一方面，圆形、矩形和正方形实际上具有形状的行为来表示一个具体的概念。抽象类在本质上是不完整的，当一个类（或继承）其行为时，它就变得完整，这被表示为**具体**。
- en: 'Thus, Abstract (or incomplete) concept is meant to be completed by other classes
    inheriting it, forming *Concrete Classes*. An Abstract class is incomplete and
    just a concept, so instantiating it becomes meaningless. Shape, for instance,
    is not meant to be instantiated, rather it''s meant to be inherited by actual
    shape classes. The following diagram shows the relationship:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抽象（或不完整）的概念意味着通过继承它的其他类来完成，形成*具体类*。抽象类是不完整的，只是一个概念，所以实例化它是没有意义的。例如，形状不是用来实例化的，而是用来被实际的形状类继承的。以下图表显示了这种关系：
- en: '![](img/36b8337a-1d81-4ff2-9ace-c1d5a66d9050.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36b8337a-1d81-4ff2-9ace-c1d5a66d9050.png)'
- en: 'A single `Example` class implements all these interfaces and defines the `ExampleId` guid.
    Two constructors are there: one which takes the `Guid` as a param and the other
    one is the default which initializes a new guid. All those interfaces will be
    resolved as this class in *Startup*. We are approaching that code soon:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的`Example`类实现了所有这些接口，并定义了`ExampleId` guid。有两个构造函数：一个接受`Guid`作为参数，另一个是默认的，它初始化一个新的guid。所有这些接口都将在这个类的*Startup*中解析。我们很快就会接近那段代码：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Service class
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务类
- en: As we said to have a simple class using these interfaces, here is that class
    called as `ExampleService`. We have a constructor here, which is waiting for the
    interfaces to be injected and assigned to local interface type variables.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，使用这些接口创建一个简单的类，这个类被称作`ExampleService`。这里有一个构造函数，它等待接口被注入并分配给局部接口类型变量。
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The controller
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: 'The controller is almost the same as the service class with an additional reference
    of `ExampleService`. It has a constructor to initialize them. The properties of
    `ExampleService` will be printed on a view, that''s why we are referring to that
    class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器几乎与 `Service` 类相同，只是多了一个 `ExampleService` 的引用。它有一个构造函数来初始化它们。`ExampleService`
    的属性将在视图中打印出来，这就是为什么我们引用那个类：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inside `Index()` action, we are returning all these values in `ViewBag`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Index()` 动作中，我们正在将所有这些值返回到 `ViewBag`。
- en: View
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Last, but not least, we will simply design a view which can show all these values
    so that we can start our observation. This would be `Index.cshtml` inside `Views/Example`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们将简单地设计一个视图，以显示所有这些值，这样我们就可以开始观察。这将是 `Views/Example` 中的 `Index.cshtml`。
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we completed the codes. Are you sure? We forgot the main entry point.
    The one which decides what class will be resolved against which interface.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了代码。你确定吗？我们忘记了主要入口点。决定哪个类将针对哪个接口进行解析的那个。
- en: Startup ConfigureServices
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Startup ConfigureServices
- en: 'Now each type of lifestyle is added to the container resolved using `Example`
    class. The class `ExampleService` is resolved for itself. That means, whenever
    we need `ExampleService` anywhere in the app, to be injected, it will automatically
    assign an object of that class with all its properties:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每种类型的生命周期都被添加到使用 `Example` 类解析的容器中。`ExampleService` 类为自己解析。这意味着，无论何时在应用程序的任何地方需要
    `ExampleService` 进行注入，它都会自动分配一个具有所有属性的该类对象：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Add***` methods (with different lifestyles) make sure that the objects are
    created according to the desired behavior expected from them. Once these objects
    are initialized, they can be injected where ever required.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add***` 方法（具有不同的生命周期）确保对象根据预期的行为被创建。一旦这些对象被初始化，它们就可以在任何需要的地方被注入。'
- en: 'If we run the app now, for the first request, we will get the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，对于第一个请求，我们将得到以下输出：
- en: '![](img/9a77645f-5f93-4b86-9e98-17f9d68cf2aa.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a77645f-5f93-4b86-9e98-17f9d68cf2aa.png)'
- en: 'I opened the page in another tab (or you can just refresh the tab). I saw the
    following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我在另一个标签页中打开了页面（或者你也可以简单地刷新标签页）。我看到以下输出：
- en: '![](img/eed82ac7-6517-4824-90c6-44afd3b3ed53.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eed82ac7-6517-4824-90c6-44afd3b3ed53.png)'
- en: Object lifetimes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: Let's examine all the lifetimes one by one according to the values we see in
    these screenshots. The values help us recognize the objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查所有生命周期，根据我们在这些截图中看到的价值。这些值帮助我们识别对象。
- en: Singleton
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: Looking at the screenshots and diagrams, the first thing which is clearly seen
    is the `Singleton` one. No matter how many requests you do after running the app,
    the object will be the same. It does not depend upon the Controller or the `Service`
    class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 观察截图和图表，首先明显看到的是 `Singleton`。无论在运行应用程序后进行多少次请求，对象都是相同的。它不依赖于控制器或 `Service` 类。
- en: Scoped
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: For a particular request, the object is same throughout the scope. Notice how
    the object's guid value is different in the second request. However, the values
    are same for Controller and `Service` class in both the requests. Here the scope
    is the web request. When one more request is served, the object is recreated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的请求，对象在整个作用域内是相同的。注意在第二个请求中对象的 guid 值是如何不同的。然而，在两个请求中，控制器和 `Service` 类的值是相同的。这里的范围是
    Web 请求。当服务另一个请求时，对象将被重新创建。
- en: 'Creating a scope in code is possible though. There is an interface called `IServiceScopeFactory`
    which exposes the method `CreateScope`. `CreateScope` is of the type `IServiceScope`,
    which implements `IDisposable`. Here the `using` block comes to our rescue for
    disposal of the scoped instance:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在代码中创建作用域是可能的。有一个名为 `IServiceScopeFactory` 的接口，它公开了 `CreateScope` 方法。`CreateScope`
    是 `IServiceScope` 类型，它实现了 `IDisposable`。在这里，`using` 块帮助我们处理作用域实例的释放：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We created two scoped instances in the preceding code using `CreateScope`. Both
    are independent of each other and are not shared within a request like a normal
    scoped instance. That is because we manually assigned the scope instead of the
    default Web Request scope.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面代码中使用 `CreateScope` 创建了两个作用域实例。这两个实例相互独立，并且不像普通的作用域实例那样在请求中共享。这是因为我们手动指定了作用域而不是默认的
    Web 请求作用域。
- en: Transient
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时
- en: Simple! A new object is always created whenever requested from the container.
    In the screenshot, you can see the guid values are different in the Controller
    and the `Service` class even for a single request.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！每次从容器请求时都会创建一个新的对象。在截图中，你可以看到即使对于单个请求，控制器和 `Service` 类的 guid 值也是不同的。
- en: Instance
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例
- en: The last one is a special case of Singleton, where the user creates the object
    and provides that to the `AddSingleton` method. So, we are explicitly creating
    the object of the `Example` class ( `services.AddSingleton(new Example(Guid.Empty))`)
    and asking DI framework to register it as a Singleton. In this case, we are sending
    `Guid.Empty`. Thus, an empty guid is assigned which stays unchanged for all requests.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是Singleton的特殊情况，用户创建对象并将其提供给`AddSingleton`方法。因此，我们明确地创建了`Example`类的对象（`services.AddSingleton(new
    Example(Guid.Empty))`），并要求DI框架将其注册为Singleton。在这种情况下，我们发送了`Guid.Empty`。因此，一个空的GUID被分配，对所有请求保持不变。
- en: Object disposal
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象销毁
- en: When we register a service directly with the `Add***` method, the container
    is responsible for creating the object and managing the lifetime. Essentially,
    it calls `Dispose` for the objects, which implement `IDisposable` according to
    the lifetime.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接使用`Add***`方法注册服务时，容器负责创建对象和管理其生命周期。本质上，它会为实现了`IDisposable`接口的对象调用`Dispose`方法，根据生命周期进行管理。
- en: 'Consider the following example where `ServiceDisposable` implements `IDisposable`
    and we told services to manage its lifetime as `Scoped`. Therefore, it will create
    the instance, then make it available across all resources in the app for a single
    request. At last, it disposes of it when the request ends:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中`ServiceDisposable`实现了`IDisposable`，我们告诉服务将其生命周期管理为`Scoped`。因此，它将创建实例，然后在整个应用程序的资源中为单个请求提供它。最后，当请求结束时，它将销毁它：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, when we create the object explicitly and provide that to the DI, we
    need to handle it''s disposal our self. In the following case, we have to manually
    call `Dispose()` somewhere to dispose the instance:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们显式创建对象并将其提供给DI时，我们需要自己处理其销毁。在以下情况下，我们必须在某个地方手动调用`Dispose()`以销毁实例：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When to choose what?
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时选择什么？
- en: It's important how we deal with different objects in our application so that
    they consume limited memory space and resources, yet optimize the performance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理应用程序中的不同对象，以使它们消耗有限的内存空间和资源，同时优化性能，这一点很重要。
- en: Objects which require more space and utilize large server resources should not
    be recreated, rather they should be reused. Database objects, for instance, should
    be reused for all the requests which follow a `Singleton` pattern.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要占用更多空间并使用大量服务器资源的对象不应被重新创建，而应重用。例如，数据库对象应重用于所有遵循`Singleton`模式的后续请求。
- en: Operations which runs in a batch or a loop can be reused in a particular request
    but should be recreated for another. That indicates a Scoped lifetime.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在批量或循环中运行的操作可以在特定请求中重用，但对于另一个请求则应重新创建。这表明是Scoped生命周期。
- en: The `Model` and `View Model` classes should be instantiated every time we try
    to form them. We can't reuse a Model class object while doing a CRUD operation,
    else we might end up with the wrong values going into the database. Of course,
    that is `Transient` as it lives for a short period of time.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们尝试创建`Model`和`View Model`类时，都应该实例化它们。在进行CRUD操作时，我们不能重用`Model`类对象，否则可能会导致错误的值进入数据库。当然，这是`Transient`的，因为它存在的时间很短。
- en: Relationship and dependencies among lifetimes
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期之间的关系和依赖
- en: In this section, we will dig more to find out the relation between the lifetimes.
    The reason is pretty clear. While instantiating our classes with a different type
    of lifestyle, we might face situations where we need dependency of one class in
    another class. But the catch here is that they may not be following a similar
    lifestyle. So, what happens to the instance which is following a scoped lifestyle
    referred inside a `Singleton` class. Does that behave as Scoped?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入挖掘生命周期之间的关系。原因很清楚。当我们用不同类型的生活方式实例化我们的类时，我们可能会遇到需要另一个类依赖一个类的情况。但是，这里的难点是它们可能不遵循类似的生活方式。那么，在`Singleton`类内部引用的遵循scoped生命周期的实例会发生什么？它是否表现得像Scoped？
- en: Let's get our hands dirty and do some code modifications to inject dependencies
    into one another.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手做一些代码修改，将依赖注入到彼此中。
- en: Singleton depending on Scoped and Transient
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据Scoped和Transient选择Singleton
- en: 'First, we need to add two new properties to the existing `IExampleSingleton`
    interface:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向现有的`IExampleSingleton`接口添加两个新属性：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we want to design a new class explicitly for all lifestyles. As we have
    planned, let's inject Transient and Scoped dependencies into this `Singleton`
    class through the constructor. The properties defined for dependent lifestyles
    are assigned values accordingly from the arguments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要为所有生命周期设计一个新类。正如我们计划的，让我们通过构造函数将Transient和Scoped依赖项注入到这个`Singleton`类中。为依赖的生活方式定义的属性将从参数中相应地分配值。
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I have defined all classes in a single place just for the readability purposes
    of this book. You should ideally add them in different files every time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是为了这本书的可读性，在同一个地方定义了所有类。理想情况下，你应该每次都把它们添加到不同的文件中。
- en: The controller is the next place where we need to have an action which will
    return the view where we will show the values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是我们需要添加操作的下一个地方，该操作将返回一个视图，我们将展示其中的值。
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's similar to what we have done with the `Index` action. The difference is
    that we have removed the `SingletonInstance` reference and returned a view called
    as `Singleton`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在`Index`操作中做的是相似的。区别在于我们移除了`SingletonInstance`引用，并返回了一个名为`Singleton`的视图。
- en: 'The view would look something like the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 视图看起来可能如下所示：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, I am trying to print the `ExampleId` of `Singleton` object and properties
    related to the dependent objects (`Transient` and `Scoped`). I have omitted the
    styles from this code which is just to make the table look cool.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我正在尝试打印`Singleton`对象的`ExampleId`以及与依赖对象（`Transient`和`Scoped`）相关的属性。我已经省略了这段代码中的样式，只是为了使表格看起来更酷。
- en: 'It''s time to tell the `Startup` `ConfigureService` to register the classes
    with the appropriate lifestyle:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候告诉`Startup` `ConfigureService`注册具有适当生命周期的类了：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Voila! We are done. Let''s check the output. I have pasted the screenshots
    of two requests done to the controller side by side so that we can easily mark
    the findings:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们完成了。让我们检查输出。我已经并排粘贴了两个请求的截图，这样我们可以轻松地标记发现的内容：
- en: '![](img/f98f9b19-cec3-4dbe-b7ec-7aa5d7e9b4a7.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f98f9b19-cec3-4dbe-b7ec-7aa5d7e9b4a7.png)'
- en: '**Observation**: The `Singleton` object is shared across two requests as the
    underlined `ExampleId` value is same.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察**：由于下划线的`ExampleId`值相同，`Singleton`对象在两个请求之间被共享。'
- en: Hold on! There is something weird. Dependent objects' values are also the same
    across request. Notice the values in red blocks. Even though those classes are
    registered as `Scoped` and `Transient`, they are behaving like a `Singleton`.
    That means the normal lifestyle of these objects is tampered.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！这里有些奇怪。依赖对象的值在请求之间也是相同的。注意红色块中的值。尽管这些类被注册为`Scoped`和`Transient`，但它们的行为像`Singleton`。这意味着这些对象的正常生命周期被篡改了。
- en: '**Inference**: It''s not recommended to refer `Scoped` and `Transient` lifestyle
    classes inside a `Singleton` class as they will lose their usual behavior and
    become Singletons.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**推断**：不建议在`Singleton`类内部引用`Scoped`和`Transient`生命周期类，因为它们将失去其正常行为并变成Singleton。'
- en: Obviously, a `Singleton` class can depend on another a `Singleton` class. Likewise,
    other lifestyles follow the same rule. So, a `Scoped` class can refer another
    `Scoped` class and a `Transient` can refer another `Transient`. They all will
    behave as expected when executed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个`Singleton`类可以依赖于另一个`Singleton`类。同样，其他生活方式遵循相同的规则。因此，一个`Scoped`类可以引用另一个`Scoped`类，一个`Transient`可以引用另一个`Transient`。当执行时，它们都将按预期行为。
- en: Scoped depending on Singleton and Transient
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scoped依赖于Singleton和Transient
- en: 'Similarly, we can test for dependencies inside a `Scoped` class. We will start
    by adding two properties to the interface `IExampleScoped`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在`Scoped`类内部测试依赖关系。我们将从向接口`IExampleScoped`添加两个属性开始：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ExampleScoped` should now implement these two properties. Also, the interfaces
    related to `Transient` and `Singleton` need to be injected into the `constructor`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExampleScoped`现在应该实现这两个属性。同时，与`Transient`和`Singleton`相关的接口需要注入到`constructor`中：'
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A new action is added which will return the view named as `Scoped`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的操作，它将返回名为`Scoped`的视图：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Looks like we are done. Let''s run the app:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经完成了。让我们运行应用程序：
- en: '![](img/ded12cfc-42d1-41fa-a62f-a1699b3d40d5.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ded12cfc-42d1-41fa-a62f-a1699b3d40d5.png)'
- en: Oops! We see an exception screen which says a Circular Dependency was detected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们看到了一个异常屏幕，上面显示检测到一个循环依赖。
- en: '**Circular Dependency**, as the name suggests, is a class which depends on
    another, which in turn, depends on the first class. We designed everything to
    test the dependencies of other lifestyles in Scoped lifestyle, but we forgot one
    thing before doing that. Previously, we added a dependency of `Scoped` class inside
    a `Singleton` class and now, if you see the preceding `ExampleScoped` constructor,
    we now inject `IExampleSingleton`, which is resolved as the `Singleton` class
    `ExampleSingleton`. That''s how it became circular.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环依赖**，正如其名所示，是一个依赖于另一个类的类，而另一个类又反过来依赖于第一个类。我们设计了一切来测试Scoped生活方式中其他生活方式的依赖，但在做之前，我们忘记了一件事。之前，我们在`Singleton`类内部添加了`Scoped`类的依赖，现在，如果你看到前面的`ExampleScoped`构造函数，我们现在注入`IExampleSingleton`，它被解析为`Singleton`类`ExampleSingleton`。这就是它变成循环的原因。'
- en: 'Therefore, we need to remove the dependencies from the `Singleton` class to
    test. We can also test by doing another interface and class for `Singleton`. So,
    when you fix the code, we will get the following output. I am not going to write
    the codes of the `View` here. It''s pretty much the same as we done in `Singleton`.
    We just need to print `ExampleId`, `SingletonExampleId` and `TransientExampleId`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要从`Singleton`类中移除依赖以进行测试。我们还可以通过为`Singleton`创建另一个接口和类来进行测试。所以，当你修复代码时，我们将得到以下输出。我这里不会写`View`的代码。它与我们在`Singleton`中做的几乎一样。我们只需要打印`ExampleId`、`SingletonExampleId`和`TransientExampleId`：
- en: '![](img/157c30df-1f4d-4d51-817f-978969316d74.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/157c30df-1f4d-4d51-817f-978969316d74.png)'
- en: '**Observation:** In the red boxes, we have transient object values. That is
    because they are not `Transient` anymore and behave like `Scoped`, as the values
    are the same in a request, which is not what `Transient` looks like. It should
    be different every time it is requested. But in the case of `Singleton` dependency,
    it is the same across requests, which not only satisfies the `Singleto`n paradigm
    but also behaves like scoped in a particular request.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察：** 在红色框中，我们有瞬态对象值。这是因为它们不再是`Transient`了，它们的行为像`Scoped`一样，因为值在请求中是相同的，这并不是`Transient`的样子。它应该在每次请求时都不同。但在`Singleton`依赖的情况下，它在请求之间是相同的，这不仅满足了`Singleton`范式，而且在特定请求中表现得像`Scoped`。'
- en: '**Inference:** That''s why it is recommended to use `Scoped` and `Singleton`
    dependencies inside a `Scoped` class, but not Transient.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**推断：** 这就是为什么建议在`Scoped`类内部使用`Scoped`和`Singleton`依赖，而不是`Transient`。'
- en: Transient depending on Singleton and Scoped
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Transient依赖于Singleton和Scoped
- en: 'The following the same pattern for `Transient`, we will design the interface
    and class as required. The interface will look like the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Transient`，我们将按照相同的模式设计所需的接口和类。接口看起来如下：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next is the `Transient` class depending on `Singleton` and `Scoped`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Transient`类依赖于`Singleton`和`Scoped`。
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Last, but not the least, a new action to render the view `Transient`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，一个新的动作来渲染视图`Transient`：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running this after designing the view will end up with something like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计视图之后运行，最终结果可能如下所示：
- en: '![](img/964da5d3-1efd-41bf-a166-cb3cd8aa5334.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/964da5d3-1efd-41bf-a166-cb3cd8aa5334.png)'
- en: You can see how the `Transient` `ExampleId` differs in inside and outside the
    request.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`Transient` `ExampleId`在请求内外是如何不同的。
- en: '**Observation:** You must be wondering why I don''t have red boxes in this
    picture. That is because everything looks perfect. `Singleton` is the same everywhere
    and `Scoped` is the same in a particular request, however, changes in the next
    request.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察：** 你可能想知道为什么这张图片中没有红色框。那是因为一切看起来都很完美。`Singleton`到处都是相同的，`Scoped`在特定请求中是相同的，然而，在下一个请求中会有变化。'
- en: '**Inference:** That means, both these dependencies carry their usual characteristics
    when injected inside a *Transient* class. Also, another *Transient* dependency
    will definitely work if injected to a *Transient* class.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**推断：** 这意味着，这两种依赖在注入到*Transient*类内部时都保留了它们通常的特性。另外，如果注入到*Transient*类，另一个*Transient*依赖肯定也能工作。'
- en: Saying all this, I would say these are the recommended patterns to follow while
    injecting one lifestyle into another. We should be careful while designing the
    classes and their lifestyle. Either we will end up in a Circular Dependency or
    lose the appropriate behavior of the lifestyle injected as we saw in the preceding
    examples. We can still mix it up as long as we are aware of the consequences.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，我想说的是，这些都是将一种生活方式注入到另一种生活方式时应遵循的推荐模式。在设计类及其生活方式时，我们应该小心。要么我们最终会陷入循环依赖，要么会失去注入到生活方式中的适当行为，正如我们在前面的例子中所看到的。只要我们意识到后果，我们仍然可以混合使用。
- en: 'With just a simple table, I can represent the whole point:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 只用一个简单的表格，我就能表达整个要点：
- en: '![](img/99131700-c1b9-4a79-a682-50d2c5038a10.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99131700-c1b9-4a79-a682-50d2c5038a10.png)'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how objects are created and destroyed by .NET
    Framework. Creation and destruction mechanism were discussed. *Garbage Collector*
    plays an important role in the automatic disposal through Finalizers, which we
    analyzed through examples.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了.NET Framework如何创建和销毁对象。我们讨论了创建和销毁机制。*垃圾回收器*在通过终结器自动处理中扮演着重要角色，我们通过示例进行了分析。
- en: Most importantly, we saw a step-by-step walkthrough to manually dispose of objects
    as soon as we are done by implementing the `IDisposal` interface.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们看到了如何通过实现`IDisposal`接口来手动处理对象的步骤分解。
- en: After that, we explored the different lifetimes maintained by objects in .NET
    Core. We saw examples using the controller and service classes. We learned how
    the objects are created and disposed of. Most importantly, we experimented with
    the adaptability of different lifestyles with each other.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们探讨了.NET Core中对象维护的不同生命周期。我们通过控制器和服务类示例了解了对象的创建和销毁过程。最重要的是，我们实验了不同生活方式之间的适应性。
- en: Interception, another pillar of DI, will be covered in [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml),
    *Interception*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的另一个支柱——拦截，将在[第7章](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml)“拦截”中介绍。
