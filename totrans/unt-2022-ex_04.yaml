- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Creating a 2D Collection Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个2D收集游戏
- en: In [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015), you were introduced to the
    Unity Editor and its common windows and toolbars. We also created our first player
    character – the ladybug! Sadly, the ladybug is currently sitting in a vast nothingness
    without any goals providing value for its existence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18347_01.xhtml#_idTextAnchor015)中，你被介绍了Unity编辑器和其常见的窗口和工具栏。我们还创建了我们的第一个玩家角色——瓢虫！遗憾的是，瓢虫目前正坐在一片浩瀚的虚无之中，没有任何目标为其存在提供价值。
- en: In this chapter, we’ll start putting the previous knowledge gained to good use
    by first adding more GameObjects to our Scene and creating a 2D, top-down environment
    for the *Outer World* collection game (our ladybugs will be happy indeed).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过首先向场景中添加更多的GameObject并创建一个为*外部世界*收集游戏（我们的瓢虫们确实会感到高兴）的2D、自上而下环境来开始将之前获得的知识付诸实践。
- en: Creating a 2D top-down environment and designing a level is a trivial task when
    using the **Tilemap** feature. It allows you to create a palette of **Tiles**
    and then simply draw the level right within the Unity scene View.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Tilemap**功能创建2D自上而下环境和设计关卡是一个简单的任务。它允许你创建一个**瓦片**调色板，然后只需在Unity场景视图中直接绘制关卡。
- en: There is only so much you can do with GameObjects and Unity’s built-in components
    alone, so you’ll be introduced to the **C#** language. Writing your own scripts
    in C# allows you to create the functionality your games and experiences require.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用GameObject和Unity的内置组件所能做的有限，因此你将接触到**C#**语言。用C#编写自己的脚本允许你创建游戏和体验所需的功能。
- en: We’ll discuss how to create scripts and understand the best-practice approach
    to structuring code, principles, and patterns to follow that will keep your code
    easy to work with, maintain, and extend. These approaches to writing code will
    benefit you individually but also in a team environment, working with other professionals,
    since the structure and practices are widely adopted in the industry.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何创建脚本，并了解编写代码的最佳实践方法，包括结构、原则和模式，这将使你的代码易于工作、维护和扩展。这些编写代码的方法将对你个人以及团队环境中的工作都有益，因为在行业中广泛采用了这些结构和实践。
- en: The first C# script we’ll be tackling is a **controller** to solve the problem
    of our ladybug character not having the ability to move. Throughout the book,
    we will use a *problem-solving* approach to define the process because it frames
    the coding requirements with an analytical mindset, breaking down a problem into
    smaller tasks while considering the overall solution. We’ll also be working with
    player input, so you’ll learn how to set up and connect your code to Unity’s new
    event-based **Input System**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的第一个C#脚本是一个**控制器**，用于解决我们的瓢虫角色无法移动的问题。在整个书中，我们将使用一种*问题解决*的方法来定义过程，因为它以分析的心态来界定编码需求，将问题分解成更小的任务，同时考虑整体解决方案。我们还将处理玩家输入，因此你将学习如何设置和连接你的代码到Unity的新基于事件的**输入系统**。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating a 2D, top-down game environment with **Tilemap**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Tilemap**创建一个2D、自上而下的游戏环境
- en: An introduction to creating scripts in C# – IDE, SOLID principles, and design
    patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中创建脚本的介绍——IDE、SOLID原则和设计模式
- en: Coding a simple player controller with the new Input System
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新输入系统编写简单的玩家控制器
- en: By the end of this chapter, you’ll be able to quickly create a 2D, top-down,
    tile-based game environment, design a level, and understand how to create and
    edit C# scripts while considering best practice principles and design patterns.
    Our ladybug character will also be able to explore a cool new environment by responding
    to player input.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够快速创建一个2D、自上而下、基于瓦片的游戏环境，设计一个关卡，并了解如何在考虑最佳实践原则和设计模式的同时创建和编辑C#脚本。我们的瓢虫角色也将能够通过响应玩家输入来探索一个酷炫的新环境。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along in this chapter, you’ll need to have **Visual Studio Community
    2022** installed; we will be using this version throughout the chapters and projects
    in the book. This should have been installed with the Unity Editor in [*Chapter
    1*](B18347_01.xhtml#_idTextAnchor015).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的内容，你需要安装**Visual Studio Community 2022**；我们将在整个章节和书中的项目中使用这个版本。这应该已经在[*第一章*](B18347_01.xhtml#_idTextAnchor015)中与Unity编辑器一起安装了。
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上下载完整项目：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Creating a 2D, top-down game environment with Tilemap
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tilemap创建2D、俯视游戏环境
- en: The first thing we will accomplish to create the collection game environment
    is some level design. The design of the level will affect how the game plays –
    how fun and how challenging it is. This will not be a comprehensive dive into
    level design; after all, we’re making a very simple collection game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先完成的事情来创建收集游戏环境是进行一些水平设计。级别的设计将影响游戏玩法——游戏的乐趣和挑战性。这不会是一个对水平设计的全面深入研究；毕竟，我们正在制作一个非常简单的收集游戏。
- en: We’ll be focusing on just one principle of level design right now – guiding
    the player. Since this is a 2D, top-down view, the easiest way for us to guide
    the player is by using shapes in the level and introducing hazards. We can only
    do so much with such a simple game, but the principles can be applied to larger
    and more complex games.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将专注于水平设计的一个原则——引导玩家。由于这是一个2D、俯视视角的游戏，我们引导玩家的最简单方法就是使用水平中的形状并引入危险。在这样的简单游戏中我们能做的有限，但这些原则可以应用于更大、更复杂的游戏。
- en: 'Visualizing design isn’t everyone’s strong suit – we all need creative help
    and inspiration sometimes. And while a **Game Design Document** (**GDD**) is good
    at describing things, it can only convey so much in so many words. As they say,
    a picture is worth a thousand words, so have a look at my initial sketch of what
    I was planning for the collection game’s level design:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的可视化不是每个人的强项——我们有时都需要创造性的帮助和灵感。虽然**游戏设计文档**（**GDD**）擅长描述事物，但它只能用这么多字来传达。正如人们所说，一张图胜过千言万语，所以看看我最初为收集游戏级别设计所做的草图：
- en: '![Figure 2.1 – The collection game-level sketch](img/B18347_02_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 收集游戏级别的草图](img/B18347_02_01.jpg)'
- en: Figure 2.1 – The collection game-level sketch
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 收集游戏级别的草图
- en: If you’re lacking inspiration or just prefer to follow along (no one here will
    judge you for it), then use my sketch for your own ends. I’ll probably sound like
    a broken record by the time you’re well into this book, but remember this – if
    you’re not having fun, you’re doing something wrong.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你缺乏灵感或者只是喜欢跟随（这里没有人会因为你这样做而评判你），那么就使用我的草图来达到你自己的目的。当你深入这本书的时候，我可能听起来就像一个破唱片，但请记住这一点——如果你不觉得开心，你就是在做错事。
- en: Next, let’s explore some examples of guiding the player.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索一些引导玩家的例子。
- en: Level design – Guiding the player
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水平设计 – 引导玩家
- en: By creating shapes in the level (also known as **leading lines**), we encourage
    the player to move in desirable directions. For example, from the position the
    player is spawned in, let’s start by giving them an open area directly in front
    of them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在水平中创建形状（也称为**引导线**），我们鼓励玩家向期望的方向移动。例如，从玩家生成的位置开始，让我们先给他们一个直接在他们面前的开阔区域。
- en: The sides of this open area will begin to angle inward as it gets farther from
    the player in the direction they face. This will create the appearance of an arrow
    shape. This shape will invite the player subconsciously to move forward in the
    direction the “arrow” is pointing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个开阔区域的一侧将开始向内倾斜，随着它远离玩家面对的方向，这将创造出箭头形状。这种形状会无意识地引导玩家向前移动，朝着“箭头”所指的方向。
- en: Spawn/respawn/despawn player
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 生成/重生/消失玩家
- en: '**Spawning** refers to the creation of the player in the game. This typically
    occurs at the beginning of gameplay when starting the game or when starting a
    level.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成**指的是在游戏中创建玩家。这通常发生在游戏开始时，或者在开始一个关卡时。'
- en: A **respawn** is when the player is spawned after death or some game event that
    requires the player to restart at a specific position.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**重生**是指玩家在死亡或需要玩家在特定位置重新开始的某些游戏事件后重新生成。'
- en: When the player is **despawned**, they are removed from the game world.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家**消失**时，他们将从游戏世界中移除。
- en: Shapes are one of the tools we have in level design to guide the player through
    the environment, while another is hazards. Let’s have a look at using hazards
    in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 形状是我们水平设计中用来引导玩家通过环境的工具之一，另一个是危险。让我们在下一节中看看如何使用危险。
- en: Hazards
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 危险
- en: The level design in a video game can influence the player’s movement through
    visual cues, and one of those cues is hazards. These elements can guide the player
    toward their next objective and progress gameplay forward while also changing
    the level’s difficulty by placing hazards in areas that the player must visit
    to complete the game’s objectives.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，关卡设计可以通过视觉提示影响玩家的移动，其中之一就是危险元素。这些元素可以引导玩家向下一个目标前进，推动游戏进程，同时通过在玩家必须访问以完成游戏目标的地方放置危险元素来改变关卡难度。
- en: Additional reading | 2D level design
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读材料 | 2D关卡设计
- en: 'Level Design Patterns in 2D Games by *Ahmed* *Khalifa*: [https://www.gamedeveloper.com/design/level-design-patterns-in-2d-games](https://www.gamedeveloper.com/design/level-design-patterns-in-2d-games)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 《2D游戏中的关卡设计模式》由*Ahmed* *Khalifa*著：[https://www.gamedeveloper.com/design/level-design-patterns-in-2d-games](https://www.gamedeveloper.com/design/level-design-patterns-in-2d-games)
- en: In this section, you learned that shapes and hazards are simple concepts to
    guide the player, and they can be used with great effect if done well. It takes
    practice to make guidance subtle and blended/hidden into an environment design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解到形状和危险元素是简单的概念，可以引导玩家，如果做得好，它们可以产生很好的效果。要使引导微妙并融入/隐藏到环境设计中，需要练习。
- en: Let’s start practicing by creating the level for the 2D collection game. In
    the next section, we’ll be using the **Tilemap** feature that is a part of Unity’s
    2D toolset, and the first step in this workflow is to create a **Tile Palette**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建2D收集游戏关卡来开始练习。在下一节中，我们将使用Unity 2D工具集的一部分，即**Tilemap**功能，这个工作流程的第一步是创建一个**Tile
    Palette**。
- en: Creating Tile Palettes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Tile Palettes
- en: 'You may have closed Unity since the last time we worked on the player character
    in [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015). To return where we left off
    in the project, open Unity Hub. The default view will list all of the projects
    you previously created. The list also includes some additional information about
    the project, such as the last time it was modified and the Editor version being
    used for it. You can see an example of this in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在上次我们处理玩家角色时关闭了Unity。要返回项目中我们上次停止的地方，请打开Unity Hub。默认视图将列出你之前创建的所有项目。列表还包括一些关于项目的附加信息，例如上次修改时间和用于它的编辑器版本。以下截图是一个示例：
- en: '![Figure 2.2 – The Unity Hub Projects list](img/B18347_02_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – Unity Hub项目列表](img/B18347_02_02.jpg)'
- en: Figure 2.2 – The Unity Hub Projects list
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Unity Hub项目列表
- en: Adding and removing projects from Unity Hub
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unity Hub添加和删除项目
- en: You can add and remove projects from Unity Hub to keep your project list relevant.
    Add a project from disk by using the **Open** button at the top right of the window.
    Use the horizontal ellipses on the right side of each entry in the list to remove
    the project. Please note that removing a project from Hub will not delete it from
    the disk and will have to be cleaned up manually outside of Hub.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Unity Hub添加和删除项目以保持项目列表的相关性。通过使用窗口右上角的**打开**按钮从磁盘添加项目。使用列表中每个条目右侧的水平省略号来删除项目。请注意，从Hub中删除项目不会从磁盘上删除它，并且需要在Hub外手动清理。
- en: Open the project you previously created from the **2D URP Core** template (in
    the screenshot shown in *Figure 2**.2*, it is the **My Project** project). Do
    that by simply clicking on the project name in the list.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你之前从**2D URP Core**模板（如图2.2所示，它是**My Project**项目）创建的项目。只需在列表中单击项目名称即可完成此操作。
- en: Before actually creating our tilemap, we need sprite images to work with. The
    following section will address adding sprites to the project that will form the
    basis of our first tilemap, used to construct the game’s level.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际创建我们的瓦片地图之前，我们需要一些精灵图像来工作。以下部分将介绍向项目中添加精灵，这些精灵将构成我们第一个瓦片地图的基础，用于构建游戏关卡。
- en: 2D game assets
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2D游戏资源
- en: To create the environment for our level, we’ll be using some freely available
    game assets. We’ll use original art assets in the upcoming chapters with different
    art pipelines and workflows, so you will gain a more rounded knowledge when dealing
    with 2D art in Unity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们关卡的环境，我们将使用一些免费提供的游戏资源。在接下来的章节中，我们将使用原始艺术资源，并采用不同的艺术流程和工作流程，这样你将获得更全面的知识，当处理Unity中的2D艺术时。
- en: Free game assets
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 免费游戏资源
- en: '**Kenney** provides readymade game assets with no strings attached! Thousands
    of sprites are available – for many different themes and genres – for you to use
    in your own projects, with any kind of use allowed, even commercial. You can find
    all of the Kenney assets listed here: [https://kenney.nl/assets](https://kenney.nl/assets)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kenney**提供无附加条件的现成游戏资源！数千个精灵可供使用——适用于许多不同的主题和流派——您可以在自己的项目中使用，任何类型的用途都允许，甚至包括商业用途。您可以在以下位置找到所有Kenney资源列表：[https://kenney.nl/assets](https://kenney.nl/assets)'
- en: '**Kenney** is a website that provides many pre-made sprite sheets and tilemap
    images. The main difference between these two graphics terms can be broken down
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kenney**是一个提供许多预制精灵图集和瓦片图资源的网站。这两个图形术语之间的主要区别可以概括如下：'
- en: A **sprite sheet image** is an image made up of several smaller images (the
    left image in *Figure 2**.5*)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精灵图集图像**是由几个较小的图像组成的图像（*图2.5*中的左侧图像）'
- en: A **tilemap image** is an image made up of several smaller images arranged in
    a two-dimensional grid (the right image in *Figure 2**.5*)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瓦片图**是由几个较小的图像组成的图像，这些图像以二维网格的形式排列（*图2.5*中的右侧图像）'
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: The terms *sprite sheet* and *tilemap* are often used interchangeably without
    much difference in meaning. I’ve attempted to clarify the terms practically and
    provide examples in the following sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵图集**和**瓦片图**这两个术语经常被互换使用，意义差别不大。我在以下章节中尝试从实际角度澄清这些术语，并提供示例。'
- en: 2D art is generally provided in sprite sheets since a single image is a more
    optimized way of working with images in a game engine instead of using individual
    images for each asset. Even if the 2D art is provided in single images, Unity
    has tooling that combines the individual sprite images into a single image for
    optimization (in this case, the combined or packed image in Unity is referred
    to as a **Sprite Atlas**). As mentioned previously, Kenney provides game assets
    in both sprite sheets and tilemap images.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 2D艺术通常以精灵图集的形式提供，因为单个图像是在游戏引擎中处理图像的更优方式，而不是为每个资产使用单独的图像。即使2D艺术以单个图像的形式提供，Unity也有工具可以将单个精灵图像组合成单个图像以进行优化（在这种情况下，Unity中的组合或打包图像被称为**精灵图集**）。如前所述，Kenney提供以精灵图集和瓦片图形式的游戏资源。
- en: Optimization note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 优化注意事项
- en: Sprite sheets are *more optimized* because they reduce the number of draw calls
    the renderer (graphics card) has to perform. All of the sprites included on the
    sheet can be drawn simultaneously, treating the entire sprite sheet as a single
    draw, whereas if they were individual sprites, they would need to be drawn separately.
    This reduction in draw calls can improve game performance (increasing the frame
    rate).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集更加**优化**，因为它们减少了渲染器（显卡）必须执行的绘制调用次数。图集上包含的所有精灵可以同时绘制，将整个精灵图集视为单个绘制，而如果它们是单独的精灵，则需要单独绘制。这种减少绘制调用的次数可以提高游戏性能（提高帧率）。
- en: Now that we understand what 2D game asset images are, let’s import some assets
    from Kenney in the next section to understand importing and working with the images
    in practice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了2D游戏资产图像是什么，让我们在下一节中从Kenney导入一些资产，以了解实际导入和使用图像的过程。
- en: Importing sprites
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入精灵
- en: 'Importing images into Unity is easy, but let’s first start with defining some
    organization in our project by creating some folders. Perform the following steps
    to create the `Sprites`, `Tile Palettes`, and `Tile` `Palettes/Tiles` folders:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像导入Unity很容易，但让我们首先通过创建一些文件夹来定义我们项目中的组织结构。按照以下步骤创建`Sprites`、`Tile Palettes`和`Tile
    Palettes/Tiles`文件夹：
- en: In the `Assets` folder.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets`文件夹中。
- en: Right-click within the **Project** window to bring up the **Create** menu (or
    click on the **+** button at the top just under the **Project** tab) and select
    **Create** | **Folder**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口内右键点击以打开**创建**菜单（或者在**项目**标签上方直接点击**+**按钮）并选择**创建** | **文件夹**。
- en: Name the folder `Sprites` and hit *Enter*.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件夹命名为`Sprites`并按*Enter*键。
- en: Repeat *step 2* to create the `Tile` `Palettes` folder.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*以创建`Tile Palettes`文件夹。
- en: Now, after selecting the `Tile Palettes` folder, repeat *step 2* to create the
    `Tiles` folder (this folder is a subfolder of the `Tile` `Palettes` folder).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在选择了`Tile Palettes`文件夹后，重复*步骤2*以创建`Tiles`文件夹（此文件夹是`Tile Palettes`文件夹的子文件夹）。
- en: We’ll be using two sprite sheets from Kenney in the collection game project
    to create the game environment – the **Top-down Tanks Redux** and **Tower Defense**
    (**top-down**) game assets. You can get the sprite sheets by downloading them
    directly from the [https://kenney.nl/assets](https://kenney.nl/assets) website,
    or they are also provided in the book’s project files available in the GitHub
    project (refer to the link in the *Technical* *requirements* section).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在集合游戏项目中使用 Kenney 的两个精灵图集来创建游戏环境 – **俯视坦克 Redux** 和 **塔防**（**俯视**）游戏资源。您可以直接从
    [https://kenney.nl/assets](https://kenney.nl/assets) 网站下载精灵图集，或者它们也包含在 GitHub
    项目中提供的书籍项目文件中（参考 *技术要求* 部分的链接）。
- en: Once the folders are created and the sprite sheets have downloaded, we are now
    ready to import sprites. Yay!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了文件夹并下载了精灵图集，我们现在就可以导入精灵了。太好了！
- en: You can import sprites into Unity by either dragging them from the File Manager
    (Windows)/Finder (Mac) and dropping them into the Unity **Project** window or
    by right-clicking within the **Project** window and selecting **Import** **New
    Asset…**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从文件管理器（Windows）/Finder（Mac）拖动它们并将它们拖放到 Unity **项目** 窗口中，或者通过在 **项目** 窗口中右键单击并选择
    **导入** **新资源…** 来将精灵导入 Unity。
- en: First, we will be working with the *Tower Defense (top-down)* game asset’s `towerDefense_tilesheet.png`
    sprite sheet. Import the image into the `Assets/Sprites` folder, and once the
    asset has finished importing, selecting it in the **Project** window will display
    the sprite import settings in the **Inspector** window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 *塔防（俯视）* 游戏资源的 `towerDefense_tilesheet.png` 精灵图集。将图像导入到 `Assets/Sprites`
    文件夹中，一旦资源导入完成，在 **项目** 窗口中选择它将在 **检查器** 窗口中显示精灵导入设置。
- en: '![Figure 2.3 – Sprite import settings](img/B18347_02_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 精灵导入设置](img/B18347_02_03.jpg)'
- en: Figure 2.3 – Sprite import settings
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 精灵导入设置
- en: Since the sprite sheet comprises many images, we first want to change **Sprite
    Mode** to **Multiple**. Any time you change the import settings, you’ll have to
    click the **Apply** button at the bottom of the list of fields. Once clicked,
    we’ll move on to slicing the sprite sheet to create the individually selectable
    sprites.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精灵图集包含许多图像，我们首先想要将 **精灵模式** 改为 **多个**。每次更改导入设置时，您都必须点击字段列表底部的 **应用** 按钮。一旦点击，我们将继续切片精灵图集以创建可单独选择的精灵。
- en: Power of two textures
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 2 的幂纹理
- en: It is best to size textures with dimensions that are powers of two on all sides.
    The sizes are 2, 4, 8, 16, 32, 64, 128, 256, 512, 1,024, or 2,048 pixels (px).
    Note that the textures do not have to be square (for example, 256 x 1,024). Unity
    will use the non-power of two textures, although they will not be compressed (taking
    up more video memory) and not optimized (in some cases, slower to load and render).
    The **Inspector** window will display a warning when they cannot be compressed,
    as seen at the bottom of *Figure 2**.3*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将纹理的尺寸设置为所有边都是 2 的幂的尺寸。尺寸为 2、4、8、16、32、64、128、256、512、1,024 或 2,048 像素（px）。请注意，纹理不必是正方形的（例如，256
    x 1,024）。Unity 将使用非 2 的幂纹理，尽管它们不会被压缩（占用更多视频内存）并且不会优化（在某些情况下，加载和渲染速度较慢）。当它们无法被压缩时，**检查器**窗口将显示警告，如图
    2.3* 底部所示。
- en: Slicing the sprite sheet
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切片精灵图集
- en: With **Sprite Mode** set to *Multiple*, the imported image is now treated as
    a sprite sheet, with several smaller images needing to be defined. If we skip
    this step, all of the smaller images within the sprite sheet image will not be
    accessible, and we won’t be able to assign them to a **Sprite Renderer** or create
    tiles for use in the **Tilemap** **Tile Palette** for drawing or filling in our
    level.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **精灵模式** 设置为 *多个* 时，导入的图像现在被视为精灵图集，需要定义几个较小的图像。如果我们跳过此步骤，精灵图集中的所有较小图像将无法访问，我们无法将它们分配给
    **精灵渲染器** 或为在 **瓦片地图** **瓦片调色板** 中绘制或填充我们的关卡创建瓦片。
- en: Open the Sprite Editor by clicking the **Sprite Editor** button just below the
    **Sprite Mode** section fields (refer to *Figure 2**.3*). You’ll see that the
    sprite sheet is actually a tilemap image because the sprites are already arranged
    in a two-dimensional grid for us. This makes slicing easy-peasy!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击 **精灵编辑器** 按钮位于 **精灵模式** 部分字段下方来打开精灵编辑器（参考 *图 2.3*）。您会看到精灵图集实际上是一个瓦片地图图像，因为精灵已经为我们排列在一个二维网格中。这使得切片变得轻而易举！
- en: Next, click the `64` and `64`. This Kenney tilemap’s sprite cells are 64 pixels
    square, but you may end up working with sprites of different sizes, so you will
    have to set this value accordingly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击`64`和`64`。这个 Kenney 瓦片图的精灵单元是 64 像素方形，但你可能需要处理不同大小的精灵，因此你必须相应地设置此值。
- en: 'We can keep the default values for the remainder of the fields in the dialog,
    so proceed to slice the image into sprites by clicking the **Slice** button. The
    slicing results should appear like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保留对话框中其余字段的默认值，然后通过点击**切片**按钮继续将图像切片成精灵。切片结果应如下所示：
- en: '![Figure 2.4 – The Sprite Editor Tower Defense (top-down) tilemap](img/B18347_02_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 精灵编辑器塔防（俯视）瓦片图](img/B18347_02_04.jpg)'
- en: Figure 2.4 – The Sprite Editor Tower Defense (top-down) tilemap
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 精灵编辑器塔防（俯视）瓦片图
- en: Trimming sprites
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪精灵
- en: For some sprites that don’t completely fill the grid cell, you may get some
    bleeding from neighboring sprites if some of the spacing was not adjusted just
    right. This is easy to fix by clicking on the offending sprite in the Sprite Editor
    and then clicking the **Trim** button (directly to the right of the **Slice**
    button).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些没有完全填满网格单元的精灵，如果某些间距没有调整得恰到好处，你可能会从相邻的精灵中得到一些溢出。这可以通过在精灵编辑器中点击有问题的精灵，然后点击**裁剪**按钮（位于**切片**按钮的右侧）来轻松修复。
- en: Let’s proceed to slice the other Kenney asset we’ll be using for the objects
    in the environment of the collection game now – the *Top-down Tanks Redux* game
    asset’s `Assets/Sprites/topdowntanks_onlyObjects_default.png` sprite sheet.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续切片我们将用于收集游戏环境中的对象的另一个 Kenney 资产 – `Top-down Tanks Redux` 游戏资产的 `Assets/Sprites/topdowntanks_onlyObjects_default.png`
    精灵图集。
- en: Again, after importing, select the image in the **Project** window to display
    the import settings in the **Inspector** window, set **Sprite Mode** to **Multiple**,
    click the **Apply** button (at the bottom), and finally, click the **Sprite**
    **Editor** button.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，导入后，在**项目**窗口中选择图像以在**检查器**窗口中显示导入设置，将**精灵模式**设置为**多个**，点击底部的**应用**按钮，最后点击**精灵****编辑器**按钮。
- en: You’ll likely notice right away that something is different with this image
    – it’s not a tilemap. Kenney provides game assets as sprite sheets for more game
    engines than just Unity. While this sprite sheet may work well in some other game
    engines, it, unfortunately, does not in Unity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会立即注意到这张图片的不同之处 – 它不是一个瓦片图。Kenney 为比 Unity 更多的游戏引擎提供了游戏资产作为精灵图集。虽然这个精灵图集可能在其他一些游戏引擎中工作得很好，但不幸的是，它在
    Unity 中却不行。
- en: Suppose the smaller images had more padding (blank space represented by transparent
    pixels surrounding the image). In that case, Unity’s **Automatic** slice type
    setting may work as intended to slice into individual sprites – it does with sufficient
    padding – but in this case, it did not work and treated the whole sprite sheet
    image as a single Sprite.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设较小的图像有更多的填充（由围绕图像的透明像素表示的空白空间）。在这种情况下，Unity 的**自动**切片类型设置可能按预期工作，将切片分割成单个精灵
    – 它在有足够填充的情况下可以这样做 – 但在这种情况下，它没有工作，并将整个精灵图集图像视为单个精灵。
- en: So, to use the images from a sprite sheet that does not have sufficient padding
    to work well with Unity’s automatic slicing, you’ll have to open your favorite
    image editing software (for example, Adobe Photoshop, Gimp, or Krita) and rearrange
    the images with padding, or arrange them in a grid for slicing by cell size.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使用与 Unity 的自动切片不兼容的填充不足的精灵图集中的图像，你必须打开你喜欢的图像编辑软件（例如，Adobe Photoshop、Gimp
    或 Krita）并重新排列图像以添加填充，或者按单元格大小排列它们进行切片。
- en: As you can see in the following screenshot, I chose to copy the images from
    the original Kenney sprite sheet (the left side) and create a new tilemap image
    with a consistent cell size layout (the right side – this image is included in
    the book’s project files).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，我选择从原始 Kenney 精灵图集中复制图像（左侧）并创建一个新的瓦片图图像，具有一致的单元格大小布局（右侧 – 此图像包含在本书的项目文件中）。
- en: '![Figure 2.5 – Sprite Editor – automatic versus grid slicing](img/B18347_02_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 精灵编辑器 – 自动切片与网格切片](img/B18347_02_05.jpg)'
- en: Figure 2.5 – Sprite Editor – automatic versus grid slicing
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 精灵编辑器 – 自动切片与网格切片
- en: Optimization note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 优化提示
- en: To reduce draw calls using a rendering technique called batching, a Sprite Atlas
    can be added to the project. Assigning individual sprites, sprite sheet images,
    and even folders to the Sprite Atlas will pack them into a single sprite sheet
    image to render from. This atlas will be the only asset being drawn from instead
    of multiple sprite images, where each additional sprite image would add a draw
    call to the renderer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少使用称为批处理渲染技术的绘制调用，可以将精灵图集添加到项目中。将单个精灵、精灵图集图像甚至文件夹分配给精灵图集，将它们打包成一个单独的精灵图集图像以进行渲染。这个图集将是唯一被绘制的资产，而不是多个精灵图像，其中每个额外的精灵图像都会向渲染器添加一个绘制调用。
- en: As a bonus activity, create a Sprite Atlas in the **Project** window from the
    **Create** menu by choosing **Create** | **2D** | **Sprite Atlas**. You can then
    assign both imported and sliced sprite sheets to the **Objects for Packing** list
    or the **Sprites** folder itself. You may need to verify that the feature is enabled
    (default) in **Project Settings** | **Editor** | **Sprite Packer** | **Mode =
    Sprite Atlas v2 –** **Enabled**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项附加活动，从 **创建** 菜单中选择 **创建** | **2D** | **精灵图集** 在 **项目** 窗口中创建一个精灵图集。然后，您可以将导入的切片精灵图集分配给
    **打包对象** 列表或 **精灵** 文件夹本身。您可能需要验证在 **项目设置** | **编辑器** | **精灵打包器** | **模式 = 精灵图集
    v2 –** **启用** 中该功能是否已启用（默认）。
- en: Now that we have our tilemaps sliced into individual Sprites, we’re ready to
    create a Tile Palette. The Sprites will be added to a Tile Palette to create Tiles
    used to draw out the level. Let’s make our first Tile Palette in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将瓦片图分成单个精灵，我们准备创建一个瓦片调色板。精灵将被添加到瓦片调色板中，以创建用于绘制关卡的瓦片。让我们在下一节中创建我们的第一个瓦片调色板。
- en: Additional reading | Unity documentation
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: '**Sprite** **Editor**: [https://docs.unity3d.com/2022.3/Documentation/Manual/SpriteEditor.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/SpriteEditor.xhtml)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵** **编辑器**：[https://docs.unity3d.com/2022.3/Documentation/Manual/SpriteEditor.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/SpriteEditor.xhtml)'
- en: Creating Tile Palettes
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建瓦片调色板
- en: 'To get started creating Tile Palettes, perform the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建瓦片调色板，请执行以下步骤：
- en: First, open the **Tile Palette** window by going to **Windows** | **2D** | **Tile
    Palette**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过转到 **窗口** | **2D** | **瓦片调色板** 打开 **瓦片调色板** 窗口。
- en: We’ll use the *Tower Defense (top-down)* game asset as our main environment
    map, so create a new **Tile Palette** by clicking the **Create New Palette** drop-down
    menu and selecting *New Palette*. This drop-down list is where we will be selecting
    the current Palette to use to draw the tilemap in the scene View.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 *塔防（俯视）* 游戏资源作为我们的主要环境图，因此通过点击 **创建新调色板** 下拉菜单并选择 *新建调色板* 来创建一个新的 **瓦片调色板**。这个下拉列表是我们将选择当前调色板以在场景视图中绘制瓦片图的地方。
- en: Name it `Environment Main`; keep the defaults since we’re using a rectangle
    grid.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为 `Environment Main`；保持默认设置，因为我们使用的是矩形网格。
- en: Click the **Create** button, as shown in *Figure 2**.6*.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如图 *图 2.6* 所示的 **创建** 按钮。
- en: A Tile Palette is an asset saved in the `Project` folders, so you will be prompted
    to save it. Select the folder we previously created – `Assets/Tile Palettes`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 瓦片调色板是一个保存在 `项目` 文件夹中的资产，因此您将被提示保存它。选择我们之前创建的文件夹 – `Assets/Tile Palettes`。
- en: '![Figure 2.6 – Creating a Tile Palette and Tiles](img/B18347_02_06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 创建瓦片调色板和瓦片](img/B18347_02_06.jpg)'
- en: Figure 2.6 – Creating a Tile Palette and Tiles
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 创建瓦片调色板和瓦片
- en: Additional reading | Unity documentation
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: 'Creating a Tile Palette: [https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Palette.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Palette.xhtml)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建瓦片调色板：[https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Palette.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Palette.xhtml)
- en: With the palette created, we can move on to the last step required before we
    can start drawing our level, and we’ll tackle that in the next section by adding
    Tiles to the Palette.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 调色板创建完成后，我们可以继续进行在开始绘制关卡之前所需的最后一步，我们将在下一节通过向调色板添加瓦片来解决这个问题。
- en: Creating Tiles
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建瓦片
- en: Tiles are what the Tile Palette uses to draw sprites into the Scene. You may
    be wondering why we need to create Tiles if we already have our sprites sliced
    and ready to use as individual images. That’s because Tiles can provide additional
    functionality when drawing your tilemaps. Other types of Tiles are the **Rule
    Tile** and **Animated Tile**, but we’ll start by using the default Tile type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片是瓦片调色板用来将精灵绘制到场景中的东西。你可能想知道为什么我们已经有切片并准备好作为单独图像使用的精灵，还需要创建瓦片。那是因为瓦片在绘制瓦片图时可以提供额外的功能。其他类型的瓦片包括
    **规则瓦片** 和 **动画瓦片**，但我们将从默认的瓦片类型开始使用。
- en: Let’s start by dragging the `towerDefense_tilesheet.png` sprite sheet from the
    `Assets/Sprites` folder into the `Assets/Tile Palettes/Tiles` folder we already
    prepared for them. The result should look like the Tile Palette window in *Figure
    2**.6*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从将 `towerDefense_tilesheet.png` 精灵图集从 `Assets/Sprites` 文件夹拖动到我们已为他们准备的 `Assets/Tile
    Palettes/Tiles` 文件夹开始。结果应该看起来像 *图 2**.6* 中的瓦片调色板窗口。
- en: Before we start drawing our level, let’s have a quick look at two very useful
    types of Tiles.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始绘制我们的关卡之前，让我们快速查看两种非常有用的瓦片类型。
- en: Types of Tiles
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 瓦片类型
- en: 'The common types of tiles include:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的瓦片类型包括：
- en: '**Rule Tile**: This allows us to create rules where specified adjacent tiles
    will be used to draw complex shapes more easily. It is essentially an automated
    drawing tool. This is a huge time-saver!'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则瓦片**：这允许我们创建规则，其中指定的相邻瓦片将被用来更容易地绘制复杂形状。这本质上是一个自动绘图工具。这是一个节省大量时间的方法！'
- en: 'To create a new Rule Tile, change to the `Tiles` folder in the `Assets/Tile
    Palettes/Tiles` named `Rule Tiles`. Right-click within the `Environment Area 1`,
    as shown in the **Inspector** window:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的规则瓦片，切换到 `Assets/Tile Palettes/Tiles` 中的 `Rule Tiles` 文件夹。在如图 **检查器**
    窗口中，在 `Environment Area 1` 内右键单击：
- en: '![Figure 2.7 – Rule Tile setup](img/B18347_02_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 规则瓦片设置](img/B18347_02_07.jpg)'
- en: Figure 2.7 – Rule Tile setup
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 规则瓦片设置
- en: We’ll add Tiling Rules to create a filled square with appropriate corner sprites,
    adjacent to the horizontal and vertical side sprites. That makes nine sprites
    in total – four on the sides, four in the corners, and one in the center.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加瓦片规则来创建一个带有适当角落精灵的填充正方形，与水平和垂直边精灵相邻。这总共需要九个精灵——四个在边缘，四个在角落，一个在中心。
- en: Set the `9`, and proceed to assign all the sprites from the environment sprite
    sheet by using *Figure 2**.7* as a guide. Once the sprites are assigned, we can
    set the “3 x 3” boxes that visualize the behavior of the Rule. Again, using *Figure
    2**.7*, set the box rules accordingly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `9`，然后按照 *图 2**.7* 作为指南，分配环境精灵图集中的所有精灵。一旦分配了精灵，我们就可以设置“3 x 3”的盒子，这些盒子可以可视化规则的行为。再次使用
    *图 2**.7*，相应地设置盒子规则。
- en: Additional reading | Unity documentation
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**Rule** **Tile**: [https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/RuleTile.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/RuleTile.xhtml)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则** **瓦片**：[https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/RuleTile.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/RuleTile.xhtml)'
- en: '**Animated Tile**: This allows us to create a sprite animation by assigning
    several sprites to replace each other at a specified speed.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画瓦片**：这允许我们通过分配几个精灵以指定速度相互替换来创建精灵动画。'
- en: To create a new Animated Tile, change to the `Tiles` folder in the `Assets/Tile
    Palettes/Tiles`, named `Animated Tiles`. Right-click within the **Project** window
    to open the **Create** menu and go to **Create** | **2D** | **Tiles** | **Animated
    Tile** within the new folder. To use this tile, drag a sequence of sprites to
    the **Drag a Sprite or Sprite Texture assets to start creating an Animated** **Tile**
    section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的动画瓦片，切换到 `Assets/Tile Palettes/Tiles` 中的 `Animated Tiles` 文件夹。在 **项目**
    窗口中右键单击以打开 **创建** 菜单，然后在新的文件夹中转到 **创建** | **2D** | **瓦片** | **动画瓦片**。要使用此瓦片，将一系列精灵拖到
    **拖动精灵或精灵纹理资产以开始创建动画瓦片** 部分。
- en: Additional reading | Unity documentation
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**Animated** **Tile**: [https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/AnimatedTile.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/AnimatedTile.xhtml)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画** **瓦片**：[https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/AnimatedTile.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/AnimatedTile.xhtml)'
- en: 'For a quick recap concerning all the folders we’ve created to organize and
    contain all of our art assets, our **Project** window should look similar to the
    following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速回顾我们创建的所有文件夹以组织和包含所有我们的艺术资产，我们的 **项目** 窗口应该看起来类似于以下内容：
- en: '![Figure 2.8 – Project folder structure](img/B18347_02_08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 项目文件夹结构](img/B18347_02_08.jpg)'
- en: Figure 2.8 – Project folder structure
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 项目文件夹结构
- en: In this section, you learned how to create Tile Palettes, understood how to
    import and slice sprite sheets to create individual sprites, and explored the
    advantages of using Rule Tiles to make drawing easier.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何创建瓦片调色板，了解了如何导入和切割精灵图集以创建单个精灵，并探讨了使用规则瓦片使绘制更容易的优势。
- en: This is all the prerequisite setup we need to draw the environment for our collection
    game level, so let’s get started doing just that. In the next section, we’ll add
    several tilemaps for the different components that make up the level design.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们绘制收集游戏关卡环境所需的所有先决设置，所以让我们开始做吧。在下一节中，我们将添加几个瓦片图，用于构成关卡设计的不同组件。
- en: Building the collection game environment with Tilemap
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用瓦片图构建收集游戏环境
- en: 'We’ll need a new scene for the game level, so go to **File** | **New Scene**
    (*Ctrl*/*Cmd* + *N*). This will bring up the **New Scene** window, where we’ll
    select the **Lit 2D (URP)** Scene Template and then click the **Create** button
    in the window’s lower-right corner, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新场景来放置游戏关卡，所以请转到**文件** | **新建场景** (*Ctrl*/*Cmd* + *N*)。这将打开**新建场景**窗口，在那里我们将选择**Lit
    2D (URP)**场景模板，然后点击窗口右下角的**创建**按钮，如图下截图所示：
- en: '![Figure 2.9 – New Scene Templates](img/B18347_02_09.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 新场景模板](img/B18347_02_09.jpg)'
- en: Figure 2.9 – New Scene Templates
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 新场景模板
- en: Scene Templates – Unity documentation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 场景模板 – Unity 文档
- en: 'Unity provides a set of built-in Scene Templates, but you can add your own
    user-defined templates to create new scenes containing all of your starting content.
    For additional information on creating Scene Templates, refer to the Unity documentation
    here: [https://docs.unity3d.com/2022.3/Documentation/Manual/scene-templates.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/scene-templates.xhtml)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一套内置的场景模板，但您可以添加自己的用户定义模板来创建包含所有起始内容的新场景。有关创建场景模板的更多信息，请参阅 Unity 文档：[https://docs.unity3d.com/2022.3/Documentation/Manual/scene-templates.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/scene-templates.xhtml)
- en: A new `Game` or `Level`, since our game will consist entirely of just a single
    scene (that is, for a single game level).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的**游戏**或**关卡**，因为我们的游戏将完全由单个场景（即单个游戏关卡）组成。
- en: With our new game scene saved, we’re ready to start adding tilemaps in the next
    section!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存了我们的新游戏场景后，我们就可以在下一节开始添加瓦片图了！
- en: Adding tilemaps to a Scene
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向场景添加瓦片图
- en: A **Tilemap** is a component added to a GameObject that adds functionality just
    like any other component we previously discussed. The **Tilemap** component stores
    and manages the **Tile** assets used for creating 2D environments and levels.
    It also depends on a **Grid** component that provides a visual guide and aligns
    the painted tiles. We will make multiple tilemaps to serve different visual and
    functional purposes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**瓦片图**是添加到GameObject上的组件，它提供的功能就像我们之前讨论过的任何其他组件一样。**瓦片图**组件存储和管理用于创建2D环境和关卡所使用的**瓦片**资源。它还依赖于一个**网格**组件，该组件提供视觉引导并使绘制的瓦片对齐。我们将制作多个瓦片图，以服务于不同的视觉和功能目的。'
- en: To create a tilemap in the scene, from the `Tilemap – Background`. Refer to
    *Figure 2**.11* for an example of this in the **Hierarchy** window.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要在场景中创建瓦片图，请从**瓦片图 – 背景**开始。请参考图 2.11 以了解在**层次结构**窗口中此操作的示例。
- en: In the next section, we will learn how to control the drawing order of multiple
    tilemaps.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何控制多个瓦片图的绘制顺序。
- en: Sorting Layers
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 层级排序
- en: Like we have a Sorting Layer on individual Sprites, we have one on tilemaps.
    The **Tilemap Sorting Layer** will allow us to draw sprites on different layers
    to control front-to-back layering (objects drawn on top of or behind others) and
    is applied to the whole tilemap (all the sprites that make up the tilemap).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在单个精灵上有排序层一样，我们在瓦片图上也有。**瓦片图排序层**将允许我们在不同的层上绘制精灵，以控制前后层叠（绘制在其他人之上或之后的对象）并应用于整个瓦片图（构成瓦片图的全部精灵）。
- en: 'Let’s create a new **Sorting Layer** for the background tilemap by clicking
    on the **Sorting Layer** drop-down list, which currently has a **Default** value,
    and click **Add Sorting Layer…**. The **Inspector** window will change to the
    **Tags & Layers** settings, where we’ll specify the following layers and their
    order: *Background*, *Collider*, *Objects*, and *Foreground*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过点击**排序层**下拉列表创建一个新的**排序层**用于背景瓦片地图，当前该下拉列表的值为**默认**，然后点击**添加排序层…**。**检查器**窗口将切换到**标签与层**设置，我们将指定以下层及其顺序：*背景*，*碰撞器*，*对象*和*前景*。
- en: '![Figure 2.10 – Sorting Layers](img/B18347_02_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 排序层](img/B18347_02_10.jpg)'
- en: Figure 2.10 – Sorting Layers
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 排序层
- en: The renderer will draw the layers in the order they appear here, with **Layer
    0** (**Background**) at the back, **Layer 4** (**Foreground**) at the front, and
    the layers in between drawn in their respective locations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器将按照它们在这里出现的顺序绘制层，**层 0**（**背景**）在后面，**层 4**（**前景**）在前面，中间的层将在它们各自的位置绘制。
- en: Clicking the **+** button will add a new layer to the list while clicking the
    **-** button with a layer selected will remove it. Dragging **=** to the left
    of the field (for example, **Layer 0**) up/down will reorder. Once we’ve finished
    adding and setting the layer orders, click on **Tilemap - Background** in the
    **Hierarchy** window again and select *Background* in the **Tilemap Renderer Sorting**
    Layer drop-down field.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**+**按钮将向列表中添加一个新层，而点击已选中的层旁边的**-**按钮将移除它。将字段左侧的**=**向上/向下拖动（例如，**层 0**）将重新排序。一旦我们完成添加和设置层顺序后，再次点击**层次结构**窗口中的**Tilemap
    - Background**，并在**瓦片地图渲染器排序**层下拉字段中选择*背景*。
- en: We still have the option of creating a second Tilemap background on the same
    Sorting Layer, and we can control which background draws above/below the other
    background by using the **Order in Layer** field – this is useful if you have
    two different style environments for your background and would like to manage
    them separately.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有在同一个排序层上创建第二个瓦片地图背景的选项，我们可以通过使用**层中顺序**字段来控制哪个背景绘制在另一个背景之上/之下——如果你有两个不同风格的背景环境并且想要分别管理它们，这将很有用。
- en: We are finally ready to start drawing with our Tiles in the next section!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好在下一节开始使用我们的瓦片进行绘制了！
- en: Drawing the level in the scene view
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在场景视图中绘制关卡
- en: If you’ve ever previously used a drawing program, then the painting tools in
    the Tile Palette’s toolbar will seem familiar, except that you will now be limited
    to painting on a grid. Paintbrush, flood fill, box fill, and eraser tools are
    all standard painting tools in drawing programs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过绘图程序，那么在瓦片调色板工具栏中的绘画工具将看起来很熟悉，只是你现在将限制在网格上绘画。画笔、填充、框填充和橡皮擦工具都是绘图程序中的标准绘画工具。
- en: We won’t cover all the painting tools in detail, but I encourage you to explore
    them on your own as you draw out your environment and level design – don’t be
    afraid to make mistakes! Like most things in Unity – and pretty much every program
    – you can quickly undo things by using *Ctrl*/*Cmd* + *Z*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细涵盖所有绘画工具，但我鼓励你在绘制你的环境和关卡设计时自己探索它们 – 不要害怕犯错！像Unity中的大多数事情一样——以及几乎每个程序——你可以通过使用
    *Ctrl*/*Cmd* + *Z* 快速撤销操作。
- en: Remember to save your progress as you go to keep what you like. Have fun with
    your drawing, and take the time to experiment because you never know where this
    type of creativity will lead.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行过程中记得保存你的进度，以保留你喜欢的部分。享受你的绘画过程，并花时间进行实验，因为你永远不知道这种创造力的方向在哪里。
- en: Scene navigation
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 场景导航
- en: As a reminder for getting around in the scene View while drawing out your level,
    refer back to *Navigating the scene View* section in [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在绘制关卡时在场景视图中导航的提醒，请参考[*第 1 章*](B18347_01.xhtml#_idTextAnchor015)中的*导航场景视图*部分。
- en: 'Follow these steps every time you want to draw in the scene View using the
    painting tools:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想在场景视图中使用绘画工具进行绘制时，请遵循以下步骤：
- en: Start by selecting the tilemap you want to paint on, either in the **Hierarchy**
    window or within the **Tile Palette** window, using the **Active Tilemap** drop-down
    list (just below the toolbar).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择你想要绘制的瓦片地图，无论是在**层次结构**窗口中还是在**瓦片调色板**窗口内，使用**活动瓦片地图**下拉列表（位于工具栏下方）。
- en: Select the **Palette** for the **Tile** you want to paint with using the **Tile
    Palettes** drop-down list located just below the **Active Tilemap** section on
    the left. For instance, we will choose the **Environment Main** palette that we
    created earlier.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位于左侧**活动瓷砖图**部分下方**瓷砖调色板**下拉列表中选择你想要绘制的**瓷砖**的**调色板**。例如，我们将选择我们之前创建的**环境主**调色板。
- en: Choose the tile to paint with by clicking on it in the tiles section grid. Remember
    that we’re starting with the background of our level design, so pick a solid square
    tile that we can use to fill a large area.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在瓷砖部分网格中点击它来选择要绘制的瓷砖。记住，我们是从我们的关卡设计的背景开始，所以选择一个可以用来填充大面积的实心方块瓷砖。
- en: To paint individual tiles, by clicking on a grid cell in the scene View or painting
    continuous lines of sprites by clicking and dragging, select the **Paintbrush**
    tool (the paintbrush icon).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制单个瓷砖，请在场景视图中点击网格单元格，或者通过点击并拖动来绘制精灵的连续线条，选择**画笔**工具（画笔图标）。
- en: To draw a rectangular shape filled with the selected tile, select the **Box
    Fill** tool (the box icon).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制一个用所选瓷砖填充的矩形形状，请选择**方块填充**工具（方块图标）。
- en: You can also fill a larger contiguous area of grid cells with the selected tile
    by using the **Flood Fill** tool (the bucket icon).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以使用**填充**工具（水桶图标）用所选瓷砖填充更大的连续网格单元格区域。
- en: The **Eraser** tool can erase tiles from the cell grid by clicking on them or
    clicking and dragging.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**橡皮擦**工具可以通过点击它们或点击并拖动来擦除单元格网格中的瓷砖。'
- en: The following figure illustrates the background tilemap selected in the **Hierarchy**
    window (*A*), a view of its components in the **Inspector** window (*B*), the
    environment palette (**Environment Main**) that we’re using to draw the background
    with (*C*), and both the selected tile (**grass**) (*D*) and painting tool (**Paintbrush**)
    currently being used (*E*).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了在**层级**窗口中选定的背景瓷砖图（*A*），在**检查器**窗口中查看其组件（*B*），我们正在使用它来绘制背景的环境调色板（**环境主**）（*C*），以及当前选定的瓷砖（**草地**）（*D*）和正在使用的绘画工具（**画笔**）（*E*）。
- en: '![Figure 2.11 – The Tilemap in the Hierarchy and Tile Palette windows](img/B18347_02_11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 层级和瓷砖调色板窗口中的瓷砖图](img/B18347_02_11.jpg)'
- en: Figure 2.11 – The Tilemap in the Hierarchy and Tile Palette windows
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 层级和瓷砖调色板窗口中的瓷砖图
- en: Additional reading | Unity documentation
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Painting on** **Tilemaps**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Painting.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Painting.xhtml)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**在瓷砖图中绘制**：[https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Painting.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Painting.xhtml)'
- en: As a reminder of what we’re drawing here, we’re creating the background for
    the level of our collection game – defining the general play area. To visualize
    the overall level design plan, it may help to start drawing some of your ideas
    out on paper first, then using those ideas to start drawing things out in the
    Editor (refer to my initial sketch as a guide, if needed).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们在这里绘制内容的提醒，我们正在为我们的收集游戏关卡创建背景——定义一般游戏区域。为了可视化整体关卡设计计划，可能有助于首先在纸上绘制一些你的想法，然后使用这些想法在编辑器中开始绘制（如有需要，请参考我的初始草图作为指南）。
- en: Paper prototyping
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 纸质原型设计
- en: Paper prototyping is a widely used method in the game design process that helps
    you test out ideas before committing time to writing code or creating digital
    art assets. It’s also a quick way to validate your gameplay and discover potential
    problems early on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 纸质原型设计是游戏设计过程中广泛使用的方法，它可以帮助你在投入时间编写代码或创建数字艺术资源之前测试你的想法。这也是验证你的游戏玩法和早期发现潜在问题的快速方法。
- en: While experimenting with your level design, consider that we’ll want to guide
    the player to where we’ll be placing collectibles throughout the level in the
    following sections. Don’t be afraid of making any mistakes; making changes in
    response to playtesting your games is something that you’ll have to do regularly
    – iterating changes to improve gameplay or balance the difficulty.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试你的关卡设计时，请考虑我们将在以下部分引导玩家到达关卡中我们将放置收集品的区域。不要害怕犯错；根据游戏测试对游戏进行更改是您将不得不定期做的事情——迭代更改以改进游戏玩法或平衡难度。
- en: Before tailoring additional elements of the environment and level design, let’s
    make sure our art assets are looking their best in the game view by adjusting
    the **Camera** settings.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整环境和其他关卡设计元素之前，让我们确保通过调整**相机**设置，我们的艺术资源在游戏视图中看起来最好。
- en: Camera settings for crisp graphics
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图像设置以获得清晰的图形
- en: The default settings Unity provides in new Scenes are not always ideal for the
    game assets you’ll be working with. Because of this, we’ll want to make some adjustments
    to our sprite sheet image import settings and our scene camera to have them looking
    their best!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在新场景中提供的默认设置并不总是适合您将要工作的游戏资产。因此，我们将调整我们的精灵图导入设置和场景相机，以确保它们看起来最好！
- en: The individual images in our tilemap image are 64 pixels square (note that these
    sizes could be different, depending on the desired size of the art for the game
    design dictates). The best way to work with tilemap images is to ensure that the
    individual sprite size equals the grid size. Since tilemap grid cells are sized
    to equal one square Unity unit, we’ll have to set our pixels per unit to equal
    one Unity unit.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在瓦片图图像中的单个图像是64像素的方形（注意，这些尺寸可能不同，取决于游戏设计对艺术作品所需尺寸的规定）。与瓦片图图像一起工作的最佳方式是确保单个精灵大小等于网格大小。由于瓦片图网格单元格的大小设置为等于一个Unity单位，因此我们必须将每单位像素数设置为等于一个Unity单位。
- en: To set the pixels per unit for the sprites in our *Tower Defense (top-down)*
    asset, click on the `towerDefense_tilesheet.png` image in the `Assets/Sprites`
    folder to view the import settings in the `64` (pixels).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的**塔防（俯视）**资产中精灵的每单位像素数，请点击位于`Assets/Sprites`文件夹中的`towerDefense_tilesheet.png`图像以查看导入设置在`64`（像素）。
- en: We’ll now have to address the camera setting so that 64-pixel sprite images
    are represented on screen at their native resolution. These are the *crisp graphics*
    we are referring to – the native size. This will require a bit of math and a decision
    on the preferred resolution for the target platform. Assuming that most players
    on desktop systems – our target platform for the collection game – have a screen
    resolution of 1,920 px wide x 1,080 px high, let’s use that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须解决相机设置问题，以便64像素的精灵图像在屏幕上以原生分辨率表示。这是我们所说的**清晰图形**——原生大小。这需要一点数学计算和针对目标平台的首选分辨率的决定。假设大多数桌面系统上的玩家——我们的目标平台是收集游戏——的屏幕分辨率为1,920像素宽
    x 1,080像素高，让我们使用这个值。
- en: Select the **Main Camera** in the **Scene Hierarchy** window; then, in the **Projection**
    section, set the orthographic camera projection size (this is a vertical value)
    by taking the screen resolution height divided by the pixels per unit and dividing
    the result by 2 – we are dividing by 2 because the size value is half the vertical
    viewing volume of the camera. Here is what the calculation looks like with the
    resulting value set in the **Inspector** window – *(1,080 ÷ 64) ÷ 2 =* *8.4375*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景层次结构**窗口中选择**主相机**；然后，在**投影**部分，通过将屏幕分辨率高度除以每单位像素数，然后将结果除以2来设置正交相机投影大小（这是一个垂直值）——我们之所以除以2，是因为大小值是相机垂直视场的一半。以下是计算结果在**检查器**窗口中的样子
    – *(1,080 ÷ 64) ÷ 2 =* *8.4375*。
- en: '![Figure 2.12 – The camera orthographic size](img/B18347_02_12.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 相机的正交大小](img/B18347_02_12.jpg)'
- en: Figure 2.12 – The camera orthographic size
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 相机的正交大小
- en: The number of sprites extending the vertical extent is now optimal for crisp
    graphics! To visualize the result in the Editor, switch to the **Game** view (by
    clicking on its tab next to **Scene**, just under the main toolbar) and set the
    **Aspect Ratio** drop-down list value to **Full HD (1920x1080)** – by default;
    this is set to **Free Aspect**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在垂直延伸的精灵数量对于清晰图形来说是最佳的！为了在编辑器中可视化结果，切换到**游戏**视图（通过点击位于主工具栏下方的**场景**旁边的标签）并将**纵横比**下拉列表值设置为**全高清（1920x1080）**——默认情况下；这是设置为**自由纵横比**。
- en: In this section, we learned how to draw tiles in the scene View to create the
    background environment and define the play area for the level. We also learned
    how to make our art assets look their best! Next, we’ll add some 2D lights – leveraging
    the Universal Render Pipeline’s (Universal RP, or URP) 2D features – to enhance
    the environment design.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在场景视图中绘制瓦片以创建背景环境并定义关卡的游戏区域。我们还学习了如何使我们的艺术资产看起来最好！接下来，我们将添加一些2D灯光——利用通用渲染管道（通用RP，或URP）的2D功能——以增强环境设计。
- en: Adding 2D lights
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加2D灯光
- en: 'The Universal RP 2D renderer allows us to enhance our environment by adding
    2D lights! Let’s add some 2D lights to the position of some tiles, representing
    light sources in our environment design. Follow these steps to add some *light
    sources*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通用RP 2D渲染器允许我们通过添加2D灯光来增强我们的环境！让我们在代表环境设计中光源的一些瓦片位置添加一些2D灯光。按照以下步骤添加一些**光源**：
- en: Start by creating a new tilemap for tiles that will draw above the background
    tilemap, and name it `Tilemap -` `Objects`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为将绘制在背景瓷砖图之上的瓷砖创建一个新的瓷砖图，并将其命名为`Tilemap -` `Objects`。
- en: Set **Sorting Layer** to *Objects*.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**排序层**设置为*对象*。
- en: Create a new `Environment Objects`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Environment Objects`。
- en: Add the sprites from the `topdowntanks_onlyObjects_default` sprite sheet to
    create the tiles used for painting.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`topdowntanks_onlyObjects_default`精灵图集中的精灵添加到创建瓷砖中。
- en: Select *Tilemap - Objects* as **Active Tilemap** in the **Tile** **Palette**
    window.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**瓷砖** **调色板**窗口中，将*Tilemap - Objects*设置为**活动瓷砖图**。
- en: Select the star-looking tile and paint a few in the Scene using the **Paintbrush**
    tool.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择星形瓷砖，并使用**画笔**工具在场景中绘制几个。
- en: Important note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To focus work on a specific tilemap with the other GameObjects in the scene
    faded out, use the **Tilemap Focus** mode (the floating overlay in the scene View).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要专注于特定瓷砖图，同时将场景中的其他GameObject淡出，请使用**瓷砖图聚焦**模式（场景视图中的浮动叠加层）。
- en: 'Okay, we have some light sources in the environment; now, let’s add some 2D
    lights to them by following these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，环境中有一些光源；现在，按照以下步骤给它们添加一些2D光源：
- en: Create a new empty GameObject in the root of the scene’s `Lights`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景的`Lights`根目录下创建一个新的空GameObject。
- en: Right-click on the **Lights** GameObject – to open the **Create** menu – and
    select **Light** | **Freeform Light 2D** | **Circle.**
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**Lights** GameObject——以打开**创建**菜单——然后选择**Light** | **Freeform Light 2D**
    | **Circle**。
- en: Using the **Move** tool, position it over one of your *star* tiles.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**移动**工具，将其定位在其中一个*星*瓷砖上。
- en: You can experiment with what looks good to you. I changed the light’s **Blending**
    section’s **Blend Style** value to **Additive** (the default is **Multiply**)
    to better visualize the example screenshots. For a finished game, I would reduce
    the global light source intensity and use the **Multiply** blend style on many
    2D lights added to the environment to set the right lighting design tone.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以尝试看看什么对你来说看起来不错。我将灯光的**混合**部分的**混合样式**值更改为**加法**（默认是**乘法**），以便更好地可视化示例截图。对于完成的游戏，我会降低全局光源的强度，并在环境中添加的许多2D光源上使用**乘法**混合样式，以设定正确的光照设计基调。
- en: Additional reading | Unity documentation
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Light Blend** **Styles**: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/LightBlendStyles.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/LightBlendStyles.xhtml)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**灯光混合** **样式**：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/LightBlendStyles.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/LightBlendStyles.xhtml)'
- en: Adjust the **Radius**, **Inner Spot Angle**/**Outer Spot Angle**, **Intensity**,
    and **Falloff Strength** values to your liking.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整**半径**、**内聚光角度**/**外聚光角度**、**强度**和**衰减强度**值，直到满意。
- en: Repeat as necessary for all of the light sources in your environment design!
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于你环境设计中的所有光源，按需重复此操作！
- en: You will want to adjust the overall lighting in the scene to use 2D lights to
    their full effect. Do this by selecting the **Global Light 2D** GameObject in
    the **Scene Hierarchy** window and adjusting the Light 2D component’s **Intensity**
    value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要调整场景中的整体光照，以充分利用2D光源。通过在**场景层次结构**窗口中选择**全局光2D**GameObject并调整光2D组件的**强度**值来完成此操作。
- en: The results of adding 2D lights to the scene can be seen in *Figure 2**.13*
    – to the left and right sides of the player character (the ladybug). We’ll be
    using the different types of 2D lights in the coming chapters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中添加2D光源的结果可以在**图2**.13*中看到——在玩家角色（瓢虫）的左右两侧。在接下来的章节中，我们将使用不同类型的2D光源。
- en: In this section, you learned how to add 2D lights to your environment design
    to great effect. The following section will tackle a missing requirement to get
    our level playable by using the **TilemapCollider2D** component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何有效地将2D光源添加到你的环境设计中。下一节将解决一个缺失的要求，通过使用**TilemapCollider2D**组件使我们的关卡可玩。
- en: Making the level playable – Tilemap Collider 2D
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使关卡可玩——Tilemap Collider 2D
- en: We’ll need to prepare our level design a bit more before we’re able to make
    it playable – we’ll be making the player character controllable in the next chapter
    by adding a custom script and mapping inputs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使关卡可玩之前，我们需要对关卡设计做一些准备——我们将在下一章通过添加自定义脚本和映射输入来使玩家角色可控制。
- en: To keep the player from crossing into specified areas in the level, we need
    to add a special kind of collider to a tilemap. Colliders are a part of Unity’s
    Physics system and provide a way for developers to work with GameObjects, similar
    to how objects work in the real world.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止玩家穿越到关卡中指定的区域，我们需要在 tilemap 中添加一种特殊的碰撞器。碰撞器是 Unity 物理系统的一部分，为开发者提供了与 GameObjects
    交互的方式，类似于现实世界中的物体工作方式。
- en: Colliders prevent things from entering each other, and collisions of objects
    can all be responded to in code as events – we’ll be exploring this more in the
    upcoming chapters when adding features to our game.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞器阻止事物相互进入，并且对象的碰撞都可以通过代码作为事件来响应——我们将在添加游戏功能时进一步探讨这一点。
- en: 'Let’s add a new tilemap to our scene to define areas that the player is not
    allowed to enter. This will be similar to how we created the previous tilemaps,
    except for having to add a **TilemapCollider2D** component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中添加一个新的 tilemap 来定义玩家不允许进入的区域。这将与创建之前的 tilemap 类似，但需要添加一个 **TilemapCollider2D**
    组件：
- en: Create a new tilemap for tiles that will draw above the background tilemap and
    contain areas the player cannot cross. Name it `Tilemap -` `Collider`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为将要在背景 tilemap 上绘制并包含玩家无法穿越的区域的新 tilemap 创建一个新的 tilemap。命名为 `Tilemap -` `Collider`。
- en: Set **Sorting Layer** to *Collider*.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Sorting Layer** 设置为 *Collider*。
- en: Let’s use a `Rules Palette`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一个 `Rules Palette`。
- en: Drag in the `Assets/Tile Palettes/Rule` `Tiles` folder.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Assets/Tile Palettes/Rule` `Tiles` 文件夹拖入。
- en: Select *Tilemap - Collider* as **Active Tilemap** in the **Tile** **Palette**
    window.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Tile** **Palette** 窗口中，将 *Tilemap - Collider* 设置为 **Active Tilemap**。
- en: Select the rule tile and paint out areas in the scene using the **Filled** **Box**
    tool.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择规则图块，并使用 **Filled** **Box** 工具在场景中绘制区域。
- en: Now, to make this tilemap interactive, with **Tilemap - Collider** selected
    in the **Hierarchy** window, go to the bottom of the **Inspector** window and
    click the **Add Component** button. In the search field at the top of the dialog
    that opens, type *Tilemap*, and then select the **Tilemap Collider 2D** item to
    add it – we can use the default values.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使这个 tilemap 具有交互性，在 **Hierarchy** 窗口中选中 **Tilemap - Collider**，在 **Inspector**
    窗口的底部点击 **Add Component** 按钮。在打开的对话框顶部的搜索字段中输入 *Tilemap*，然后选择 **Tilemap Collider
    2D** 项以添加它——我们可以使用默认值。
- en: 'Refer to the following figure to get an idea of what we’re creating:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图示，了解我们正在创建的内容：
- en: '![Figure 2.13 – A collider level design example in the scene View](img/B18347_02_13.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 场景视图中碰撞器关卡设计示例](img/B18347_02_13.jpg)'
- en: Figure 2.13 – A collider level design example in the scene View
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 场景视图中碰撞器关卡设计示例
- en: Now that you understand how to add tilemaps, paint tiles in the scene, and sort
    the tilemap layers to set the proper drawing order, spend some time filling in
    environmental details. This is your time to experiment with detailing the environment’s
    design and think about how the player will be guided through the level to accomplish
    the game objective – collecting items.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何添加 tilemap、在场景中绘制图块以及排序 tilemap 层以设置正确的绘制顺序，花些时间填充环境细节。这是你实验环境设计细节和思考玩家如何通过关卡完成游戏目标——收集物品的时间。
- en: In this section, you learned some key elements of level design. You understood
    how to create and work with tilemaps by importing and slicing sprite sheet images.
    To draw out a game level, you used tiles to paint individual sprites and areas.
    You completed the design by adding lights and making the graphics crisp. Finally,
    we made interactable objects through the use of colliders.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了关卡设计的一些关键元素。你了解了如何通过导入和切割精灵图集图像来创建和操作 tilemap。为了绘制游戏关卡，你使用了图块来绘制单个精灵和区域。通过添加灯光和使图形清晰，你完成了设计。最后，我们通过使用碰撞器创建了可交互的对象。
- en: We’ll start bringing all of these concepts together in the following sections
    by adding C# scripts to move the player and collect items.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过添加 C# 脚本来移动玩家和收集物品，将这些概念结合起来。
- en: Introduction to creating scripts in C# – IDE, SOLID principles, and design patterns
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 脚本创建入门 – IDE、SOLID 原则和设计模式
- en: When making games in Unity, you’ll need to create your own functionality specific
    to the requirements of your game. We’ll need to learn how Unity provides programming
    support for writing scripts using the C# language to accomplish this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中制作游戏时，你需要创建自己游戏特定功能。我们需要学习 Unity 如何提供编程支持，使用 C# 语言编写脚本以实现这一点。
- en: In this section, you’ll be introduced to the default code editor, get into the
    specifics of the C# language, and learn the best-practice approach to writing
    manageable, maintainable, and extensible code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解默认代码编辑器，深入了解C#语言的具体内容，并学习编写可管理、可维护和可扩展代码的最佳实践方法。
- en: The IDE – Visual Studio Community 2022
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDE – Visual Studio Community 2022
- en: The default **integrated development environment** (**IDE**) that Unity provides
    as part of the Unity Editor installation is **Microsoft Visual Studio 2022 Community
    Edition**. The Community Edition is free for students and individuals and provides
    a powerful IDE, with comprehensive tools and features for every stage of development,
    including tools specific to Unity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Unity作为Unity编辑器安装的一部分提供的默认**集成开发环境**（**IDE**）是**Microsoft Visual Studio 2022社区版**。社区版对学生和个人免费，提供功能强大的IDE，包括适用于开发每个阶段的全套工具和功能，包括针对Unity的特定工具。
- en: Additional reading | Unity Visual Scripting
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 视觉脚本
- en: 'We will use Visual Studio 2022 to write C# code in this book, but it’s worth
    noting that Unity also offers a visual scripting option that uses a graph-based
    system instead of traditional code: [https://unity.com/features/unity-visual-scripting](https://unity.com/features/unity-visual-scripting)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中使用Visual Studio 2022编写C#代码，但值得注意的是，Unity还提供了一个使用基于图系统的视觉脚本选项，而不是传统的代码：[https://unity.com/features/unity-visual-scripting](https://unity.com/features/unity-visual-scripting)
- en: 'The Visual Studio 2022 interface, with its standard windows, features, and
    a script that is open for editing, can be seen as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022的界面，拥有标准窗口、功能和可编辑的脚本，可以如下所示：
- en: '![Figure 2.14 – Visual Studio 2022 Community Edition](img/B18347_02_14.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – Visual Studio 2022社区版](img/B18347_02_14.jpg)'
- en: Figure 2.14 – Visual Studio 2022 Community Edition
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – Visual Studio 2022社区版
- en: 'In addition to an essential script editing capability, let’s have a quick look
    at some of the features that Visual Studio 2022 provides:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的脚本编辑功能外，让我们快速了解一下Visual Studio 2022提供的一些功能：
- en: '**IntelliSense**: Aids in code completion by providing suggestions for naming,
    parameter info, and words – saving you keystrokes!'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliSense**：通过提供命名、参数信息和单词的建议来帮助代码完成，节省您按键！'
- en: '**IntelliCode**: Enhances your software development with **artificial intelligence**
    (**AI**) that can automatically complete code – even up to a whole line!'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliCode**：通过**人工智能**（**AI**）增强您的软件开发，可以自动完成代码 – 甚至整行！'
- en: '**CodeLens**: Keeps you focused on your code’s structure without leaving the
    IDE, code references, and contextual information at your fingertips!'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码镜头**：在IDE中保持对代码结构的关注，无需离开，代码引用和上下文信息尽在指尖！'
- en: '**Live Share**: Provides a real-time collaborative coding session you can share
    with other members on your project – work together to produce results faster!'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时共享**：提供实时协作编码会话，您可以与项目中的其他成员共享 – 一起工作，更快地产生结果！'
- en: '**Integrated debugging**: Allows the developer to control the execution, step
    through the code, and examine its state interactively while it’s running – see
    what your code is doing while it runs!'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成调试**：允许开发者在代码运行时控制执行、逐行执行代码并交互式地检查其状态 – 看看您的代码在运行时做了什么！'
- en: Additional reading | Visual Studio
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Visual Studio
- en: '**What’s new in Visual Studio** **2022**: [https://docs.microsoft.com/en-us/visualstudio/ide/whats-new-visual-studio-2022?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/ide/whats-new-visual-studio-2022?view=vs-2022%0D)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio 2022的新功能**：[https://docs.microsoft.com/en-us/visualstudio/ide/whats-new-visual-studio-2022?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/ide/whats-new-visual-studio-2022?view=vs-2022%0D)'
- en: Before opening up the IDE to edit a script, we’ll first need to create one!
    Creating scripts can be performed in a couple of ways. It’s good practice to keep
    your project files organized from the start, so let’s first create a new folder
    named `Scripts` at the root of our project – `Assets/Scripts`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开IDE编辑脚本之前，我们首先需要创建一个！创建脚本可以通过几种方式完成。良好的做法是从一开始就保持项目文件的组织，因此让我们首先在项目根目录下创建一个名为`Scripts`的新文件夹
    – `Assets/Scripts`。
- en: 'To create a new script in this folder, do the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此文件夹中创建新脚本，请执行以下操作：
- en: Make sure the `Scripts` folder is the currently selected folder in the **Project**
    window.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**项目**窗口中当前选中的文件夹是`Scripts`文件夹。
- en: Right-click within the **Project** window to open the **Create** menu (or use
    the **+** button).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口内右键单击以打开**创建**菜单（或使用**+**按钮）。
- en: Select **C# Script**.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**C# 脚本**。
- en: Rename the script from its default name of `PlayerController` (it’s currently
    highlighted to make naming it right away easier).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本重命名为其默认名称 `PlayerController`（它当前被高亮显示，以便立即命名）。
- en: Tip
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not use any spaces in your script filenames or start the script’s name with
    a number. Both are naming rule violations for C# classes, so your script will
    not work. You can use the underscore character in place of spaces. However, this
    naming convention style is generally frowned upon in the developer community –
    unless it is the first character of the name for private member variables (which
    is a common convention in C# and used in this book).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在脚本文件名中使用空格或以数字开头命名脚本。这两者都是C#类的命名规则违规，因此你的脚本将无法工作。你可以使用下划线字符代替空格。然而，这种命名约定风格在开发者社区中通常是不受欢迎的——除非它是私有成员变量的名称的第一个字符（这是C#中的常见约定，并在本书中使用）。
- en: 'As a reference for a good naming convention standard to use – and stick to
    (because consistency and good naming improve code readability for everyone) –
    check out the following guide: https://[https://www.c-sharpcorner.com/UploadFile/8a67c0/C-Sharp-coding-standards-and-naming-conventions/](https://www.c-sharpcorner.com/UploadFile/8a67c0/C-Sharp-coding-standards-and-naming-conventions/)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用良好命名约定标准的参考——并且坚持使用（因为一致性和良好的命名可以提高所有人的代码可读性）——请参阅以下指南：[C#编码标准和命名约定](https://www.c-sharpcorner.com/UploadFile/8a67c0/C-Sharp-coding-standards-and-naming-conventions/)
- en: You can also add new scripts (that is, components) to GameObjects directly in
    the **Inspector** window through the **Add Component** button at the bottom of
    the window (and when you currently have a GameObject selected). Click the **Add
    Component** button, and then select **New** **Script >**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过窗口底部的 **添加组件** 按钮直接在 **检查器** 窗口中添加新脚本（即组件）（当你当前选中一个GameObject时）。点击 **添加组件**
    按钮，然后选择 **新** **脚本 >**。
- en: You’ll be prompted to enter the script name, and then click `Assets` folder
    – so I prefer the methods previously mentioned to create in a specific folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入脚本名称，然后点击 `Assets` 文件夹——因此我更喜欢之前提到的方法在特定文件夹中创建。
- en: New scripts are generated from the default template Unity provides (you can
    modify the template to suit your personal needs; see the following *C# Script
    Templates* callout box). New scripts are also given the `.cs` file extension,
    denoting them as C# script files (file extensions are not visible in the Unity
    **Project** window).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 新脚本是从Unity提供的默认模板生成的（你可以修改模板以适应个人需求；请参阅以下 *C# 脚本模板* 提示框）。新脚本也赋予了 `.cs` 文件扩展名，表示它们是C#脚本文件（文件扩展名在Unity
    **项目**窗口中不可见）。
- en: We’ve named it `PlayerController` here, because the first C# code we’ll be writing
    in the next section is to give the ladybug player character we previously created
    the ability to move around from player input.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将其命名为 `PlayerController`，因为下一节我们将编写的第一个C#代码是赋予我们之前创建的瓢虫玩家角色从玩家输入移动的能力。
- en: C# script templates – Unity documentation
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: C#脚本模板 - Unity文档
- en: Script templates are what Unity uses to generate the default C# code when new
    scripts are created, providing commonly used code as a starting point for your
    scripts. You can modify the templates with your own changes, additions, notes,
    and so on.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本模板是Unity在创建新脚本时生成默认C#代码所使用的，为你的脚本提供了一个常用的代码起点。你可以根据自己的更改、添加、注释等修改模板。
- en: 'Additional information can be found here: [https://support.unity.com/hc/en-us/articles/210223733-How-to-customize-Unity-script-templates](https://support.unity.com/hc/en-us/articles/210223733-How-to-customize-Unity-script-templates%0D)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在以下链接中找到：[如何自定义Unity脚本模板](https://support.unity.com/hc/en-us/articles/210223733-How-to-customize-Unity-script-templates%0D)
- en: Unity has also named the class in the script `PlayerController` as part of the
    script generation process (a function provided by the script template). Note that
    the filename and the class name must match for scripts that will need to be added
    as Components to GameObjects (otherwise, you’ll get a **Can’t add script component
    ‘ScriptName’ because the script class cannot be found.** error if you try). Refer
    to *Figure 2**.14* for an example of a new script’s contents.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在脚本生成过程中也将脚本中的类命名为 `PlayerController`（这是脚本模板提供的一个功能）。请注意，对于需要添加到GameObject中的脚本（否则，如果你尝试添加，你会得到一个错误：“无法添加脚本组件‘ScriptName’，因为找不到脚本类。’”），文件名和类名必须匹配。参见图2.14以了解新脚本内容的示例。
- en: VS2022 is installed and configured as the default script editor for the C# scripts
    in your project when the Unity Editor is installed. You can verify this by going
    to **Edit** | **Preferences…** and selecting **External Tools** – the **External
    Script Editor** dropdown will be set to **Microsoft Visual Studio** **2022 [version]**.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装 Unity 编辑器时，VS2022 已安装并配置为项目中 C# 脚本的默认脚本编辑器。您可以通过转到 **编辑** | **首选项…** 并选择
    **外部工具** – **外部脚本编辑器** 下拉菜单将设置为 **Microsoft Visual Studio** **2022 [版本]** 来验证此设置。
- en: 'Now that we have a script created and confirmed our script editor is configured,
    editing the script is as simple as doing any of the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个脚本并确认了脚本编辑器已配置，编辑脚本就像执行以下任何一项操作一样简单：
- en: Double-clicking on scripts in the **Project** Window.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **项目** 窗口中双击脚本。
- en: For components added to GameObjects in the Scene, right-clicking on the component
    in the **Inspector** window (or using the vertical ellipsis menu) and selecting
    **Edit Script**.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于添加到场景中 GameObject 的组件，在 **检查器** 窗口中右键单击组件（或使用垂直省略号菜单）并选择 **编辑脚本**。
- en: Opening from within VS using the **Unity Project** **Explorer** window.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Unity 项目** **资源管理器** 窗口从 VS 内部打开。
- en: We have learned how to create a new script and open it for editing in VS, but
    we still need to understand what the C# code we’re looking at means. In the next
    section, let’s dissect the generated C# code for the player controller script.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何在 VS 中创建一个新的脚本并打开它进行编辑，但我们仍然需要理解我们所看到的 C# 代码的含义。在下一节中，让我们剖析玩家控制器脚本的生成
    C# 代码。
- en: The C# Language – Object-oriented programming (OOP)
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 语言——面向对象编程（OOP）
- en: Unity provides coding support through the open source .NET **Common Language
    Runtime** (**CLR**) and uses the C# language – these are Microsoft technologies.
    C# is a managed language, which means that it provides a safe coding environment
    by – mostly – managing memory and the CLR safely executing the code (that is,
    not bytecode being executed by the operating system directly).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 通过开源的 .NET **公共语言运行时（CLR**）提供编码支持，并使用 C# 语言——这些都是微软的技术。C# 是一种托管语言，这意味着它通过——主要是——管理内存和
    CLR 安全执行代码（即不是由操作系统直接执行的字节码）提供了一个安全的编码环境。
- en: Code can be compiled to run **just-in-time** (**JIT**) or **ahead-of-time**
    (**AOT**), depending on which of the two scripting backends that Unity provides
    is used – Mono or **Intermediate Language to C++** (**IL2CPP**). The primary difference
    here is in compilation time, but some platform builds require one or the other.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以编译为即时运行（**JIT**）或预编译运行（**AOT**），具体取决于使用的 Unity 提供的两个脚本后端中的哪一个——Mono 或 **中间语言到
    C++（IL2CPP**）。这里的主要区别在于编译时间，但某些平台构建可能需要其中一个。
- en: Unity is a C++ game engine
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 是一个 C++ 游戏引擎
- en: The Unity game engine is written in C++, but C# is used as a “more friendly”
    coding language. The Unity Object type in C# is linked to a native C++ counterpart
    object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 游戏引擎是用 C++ 编写的，但 C# 被用作“更友好”的编程语言。C# 中的 Unity 对象类型与原生 C++ 对象相对应。
- en: Okay, the preceding paragraph was pretty boring. So, now comes the obligatory
    nerd warning… we’re going to talk about some programming concepts, principles,
    and design patterns in this and the next two sections. While these won’t teach
    you the basics of how to write a section of code that loops or even evaluates
    variables, I feel they are an important introduction at the onset of a developer’s
    journey.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，前面的段落相当无聊。所以，现在来点必要的“书呆子”警告…我们将在这和接下来的两个部分中讨论一些编程概念、原则和设计模式。虽然这些内容不会教你如何编写循环或评估变量的代码基础知识，但我认为它们是开发者旅程开始时的重要介绍。
- en: It’s essential to not only learn the basics (such as how to write code that
    loops and evaluates variables) but also to understand the broader concepts of
    how code should be structured – for the sake of your future developer self (and
    possibly for the benefit of your future developer teammates).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅学习基础知识（例如如何编写循环和评估变量的代码）很重要，而且还要理解代码应该如何结构的更广泛概念——为了你未来的开发者自我（以及可能为了你未来的开发者队友）。
- en: While I’ve attempted to make this section concise and provide relatable real-world
    analogies, these broader concepts on how code should be structured may be too
    early an introduction for some of you, so, in that case, don’t be afraid – still
    have a read and do your best to understand, but don’t worry if it’s difficult.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我已经尝试使这一节简洁并提供了相关的现实世界类比，但这些关于代码应该如何结构的更广泛概念可能对一些人来说还太早，所以在这种情况下，不要害怕——仍然要阅读并尽力理解，但如果很难理解，也不要担心。
- en: We’ll be implementing all of this as we work through the projects in the book
    (maybe you’ll even recall some of what was stated here or will want to come back
    and reread).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在书中通过项目来实现所有这些（也许你甚至会回忆起这里所说的内容，或者想要回来重新阅读）。
- en: Okay, with that now out of the way, let’s dive into the concepts that will level
    up your coding skills on your journey as a Unity developer!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经讲完了这些，让我们深入探讨那些将提升你在Unity开发者旅程中编码技能的概念！
- en: The C# language
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C#语言
- en: C# (pronounced as *C sharp*) is a modern, object-oriented, type-safe, managed
    programming language. **Object-oriented programming** is a computer programming
    model that organizes software design around objects, which can contain data and
    code (classes) rather than functions and logic.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C#（发音为 *C sharp*）是一种现代的、面向对象、类型安全、受管理的编程语言。**面向对象编程**是一种计算机编程模型，它将软件设计围绕对象组织，对象可以包含数据和代码（类），而不是函数和逻辑。
- en: C# primarily being a type-safe language means that specific types can only interact
    through their defined protocols, which ensures each type’s consistency. For instance,
    you cannot write code to interact with a string type the same as if it were a
    number type.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: C#主要是一种类型安全的语言，这意味着特定类型只能通过它们定义的协议进行交互，这确保了每种类型的连续性。例如，你不能像与数字类型交互一样编写与字符串类型交互的代码。
- en: 'OOP has four basic concepts for working with objects. We’ll review them briefly
    now and apply these concepts in practice while writing the code for our game in
    the upcoming chapters:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程有四个基本概念用于处理对象。我们现在将简要回顾这些概念，并在接下来的章节中编写游戏代码时应用这些概念：
- en: '**Encapsulation**: Hide the internal data and behavior of an object (class)
    from other objects and only allow access through public methods; preventing objects
    from modifying other objects directly reduces the chance of making mistakes external
    to the object.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：隐藏对象的内部数据和行为（类）以防止其他对象访问，并且只允许通过公共方法访问；防止对象直接修改其他对象可以减少外部错误发生的可能性。'
- en: '**Abstraction**: An incomplete implementation that hides specific details and
    only provides required information but is also not associated with any particular
    instance, since an abstract class is intended only to be a base class of other
    classes. It provides a template to organize an object hierarchy with required
    details, such as a spotlight (object) being a type of light (abstract class) that
    requires a brightness property.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：一个不完整的实现，它隐藏特定细节，只提供所需信息，但也不与任何特定实例相关联，因为抽象类仅打算成为其他类的基类。它提供了一个模板，用于组织具有所需细节的对象层次结构，例如，聚光灯（对象）是光（抽象类）的一种类型，它需要一个亮度属性。'
- en: '**Inheritance**: Abstraction is possible due to inheritance because a derived
    class inherits all properties and methods of the base class when creating a new
    class from it, which means we can reuse, extend, and modify the behavior of the
    base class. In the preceding light example, a point light will have the same brightness
    property as the spotlight if both are inherited from the light abstract base class.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：由于继承，抽象成为可能，因为当从一个基类创建新类时，派生类继承了基类的所有属性和方法，这意味着我们可以重用、扩展和修改基类的行为。在前面的简单示例中，如果点光源和聚光灯都从光抽象基类继承，那么它们将具有相同的亮度属性。'
- en: '**Polymorphism**: This is a Greek word, meaning *one name with many forms*
    or *having many forms*, which we can apply in C# to mean one name with multiple
    functions. Polymorphism allows a class to have multiple implementations with the
    same name by overriding it, thanks to inheritance.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**：这是一个希腊词，意思是*一个名称具有多种形式*或*具有多种形式*，在C#中我们可以将其理解为具有多个函数的一个名称。多态性允许一个类通过重写它来拥有多个具有相同名称的实现，这要归功于继承。'
- en: Continuing with the preceding light example, we can implement inherited methods
    from the base class differently across the spotlight and point light abstractions
    by having different code for a `ChangeLightRadius()` method – a spotlight has
    a *cone* *of light*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的光示例，我们可以通过为`ChangeLightRadius()`方法提供不同的代码，在不同的聚光灯和点光源抽象中实现从基类继承的方法，聚光灯有一个*锥形*
    *光束*。
- en: In contrast, a point light is omnidirectional, so it behaves differently. Polymorphism
    helps in code reuse since classes, once written, tested, and implemented, can
    be reused as required and save a lot of time while keeping things more logically
    structured.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，点光源是全方向的，因此它的行为不同。多态性有助于代码重用，因为一旦编写、测试和实现，类就可以根据需要重用，节省大量时间，同时使事物更加逻辑化。
- en: Additional reading | C#
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | C#
- en: '**Microsoft C# documentation for object-oriented** **programming**: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程的 Microsoft C# 文档**：[https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/)'
- en: The MonoBehaviour class
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 类'
- en: The `MonoBehaviour` class is the base class that every Unity script assignable
    to a GameObject derives from – this is Unity’s **component-based architecture**.
    You’ve seen the word *class* mentioned previously, so for clarity, a class is
    an object type. You will be creating custom object types that group variables,
    methods, and events together to give your script data and provide its intended
    function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 类是每个可以分配给 GameObject 的 Unity 脚本的基类——这是 Unity 的**组件化架构**。你之前已经看到过“类”这个词，所以为了清晰起见，类是一种对象类型。你将创建自定义对象类型，将变量、方法和事件组合在一起，以给你的脚本提供数据和实现其预期功能。'
- en: Deriving the class from `MonoBehaviour` – due to inheritance – provides a base
    set of variables, methods, and events for components added to GameObjects; this
    is also a requirement – you cannot add a script to a GameObject unless it inherits
    from `MonoBehaviour`. We’ll be using the functionality the `MonoBehaviour` base
    class provides for our custom script components throughout the projects in the
    book.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `MonoBehaviour` 继承类——由于继承——为添加到 GameObject 的组件提供了一组基础变量、方法和事件；这也是一个要求——除非继承自
    `MonoBehaviour`，否则你不能将脚本添加到 GameObject。在本书的项目中，我们将使用 `MonoBehaviour` 基类为我们自定义脚本组件提供的功能。
- en: Important note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Due to the nature of the **MonoBehaviour** class requiring it to be an instance
    of an object in the **Scene Hierarchy**, you cannot use the **new** keyword to
    create a new instance of it, as you could for a class that does not derive from
    anything.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **MonoBehaviour** 类需要它是 **场景层次结构**中对象的实例，因此你不能使用 **new** 关键字来创建其新实例，就像你为不继承任何类的类那样做。
- en: 'The code for the new `PlayerController` class we created previously, as generated
    from the default Unity template, already derives from `MonoBehaviour` for us –
    as denoted by `:` just after the `public class` declaration line in the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的 `PlayerController` 类的代码，由默认的 Unity 模板生成，已经为我们继承自 `MonoBehaviour`——正如以下
    `public class` 声明行之后的冒号（`:`）所示：
- en: '[PRE0]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: // (C#) | Code commenting
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: // (C#) | 代码注释
- en: A single-line **comment** is started with two forward slashes (**//**). The
    C# compiler will strip out this text and ignore it when running the program.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 单行**注释**以两个反斜杠（**//**）开始。C# 编译器会在运行程序时移除这些文本并忽略它们。
- en: Don’t be afraid to comment on anything and everything in the code to clarify
    the intent. There are always at least two people looking at your code when programming
    – you and yourself in 6 months’ time (or sometimes on any Monday morning). You
    *will* forget why you did what you did.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕对代码中的任何内容进行注释以阐明意图。在编程时，总会有至少两个人在查看你的代码——你和你自己在 6 个月后（或者有时在任何周一早上）。你*会*忘记你为什么要这样做。
- en: '**Self-commenting code**/**self-documenting code** is something that you may
    hear when discussing the topic of code commenting, which relies on good class,
    method, and variable naming. This, of course, is important. Still, my opinion
    is that you can spend an awful lot of time deliberating what to name things –
    while interrupting your train of thought – where a simple few words in a comment
    can instead bring quick clarity to the desired intention.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**自注释代码**/**自文档代码**是讨论代码注释时可能会听到的一个术语，它依赖于良好的类、方法和变量命名。这当然是重要的。然而，我的观点是，你可以花费大量时间来深思熟虑地命名事物——这可能会打断你的思路——而简单的几句话在注释中可以迅速带来清晰的意图。'
- en: The `Start()` and `Update()` methods are also provided for us. `MonoBehaviour`
    provides Message events for initializing any code in `Start()` and running code
    on each frame update in `Update()`. There are several other Message events that
    `MonoBehaviour` provides, and we’ll be exploring them in the upcoming chapters.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 和 `Update()` 方法也为我们提供了。`MonoBehaviour` 提供了初始化任何代码的 Message 事件，并在每一帧更新时运行代码的
    `Update()`。`MonoBehaviour` 还提供了其他几个 Message 事件，我们将在接下来的章节中探讨它们。'
- en: namespace (C#)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间（C#）
- en: '**using UnityEngine;** at the top of the preceding **PlayerController** code
    example is what gives the containing code access to the **MonoBehaviour** base
    class. **Namespaces** are a way of organizing and providing levels of separation
    in your code. They are handy for providing containers to control the scope of
    classes and methods in larger projects. You can, and should, add your own namespaces
    to your classes.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 UnityEngine;** 在上一个 **PlayerController** 代码示例的顶部是赋予包含代码访问 **MonoBehaviour**
    基类权限的关键。**命名空间** 是一种组织和提供代码中分离层次的方式。它们在为大型项目中的类和方法提供容器以控制作用域时非常有用。你可以，并且应该，为你的类添加自己的命名空间。'
- en: With the basics of understanding how to create a new C# script, open it in the
    VS IDE, and identify the essential parts of a `MonoBehaviour`-derived class out
    of the way, we can now explore some best-practice principles to follow as we write
    code for our game with SOLID principles.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了如何创建新的 C# 脚本、在 VS IDE 中打开它以及识别从 `MonoBehaviour` 派生类的基本部分之后，我们现在可以探索一些最佳实践原则，这些原则是我们编写使用
    SOLID 原则的游戏代码时应该遵循的。
- en: SOLID principles
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOLID 原则
- en: '**SOLID** is an acronym adopted to represent the first five principles of object-oriented
    design by Robert C. Martin and applies to various programming languages, not just
    C#. They are basic design principles to keep the code you write maintainable and
    extensible while avoiding refactoring (restructuring existing code) unnecessarily
    in the future. The resulting code should be easily read and followed by other
    developers – avoid writing spaghetti code!'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID** 是一个缩写，用于表示罗伯特·C·马丁提出的面向对象设计的五个基本原则，适用于各种编程语言，而不仅仅是 C#。它们是基本的设计原则，旨在保持你编写的代码可维护和可扩展，同时避免在未来不必要地重构（重构现有代码）。生成的代码应该易于其他开发者阅读和遵循——避免编写意大利面代码！'
- en: Spaghetti code
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码
- en: '**Spaghetti code** is a phrase used to describe unstructured and difficult-to-understand-and-maintain
    source code in your projects. The cause can be attributed to several factors,
    which usually boil down to not following best practices such as SOLID principles,
    **don’t repeat yourself** (**DRY**), and clean code – code that is formatted correctly
    and organized in a manner that is easily read or modified by others, or by yourself
    in 6 months’ time!'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**意大利面代码** 是一个用来描述项目中无结构、难以理解和维护的源代码的短语。原因可以归因于几个因素，通常归结为没有遵循最佳实践，如 SOLID 原则、**不要重复自己**（**DRY**）和清洁代码——格式正确且以易于他人或自己在
    6 个月后阅读或修改的方式组织的代码！'
- en: 'The SOLID principles are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 原则是以下内容：
- en: '**S –** **single-responsibility principle****(SRP)**: Each class or function
    (a *function* for a language-agnostic term, but I will refer to functions in C#
    as methods) in your code should only have a single responsibility.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S –** **单一职责原则**（**SRP**）：你的代码中的每个类或函数（对于语言无关的术语，但我会将 C# 中的函数称为方法）应该只有一个职责。'
- en: It means *do one thing* and not everything, including the kitchen sink! Everything
    within the class should contribute to the one reason it exists. Multiple single-function
    classes can work together to complete larger, more complex tasks. If something
    breaks, it’s generally easier to know where the bug exists, and it will also be
    isolated from that class.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 *只做一件事* 而不是所有事情，包括厨房用具！类内的所有内容都应该有助于它存在的单一原因。多个单功能类可以协同工作以完成更大、更复杂的任务。如果出现问题，通常更容易知道错误在哪里，并且它也将与该类隔离。
- en: '**O –** **open-closed principle** **(OCP)**: Classes can be extended but not
    modified.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O –** **开闭原则**（**OCP**）：类可以被扩展但不能被修改。'
- en: No, this is not a contradiction; how can something be both open and closed simultaneously?
    Well, it means that a class should be open for extension but closed for modification.
    Through polymorphism, we can change the behavior of an abstract base class by
    the inheriting class while leaving the base class unmodified. By designing base
    classes that *never change*, you prevent undesirable changes that propagate to
    dependent classes, contributing to code that is not reusable and ultimately harder
    to work with.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这并不是一个矛盾；如何同时既是开放的又是封闭的？嗯，这意味着一个类应该对扩展开放但对修改封闭。通过多态，我们可以通过继承类来改变抽象基类的行为，同时不修改基类。通过设计永远不会改变的基类，你可以防止不希望的变化传播到依赖的类，从而有助于代码的可重用性，并最终使代码更难工作。
- en: '**L –** **Liskov substitution principle**: Methods that reference base classes
    must be able to use derived classes seamlessly.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L –** **Liskov 替换原则**：引用基类的方法必须能够无缝地使用派生类。'
- en: Any function that uses a reference to a base class should be able to use a derivative
    of that class without knowing it. That might sound a bit confusing, so let’s use
    the light example from the earlier OOP concepts – a method that references a light
    should not care whether that light is a spotlight or a point light. We can substitute
    a point light for a spotlight, and the code should just work.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用基类引用的函数都应该能够使用该类的派生类，而无需知道它。这听起来可能有点令人困惑，所以让我们使用之前OOP概念中的简单例子——一个引用灯的方法不应该关心那盏灯是聚光灯还是点光源。我们可以用一个点光源替换聚光灯，代码应该仍然可以正常工作。
- en: We can accomplish this substitution through the use of an **interface** (a type
    that is similar to a class, but it only represents a structure of declarations
    – this is commonly referred to as a **contract**, but you can also think of it
    as a *blueprint for a* *class definition*).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个**接口**（一种类似于类的类型，但它只代表声明结构——这通常被称为**契约**，但您也可以将其视为**类定义**的蓝图）来实现这种替换。
- en: An interface can also be used to implement the **open-closed principle** by
    having a base class take an interface as an abstract reference for injecting different
    functionality. The functionality can be extended while the reference in the closed
    base class remains the same.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接口还可以通过让基类接受接口作为抽象引用以注入不同功能来实现**开闭原则**。功能可以扩展，而封闭基类中的引用保持不变。
- en: '**I –** **Interface segregation principle**: Several smaller scope interfaces
    are preferred over a single monolithic interface.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I –** **接口分离原则**：几个较小范围的接口比单一的大规模接口更受欢迎。'
- en: Classes should not include behaviors they do not use in their single-responsibility
    role. In Martin’s original introduction, he describes it as a *disadvantage of
    fat interfaces*, where the functions of a large multipurpose interface can instead
    be broken up into groups of member functions to provide better cohesion. This
    can prevent classes from using interfaces that they do not require to function.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 类不应该包含在其单一职责角色中不使用的功能。在马丁的原始介绍中，他将其描述为**胖接口**的**缺点**，其中大型多用途接口的功能可以分解成成员函数的组，以提供更好的内聚性。这可以防止类使用它们不需要以实现功能的功能。
- en: '**D –** **Dependency inversion principle**: Use abstractions over direct class
    references.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D –** **依赖倒置原则**：使用抽象而不是直接类引用。'
- en: This last principle states that concrete classes should depend upon interfaces
    – or abstract functions and classes – rather than concrete functions and classes.
    Abstract classes should also not depend on concrete classes; interfaces should
    be used here. The advantage here means code requires less work to change because
    the interface abstractions decouple concrete classes – a change in one also does
    not break the other. Loosely coupled code is more flexible and easier to test.
    Yay!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个原则指出，具体类应该依赖于接口——或者抽象函数和类——而不是具体的函数和类。抽象类也不应该依赖于具体类；这里应该使用接口。这里的优势意味着代码需要更少的工作来更改，因为接口抽象解耦了具体类——一个类的更改也不会破坏另一个类。松散耦合的代码更灵活，更容易测试。太棒了！
- en: Additional reading | SOLID principles
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | SOLID原则
- en: 'To read the original quotes and ideas behind the SOLID principles, as introduced
    by Robert C. Martin, you can refer to this article: [https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/may/csharp-best-practices-dangers-of-violating-solid-principles-in-csharp](https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/may/csharp-best-practices-dangers-of-violating-solid-principles-in-csharp)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读由罗伯特·C·马丁提出的SOLID原则背后的原始引言和思想，您可以参考这篇文章：[https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/may/csharp-best-practices-dangers-of-violating-solid-principles-in-csharp](https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/may/csharp-best-practices-dangers-of-violating-solid-principles-in-csharp)
- en: 'Alternatively, just do some web searching on the subject: [https://www.google.com/search?q=SOLID+programming+principles](https://www.google.com/search?q=SOLID+programming+principles%0D)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，只需在主题上做一些网络搜索：[https://www.google.com/search?q=SOLID+programming+principles](https://www.google.com/search?q=SOLID+programming+principles%0D)
- en: After this brief introduction, you may not completely understand these principles,
    but don’t worry – we’ll be using them in practice in the upcoming chapters, so
    you will learn how they are implemented. With a basic understanding of the SOLID
    principles, we can now talk about design patterns that implement the ideas the
    SOLID principles present.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，你可能不完全理解这些原则，但不用担心——我们将在接下来的章节中实际使用它们，这样你就会了解它们是如何实现的。有了对SOLID原则的基本理解，我们现在可以讨论实现SOLID原则所提出思想的设计模式。
- en: Design patterns
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式
- en: Now that you know what the C# language is and some principles to keep in mind
    while coding your games, let’s see how to apply them in practice.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了C#语言是什么，以及编写游戏时需要注意的一些原则，让我们看看如何在实践中应用它们。
- en: When writing the code for your game, you can make your own decisions on how
    to approach the architecture. Within Unity, there aren’t any restrictions or specific
    ways things need to be set up – it can be as messy or as organized as you like.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为游戏编写代码时，你可以自己决定如何处理架构。在Unity中，没有任何限制或特定的设置方式——它可以像你喜欢的那么混乱或有序。
- en: However, it should be evident that the more disorganized and unstructured your
    code is, the harder it will be to work with and extend upon in the future. We’ve
    already touched on some fundamental principles with OOP and SOLID, but those are
    just principles to follow. To execute those principles, we use design patterns.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应该很明显，你的代码越无序、越不结构化，将来就越难与之合作和扩展。我们已经通过OOP和SOLID原则接触了一些基本原理，但那些只是需要遵循的原则。为了执行这些原则，我们使用设计模式。
- en: Common design patterns in games development
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏开发中的常见设计模式
- en: 'The following is a list of common design patterns used to solve common problems
    when writing code – this is not an extensive list by any means, and we’re only
    touching on the reasons for the patterns here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个常见设计模式的列表，用于在编写代码时解决常见问题——这绝对不是一个详尽无遗的列表，我们在这里只是简要介绍这些模式的原因：
- en: '`MyClass.Instance.MyMember` (where `Instance` is the static variable and `MyMember`
    is any publicly accessible variable or method).'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyClass.Instance.MyMember`（其中`Instance`是静态变量，`MyMember`是任何公开可访问的变量或方法）。'
- en: This pattern gets a bad reputation for misuse, but it can be pretty helpful
    for small projects – it’s quick and easy to implement and use everywhere (hello,
    game jams!). This reputation is mainly related to more extensive projects where
    static variables make for code that’s harder to troubleshoot and debug – the general
    sentiment is that when you make something accessible to every part of the code,
    you’re just asking for trouble!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式因为误用而声名狼藉，但对于小型项目来说却非常有帮助——它快速且易于实现，并且可以在任何地方使用（你好，游戏马拉松！）。这种声誉主要与更广泛的项目相关，在这些项目中，静态变量使得代码更难调试和调试——普遍的观点是，当你使代码的每一部分都易于访问时，你只是在自找麻烦！
- en: '`GetComponent()` method of its GameObject scripting API. Essentially, the locator
    will retrieve the reference to the required class or object instance so that it
    can be consumed in the calling method.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameObject脚本API中的`GetComponent()`方法。本质上，定位器将检索所需类或对象实例的引用，以便在调用方法中使用。
- en: '**Observer pattern (events)**: Another one of the most popular design patterns.
    This pattern enables a listener to register with and receive notifications from
    a provider. This is generally performed with a one-to-many relationship, where
    any number of listeners are notified when the provider object changes state and
    invokes the notification. This pattern in C# is implemented using events. An event
    is a special keyword in C# that enforces a proper pattern, where only the declaring
    class can invoke the notification.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者模式（事件）**：这是最受欢迎的设计模式之一。这种模式允许监听器注册到提供者并接收通知。这通常是通过一对一的关系来执行的，当提供者对象状态改变并调用通知时，任何数量的监听器都会收到通知。在C#中，这种模式是通过事件实现的。事件是C#中的一个特殊关键字，它强制执行正确的模式，只有声明类才能调用通知。'
- en: '`GameManager` class, where you could have states for loading, playing, paused,
    game over, win, lose, and so on. Events can be triggered when entering and exiting
    states to extend state-based functionality easily. The object the pattern is implemented
    on can also delegate state-related behavior to separate classes, such as a `Tick()`
    method called on every frame update.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameManager`类，其中可以包含加载、播放、暂停、游戏结束、胜利、失败等状态。当进入和退出状态时可以触发事件，以便轻松扩展基于状态的功能。实现该模式的对象还可以将状态相关行为委托给其他类，例如在每一帧更新时调用的`Tick()`方法。'
- en: '**Command pattern**: This pattern turns a request for executing functions into
    an object that contains all the required information about the request. The command
    pattern is popular in C# for when we want to delay or queue a request’s execution,
    or when we would want to keep track of the sequence of operations (such as in
    a replay system).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令模式**：这种模式将执行函数的请求转换为一个包含所有请求所需信息的对象。当我们需要延迟或排队请求的执行，或者我们想要跟踪操作序列（如回放系统）时，命令模式在C#中很受欢迎。'
- en: The other benefit of this pattern is that it decouples the invoking class from
    the object that executes the process – loosely coupled code (one class will not
    affect another class, reducing dependency) is easier to test and maintain!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的另一个好处是它将调用类与执行过程的对象解耦——松散耦合的代码（一个类不会影响另一个类，减少依赖）更容易测试和维护！
- en: '`Update()` method, each one is added to a list of scripts that need to be updated
    in each frame.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`方法，每个都会添加到需要每帧更新的脚本列表中。'
- en: This pattern can reduce the number of `Update()` methods being called each frame
    to reduce overhead – these Unity messages are called from native C++ to managed
    C#, and they have a cost! For example, the manager will be the only object with
    an `Update()` method that runs on each frame update, while the many instances
    referenced only have a `Tick()` method that the manager calls.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以减少每帧调用`Update()`方法的次数，以减少开销——这些Unity消息是从原生C++调用到托管C#的，它们是有成本的！例如，管理器将是唯一具有在每帧更新时运行的`Update()`方法的对象，而许多引用的实例仅有一个管理器调用的`Tick()`方法。
- en: Additional reading | Programming patterns
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | 编程模式
- en: '**Game Programming Patterns** (the web version is free): [https://gameprogrammingpatterns.com/contents.xhtml](https://gameprogrammingpatterns.com/contents.xhtml)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏编程模式**（网络版免费）：[https://gameprogrammingpatterns.com/contents.xhtml](https://gameprogrammingpatterns.com/contents.xhtml)'
- en: Optimization note
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 优化提示
- en: If you don’t need to use the Unity message events, then remove them from your
    code – even empty **Start()** and **Update()** methods are still cached and called
    on every script derived from **MonoBehaviour**, and in the case of **Update()**,
    it will be called on every frame update!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要使用Unity消息事件，那么请从你的代码中移除它们——即使是空的**Start()**和**Update()**方法仍然被缓存并在每个从**MonoBehaviour**派生的脚本上调用，在**Update()**的情况下，它将在每一帧更新时被调用！
- en: In this section, you learned about creating scripts and editing them with the
    VS2022 IDE and received an introduction to the C# language, SOLID principles,
    and some common design patterns.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用VS2022 IDE创建和编辑脚本，并了解了C#语言、SOLID原则和一些常见的设计模式。
- en: We’ll dig into specific use cases in the upcoming chapters as we flesh out the
    features and functionality in our collection game, starting with the next section,
    where we’ll put together a simple player controller for our ladybug character.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨具体用例，随着我们在我们的收集游戏中完善功能和功能，从下一节开始，我们将为我们的瓢虫角色组合一个简单的玩家控制器。
- en: Coding a simple player controller with the new Input System
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的输入系统编写简单的玩家控制器
- en: 'You’ll be surprised to find that most of the work to make our player character
    move has already been done for us by Unity’s features. The features that we’ll
    be looking at in this section are as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，使我们的玩家角色移动的大部分工作已经被Unity的功能为我们完成了。本节中我们将探讨以下功能：
- en: '**The new Input System**: For receiving keyboard device input from the player.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新的输入系统**：用于接收来自玩家的键盘设备输入。'
- en: '**2D physics engine**: For translating input values into movement and providing
    interaction with objects in the environment.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2D物理引擎**：用于将输入值转换为运动并提供与环境对象的交互。'
- en: New Input System
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新输入系统
- en: 'The new **Input System** is a package that provides input device support for
    controlling objects in your project in a flexible and configurable way. It also
    replaces the legacy Input Manager. We’ll first want to make sure that it’s installed
    to use it:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 新的**输入系统**是一个提供对输入设备支持的包，它以灵活和可配置的方式控制项目中的对象。它还取代了传统的输入管理器。我们首先需要确保它已安装以便使用：
- en: Open the Package Manager from the **File** menu by going to **Windows** | **Package
    Manager** and following these steps.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件**菜单中的**窗口** | **包管理器**来打开包管理器，并按照以下步骤操作。
- en: 'Make sure the **Packages** drop-down list is set to **Package: Unity Registry**
    (just under the window’s tab).'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将**包**下拉列表设置为**包：Unity注册表**（位于窗口标签下方）。
- en: Find **Input System** in the list of packages (the dialog’s left side) and click
    to select it.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包列表（对话框的左侧）中找到**输入系统**并点击以选择它。
- en: Now, click the **Install** button in the window’s bottom-right corner.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击窗口右下角的**安装**按钮。
- en: '![Figure 2.15 – The Input System installation Package Manager](img/B18347_02_15.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – 输入系统安装包管理器](img/B18347_02_15.jpg)'
- en: Figure 2.15 – The Input System installation Package Manager
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 输入系统安装包管理器
- en: If, once the installation completes, you receive a warning stating **The project
    is using the new input system package, but the native platform backends for the
    new input system are not enabled in player settings**, go ahead and click **Yes**
    to enable the backends. Note that this will restart the Editor – so, if you have
    unsaved changes in your Scene, click **Save** when prompted.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装完成后，你收到一个警告说**项目正在使用新的输入系统包，但新的输入系统的本地平台后端在玩家设置中未启用**，请点击**是**以启用后端。请注意，这将重新启动编辑器
    – 因此，如果你在场景中有未保存的更改，请在提示时点击**保存**。
- en: Additional reading | Unity documentation
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Input** **System**: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.3/manual/](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.3/manual/)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入** **系统**：[https://docs.unity3d.com/Packages/com.unity.inputsystem%401.3/manual/](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.3/manual/)'
- en: We’re ready to start coding our player movement in the next section with the
    Input System installed.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好在安装了输入系统后，在下一节中开始编写玩家移动的代码。
- en: Player controller script
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家控制器脚本
- en: 'Before we jump into coding, we’ll first need to understand that there are two
    ways we can work with the new Input System:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们首先需要了解我们可以用两种方式与新的输入系统一起工作：
- en: Receiving input directly from an **Input Device**
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从**输入设备**接收输入
- en: Receiving input through an **Input** **Action** indirectly
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间接通过**输入** **动作**接收输入
- en: We’ll cover both of these approaches in the book, but we’ll start with reading
    directly from an Input Device – the keyboard. Having determined our approach to
    receiving player input, let’s start coding that now, since we’ve already created
    our ladybug character’s player controller script in a previous section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在书中介绍这两种方法，但我们将从直接从输入设备读取开始 – 键盘。在确定了接收玩家输入的方法后，我们现在就开始编码，因为我们已经在之前的一个部分中创建了我们的瓢虫角色的玩家控制器脚本。
- en: Receiving keyboard input
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收键盘输入
- en: Processing player input through the keyboard directly from the Input Device
    is straightforward. You simply need to get a reference to the current keyboard
    device and read the property appropriate for the desired function. We read input
    in the `Update()` method because it runs every frame.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键盘直接从输入设备处理玩家输入是直接的。你只需要获取当前键盘设备的引用并读取适合所需功能的属性。我们在`Update()`方法中读取输入，因为它每帧都会运行。
- en: 'Let’s have a look at this portion of the `Update()` method in the following
    `PlayerController` code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下`PlayerController`代码中的`Update()`方法这一部分：
- en: '[PRE1]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Within the `Update()` method (between the `{}` squiggly brackets), we start
    by assigning a variable (a container for storing data) for the current keyboard
    device with `var keyboard = Keyboard.current;` (in C#, every line of code to be
    executed must end in a semicolon).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`方法（位于`{}`波浪括号之间），我们首先通过`var keyboard = Keyboard.current;`（在C#中，每行要执行的代码必须以分号结尾）为当前键盘设备分配一个变量（用于存储数据的容器）。
- en: var (C#)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: var（C#）
- en: The **var** keyword is an implicitly typed variable that infers the type from
    the right side of the assignment statement (what comes after the equals sign).
    This means that we don’t need to use an **int** type for a math expression that
    returns an integer value – **var** will infer that it should be of an **int**
    type.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**var**关键字是一个隐式类型的变量，它从赋值语句的右侧（等号之后的内容）推断类型。这意味着我们不需要为返回整数值的数学表达式使用**int**类型
    - **var**将推断它应该是**int**类型。'
- en: '`Keyboard.current` is available to our code from the Input System, simply by
    including the namespace for `InputSystem` at the top of our script with the `using`
    keyword:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`Keyboard.current`通过输入系统对我们的代码可用，只需在我们的脚本顶部使用`using`关键字包含`InputSystem`命名空间即可：'
- en: '[PRE2]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the current keyboard device is assigned to our keyboard variable, we can
    check to make sure a keyboard is connected by testing the variable against a `null`
    value, using the `== operator` (a single `=` is for assigning a value, whereas
    a double `==` is an *is* *equal?* operation).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将当前键盘设备分配给我们的键盘变量，我们可以通过将变量与 `null` 值进行比较来检查是否已连接键盘，使用 `== 操作符`（一个 `=` 是用于赋值，而两个
    `==` 是 *是* *等于* 操作）。
- en: 'Here, we can see that if the keyboard value is equal to `null`, we stop running
    the code in this method immediately by using the `return` keyword:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如果键盘值等于 `null`，我们可以通过使用 `return` 关键字立即停止在此方法中运行代码：
- en: '[PRE3]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: null (C#)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: null (C#)
- en: The **null** value means there is *no* *object* assigned.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**null** 值表示没有 *对象* 被分配。'
- en: '[PRE4]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: if (C#)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: if (C#)
- en: An **if** statement tests whether a condition is evaluated to **true** or **false**
    and executes the directly preceding block or line of code if **true**.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **if** 语句测试条件是否评估为 **true** 或 **false**，如果为 **true**，则执行直接 preceding 的块或代码行。
- en: In C#, a variable type that holds a **true** or **false** value is called a
    **bool** type (Boolean). A **bool** type has a default value of **false** when
    it’s declared without a specific value being assigned.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，一个存储 **true** 或 **false** 值的变量类型称为 **bool** 类型（布尔）。当未指定特定值时，**bool**
    类型有一个默认值 **false**。
- en: Moving with 2D physics
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 2D 物理移动
- en: We are receiving input from the player and are ready to process it now. Yay!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接收玩家的输入，并且现在准备好处理它。耶！
- en: Technically speaking, following the single responsibility principle, we’d now
    create a second script to handle the player movement. For now, since our collection
    game is small, with a single input, it doesn’t require a more complex architecture.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，遵循单一责任原则，我们现在将创建第二个脚本来处理玩家移动。目前，由于我们的收集游戏很小，只有一个输入，它不需要更复杂的架构。
- en: 'When the player is holding down the *spacebar*, let’s move them forward while
    the key is held down and stop them moving when it’s released:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下 *空格键* 时，让我们在按键按下时向前移动他们，并在释放时停止移动：
- en: '[PRE6]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: else if (C#)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: else if (C#)
- en: An **else if** statement tests a new condition only if the previous **if** statement
    evaluates to a **false** condition and executes the directly proceeding block
    or line of code if **true**. To evaluate multiple conditions, you can cascade
    multiple **else if** statements as many times as is required.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **else if** 语句仅在之前的 **if** 语句评估为 **false** 条件时测试新的条件，如果为 **true**，则执行直接 proceeding
    的块或代码行。为了评估多个条件，你可以级联多个 **else if** 语句，直到满足所需次数。
- en: Using the `Update()` method is excellent for processing player input. Still,
    we want to move the player using `2D Physics`, and for that, we need to use `FixedUpdate()`
    – this is called every physics `0.02` (this value, generally, doesn’t need to
    be changed).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Update()` 方法非常适合处理玩家输入。然而，我们想要使用 `2D Physics` 来移动玩家，为此，我们需要使用 `FixedUpdate()`
    – 这会在每次物理 `0.02`（这个值通常不需要更改）时被调用。
- en: You might already wonder how we can tell a different Unity message event that
    is being called *automatically* to execute code from another Unity message event.
    We’ll simply use a `bool` variable as a *flag* to indicate that code should be
    executed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经想知道我们如何告诉一个不同的 Unity 消息事件，该事件是 *自动* 调用来执行另一个 Unity 消息事件的代码。我们将简单地使用一个 `bool`
    变量作为 *标志* 来指示应该执行代码。
- en: 'Let’s create one now:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个现在：
- en: '[PRE7]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Public and private accessors (C#) | Serialization
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 公共和私有访问器（C#） | 序列化
- en: '**Accessors** such as **public** and **private** define the scope of a variable
    for how it can be accessed internally and externally by the class. A public accessor
    assigned to a variable makes it accessible to other external classes, whereas
    a private accessor makes it accessible only within the class. If you do not explicitly
    declare an accessor, the default will be internal (refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)).'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问器**，如 **public** 和 **private**，定义了变量的作用域，即它如何被类内部和外部访问。将 `public` 访问器分配给变量使其对其他外部类可访问，而将
    `private` 访问器使其仅对类内部可访问。如果你没有明确声明访问器，默认将是 `internal`（参考[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)）。'
- en: Another function of declaring a variable public is Unity marking it for serialization.
    **Serialization** is the process of transforming an object’s state into a format
    that Unity can use – this is required for fields to be available in the **Inspector**
    window.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个变量为公共的另一个功能是Unity将其标记为序列化。**序列化**是将对象状态转换为Unity可以使用的格式的过程——这对于在**检查器**窗口中可用字段是必需的。
- en: We’ve created the variable as a private field to only be accessible within the
    `PlayerController` class. We did not assign a value when declaring it so that
    it will have a starting value of `false` – our flag will not prompt code execution
    when the program starts.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量创建为私有字段，以便仅在`PlayerController`类内部可访问。我们在声明时没有为其赋值，因此它将有一个初始值`false`——我们的标志在程序启动时不会触发代码执行。
- en: 'To execute the code in `FixedUpdate()` to move the player, we’ll set it to
    `true`, with the *spacebar* key being held down and set back to `false` when it
    is released:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`FixedUpdate()`中执行移动玩家的代码，我们将它设置为`true`，当按下**空格键**时，并在释放时将其设置回`false`：
- en: 'Our player input code will now look like this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们玩家的输入代码现在看起来是这样的：
- en: '[PRE8]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And we’ll check the value of the `_shouldMoveForward` Boolean flag in `FixedUpdate()`
    like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样在`FixedUpdate()`中检查`_shouldMoveForward`布尔标志的值：
- en: '[PRE9]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Refer to the **InputSystem** documentation for all the possible properties and
    methods available on a keyboard device. You can also see what is available right
    within the VS IDE when pressing the *.* (period/dot) character. IntelliSense will
    provide a list of all the possible choices for completion (for example, when typing
    **keyboard** and then **.**, the popup list will have both the **IsPressed()**
    method and the **wasReleasedThisFrame** property listed).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅**InputSystem**文档，了解键盘设备上所有可能的属性和方法。您还可以在按下**.*（点号/句点）**字符时，在VS IDE中查看可用的内容。IntelliSense将提供所有可能的完成选项列表（例如，当输入**keyboard**然后**.**时，弹出列表将列出**IsPressed()**方法和**wasReleasedThisFrame**属性）。
- en: Rigidbody2D
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Rigidbody2D
- en: Moving objects in the Scene with the ability to interact with other objects
    is really quite easy when using the physics system – you get a lot of value *out
    of the box*, since you don’t have to program these interactions yourself. For
    example, moving the player is as simple as setting a velocity value for the direction
    of movement.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用物理系统时，在场景中移动具有与其他对象交互能力的对象非常简单——您可以得到很多**现成的**价值，因为您不需要自己编程这些交互。例如，移动玩家就像为移动方向设置一个速度值一样简单。
- en: 'Consider the following addition to our `FixedUpdate()` method:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对`FixedUpdate()`方法的补充：
- en: '[PRE10]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve added a line that assigns a value to an `Rb` object’s `velocity` property,
    by multiplying the `transform.up` value with a `MoveSpeed` variable’s value. `Rb`
    is a public field we declare, representing the `Rigidbody2D` component that we’ll
    add to the player GameObject in the `Rb` as public, assignments can also be made
    in the **Inspector** window.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一行代码，将一个值赋给`Rb`对象的`velocity`属性，通过将`transform.up`值与`MoveSpeed`变量的值相乘。`Rb`是我们声明的公共字段，代表我们将添加到玩家GameObject中的`Rigidbody2D`组件，作为公共字段，也可以在**检查器**窗口中进行赋值。
- en: 'Let’s add the declaration for `Rb` and the `MoveSpeed` variable – with a default
    value of `10f` (`f` indicates that this is a float value, a numeric value stored
    in floating-point representation) – to provide some speed to the movement:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`Rb`和`MoveSpeed`变量的声明——默认值为`10f`（`f`表示这是一个浮点值，一个以浮点表示法存储的数值）——以提供一些移动速度：
- en: '[PRE11]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip | VS IntelliSense
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 | VS IntelliSense
- en: You can type **MoveSpeed** first in the **Rb.velocity** assignment line of code,
    but VS will complain that it is not declared yet with a squiggly red underline.
    You can easily add the variable declaration to the code by first clicking on the
    underlined word, then pressing *Alt*/*Cmd* + *Enter*, and selecting the **Generate**
    field under **MoveSpeed**.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**Rb.velocity**赋值行代码中首先输入**MoveSpeed**，但VS会抱怨它尚未声明，并显示一条红色的波浪线。您可以通过首先单击下划线单词，然后按*Alt*/*Cmd*
    + *Enter*，并在**MoveSpeed**下选择**生成**字段，轻松地将变量声明添加到代码中。
- en: 'By setting a value to `velocity`, we tell the object to move in a specified
    direction – that direction is indicated by `transform.up` – and at the speed indicated
    by the `MoveSpeed` multiplier value. The player sprite will always move in the
    direction indicated by `transform.up`, no matter its rotation, as seen in the
    following diagram:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`velocity`的值，我们告诉对象向指定方向移动——这个方向由`transform.up`指示——并且以`MoveSpeed`乘数值指示的速度移动。玩家精灵将始终沿着`transform.up`指示的方向移动，无论其旋转如何，如下面的图所示：
- en: '![Figure 2.16 – The ladybug Sprite Transform.up direction](img/B18347_02_16.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 –瓢虫精灵的Transform.up方向](img/B18347_02_16.jpg)'
- en: Figure 2.16 – The ladybug Sprite Transform.up direction
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 –瓢虫精灵的Transform.up方向
- en: Transform.up (Unity API)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Transform.up（Unity API）
- en: This manipulates the position of an object on the *Y* axis (the green axis)
    in world space. It’s similar to **Vector3.up**, but **Transform.up** instead moves
    the object while considering its rotation.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这操作的是对象在**Y**轴（绿色轴）上的位置（世界空间中的位置）。它与**Vector3.up**类似，但**Transform.up**在移动对象时会考虑其旋转。
- en: Other axes available are right (the *X* axis – red) and forward (the *Z* axis
    – blue).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的轴有右侧（**X**轴——红色）和前方（**Z**轴——蓝色）。
- en: When the player releases the *spacebar* key, `_shouldMoveForward` is assigned
    `false`, which results in `Rb.velocity` being set to `Vector2.zero` – velocity
    is a `Vector2` structure, meaning that it can be used to represent 2D positions
    by `X` and `Y` values, as represented by this notation – `Vector2(float, float)`.
    `Vector2.zero` is shorthand for `Vector2(0`, `0)`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家释放**空格键**时，`_shouldMoveForward`被赋值为`false`，这导致`Rb.velocity`被设置为`Vector2.zero`——速度是一个`Vector2`结构，意味着它可以用来通过`X`和`Y`值表示2D位置，正如这种表示法——`Vector2(float,
    float)`所示。`Vector2.zero`是`Vector2(0, 0)`的简写。
- en: Additional reading | Unity documentation
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Vector2**: [https://docs.unity3d.com/ScriptReference/Vector2.xhtml](https://docs.unity3d.com/ScriptReference/Vector2.xhtml)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vector2**: [https://docs.unity3d.com/ScriptReference/Vector2.xhtml](https://docs.unity3d.com/ScriptReference/Vector2.xhtml)'
- en: Vector Math, Mathf, and Quaternion
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量数学、Mathf和Quaternion
- en: The code, so far, has tackled moving the player character in a forward direction
    in relation to the direction the sprite is facing. Still, it’s currently only
    facing one direction – up. We’ll guide our player around the environment by having
    it look in the direction of the mouse pointer – steering the forward movement.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码已经解决了根据精灵面向的方向向前移动玩家角色的方向问题。然而，它目前只面向一个方向——向上。我们将通过让玩家朝向鼠标指针的方向看，来引导玩家在环境中移动——控制前进运动。
- en: We can accomplish this by reading another input device – the mouse – and using
    some vector math to rotate the player object, according to where the mouse pointer
    is positioned on the screen.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取另一个输入设备——鼠标——并使用一些向量数学来根据鼠标指针在屏幕上的位置旋转玩家对象来实现这一点。
- en: 'Have a look at the following `LookAtMousePointer()` method:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的`LookAtMousePointer()`方法：
- en: '[PRE12]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s analyze the code item by item:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐项分析代码：
- en: Just like how we verified we had a valid keyboard, `mouse` is being assigned
    and checked for `null` (stops running the code with `return` if none is assigned)
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们验证了键盘的有效性一样，`mouse`被分配并检查是否为`null`（如果没有分配，则使用`return`停止代码的执行）
- en: The `mousePos` variable is assigned by the return value of the `mouse.position.ReadValue()`
    method, which returns a `Vector2` position, and uses the main camera reference
    in `Scene (Camera.main)` to convert its `Vector2` screen space position to a `Vector3`
    world point (the 3D coordinate system the Unity engine uses).
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mousePos`变量通过`mouse.position.ReadValue()`方法的返回值赋值，该方法返回一个`Vector2`位置，并使用主相机引用`Scene
    (Camera.main)`将其`Vector2`屏幕空间位置转换为`Vector3`世界点（Unity引擎使用的3D坐标系）。'
- en: The direction from the mouse position to the `Rigidbody2D` position on the player
    is calculated using a simple vector math expression – subtracting one vector from
    another is a quick way to calculate the direction. Simple!
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过简单的向量数学表达式计算鼠标位置到玩家`Rigidbody2D`位置的方向——从一个向量减去另一个向量是计算方向的一种快速方法。简单！
- en: Note that you can only use vector arithmetic operations on the same vector type
    – here, we have `Vector3` representing the mouse position and `Vector2` representing
    the `Rigidbody2D` position. To treat the `mousePos` variable as `Vector2` in the
    expression, we cast the value by prepending `(Vector2)` to it (we only need the
    `x` and `y` values for 2D).
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你只能在同一向量类型上使用向量算术运算——这里，我们有 `Vector3` 表示鼠标位置，`Vector2` 表示 `Rigidbody2D` 位置。为了在表达式中将
    `mousePos` 变量作为 `Vector2` 处理，我们通过在它前面加上 `(Vector2)` 来进行类型转换（我们只需要 2D 的 `x` 和 `y`
    值）。
- en: Now, we need the rotation angle to apply to the player’s `Rigidbody2D`. Unity
    provides a math library for just such an occasion – `Mathf`. In particular, we’re
    using the `Atan2` method, which returns an angle in radians from a 2D vector.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将旋转角度应用到玩家的 `Rigidbody2D` 上。Unity 提供了一个数学库，正好用于这种情况——`Mathf`。特别是，我们使用的是
    `Atan2` 方法，它从 2D 向量返回一个弧度角度。
- en: We’ll actually want our angle value to be in degrees of rotation – not radians
    – so again, `Mathf` to the rescue. `Mathf.Rad2Deg` is a conversion constant (equal
    to *360 / (PI x 2)*) that we’ll multiply with the returned radians, and with that,
    we have our degrees of rotation value. The `SpriteRotationOffset` public variable
    provides an offset if the sprite’s direction is not facing `Transform.right` –
    the direction the equation results in (we do need a value of -90 degrees here,
    since our ladybug sprite is pointing up, not right).
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上希望我们的角度值以旋转度数表示——而不是弧度——所以，再次，`Mathf` 来拯救我们。`Mathf.Rad2Deg` 是一个转换常数（等于
    *360 / (PI x 2)*），我们将它与返回的弧度相乘，然后，我们就得到了旋转度数值。`SpriteRotationOffset` 公共变量提供了一个偏移量，如果精灵的方向不是面向
    `Transform.right` ——方程结果的方向（我们在这里确实需要一个 -90 度的值，因为我们的瓢虫精灵是指向上方的，而不是向右的）。
- en: Finally, we set the resulting angle (in degrees of rotation) to the `Rb.rotation`
    property!
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将得到的旋转角度（以旋转度数表示）设置为 `Rb.rotation` 属性！
- en: 'To make sure our player rotation is being set every frame, add a call to the
    `LookAtMousePointer()` method at the end of `Update()`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保玩家的旋转每帧都被设置，在 `Update()` 的末尾添加对 `LookAtMousePointer()` 方法的调用：
- en: '[PRE13]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Smoothing rotation
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平滑旋转
- en: Setting the `Rb.rotation` value for every frame update would be sufficient to
    make pointing the player in the direction of the mouse pointer work, but we can
    do better!
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧更新时设置 `Rb.rotation` 值足以使玩家指向鼠标指针的方向工作，但我们能做得更好！
- en: We can accomplish a smoother rotation and adjust the rotation speed to alter
    gameplay using an interpolation method that Unity provides, called **Slerp**.
    Slerp will smooth the rotation and remove abrupt rotations while providing a better
    game feel, enhancing the player experience.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Unity 提供的插值方法，称为 **Slerp**，来实现更平滑的旋转并调整旋转速度以改变游戏玩法。Slerp 将平滑旋转并消除突兀的旋转，同时提供更好的游戏感觉，增强玩家体验。
- en: Slerp (Unity API) | Additional reading | Unity documentation
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Slerp (Unity API) | 额外阅读 | Unity 文档
- en: '**Slerp** is shorthand for **spherically interpolated**. It provides a method
    that interpolates values between *A* and *B* by an amount of *T*. The difference
    between this and **linear interpolation** (**Lerp**) is that the *A* and *B* vectors
    are treated as directions instead of location points.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**Slerp** 是 **spherically interpolated** 的缩写。它提供了一个方法，通过一个名为 *T* 的量插值 *A* 和
    *B* 之间的值。与 **线性插值**（**Lerp**）的区别在于，*A* 和 *B* 向量被视为方向而不是位置点。'
- en: '**Quaternion.Slerp**: [https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.xhtml](https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.xhtml)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quaternion.Slerp**: [https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.xhtml](https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.xhtml)'
- en: 'Replace the direct rotation assignment (`Rb.rotation = angle;`) with the following
    code snippet:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 将直接旋转赋值（`Rb.rotation = angle;`）替换为以下代码片段：
- en: '[PRE14]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s break down this code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码：
- en: To interpolate the rotation value, we’ll need to use a slightly different approach
    using `Quaternion` (based on complex numbers that represent rotations that can
    easily be interpolated and what Unity uses internally to represent all rotations).
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了插值旋转值，我们需要使用一个稍微不同的方法，使用 `Quaternion`（基于表示旋转的复数，这些旋转可以很容易地进行插值，并且 Unity 内部用于表示所有旋转）。
- en: The first calculation we’ll need to get our angle degrees into a quaternion
    value (`var q`) is using the `AngleAxis()` method to calculate the rotation around
    an axis. Here, we provide `Vector3.forward` as our rotation axis – referring to
    *Figure 2**.16*, we can see that it will rotate the ladybug sprite on the *XY*
    plane, which is precisely what we want!
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要使用`AngleAxis()`方法来计算围绕轴的旋转，以便将我们的角度度数转换为四元数值（`var q`）。在这里，我们提供`Vector3.forward`作为我们的旋转轴——参照*图2**.16*，我们可以看到它将在*XY*平面上旋转瓢虫精灵，这正是我们想要的！
- en: Unlike with `Rb.rotation`, which required a float value for the angle degrees,
    we need to assign a quaternion value now, so we’ll have to use the `Rb.transform.rotation`
    property instead.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与需要浮点值作为角度度的`Rb.rotation`不同，我们现在需要分配一个四元数值，因此我们将不得不使用`Rb.transform.rotation`属性。
- en: Finally, we will use `Quaternion.Slerp()` to interpolate the rotation value,
    producing a smooth rotation from the player character’s current rotation to the
    desired rotation – pointing in the direction of the mouse pointer.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`Quaternion.Slerp()`来插值旋转值，从玩家角色的当前旋转到期望的旋转——指向鼠标指针的方向。
- en: We can change the rotation speed by using the `LookAtSpeed` public variable
    value. The speed value is multiplied by `Time.deltaTime` to make this a frame
    rate independent rotation speed (which means it will be consistent across all
    different performing systems that will run the game).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`LookAtSpeed`公共变量值来改变旋转速度。速度值乘以`Time.deltaTime`以使其成为帧率无关的旋转速度（这意味着它将在所有不同的运行游戏系统中保持一致）。
- en: Additional reading | Unity documentation
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Time.deltaTime**: [https://docs.unity3d.com/ScriptReference/Time-deltaTime.xhtml](https://docs.unity3d.com/ScriptReference/Time-deltaTime.xhtml)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time.deltaTime**: [https://docs.unity3d.com/ScriptReference/Time-deltaTime.xhtml](https://docs.unity3d.com/ScriptReference/Time-deltaTime.xhtml)'
- en: 'Our final variable declarations, including the newly added variables for `SpriteRotationOffset`
    and `LookAtSpeed`, with some default starting values assigned, look like the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的变量声明，包括为`SpriteRotationOffset`和`LookAtSpeed`新添加的变量，以及一些默认的起始值，如下所示：
- en: '[PRE15]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: PlayerController.cs Code
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController.cs 代码
- en: 'To view the completed code for the **PlayerCharacter** class, visit the GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project/Assets/Scripts)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看**PlayerCharacter**类的完整代码，请访问以下GitHub仓库：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project/Assets/Scripts)
- en: This section taught us how to read player input directly using Input Devices,
    move a `Rigidbody2D` object by manipulating its velocity, and implement smooth
    rotation using vector math and quaternions.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 本节教我们如何直接使用输入设备读取玩家输入，通过操作速度来移动`Rigidbody2D`对象，以及使用向量数学和四元数实现平滑旋转。
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced many subjects, including level design concepts, adding
    2D artwork to a project, preparing it with Unity’s 2D tooling as sprites, and
    using the prepared artwork to draw a 2D game environment with a **Tilemap**. We
    also created scripts using the C# language and Visual Studio IDE to add functionality
    to GameObjects, for reading input and moving the player character with physics.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了许多主题，包括关卡设计概念、将2D艺术作品添加到项目中，使用Unity的2D工具将其作为精灵准备，以及使用准备好的艺术作品使用**Tilemap**绘制2D游戏环境。我们还使用C#语言和Visual
    Studio IDE编写脚本，为GameObject添加功能，用于读取输入和用物理移动玩家角色。
- en: In the next chapter, we’ll add a virtual camera system to follow the ladybug
    character around the level, add a basic UI, and process conditions for winning
    and losing the game.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加一个虚拟相机系统来跟随瓢虫角色在关卡中移动，添加基本UI，并处理游戏胜负的条件。
