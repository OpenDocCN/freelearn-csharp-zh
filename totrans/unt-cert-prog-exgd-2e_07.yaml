- en: '*Chapter 7*: Creating a Game Loop and Mock Test'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：创建游戏循环和模拟测试'
- en: In the previous chapter, we moved from the `testLevel` scene (where we controlled
    the player ship) to a `shop` scene (buying and calibrating the player's ship).
    In this chapter, we will be following a similar trend of stretching out to the
    rest of the other game scenes in our `Scene` folder (found in the `Assets` folder).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从`testLevel`场景（我们在这里控制玩家飞船）移动到`shop`场景（购买和校准玩家的飞船）。在本章中，我们将遵循类似趋势，扩展到`Scene`文件夹中的其他游戏场景（位于`Assets`文件夹中）。
- en: As part of scene management, all games we play have something called a "Game
    Loop" – if you're not familiar with the term, it basically means our game will
    have alternative routes to take. Each route will load a particular scene. We will
    need to cater for either outcome at each stage of the game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为场景管理的一部分，我们玩的所有游戏都有一种称为“游戏循环”的东西——如果你不熟悉这个术语，它基本上意味着我们的游戏将有多条替代路线。每条路线将加载特定的场景。我们需要在每个游戏阶段为每种结果做好准备。
- en: 'Eventually, all game loops will loop back to somewhere near the beginning.
    The following image shows what our game loop will look like by the end of this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，所有游戏循环都会回到接近开始的地方。以下图像显示了在本章结束时我们的游戏循环将看起来是什么样子：
- en: '![Figure 7.1 – Killer Wave''s Game Loop'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – Killer Wave的游戏循环'
- en: '](img/Figure_7.01_B18381.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B18381.jpg)'
- en: Figure 7.1 – Killer Wave's Game Loop
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – Killer Wave的游戏循环
- en: Referring to the game loop image still, each name in its rectangular box represents
    a scene in Unity that we have in our `Scene` folder inside the **Project** window.
    The flow of each scene goes in one overall direction, starting at the top with
    **BOOTUP**. This is when the game is launched for the first time. The flow will
    fall through each scene until the player beats all three levels or dies. Either
    way, they will eventually reach the **GAMEOVER** scene, which will then loop back
    up to the **TITLE** scene to create a loop.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然参考游戏循环图像，每个矩形框中的每个名称都代表Unity中我们`Scene`文件夹内的一个场景。每个场景的流程都沿着一个整体方向进行，从顶部的**BOOTUP**开始。这是游戏首次启动时。流程将穿过每个场景，直到玩家击败所有三个级别或死亡。无论如何，他们最终都会到达**GAMEOVER**场景，然后循环回到**TITLE**场景以创建循环。
- en: By the end of this chapter, we will be in the position to run our game from
    the `bootUp` scene, where it will automatically move onto the `title` scene. From
    there, the player will press the fire button or tap the screen to then load up
    the `shop` scene, which is where purchases can be made.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将能够从`bootUp`场景运行我们的游戏，它将自动移动到`title`场景。从那里，玩家将按下射击按钮或轻触屏幕，然后加载`shop`场景，这是可以进行购买的地方。
- en: Once the player presses the `shop` scene, the first level (`level1`) will start.
    If the player dies, the level will restart, whereas if the player completes the
    level, they will move onto the next level.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家按下`shop`场景，第一级（`level1`）将开始。如果玩家死亡，该级别将重新启动，而如果玩家完成该级别，他们将继续到下一级。
- en: The final outcome from all of this will be that if the player dies three times,
    they will be taken back to the `title` scene, whereas if the player completes
    the `level3` scene, then the game will be over, and the player will be taken to
    the `gameOver` scene.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果将是，如果玩家死亡三次，他们将被带回到`title`场景，而如果玩家完成`level3`场景，则游戏结束，玩家将被带到`gameOver`场景。
- en: Finally, we will cover a few mock test questions related to what we have covered
    so far.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将涵盖一些与我们迄今为止所涵盖内容相关的模拟测试问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Transitioning our player ship
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换我们的玩家飞船
- en: Expanding our `ScenesManager` script
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展我们的`ScenesManager`脚本
- en: Preparing to loop our game
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备循环我们的游戏
- en: Mock test
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟测试
- en: Core exam skills covered in this chapter
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技能
- en: 'The following are the core exam skills that will be covered in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将涵盖的核心考试技能：
- en: '*Programming core interactions:*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程核心交互：*'
- en: Implement and configure game object behavior and physics
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象行为和物理
- en: Implement and configure camera views and movement
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置摄像机视图和移动
- en: '*Working in the art pipeline:*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*在艺术管道中工作：*'
- en: Understand materials, textures, and shaders, and write scripts that interact
    with Unity's rendering API
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解材质、纹理和着色器，并编写与Unity渲染API交互的脚本
- en: Understand 2D and 3D animation, and write scripts that interact with Unity's
    animation API
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解2D和3D动画，并编写与Unity动画API交互的脚本
- en: '*Programming for scene and environment design:*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景和环境设计的编程：*'
- en: Identify methods for implementing Game Object instantiation, destruction, and
    management
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别实现游戏对象实例化、销毁和管理的方法。
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用于构建模块化、可读性和可重用性脚本的技巧。
- en: Technical requirements
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求。
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_07](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_07).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可以在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_07](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_07)找到。
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载每个章节的项目文件的全部内容，链接为[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)。
- en: All the content for this chapter is held in this chapter's `unitypackage` file,
    including a `Complete` folder that holds all of the work we'll carry out in this
    chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都包含在本章的`unitypackage`文件中，包括一个`Complete`文件夹，其中包含本章我们将执行的所有工作。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/37Rie3B](https://bit.ly/37Rie3B).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码执行情况*：[https://bit.ly/37Rie3B](https://bit.ly/37Rie3B)。
- en: Transitioning our player ship
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换我们的玩家飞船。
- en: Currently, our levels can only be completed when the player dies, causing the
    level to restart, or when the player loses all three lives. Only then are we taken
    to the game over screen. We now need to start thinking of how a player starts
    and ends a level. Currently, the player just appears at the start of a level.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的关卡只能在玩家死亡、关卡重新开始或玩家失去所有三个生命时完成。只有在这种情况下，我们才会被带到游戏结束屏幕。我们现在需要开始思考玩家如何开始和结束关卡。目前，玩家只是在关卡开始时出现。
- en: In this section, we are going to write some code that animates our player into
    the scene and, when the level completes, we will have the player ship exit the
    camera view.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一些代码，将我们的玩家动画化到场景中，并在关卡完成时，我们将让玩家飞船退出摄像机视图。
- en: So, let's make a script the same way we did all the other scripts ([*Chapter
    2*](B18381_02_Epub.xhtml#_idTextAnchor048)*, Adding and Manipulating Objects*,
    if you need a reference). Name the script `PlayerTransition` and make sure we
    have the file in our `Script` folder in the Unity Editor **Project** window.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们像创建所有其他脚本一样创建一个脚本（[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)*，添加和管理对象*，如果您需要参考）。将脚本命名为`PlayerTransition`并确保我们在Unity编辑器的**项目**窗口中的`Script`文件夹中有该文件。
- en: 'We now need to attach the `PlayerTransition` script to our `player_ship` prefab:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`PlayerTransition`脚本附加到我们的`player_ship`预制体上：
- en: Load up the `testLevel` scene from `Assets/Scene` in the **Project** window.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口中加载`testLevel`场景到`Assets/Scene`。
- en: Then, navigate to the `Assets/Prefab/Player` folder, and select the `player_ship`
    prefab.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到`Assets/Prefab/Player`文件夹，并选择`player_ship`预制体。
- en: Finally, drag and drop the `PlayerTransition` script into an empty area of the
    `player_ship` `PlayerTransition` component in the `PlayerTransition` component
    will start animating `player_ship` in the `shop` scene.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`PlayerTransition`脚本拖放到`player_ship`的`PlayerTransition`组件的空区域，`player_ship`的`PlayerTransition`组件将开始动画化`shop`场景中的`player_ship`。
- en: 'Now that our script has been created and attached, we can go into it and start
    setting up the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了脚本并将其附加，我们可以进入它并开始设置以下代码：
- en: Adding variables to our `PlayerTransition` script
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的`PlayerTransition`脚本添加变量。
- en: Adding methods/functions to our `PlayerTransition` script
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的`PlayerTransition`脚本添加方法/函数。
- en: Adding `if` statement checks
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`if`语句检查。
- en: Adding content to `PlayerMovement IEnumerator`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`PlayerMovement IEnumerator`添加内容。
- en: Moving the player ship out of the screen
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家飞船移出屏幕。
- en: Let's take a look.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看。
- en: Adding variables to our PlayerTransition script
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的`PlayerTransition`脚本添加变量。
- en: In this section, we are going to make a start by setting up our `PlayerTransition`
    script. We'll do this by adding global variables so that these can be used to
    position the player ship.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从设置我们的`PlayerTransition`脚本开始。我们将通过添加全局变量来实现这一点，以便可以使用这些变量来定位玩家飞船。
- en: 'To start adding our global variables, follow these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始添加我们的全局变量，请按照以下步骤操作：
- en: Open our newly created `PlayerTransition` script.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们新创建的 `PlayerTransition` 脚本。
- en: 'At the top of the script, make sure we have the following libraries added:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部，确保我们添加了以下库：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, our script should be automatically named along with its default
    inherit `MonoBehaviour` as it's a requirement regarding the Unity Editor and other
    functionalities. The `System.Collections` library will be used for our `StartCoroutine`.
    Without this library, we can't create coroutines; we will explain more about this
    when we come to coding it in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的脚本应该自动命名，并与其默认继承的 `MonoBehaviour` 一起使用，因为这是关于 Unity 编辑器和其他功能的要求。我们将使用
    `System.Collections` 库来执行我们的 `StartCoroutine`。没有这个库，我们无法创建协程；我们将在编写代码时进一步解释这一点。
- en: 'Check/enter the following code for our `PlayerTransition` script, which holds
    the script''s default name and `MonoBeaviour` inheritance for added functionality:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查/输入以下代码用于我们的 `PlayerTransition` 脚本，它保留了脚本的默认名称和 `MonoBeaviour` 继承以添加功能：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within the `PlayerTransition` class, enter the following global `Vector3` variables:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerTransition` 类中，输入以下全局 `Vector3` 变量：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `startPos` and `readyPos` variables are used to measure the distance from
    where our player ship is and where we want it to travel to.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`startPos` 和 `readyPos` 变量用于测量我们的玩家飞船当前位置与我们希望其前往的位置之间的距离。'
- en: Tip
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: At this point, be sure that the `_Player` game object's **Transform Position**
    property values are set to zero on its X, Y, and Z axes in the **Inspector** window.
    Otherwise, the player ship may animate into the wrong position when entering the
    level.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，请确保 `_Player` 游戏对象的 **Transform Position** 属性值在 **Inspector** 窗口中设置为 X、Y
    和 Z 轴上的零。否则，玩家飞船在进入关卡时可能会动画到错误的位置。
- en: The `transitionToEnd` variables will be used as the coordinates where we want
    our player game object ship to travel to at the start of the level, as well as
    when the player's ship is about to leave a level. `transitionToCompleteGame` is
    only used when the player completes the third and final level and is used to alter
    the player's ending animation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`transitionToEnd` 变量将被用作我们希望在关卡开始时我们的玩家游戏对象飞船要前往的坐标，以及当玩家的飞船即将离开关卡时。`transitionToCompleteGame`
    仅在玩家完成第三级和最终级时使用，用于改变玩家的结束动画。'
- en: 'Continue entering the following `float` variables in our `PlayerTransition`
    script:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在我们的 `PlayerTransition` 脚本中输入以下 `float` 变量：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`distCovered` will hold time data that will be used later to measure between
    two `Vector3` points (we will talk about this in more detail when we make `PlayerMovement`
    `IEnumerator`).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`distCovered` 将持有时间数据，这些数据将被用于稍后测量两个 `Vector3` 点（我们将在制作 `PlayerMovement` 为
    `IEnumerator` 时详细讨论这一点）。'
- en: '`journeyLength` will hold the distance between the two `Vector3` points mentioned
    previously (`startPos` and `readyPos`).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`journeyLength` 将持有之前提到的两个 `Vector3` 点（`startPos` 和 `readyPos`）之间的距离。'
- en: 'The final set of variables are the bools to be added to our `PlayerTransition`
    script:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的一组变量是要添加到我们的 `PlayerTransition` 脚本中的 `bool`。
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`levelStarted` is the only `bool` set to `true` as it confirms that the level
    has started and will only be set to `false` after the transition of the player''s
    animation has finished. `speedOff` will be set to `true` when we want the player''s
    ship to leave the level.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`levelStarted` 是唯一被设置为 `true` 的 `bool`，因为它确认了关卡已经开始，并且只有在玩家动画过渡完成后才会被设置为 `false`。`speedOff`
    将在我们要让玩家的飞船离开关卡时设置为 `true`。'
- en: '`levelEnds` is set to `true` when the level has come to the end and the player
    ship will then move to its exit position. The last `bool` is for when the whole
    game has been completed. This is used to change the ending animation. The two
    properties are used for accessing the `levelEnds` and `gameCompleted` variables
    from outside of the script.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当关卡结束时，`levelEnds` 被设置为 `true`，此时玩家飞船将移动到其出口位置。最后一个 `bool` 用于整个游戏完成时。这用于改变结束动画。这两个属性用于从脚本外部访问
    `levelEnds` 和 `gameCompleted` 变量。
- en: That's our variables added to our script. Now, let's continue to the `PlayerTransition`
    methods and functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是添加到我们脚本中的变量。现在，让我们继续到 `PlayerTransition` 的方法和函数。
- en: Adding methods/functions to our PlayerTransition script
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的 `PlayerTransition` 脚本添加方法/函数
- en: 'As we continue through our `PlayerTransition` script, we will add Unity''s
    `Start` function and create our own `Distance` method to position the player''s
    ship in the correct location:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续 `PlayerTransition` 脚本的过程中，我们将添加 Unity 的 `Start` 函数并创建我们自己的 `Distance`
    方法来定位玩家的飞船到正确的位置：
- en: 'Starting with the `Start` function, continue entering the following code for
    our `PlayerTransition` script:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Start`函数开始，继续为我们的`PlayerTransition`脚本输入以下代码：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Start` function gets called as soon as this script is enabled. In this
    function, we will reset the position of the player's ship to its parent game object,
    which is the `PlayerSpawner` game object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`函数在脚本启用后立即被调用。在这个函数中，我们将玩家飞船的位置重置为其父游戏对象，即`PlayerSpawner`游戏对象。'
- en: We will then assign the player ship's beginning world space position to one
    of the vectors we created earlier in this section (`startPos`). We will use this
    in the `Distance` method, which we will talk about next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把玩家飞船的初始世界空间位置分配给我们在此节中较早创建的一个向量（`startPos`）。我们将在`Distance`方法中使用这个向量，我们将在下一节中讨论它。
- en: 'Enter the `Distance` method and its content in the `PlayerTransition` class:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerTransition`类中输入`Distance`方法及其内容：
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Vector3.Distance` is a ready-made Unity function that will measure the distance
    between two vector points and gives the answer in the form of a `float` that we
    will be storing in `journeyLength`. The reason for this is that we will want to
    know the length between where our player ship is and where it needs to go (which
    we''ll cover later in this chapter).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector3.Distance`是Unity的一个现成函数，它将测量两个向量点之间的距离，并以`float`形式给出答案，我们将将其存储在`journeyLength`中。这样做的原因是我们将想知道玩家飞船当前位置和它需要到达的位置之间的距离（我们将在本章稍后讨论）。'
- en: In the next section, we will move into Unity's `Update` function, where we will
    check for when the level has ended so that we can exit (move) our player ship
    out of the screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进入Unity的`Update`函数，检查关卡何时结束，以便我们可以将玩家飞船移出屏幕。
- en: Adding if statement checks
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加if语句检查
- en: In this section, we are going to make use of Unity's frame update function,
    `Update`, so that we can run checks to see what state our game is at within the
    level.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用Unity的帧更新函数`Update`，以便我们可以运行检查以查看游戏在关卡中的状态。
- en: 'Within our `Update` function, we will have three `if` statements. `levelStarted`
    is from one of the `bool` variables that we introduced earlier on in this section,
    which is already set to `true`. So, this `if` statement is going to be called
    instantly. Let''s take a look:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Update`函数中，我们将有三个`if`语句。`levelStarted`是从我们在此节较早介绍的一个布尔变量中来的，它已经设置为`true`。因此，这个`if`语句将立即被调用。让我们看看：
- en: 'Let''s start by entering the first `if` statement in the `PlayerTransition`
    script''s `Update` function:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`PlayerTransition`脚本中的`Update`函数的第一个`if`语句开始：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Within the first `if` statement is a method called `PlayerMovement`, which also
    takes two parameters. With regards to what this method does, we will review its
    content after we have covered the entirety of the `Update` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`if`语句中有一个名为`PlayerMovement`的方法，它也接受两个参数。关于这个方法的作用，我们将在覆盖完整个`Update`函数后对其进行回顾。
- en: Now, let's continue with the second `if` statement in the `Update` function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续处理`Update`函数中的第二个`if`语句。
- en: This `if` statement checks to see if the `levelEnds` variable is `true`, which,
    as you may recall, we set to `false` by default. This `bool` is accessed outside
    of the `PlayerTransition` class, which we will cover later, but for now, all we
    need to know is that it becomes `true` at the end of a level.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if`语句检查`levelEnds`变量是否为`true`，如您所记得，我们将其默认设置为`false`。这个布尔值在`PlayerTransition`类外部访问，我们将在稍后讨论，但就目前而言，我们只需要知道它在关卡结束时变为`true`。
- en: Inside the `if` statement, there are several lines that prepare our player's
    ship to begin the end of the level, starting with disabling the `Player` script
    by setting its `enabled` bool setting to `false`. This will knock out the player's
    controls so that we can animate the player ship into position for the end of the
    level.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句内部，有几行代码为玩家飞船准备开始结束关卡，首先是通过将`Player`脚本的`enabled`布尔设置设置为`false`来禁用`Player`脚本。这将使玩家失去控制，以便我们可以将玩家飞船动画化到关卡结束的位置。
- en: Next, we disable the player ship's `SphereCollider` so that if an enemy or one
    of its bullets comes into contact with the player's ship, it won't destroy the
    ship while it's preparing to end the level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们禁用玩家飞船的`SphereCollider`，这样如果敌人或其子弹与玩家飞船接触，在准备结束关卡时，它不会摧毁飞船。
- en: 'Enter the second following `if` statement inside the `PlayerTransition` `Update`
    function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerTransition` `Update`函数内部输入第二个`if`语句：
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, we measure the distance between where the player's ship was at the start
    of the level and where it needs to go with the `Distance` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Distance`方法来测量玩家飞船在关卡开始时的位置和它需要到达的位置之间的距离。
- en: Finally, within the `if` statement, we have the same method that we mentioned
    earlier, with the only difference being that the argument value is set to `200`.
    These values will be explained after the fourth `if` statement for this `Update`
    function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`if`语句中，我们有我们之前提到的方法，唯一的区别是参数值设置为`200`。这些值将在第四个`if`语句之后的这个`Update`函数中解释。
- en: 'While we''re still within the `Update` function, we can enter the `if` statement
    that covers when the player completes the third and final level:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仍然在`Update`函数内部时，我们可以进入覆盖玩家完成第三和最后一个级别的`if`语句：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the `gameCompleted` `bool` is `true`, we fall into the `if` statements condition.
    Inside, we turn off the `Player` script to disable the player's controls. The
    second line disables the player's collider to avoid any collisions with any enemy-related
    game objects, while the third line makes the player ship translate from its current
    position to the value of `transitionToCompleteGame`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`gameCompleted` `bool`为`true`，我们将进入`if`语句的条件。在内部，我们关闭`Player`脚本以禁用玩家的控制。第二行禁用玩家的碰撞器，以避免与任何与敌人相关的游戏对象发生碰撞，而第三行使玩家飞船从当前位置移动到`transitionToCompleteGame`的值。
- en: 'Enter the fourth `if` statement in our `PlayerTransition` `Update` function:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入我们的`PlayerTransition` `Update`函数中的第四个`if`语句：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the fourth `if` statement, we run a check to see if the `speedOff` `bool`
    holds the value of `true`. If it does, we run Unity's own `Invoke` function, which
    delays the execution of the `SpeedOff` method with a 1-second delay.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个`if`语句中，我们运行一个检查以查看`speedOff` `bool`是否持有`true`的值。如果是这样，我们运行Unity自己的`Invoke`函数，该函数将`SpeedOff`方法的执行延迟1秒。
- en: Further Information
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'More about `Invoke` can be found on the Unity Scripting reference site: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`Invoke`的信息可以在Unity脚本参考网站上找到：[https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html)。
- en: 'In the next section, we will write some code so that the player is moved from
    where they are to where they need to be. The two cases where this will need to
    be achieved are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编写一些代码，以便将玩家从他们所在的位置移动到他们需要到达的位置。需要实现这种情况的两个案例如下：
- en: When the player starts the game, we animate them into the scene.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家开始游戏时，我们将动画化他们进入场景。
- en: When the player has completed the level, they need to move into a position to
    leave the level.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家完成关卡后，他们需要移动到一个位置以离开关卡。
- en: We will be covering two new Unity functions (`Mathf.Round` and `Vector3.Lerp`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍两个新的Unity函数（`Mathf.Round`和`Vector3.Lerp`）。
- en: Adding content to the PlayerMovement method
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向`PlayerMovement`方法添加内容
- en: The `PlayerMovement` method holds the responsibility of animating our player
    ship in the near center of the screen so that it can begin and also exit the level.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerMovement`方法负责在屏幕近中心处动画化我们的玩家飞船，以便它可以从一个位置开始并退出关卡。'
- en: 'Let''s go into more detail to fully understand this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这一点：
- en: 'Enter the following code for our `PlayerMovement` method, along with its two
    parameters:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`PlayerMovement`方法及其两个参数输入以下代码：
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As mentioned previously, our `PlayerMovement` takes two parameters: a `Vector3`
    with the reference name `point` and a `float` with the reference name `transitionSpeed`.
    As you can imagine, `transitionSpeed` is the speed of the player ship moving from
    one point to another.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的`PlayerMovement`方法接受两个参数：一个带有参考名称`point`的`Vector3`和一个带有参考名称`transitionSpeed`的`float`。正如你可以想象的那样，`transitionSpeed`是玩家飞船从一个点到另一个点移动的速度。
- en: If we trace back to what the value of `point` is, it's coming from a variable
    that we've already initialized, `transitionToStart`, with a `Vector3` at the beginning
    of this script with a value of `(-100,0,0)`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回溯到`point`的值，它来自一个我们已经在脚本开头初始化的变量，即`transitionToStart`，其值为`(-100,0,0)`的`Vector3`。
- en: 'So, effectively, `transitionToStart` and `point` are the same – they''re just
    different in terms of their names, for the sake of keeping their references separate.
    Anyway, coming back to `point`, this value is for our player''s ship position.
    The following screenshot shows our player ship with `-100,0,0`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上 `transitionToStart` 和 `point` 是相同的——它们只是名称不同，为了保持它们的引用独立。无论如何，回到 `point`，这个值是我们玩家飞船的位置。以下截图显示了我们的玩家飞船，位置为
    `-100,0,0`：
- en: '![Figure 7.2 – Player Ship''s position'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 玩家飞船的位置'
- en: '](img/Figure_7.02_B18381.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B18381.jpg)'
- en: Figure 7.2 – Player Ship's position
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 玩家飞船的位置
- en: So, when a level begins, our player ship will be on the far left, outside of
    the screen, and animate into the position we have marked in the previous screenshot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当关卡开始时，我们的玩家飞船将位于屏幕的左侧边缘，并且会动画过渡到之前截图中所标记的位置。
- en: Carrying on with the `PlayerMovement` method, we begin with an `if` statement
    that checks when a series of conditions are met.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 `PlayerMovement` 方法，我们从一个 `if` 语句开始，该语句检查一系列条件是否满足。
- en: 'Enter the following `if` statement, along with its four conditions:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下 `if` 语句及其四个条件：
- en: '[PRE12]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous code, we''ve run a check on four occasions to see if the player
    is in the correct position before executing the rest of the code. Each line of
    code checks the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们已经四次检查了玩家是否处于正确的位置，然后再执行其余的代码。每一行代码都会检查以下内容：
- en: If the player ship's X position is more than or equal to the value that is stored
    in `readyPos` variable's X position, minus 5.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家飞船的 X 位置大于或等于存储在 `readyPos` 变量 X 位置的值，减去 5。
- en: If the player ship's X position is less than or equal to the value that is stored
    in `readyPos` variable's X position, plus 5.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家飞船的 X 位置小于或等于存储在 `readyPos` 变量 X 位置的值，加上 5。
- en: If the player ship's Y position is more than or equal to the value that is stored
    in `readyPos` variable's Y position, minus 5.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家飞船的 Y 位置大于或等于存储在 `readyPos` 变量 Y 位置的值，减去 5。
- en: If the player ship's Y position is less than or equal to the value that is stored
    in `readyPos` variable's Y position, plus 5.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家飞船的 Y 位置小于或等于存储在 `readyPos` 变量 Y 位置的值，加上 5。
- en: 'Still within our `PlayerMovement` method and within the previous `if` statement,
    enter the following two `if` statements:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `PlayerMovement` 方法中，并且在之前的 `if` 语句内，输入以下两个 `if` 语句：
- en: '[PRE13]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the previous code block, we have two `if` statements (`levelEnds` and `levelStarted`)
    that check that each of the `bool` conditions are `true`. Let''s go through both
    of their content:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，我们有两个 `if` 语句（`levelEnds` 和 `levelStarted`），它们检查每个 `bool` 条件是否为 `true`。让我们来看看它们的内容：
- en: '`levelEnds`: `if` `levelEnds` becomes `true`, we apply `false` to the `levelEnds`
    `bool` and apply `true` to the `speedOff` `bool`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelEnds`：如果 `levelEnds` 变为 `true`，我们将 `levelEnds` 的 `bool` 设置为 `false`，并将
    `speedOff` 的 `bool` 设置为 `true`。'
- en: '`levelStarted`: `if` `levelStarted` is given the value `true`, we apply false
    to the `levelStarted` `bool`, set the `distCovered` `float` to `0`, and we set
    the `Player` script to `true`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelStarted`：如果 `levelStarted` 被赋予 `true` 的值，我们将 `levelStarted` 的 `bool`
    设置为 `false`，将 `distCovered` 的 `float` 设置为 `0`，并将 `Player` 脚本设置为 `true`。'
- en: 'Lastly, in our `PlayerMovement` method, enter the following `else` condition
    that sits outside the main `if` statement:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的 `PlayerMovement` 方法中，输入以下位于主 `if` 语句之外的 `else` 条件：
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Referring to the `else` condition code block, we add time and multiply it by
    `transitionSpeed`, which, as you may recall, is one of the two arguments this
    method takes. Make sure this else statement is relating to the Mathf.Round if
    statement and not the two bool checking if statements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 查看之前的 `else` 条件代码块，我们添加时间并将其乘以 `transitionSpeed`，如您所记得的，这是此方法接受的两个参数之一。确保此 `else`
    语句与 `Mathf.Round` 语句相关，而不是检查两个 `bool` 的语句。
- en: We then divide the `distCovered` variable by the `journeyLength` variable, which,
    as you may recall, is a measurement between two points. We store the division
    in a `float` variable called `fractionOfJourney`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `distCovered` 变量除以 `journeyLength` 变量，如您所记得的，这是两点之间的测量值。我们将除法的结果存储在一个名为
    `fractionOfJourney` 的 `float` 变量中。
- en: 'The last thing we do in this `else` condition is use one of Unity''s pre-made
    functions called `Lerp`, which linearly interpolates our player''s ship between
    two points. `Lerp` takes three arguments: point A, point B, and the time scale
    it''s going to move between these two points. `transform.position` is our player''s
    ship, the second is the `Vector3` point, which is the other variable we brought
    into `IEnumerator`, and the third is the active `float` `fractionOfJourney`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此 `else` 条件中我们最后做的事情是使用 Unity 的预制函数之一 `Lerp`，它将我们的玩家飞船在两点之间进行线性插值。`Lerp` 接受三个参数：点
    A、点 B 和它将在两点之间移动的时间比例。`transform.position` 是我们的玩家飞船，第二个是 `Vector3` 点，这是我们带到 `IEnumerator`
    中的另一个变量，第三个是活动的 `float` `fractionOfJourney`。
- en: Information
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: It's also possible to `Lerp` colors over time with `Material.Lerp`.For more
    information about changing one color into another, check out [https://docs.unity3d.com/ScriptReference/Material.Lerp.html](https://docs.unity3d.com/ScriptReference/Material.Lerp.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 `Material.Lerp` 在一段时间内渐变颜色。有关将一种颜色渐变为另一种颜色的更多信息，请参阅[https://docs.unity3d.com/ScriptReference/Material.Lerp.html](https://docs.unity3d.com/ScriptReference/Material.Lerp.html)。
- en: We now need to add a single line of code in the `PlayerSpawner` script to turn
    the `PlayerTransition` script on after the player leaves the shop scene. As mentioned
    earlier in the chapter, if the `PlayerTransition` was left on in the shop scene,
    the `player_ship` would animate across the screen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要在 `PlayerSpawner` 脚本中添加一行代码，在玩家离开商店场景后启用 `PlayerTransition` 脚本。如本章前面所述，如果
    `PlayerTransition` 在商店场景中保持开启状态，`player_ship` 将在屏幕上动画化。
- en: 'So, to turn on the `PlayerTransition` script at the start of the `level1` scene,
    we need to do the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在 `level1` 场景的开始时开启 `PlayerTransition` 脚本，我们需要做以下操作：
- en: In the `Assets/Script` and open the `PlayerSpawner` script.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Script` 中打开 `PlayerSpawner` 脚本。
- en: 'Scroll down to the following line of code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到以下代码行：
- en: '[PRE15]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Enter the following line of code just after it:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后输入以下代码行：
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This line of code will make our player ship animate into the `level1` scene.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将使我们的玩家飞船动画化进入 `level1` 场景。
- en: The last change we need to make in the `PlayerSpawner` script is to remove the
    ability to enable the `Player` script in the `PlayerSpawner Start` function, we
    will enable this in the `ScenesManager` script.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `PlayerSpawner` 脚本中做的最后一个更改是移除在 `PlayerSpawner Start` 函数中启用 `Player` 脚本的能力，我们将在
    `ScenesManager` 脚本中启用它。
- en: 'In the `PlayerSpawner` script, remove the following line in the `Start` function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerSpawner` 脚本中，从 `Start` 函数中删除以下行：
- en: '[PRE17]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save the `PlayerSpawner` script.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `PlayerSpawner` 脚本。
- en: Now, let's move onto the last bit of code, where we'll be moving our player
    ship out of the screen at the end of the level.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到最后一段代码，我们将在这里移动玩家飞船，使其在关卡结束时离开屏幕。
- en: Moving the player ship out of the screen
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将玩家飞船移出屏幕
- en: 'The last method we need to cover in the `PlayerTransition` script is the `SpeedOff`
    method. This method simply makes our player''s ship jet off, out of the screen,
    when the level is completed. Let''s take a look:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `PlayerTransition` 脚本中覆盖的最后一个方法是 `SpeedOff` 方法。此方法简单地将我们的玩家飞船喷射出屏幕，当关卡完成时。让我们看看：
- en: 'Enter the following code in our `PlayerTransition` script:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `PlayerTransition` 脚本中输入以下代码：
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code block uses Unity's pre-made `Translate` function, which takes a `Vector3.left`
    multiplied by time, with `800` being used to make the player ship move a little
    faster.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块使用 Unity 的预制 `Translate` 函数，它接受 `Vector3.left` 乘以时间，其中 `800` 用于使玩家飞船移动得更快。
- en: Save the script.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'That is the end of the `PlayerTransition` script. Now, our game has an introduction
    and an ending for our player ship. Originally, our player would just be present
    at the start of the level and when it was classed as being completed, the next
    level would load. We also technically covered three new functions, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `PlayerTransition` 脚本的结束。现在，我们的游戏为玩家飞船添加了开场和结尾。最初，我们的玩家将在关卡开始时出现，当它被标记为完成时，将加载下一关卡。我们还技术性地覆盖了三个新函数，如下所示：
- en: '`Vector3.Distance`, which measures between two `Vector3` points'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.Distance`，用于测量两个 `Vector3` 点之间的距离'
- en: '`Vector3.Lerp`, which moves the player ship, smoothing between two `Vector3`
    points'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.Lerp`，用于移动玩家飞船，在两个 `Vector3` 点之间平滑移动'
- en: '`MathF.Round`, which rounds off a number'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MathF.Round`，用于四舍五入一个数字'
- en: We combined these new skills to make our player ship move into position to start
    the level and, when completed, no matter where the player was on the screen, we
    moved them into position. Finally, our player zooms off the screen.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些新技能结合起来，使我们的玩家飞船进入位置以开始关卡，完成后，无论玩家在屏幕上的位置如何，我们都将他们移动到正确的位置。最后，我们的玩家从屏幕上飞走。
- en: In the next section, we are going to revisit the `ScenesManager` script and
    apply some code so that there's a time limit, counting down to when the level
    is over.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重新访问`ScenesManager`脚本并应用一些代码，以便有一个时间限制，倒计时到关卡结束。
- en: Expanding our ScenesManager script
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展`ScenesManager`脚本
- en: In this section, we are going to make our `ScenesManager` script recognize levels
    2 and 3 from our `scenes` folder (`Assets/Scene`). We will then add these levels
    to the game loop. Also, we will be adding a game timer for each level. When the
    timer reaches its limit, we can then trigger the player leaving the level with
    an animation that will play out. Lastly, we will add a few common methods to move
    the game onto the next level.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使我们的`ScenesManager`脚本识别`scenes`文件夹（`Assets/Scene`）中的2级和3级关卡。然后我们将这些关卡添加到游戏循环中。此外，我们还将为每个关卡添加一个游戏计时器。当计时器达到其限制时，我们可以通过播放一个动画来触发玩家离开关卡。最后，我们将添加一些常见的方法来将游戏推进到下一级。
- en: 'Let''s start by opening the `ScenesManager` script (`Assets/Script/Scenesmanager.cs`)
    and adding some variables to assist with what we were talking about. Follow these
    steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`ScenesManager`脚本（`Assets/Script/Scenesmanager.cs`）并添加一些变量开始，以帮助我们讨论的内容。按照以下步骤操作：
- en: 'At the top of the `ScenesManager` script, add the following variables:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScenesManager`脚本顶部添加以下变量：
- en: '[PRE19]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `gameTimer` variable timer will be used as our current counter to time how
    long the level has left until it is over. The following variable is an array that
    holds the time until each level ends. So, we have three levels in total, but the
    question is, how long do we want each level to last? We need to enter a value
    that represents the seconds until the level ends, so I've chosen `30` seconds
    for levels 1 and 2\. Level 3, however, will last 45 seconds. This is because we
    will be building a special level in , *NavMesh, Timeline, and a Mock Test*. We
    will go into more detail about this when we reach that chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameTimer`变量计时器将用作我们的当前计数器，以计时关卡剩余的时间直到结束。以下变量是一个数组，它保存了每个关卡结束前的时间。因此，我们总共有三个关卡，但问题是，我们希望每个关卡持续多长时间？我们需要输入一个表示关卡结束前秒数的值，所以我选择了1级和2级的`30`秒。然而，3级关卡将持续`45`秒。这是因为我们将在这个章节中构建一个特殊的关卡，*NavMesh,
    Timeline, and a Mock Test*。我们将在这个章节中详细介绍这一点。'
- en: As you can imagine, `currentSceneNumber` will hold the number that denotes which
    scene our player is currently on. Lastly, we have the `gameEnding` bool, which
    will be used to trigger the end of the level animation for the player's ship.
    We will cover these variables in more detail later in this section, let's start
    with `currentSceneNumber`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，`currentSceneNumber`将保存表示玩家当前所在场景的数字。最后，我们有`gameEnding`布尔值，它将用于触发玩家飞船关卡动画的结束。我们将在本节稍后更详细地介绍这些变量，让我们从`currentSceneNumber`开始。
- en: Following on from the global variables we just set, let's make sure that the
    `ScenesManager` script is always aware of what scene our player is on during the
    game. This will help our code know which scene the player is on and what scene
    they will be going to next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚设置的全球变量之后，让我们确保`ScenesManager`脚本在整个游戏过程中始终知道玩家所在的是哪个场景。这将帮助我们的代码知道玩家当前所在场景以及他们将要进入的场景。
- en: 'Add the `Update` function, which will be called on every frame to check which
    scene we are at. Do this by entering the following code in the `ScenesManager`
    script:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Update`函数，它将在每一帧被调用以检查我们处于哪个场景。请在`ScenesManager`脚本中输入以下代码：
- en: '[PRE20]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inside the `Update` function, we use an `if` condition to check if the `currentSceneNumber`
    variable is not equal to the `buildIndex` we are grabbing from the active scene
    we are in.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`函数内部，我们使用一个`if`条件来检查`currentSceneNumber`变量是否不等于我们从活动场景中获取的`buildIndex`。
- en: If it is not equal, we update `currentSceneNumber` with the current scene's
    `buildIndex`, followed by the `GetScene` method. The `GetScene` method is a small
    method that is worth covering now instead of later as it relates to everything
    we've just said.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不相等，我们将使用当前场景的`buildIndex`更新`currentSceneNumber`，然后调用`GetScene`方法。`GetScene`方法是一个小的方法，现在就介绍它比以后介绍更好，因为它与我们刚刚讨论的所有内容都相关。
- en: Inside the `GetScene` method is a single line of code that updates the scene's
    variable. This is an instance from the `Scenes` `enum` that holds the names for
    each scene in our game. Also, the code in the `GetScene` method is casting `currentSceneNumber`
    to an `enum`, which is why the `Scenes` type is in brackets. More about casting
    can be found at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GetScene` 方法中，有一行代码用于更新场景的变量。这是一个来自 `Scenes` 枚举的实例，它包含我们游戏中每个场景的名称。此外，`GetScene`
    方法中的代码将 `currentSceneNumber` 强制转换为枚举，这就是为什么 `Scenes` 类型放在括号中的原因。更多关于强制转换的信息可以在
    [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions)
    找到。
- en: 'Enter the following code for our `ScenesManager` script:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的 `ScenesManager` 脚本输入以下代码：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can put the `GetScene` method anywhere in the `ScenesManager` class, as long
    as it's not within another method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `ScenesManager` 类中的任何地方放置 `GetScene` 方法，只要它不在另一个方法内部。
- en: Coming back to the `Update` function, after calling the `GetScene` method, we
    close the `if` conditions brackets. The last thing we do before closing the `Update`
    function is run the `GameTimer` method, which will keep track of our game's time
    and set up some basic methods that will start, reset, and end our game levels.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `Update` 函数，在调用 `GetScene` 方法之后，我们关闭 `if` 条件的括号。在关闭 `Update` 函数之前，我们最后要做的事情是运行
    `GameTimer` 方法，这个方法将跟踪我们游戏的时间，并设置一些基本方法，这些方法将开始、重置和结束我们的游戏关卡。
- en: 'In the following sections, we will cover the following topics:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将涵盖以下主题：
- en: Adding a timer to each game level. When the timer is up, that notifies the player
    has completed the level.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个游戏关卡添加计时器。当计时器结束时，这会通知玩家已经完成了关卡。
- en: Make it so that when a level is completed, the `ScenesManager` script knows
    what to do next; that is, load a level, which level, and so on.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 `ScenesManager` 脚本知道关卡完成后要做什么；也就是说，加载关卡，哪个关卡，等等。
- en: Let's get started.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Adding a game level timer
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加游戏关卡计时器
- en: In the `ScenesManager` script, we will set up a method that will be responsible
    for acknowledging the level has ended. The `GameTimer` method serves the purpose
    of adding time to a `gameTimer` variable and checking to see if it has reached
    its limit, depending on the `endLevelTimer` it's comparing to. Finally, if the
    game has been triggered to end the player ship's animation, it is set to start
    and the next level is loaded after `4` seconds.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ScenesManager` 脚本中，我们将设置一个负责确认关卡结束的方法。`GameTimer` 方法的作用是为 `gameTimer` 变量添加时间，并检查它是否达到了其限制，这取决于它比较的
    `endLevelTimer`。最后，如果游戏被触发结束玩家飞船的动画，它将被设置为开始，并在 `4` 秒后加载下一关卡。
- en: 'With your `ScenesManager` script still open, add the following method to your
    code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `ScenesManager` 脚本仍然打开的情况下，将以下方法添加到你的代码中：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside the `GameTimer` method, we run a `switch` statement holding the `scenes`
    instance that will contain all of the `enum` names of each level. We run a check
    on three possible cases: `level1`, `level2`, and `level3`. If the `scenes` instance
    is set to either of the three possibilities, we will fall into an `if` condition
    that will then compare whether the `gameTimer` variable is less than what the
    `endLevelTimer` array has been set to.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameTimer` 方法中，我们运行一个包含 `scenes` 实例的 `switch` 语句，该实例将包含每个级别的所有枚举名称。我们对三个可能的案例进行检查：`level1`、`level2`
    和 `level3`。如果 `scenes` 实例设置为这三个可能性中的任何一个，我们就会进入一个 `if` 条件，然后比较 `gameTimer` 变量是否小于
    `endLevelTimer` 数组已设置的限制。
- en: We only need to know what build index number levels 1, 2, and 3 are on. So,
    to avoid the first three scenes, we must subtract by `3`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要知道关卡 1、2 和 3 的构建索引号。因此，为了避免前三个场景，我们必须减去 `3`。
- en: 'The following screenshot shows the **Build Settings** window (**File** | **Build
    Settings**), which contains the scenes and their build numbers in your project
    on the right-hand side:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 **构建设置** 窗口（**文件** | **构建设置**），其中包含你的项目右侧的场景及其构建编号：
- en: '![Figure 7.3 – Build Settings – scene order'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – Build Settings – scene order](img/Figure_7.3_Build_Settings_scene_order.jpg)'
- en: '](img/Figure_7.03_B18381.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.03_B18381.jpg](img/Figure_7.03_B18381.jpg)'
- en: Figure 7.3 – Build Settings – scene order
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.3 – Build Settings – scene order
- en: 'If `gameTimer` is less than `levelTimer`, we will continue to increment `gameTimer`
    with the `Time.deltaTime` fixed function that Unity has pre-made for us. More
    information about `Time.deltaTime` can be found here: [https://docs.unity3d.com/ScriptReference/Time-deltaTime.html](https://docs.unity3d.com/ScriptReference/Time-deltaTime.html).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `gameTimer` 小于 `levelTimer`，我们将使用 Unity 为我们预先制作的 `Time.deltaTime` 固定函数继续增加
    `gameTimer`。有关 `Time.deltaTime` 的更多信息，请参阅此处：[https://docs.unity3d.com/ScriptReference/Time-deltaTime.html](https://docs.unity3d.com/ScriptReference/Time-deltaTime.html)。
- en: If `gameTimer` is equal to or more than `levelTimer`, we will move into the
    `else` condition, which checks the condition of the `if` statement of the `gameEnding`
    `bool` being `false`. If the condition is `false`, we fall into the content of
    the `if` statement, which first sets the `gameEnding` `bool` to `true`. This will
    stop the `if` statement from repeating in the `Update` function's frame cycle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `gameTimer` 等于或大于 `levelTimer`，我们将进入 `else` 条件，该条件检查 `gameEnding` `bool`
    的 `if` 语句条件是否为 `false`。如果条件为 `false`，我们将进入 `if` 语句的内容，首先将 `gameEnding` `bool`
    设置为 `true`。这将阻止 `if` 语句在 `Update` 函数的帧周期中重复。
- en: The last `if` statement checks which level our game is on. If we are not on
    `"level3"`, we set the `LevelEnds` property in the `PlayerTransition` script to
    `true`. Otherwise, we must have completed the game. So, in the `else` condition,
    we set the `GameComplete` property to `true` in the `PlayerTransition` script.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `if` 语句检查游戏处于哪个关卡。如果不是 `"level3"`，我们在 `PlayerTransition` 脚本中将 `LevelEnds`
    属性设置为 `true`。否则，我们必须已经完成了游戏。因此，在 `else` 条件中，我们在 `PlayerTransition` 脚本中将 `GameComplete`
    属性设置为 `true`。
- en: In this section, we created a method in the `ScenesManager` script that made
    our game aware of how long each level will last before classing the level as completed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在 `ScenesManager` 脚本中创建了一个方法，使我们的游戏知道每个关卡将持续多长时间，然后将其视为已完成。
- en: We will now continue with the `ScenesManager` script by adding methods that
    will start, reset, and move our player onto the next level when triggered by the
    `GameTimer` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续在 `ScenesManager` 脚本中添加方法，这些方法将在 `GameTimer` 方法触发时开始、重置并将玩家移动到下一个关卡。
- en: Beginning, resetting, and skipping levels
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始、重置和跳过关卡
- en: '`ScenesManager` will have the responsibility of starting a level, resetting
    it when the player dies, and moving onto the next level when the current one has
    been completed. Thankfully, these require minimal work thanks to Unity''s `SceneManagement`
    library.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScenesManager` 将负责开始一个关卡，当玩家死亡时重置它，并在当前关卡完成后移动到下一个关卡。幸运的是，由于 Unity 的 `SceneManagement`
    库，这些工作需要的工作量很小。'
- en: 'Let''s start by revisiting the `ResetScene` method we have already started,
    but now, we will simplify it even more:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾我们已经开始的 `ResetScene` 方法开始，但现在，我们将进一步简化它：
- en: 'Replace the content from our `ResetScene` method with the following code in
    our `ScenesManager` script:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `ScenesManager` 脚本中，用以下代码替换 `ResetScene` 方法中的内容：
- en: '[PRE23]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inside the `ResetScene` method, we reset the `gameTimer` variable to zero, followed
    by replacing its parameter from the current `SceneManager.LoadScene` `buildIndex`
    to `GameManager.currentScene`, which we coded back in [*Chapter 3*](B18381_03_Epub.xhtml#_idTextAnchor073),
    *Managing Scripts and Taking aMock Test*. This is basically just holding the current
    build index as a `static` integer so that any script can access it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ResetScene` 方法内部，我们将 `gameTimer` 变量重置为零，然后将其参数从当前的 `SceneManager.LoadScene`
    `buildIndex` 替换为 `GameManager.currentScene`，这是我们回到 [*第 3 章*](B18381_03_Epub.xhtml#_idTextAnchor073)，*管理脚本和进行模拟测试*
    时编写的。这基本上就是将当前构建索引作为一个 `static` 整数保持下来，以便任何脚本都可以访问它。
- en: With `ResetScene` updated, we can now move onto the next method, which is very
    similar to what we have just done, but it is separate to `ResetScene` in order
    to support the expansion of our code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `ResetScene` 后，我们现在可以继续进行下一个方法，这个方法与我们刚刚做的非常相似，但它与 `ResetScene` 分开，以便支持我们代码的扩展。
- en: When a player completes a level, the `NextLevel` method runs, which will reset
    the `gameTimer` variable. The `gameTimer` `bool` will be set back to `false` and
    the same `SceneManager.LoadScene` command will be used to increment the `GameManager`
    `currentScene` integer by `1`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家完成一个关卡时，`NextLevel` 方法会运行，这将重置 `gameTimer` 变量。`gameTimer` `bool` 将被设置为 `false`，并使用相同的
    `SceneManager.LoadScene` 命令将 `GameManager` `currentScene` 整数增加 `1`。
- en: 'Enter the following method in the `ScenesManager` script:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ScenesManager` 脚本中输入以下方法：
- en: '[PRE24]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The last method we need to change in our `ScenesManager` script is our `BeginGame`
    method, which will be called when the player is in the `shop` scene and pressing
    the `"START"` button.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ScenesManager`脚本中需要更改的最后一个方法是`BeginGame`方法，当玩家在`shop`场景中并按下`"START"`按钮时将被调用。
- en: 'Enter the following code for our `ScenesManager` script:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`ScenesManager`脚本输入以下代码：
- en: '[PRE25]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `BeginGame` method will take an integer parameter called `gameLevel`. Inside
    this method is the same `SceneManager.LoadScene` we have already used, but this
    time, it will load the `gameLevel` integer we are providing it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeginGame`方法将接受一个名为`gameLevel`的整数参数。在这个方法内部，我们有之前已经使用过的`SceneManager.LoadScene`，但这次，它将加载我们提供的`gameLevel`整数。'
- en: Save the script.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: If you remember, back in the previous chapter we set the `PlayerSpawner` script
    to temporary call the `GameManager.Instance.CameraSetup()`;
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在上一章中，我们将`PlayerSpawner`脚本临时设置为调用`GameManager.Instance.CameraSetup()`；
- en: This call is no longer required and can now be removed. Let's remove it
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用不再需要，现在可以删除。让我们删除它
- en: In the `Assets/Script`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`。
- en: Load the PlayerSpawner script and remove the line from the Start function `GameManager.Instance.CameraSetup();`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`PlayerSpawner`脚本并从`Start`函数中删除`GameManager.Instance.CameraSetup();`这一行。
- en: Save the script.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Because we have changed the `BeginGame` method to now take a parameter, we
    must update our `PlayerShipBuild` script, which has a `StartGame` method that
    runs the `BeginGame` method with, currently, no parameter value. To update the
    `PlayerShipBuild` `StartGame` method, we need to do the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`BeginGame`方法改为现在接受一个参数，我们必须更新我们的`PlayerShipBuild`脚本，该脚本有一个`StartGame`方法，它运行`BeginGame`方法，目前没有参数值。为了更新`PlayerShipBuild`的`StartGame`方法，我们需要做以下几步：
- en: In the Unity Editor, navigate to the `Assets/Script/PlayerShipBuild.cs` folder
    in the **Project** window and open it.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，导航到**项目**窗口中的`Assets/Script/PlayerShipBuild.cs`文件夹并打开它。
- en: 'Scroll down to the `StartGame` method and find this line of code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`StartGame`方法并找到以下代码行：
- en: '[PRE26]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, change the preceding line of code to this:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将前面的代码行改为以下内容：
- en: '[PRE27]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code change will now call the `level1` scene directly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码更改现在将直接调用`level1`场景。
- en: 'With that, we have reached the end of this section. So far, we have covered
    the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就到达了本节的结尾。到目前为止，我们已经涵盖了以下内容：
- en: Our game is now aware of how long a level will take until it is classed as completed.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的游戏现在知道一个级别需要多长时间才能被归类为完成。
- en: The `ScenesManager` script can now call methods that will start, reset, and
    move the player onto the next level.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScenesManager`脚本现在可以调用将启动、重置并将玩家移动到下一级的方法。'
- en: The majority of our code was created with the use of `switch` statements and
    an `enum` to call when the scenes need to be changed. To load the scenes themselves,
    we used Unity's own `SceneManager` class, which is fundamental to loading any
    scene in a Unity Project.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数代码都是使用`switch`语句和`enum`来调用，当场景需要改变时使用。为了加载场景本身，我们使用了Unity自带的`SceneManager`类，这是在Unity项目中加载任何场景的基础。
- en: In the next section, we will prepare the rest of the scenes in our project that
    aren't game levels (the `bootUp` scene, the `title` scene, and the `gameOver`
    scene).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将准备项目中不是游戏级别的其余场景（`bootUp`场景、`title`场景和`gameOver`场景）。
- en: Preparing to loop our game
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备循环我们的游戏
- en: In this section, we are going to move away from the `testLevel` scene and introduce
    three other levels (`level1`, `level2`, and `level3`) to demonstrate the game
    loop.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从`testLevel`场景移开，并介绍三个其他级别（`level1`、`level2`和`level3`），以演示游戏循环。
- en: By the end of this section, our game loop will be complete. We will be able
    to start our game from the `bootUp` scene. From there, we will be able to progress
    through each scene.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们的游戏循环将完成。我们将能够从`bootUp`场景开始我们的游戏。从那里，我们将能够通过每个场景进行进度。
- en: 'Let''s start by removing the placeholder levels in the Unity Editor. Go to
    the `Assets/Scene` location. Follow these steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从Unity编辑器中删除占位符级别开始。转到`Assets/Scene`位置。按照以下步骤操作：
- en: Make sure your `player_ship` is saved (`testLevel` scene. Next, Delete `level1`,
    `level2`, and `level3`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`player_ship`已保存（`testLevel`场景）。然后，删除`level1`、`level2`和`level3`。
- en: Select `testLevel`, hold the *Left Ctrl* *(Command* on the Mac) key on the keyboard,
    and press *D* twice. We should now have three `testLevel` instances.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`testLevel`，在键盘上按住*左Ctrl* *(Mac上的Command*)键，然后按*D*两次。我们现在应该有三个`testLevel`实例。
- en: Rename `testLevel` to `level1`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`testLevel`重命名为`level1`。
- en: Rename `testLevel 1` to `level2`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`testLevel 1`重命名为`level2`。
- en: Rename `testLevel 2` to `level3`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `testLevel 2` 重命名为 `level3`。
- en: We now need to check the **Build Settings** window to check on the order of
    our scenes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要检查 **构建设置** 窗口以查看场景的顺序。
- en: At the top of the Unity Editor, click **File** | **Build Settings.**
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的顶部，点击 **文件** | **构建设置**。
- en: 'Our order should look like the one shown in the following screenshot. If it
    doesn''t, select and move the scenes into the correct position by clicking and
    dragging them in the **Build Settings** window and by selecting and deleting any
    extra scenes in the list:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到的顺序如下面的截图所示。如果不是这样，请通过在 **构建设置** 窗口中点击并拖动场景以及选择并删除列表中的任何额外场景来选择并移动场景到正确的位置：
- en: '![Figure 7.4 – Build Settings – complete scene order'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 构建设置 – 完整场景顺序'
- en: '](img/Figure_7.04_B18381.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04_B18381.jpg)'
- en: Figure 7.4 – Build Settings – complete scene order
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 构建设置 – 完整场景顺序
- en: We have duplicated our first level twice to test that our levels can be completed
    and move forward. Next, we will go back to the first scene in our project list
    and set it up so that it's ready to act like a boot up scene.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将第一个关卡复制了两次，以测试我们的关卡是否可以完成并继续前进。接下来，我们将回到项目列表中的第一个场景，并设置它以便它可以像启动场景一样运行。
- en: Because we have removed our `testLevel` scene, we need to update our `GameManager`
    script with regards to the `LightandCameraSetup` method to keep its `Switch` statement
    in sync with the levels we need to light up, as well as set up our camera.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已删除 `testLevel` 场景，我们需要更新 `GameManager` 脚本中的 `LightandCameraSetup` 方法，以保持其
    `Switch` 语句与我们需要照亮的关卡同步，以及设置我们的相机。
- en: 'To make it so our camera and lights work correctly for each scene, we need
    to do the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的相机和灯光为每个场景正确工作，我们需要执行以下操作：
- en: In the `Assets/Script` folder.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Script` 文件夹中。
- en: Double-click on the `GameManager` script.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 `GameManager` 脚本。
- en: 'Scroll down to the `LightandCameraSetup` method''s content and make it so that
    each case number follows this pattern:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `LightandCameraSetup` 方法的具体内容，并确保每个案例编号遵循以下模式：
- en: '[PRE28]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each case represents the levels the player is going to play.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个案例代表玩家将要玩的游戏关卡。
- en: Save the script.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'In the next few sections, we will be customizing a placeholder look for each
    nonlevel scene (basic but informative). These scenes are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将为每个非关卡场景（基本但信息丰富）自定义一个占位符外观。这些场景如下：
- en: '`bootUp`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootUp`'
- en: '`title`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`'
- en: '`gameOver`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameOver`'
- en: Each of these scenes will also require basic coding so that the player either
    presses a button to continue or a timer will be issued. This timer will count
    down until the next scene is loaded.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景也将需要基本的编码，以便玩家可以按按钮继续，或者发出一个计时器。这个计时器将倒计时，直到加载下一个场景。
- en: Setting up the bootUp scene
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置启动场景
- en: When we run a game, typically, the game doesn't start straight away – there's
    normally a splash screen to show who developed/published the game. Sometimes,
    it's used as a loading screen, but for us, it will be used to get our game started.
    In this section, we are going to take away the typical Unity sky background and
    replace it with a neutral grey color background with a text title that states
    what screen has loaded up.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行游戏时，通常游戏不会立即开始 - 通常有一个启动屏幕来显示谁开发了/发布了游戏。有时，它用作加载屏幕，但对我们来说，它将用于启动我们的游戏。在本节中，我们将移除典型的
    Unity 天空背景，并用一个中性灰色背景替换它，并在背景上显示一个文本标题，说明已加载哪个屏幕。
- en: 'Let''s make a start and open the `bootUp` scene in the Unity Editor:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，并在 Unity 编辑器中打开 `bootUp` 场景：
- en: In the `level1` scene by going to `Assets/Scene`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 `Assets/Scene` 中的 `level1` 场景。
- en: Double-click on `prefab` folder if it isn't already.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请双击 `prefab` 文件夹。
- en: Next, double-click on the bootUp scene file from `Assets/Scene`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，双击从 `Assets/Scene` 中打开的 `bootUp` 场景文件。
- en: Drag and drop the `GameManager` prefab from the `Assets/Prefab`, to the **Hierarchy**
    window.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Assets/Prefab` 中的 `GameManager` 预制体拖放到 **层次结构** 窗口中。
- en: Create an empty game object in the **Hierarchy** window. If you have forgotten
    how to do this, refer to [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中创建一个空的游戏对象。如果您忘记了如何做，请参阅 [*第 2 章*](B18381_02_Epub.xhtml#_idTextAnchor048)，*添加和操作对象*。
- en: Name the newly created game object `BootUpText`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的游戏对象命名为 `BootUpText`。
- en: Create another empty game object as before and name that `BootUpComponent`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，创建另一个空的游戏对象并命名为 `BootUpComponent`。
- en: 'The following screenshot shows the components on the left-hand side of the
    **Hierarchy** window. These are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 **层次结构** 窗口左侧的组件。这些组件如下：
- en: '**Main Camera**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主相机**'
- en: '**Direction Light**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光**'
- en: '**GameManager**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏管理器**'
- en: '**BootUpComponent**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BootUpComponent**'
- en: '**BootUp Text**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BootUp Text**'
- en: '![Figure 7.5 – Game object Hierarchy window order'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 游戏对象层次结构窗口顺序'
- en: '](img/Figure_7.05_B18381.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.05_B18381.jpg)'
- en: Figure 7.5 – Game object Hierarchy window order
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 游戏对象层次结构窗口顺序
- en: 'On the right-hand side of the preceding screenshot, we have our `GameManager`
    game object selected showing its three main component scripts:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图右侧，我们选定了 `GameManager` 游戏对象，显示了其三个主要组件脚本：
- en: Game Manager
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏管理器
- en: Scenes Manager
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景管理器
- en: Score Manager
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数管理器
- en: As you may recall, our `GameManager` script will always remain in a scene, even
    if the scene is replaced with another, so it's vital we have these components
    in our Game Manager prefab.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，我们的 `GameManager` 脚本将始终保留在场景中，即使场景被另一个场景替换，因此我们必须在游戏管理器预制件中拥有这些组件。
- en: 'Next, we are going to change the background from sky to grey, as mentioned
    previously. To do this, select **Main Camera** from the **Hierarchy** window.
    Now, follow these steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把背景从天空更改为灰色，如之前所述。为此，从 **层次结构** 窗口中选择 **主相机**。现在，按照以下步骤操作：
- en: In the **Inspector** window, click the **Clear Flags** selection and change
    it from **Skybox** to **Solid Color**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中，点击 **清除标志** 选择项，并将其从 **天空盒** 更改为 **纯色**。
- en: Just below `32323200`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `32323200` 下方。
- en: This will change the RGB values to `50`,`50`,`50` with an alpha setting of `zero`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将把 RGB 值更改为 `50`,`50`,`50`，并设置透明度为 `零`。
- en: 'Use the following screenshot as a reference for the location for **Clear Flags**,
    **Background**, and **Hex Color**:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下截图作为 **清除标志**、**背景** 和 **十六进制颜色** 位置的参考：
- en: '![Figure 7.6 – Changing the background color of our scene'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 更改场景的背景颜色'
- en: '](img/Figure_7.06_B18381.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.06_B18381.jpg)'
- en: Figure 7.6 – Changing the background color of our scene
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 更改场景的背景颜色
- en: This will change the background in the **Game** window to gray.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 **游戏** 窗口中的背景更改为灰色。
- en: 'Next, we will select `BootUpText` and add a **Text Mesh** that will be at the
    bottom center of the screen. Follow these steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将选择 `BootUpText` 并添加一个位于屏幕底部中央的 **文本网格**。按照以下步骤操作：
- en: Select the `BootUpText` game object in the **Hierarchy** window.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中选中 `BootUpText` 游戏对象。
- en: Then, in the **Inspector** window, click the **Add Component** button.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **检查器** 窗口中，点击 **添加组件** 按钮。
- en: In the drop-down, type `Text Mes`h until you see it in the drop-down list.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中输入 `Text Mes`h，直到你在下拉列表中看到它。
- en: Select **Text Mesh** from the drop-down.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择 **文本网格**。
- en: 'With the `BootUp Text` game object still selected, change its **Transform**
    Position to the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在仍然选中 `BootUp Text` 游戏对象的情况下，将其 **变换** 位置更改为以下内容：
- en: '![](img/Table_011.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_011.jpg)'
- en: 'Now that our text is in the correct position, we need to fill out the **Text
    Mesh** component in **Inspector**. Follow these steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将文本放置在正确的位置，我们需要在 **检查器** 中填写 **文本网格** 组件。按照以下步骤操作：
- en: In the `BootUp`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BootUp`。
- en: Set **Anchor** to **Middle center**.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **锚点** 设置为 **居中**。
- en: Set **Alignment** to **Center**.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **对齐** 设置为 **居中**。
- en: 'Open the **Game** window (shortcut: *Ctrl (command* on Mac*) + 2*). Now, we
    should have a gray screen with white text so that we can easily identify the scene
    we are in. The following screenshot shows the "**BootUp**" text''s settings, along
    with its **Inspector** properties for reference:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **游戏** 窗口（快捷键：*Ctrl (command* 在 Mac 上) + 2*）。现在，我们应该有一个灰色屏幕和白色文本，这样我们就可以轻松地识别我们所在的场景。以下截图显示了
    “**BootUp**” 文本的设置，以及其 **检查器** 属性供参考：
- en: '![Figure 7.7 – Basic ''BootUp'' scene'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 基本的 ''BootUp'' 场景'
- en: '](img/Figure_7.07_B18381.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.07_B18381.jpg)'
- en: Figure 7.7 – Basic 'BootUp' scene
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 基本的 'BootUp' 场景
- en: The last thing we need to do for this `bootUp` scene is to make it function
    like most `bootUp` screens.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个 `bootUp` 场景，我们最后需要做的就是让它像大多数 `bootUp` 屏幕一样工作。
- en: When the `bootUp` screen appears, it stays there for a couple of seconds and
    then moves onto the next scene.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `bootUp` 屏幕出现时，它会停留几秒钟，然后转到下一个场景。
- en: To make it so the `bootUp` screen loads onto the next screen after a few seconds,
    we will need to create a script and add it to the `BootUpComponent` game object.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `bootUp` 屏幕在几秒钟后加载到下一个屏幕，我们需要创建一个脚本并将其添加到 `BootUpComponent` 游戏对象中。
- en: When we make the script, we need to store it with our other scripts in the `Assets/Script`).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建脚本时，需要将其存储在我们其他脚本所在的`Assets/Script`文件夹中。
- en: If you have forgotten how to make a script, check out the *Updating our camera
    properties via script* section in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects.*
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了如何创建脚本，请查看[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)中关于*通过脚本更新相机属性*的部分，*添加和操作对象*。
- en: Name the script `LoadSceneComponent`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本命名为`LoadSceneComponent`。
- en: 'The following screenshot shows what the `BootUpComponent` game object should
    look like when it''s selected in the **Hierarchy** window:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在**层次结构**窗口中选择`BootUpComponent`游戏对象时应看起来是什么样子：
- en: '![Figure 7.8 – ''BootUpComponent'' game object and script'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – `''BootUpComponent''`游戏对象和脚本'
- en: '](img/Figure_7.08_B18381.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – `''BootUpComponent''`游戏对象和脚本'
- en: Figure 7.8 – 'BootUpComponent' game object and script
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – `'BootUpComponent'`游戏对象和脚本
- en: Double-click the grayed-out field of `LoadSceneComponent` in the **Inspector**
    window to open the file.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**检查器**窗口中灰色的`LoadSceneComponent`字段以打开文件。
- en: The following code is similar to the code that we entered previously for loading
    a level, just in a shorter form. The basic principle is that we load in `UnityEngine.SceneManagement`
    to inherit Unity's `SceneManager` class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与我们之前为加载关卡输入的代码类似，只是形式更简短。基本原理是我们通过`UnityEngine.SceneManagement`加载以继承Unity的`SceneManager`类。
- en: Our game's score gets reset at the start of the script to stop any previous
    scores being carried over.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本开始时，我们的游戏分数将被重置，以防止之前的分数被携带过来。
- en: Then, we create a timer and increment the time in Unity's `Update` function.
    Once the timer goes over `3` seconds, `SceneManager` will load whatever we have
    put in the `loadThisScene` public variable, which in our case is `"title"`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个计时器，并在Unity的`Update`函数中递增时间。一旦计时器超过`3`秒，`SceneManager`将加载我们在`loadThisScene`公共变量中放入的内容，在我们的例子中是`"title"`。
- en: 'The following screenshot shows the `LoadSceneComponent` script in **Inspector**
    with a field where we can enter the scene we wish to load:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**检查器**中的`LoadSceneComponent`脚本，其中有一个我们可以输入要加载的场景的字段：
- en: '![Figure 7.9 – Load Scene Component will load the ''title'' scene'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 – `Load Scene Component`将加载''title''场景'
- en: '](img/Figure_7.09_B18381.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.09_B18381.jpg)'
- en: Figure 7.9 – Load Scene Component will load the 'title' scene
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – `Load Scene Component`将加载'title'场景
- en: It's as simple as that – we don't need to worry about anything else as the `bootUp`
    scene isn't part of the game loop. The `bootUp` scene is only played once when
    the game starts.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单 – 我们不需要担心其他任何事情，因为`bootUp`场景不是游戏循环的一部分。`bootUp`场景仅在游戏开始时播放一次。
- en: 'Enter the following code into `LoadSceneComponent`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到`LoadSceneComponent`：
- en: '[PRE29]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once you're done, save the script.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，保存脚本。
- en: Go back into the Unity Editor and type `title` into the `loadThisScene` variable
    field in the **Inspector** window, as shown in the preceding screenshot.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity编辑器，并在**检查器**窗口的`loadThisScene`变量字段中输入`title`，如前一个截图所示。
- en: Save the `bootUp` scene and press `bootUp` scene should load up and then, after
    `3` seconds, load up the `title` scene.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`bootUp`场景并按`bootUp`，场景应该加载，然后`3`秒后加载`title`场景。
- en: We can now repeat the majority of what we've done in the `bootUp` scene and
    duplicate this for the `title` and `gameOver` scenes. We will do this next.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以重复在`bootUp`场景中做的多数操作，并将这些操作复制到`title`和`gameOver`场景中。我们将在下一步进行操作。
- en: Setting up the title and gameOver scenes
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置标题和游戏结束场景
- en: The way we set the `bootUp` scene in the previous section is similar to how
    we want the `title` and `gameOver` scenes to look and act before we add any new
    art and custom functionality.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中设置`bootUp`场景的方式与我们想要在添加任何新艺术和自定义功能之前`title`和`gameOver`场景看起来和表现的方式相似。
- en: Thankfully, with Unity, we don't have to repeat the entire process of making
    these two scenes from scratch. We can copy, paste, and rename the game objects
    we have already created in the `bootUp` scene's `title` and `gameOver` scenes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用Unity，我们不需要从头开始重复创建这两个场景的整个过程。我们可以复制、粘贴并重命名在`bootUp`场景中已经创建的游戏对象。
- en: 'To copy the gray background and white `bootUp` scene, do the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制灰色背景和白色`bootUp`场景，请执行以下操作：
- en: With the `bootUp` scene still active in the Unity Editor, select all of the
    `5` game objects from the **Hierarchy** window (click the top or the bottom of
    the list, hold *Shift*, then click either end of the list to select all).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，当`bootUp`场景仍然处于活动状态时，从**层次结构**窗口中选择所有`5`个游戏对象（点击列表的顶部或底部，按住*Shift*，然后点击列表的任一端以选择所有对象）。
- en: Press *Left Ctrl* (*Command* on Mac) *+ C* to copy these `5` game objects.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*左Ctrl* (*Mac上的Command*) *+ C* 复制这些`5`个游戏对象。
- en: Open the `title` scene from the `Assets/Scene`).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/Scene`打开`title`场景。
- en: Select and delete all game objects in the **Hierarchy** window.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择并删除所有游戏对象。
- en: Click anywhere in the open space of the `bootUp` game objects.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bootUp`游戏对象的开放空间中点击任何位置。
- en: Select `BootUpText` in the `TitleText`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TitleText`中选择`BootUpText`。
- en: With the `TitleText` game object still selected, change the `Title`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`TitleText`游戏对象仍然被选中时，更改`Title`。
- en: Select `BootUpComponent` in the `TitleComponent`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TitleComponent`中选择`BootUpComponent`。
- en: With the `TitleComponent` game object still selected, click the three small
    dots in the **Inspector** window next to **LoadSceneComponent** (**Script**)**.**
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，仍然选择`TitleComponent`游戏对象，点击**LoadSceneComponent**（**脚本**）旁边的三个小点。
- en: A drop-down will appear; click **Remove Component** from it.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个下拉菜单；从中点击**移除组件**。
- en: We now need to make a script for the `TitleComponent` game object so that when
    the player taps or clicks the mouse button, the `shop` scene will load up next.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为`TitleComponent`游戏对象编写一个脚本，以便当玩家轻触或点击鼠标按钮时，将加载下一个场景`shop`。
- en: 'Repeat the same process of making and attaching a script as we did with `BootUpComponent`,
    but this time, name the script `TitleComponent` (also, as with the `TitleComponent`
    script, make sure it is moved into the correct folder in the `Assets/Script`)
    and paste in the following code:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复与`BootUpComponent`相同的步骤来创建和附加脚本，但这次，将脚本命名为`TitleComponent`（同样，与`TitleComponent`脚本一样，确保将其移动到`Assets/Script`中的正确文件夹）并粘贴以下代码：
- en: '[PRE30]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The difference between this `TitleComponent` script and the previous `BootUpComponent`
    script is that `TitleComponent` will move onto the next scene (`shop` scene) when
    a mouse button (or a finger on a touch screen) is pressed and released in `BootUpComponent`,
    which is dependent on a timer to increment the past `3` seconds to load the next
    scene, where its failsafe is to reset the game's score if the player completes
    the game.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`BootUpComponent`脚本相比，`TitleComponent`脚本的区别在于，当在`BootUpComponent`中按下并释放鼠标按钮（或在触摸屏上用手指触摸）时，`TitleComponent`将进入下一个场景（`shop`场景），这依赖于计时器将过去的`3`秒增加到加载下一个场景，其安全措施是在玩家完成游戏时重置游戏分数。
- en: Save the `TitleComponent` script and `title` scene.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`TitleComponent`脚本和`title`场景。
- en: 'The following screenshot shows what the `title` scene should look like in the
    Unity Editor:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Unity编辑器中`title`场景应该看起来是什么样子：
- en: '![Figure 7.10 – Hierarchy ''title'' scene game object order'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 – ''title''场景游戏对象层次结构顺序'
- en: '](img/Figure_7.10_B18381.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B18381.jpg)'
- en: Figure 7.10 – Hierarchy 'title' scene game object order
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 'title'场景游戏对象层次结构顺序
- en: We now need to repeat the exact same process for the `gameOver` scene.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对`gameOver`场景重复完全相同的步骤。
- en: 'Open the `gameOver` scene from the `Assets/Scene`) and repeat the process of
    pasting and renaming the game objects. Do the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Assets/Scene`打开`gameOver`场景并重复粘贴和重命名游戏对象的步骤。执行以下操作：
- en: In the `BootUpComponent` game object to `GameOver`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BootUpComponent`游戏对象到`GameOver`。
- en: Still in the `BootUpText` to `GameOverText`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`BootUpText`到`GameOverText`。
- en: Select the `GameOver` component in the `LoadSceneComponent` until we see it
    in the list. Then, select it if we don't have the component added already..
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LoadSceneComponent`组件中选择`GameOver`组件，直到我们在列表中看到它。然后，如果我们还没有添加该组件，就选择它。
- en: 'The following screenshot shows the `GameOver` component with the same `LoadSceneComponent`
    script where I added `"title"` to the `loadThisScene` variable field:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了具有相同`LoadSceneComponent`脚本的`GameOver`组件，我在`loadThisScene`变量字段中添加了`"title"`：
- en: '![Figure 7.11 – Load Scene Component loading the ''title'' scene'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 – 加载场景组件正在加载''title''场景'
- en: '](img/Figure_7.11_B18381.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B18381.jpg)'
- en: Figure 7.11 – Load Scene Component loading the 'title' scene
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 加载场景组件正在加载'title'场景
- en: Save the `gameOver` scene.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`gameOver`场景。
- en: Our Unity Project is now ready to run its full game loop. We will talk about
    the game loop in more detail in the next section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Unity项目现在已准备好运行其完整游戏循环。我们将在下一节中更详细地讨论游戏循环。
- en: Demonstrating that the game loop is complete
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示游戏循环已完成
- en: 'In this final section, we will confirm what we have achieved in this chapter.
    Our game now has a game loop, so if we load up the `bootUp` scene and press **Play**
    in the Unity Editor, the sequence will be as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将确认在本章中我们取得了什么成果。我们的游戏现在有一个游戏循环，所以如果我们加载`启动`场景并在 Unity 编辑器中按下**播放**，序列将如下所示：
- en: '`bootUp`: The scene runs for `3` seconds and then moves to the `title` scene.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`启动`: 场景运行`3`秒后移动到`标题`场景。'
- en: '`title`: If the player presses the mouse button, the `shop` scene will load.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`: 如果玩家按下鼠标按钮，将加载`商店`场景。'
- en: '`shop`: The player presses the `level1`.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`商店`: 玩家按下`level1`。'
- en: '`level1`: The player completes the level after `30` seconds (45 seconds for
    level 3) or dies. If the player dies more than `3` times, they will be presented
    with the `gameOver` scene.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1`: 玩家在`30`秒后（`level3`为`45`秒）完成关卡或死亡。如果玩家死亡超过`3`次，他们将看到`游戏结束`场景。'
- en: '`level2`: The same rules apply as the ones present for `level1`.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2`: 应用与`level1`相同的规则。'
- en: '`level3`: The same rules apply as the ones present for `level1`, but if the
    player completes the level, they will be presented with the `gameOver` scene.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level3`: 应用与`level1`相同的规则，但如果玩家完成关卡，他们将看到`游戏结束`场景。'
- en: '`gameOver`: The scene runs for `3` seconds and then moves to the `title` scene.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`游戏结束`: 场景运行`3`秒后移动到`标题`场景。'
- en: 'The following image shows the process of our game loop moving through each
    scene, then going back to the `title` scene:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了我们的游戏循环在各个场景之间移动的过程，然后回到`标题`场景：
- en: '![Figure 7.12 – Killer Wave''s game loop'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12 – Killer Wave 的游戏循环'
- en: '](img/Figure_7.12_B18381.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 7.12](img/Figure_7.12_B18381.jpg)'
- en: Figure 7.12 – Killer Wave's game loop
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – Killer Wave 的游戏循环
- en: Tip
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that if any of our scenes look darker than usual, we will need to bake
    its lights manually, as we did back in [*Chapter 3*](B18381_03_Epub.xhtml#_idTextAnchor073),
    *Managing Scripts and Taking a Mock Test.*
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果我们的任何场景看起来比平时暗，我们需要手动烘焙其灯光，就像我们在[*第3章*](B18381_03_Epub.xhtml#_idTextAnchor073)中做的那样，*管理脚本和进行模拟测试*。
- en: With this, we have created a series of scenes that carry their own individual
    responsibilities. When a scene comes to its end, either by its own choice or prompted
    to by the player, the next scene in the sequence will load. Eventually, by the
    player either completing all three levels or losing all their lives, our game
    will reach the `gameOver` scene. From the `gameOver` scene, we send the player
    back to the `title` scene. This is our game loop, and this is what every game
    will have. Game loops are a fundamental requirement for game development, and
    it's also possible that this will be mentioned in the exam.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建了一系列承担各自职责的场景。当一个场景结束时，无论是由于自身选择还是玩家提示，下一个场景将加载。最终，玩家要么完成所有三个级别，要么失去所有生命，我们的游戏将进入`游戏结束`场景。从`游戏结束`场景，我们将玩家送回到`标题`场景。这是我们游戏循环，这也是每个游戏都会有的。游戏循环是游戏开发的基本要求，而且这也可能在考试中提到。
- en: This concludes this section and this chapter, where we have created and managed
    our scenes in order to create a game loop.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分和这一章的内容到此结束，我们创建并管理了场景以创建游戏循环。
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a game loop; these are fundamental to game development,
    and sometimes application development. To create a game loop for our project,
    we needed multiple scenes that served their own purposes. We also needed to know
    when a scene started and when it should end. A scene ends when the player presses
    a button to continue, such as the `7` scene, or when the `bootUp` title automatically
    moves onto the next scene after so many seconds.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个游戏循环；这些是游戏开发的基础，有时也是应用开发的基础。为了为我们的项目创建游戏循环，我们需要多个具有各自目的的场景。我们还需要知道场景何时开始以及何时结束。场景在玩家按下按钮继续时结束，例如`7`场景，或者当`启动`标题在经过几秒钟后自动移动到下一个场景。
- en: Apart from making our game loops, we also learned some new vector math components
    on the way, including `Mathf.round`, which is used to round off figures `Vector3.distance`,
    which is used to measure the distance between two `Vector3` points; and `Vector3.lerp`,
    which is used to interpolate between two `Vector3` points.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建我们的游戏循环之外，我们还学习了一些新的矢量数学组件，包括`Mathf.round`，用于四舍五入`Vector3.distance`，用于测量两个`Vector3`点之间的距离；以及`Vector3.lerp`，用于在两个`Vector3`点之间进行插值。
- en: These are useful components in game development and will also likely be mentioned
    in the exam.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是游戏开发中有用的组件，也可能会在考试中提到。
- en: In the next chapter, we will be adding some polish to our placeholder scenes
    with custom fonts, creating our own images, and applying some UI animation in
    the Unity Editor.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过自定义字体、创建自己的图像和在Unity编辑器中应用一些UI动画来为我们的占位符场景添加一些润色。
- en: Mock test
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟测试
- en: What would be the best way for a UI menu system to be worked on from a programmer's
    perspective, but at the same time in a way that doesn't interfere with an artist
    working on the same workflow?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，但同时又不会干扰艺术家在同一工作流程中工作的最佳方式是什么？
- en: Make it so that each UI component has its own class so that any art changes
    won't affect either outcome.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保每个UI组件都有自己的类，这样任何艺术上的更改都不会影响结果。
- en: Give each UI component a separate material so that any changes in the code will
    be isolated.
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给每个UI组件分配一个单独的材料，以便任何代码更改都将被隔离。
- en: Use prefabs for each UI component so that any artist can modify them individually.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个UI组件使用预制件，以便任何艺术家都可以单独修改它们。
- en: Have a separate script that sweeps through all UI components to check any changes
    that are made so that they're known to everyone.
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个单独的脚本遍历所有UI组件，检查所做的任何更改，以便让每个人都知道。
- en: An **Image** component has a sprite in its **Source Image** parameter and its
    **Image Type** is set to **Filled**. What does **Filled** do?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**Image**组件在其**Source Image**参数中有一个精灵，其**Image Type**设置为**Filled**。**Filled**的作用是什么？
- en: Fills open spaces in the sprite.
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充精灵中的开放空间。
- en: It offers various ways to fill in the sprite.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供了多种填充精灵的方法。
- en: Makes it so no other sprite can override it.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保没有其他精灵可以覆盖它。
- en: Inverts the color of the sprite.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转精灵的颜色。
- en: What component does `CrossPlatformInputManager` replace?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CrossPlatformInputManager`替换了哪个组件？'
- en: '`anyKey`'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`anyKey`'
- en: '`Input `'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input`'
- en: '`mousePosition`'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mousePosition`'
- en: '`acceleration`'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`acceleration`'
- en: When testing a top-down shooter game you have just developed, you want the controls
    to have an "Arcade" feel. To make the controls snap into position when moving
    the player, which property would help create what is required?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试你刚刚开发的上向下射击游戏时，你希望控制具有“街机”感。为了使控制能够在移动玩家时自动对齐位置，哪个属性有助于创建所需的效果？
- en: '`GetAxisRaw `'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetAxisRaw`'
- en: '`GetJoystickNames`'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetJoystickNames`'
- en: '`InputString`'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InputString`'
- en: '`gyro`'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gyro`'
- en: When writing code such as variable names, which is the correct naming convention
    to use?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码时，例如变量名，应该使用哪种命名规范？
- en: Pascal case
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帕斯卡命名法
- en: Lower case
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小写
- en: Cake case
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蛋糕命名法
- en: Camel case
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 骆驼命名法
- en: You are working with a team to create a realistic simulation for the military
    that includes a series of explosions. You have been asked to take over from the
    previous developer who has, so far, created a framework that issues a series of
    explosions from a bank of prefabs. The prefabs are updated on a regular basis
    by one of the artists on the team. As impressive as this looks, the program has
    gotten quite big and the artist will need to have the option to update, swap out,
    replace, and delete prefabs from the framework.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在与一个团队一起创建一个用于军事的逼真模拟，该模拟包括一系列爆炸。你被要求接替之前开发者的工作，他到目前为止已经创建了一个从预制件库中发出一系列爆炸的框架。这些预制件由团队中的艺术家定期更新。尽管看起来很令人印象深刻，但程序已经变得相当庞大，艺术家将需要有权更新、替换、替换和从框架中删除预制件。
- en: What solution can you offer the team that keeps this framework from not going
    against SOLID principles and is accessible to the artist in the team?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你能为团队提供什么解决方案，以防止该框架违反SOLID原则，并且对团队中的艺术家来说是可访问的？
- en: Create a series of prefabs that hold a cluster of prefabs that randomize on
    each occasion when they're used in the Unity scene.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一系列预制件，这些预制件包含一个预制件簇，每次在Unity场景中使用时都会随机化。
- en: Create a single scriptable object that holds an array of prefabs that holds
    a reference to either script.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可脚本化的对象，该对象包含一个预制件数组，该数组引用了任意的脚本。
- en: Create a non-procedural particle system that creates its own explosions.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个非过程式的粒子系统，使其能够生成自己的爆炸效果。
- en: Hold all the explosions in the scene at runtime but off-camera and then bring
    in those required using a random selection script.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行时将场景中的所有爆炸保留在摄像机之外，然后使用随机选择脚本引入所需的爆炸。
- en: Which collider is the fastest for the Unity physics system to calculate?
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个碰撞器对Unity物理系统来说计算速度最快？
- en: Hinge
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轴承
- en: Sphere
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 球体
- en: Mesh
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格
- en: Box
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩形
- en: Which is the cheapest MinMaxCurve to use?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个MinMaxCurve是最便宜的？
- en: Optimized Curve
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化曲线
- en: Random between two constants
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个常量之间随机选择
- en: Random between two curves
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个曲线之间随机选择
- en: Constant
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量
- en: Which property needs to be accessed through code to create a strobe effect for
    a nightclub scene?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个属性需要通过代码访问以创建夜总会场景的闪烁效果？
- en: '`color.a`'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`color.a`'
- en: '`spotAngle`'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spotAngle`'
- en: '`range`'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`range`'
- en: '`intensity`'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`intensity`'
