- en: Building Our First .NET Core Game – Tic-Tac-Toe
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个 .NET Core 游戏——菲尔兹棋
- en: Learning is more fun if we do it while playing games. With this thought, let's
    continue our quest to learn .NET Core 2.0 by writing our very first game in .NET
    Core 2.0, Tic-Tac-Toe. In this chapter, we will understand the anatomy of the
    ASP.NET Core 2.0 application that we created in [Chapter 1](ch01.html), *Getting
    Started*, and understand each file and its purpose in the application. Then, we
    will quickly understand the basics of SignalR Core, which is the technology we
    will use to write the game in .NET Core 2.0\. We will then proceed with the quick
    setup of SignalR Core, followed by the design and coding of the basic Tic-Tac-Toe
    game, in which players can specify their own images instead of conventional *X*
    and *O*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习在玩游戏的同时会更加有趣。带着这个想法，让我们继续我们的学习之旅，通过编写我们的第一个 .NET Core 2.0 游戏——菲尔兹棋来学习 .NET
    Core 2.0。在本章中，我们将了解我们在 [第 1 章](ch01.html) “入门”中创建的 ASP.NET Core 2.0 应用程序的解剖结构，并了解应用程序中的每个文件及其目的。然后，我们将快速了解
    SignalR Core 的基础知识，这是我们将在 .NET Core 2.0 中编写游戏的技术。接下来，我们将进行 SignalR Core 的快速设置，然后是基本菲尔兹棋游戏的设计和编码，玩家可以指定自己的图片而不是传统的
    *X* 和 *O*。
- en: 'Here are the topics that we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Anatomy of ASP.NET Core 2.0 application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0 应用程序的解剖结构
- en: Tic-Tac-Toe
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菲尔兹棋
- en: Game design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏设计
- en: SignalR Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalR Core
- en: Solution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案
- en: Anatomy of an ASP.NET Core 2.0 application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0 应用程序的解剖结构
- en: In this section, we will discuss the *who is who and what is what* of the ASP.NET
    Core 2.0 application that we created in the *Creating a simple* *running code* section
    of [Chapter 1](ch01.html), *Getting Started*. The idea is to understand the purpose
    and use of each file that comes with the MVC template when creating the application,
    so that we can make the best possible use of them when needed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论我们在 [第 1 章](ch01.html) “入门”中“创建简单运行代码”部分创建的 ASP.NET Core 2.0 应用程序的“谁是谁，什么是何物”。目的是理解
    MVC 模板附带每个文件的目的和使用方法，以便在需要时能最大限度地利用它们。
- en: 'The following screenshot shows what our application structure looks like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的应用程序结构：
- en: '![](img/e7b5942b-09e6-4867-b4b6-b688f2575575.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7b5942b-09e6-4867-b4b6-b688f2575575.png)'
- en: 'For ease of understanding, the items are numbered from 1 to 12\. We will walk
    through each item and understand what they bring to the table:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于理解，项目从 1 到 12 编号。我们将逐一介绍每个项目，并了解它们带来的价值：
- en: 'Connected Services: This doesn''t present itself as a physical file in the
    project template created by .NET Core 2.0 tooling, and is only visible when the
    project is opened from Visual Studio 2017 IDE; that is, it''s a Visual Studio
    2017 feature. The intent is to make it easier for developers to add connected
    services to their application. The services may be deployed on-premises or in
    the cloud. Earlier, this used be available as Add Connected Service in the project''s,
    right-click context menu; now it''s available as a node in Solution Explorer for
    web and mobile projects. One of the services that every ASP.NET Core web app can
    leverage is Application Insights. The entire comprehensive list of services can
    be found at [https://docs.microsoft.com/en-us/azure/#pivot=services&panel=all](https://docs.microsoft.com/en-us/azure/#pivot=services&panel=all).
    If we click on the Connected Services node in Solution Explorer, we will see a
    new full page window in Visual Studio which has three tabs:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接服务：这并不是由 .NET Core 2.0 工具创建的项目模板中的物理文件，只有在从 Visual Studio 2017 IDE 打开项目时才可见；也就是说，这是一个
    Visual Studio 2017 的功能。目的是让开发者更容易将连接服务添加到他们的应用程序中。这些服务可以部署在本地或云端。以前，这可以通过在项目的右键上下文菜单中选择“添加连接服务”来获得；现在，它作为
    Solution Explorer 中的节点提供，适用于 Web 和移动项目。每个 ASP.NET Core Web 应用都可以利用的服务之一是 Application
    Insights。完整的综合服务列表可以在 [https://docs.microsoft.com/en-us/azure/#pivot=services&panel=all](https://docs.microsoft.com/en-us/azure/#pivot=services&panel=all)
    找到。如果我们点击 Solution Explorer 中的“连接服务”节点，我们将在 Visual Studio 中看到一个新全页窗口，它有三个选项卡：
- en: '![](img/39fb2154-050b-47ee-a0f8-0bedee914fe2.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39fb2154-050b-47ee-a0f8-0bedee914fe2.png)'
- en: 'Overview: This tab is in the `GettingStarted` section of the ASP.NET Core app.
    It lists Microsoft''s official documentation links for ASP.NET Core app development,
    adding services, and deploying it to the cloud.'
  id: totrans-15
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概述：此选项卡位于 ASP.NET Core 应用程序的 `GettingStarted` 部分。它列出了 Microsoft 为 ASP.NET Core
    应用程序开发、添加服务和将其部署到云提供的官方文档链接。
- en: 'Connected Services: This is the section that enables us to add connected services
    to the application. Right-click on the Connected Services node in Solution Explorer;
    we see a context menu item, Add Connected Service. If we click this item, it also
    navigates to the same place. We will add connected services in subsequent chapters,
    when we discuss Azure:'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接服务：这是允许我们向应用程序添加连接服务的部分。在解决方案资源管理器中的连接服务节点上右键单击；我们看到一个上下文菜单项，添加连接服务。如果我们点击此项，它也会导航到相同的位置。我们将在后续章节中添加连接服务，当我们讨论Azure时。
- en: '![](img/4099ae78-3b92-493f-9931-31290397cd52.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4099ae78-3b92-493f-9931-31290397cd52.png)'
- en: 'Publish: To publish the web app in the cloud or on-premises. We will discuss
    this further in a later chapter, when we publish our app in Azure.'
  id: totrans-18
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布：在云或本地环境中发布Web应用程序。我们将在后续章节中进一步讨论这个问题，当我们发布我们的应用程序到Azure时。
- en: 'Dependencies: This node has been around in Visual Studio for a while now. Again,
    this isn''t present as a physical file in the system. There is a tooling update
    in Visual Studio 2017, which categorizes the dependencies and groups them into
    the following:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项：这个节点已经在Visual Studio中存在了一段时间。同样，它不是作为系统中的物理文件存在的。Visual Studio 2017中有一个工具更新，它将依赖项分类并将它们分组到以下类别：
- en: 'Analyzers: The analyzers are included in the project by default, as shown here:'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析器：分析器默认包含在项目中，如下所示：
- en: '![](img/4ae41f65-6923-4332-91a7-58cfa08b921e.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ae41f65-6923-4332-91a7-58cfa08b921e.png)'
- en: 'NuGet: The NuGet packages referred by the project are listed here. In the default
    ASP.NET Core 2.0 MVC template, we will see just one NuGet package called `Microsoft.AspNetCore.All`
    and that''s awesome, as we no longer need to worry about versioning different
    packages and plumbing them to use in our app. `Microsoft.AspNetCore.All` is a
    metapackage; that is, it only references other packages. It references all ASP.NET
    Core packages and their dependencies, and all Entity Framework Core packages and
    their dependencies. The version of this package represents the ASP.NET Core and
    Entity Framework Core version. And the best part is that even though it''s just
    one package, you can still go ahead and visualize all the packages that come with
    it alongside their dependencies:'
  id: totrans-22
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: NuGet：项目引用的NuGet包在此列出。在默认的ASP.NET Core 2.0 MVC模板中，我们将看到一个名为`Microsoft.AspNetCore.All`的NuGet包，这真是太棒了，因为我们不再需要担心不同包的版本控制以及将它们集成到我们的应用程序中。`Microsoft.AspNetCore.All`是一个元包；也就是说，它只引用其他包。它引用了所有ASP.NET
    Core包及其依赖项，以及所有Entity Framework Core包及其依赖项。此包的版本代表ASP.NET Core和Entity Framework
    Core的版本。最好的部分是，尽管它只是一个包，你仍然可以继续可视化所有与之相关的包及其依赖项：
- en: '![](img/043d4ea3-3737-4dd4-ad95-b5430bb2b5eb.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/043d4ea3-3737-4dd4-ad95-b5430bb2b5eb.jpg)'
- en: 'SDK: Displays the target SDK. For the default ASP.NET Core 2.0 app, it would
    be Microsoft.NETCore.App.'
  id: totrans-24
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDK：显示目标SDK。对于默认的ASP.NET Core 2.0应用程序，它将是Microsoft.NETCore.App。
- en: 'Bower: This is the package manager for the web. It helps manage all the client-related
    stuff, such as HTML, CSS, JavaScript, fonts, and images. All the client-side packages
    are listed here. In the default project template, we can see stuff such as bootstrap,
    jquery, and so on.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bower：这是Web的包管理器。它帮助管理所有客户端相关的内容，例如HTML、CSS、JavaScript、字体和图像。所有客户端包都列在这里。在默认项目模板中，我们可以看到诸如bootstrap、jquery等东西。
- en: These are the four types of dependency that come with the default ASP.NET Core
    2.0 MVC template. But we are not limited to these dependencies alone. Based on
    the package manager of choice, we may also have **node package manager** (**npm**)
    or other package managers as the dependency listed here. In this chapter, we will
    use npm to install the SignalR client package, as it is available through npm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是默认ASP.NET Core 2.0 MVC模板中包含的四种类型的依赖项。但我们不仅限于这些依赖项。根据选择的包管理器，我们可能还有**node包管理器**（**npm**）或其他包管理器作为列出的依赖项。在本章中，我们将使用npm安装SignalR客户端包，因为它可以通过npm获得。
- en: The immediate question that comes to mind is what is Node.js? Node.js is a platform
    built on Chrome's JavaScript runtime engine for easily building fast and scalable
    applications. It uses an event-driven, non-blocking, asynchronous I/O model, which
    makes it lightweight and efficient, perfect for data-intensive (and non-CPU-intensive)
    real-time applications. So, npm is the package manager for JavaScript. To use
    npm, we need to install Node.js.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 脑海中浮现的第一个问题是什么是Node.js？Node.js是一个基于Chrome的JavaScript运行时引擎构建的平台，用于轻松构建快速且可扩展的应用程序。它使用事件驱动、非阻塞、异步I/O模型，这使得它轻量级且高效，非常适合数据密集型（和非CPU密集型）的实时应用程序。因此，npm是JavaScript的包管理器。要使用npm，我们需要安装Node.js。
- en: 'Properties: Double-clicking on the Properties node of the project in Solution
    Explorer takes us to the project properties page and, on expanding this, displays
    the `launchSettings.json` file, where all the launch/startup-related configurations
    are serialized and saved as JSON. The following is the default code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性：在解决方案资源管理器中双击项目的“属性”节点，将带我们到项目属性页面，展开后显示`launchSettings.json`文件，其中所有启动/启动相关的配置都序列化并保存为JSON。以下是对默认代码的描述：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s evident that the values in the preceding code match the Debug section
    of the properties page of the project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，前面代码中的值与项目属性页面的调试部分相匹配：
- en: '![](img/6a4228fb-5479-4c48-931a-d2362c3a13f8.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a4228fb-5479-4c48-931a-d2362c3a13f8.png)'
- en: 'wwwroot: All client-side packages and images are part of this folder. Files
    in this folder are served as static content and can be bundled and minified to
    reduce payloads and page rendering by using `bundleconfig.json`. A few of the
    common folders are:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'wwwroot: 所有客户端包和图像都是这个文件夹的一部分。这个文件夹中的文件作为静态内容提供服务，可以使用`bundleconfig.json`进行捆绑和压缩以减少负载和页面渲染。以下是一些常见的文件夹：'
- en: '`css`: Contains cascading style sheets'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css`: 包含层叠样式表'
- en: '`images`: Contains the image assets that are needed in the app'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`: 包含应用中需要的图像资源'
- en: '`js`: Contains JavaScript files'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js`: 包含JavaScript文件'
- en: '`lib`: Contains the client-side packages'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`: 包含客户端包'
- en: 'Controllers: Contains the controllers as per the Model-View-Controller (MVC)
    architecture.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器：包含按照模型-视图-控制器（MVC）架构的控制器。
- en: 'Models: Contains the models as per the MVC architecture.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型：包含按照MVC架构的模型。
- en: 'Views: Contains the views as per the MVC architecture.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图：包含按照MVC架构的视图。
- en: '`appsettings.json`: The application settings for the application. It contains
    the key and value-based settings in JSON format. If you are an old school ASP.NET
    web developer, you can think of it as the `appSettings` section defined inside
    `web.config`. The following is the sample configuration for `Logging`, which comes
    with the default template:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`appsettings.json`: 这是应用程序的设置。它包含基于键和值的设置，格式为JSON。如果你是老派的ASP.NET Web开发者，你可以将其视为定义在`web.config`内部的`appSettings`部分。以下是对`Logging`的示例配置，这是默认模板自带的部分：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`bower.json`: The Bower package manager is part of Visual Studio, as mentioned
    previously. This client-side package manager is one of the most widely-used package
    managers in the open source community for managing packages. `bower.json` is used
    by Bower to download and manage the client-side packages. This is very similar
    to the `packages.config` file that is used for managing NuGet packages. Just specify
    the package name that you want in the JSON file and Bower will do the rest. In
    case you do not see the packages, just right-click on the file in Solution Explorer
    and click Restore Packages. The following is the code snippet from `bower.json`,
    which lists the dependencies as `bootstrap`, `jquery`, and so on:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bower.json`: 如前所述，Bower包管理器是Visual Studio的一部分。这个客户端包管理器是开源社区中用于管理包的最广泛使用的包管理器之一。`bower.json`被Bower用于下载和管理客户端包。这与用于管理NuGet包的`packages.config`文件非常相似。只需在JSON文件中指定你想要的包名，Bower就会完成剩余的工作。如果你看不到包，只需在解决方案资源管理器中右键单击文件，然后点击“还原包”。以下是从`bower.json`中的代码片段，列出了依赖项为`bootstrap`、`jquery`等：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In case you do not like this approach of adding the client-side dependency
    in the `bower.json` file, right-click on the `bower.json` file and click on Manage
    Bower Packages. This has a very similar user interface to the NuGet package manager
    and can be used in the same way. Just search the package and click Install. The
    following image shows the installed Bower packages in the project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢在`bower.json`文件中添加客户端依赖项的方法，右键单击`bower.json`文件，然后点击“管理Bower包”。它具有与NuGet包管理器非常相似的用户界面，并且可以以相同的方式使用。只需搜索包并点击安装。以下图片显示了项目中安装的Bower包：
- en: '![](img/b642db67-7851-48a4-9db6-19bcdc9d58f4.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b642db67-7851-48a4-9db6-19bcdc9d58f4.jpg)'
- en: '`bundleconfig.json`: This JSON file used to store the project bundling and
    minification configuration for the static content of the site, that is, scripts
    and styles. The following is what the default MVC project template, `bundleconfig.json`,
    looks like. The names and comments are intuitive to understand:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bundleconfig.json`: 这个JSON文件用于存储网站静态内容（即脚本和样式）的项目捆绑和压缩配置。以下是对默认MVC项目模板`bundleconfig.json`的描述。名称和注释都是直观易懂的：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Bundling and minification are techniques to improve request load time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑和压缩是提高请求加载时间的技巧：
- en: Bundling improves load time by reducing the number of requests sent to the server
    by the client to fetch static content; that is, CSS, JavaScript. Most major modern
    browsers limit the number of simultaneous connections for each hostname to six;
    that is to say, if six requests are being processed, any additional requests from
    the client for assets on the same hostname would be queued by the browser. With
    bundling, this issue is avoided, as all CSS files can be bundled as one file and,
    likewise, one file for JavaScript. This improves the first-time load performance.
    For subsequent requests, it's not much of an improvement, as the browser caches
    the files.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包（Bundling）通过减少客户端发送到服务器的请求次数来提高加载时间，即减少获取静态内容（CSS和JavaScript）的请求次数。大多数现代浏览器限制每个主机名的并发连接数最多为六个；也就是说，如果有六个请求正在处理，来自客户端的任何附加请求都会被浏览器排队。通过打包，可以避免这个问题，因为所有CSS文件都可以打包成一个文件，同样，JavaScript也可以打包成一个文件。这提高了首次加载的性能。对于后续请求，改进并不大，因为浏览器会缓存这些文件。
- en: Minification improves performance by reducing the size of  the requested assets,
    that is, CSS and JavaScript, by removing unnecessary white spaces and comments,
    and  shortening the variable names to one character. We have all seen the `jquery.min.js`
    file while doing web development. The `min` in the name is to help the user identify
    that it is the minified version of the file.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩（Minification）通过减少请求资源的尺寸来提高性能，即通过移除不必要的空白和注释，以及缩短变量名到单个字符来减少CSS和JavaScript的大小。我们在进行Web开发时都见过`jquery.min.js`文件。文件名中的`min`是为了帮助用户识别这是文件的压缩版本。
- en: '`Program.cs`: This is the main entry point to the ASP.NET Core 2.0 app. It
    has the minimum code needed to get the app up and running with the default configurations:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Program.cs`：这是ASP.NET Core 2.0应用程序的主要入口点。它包含启动应用程序所需的最低限度的代码，使用默认配置：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, this looks more like a console application and, actually, that
    is what it is—a console app. In its entry point `Main` method, it creates a web
    server, hosts the application, and starts listening to HTTP requests. Notice here
    that `BuildWebHost` is a method which returns an object that implements `IWebHost`,
    accepting a string array argument. This method is implemented as an expression
    bodied member, just to make the developers aware that the sole purpose of this
    method is to build the web host and no other code should be put here. The method
    follows the builder pattern to build the host. There are several methods that
    we can hook up, one after another, as needed, and they would be added to the object
    incrementally, one after the other. The `CreateDefaultBuilder` method builds the
    web host with the default configuration wired up from various configuration providers
    (such as JSON and environment variables, to name a few), sets the logging configuration,
    and sets up a Kestrel web server with IIS integration, which is good enough for
    the app to run. The `Build` method builds the object and returns. Notice the `UseStartup<Startup>`
    method call, which actually specifies the `Startup` class for the app. We will
    discuss this class next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这看起来更像是一个控制台应用程序，实际上它确实是一个控制台应用程序。在其入口点`Main`方法中，它创建了一个Web服务器，托管应用程序，并开始监听HTTP请求。注意这里，`BuildWebHost`是一个返回实现`IWebHost`的对象的方法，它接受一个字符串数组参数。这个方法被实现为一个表达式主体成员，只是为了让开发者意识到这个方法的唯一目的是构建Web宿主，不应该在这里放置其他代码。该方法遵循构建者模式来构建宿主。我们可以根据需要连接几个方法，一个接一个地添加到对象中。`CreateDefaultBuilder`方法使用来自各种配置提供者（例如JSON和环境变量等）的默认配置来构建Web宿主，设置日志配置，并设置一个与IIS集成的Kestrel
    Web服务器，这对于应用程序的运行已经足够好了。`Build`方法构建对象并返回。注意`UseStartup<Startup>`方法的调用，实际上指定了应用程序的`Startup`类。我们将在下一节讨论这个类。
- en: The **Builder pattern** is an object creation design pattern. It is one of the
    23 well-known **Gang of Four** (**GoF**) design patterns. The intent behind this
    pattern is to separate the construction of a complex object from its representation,
    so that the same construction process can create different representations. To
    do so, this pattern builds a complex object using simple objects in a step-by-step
    approach.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建者模式（Builder pattern**）是一种对象创建设计模式。它是23个著名的**四人帮（Gang of Four，GoF**）设计模式之一。这种模式的目的是将复杂对象的构建与其表示分离，以便相同的构建过程可以创建不同的表示。为此，这种模式通过逐步使用简单对象来构建复杂对象。'
- en: '`Startup.cs`: This is the class, where we define the request handling pipeline
    and configure the services needed by the application. Let''s look at the code
    and then discuss it in depth:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Startup.cs`：这是定义请求处理管道和配置应用程序所需服务的类。让我们看看代码，然后深入讨论它：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The key takeaways from the class code are:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从类代码中得出的关键要点是：
- en: The class should be `public`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类应该是`public`。
- en: The constructor has a dependency on `IConfiguration`, which is injected as the
    core service and assigned to the `public` property `Configuration` of type `IConfiguration`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数依赖于`IConfiguration`，它作为核心服务注入，并分配给类型为`IConfiguration`的`public`属性`Configuration`。
- en: This makes `Configuration` a first class citizen of the ASP.NET Core application
    and can be easily used to read the `appSettings` value just by using this code: `Configuration["<KeyName>"]`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使得`Configuration`成为ASP.NET Core应用程序的一等公民，并且可以通过使用以下代码轻松读取`appSettings`值：`Configuration["<KeyName>"]`。
- en: 'There are only two public methods in the class:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类中只有两个公共方法：
- en: '`ConfigureServices`: This method is called by the runtime. This method is the
    place to add services to the container, such as MVC, antiforgery, application
    insight telemetry, authentication, authorization, localization, identity, and
    so on. There is a huge list of services available, which can be seen through IntelliSense.
    In the preceding code, we are c files, such as css, js, images, HTjust adding
    the MVC service, so that we can leverage all the MVC goodness in our app.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigureServices`：这个方法由运行时调用。这个方法是将服务添加到容器的地方，例如MVC、反伪造、应用程序洞察遥测、身份验证、授权、本地化、身份等。有一个巨大的服务列表可供选择，可以通过IntelliSense查看。在前面的代码中，我们正在添加MVC服务，这样我们就可以在我们的应用程序中利用所有MVC的优点。'
- en: '`Configure`: As the comment in the code explains, this method is called by
    the runtime and is used to configure the HTTP request pipeline. In this method,
    we have access to the application builder and the hosting environment, which is
    another first class citizen of the .NET Core 2.0 app and is available in the container
    for injection into the objects that we construct. In the preceding code, which
    comes with the default MVC template, we can see the following:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Configure`：如代码中的注释所述，这个方法由运行时调用，并用于配置HTTP请求管道。在这个方法中，我们可以访问应用程序构建器和托管环境，这是.NET
    Core 2.0应用程序的另一个一等公民，并且可以在容器中用于注入到我们构建的对象中。在前面的代码中，即默认MVC模板中，我们可以看到以下内容：'
- en: First, it checks whether the environment is for development or not. This is
    determined by the environment variable, `ASPNETCORE_ENVIRONMENT`. If its value
    is `Development`, it will detect the host environment to be `Development`; otherwise,
    it will be `Production`. If this environment variable is not available, it defaults
    the environment to `Production`. The variable can be set in the project properties
    page in the Debug section. The screenshot of the preceding properties section
    displays the Environment variable clearly.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它会检查环境是否为开发环境。这是通过环境变量`ASPNETCORE_ENVIRONMENT`来确定的。如果其值为`Development`，它将检测主机环境为`Development`；否则，它将是`Production`。如果这个环境变量不可用，它将默认环境设置为`Production`。这个变量可以在项目属性页的调试部分设置。前面属性部分的截图清楚地显示了环境变量。
- en: If the environment is `Development`, it tells the app to use the developer exception
    page by calling the `UseDeveloperExceptionPage()` method. The developer exception
    page gives a detailed error message with the exception stack trace to help the
    developer pinpoint the issue and resolve it. This should not be used in `Production`,
    as the exception information may be used by a hacker to attack your site. Also,
    your end user may not be a technical person, and may prefer to see a more user-friendly
    message than a .NET stack trace, so in production we use a custom error page,
    which is specified by calling the `UseExceptionHandler("/Home/Error");` method.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果环境是`Development`，它通过调用`UseDeveloperExceptionPage()`方法告诉应用程序使用开发者异常页面。开发者异常页面提供了一个详细的错误消息和异常堆栈跟踪，以帮助开发者定位问题并解决它。在`Production`中不应使用此功能，因为异常信息可能被黑客用来攻击您的网站。此外，您的最终用户可能不是技术人员，他们可能更喜欢看到比.NET堆栈跟踪更友好的消息，因此在生产中我们使用自定义错误页面，该页面通过调用`UseExceptionHandler("/Home/Error");`方法指定。
- en: During the development phase, you may want to test your web app against multiple
    browsers, and hence may want to open multiple browsers and browse the page to
    check for compatibility issues and refresh them when you make a fix. The `UseBrowserLink()` method
    helps you do just that. **Browser Link** is a feature in Visual Studio that creates
    a communication channel between the `Development` environment and one or more
    web browsers. We can use Browser Link to refresh the web application in several
    browsers at once.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发阶段，你可能想要测试你的 Web 应用程序针对多个浏览器，因此可能需要打开多个浏览器并浏览页面以检查兼容性问题，并在修复时刷新它们。`UseBrowserLink()`
    方法可以帮助你做到这一点。**浏览器链接** 是 Visual Studio 中的一项功能，它创建了一个在 `Development` 环境和一台或多台 Web
    浏览器之间的通信通道。我们可以使用浏览器链接同时刷新多个浏览器中的 Web 应用程序。
- en: Static files, such as `css`, `js`, `images`, HTML, and so on, which are placed
    in the `wwwroot` folder, are not servable by default. To make them servable, we
    need to call the `UseStaticFiles()` method.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态文件，如 `css`、`js`、`images`、HTML 等，它们放置在 `wwwroot` 文件夹中，默认情况下不可服务。为了使它们可服务，我们需要调用
    `UseStaticFiles()` 方法。
- en: Finally, the last piece of the code configures the MVC service (added in the `Configure`
    method) by specifying the default route.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，代码的最后一段配置了 MVC 服务（在 `Configure` 方法中添加），通过指定默认路由来完成。
- en: 'To sum up, in this method we just configure the HTTP request pipeline using
    middleware. We will look at middleware in the next chapter, but for the time being,
    just think of them as HTTP modules in the earlier versions of ASP.NET. We added
    the services and then configured them as per our requirements using middleware.
    We will find three types of middleware configuration in the code samples:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结一下，在这个方法中，我们只是使用中间件配置了 HTTP 请求管道。我们将在下一章查看中间件，但在此期间，只需将它们视为 ASP.NET 早期版本中的
    HTTP 模块。我们添加了服务，然后根据我们的要求使用中间件进行配置。我们将在代码示例中找到三种类型的中间件配置：
- en: '`app.Run()`: The first `app.Run`  delegate terminates the HTTP request pipeline.
    If you use `Run`, it expects the handler and hence the request is served back
    to the client. No further middleware will be called in the request path.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.Run()`：第一个 `app.Run` 委托终止 HTTP 请求管道。如果你使用 `Run`，它期望处理程序，因此请求会被服务回客户端。在请求路径中不会调用其他中间件。'
- en: '`app.Map*`: This extension is used as a convention for branching the pipeline.
    `Map` branches the request pipeline based on matches of the given request path.
    If the request path starts with the given path, the branch is executed.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.Map*`：这个扩展用作分支管道的约定。`Map` 根据给定的请求路径匹配来分支请求管道。如果请求路径以给定的路径开头，则执行分支。'
- en: '`app.Use[Middleware]`: `Use` can be used to chain the middleware; that is,
    we can arrange them to execute one after another. `Use` can also be used to short-circuit
    the request pipeline as needed.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.Use[Middleware]`：`Use` 可以用来链式调用中间件；也就是说，我们可以将它们安排成依次执行。`Use` 也可以根据需要短路请求管道。'
- en: If this sounds scary, don't worry! We will discuss middleware, dependency injection,
    and containers in detail in the next chapter while developing our Let's Chat application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很可怕，别担心！在我们开发 Let's Chat 应用程序的同时，我们将在下一章详细讨论中间件、依赖注入和容器。
- en: 'Last but not least, the `.csproj` file has major and long-anticipated enhancements.
    The `.xproj` from .NET Core 1.0 is now gone and we have our familiar `.csproj`
    back in business with ASP.NET Core 2.0\. It''s better than earlier, as it is lightweight
    and easier to manage. Visual Studio 2017 also has a tooling update, which enables
    us to edit the `.csproj` file without having to unload the project and edit. This
    is super awesome. Just right-click on the project in Solution Explorer and then
    click `Edit <Project Name>.csproj`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`.csproj` 文件有了重大和长期期待的增强。.NET Core 1.0 的 `.xproj` 现在已经消失，我们熟悉的 `.csproj`
    在 ASP.NET Core 2.0 中重新投入使用。它比之前更好，因为它更轻量级且易于管理。Visual Studio 2017 也进行了工具更新，这使得我们可以在不卸载项目的情况下编辑
    `.csproj` 文件。这真是太棒了。只需在解决方案资源管理器中右键单击项目，然后点击 `Edit <Project Name>.csproj`：
- en: '![](img/fa59f1c0-179b-43b8-8c3e-521d18fdf703.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa59f1c0-179b-43b8-8c3e-521d18fdf703.png)'
- en: 'We will have the `.csproj` file opened as an XML file in the code editor, with
    the entire project still loaded. The following is the `.csproj` file code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码编辑器中将 `.csproj` 文件打开为 XML 文件，同时整个项目仍然加载。以下是 `.csproj` 文件代码：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's very lean, with just `TargetFramework`, which is `netcoreapp2.0`; `PackageReference`,
    which has just one metapackage, `Microsoft.AspNetCore.All`; and `DotNetCliToolReference`
    included as part of `ItemGroup`. This is much better than the conventional `.csproj`
    file, where we had different build configurations, property groups, all the projects,
    DLL, NuGet package references, and all the files and folders that need to be included
    in the project, making it really hard to manage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简洁，只包含`TargetFramework`，即`netcoreapp2.0`；`PackageReference`，只有一个元包`Microsoft.AspNetCore.All`；以及作为`ItemGroup`一部分的`DotNetCliToolReference`。这比传统的`.csproj`文件要好得多，在传统的`.csproj`文件中，我们有不同的构建配置、属性组、所有项目、DLL、NuGet包引用，以及需要包含在项目中的所有文件和文件夹，这使得管理变得非常困难。
- en: This concludes our basic anatomy of an ASP.NET Core 2.0 app. Let's get started
    with our game development in ASP.NET Core 2.0.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对ASP.NET Core 2.0应用程序基本结构的探讨。让我们开始使用ASP.NET Core 2.0进行游戏开发。
- en: Tic-Tac-Toe
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 井字棋
- en: Tic-Tac-Toe is a simple two-player game, traditionally with its marks as *X*
    and *O*. Each player places his/her mark in a space and alternate turns in a 3×3
    grid. The player who succeeds in placing three of their marks in a horizontal,
    vertical, or diagonal row wins the game.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋是一种简单的两人游戏，传统上使用*X*和*O*作为标记。每个玩家在自己的标记在空位上，并在3×3的网格中轮流进行。成功地将三个标记放置在水平、垂直或对角线上的一方获胜。
- en: 'This is what the pen and pencil game board looks like. In the following illustration,
    the player with the **X** marker is the winner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是笔和纸游戏板的样子。在下图 illustration 中，带有**X**标记的玩家是赢家：
- en: '![](img/7f525bff-8039-4463-aea2-65fbbb187873.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f525bff-8039-4463-aea2-65fbbb187873.png)'
- en: Requirement specifications
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求规范
- en: 'In this chapter, we will create a two-player Tic-Tac-Toe game with the following
    basic requirements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个具有以下基本要求的两人制井字棋游戏：
- en: As a player, I should be able to register with my name and display a picture
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为玩家，我应该能够用我的姓名注册并显示图片
- en: As a player, I should be able to find an opponent, that is, the second player
    to play against
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为玩家，我应该能够找到一个对手，即第二个要对抗的玩家
- en: The first two players to find opponents should be paired as opponents in the
    game
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先找到对手的前两名玩家应该被配对为游戏中的对手。
- en: The decision as to which player gets the chance to make the first move should
    be fair
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个玩家先走的机会应该是公平的。
- en: As a player, I should be able to use my display picture as my mark, rather than
    the conventional *X* and *O*
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为玩家，我应该能够使用我的显示图片作为我的标志，而不是传统的*X*和*O*。
- en: The decision as to who wins should be made fairly
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁赢的决定应该公平地做出。
- en: In future, we want multiple players playing online simultaneously
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在未来，我们希望有多个玩家同时在线游戏。
- en: 'Now that we have the requirement specifications in place, let''s see the activity
    flow of the game and come up with a flowchart. The following is a rough flowchart
    of the game workflow:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经制定了需求规范，让我们看看游戏的活动流程，并制定一个流程图。以下是对游戏工作流程的粗略流程图：
- en: '![](img/284e8ca3-199a-4d6f-90ae-7fc433220db8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/284e8ca3-199a-4d6f-90ae-7fc433220db8.png)'
- en: '**Start**: This is the start of the flow. The player browses the game site
    URL. It is being conceptualized as a site, since in future we want to allow multiple
    players to play simultaneously online (requirement *Step 7*)*.*'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始**：这是流程的开始。玩家浏览游戏网站的URL。它被构想为一个网站，因为未来我们希望允许多个玩家同时在线游戏（要求*步骤7*）。'
- en: '**Register with name and display picture**: The player registers himself/herself
    with a name and display picture (requirement *Step 1*).'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用姓名和显示图片注册**：玩家使用姓名和显示图片进行注册（要求*步骤1*）。'
- en: '**Is Opponent available?:** The player finds an opponent to play against. If
    an opponent is found, the game can start with a toss; otherwise, the player needs
    to wait for the opponent (requirement *Steps 2* and* 3*).'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对手是否可用？**：玩家找到一个对手进行游戏。如果找到对手，游戏可以开始投掷；否则，玩家需要等待对手（要求*步骤2*和*步骤3*）。'
- en: '**Wait for opponent**: There may be a scenario where the player is alone and
    registered with no one to play against, so the player needs to wait until another
    player registers and looks for an opponent (requirement *Steps 2* and *3*).'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待对手**：可能存在玩家独自注册但没有对手可玩的情况，因此玩家需要等待另一个玩家注册并寻找对手（要求*步骤2*和*步骤3*）。'
- en: '**Won toss?**: Once the players are paired as opponents, the game starts and
    one of the players gets the opportunity to make the first move. To keep this fair,
    we will have a toss. The player may either win the toss or lose the toss (requirement
    *Step 4*).'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**赢得投币吗？**：一旦玩家被配对为对手，游戏开始，其中一名玩家将有机会先走一步。为了保持公平，我们将进行投币。玩家可能赢得投币或输掉投币（要求*步骤
    4*）。'
- en: '**Make a move/Wait for opponent to make a move**: The player winning the toss
    gets the first move, while their opponent would waits for the first player to
    make their move.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**移动/等待对手移动**：赢得投币的玩家先走一步，而他们的对手将等待第一个玩家移动。'
- en: '**Do we have a winner?**: After every move, we check whether the win/draw criteria
    have been met and check whether we have a winner. If not, then the game continues
    with each player moving alternately until the game ends (requirement *Step 6*).'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们有胜者吗？**：每次移动后，我们检查是否满足胜利/平局的条件，并检查是否有胜者。如果没有，则游戏继续，每位玩家轮流移动，直到游戏结束（要求*步骤
    6*）。'
- en: '**Game Over**: Finally, the players will either run out of moves or a player
    will win the game.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**游戏结束**：最后，玩家要么用完移动，要么有玩家赢得游戏。'
- en: As we can see, the game will be played only in *Steps 6* and *7* of the flowchart.
    The other steps are required only for setting up the game. Also, notice that this
    flow covers all our requirements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，游戏只会在流程图的*步骤 6*和*步骤 7*中进行。其他步骤仅用于设置游戏。此外，请注意，这个流程涵盖了我们的所有要求。
- en: Designing the game
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计游戏
- en: 'Looking at the preceding flow chart, which meets our requirements, we know
    we need to develop the following in the ASP.NET Core 2.0 application to constitute
    a basic two-player Tic-Tac-Toe game:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的流程图，它符合我们的要求，我们知道我们需要在 ASP.NET Core 2.0 应用程序中开发以下内容，以构成一个基本的两人井字棋游戏：
- en: A web page where players can go and register themselves with their name and
    display a picture
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个玩家可以注册并显示他们姓名和图片的网页
- en: A module to find an opponent to play against
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个模块，用于找到对手进行游戏
- en: A module to simulate a coin toss to ensure fairness in giving players the option
    of making the first move
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个模块，用于模拟投币来确保在给予玩家先走一步的机会时保持公平
- en: The UI for the Tic-Tac-Toe game board in the web page, that is, a 3×3 grid where
    players can place their image
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网页上井字棋游戏界面的UI，即一个3×3的网格，玩家可以在其中放置他们的图像
- en: Logic to indicate to the player whether it's their turn or the opponent's turn
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑指示玩家是轮到他们还是对手
- en: A module to show the opponent and player the move that was made
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个模块，用于向对手和玩家展示所进行的移动
- en: A mechanism to ensure that the player and opponent's board are in sync with
    their moves
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保玩家和对手的棋盘与他们的移动同步的机制
- en: Logic to check whether the game is over
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查游戏是否结束的逻辑
- en: Logic to determine the winner
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定胜者的逻辑
- en: 'Sounds simple enough! Let''s see how we can design and implement each of the
    preceding points by using ASP.NET Core 2.0 goodness:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单！让我们看看我们如何利用 ASP.NET Core 2.0 的优点设计和实现上述每个点：
- en: '**Web page for registration:** We have multiple options available to code this.
    We can either use a static HTML page, or a regular `.cshtml` view of MVC, or the
    new Razor Pages introduced by ASP.NET Core 2.0\. Since we will be working extensively
    with Razor Pages in the next chapter, we will use the `.cshtml` Razor view to
    create the UI of the game.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注册网页**：我们有多种选项可供选择。我们可以使用静态HTML页面，或者MVC的常规`.cshtml`视图，或者ASP.NET Core 2.0引入的新Razor
    Pages。由于我们将在下一章中广泛使用Razor Pages，我们将使用`.cshtml` Razor视图来创建游戏的UI。'
- en: '**Opponent-finding module:** When a player registers, we can store his details
    somewhere on the server so the server knows how many players are registered to
    play. When a player finds an opponent, we can pair them as opponents based on
    their registration time. The problem with just relying on registered users, though,
    is when a player registers and closes the browser window knowingly or unknowingly,
    or decides not to play the game after registering. So, we need to ensure that
    we pair up only those players who are registered, are actively connected to the
    server, and are looking for an opponent to play the game with. If a player disconnects
    in the middle of the game, award the game to the opponent and inform them that
    the opponent has disconnected. We will need to do additional housekeeping to refresh
    the registered players in the server as new players join and existing players
    disconnect. To check whether a user is connected or not, we may need to perform
    additional housekeeping by writing additional code or making use of sessions.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**寻找对手的模块：** 当玩家注册时，我们可以在服务器上的某个地方存储他的详细信息，以便服务器知道有多少玩家注册来玩游戏。当玩家找到一个对手时，我们可以根据他们的注册时间将他们配对为对手。然而，仅仅依赖注册用户的问题在于，当玩家注册后有意或无意地关闭浏览器窗口，或者注册后决定不玩游戏。因此，我们需要确保我们只配对那些注册、积极连接到服务器并且正在寻找对手一起游戏的玩家。如果玩家在游戏中断开连接，则将游戏判给对手，并通知他们对手已经断开连接。我们需要进行额外的维护工作来刷新服务器上的注册玩家，因为新玩家加入而现有玩家断开连接。为了检查用户是否连接，我们可能需要通过编写额外的代码或使用会话来执行额外的维护工作。'
- en: '**Simulate coin toss:** There are many ways to simulate a coin toss, such as
    generating a random number between two numbers and seeing whether it''s even or
    odd. In our case, to keep things simple, we will generate a random number, either
    `0` or `1`. If it''s `0`, it''s heads; otherwise, it''s tails.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟抛硬币：** 模拟抛硬币的方法有很多，例如在两个数字之间生成随机数，看它是偶数还是奇数。在我们的情况下，为了使事情简单，我们将生成一个随机数，要么是`0`，要么是`1`。如果是`0`，则是正面；否则，是反面。'
- en: '**UI for game board:** As already discussed, we will be using the standard
    MVC Razor view to create the registration form as well as the Tic-Tac-Toe game
    board user interface. Designing the game board for Tic-Tac-Toe is rather simple
    with CSS; we just need to get the correct box style and arrange the boxes in a
    3×3 grid. To place the player''s image on the board, we pass the player image
    to each of the players and update the box background style to the image when the
    user clicks on that grid box. The challenge we can see here is how we will keep
    the game board of both the players in sync at any given time. Although the individual
    player and server know which player has a marker placed at which position, the
    opponent needs to have the same picture of the game board. This is something that
    the server needs to inform both players of after every turn.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**游戏棋盘的UI设计：** 如前所述，我们将使用标准的MVC Razor视图来创建注册表单以及井字棋游戏棋盘的用户界面。使用CSS设计井字棋的棋盘相对简单；我们只需要获取正确的框样式并将框排列成3x3的网格。为了在棋盘上放置玩家的图像，我们将玩家图像传递给每位玩家，并在用户点击该网格框时更新框的背景样式。我们在这里可以看到的挑战是如何在任何给定时间保持两位玩家棋盘的同步。尽管单个玩家和服务器知道哪个玩家在哪个位置放置了标记，但对手需要拥有相同的游戏棋盘图片。这是服务器需要在每一回合之后通知两位玩家的内容。'
- en: '**Logic to indicate whose turn it is:** Although the server knows the toss
    result, it needs to inform one player to make a move and the other to wait for
    the other player to make a move. And after each turn, the server needs to inform
    both players (clients) about the turn, so the server has to push data to the clients
    after every move.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指示轮到谁的逻辑：** 虽然服务器知道投掷结果，但它需要通知一位玩家进行移动，而另一位玩家则需要等待其他玩家移动。在每一回合之后，服务器还需要通知两位玩家（客户端）关于轮次的信息，因此服务器必须在每次移动后向客户端推送数据。'
- en: '**Module to show the players the move that was made:** Like the preceding point,
    it is again the server''s responsibility to update the players about the last
    move and ensure both players have a game board view after each move.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显示玩家所做移动的模块：** 就像前面的点一样，这也是服务器的责任，更新玩家关于最后一步的信息，并确保在每次移动后两位玩家都有游戏棋盘视图。'
- en: The last two modules are straightforward. We need to check whether the game
    is over and we have a winner. The interesting part of our discussion is that in
    *Steps 2*, *4*, *5*, and *6*, we came across scenarios where the server needs
    to push data to the client. This is something that has already been made incredibly
    easy by the ASP.NET team who developed a library called SignalR. So, we will use
    SignalR to cover these scenarios. Before we dive into coding, let's understand
    what SignalR is, how it works, and how it saves us from writing all this stuff
    ourselves.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个模块很简单。我们需要检查游戏是否结束，是否有胜者。我们讨论的有趣部分在于，在*步骤2*、*4*、*5*和*6*中，我们遇到了服务器需要向客户端推送数据的情况。这是ASP.NET团队通过开发名为SignalR的库已经使事情变得非常简单的事情。因此，我们将使用SignalR来覆盖这些场景。在我们开始编码之前，让我们了解SignalR是什么，它是如何工作的，以及它是如何帮助我们避免自己编写所有这些内容的。
- en: SignalR
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SignalR
- en: SignalR is a library for ASP.NET developers for developing real-time web experiences.
    In traditional web applications, the client makes requests and the server responds.
    With SignalR, we have the ability to push the content from the  server to the
    connected clients in real time. SignalR provides a simple API for creating server-to-client
    remote procedure calls that call JavaScript functions in client browsers (and
    other client platforms) from server-side .NET code. Anywhere in an application,
    if we need to refresh the browser for fresh data or have polling code wriiten
    to refresh the data, SignalR may be a good candidate for this. Some real-world
    applications of SignalR are chat applications where multiple users can chat, dashboards
    for monitoring, stock ticker applications that update a stock price as and when
    it changes, and multiplayer games. Basically, for any app that needs to display
    live data, SignalR makes it incredibly simple to broadcast a message to all clients,
    a group of clients, or a specific client as needed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR是一个为ASP.NET开发者提供的库，用于开发实时网络体验。在传统的网络应用程序中，客户端发起请求，服务器做出响应。使用SignalR，我们能够实时地将内容从服务器推送到已连接的客户端。SignalR提供了一个简单的API，用于创建从服务器到客户端的远程过程调用，这些调用从服务器端的.NET代码调用客户端浏览器（和其他客户端平台）中的JavaScript函数。在任何应用程序中，如果我们需要刷新浏览器以获取新鲜数据或编写轮询代码来刷新数据，SignalR可能是一个不错的选择。SignalR的一些实际应用包括聊天应用程序，其中多个用户可以进行聊天，监控仪表板，股票行情应用程序，它会根据股票价格的变化更新股票价格，以及多人游戏。基本上，对于任何需要显示实时数据的应用程序，SignalR使向所有客户端、一组客户端或特定客户端广播消息变得极其简单。
- en: SignalR transport mechanisms
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SignalR传输机制
- en: 'SignalR connects through WebSockets, Server-Sent Events, Forever Frames, and
    long polling. The following is a short description of each of these transport
    mechanisms:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR通过WebSockets、服务器发送事件、永久帧和长轮询进行连接。以下是这些传输机制各自的简要描述：
- en: '**WebSockets**: WebSockets is an advanced computer communication protocol that
    enables you to open an interactive communication session between the user''s browser
    and a server with a lower overhead. With the advent of HTML5, WebSockets is supported
    by the latest version of all major browsers, such as Microsoft Edge, Microsoft
    Internet Explorer, Google Chrome, Firefox, Safari, and Opera. With WebSockets,
    we can send messages to a server and receive event-driven responses without having
    to poll the server for a reply. This is full-duplex communication.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSockets**：WebSockets是一种高级计算机通信协议，它允许您以更低的开销在用户的浏览器和服务器之间打开一个交互式通信会话。随着HTML5的出现，所有主要浏览器的最新版本都支持WebSockets，例如Microsoft
    Edge、Microsoft Internet Explorer、Google Chrome、Firefox、Safari和Opera。使用WebSockets，我们可以向服务器发送消息并接收事件驱动的响应，而无需轮询服务器以获取回复。这是一种全双工通信。'
- en: '**Server-Sent Eevents**: Server-Sent Events are a technology that enables web
    pages to receive automatic updates from the server through a HTTP connection.
    The server can initiate the data transmission toward a client after an initial
    connection has been established. This is not supported by the current version
    of Microsoft Edge and Microsoft Internet Explorer, but is available in Google
    Chrome, Mozilla Firefox, Safari, Opera, and others. This is simplex communication,
    as the server pushes the data to the client. This is part of the HTML5 specification.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器发送事件**：服务器发送事件是一种技术，它允许网页通过HTTP连接从服务器接收自动更新。在建立初始连接后，服务器可以启动向客户端的数据传输。当前版本的Microsoft
    Edge和Microsoft Internet Explorer不支持此功能，但在Google Chrome、Mozilla Firefox、Safari、Opera和其他浏览器中可用。这是一种单工通信，因为服务器将数据推送到客户端。这是HTML5规范的一部分。'
- en: '**Forever Frame**: Forever Frame is a Microsoft Internet Explorer concept and
    is not supported by any other browser. When a connection is established between
    a client web page and a server through Forever Frame, it creates a hidden IFrame
    in the client page. This IFrame makes a request to the server endpoint, which
    never completes; that is, it keeps the connection alive forever (hence the name,
    Forever Frame). Since the connection remains open, the server can use this connection
    to push scripts to the client, which are loaded and executed immediately in the
    client page, thus providing a real-time one-way communication from the server
    to the client. This is supported in old SignalR but removed from SignalR Core.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久帧**：永久帧是微软 Internet Explorer 的一个概念，并且不被任何其他浏览器支持。当客户端网页和服务器通过永久帧建立连接时，它会在客户端页面中创建一个隐藏的
    IFrame。这个 IFrame 向服务器端点发出请求，该请求永远不会完成；也就是说，它永远保持连接活跃（因此得名，永久帧）。由于连接保持打开，服务器可以使用这个连接向客户端推送脚本，这些脚本在客户端页面中被加载并立即执行，从而提供从服务器到客户端的实时单向通信。这在旧的
    SignalR 中得到支持，但在 SignalR Core 中被移除。'
- en: '**Long polling**: Long polling is something that most web developers do in
    their regular web development without realizing it is actually long polling. Long
    polling does not create a persistent connection, but instead polls the server
    with a request that stays open until the server responds. This may introduce some
    latency while the connection resets. Long polling is basically an approach used
    for backward compatibility with old browsers and is definitely not a preferred
    method for client-server communication for the modern web.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长轮询**：长轮询是大多数网页开发者在其常规网页开发中做的事情，而没有意识到它实际上是长轮询。长轮询不会创建一个持久连接，而是通过一个保持打开直到服务器响应的请求来轮询服务器。这可能会在连接重置时引入一些延迟。长轮询基本上是一种用于与旧浏览器的向后兼容的方法，绝对不是现代网络客户端-服务器通信的首选方法。'
- en: SignalR Core
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SignalR Core
- en: SignalR Core is the complete rewrite of SignalR for ASP.NET Core 2.0 and, at
    the time of writing this chapter, is available as an alpha release for ASP.NET
    Core 2.0\. As per the road-map, it is scheduled to be released in the fourth quarter
    of 2017 and will be shipped with ASP.NET Core 2.1\. The current alpha release
    consists of a server component, .NET client, and JavaScript/TypeScript client.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR Core 是为 ASP.NET Core 2.0 完全重写的 SignalR，在撰写本章时，它作为 ASP.NET Core 2.0 的
    alpha 版本提供。根据路线图，它计划在 2017 年第四季度发布，并将与 ASP.NET Core 2.1 一起发布。当前的 alpha 版本包括服务器组件、.NET
    客户端和 JavaScript/TypeScript 客户端。
- en: We will be using SignalR Core for our game development as it will take care
    of all the heavy duty stuff needed to push the content from the server to the
    client and let us concentrate on the problem at hand. With the ASP.NET Core 2.0
    and SignalR Core basics in place, and the design and approach finalized, let's
    get started with our implementation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SignalR Core 进行游戏开发，因为它将处理从服务器向客户端推送内容所需的所有繁重任务，让我们专注于手头的问题。有了 ASP.NET
    Core 2.0 和 SignalR Core 基础，以及设计和方法的最终确定，让我们开始我们的实现。
- en: Solution
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: In this section, we will develop the Tic-Tac-Toe game in the ASP.NET Core 2.0
    web app, using SignalR Core. We will follow a step-by-step approach and use Visual
    Studio 2017 as the primary IDE, but will list the steps needed while using the
    Visual Studio Code editor as well. Let's do the project setup first and then we
    will dive into the coding.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在 ASP.NET Core 2.0 网页应用程序中开发井字棋游戏，使用 SignalR Core。我们将遵循逐步方法，并使用 Visual
    Studio 2017 作为主要 IDE，但也会列出使用 Visual Studio Code 编辑器所需的步骤。让我们先进行项目设置，然后我们将深入编码。
- en: Project setup
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Create a new ASP.NET Core 2.0 MVC app named `TicTacToeGame`, like we did in
    the *Creating a simple running code* section in [Chapter 1](ch01.html), *Getting
    Started*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `TicTacToeGame` 的新 ASP.NET Core 2.0 MVC 应用程序，就像我们在 [第 1 章](ch01.html)
    的 *创建简单运行代码* 部分中所做的那样。
- en: With this, we will have a basic working ASP.NET Core 2.0 MVC app in place. However,
    to leverage SignalR Core in our app, we need to install SignalR Core NuGet and
    the client packages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们将有一个基本的 ASP.NET Core 2.0 MVC 应用程序。然而，为了在我们的应用程序中利用 SignalR Core，我们需要安装
    SignalR Core NuGet 和客户端包。
- en: 'To install the SignalR Core NuGet package, we can perform one of the following
    two approaches in the Visual Studio IDE:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 SignalR Core NuGet 包，我们可以在 Visual Studio IDE 中执行以下两种方法之一：
- en: 'In the context menu of the `TicTacToeGame` project, click on Manage NuGet Packages.
    It will open the NuGet Package Manager for the project. In the Browse section,
    search for the `Microsoft.AspNetCore.SignalR` package and click Install. This
    will install SignalR Core in the app. Please note that currently the package is
    in the preview stage and hence the pre-release checkbox has to be ticked:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`TicTacToeGame`项目的上下文菜单中，点击管理NuGet包。它将为项目打开NuGet包管理器。在浏览部分，搜索`Microsoft.AspNetCore.SignalR`包，然后点击安装。这将安装SignalR
    Core到应用中。请注意，目前该包处于预览阶段，因此需要勾选预发布复选框：
- en: '![](img/6a1ddd74-b570-4f6f-a64d-14735f0b2743.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a1ddd74-b570-4f6f-a64d-14735f0b2743.png)'
- en: 'Edit the `TicTacToeGame.csproj` file, add the following code snippet in the
    `ItemGroup` code containing package references, and click Save. As soon as the
    file is saved, the tooling will take care of restoring the packages and in a while,
    the SignalR package will be installed. This approach can be used with Visual Studio
    Code as well. Although Visual Studio Code detects the unresolved dependencies
    and may prompt you to restore the package, it is recommended that immediately
    after editing and saving the file, you run the `dotnet restore` command in the
    terminal window at the location of the project:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`TicTacToeGame.csproj`文件，在包含包引用的`ItemGroup`代码中添加以下代码片段，然后点击保存。文件保存后，工具将负责恢复包，不久SignalR包将被安装。此方法也可以用于Visual
    Studio Code。尽管Visual Studio Code会检测未解决的依赖项并可能提示您恢复包，但建议在编辑并保存文件后，在项目位置的终端窗口中运行`dotnet
    restore`命令：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have server-side packages installed. We still need to install the client-side
    package of SignalR, which is available through npm. To do so, we need to first
    ascertain whether we have npm installed on the machine or not. If not, we need
    to install it. npm is distributed with Node.js, so we need to download and install
    Node.js from [https://nodejs.org/en/](https://nodejs.org/en/). The installation
    is quite straightforward.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了服务器端包。我们还需要安装SignalR的客户端包，它可以通过npm获取。为此，我们首先需要确认机器上是否已安装npm。如果没有，我们需要安装它。npm与Node.js一起分发，因此我们需要从[https://nodejs.org/en/](https://nodejs.org/en/)下载并安装Node.js。安装过程相当简单。
- en: 'Once this installation is done, open a Command Prompt at the project location
    and run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，在项目位置打开命令提示符并运行以下命令：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will install the SignalR client package. Just go to the package location
    (npm creates a `node_modules` folder in the project directory). The relative path
    from the project directory would be `\node_modules\@aspnet\signalr-client\dist\browser`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装SignalR客户端包。只需转到包位置（npm在项目目录中创建一个`node_modules`文件夹）。从项目目录的相对路径将是`\node_modules\@aspnet\signalr-client\dist\browser`。
- en: From this location, copy the `signalr-client-1.0.0-alpha1-final.js` file into
    the `wwwroot\js` folder. In the current version, the name is `signalr-client-1.0.0-alpha1-final.js`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从此位置，将`signalr-client-1.0.0-alpha1-final.js`文件复制到`wwwroot\js`文件夹。在当前版本中，文件名为`signalr-client-1.0.0-alpha1-final.js`。
- en: With this, we are done with the project setup and we are ready to use SignalR
    goodness as well. So let's dive into the coding.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们就完成了项目的设置，现在我们可以使用SignalR的优势了。那么，让我们开始编码吧。
- en: Coding the game
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写游戏代码
- en: 'In this section, we will implement our gaming solution. The end output will
    be the working two-player Tic-Tac-Toe game. We will do the coding in steps for
    ease of understanding:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们的游戏解决方案。最终输出将是一个可工作的两人井字棋游戏。我们将分步骤进行编码，以便于理解：
- en: 'In the `Startup` class, we modify the `ConfigureServices` method to add SignalR
    to the container, by writing the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup`类中，我们修改`ConfigureServices`方法，将SignalR添加到容器中，代码如下：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `Configure` method of the same class, we configure the pipeline to use
    SignalR and intercept and wire up the request containing `gameHub` to our SignalR
    hub that we will be creating with the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一类的`Configure`方法中，我们配置管道以使用SignalR，并拦截并连接包含`gameHub`的请求到我们将要创建的SignalR中心，代码如下：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the code for both methods, for the sake of clarity and completion.
    Other methods and properties are removed for brevity:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为两种方法的代码，为了清晰和完整，其他方法和属性已被省略：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous two steps set up SignalR for us. Now, let''s start with the coding
    of the player registration form. We want the player to be registered with a name
    and display the picture. Later, the server will also need to know whether the
    player is playing, waiting for a move, searching for an opponent, and so on. Let''s
    create the `Player` model in the `Models` folder in the app. The code comments
    are self-explanatory:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前两个步骤为我们设置了 SignalR。现在，让我们开始编写玩家注册表单的代码。我们希望玩家通过姓名和显示图片进行注册。稍后，服务器还需要知道玩家是否在玩游戏、等待移动、寻找对手等。让我们在应用中的
    `Models` 文件夹中创建 `Player` 模型。代码注释是自解释的：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we need to have a UI in place so that the player can fill in the form
    and register. We also need to show the image preview to the player when he/she
    browses the image. To do so, we will use the `Index.cshtml` view of the `HomeController` class
    that comes with the default MVC template. We will refer to the following two `.js`
    files in the `_Layout.cshtml` partial view so that they are available to all the
    views. Alternatively, you could add these in the `Index.cshtml` view as well,
    but its highly recommended that common scripts should be added in `_Layout.cshtml`.
    The version of the script file may be different in your case. These are the currently
    available latest versions. Although jQuery is not required to be the library of
    choice for us, we will use jQuery to keep the code clean, simple, and compact.
    With these references, we have jQuery and SignalR available to us on the client
    side:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要设置一个用户界面，以便玩家可以填写表格并注册。我们还需要在玩家浏览图片时显示图片预览。为此，我们将使用默认 MVC 模板中包含的 `HomeController`
    类的 `Index.cshtml` 视图。我们将在 `_Layout.cshtml` 部分视图中引用以下两个 `.js` 文件，以便它们对所有视图都可用。或者，你也可以在
    `Index.cshtml` 视图中添加这些文件，但强烈建议将常用脚本添加到 `_Layout.cshtml` 中。脚本文件的版本可能因情况而异。这些是目前可用的最新版本。虽然
    jQuery 不是我们必须选择的库，但我们将使用 jQuery 来保持代码的简洁、简单和紧凑。有了这些引用，我们可以在客户端使用 jQuery 和 SignalR：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After adding these references, create the simple HTML UI for the image preview
    and registration, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些引用后，创建简单的 HTML UI 以进行图片预览和注册，如下所示：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the player registers by clicking the `Register` button, the player''s
    details need to be sent to the server. To do this, we will write the JavaScript
    to send details to our `gameHub`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家通过点击 `Register` 按钮进行注册时，需要将玩家的详细信息发送到服务器。为此，我们将编写 JavaScript 代码将详细信息发送到我们的
    `gameHub`：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The player now has a UI to input the name and image, see the preview image,
    and click `Register`. On clicking the `Register` button, we are sending the concatenated
    name and image to the `gameHub` on the server through `hubConnection.invoke(''RegisterPlayer'',
    data);`  So, it''s quite simple for the client to make a call to the server. Initialize
    the `hubConnection` by specifying hub name as we did in the first three lines
    of the preceding code snippet. Start the connection by `hubConnection.start();`,
    and then invoke the server hub method by calling the `invoke` method, specifying
    the hub method name and the parameter it expects. We have not yet created the
    hub, so let''s create the `GameHub` class on the server:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在玩家有一个用户界面来输入姓名和图片，查看预览图片，并点击 `Register`。点击 `Register` 按钮时，我们通过 `hubConnection.invoke('RegisterPlayer',
    data);` 将连接名和图片发送到服务器上的 `gameHub`。因此，客户端调用服务器非常简单。通过指定连接名来初始化 `hubConnection`，就像前面代码片段的前三行所做的那样。通过调用
    `hubConnection.start();` 来启动连接，然后通过调用 `invoke` 方法并指定连接方法名和它期望的参数来调用服务器端端点方法。我们尚未创建端点，因此让我们在服务器上创建
    `GameHub` 类：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code comments make it self-explanatory. The class should derive from the
    SignalR `Hub` class for it to be recognized as `Hub.`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注释使代码自解释。该类应该从 SignalR 的 `Hub` 类派生，以便它被识别为 `Hub`。
- en: 'There are two methods of interest which can be overridden. Notice that both
    the methods follow the async pattern and hence return `Task`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种感兴趣的方法可以被覆盖。请注意，这两种方法都遵循异步模式，因此返回 `Task`：
- en: '`Task OnConnectedAsync()`: This method fires when a client/player connects
    to the hub.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task OnConnectedAsync()`: 当客户端/玩家连接到端点时，此方法会触发。'
- en: '`Task OnDisconnectedAsync(Exception exception)`: This method fires when a client/player
    disconnects or looses the connection. We will override this method to handle the
    scenario where the player disconnects.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task OnDisconnectedAsync(Exception exception)`: 当客户端/玩家断开连接或失去连接时，此方法会触发。我们将覆盖此方法来处理玩家断开连接的情况。'
- en: 'There are also a few properties that the hub class exposes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 端点类还公开了一些属性：
- en: '`Context`: This property is of type `HubCallerContext` and gives us access
    to the following properties:'
  id: totrans-173
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context`：这个属性是`HubCallerContext`类型，为我们提供了访问以下属性的方式：'
- en: '`Connection`: Gives access to the current connection'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection`：提供对当前连接的访问'
- en: '`User`: Gives access to the `ClaimsPrincipal` of the user who is currently
    connected'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：提供对当前连接用户的`ClaimsPrincipal`的访问'
- en: '`ConnectionId`: Gives the current connection ID string'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionId`：提供当前连接ID字符串'
- en: '`Clients`: This property is of type `IHubClients` and gives us the way to communicate
    to all the clients via the client proxy'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clients`：这个属性是`IHubClients`类型，为我们提供了通过客户端代理与所有客户端通信的方式'
- en: '`Groups`: This property is of type `IGroupManager` and provides a way to add
    and remove connections to the group asynchronously'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Groups`：这个属性是`IGroupManager`类型，提供了一种异步添加和删除连接到组的方法'
- en: To keep the things simple, we are not using a database to keep track of our
    registered players. Rather we will use an in-memory collection to keep the registered
    players. We could have used a normal list of players, such as `List<Player>`,
    but then we would need all the thread safety and use one of the thread safety
    primitives, such as `lock`, `monitor`, and so on, so we are going with `ConcurrentBag<Player>`,
    which is thread safe and reasonable for our game development. That explains the
    declaration of the players collection in the class. We will need to do some housekeeping
    to add players to this collection when they resister and remove them when they
    disconnect.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们不会使用数据库来跟踪已注册的玩家。相反，我们将使用内存中的集合来存储已注册的玩家。我们本可以使用普通的玩家列表，例如`List<Player>`，但那样我们就需要所有线程安全，并使用线程安全原语，如`lock`、`monitor`等，所以我们选择了`ConcurrentBag<Player>`，它是线程安全的，并且适合我们的游戏开发。这解释了在类中对玩家集合的声明。当玩家注册时，我们需要将玩家添加到这个集合中，当它们断开连接时，我们需要从集合中删除它们。
- en: 'We saw in previous step that the client invoked the `RegisterPlayer` method
    of the hub on the server, passing in the name and image data. So we defined a
    `public` method in our hub, named `RegisterPlayer,` accepting the name and image
    data string concatenated through `#`. This is just one of the simple ways of accepting
    the client data for demonstration purposes, we can also use strongly typed parameters.
    In this method, we split the string on `#` and extract the name as the first part
    and the image as the second part. We then check if the player with the current
    connection ID already exists in our players collection. If it doesn''t, we create
    a `Player` object with default values and add them to our players collection.
    We are distinguishing the player based on the name for demonstration purposes,
    but we can add an `Id` property in the `Player` class and make different players
    have the same name also. After the registration is complete, the server needs
    to update the player, that the registration is complete and the player can then
    look for the opponent. To do so, we make a call to the `OnRegistrationComplete`
    method which invokes a method called  `registrationComplete` on the client with
    the current connection ID. Let''s understand the code to invoke the method on
    the client:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中，我们看到了客户端在服务器上调用了`RegisterPlayer`方法，并传递了名称和图像数据。因此，我们在我们的中心类中定义了一个`public`方法，命名为`RegisterPlayer`，接受通过`#`连接的名称和图像数据字符串。这只是接受客户端数据的一种简单方式，用于演示目的，我们也可以使用强类型参数。在这个方法中，我们在`#`上拆分字符串，提取名称作为第一部分，图像作为第二部分。然后我们检查具有当前连接ID的玩家是否已经存在于我们的玩家集合中。如果没有，我们创建一个具有默认值的`Player`对象并将其添加到我们的玩家集合中。为了演示目的，我们根据名称区分玩家，但我们可以向`Player`类中添加一个`Id`属性，使不同玩家也可以有相同的名称。注册完成后，服务器需要更新玩家信息，表明注册已完成，然后玩家可以寻找对手。为此，我们调用`OnRegistrationComplete`方法，该方法在客户端上调用名为`registrationComplete`的方法，并传递当前连接ID。让我们理解调用客户端上方法的代码：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On the `Clients` property, we can choose a client having a specific connection
    ID (in this case, the current connection ID from the `Context`) and then call
    `InvokeAsync` to invoke a method on the client specifying the method name and
    parameters as required. In the preceding case method, the name is `registrationComplete`
    with no parameters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Clients`属性上，我们可以选择具有特定连接ID的客户端（在这种情况下，来自`Context`的当前连接ID），然后调用`InvokeAsync`来在客户端上调用方法，指定所需的方法名称和参数。在前面的例子中，方法名称是`registrationComplete`，没有参数。
- en: Now we know how to invoke a server method from the client and also how to invoke
    the client method from the server. We also know how to select a specific client
    and invoke a method there. We can invoke the client method from the server, for
    all the clients, a group of clients, or a specific client, so rest of the coding
    stuff would be just a repetition of these two concepts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从客户端调用服务器方法，以及如何从服务器调用客户端方法。我们还知道如何选择特定的客户端并调用那里的方法。我们可以从服务器调用客户端方法，对所有客户端、一组客户端或特定客户端，所以其余的编码内容只是这两个概念的重复。
- en: Next, we need to implement the `registrationComplete` method on the client.
    On registration completion, the registration form should be hidden and the player
    should be able to find an opponent to play against. To do so, we would write JavaScript
    code to hide the registration form and show the UI for finding the opponent. On
    clicking the `Find Opponent` button, we need the server to pair us against an
    opponent, so we need to invoke a hub method on server to find opponent.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在客户端实现`registrationComplete`方法。在注册完成后，注册表单应该被隐藏，玩家应该能够找到对手进行比赛。为此，我们将编写JavaScript代码来隐藏注册表单并显示查找对手的用户界面。点击`查找对手`按钮时，我们需要服务器为我们匹配对手，因此我们需要在服务器上调用中心方法来查找对手。
- en: 'The server can respond us with two outcomes:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器可以给我们两种结果：
- en: It finds an opponent player to play against. In this case, the game can start
    so we need to simulate the coin toss, determine the player who can make the first
    move, and start the game. This would be a game board in the client-user interface.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它找到了一个对手玩家进行比赛。在这种情况下，游戏可以开始，因此我们需要模拟抛硬币，确定哪个玩家可以首先移动，并开始游戏。这将在客户端用户界面中显示为游戏板。
- en: It doesn't find an opponent and asks the player to wait for another player to
    register and search for an opponent. This would be a no opponent found screen
    in the client.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它找不到对手，并要求玩家等待另一个玩家注册并寻找对手。这将在客户端显示为找不到对手的屏幕。
- en: 'In both the cases, the server would do some processing and invoke a method
    on the client. Since we need a lot of different user interfaces for different
    scenarios, let''s code the HTML markup inside `div` to make it easier to show
    and hide sections based on the server response. We will add the following code
    snippet in the body. The comments specify the purpose of each of the `div` elements
    and markup inside them:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，服务器都会进行一些处理并在客户端调用一个方法。由于我们需要为不同的情况创建很多不同的用户界面，让我们在`div`内部编写HTML标记，以便根据服务器响应更容易地显示和隐藏部分。我们将在主体中添加以下代码片段。注释指定了每个`div`元素及其内部标记的目的：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following client-side code would take care of *Steps 7* and *8*. Though
    the comments are self-explanatory, we will quickly see what all stuff is that
    is going on here. We handle the `registartionComplete` method and display the
    `Find Opponent Player` section. This section has a button to find an opponent
    player called `btnFindOpponentPlayer`. We define the event handler of the button
    to invoke the `FindOpponent` method on the hub. We will see the hub method implementation
    later, but we know that the hub method would either find an opponent or would
    not find an opponent, so we have defined the methods `opponentFound` and `opponentNotFound`,
    respectively, to handle these scenarios. In the `opponentNotFound` method, we
    just display a section in which we say, we do not have an opponent player. In
    the `opponentFound` method, we display the game section, game information section,
    opponent display picture section, and draw the Tic-Tac-Toe game board as a 3×3
    grid using CSS styling. All the other sections are hidden:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下客户端代码将处理**步骤 7**和**步骤 8**。尽管注释已经很直观，但我们会快速查看这里正在进行的所有内容。我们处理`registartionComplete`方法并显示`查找对手玩家`部分。这部分有一个名为`btnFindOpponentPlayer`的按钮用于查找对手玩家。我们定义按钮的事件处理器来在中心调用`FindOpponent`方法。我们稍后会看到中心方法的实现，但我们知道中心方法要么找到对手，要么找不到对手，因此我们分别定义了`opponentFound`和`opponentNotFound`方法来处理这些情况。在`opponentNotFound`方法中，我们只显示一个部分，其中我们说我们没有找到对手玩家。在`opponentFound`方法中，我们显示游戏部分、游戏信息部分、对手显示图片部分，并使用CSS样式绘制一个3×3的井字棋游戏板。所有其他部分都被隐藏：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First we need to have a `Game` object to track a game, players involved, moves
    left, and check if there is a winner. We will have a `Game` class defined as per
    the following code. The comments detail the purpose of the methods and the properties
    defined:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`Game`对象来跟踪游戏、涉及的玩家、剩余的移动以及检查是否有获胜者。我们将根据以下代码定义一个`Game`类。注释详细说明了方法和定义的属性的目的：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we have the entire game mystery solved with the `Game` class. We know when
    the game is over, we have the method to place the player marker, and check the
    winner. The following server side-code on the `GameHub` will handle *Steps 7*
    and *8*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用`Game`类解决了整个游戏谜题。我们知道何时游戏结束，我们有放置玩家标记和检查获胜者的方法。以下在`GameHub`上的服务器端代码将处理*步骤7*和*步骤8*：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have created a games collection to keep track of ongoing games and
    a `Random` field named toss to simulate the coin toss. How `FindOpponent` works
    is documented in the comments and is intuitive to understand.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个游戏集合来跟踪正在进行的游戏，并添加了一个名为`Random`的字段来模拟抛硬币。`FindOpponent`的工作原理在注释中有详细说明，并且很容易理解。
- en: 'Once the game starts, each player has to make a move and then wait for the
    opponent to make a move, until the game ends. The move is made by clicking on
    the available grid cells. Here, we need to ensure that cell position that is already
    marked by one of the players is not changed or marked. So, as soon as a valid
    cell is marked, we set its CSS class to `notAvailable` so we know that the cell
    is taken. While clicking on a cell, we will check whether the cell has `notAvailablestyle`.
    If yes, it cannot be marked. If not, the cell can be marked and we then send the
    marked position to the server hub. We also see the `waitingForMove`, `moveMade`,
    `gameOver`, and `opponentDisconnected` events invoked by the server based on the
    game state. The code is commented and is pretty straightforward. The `moveMade`
    method in the following code makes use of the `MoveInformation` class, which we
    will define at the server for sharing move information with both players:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏开始后，每位玩家必须进行一次移动，然后等待对手进行移动，直到游戏结束。移动是通过点击可用的网格单元格来完成的。在这里，我们需要确保已被玩家标记的单元格位置不会被更改或标记。因此，一旦标记了有效的单元格，我们就将其CSS类设置为`notAvailable`，这样我们就知道该单元格已被占用。在点击单元格时，我们将检查单元格是否有`notAvailablestyle`。如果有，则不能标记。如果没有，则可以标记单元格，然后我们将标记的位置发送到服务器中心。我们还看到服务器根据游戏状态触发的`waitingForMove`、`moveMade`、`gameOver`和`opponentDisconnected`事件。代码有注释，并且相当直接。以下代码中的`moveMade`方法使用了`MoveInformation`类，我们将在服务器上定义它以与两位玩家共享移动信息：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After every move, both players need to be updated by the server about the move
    made, so that both players'' game boards are in sync. So, on the server side we
    will need an additional model called `MoveInformation`, which will contain information
    on the latest move made by the player and the server will send this model to both
    the clients to keep them in sync:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每次移动后，服务器都需要更新两位玩家关于所进行的移动，以确保两位玩家的游戏板保持同步。因此，在服务器端，我们需要一个额外的模型，称为`MoveInformation`，它将包含玩家最新移动的信息，服务器将向两位客户端发送此模型以保持同步：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we will wire up the remaining methods in the `GameHub` class to complete
    the game coding. The `MakeAMove` method is called every time a player makes a
    move. Also, we have overidden the `OnDisconnectedAsync` method to inform a player
    when their opponent disconnects. In this method, we also keep our players and
    games list current. The comments in the code explain the workings of the methods:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将连接`GameHub`类中的剩余方法以完成游戏编码。`MakeAMove`方法在玩家每次进行移动时都会被调用。此外，我们还重写了`OnDisconnectedAsync`方法，以便在对手断开连接时通知玩家。在此方法中，我们还保持我们的玩家和游戏列表最新。代码中的注释解释了方法的工作原理：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this, we are done with the coding of the game and are ready to run the
    game app. The detailed source code can be downloaded from [https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了游戏的编码，并准备好运行游戏应用。详细的源代码可以从[https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example)下载。
- en: Game demo
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏演示
- en: Now that our app is ready, let's run it and enjoy the game. Press *F5* and the
    game should be launched in the browser. This will work for both Visual Studio
    2017 IDE and Visual Studio Code. Also, since we are running it in our local machine,
    both players will need to play it on the same machine for the time being. Once
    we deploy this game in Azure, players can browse the URL from their individual
    machines. We will see how we can publish an ASP.NET Core 2.0 app to Azure in a
    later chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用已经准备好了，让我们运行它并享受游戏吧。按*F5*键，游戏应该在浏览器中启动。这适用于Visual Studio 2017 IDE和Visual
    Studio Code。另外，由于我们在本地机器上运行它，两个玩家暂时需要在同一台机器上玩游戏。一旦我们将这个游戏部署到Azure，玩家就可以从各自的机器上浏览URL。我们将在后面的章节中看到如何将ASP.NET
    Core 2.0应用程序发布到Azure。
- en: 'This is what the game registration UI looks like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏注册用户界面的样子：
- en: '![](img/6d7d77f3-fd57-4fac-ba66-85266a267634.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d7d77f3-fd57-4fac-ba66-85266a267634.png)'
- en: 'On clicking Register, the find opponent screen is displayed:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“注册”，将显示查找对手的屏幕：
- en: '![](img/cbb06037-597d-465c-a00c-ce70a3f9cb89.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbb06037-597d-465c-a00c-ce70a3f9cb89.jpg)'
- en: 'On clicking the Find Opponent Player button, if a registered player exists,
    the game starts and this is what the two-player game looks like:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“查找对手玩家”按钮，如果存在已注册的玩家，游戏就开始了，这就是两人游戏的模样：
- en: '![](img/f2383980-13ac-4ca6-ad52-33186d658fc5.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2383980-13ac-4ca6-ad52-33186d658fc5.jpg)'
- en: 'If a player is not available, or you are the lone warrior registered to play,
    the following screen will be displayed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有玩家可用，或者你是唯一注册来玩的单打独斗者，将显示以下屏幕：
- en: '![](img/666153c2-cb46-449e-a440-9f2decb04729.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/666153c2-cb46-449e-a440-9f2decb04729.jpg)'
- en: We have developed a fully functional two-player Tic-Tac-Toe game, meeting all
    the requirement specifications. It's time to enjoy your very first ASP.NET Core
    2.0 game powered by SignalR Core!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了一个功能齐全的两人井字棋游戏，满足了所有要求规范。现在是时候享受由SignalR Core驱动的你的第一个ASP.NET Core 2.0游戏了！
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the project structure of a typical ASP.NET
    Core 2.0 app and understood the importance and purpose of each and every file
    that comes with the default MVC template. We also learned about SignalR and SignalR
    Core, and developed our very first game, Tic-Tac-Toe, on ASP.NET Core 2.0 based
    on the given requirements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了典型ASP.NET Core 2.0应用程序的项目结构，并了解了每个默认MVC模板中每个文件的重要性和目的。我们还学习了SignalR和SignalR
    Core，并根据给定要求在ASP.NET Core 2.0上开发了我们的第一个游戏，井字棋。
- en: In the next chapter, we will deep dive into learning and coding the features
    of ASP.NET Core 2.0 while developing a real-time chat application for multiple
    clients called Let's Chat.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入学习和编码ASP.NET Core 2.0的功能，同时开发一个名为Let's Chat的多客户端实时聊天应用程序。
