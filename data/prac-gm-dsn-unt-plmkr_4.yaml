- en: Chapter 4. Creating Your First Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。创建你的第一个游戏
- en: 'In [Chapter 3](ch03.html "Chapter 3. Components and State Machines"), *Components
    and State Machines*, you made your first game mechanic for the air hockey game,
    which we are going to keep improving for the rest of this book. You made a puck
    and a mallet that is controlled using the mouse pointer and pushes the puck. The
    pushing mechanic was rather complex and requires some in-depth analysis, which
    will be the first thing we talk about in this chapter. This chapter is going to
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。组件和状态机")，*组件和状态机* 中，你为空气曲棍球游戏制作了第一个游戏机制，我们将在此书的剩余部分继续改进它。你制作了一个冰球和一个由鼠标指针控制的球槌，球槌可以推动冰球。推动机制相当复杂，需要一些深入的分析，这是我们本章要讨论的第一件事。本章将涵盖以下主题：
- en: Using vector geometry and physics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矢量几何和物理
- en: Win/lose conditions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜/负条件
- en: Creating artificial intelligence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建人工智能
- en: Playmaker debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playmaker 调试
- en: In the end, I will give you a couple of exercises that you will be able to complete
    with skills and knowledge you will have acquired by the end of this chapter, as
    well as some advice on how to look for answers to your questions if you have any.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将给你一些练习，你将能够使用你在本章结束时获得的技术和知识来完成它们，以及一些如果你有任何问题如何寻找答案的建议。
- en: Using Vector geometry and physics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用矢量几何和物理
- en: If you are anything like me, you found the title of this section intimidating.
    However, before you decide to skip it or start looking for a new book about Unity,
    I assure you that it will not expose you to a single mathematical formula. Instead,
    it will use the Playmaker actions and explain what each of them does, which, in
    turn, will lead us to a conclusion about the science behind it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你可能会觉得这个部分的标题令人畏惧。然而，在你决定跳过它或开始寻找关于 Unity 的新书之前，我向你保证，它不会让你接触到任何数学公式。相反，它将使用
    Playmaker 动作，并解释每个动作的作用，这将反过来引导我们得出关于其背后的科学结论。
- en: Practically no 3D video game is possible without vector geometry and physics
    of some kind, and naturally both are instrumental in explaining how the mallet-puck
    interaction works in your new air hockey game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有哪种 3D 视频游戏不需要某种矢量几何和物理，而且自然地，这两者都是解释你的新空气曲棍球游戏中球槌-冰球交互工作原理的关键。
- en: 'To begin, let us select the **Push Puck** state in the Mallet FSM by clicking
    on it in the FSM view of the **playMaker** panel and open the **Variables** tab
    on the right. There are three variables of type **Vector3** and one of type **Float**
    in the list. The following variables are of interest to us, since they are used
    for the calculation of push force and direction:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 **playMaker** 面板的 FSM 视图中点击 **Push Puck** 状态，然后在右侧打开 **Variables** 选项卡。列表中有三个
    **Vector3** 类型的变量和一个 **Float** 类型的变量。以下变量对我们来说很重要，因为它们用于计算推力和方向：
- en: '**hitPos** is a **Vector3** variable in which we store the **X**, **Y**, and
    **Z** coordinates of the collision point between the mallet and the puck'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hitPos** 是一个 **Vector3** 变量，我们用它存储球槌和冰球碰撞点的 **X**、**Y** 和 **Z** 坐标'
- en: '**pushDir** is a **Vector3** variable we store the **X**, **Y**, and **Z**
    direction in which the puck is going to be pushed when it collides with the mallet'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pushDir** 是一个 **Vector3** 变量，我们用它存储当冰球与球槌碰撞时将要被推的 **X**、**Y** 和 **Z** 方向'
- en: '**pushMag** is a **Float** variable that is currently equal to 20 and corresponds
    to the magnitude of the push'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pushMag** 是一个当前等于 20 的 **Float** 变量，对应于推力的幅度'
- en: 'To understand how things work in video games, you will have to be comfortable
    using **Vector3** variables, because much of everything you will do is going to
    happen in 3D space. Each **Transform** component has three **Vector3** properties:
    **Position**, **Rotation**, and **Scale**, each of which has its own **X**, **Y**,
    and **Z** values.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解视频游戏中的事物是如何工作的，你必须熟悉使用 **Vector3** 变量，因为你将要做的很多事情都将发生在 3D 空间中。每个 **Transform**
    组件有三个 **Vector3** 属性：**Position**、**Rotation** 和 **Scale**，每个属性都有其自己的 **X**、**Y**
    和 **Z** 值。
- en: 'Each point in 3D space has coordinates that can be written down in the form
    of three **Float** variables: a position on the X axis, a position on the Y axis,
    and a position on the Z axis. A **Vector3** variable can store these three position
    values at the same time.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 空间中的每个点都有可以写成三个 **Float** 变量形式的坐标：X 轴上的位置、Y 轴上的位置和 Z 轴上的位置。一个 **Vector3**
    变量可以同时存储这三个位置值。
- en: You can perform various actions over **Vector3**, you can add it to another
    vector, you can multiply it by a float (or an integer), you can store its **X**,
    **Y**, and **Z** in separate **Float** variables or write separate float values
    into its **X**, **Y**, and **Z**. Most of these actions are under the **Vector3**
    category of the **Actions** panel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对 **Vector3** 执行各种操作，你可以将它添加到另一个向量中，你可以将它乘以一个浮点数（或一个整数），你可以将它的 **X**、**Y**
    和 **Z** 存储在单独的 **Float** 变量中，或者将单独的浮点值写入其 **X**、**Y** 和 **Z**。这些操作中的大多数都在 **Actions**
    面板的 **Vector3** 类别下。
- en: The first action that we use is called **Get Controller Hit Info**, and it gets
    the position of the last collision that happened to a game object. If you look
    at the **Collision Event** action in the **Move** state that triggers the **Push**
    event, you will see that this only happens when the mallet collides with the puck,
    so we do not have to worry about weeding out false collisions once we are already
    in the **Push Puck** state. All we have to do is save the contact point in a variable,
    which is exactly what happens.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的第一个动作被称为 **Get Controller Hit Info**，它获取游戏对象发生的最后碰撞的位置。如果你查看触发 **Push**
    事件的 **Move** 状态中的 **Collision Event** 动作，你会看到这只有在槌子与冰球碰撞时才会发生，所以我们不需要担心在 **Push
    Puck** 状态中过滤掉假碰撞。我们唯一需要做的就是将接触点保存到一个变量中，这正是所发生的事情。
- en: '![Using Vector geometry and physics](img/8108OT_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量和物理](img/8108OT_04_01.jpg)'
- en: Next, we simply get the current position of the mallet and store it in the **pushDir**
    variable, for the time being using the **GetPosition** action. This variable is
    called **pushDir**, because later it will contain the direction in which the mallet
    will be pushed. We get this position simply by accessing the **Position** property
    of the mallet's **Transform** component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地获取槌子的当前位置并将其存储在 **pushDir** 变量中，暂时使用 **GetPosition** 动作。这个变量被称为 **pushDir**，因为它将包含槌子将被推的方向。我们通过访问槌子的
    **Transform** 组件的 **Position** 属性来获取这个位置。
- en: '![Using Vector geometry and physics](img/8108OT_04_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量和物理](img/8108OT_04_02.jpg)'
- en: If these are all positions, how do you get a direction? What is a direction
    and how can you write it down in **Vector3**? The answer is quite simple. A direction
    is the relative position of one point with respect to another point in space,
    which is another way of saying that it is the difference between **Position A**
    and **Position B**. The following figure shows two points and their relative directions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些都是位置，那么如何得到一个方向？方向是什么，你如何在 **Vector3** 中写下来？答案是相当简单的。方向是空间中一点相对于另一点的相对位置，这另一种说法就是它是
    **位置 A** 和 **位置 B** 之间的差异。以下图显示了两个点及其相对方向。
- en: '![Using Vector geometry and physics](img/8108OT_04_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量和物理](img/8108OT_04_03.jpg)'
- en: So, in order to find the direction in which point B lies in relation to point
    A, you will have to subtract the position of point B from the position of point
    A. Then you need to normalize the result, which means writing it down as a **Vector3**
    variable that has its **X**, **Y**, and **Z** properties as numbers between `0`
    and `1` (that is, without a magnitude).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，为了找到点 B 相对于点 A 的方向，你必须从点 A 的位置中减去点 B 的位置。然后你需要对结果进行归一化，这意味着将其写成一个具有其 **X**、**Y**
    和 **Z** 属性为介于 `0` 和 `1` 之间（即没有大小）的 **Vector3** 变量。 '
- en: 'For example, if the original result of subtraction was (`-1`, `27`, `350`),
    the normalized vector of direction will be (`-0.00284867`, `0.076914`, `0.997034`),
    and the best part of it is that you do not need to know how this happens, because
    there is a Playmaker action that does it automatically for you. The following
    screenshot shows the two actions that are used to get the direction from the center
    of the mallet to the hit point:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果减法运算的原始结果是 (`-1`, `27`, `350`)，则方向归一化向量为 (`-0.00284867`, `0.076914`, `0.997034`)，而且最好的部分是，你不需要知道它是如何发生的，因为有一个
    Playmaker 动作会自动为你完成。以下截图显示了用于从槌子中心到击中点的两个动作：
- en: '![Using Vector geometry and physics](img/8108OT_04_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量和物理](img/8108OT_04_04.jpg)'
- en: 'Let us go through the things we have covered so far:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们到目前为止所涵盖的内容：
- en: We need the position of the mallet, because this is where we are going to push
    the puck from
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要槌子的位置，因为这是我们打算从那里推动冰球的。
- en: We need the point of the impact between the mallet and the puck in order to
    find where the puck lies in space in relation to the mallet when the mallet hits
    it
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要球拍和球之间的撞击点，以便在球拍击打球时找到球相对于球拍在空间中的位置
- en: Both of these values are saved as **Vector3** variables, each of which contains
    an **X**, **Y**, and **Z** position
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个值都保存为**Vector3**变量，每个变量都包含一个**X**、**Y**和**Z**位置
- en: We can find out in which direction the puck lies in relation to the mallet by
    subtracting the position of the impact from the position of the mallet and normalizing
    the resulting vector, that is, writing down its **X**, **Y**, and **Z** properties
    as numbers between `0` and `1`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过从球拍的位置减去撞击位置并归一化结果向量来找出球相对于球拍的方向，即将其**X**、**Y**和**Z**属性以`0`到`1`之间的数字写下
- en: Now that we know how to find the direction in which the puck lies in relation
    to the mallet, we want to push it in that direction, so this is exactly what we
    are going to do. However, we cannot just assign the direction vector as the puck's
    velocity, because the direction vector does not have a magnitude, which means
    that the velocity of the puck will be way smaller than we want it to be.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何找到球相对于球拍的方向，我们希望将球推向这个方向，所以这正是我们要做的。然而，我们不能直接将方向向量作为球的速率，因为方向向量没有大小，这意味着球的速率将远远小于我们想要的。
- en: In order to control the force with which the puck is being pushed, we have to
    multiply the direction by a magnitude, which is stored in the **pushMag** variable.
    This variable determines how fast the puck will move in the opposite direction
    once it meets the mallet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制推动球的力量，我们必须将方向乘以一个大小，这个大小存储在**pushMag**变量中。该变量决定了球一旦遇到球拍就会以多快的速度向相反方向移动。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you assign **pushMag** a negative value, the puck will be pushed towards
    the mallet every time it collides with it, which, in turn, means that it will
    stick to it. This too can be a useful game mechanic, albeit not in this case.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将**pushMag**赋值为负值，每次球与球拍碰撞时，球都会被推向球拍，这反过来意味着它会粘附在球拍上。这也可以是一种有用的游戏机制，尽管在这个案例中不是。
- en: The following screenshot shows the **Vector3 Multiply** action that multiplies
    the **pushDir** direction vector by **pushMag** magnitude as well as the **Add
    Force** action that applies the force to the puck at the impact point.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**Vector3 Multiply**动作，该动作将**pushDir**方向向量乘以**pushMag**大小，以及**Add Force**动作，该动作在撞击点对球施加力。
- en: '![Using Vector geometry and physics](img/8108OT_04_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量和物理](img/8108OT_04_05.jpg)'
- en: Win/Lose conditions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赢/输条件
- en: While there are games where win/lose conditions are not necessary, air hockey
    is definitely not one of them. In classic air hockey, there are two goal slots
    on the opposite sides of the table. If the puck gets into the goal of player 1,
    then player 2 gets a point and vice versa. The game ends when one of the players
    has 7 points.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些游戏不需要赢/输条件，但冰球台游戏绝对不是其中之一。在经典冰球台中，桌子两侧各有两个目标槽位。如果球进入玩家1的目标，那么玩家2得一分，反之亦然。游戏在一方玩家得到7分时结束。
- en: There is the short-term win condition (score once) and the long-term win condition
    (score seven times before your opponent does). We will only implement the short-term
    win condition, although you are highly encouraged to try and implement the long-term
    one once you are done with this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有短期赢的条件（得一分）和长期赢的条件（在对手之前得七分）。我们只会实现短期赢的条件，尽管我们强烈鼓励你在完成这一章后尝试实现长期条件。
- en: Before we start implementing the win/lose conditions, let us make sure that
    the puck cannot get stuck in the corner, because this kind of behavior will prevent
    the win/lose condition from being triggered. Make four new walls, rotate them
    45 degrees on the Y axis, and place them in the corners so as to get rid of the
    straight angles there, as shown in the next figure. This should solve the problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现赢/输条件之前，让我们确保球不能卡在角落里，因为这种行为将阻止赢/输条件被触发。制作四个新的墙壁，将它们在Y轴上旋转45度，并将它们放置在角落，以消除下一个图中显示的直角。这应该会解决问题。
- en: Now that this is taken care of, let us make the goal slots. Change the puck's
    **Scale** property to (`1`, `0.7`, `1`) and place it in (`-3`, `0.3`, `0`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经处理好了这个问题，让我们制作目标槽位。将球的大小**Scale**属性更改为(`1`, `0.7`, `1`)，并将其放置在(`-3`, `0.3`,
    `0`)。
- en: Make one more wall on the left and one more wall on the right. The walls should
    be placed as shown in the following figure:![Win/Lose conditions](img/8108OT_04_06.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧再建一堵墙，在右侧再建一堵墙。墙的放置应如图所示：![胜负条件](img/8108OT_04_06.jpg)
- en: Make two new cubes (**GoalLeft** and **GoalRight**) and place them in the gaps
    on the left and on the right, as shown in the next figure. Make the cube on the
    left green (`0`, `255`, `0`) and the cube on the right red (`255`, `0`, `0`) by
    making new materials for them. Both of them should be in `2.5` on the Y axis.
    These are there to block the mallet, but not the puck.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作两个新的立方体（**GoalLeft**和**GoalRight**），并将它们放置在下一图所示的左侧和右侧的间隙中。将左侧的立方体设置为绿色（`0`，`255`，`0`），将右侧的立方体设置为红色（`255`，`0`，`0`），为它们创建新的材质。它们都应该在Y轴上的`2.5`处。这些是为了阻挡球槌，而不是球。
- en: Make two more cubes. Call them `GoalTriggerLeft` and `GoalTriggerRight`. Place
    them just behind the game field on either side of the table. These objects will
    act as triggers to detect which goal the puck has scored. Check the **Is Trigger**
    property of these game objects' **Box Collider** component. This property of the
    collider component makes sure that the object does not do any physics collisions
    (as opposed to the puck or the walls), but instead acts as a trigger, detecting
    when rigidbodies enter, stay inside, and exit it. These objects are the actual
    goals that will trigger the win/lose conditions.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再制作两个立方体。将它们命名为`GoalTriggerLeft`和`GoalTriggerRight`。将它们放置在游戏场地的两侧，正好在桌子后面。这些对象将作为触发器来检测哪个球得分。检查这些游戏对象的**Box
    Collider**组件的**是触发器**属性。这个碰撞组件的属性确保对象不会进行任何物理碰撞（与球或墙壁相反），而是作为触发器，检测刚体何时进入、停留在其中以及何时退出。这些对象是实际触发胜负条件的球门。
- en: Your **Scene** view should look something like the following screenshot at this
    point:![Win/Lose conditions](img/8108OT_04_07.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，你的**场景**视图应该看起来像以下截图：![胜负条件](img/8108OT_04_07.jpg)
- en: Select the **GoalTriggerLeft** game object and add an FSM to it. Make two states
    and rename **State1** to `Scored` and **State2** to `LoadLevel`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**GoalTriggerLeft**游戏对象，并向其添加一个FSM。创建两个状态，将**State1**重命名为`得分`，将**State2**重命名为`加载级别`。
- en: Right-click the **Scored** state and go to **Add Transition** | **System Events**
    | **TRIGGER ENTER** from the contextual menu.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**得分**状态，从上下文菜单中选择**添加过渡** | **系统事件** | **触发进入**。
- en: Make a transition from **TRIGGER ENTER** to **LoadLevel**. When something enters
    the trigger (and it should only be the puck, because of the way things are placed
    in the scene), this event will get called, and the transition will be made.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**触发进入**到**加载级别**创建一个过渡。当某个物体进入触发器时（由于场景中物体的放置方式，这应该是球），将调用此事件，并执行过渡。
- en: Select the **LoadLevel** state and add a **Load Level** action to it. It should
    be located under the **Level** category.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**加载级别**状态，并向其添加一个**加载级别**动作。它应该位于**级别**类别下。
- en: In the **Level Name** property of the **Load Level** action, type the name of
    your game scene. It should be called `Scene1` if you haven't changed anything.
    To make sure, look at the top of the **Unity Editor** window. It always says `[SceneName].unity
    - [ProjectName] - [Platform]`, where the things in the brackets are **Scene1**,
    **UPMTutorial**, and **Web Player** for me, but can differ for you.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**加载级别**动作的**级别名称**属性中，输入你的游戏场景名称。如果你没有做任何更改，它应该被称为`Scene1`。为了确保这一点，查看**Unity
    编辑器**窗口的顶部。它总是显示为 `[SceneName].unity - [ProjectName] - [Platform]`，其中括号中的内容对我来说是**Scene1**、**UPMTutorial**和**Web
    Player**，但可能因人而异。
- en: Do the same thing for **GoalTriggerRight**. For now, keep the FSM exactly the
    same.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**GoalTriggerRight**也做同样的事情。目前，保持FSM完全相同。
- en: 'Now, we can add some finishing touches to our scene by importing a 3D model:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过导入3D模型来为我们的场景添加一些完成效果：
- en: Make sure that you have downloaded the project archive from the Packt Publishing
    website. If you haven't, do it now and unpack the archive.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经从Packt Publishing网站下载了项目存档。如果你还没有，现在就做，并解压存档。
- en: Right-click in the empty space under the file list in the **Project** panel
    and select **Import New Asset...** from the contextual menu. A file browser should
    pop up.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板下文件列表的空白区域右键单击，并从上下文菜单中选择**导入新资产...**。应该会弹出一个文件浏览器。
- en: Locate the `WallVisual.fbx` file in the `UnityPlaymakerTutorial` directory and
    click on **Import**. The file browser will close and a `WallVisual` file will
    appear in the **Project** panel. Create a `Models` folder and drag it there.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UnityPlaymakerTutorial`目录中定位`WallVisual.fbx`文件，并点击**导入**。文件浏览器将关闭，并在**项目**面板中显示`WallVisual`文件。创建一个`Models`文件夹，并将其拖入其中。
- en: 'Select the `WallVisual` file and have a look at **Inspector**. There are three
    tabs in this **Inspector**: **Model**, **Rig**, and **Animations**. These are
    all responsible for changing import settings of your model.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`WallVisual`文件，并查看**检查器**。在这个**检查器**中有三个选项卡：**模型**、**绑定**和**动画**。这些选项卡都负责更改模型的导入设置。
- en: Since the model that we have imported is not an animated one, only the **Model**
    tab is of interest to us. Set **Scale Factor** to `1.05` and uncheck **Import
    Materials**. Leave the rest of the properties at their default values. **Scale
    Factor** changes the scale of the model on import, meaning that the **Transform
    Scale** property will be equal to (`1`, `1`, `1`) while the actual size in 3D
    space may change. This is needed because the working scale in the 3D modeling
    software (such as Maya or 3DS Max) may differ from that in Unity. To make the
    model appear bigger, increase the scale factor. See the following screenshot to
    confirm that your import settings are set correctly:![Win/Lose conditions](img/8108OT_04_15.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们导入的模型不是动画模型，因此只有**模型**选项卡对我们感兴趣。将**缩放因子**设置为`1.05`，并取消选中**导入材质**。将其他属性保留在默认值。**缩放因子**在导入时改变模型的缩放，这意味着**变换缩放**属性将等于(`1`,
    `1`, `1`)，而实际在3D空间中的大小可能会改变。这是必要的，因为3D建模软件（如Maya或3DS Max）中的工作比例可能与Unity中的不同。为了使模型看起来更大，增加缩放因子。请参阅以下截图以确认您的导入设置是否正确：![胜负条件](img/8108OT_04_15.jpg)
- en: Drag **WallVisual** into **Hierarchy** twice. Position the first instance in
    (`0`, `0.5`, `-3.5`) and the second one in (`0`, `0.5`, `3.5`). Set the first
    one's **Rotation** to (`0`, `0`, `0`) and the second one's to (`0`, `180`, `0`).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**WallVisual**拖入**层次结构**两次。将第一个实例放置在(`0`, `0.5`, `-3.5`)，第二个实例放置在(`0`, `0.5`,
    `3.5`)。将第一个实例的**旋转**设置为(`0`, `0`, `0`)，第二个实例的设置为(`0`, `180`, `0`)。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The difference between a prefab and an imported model is that you cannot apply
    the changes that you made to one of the instances. You also cannot add or remove
    any components from the model. You can make a prefab from one of the instances
    of the model to be able to do that.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预制件和导入模型的区别在于，您不能将您对实例所做的更改应用到其中一个实例上。您也不能从模型中添加或删除任何组件。您可以从模型的实例中创建一个预制件，以便能够这样做。
- en: Set the material of both **WallVisual** game objects to **WallMaterial** that
    you created previously to be used on walls. Select all of the **Wall** objects
    and deactivate their **Mesh Renderer** components. The following figure shows
    what you should see in the **Game** view if you did everything right:![Win/Lose
    conditions](img/8108OT_04_16.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个**WallVisual**游戏对象的材质设置为之前创建的用于墙壁的**WallMaterial**。选择所有**Wall**对象，并禁用它们的**网格渲染器**组件。以下图示显示了如果您一切操作正确，您应该在**游戏**视图中看到的内容：![胜负条件](img/8108OT_04_16.jpg)
- en: Now, when you hit play, you should be able to score in both goals. Doing so
    will reload the currently loaded level. We also made sure that the puck does not
    get stuck in the corners of the table and imported a model that covers our cubic
    walls and makes the game look more like an actual air hockey table. This means
    that the game is finally playable, if, admittedly, not very fun yet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您按下播放时，您应该能够在两个球门得分。这样做将重新加载当前加载的水平。我们还确保了冰球不会卡在桌角的角落里，并导入了一个覆盖我们立方墙的模型，使游戏看起来更像真正的空气曲棍球桌。这意味着游戏最终可以玩，尽管坦白说，目前还不够有趣。
- en: Creating artificial intelligence
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建人工智能
- en: Having an **artificial intelligence** (**AI**) in the game, even a really simple
    one, will definitely make it more challenging and fun, so let us get to it with
    no further delay.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中加入**人工智能**（**AI**），即使是一个非常简单的AI，也肯定会使其更具挑战性和趣味性，所以让我们立即着手进行。
- en: 'Here is how our AI is going to work: it is going to constantly try and move
    to the point on the right side of the puck, pushing it to the left upon collision.
    We will keep the same collision logic that we use for the player''s mallet in
    order to keep the game fair. In order to make sure that the AI does not get stuck
    in a wall while pushing directly to the left, we will make adjustments to the
    direction based on the current position of the mallet. This way, the AI will appear
    to aim at the player''s goal slot.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的AI将如何工作：它将不断尝试移动到冰球右侧的点，并在碰撞时将其推向左侧。我们将保持与玩家球拍相同的碰撞逻辑，以保持游戏的公平性。为了确保AI在直接向左推时不会卡在墙上，我们将根据球拍当前的位置调整方向。这样，AI看起来就像是在瞄准玩家的目标槽位。
- en: 'Follow the given steps to implement the AI:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现AI：
- en: Duplicate the **Mallet** game object by selecting it in **Hierarchy** and pressing
    *command* + *D* (*Ctrl* + *D* in Windows).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**层次结构**中选择**Mallet**游戏对象并按*command* + *D*（在Windows上为*Ctrl* + *D*）来复制**Mallet**游戏对象。
- en: Move the copy to the right side of the table and put it next to the red goal.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将副本移动到桌子的右侧，并放在红色球门旁边。
- en: Name the original mallet on the left `MalletLeft`, and the copy on the right
    `MalletRight`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将左侧的原始球拍命名为`MalletLeft`，右侧的副本命名为`MalletRight`。
- en: Make a new red material for **MalletRight** and assign it to it.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**MalletRight**制作一种新的红色材料并将其分配给它。
- en: Put both mallets on a new layer called **Player** using the **TagManager** menu
    accessible from **Inspector**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**检查器**中可访问的**TagManager**菜单，将两个球拍放置在名为**玩家**的新层上。
- en: In the main menu, go to **Edit** | **Project Settings** | **Physics**. You will
    see a matrix of checkboxes with names of layers written horizontally and vertically
    next to each row and column in the **Inspector** panel.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中，转到**编辑** | **项目设置** | **物理**。你将在**检查器**面板中看到带有层名称的复选框矩阵，这些名称水平垂直地写在每一行和每一列旁边。
- en: Find the intersection between **Player** horizontally and **Player** vertically
    and uncheck that box. Make sure that the rest of the boxes stay checked. This
    matrix determines which layers can interact with each other and with themselves,
    so if you accidentally uncheck something else, such as **Default**/**Player**
    or **Default**/**Default**, the puck may no longer collide with the goal triggers
    and the mallets may stop colliding with the walls.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到**玩家**水平方向和**玩家**垂直方向之间的交点，并取消选中该框。确保其余的框保持选中状态。这个矩阵决定了哪些层可以相互交互以及与自身交互，所以如果你意外取消选中了其他内容，例如**默认**/**玩家**或**默认**/**默认**，冰球可能不再与目标触发器碰撞，球拍可能停止与墙壁碰撞。
- en: Select the **MalletRight** game object. In **Inspector**, remove the **Character
    Controller** component and add **Capsule Collider**. Add a **Rigidbody** component.
    Set **Freeze Rotation** on the **Rigidbody** component to X, Y and Z. If you don't,
    the red mallet will fall when you press play. **Rigidbody** is the component responsible
    for physics interactions.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**MalletRight**游戏对象。在**检查器**中，移除**Character Controller**组件并添加**胶囊碰撞器**。添加一个**Rigidbody**组件。在**Rigidbody**组件上设置**冻结旋转**为X、Y和Z。如果不这样做，当你按下播放时，红色球拍会掉落。**Rigidbody**是负责物理交互的组件。
- en: In the FSM view of the **playMaker** panel, select the **Move** state. It is
    here that we are going to set up the AI.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**playMaker**面板的FSM视图中，选择**移动**状态。我们将在这里设置AI。
- en: 'Remove all the actions except **Collision Event**. You can select multiple
    actions at the same time by *Shift*-clicking their headers. Open the **Actions**
    panel and add the following actions to the state, keeping in mind that the order
    of the actions matters, and moving **Collision Event** to the very bottom: **Get
    Property**, **Get Property**, **Get Property**, **Float Multiply**, **Float Add**,
    **Float Add**, **Set Vector3 XYZ**, and **Move Towards**. The following screenshot
    shows the exact order of the actions that you should have in the **Move** state
    of the FSM of **MalletRight**.![Creating artificial intelligence](img/8108OT_04_08.jpg)'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有动作，除了**碰撞事件**。你可以通过*Shift*-点击它们的标题来同时选择多个动作。打开**动作**面板，将以下动作添加到状态中，同时注意动作的顺序，并将**碰撞事件**移动到最底部：**获取属性**，**获取属性**，**获取属性**，**浮点乘法**，**浮点加法**，**浮点加法**，**设置Vector3
    XYZ**，和**向目标移动**。以下截图显示了你应该在**MalletRight**的FSM的**移动**状态中具有的动作的确切顺序。![创建人工智能](img/8108OT_04_08.jpg)
- en: In the **Events** tab, add a new event, calling it `Return`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**事件**选项卡中，添加一个新事件，命名为`Return`。
- en: Open the **Variables** tab and add/remove variables until you have the variables
    shown in the following screenshot:![Creating artificial intelligence](img/8108OT_04_09.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **变量** 选项卡，添加/删除变量，直到你拥有以下截图所示的变量：![创建人工智能](img/8108OT_04_09.jpg)
- en: These are the variables used for collision calculations that were left from
    before, and some new ones used for the simple AI behavior that we discussed earlier.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是之前留下的用于碰撞计算的变量，以及一些用于我们之前讨论的简单 AI 行为的新变量。
- en: Go back to the **State** tab and open the first **Get Property** action. Drag
    and drop the **Puck** game object into **Target Object**, and set **Property**
    to **transform** | **position** | **x** and **Store Float** to **puckX**. Check
    **Every Frame**. In fact, check **Every Frame** every time you see this checkbox
    in this state.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **状态** 选项卡，并打开第一个 **获取属性** 动作。将 **Puck** 游戏对象拖放到 **目标对象** 中，并将 **属性** 设置为
    **transform** | **position** | **x**，并将 **存储浮点数** 设置为 **puckX**。检查 **每一帧**。实际上，每次你在这个状态下看到这个复选框时，都要检查
    **每一帧**。
- en: Do the same for the second **Get Property** tab, but choose **z** instead of
    **x** and **puckZ** instead of **puckX**. These actions are used to retrieve the
    position of the puck on the two axes that matter to us.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对第二个 **获取属性** 选项卡执行相同的操作，但选择 **z** 而不是 **x**，并将 **puckZ** 而不是 **puckX**。这些动作用于检索对我们重要的两个轴上的冰球位置。
- en: Open the third **Get Property** action and drag **MalletRight** into its **Target
    Object** property; store its Z position in the offset variable.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第三个 **获取属性** 动作，并将 **MalletRight** 拖动到其 **目标对象** 属性中；将其 Z 位置存储在偏移变量中。
- en: In the **Float Multiply** action, set **Float Variable** to **offset** and **Multiply
    By** to `0.2`. This is where we define how hard the AI should try to aim the player's
    goal. If it tries too hard, it will miss. If it tries not hard enough, it will
    miss as well.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **浮点数乘法** 动作中，将 **浮点变量** 设置为 **offset**，并将 **乘以** 设置为 `0.2`。这是我们定义 AI 应该多努力瞄准玩家球门的地方。如果它太努力，它会错过。如果它不够努力，它也会错过。
- en: In the first **Float Add** action, set **Float Variable** to **puckX** and the
    **Add** property to **offset**. You need to click on the option button on the
    right to do that. This is where the offset is actually applied.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个 **浮点数添加** 动作中，将 **浮点变量** 设置为 **puckX**，并将 **添加** 属性设置为 **offset**。你需要点击右侧的选项按钮来完成此操作。这是实际应用偏移的地方。
- en: In the second **Float Add** action, set **Float Variable** to **puckZ**, and
    **Add** to `0.9`. This value can be changed as you want later. It defines the
    distance between the actual center of the puck and the point to which the AI is
    going to move. It is very important that the AI aim somewhat to the right, because
    otherwise it will never be able to hit the player's goal.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个 **浮点数添加** 动作中，将 **浮点变量** 设置为 **puckZ**，并将 **添加** 设置为 `0.9`。这个值以后可以按需更改。它定义了实际冰球中心与
    AI 将要移动到的点的距离。AI 稍微向右瞄准非常重要，否则它永远无法击中玩家的球门。
- en: In **Set Vector3 XYZ**, set **Vector3 Variable** to **targetPos**, **X** to
    **puckX,** and **Z** to **puckZ**. Make sure that **Y** is set to **None**. This
    is where we define the actual position where the AI is going to try and go in
    the current frame.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **设置 Vector3 XYZ** 中，将 **Vector3 变量** 设置为 **targetPos**，**X** 设置为 **puckX**，并将
    **Z** 设置为 **puckZ**。确保 **Y** 设置为 **None**。这是我们定义 AI 在当前帧中将要尝试移动的实际位置的地方。
- en: '**Move Towards** is the action that applies movement to the AI. Set **Target
    Position** to **targetPos**, **Max Speed** to `5`, **Finish Distance** to `0.15,`
    and **Finish Event** to **Return**.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Move Towards** 是将移动应用到 AI 的动作。将 **目标位置** 设置为 **targetPos**，**最大速度** 设置为 `5`，**完成距离**
    设置为 `0.15`，以及 **完成事件** 设置为 **Return**。'
- en: Finally, open **Collision Event** and change its **Collision** property to **On
    Collision Stay**; leaving everything else intact.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 **碰撞事件**，并将其 **碰撞** 属性更改为 **碰撞后停留**；保留其他一切不变。
- en: Now you might have an error in the **Move Towards** action. That would be because
    there is no transition from the **Return** event. Right-click the **Move** state
    in the FSM view and add a transition from the **Return** event to **Move**. Yes,
    this is a state that loops on itself. The following figure shows the layout that
    you should see in the FSM view of **MalletRight** now.![Creating artificial intelligence](img/8108OT_04_10.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可能在 **Move Towards** 动作中遇到错误。那是因为没有从 **Return** 事件过渡。在 FSM 视图中右键单击 **Move**
    状态，并添加从 **Return** 事件到 **Move** 的过渡。是的，这是一个自我循环的状态。以下图显示了你现在应该在 **MalletRight**
    的 FSM 视图中看到的布局。![创建人工智能](img/8108OT_04_10.jpg)
- en: If you click on the play button right now, the AI should be completely functional
    and, in fact, quite strong. Now, there are ways of improving it that will be discussed
    in the *Exercises* section of this chapter, but it should be enough to have a
    good bit of fun with the game debugging in Playmaker.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击播放按钮，AI应该完全功能正常，实际上相当强大。现在，有一些改进它的方法将在本章的*练习*部分讨论，但应该足以让你在Playmaker中享受游戏调试的乐趣。
- en: 'Now that you have a player controller, a win/lose condition, and a functional
    AI in the game, it begins to get quite big, and if you want to add anything to
    it or if something goes wrong, you will be hard-pressed to know what exactly is
    going on in your actions in real time. This is what debugging is for: it is a
    diagnosis tool that lets you get additional information about your game or its
    specific systems that you can later use in order to fix something.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了玩家控制器、胜负条件和功能性的AI，游戏开始变得相当庞大。如果你想要向其中添加任何内容或者出现问题，你将很难实时了解你的动作中到底发生了什么。这就是调试的作用：它是一个诊断工具，让你能够获取关于你的游戏或其特定系统的额外信息，你可以在之后使用这些信息来修复某些问题。
- en: 'Let us look at an example. Select **MalletLeft** and open its **Move** state
    in the FSM view of the **playMaker** panel. If you look at the bottom of the **State**
    tab, you will see two checkboxes there: **Debug** and **Hide Unused**. The first
    one shows you the values of all your properties at all time, while the second
    one hides the unused ones. Check both of them and, keeping **MalletLeft** selected,
    press the play button.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。选择**MalletLeft**并在**playMaker**面板的FSM视图中打开其**移动**状态。如果你查看**状态**标签页的底部，你会看到那里有两个复选框：**调试**和**隐藏未使用**。第一个复选框显示你所有属性在所有时间点的值，而第二个复选框隐藏未使用的属性。检查这两个复选框，并保持**MalletLeft**被选中，然后按下播放按钮。
- en: As you move the mallet around, observe the numbers that change under all the
    properties of the actions. When you implement a new gameplay feature, you will
    want to know in what range values change, and if they do at all.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动球槌时，观察在所有动作属性下变化的数字。当你实现一个新的游戏玩法特性时，你将想要知道数值变化在什么范围内，以及它们是否真的发生了变化。
- en: You can also use the **Console** panel for debugging some things. Uncheck both
    **Debug** and **Hide Unused**, and then open the **Push Puck** state of the same
    FSM. Add a **Debug Log** action (under the **Debug** category) to the very top
    of it. Set **Log Level** to **Warning** and write `Hit!` in the text field.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用**控制台**面板来调试某些事情。取消选中**调试**和**隐藏未使用**，然后打开相同FSM的**推球**状态。在它的顶部添加一个**调试日志**动作（在**调试**类别下）。将**日志级别**设置为**警告**并在文本框中写下`击中！`。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You should know that there are three types of debug logs: *Info*, *Warning*,
    and *Error*, each with a specific function. Warning is there to attract your attention
    to an issue, Info is a simple message that provides information about something,
    while Error lets you know that there is a problem. These are merely conventions,
    but you will see some Unity internal Info, Warnings, and Errors that follow them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，存在三种类型的调试日志：*信息*、*警告*和*错误*，每种都有特定的功能。警告是为了吸引你的注意力到某个问题，信息是提供关于某物信息的简单消息，而错误则让你知道存在问题。这些只是惯例，但你将看到一些遵循它们的Unity内部信息、警告和错误。
- en: Now open the **Console** panel. We have talked about it briefly before, but
    let us have a detailed look at various buttons in it now (from left to right).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开**控制台**面板。我们之前简要地讨论过它，但现在让我们详细看看其中的各种按钮（从左到右）。
- en: '**Clear** is quite self-explanatory; it clears the log, removing all the messages
    from it, apart from compilation errors that were not fixed'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**相当直观；它清除日志，移除所有消息，除了未修复的编译错误。'
- en: '**Collapse** is a toggle button that makes similar debug messages appear in
    the same line or separately'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠**是一个切换按钮，它使得相似的调试消息出现在同一行或分别显示。'
- en: '**Clear on Play** is a toggle button that forces the **Console** to clear the
    log when you press play.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放时清除**是一个切换按钮，当你按下播放时，它会强制**控制台**清除日志。'
- en: '**Error Pause** automatically pauses the game when there is an error to give
    you a better look at it.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误暂停**会在出现错误时自动暂停游戏，以便你能更好地查看它。'
- en: 'Finally, the three toggle buttons on the right are filters for **Console**
    that let you focus on different types of debug messages: Info, Warning, and Error.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，右侧的三个切换按钮是**控制台**的过滤器，让你能够关注不同类型的调试消息：信息、警告和错误。
- en: 'If you press play now and hit the puck with your mallet, a message with a yellow
    triangle should appear in Console saying something like **MalletLeft : FSM : Push
    Puck : DebugLog : Hit!** You might also have several of them. Stop the game and
    see what happens when you switch **Collapse** on and off and toggle the Warning
    filter.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你现在按播放并使用球槌击打冰球，**Console**中应该会显示一个带有黄色三角形的消息，例如**MalletLeft : FSM : Push
    Puck : DebugLog : Hit!** 你可能还会看到几个这样的消息。停止游戏，看看当你开关**Collapse**和切换警告过滤器时会发生什么。'
- en: 'If you press play now and hit the puck with your mallet, a message with a yellow
    triangle should appear in **Console** saying something like **MalletLeft : FSM
    : Push Puck : DebugLog : Hit!** You might also have several of them. Stop the
    game and see what happens when you switch **Collapse** on and off and toggle the
    Warning filter. You might also have several of them, as shown in the following
    screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你现在按播放并使用球槌击打冰球，**Console**中应该会显示一个带有黄色三角形的消息，例如**MalletLeft : FSM : Push
    Puck : DebugLog : Hit!** 你可能还会看到几个这样的消息。停止游戏，看看当你开关**Collapse**和切换警告过滤器时会发生什么。你可能会看到几个，如下面的截图所示：'
- en: '![Creating artificial intelligence](img/8108OT_04_11.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![创建人工智能](img/8108OT_04_11.jpg)'
- en: You can also debug variable values in the same way. Open **playMaker**, remove
    the **Debug Log** action, and put a **Debug Vector3** action right after **Get
    Controller Hit Info**, setting the **Log Level** to **Error** and **Vector3 Variable**
    to **hitPos**. Then open **Console** and test the game again, pushing the puck
    with your mallet. You should see red error messages appear in **Console** now.
    If you have **Error Pause** toggled, the game will pause and the **Console** panel
    will be revealed to show you the errors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用同样的方式调试变量值。打开**playMaker**，移除**Debug Log**动作，并在**Get Controller Hit Info**之后添加一个**Debug
    Vector3**动作，将**Log Level**设置为**Error**并将**Vector3 Variable**设置为**hitPos**。然后打开**Console**并再次测试游戏，用球槌击打冰球。现在你应该会在**Console**中看到红色错误消息。如果你启用了**Error
    Pause**，游戏将暂停，**Console**面板将展开以显示错误。
- en: You can achieve a similar effect by using something called breakpoints. Get
    rid of the **Debug Vector3** action in the **Push Puck** state of the FSM of **MalletLeft**,
    then right-click on the **Push Puck** state in the FSM view and select **Toggle
    Breakpoint** from the contextual menu. A red line will appear next to the state's
    name in the FSM view.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用称为断点的东西来实现类似的效果。从**MalletLeft**的FSM的**Push Puck**状态中移除**Debug Vector3**动作，然后在FSM视图中右键单击**Push
    Puck**状态，从上下文菜单中选择**Toggle Breakpoint**。在FSM视图中状态名称旁边将出现一条红色线。
- en: 'Now, if you press play and touch the puck with your mallet, the game will stop
    the same way it did when you used an **Error Debug** log and the **Error Pause**
    toggle in **Console**, except this time the pause will be triggered by Playmaker.
    A red circle with the name of the breakpoint''s state will appear in the FSM view.
    The following screenshot shows what it is supposed to look like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你按播放并用球槌触摸冰球，游戏将像使用**Error Debug**日志和**Console**中的**Error Pause**切换时一样停止，但这次暂停将由Playmaker触发。在FSM视图中将出现一个带有断点状态名称的红色圆圈。以下截图显示了它应该看起来像什么：
- en: '![Creating artificial intelligence](img/8108OT_04_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![创建人工智能](img/8108OT_04_12.jpg)'
- en: Note that the transition arrow from the **Push** event to the **Push Puck**
    state became yellow. This means that the breakpoint was triggered after this particular
    transition and not something else.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从**Push**事件到**Push Puck**状态的转换箭头变成了黄色。这意味着断点是在这个特定的转换之后触发的，而不是其他原因。
- en: You can unpause the game when it was paused because of a breakpoint, but it
    will be paused all over again if this or another breakpoint gets triggered. You
    can remove the breakpoint by right-clicking the state with a breakpoint and selecting
    **Toggle Breakpoint** from the contextual menu.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏因为断点而暂停时，你可以取消暂停游戏，但如果这个或另一个断点被触发，游戏将再次暂停。你可以通过右键单击带有断点的状态并从上下文菜单中选择**Toggle
    Breakpoint**来移除断点。
- en: Another useful debugging tool is step-by-step execution. When the game is paused
    (including when it was paused because of breakpoints or **Error Pause**), you
    can press the next step (![Creating artificial intelligence](img/8108OT_04_13.jpg))
    button in the toolbar or on the bottom of the **playMaker** panel. This will execute
    the next frame of the game. As you already know, some actions are executed in
    every frame so, using the **Debug** checkbox on the bottom of the **State** tab
    in the **playMaker** panel, you can see the exact values of each parameter of
    each action in any particular frame. You can press the next step button as you
    want to observe changes. When you are done debugging, just unpause or stop the
    game.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的调试工具是逐步执行。当游戏暂停时（包括由于断点或**错误暂停**而暂停），你可以按下工具栏或**playMaker**面板底部的下一步按钮。这将执行游戏的下一帧。正如你所知，一些动作在每个帧都会执行，所以，通过在**playMaker**面板底部的**状态**选项卡中的**调试**复选框，你可以看到任何特定帧中每个动作的每个参数的确切值。你可以按需按下下一步按钮来观察变化。当你完成调试后，只需取消暂停或停止游戏。
- en: 'The final debug tool that we are going to talk about is the Playmaker **FSM
    Log** panel that lets you see everything that happens to your objects that are
    under Playmaker control. You can open it by pressing the **Debug** button on the
    bottom of the **playMaker** panel next to the play/pause/next step buttons, then
    select **Open Log Window** from the drop-down menu. The following screenshot shows
    the **FSM Log** panel in action:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个调试工具是Playmaker的**FSM日志**面板，它让你可以看到所有在Playmaker控制下的对象发生的事情。你可以通过按下**playMaker**面板底部靠近播放/暂停/下一步按钮的**调试**按钮来打开它，然后从下拉菜单中选择**打开日志窗口**。以下截图显示了**FSM日志**面板的实际操作：
- en: '![Creating artificial intelligence](img/8108OT_04_14.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![创建人工智能](img/8108OT_04_14.jpg)'
- en: It might be a good idea to keep this log handy, so you could attach it as the
    second panel to the same area of the screen as **Hierarchy** or **Project**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 保留这个日志在手边可能是个好主意，这样你就可以将其作为第二个面板附加到屏幕的**层次结构**或**项目**区域。
- en: Exercises
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'There are some exercises that I would like to suggest that you try doing before
    you move on to the next chapters, which cover more advanced topics. You already
    know the basics of Unity and Playmaker—enough to make your game better or make
    a completely new one from scratch. Doing these exercises will improve your skills
    and help consolidate the new information that you have been exposed to in this
    book. Exercises are sorted by difficulty, from the easiest to the hardest one:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一些练习想建议你在进入下一章之前尝试做，这些章节将涵盖更高级的主题。你已经了解了Unity和Playmaker的基础知识——足够让你改进你的游戏或者从头开始制作一个全新的游戏。做这些练习将提高你的技能，并帮助你巩固在这本书中接触到的新的信息。练习按难度排序，从最容易到最难：
- en: Debug log all the important events in the game, including puck hits, goal hits,
    and wall collisions for both mallets.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录游戏中所有重要事件（包括冰球击中、进球击中和球槌碰撞墙壁）的调试日志。
- en: 'Hit sounds: Your `Wall` prefab has a FSM. Use it to play some sounds when a
    mallet and/or a puck hits the wall. [Freesound.org](http://Freesound.org) is a
    good resource for free sound effects. If you are more into retro sounds, try [bfxr.net](http://bfxr.net).'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 击打声音：你的`Wall`预制体有一个FSM。使用它来播放一些当球槌和/或冰球击中墙壁时的声音。[Freesound.org](http://Freesound.org)是一个免费音效的好资源。如果你更喜欢复古声音，试试[bfxr.net](http://bfxr.net)。
- en: 'Multiple levels: Try making multiple levels with obstacles/additional walls
    in the middle. You can just duplicate them all over the place and then, when the
    round is over, move on to the next level.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多级设置：尝试制作多个级别，中间有障碍物/额外的墙壁。你可以在任何地方复制它们，然后，当这一轮结束后，进入下一级。
- en: By now you have probably encountered a situation where the puck falls off of
    the table, and you are forced to restart the game using the play button. This
    is annoying for other players as well! You could try changing the table set up,
    detecting the puck position, or some other way of fixing this.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经遇到了一个情况，即冰球从桌子上掉下来，你必须使用播放按钮重新开始游戏。这对其他玩家来说也很烦人！你可以尝试改变桌子设置，检测冰球位置，或者以其他方式解决这个问题。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you are working on this, think about the way goal triggers work, or be
    creative and come up with your own solution.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在做这项工作时，想想目标触发器是如何工作的，或者发挥创意，提出你自己的解决方案。
- en: You know how to manipulate the **Scene** view and make new materials for objects,
    and you also know how to change the size and the projection of the camera. You
    can make your game much prettier if you come up with a beautiful color scheme
    and/or camera projection/orientation.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道如何操作**场景**视图并为对象创建新材料，你也知道如何更改摄像机的尺寸和投影。如果你能想出一个美丽的配色方案和/或摄像机投影/方向，你的游戏会变得更加漂亮。
- en: By now you have probably started wondering whether mouse controls are the best
    solution for this game. This is a perfectly valid question, and you should make
    this decision yourself. You will never know for sure until you try different ones,
    so take a look at the **Input** category in the **Actions** panel.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经开始怀疑鼠标控制是否是这款游戏的最佳解决方案。这是一个完全合理的问题，你应该自己做出这个决定。除非你尝试不同的方法，否则你永远不会确定，所以请查看**动作**面板中的**输入**类别。
- en: If you manage to implement keyboard controls, why not go a step further and
    make a level where instead of competing with an AI opponent you could play with
    your friend or family member while sitting at the same computer?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你成功实现了键盘控制，为什么不更进一步，制作一个关卡，在这个关卡中，你可以在同一台电脑上与朋友或家人一起玩，而不是与AI对手竞争？
- en: Have a close look at states and actions that control the AI. Try modifying some
    of the properties there or even replacing actions themselves in order to make
    the AI more intelligent and life-like. You could try and make the AI alternate
    its behavior based on the position of the puck by going back to its own goal slot
    in order to protect it. You can also try and figure out a way to stop the AI from
    being pushed backwards whenever the player pushes the puck that the AI is trying
    to push itself.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细观察控制AI的状态和动作。尝试修改那里的某些属性，甚至替换动作本身，以使AI更加智能和逼真。你可以尝试让AI根据冰球的位置改变其行为，通过回到自己的目标位置来保护它。你也可以尝试找出一种方法，阻止AI在玩家推动AI试图推动的冰球时被推回。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to do this, you will need to add a Playmaker variable to the puck and
    then use one of the **Get FSM** actions under the **StateMachine** category.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要在冰球上添加一个Playmaker变量，然后使用**状态机**类别下的**Get FSM**动作之一。
- en: 'Introduce a new game mechanic to the game: how about rounds of seven games
    instead of one? Or power-ups? Or limiting the mallets to their side of the table?
    You choose, you can do them all if you like.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向游戏中引入一个新的游戏机制：如何关于七局游戏的回合而不是一局？或者加力？或者限制球棒在桌子的那一侧？你可以选择，如果你喜欢，你可以做所有这些。
- en: Before you take up any of these challenges, you should know about some of the
    useful Unity and Playmaker online resources that can help you find answers to
    some, if not all, of the questions. You can be sure that questions will inevitably
    appear when you start implementing something on your own.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在你接受这些挑战之前，你应该了解一些有用的Unity和Playmaker在线资源，这些资源可以帮助你找到一些，如果不是所有问题的答案。你可以确信，当你开始自己实现某些功能时，问题不可避免地会出现。
- en: '**Unity answers**: [http://answers.unity3d.com/](http://answers.unity3d.com/)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity问答**：[http://answers.unity3d.com/](http://answers.unity3d.com/)'
- en: '**Unity wiki**: [http://wiki.unity3d.com/](http://wiki.unity3d.com/)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity维基**：[http://wiki.unity3d.com/](http://wiki.unity3d.com/)'
- en: '**Unity forum**: [http://forum.unity3d.com/](http://forum.unity3d.com/)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity论坛**：[http://forum.unity3d.com/](http://forum.unity3d.com/)'
- en: '**Unity documentation**: [http://unity3d.com/learn/documentation](http://unity3d.com/learn/documentation)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity文档**：[http://unity3d.com/learn/documentation](http://unity3d.com/learn/documentation)'
- en: '**Playmaker manual**: [https://hutonggames.fogbugz.com/](https://hutonggames.fogbugz.com/)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Playmaker手册**：[https://hutonggames.fogbugz.com/](https://hutonggames.fogbugz.com/)'
- en: '**Playmaker forums**: [http://hutonggames.com/playmakerforum/](http://hutonggames.com/playmakerforum/)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Playmaker论坛**：[http://hutonggames.com/playmakerforum/](http://hutonggames.com/playmakerforum/)'
- en: On Unity answers and the Unity forums, you should not hesitate to ask questions;
    the Unity community is very active, and there are chances that your problem will
    be solved in a matter of minutes. Just make sure you explain it well. But before
    asking, I strongly advise you to use the search option first, since there is a
    good chance that most of the problems that you might encounter have already been
    solved.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity问答和Unity论坛上，你不应该犹豫提问；Unity社区非常活跃，你的问题可能在几分钟内就得到了解决。只是确保你解释得很好。但在提问之前，我强烈建议你首先使用搜索选项，因为有很大可能性，你可能遇到的大多数问题都已经得到了解决。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the fundamentals of game development with Unity
    and Playmaker. You now know how to make objects, have them interact, make them
    respond to input, and even move on their own based on your algorithm. On top of
    that, you now know the fundamentals of vector geometry that you are going to use
    in most of the games you will make.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用Unity和Playmaker进行游戏开发的基础知识。你现在知道如何创建对象，使它们相互交互，使它们对输入做出响应，甚至根据你的算法自行移动。除此之外，你现在还了解了你将在大多数游戏中使用的矢量几何学基础知识。
- en: The next chapter is about programming. You will learn how to code your own Unity
    component and then make it into a Playmaker action. We will also demonstrate that
    Playmaker is essentially visual programming that uses logic very similar to that
    of conventional scripts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍编程。你将学习如何编写自己的Unity组件，并将其转换为Playmaker动作。我们还将演示Playmaker本质上是一种使用与常规脚本非常相似的逻辑的视觉编程。
