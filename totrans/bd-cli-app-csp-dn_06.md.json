["```cs\npublic class UserAlreadyExistsException : Exception\n{\n    public string UserId { get; }\n    public UserAlreadyExistsException(string userId)\n        : base($\"User with ID '{userId}' already exists.\")\n    {\n        UserId = userId;\n    }\n    public UserAlreadyExistsException(string userId, Exception \n    innerException)\n        : base($\"User with ID '{userId}' already exists.\", \n        innerException)\n    {\n        UserId = userId;\n    }\n}\n```", "```cs\ntry\n{\n    using var client = new HttpClient();\n    var response = await client.GetAsync(\"https://api.packtpub.com/\n    data\");\n    response.EnsureSuccessStatusCode();\n}\ncatch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n{\n    Console.WriteLine(\"Resource not found (404)\");\n}\ncatch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.Unauthorized)\n{\n    Console.WriteLine(\"Server error (401)\");\n}\n```", "```cs\ntry\n{\n      // Attempt to read from a file\n      string content = File.ReadAllText(fileName);\n      Console.WriteLine($»File content: {content}»);\n}\ncatch (FileNotFoundException ex)\n{\n      // Handle the specific exception\n      Console.WriteLine($\"File not found: {fileName}\");\n      Console.WriteLine($\"Exception details: {ex.Message}\");\n      // Rethrow the exception\n      throw ex;\n}\n```", "```cs\n// Rethrow the exception by encapsulating it while preserving the \n// stack trace\nthrow new IOException($\"File process error{fileName}\", ex);\n```", "```cs\nstatic void OnExportCommand(FileInfo outputfile)\n{\n    var bookmarks = service.GetAll();\n    string json = JsonSerializer.Serialize(bookmarks, new \n    JsonSerializerOptions { WriteIndented = true });\n    File.WriteAllText(outputfile.FullName, json);\n}\n```", "```cs\nstatic void OnExportCommand(FileInfo outputfile)\n{\n    try\n    {\n         var bookmarks = service.GetAll();\n         string json = JsonSerializer.Serialize(bookmarks, new \n         JsonSerializerOptions { WriteIndented = true });\n         File.WriteAllText(outputfile.FullName, json);\n    }\n    catch(JsonException ex)\n    {\n        Helper.ShowErrorMessage([$\"Failed to serialize bookmarks to \n        JSON.\",\n        $\"Error message {ex.Message}\"]);\n    }\n    catch (UnauthorizedAccessException ex)\n    {\n         Helper.ShowErrorMessage([$\"Insufficient permissions to access\n         the file {outputfile.FullName}\",\n          $\"Error message {ex.Message}\"]);\n    }\n    catch (DirectoryNotFoundException ex)\n    {\n         Helper.ShowErrorMessage([$\"The file {outputfile.FullName} \n         cannot be found due to an invalid path\",\n         $\"Error message {ex.Message}\"]);\n    }\n    catch (PathTooLongException ex)\n    {\n         Helper.ShowErrorMessage([$\"The provided path is exceeding the \n         maximum length.\",\n           $\"Error message {ex.Message}\"]);\n     }\n     catch (Exception ex)\n     {\n         Helper.ShowErrorMessage([$\"An unknown exception occurred.\",\n           $\"Error message {ex.Message}\"]);\n     }\n}\n```", "```cs\nexportCommand.SetHandler(async (context) =>\n{\n    FileInfo? outputfileOptionValue = context.ParseResult.\n    GetValueForOption(outputfileOption);\n    var token = context.GetCancellationToken();\n    await OnExportCommand(outputfileOptionValue!, token);\n});\n```", "```cs\nstatic async Task OnExportCommand(FileInfo outputfile, CancellationToken token)\n{\n     try\n     {\n        var bookmarks = service.GetAll();\n        string json = JsonSerializer.Serialize(bookmarks, new \n        JsonSerializerOptions { WriteIndented = true });\n        await File.WriteAllTextAsync(outputfile.FullName, json, \n        token);\n     }\n     catch(OperationCanceledException ex)\n     {\n        var requested = ex.CancellationToken.IsCancellationRequested ? \n        \"Cancellation was requested by you.\": \"Cancellation was NOT \n        requested by you.\";\n        Helper.ShowWarningMessage([\"Operation was cancelled.\", \n        requested, $\"Cancellation reason: {ex.Message}\"]);\n     }\n     catch(JsonException ex)\n// The rest of the method has been removed for brevity.\n```", "```cs\ndotnet add package System.CommandLine.Hosting --prerelease\n```", "```cs\nusing System.CommandLine.Hosting;\nusing Microsoft.Extensions.Hosting;\nvar parser = new CommandLineBuilder(rootCommand)\n            .UseHost(_ => Host.CreateDefaultBuilder(),\n            host =>\n            {\n                host.ConfigureServices(services =>\n                {\n                });\n            })\n            .UseDefaults()\n            .Build();\nreturn await parser.InvokeAsync(args);\n```", "```cs\ndotnet add package Serilog.Extensions.Hosting\n```", "```cs\nservices.AddSerilog();\n```", "```cs\ndotnet add package Serilog.Sinks.Console\ndotnet add package Serilog.Sinks.File\n```", "```cs\nusing Serilog;\nusing System.CommandLine.Hosting;\nusing Microsoft.Extensions.Hosting;\nvar parser = new CommandLineBuilder(rootCommand)\n            .UseHost(_ => Host.CreateDefaultBuilder(),\n            host =>\n            {\n                host.ConfigureServices(services =>\n                {\n                    services.AddSerilog((config) =>\n                    {\n                        config.MinimumLevel.Information();\n                        config.WriteTo.Console();\n                        config.WriteTo.File(\"logs/bookmarkr-.txt\", \n                        rollingInterval:RollingInterval.Day,\n                        restrictedToMinimumLevel:Serilog.Events.\n                        LogEventLevel.Error);\n                        config.CreateLogger();\n                    });\n                });\n            })\n            .UseDefaults()\n            .Build();\nreturn await parser.InvokeAsync(args);\n```", "```cs\ndotnet add package Serilog.Settings.Configuration\n```", "```cs\n<ItemGroup>\n    <None Update=\"appsettings.json\">\n          <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n</ItemGroup>\n```", "```cs\n{\n  \"Serilog\": {\n    \"Using\": [ \"Serilog.Sinks.Console\", \"Serilog.Sinks.File\" ],\n    \"MinimumLevel\": {\n      \"Default\": \"Information\",\n      \"Override\": {\n        \"Microsoft\": \"Warning\",\n        \"System\": \"Warning\"\n      }\n    },\n    \"WriteTo\": [\n      {\n        \"Name\": \"Console\",\n        \"Args\": {\n          \"outputTemplate\": \"[{Timestamp:HH:mm:ss} {Level:u3}] \n          {Message:lj}{NewLine}{Exception}\"\n        }\n      },\n      {\n        \"Name\": \"File\",\n        \"Args\": {\n          \"path\": \"logs/log-.txt\",\n          \"rollingInterval\": \"Day\",\n          \"outputTemplate\": \"[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} \n          {Level:u3}] {Message:lj}{NewLine}{Exception}\"\n        }\n      }\n    ],\n    \"Enrich\": [ \"FromLogContext\", \"WithMachineName\", \"WithThreadId\" ]\n  }\n}\n```", "```cs\nusing Microsoft.Extensions.Configuration;\n// Only the body of the ConfigureServices is shown here for clarity.\n// To see the full version of the code, please refer to the GitHub \n// repo of the book.\nservices.AddSerilog((config) =>\n{\n      var configuration = new ConfigurationBuilder()\n              .SetBasePath(Directory.GetCurrentDirectory())\n              .AddJsonFile(\"appsettings.json\")\n              .Build();\n      config.ReadFrom.Configuration(configuration);\n});\n```", "```cs\n<date and time> | Bookmark updated | name changed from '<old name>' to '<new name>' for URL '<Url>'\n```", "```cs\npublic BookmarkConflictModel? Import(Bookmark bookmark)\n{\n    var conflict = _bookmarks.FirstOrDefault(b => b.Url == bookmark.\n    Url && b.Name != bookmark.Name);\n    if(conflict is not null)\n    {\n        var conflictModel = new BookmarkConflictModel { OldName = \n        conflict.Name, NewName = bookmark.Name, Url = bookmark.Url };\n        conflict.Name = bookmark.Name; // this updates the name of the \n                                       // bookmark.\n         return conflictModel;\n    }\n    else\n    {\n        _bookmarks.Add(bookmark);\n        return null;\n    }\n}\n```", "```cs\npublic class BookmarkConflictModel\n{\n    public string? OldName { get; set; }\n    public string? NewName { get; set; }\n    public string? Url { get; set; }\n}\n```", "```cs\nstatic void OnImportCommand(FileInfo inputfile)\n{\n    string json = File.ReadAllText(inputfile.FullName);\n    List<Bookmark> bookmarks = JsonSerializer.\n    Deserialize<List<Bookmark>>(json) ?? new List<Bookmark>();\n    foreach(var bookmark in bookmarks)\n    {\n        var conflict = service.Import(bookmark);\n        if (conflict is not null)\n        {\n              Log.Information($\"{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\")} | Bookmark updated | name changed from '{conflict.OldName}' to '{conflict.NewName}' for URL '{conflict.Url}'\");\n        }\n    }\n}\n```", "```cs\nstatic void FreeSerilogLoggerOnShutdown()\n{\n    // This event is raised when the process is about to exit, \n    // allowing you to perform cleanup tasks or save data.\n    AppDomain.CurrentDomain.ProcessExit += (s, e) => \n    ExecuteShutdownTasks();\n    // This event is triggered when the user presses Ctrl+C or \n    // Ctrl+Break. While it doesn't cover all shutdown scenarios, it's \n    // useful for handling user-initiated terminations.\n    Console.CancelKeyPress += (s, e) => ExecuteShutdownTasks();\n}\n// Code to execute before shutdown\nstatic void ExecuteShutdownTasks()\n{\n    Console.WriteLine(\"Performing shutdown tasks...\");\n    // Perform cleanup tasks, save data, etc.\n    Log.CloseAndFlush();\n}\n```"]