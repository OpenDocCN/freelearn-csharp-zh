<html><head></head><body>
  <div id="_idContainer305" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-81" class="chapterTitle">Implementing Movement and Spawning</h1>
    <p class="normal">In the previous chapter, we learned about the basics of scripting, so now let’s create the first script for our game. We will see the basics of how to move objects through scripting using the <code class="inlineCode">Transform</code> component, which will be applied to the movement of our player with the keyboard keys, the constant movement of bullets, and other object movements. Also, we will see how to create and destroy objects during the game, such as the bullets our player and enemy shoot and the enemy wave spawners. These actions can be used in several other scenarios, so we will explore a few to reinforce the idea. </p>
    <p class="normal">In this chapter, we will examine the following scripting concepts: </p>
    <ul>
      <li class="bulletList">Implementing movement</li>
      <li class="bulletList">Implementing spawning</li>
      <li class="bulletList">Using the new Input System</li>
    </ul>
    <p class="normal">We will start by scripting components to move our character through the keyboard, and then we will make our player shoot bullets. Something to consider is that we are going to first see the C# version and then show the Visual Scripting equivalent in each section.</p>
    <h1 id="_idParaDest-82" class="heading-1">Implementing movement</h1>
    <p class="normal">Almost every <a id="_idIndexMarker285"/>object in the game moves one way or another: the player character with the keyboard; the enemies through AI; the bullets that simply move forward; and so on. There are several ways of moving objects in Unity, so we will start with the simplest one, that is, through the <code class="inlineCode">Transform</code> component.</p>
    <p class="normal">In this section, we will examine the following movement concepts:</p>
    <ul>
      <li class="bulletList">Moving objects through <code class="inlineCode">Transform</code></li>
      <li class="bulletList">Using input</li>
      <li class="bulletList">Understanding Delta Time</li>
    </ul>
    <p class="normal">First, we will <a id="_idIndexMarker286"/>explore how to access the <code class="inlineCode">Transform</code> component in our script to drive the player movement, to later apply movement based on the player’s keyboard input. Finally, we are going to explore the concept of Delta Time to make sure the movement speeds are consistent on every computer. We are going to start learning about the <code class="inlineCode">Transform</code> API to make a simple movement script.</p>
    <h2 id="_idParaDest-83" class="heading-2">Moving objects through Transform</h2>
    <p class="normal"><code class="inlineCode">Transform</code> is the <a id="_idIndexMarker287"/>component that holds the translation, rotation, and scale of the object, so every movement system such as physics or pathfinding <a id="_idIndexMarker288"/>will affect this component. Sometimes, we want to move the object in a specific way according to our game by creating our own script, which will handle the movement calculations we need and modify <code class="inlineCode">Transform</code> to apply them.</p>
    <p class="normal">One concept implied here is that components alter other components. The main way of coding in Unity is to create components that interact with other components. Here, the idea is to create one that accesses another and tells it to do something: in this case, to move. To create a script that tells <code class="inlineCode">Transform</code> to move, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create and add a <a id="_idIndexMarker289"/>script called <code class="inlineCode">PlayerMovement</code> to our character, like we did in the previous chapter. In this case, it would be the animated 3D model we downloaded previously (drag the 3D asset from the <strong class="screenText">Project</strong> view to the scene). Remember to move the script to the <strong class="screenText">Scripts</strong> folder after creation:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.1: Creating a Player Movement script in the character</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Double-click the created script asset to open an IDE to edit the code.</li>
      <li class="numberedList">We are <a id="_idIndexMarker290"/>moving, and the movement is applied to every frame. So this script will use only the <code class="inlineCode">Update</code> function or method, and we can remove <code class="inlineCode">Start</code> (it is a good practice to remove the unused functions):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.2: A component with just the Update event function</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">To move our object along its local forward axis (<em class="italic">z</em> axis), add the <code class="inlineCode">transform.Translate(0,0,1);</code> line to the <code class="inlineCode">Update</code> function, as shown in <em class="italic">Figure 6.3</em>:</li>
    </ol>
    <div class="note">
      <p class="normal">Every component inherits a <code class="inlineCode">Transform</code> field (to be specific, a <strong class="keyWord">getter</strong>) that is a reference to the <code class="inlineCode">Transform</code> of the GameObject the component is placed in; it represents the sibling <code class="inlineCode">Transform</code> of our component. Through this field, we can access the <code class="inlineCode">Translate </code>function of the <code class="inlineCode">Transform</code>, which will receive the offset to apply to the x, y, and z local coordinates.</p>
    </div>
    <figure class="mediaobject"><img src="../Images/B18585_06_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.3: A simple Move Forward script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Save the file and play the game to see the movement. Ensure the camera is pointing at the character to properly see the effect of the script.</li>
    </ol>
    <p class="normal">You will <a id="_idIndexMarker291"/>notice that the player is moving too fast. That’s because we are using a fixed speed of 1 meter, and because <code class="inlineCode">Update</code> is executing all frames, we are moving 1 meter per frame. In a standard 30 FPS game, the player will move 30 meters per second, which is too much, but probably our computer is running the game with way more FPS than that. We can control the player’s speed by adding a <code class="inlineCode">speed</code> field and using the value set in the editor instead of the fixed value of 1. You can see one way to do this in the <em class="italic">Figure 6.4</em>, but remember the other options we discussed in <em class="chapterRef">Chapter 5</em>,<em class="italic"> Introduction to C# and Visual Scripting</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.4: Creating a speed field and using it as the z speed of the movement script</p>
    <p class="normal">Now if you <a id="_idIndexMarker292"/>save the script to apply the changes and set the <strong class="screenText">Speed</strong> of the player in the Editor, you can play the game and see the results. In my case, I used <code class="inlineCode">0.1</code>, but you might need another value (more on this in the <em class="italic">Understanding Delta Time</em> section):</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.5: Setting speed of 0.1 meters per frame </p>
    <p class="normal">Now, for the Visual Scripting version, first remember to not mix the C# and Visual Scripting versions of our scripts, not because it is not possible, but because we want to keep things simple for now. So, you can either delete the script from the player object and add the Visual Scripting version, or you can create two player objects and enable and disable them to try both versions. I recommend creating one project for the C# version of the scripts and then creating a second project to experiment with the Visual Script version.</p>
    <p class="normal">The Visual Scripting Graph of this script will look like the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.6: Setting a speed of 0.1 meters per frame</p>
    <p class="normal">As you <a id="_idIndexMarker293"/>can see, we added a <strong class="screenText">Script Machine</strong> component to our <code class="inlineCode">Player</code> GameObject. Then, we pressed the <strong class="screenText">New</strong> button in the <strong class="screenText">Script Machine</strong> component to create a new <strong class="screenText">Graph</strong> called <code class="inlineCode">PlayerMovement</code>. We also created a <strong class="screenText">Float</strong> variable called <code class="inlineCode">speed</code> with the value of <code class="inlineCode">0.1</code>. In the <strong class="screenText">Graph</strong>, we added the <strong class="screenText">On Update</strong> event node and attached it to the <strong class="screenText">Translate (X,Y,Z)</strong> node of the <strong class="screenText">Transform</strong>, which, similarly to the C# version, will move along the local axes of the object. Finally, we connected the <strong class="screenText">Z</strong> parameter pin of <strong class="screenText">Translate</strong> to the <code class="inlineCode">GetVariable</code> node representing the speed we created in the GameObject. If you compare this <strong class="screenText">Graph</strong> with the code we used in the C# version, they are essentially the same <strong class="screenText">Update</strong> method and <code class="inlineCode">Translate</code> function. If you don’t remember how to create this <strong class="screenText">Graph</strong>, you can go back to <em class="chapterRef">Chapter 5</em>,<em class="italic"> Introduction to C# and Visual Scripting</em>, to recap the process.</p>
    <p class="normal">You will notice that the player will move automatically. Now let’s see how to execute the movement based on <strong class="keyWord">player input</strong> such as the keyboard and mouse.</p>
    <h2 id="_idParaDest-84" class="heading-2">Using Input</h2>
    <p class="normal">Unlike NPCs, we <a id="_idIndexMarker294"/>want the player’s movement to be driven by the player’s input, based on which keys they press, the mouse movement, and so on. To know whether a certain key has been pressed, such as the <em class="italic">Up</em> arrow, we can use the <code class="inlineCode">Input.GetKey(KeyCode.W)</code> line, which will return a Boolean, indicating whether the key specified in the <code class="inlineCode">KeyCode</code> enum is pressed, which is <em class="italic">W</em> in this case. We can combine the <code class="inlineCode">GetKey</code> function with an <code class="inlineCode">If</code> statement to make the translation execute when the key is pressed.</p>
    <p class="normal">Let’s start by implementing the keyboard movement by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Make the forward movement execute only when the <em class="italic">W</em> key is pressed with the code, as shown in the next screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.7: Conditioning the movement until the W key is pressed </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">We can add <a id="_idIndexMarker295"/>other movement directions with more <code class="inlineCode">If</code> statements to move backward and <em class="keystroke">A</em> and <em class="keystroke">D</em> to move left and right, as shown in the following screenshot. Notice how we used the minus sign to inverse the speed when we needed to move in the opposite axis direction:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.8: Checking the W, A, S, and D key pressure</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">In case you also want to consider the arrow keys, you can use an <code class="inlineCode">OR</code> inside <code class="inlineCode">if</code>, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.9: Checking the W, A, S, D, and arrow key pressure </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Save the changes and test the movement in <strong class="screenText">Play</strong> mode.</li>
    </ol>
    <p class="normal">Something to take into account is that, first, we have another way to map several keys to a single action by configuring the Input Manager—a place where action mappings can be created. Second, at the time of writing this, Unity has released a new Input System that is more extensible than this one. </p>
    <p class="normal">For now, we will use this one because it is simple enough to make our <a id="_idIndexMarker296"/>introduction to scripting with Unity easier, but in games with complex input, it is recommended to look for more advanced tools.</p>
    <p class="normal">Now, for the Visual Scripting version, the graph will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.10: Input movement in Visual Scripting</p>
    <p class="normal">As you can see, the graph has grown in size considerably compared to the C# version, which serves as an example of why developers prefer to code instead of using visual tools. Of course, we have several ways to split this graph into smaller chunks and make it more readable, and also consider I needed to squeeze the nodes together to be in the same image. Also, in the graph, we only see the example graph to move forward and backward, but you can easily extrapolate the necessary steps for lateral movement based on this one. As usual, you can also check the GitHub repository of the project to see the completed files.</p>
    <p class="normal">Looking at the graph, you can quickly observe all the similarities to the C# version; we chained <code class="inlineCode">If</code> nodes to the <strong class="screenText">On Update </strong>event node in a way that if the first <code class="inlineCode">If</code> node condition is true, it will execute the <strong class="screenText">Translate</strong> in the player’s forward direction. If that condition is false, we chained the <strong class="screenText">False</strong> output node to another <strong class="screenText">If</strong> that checks the pressure of <a id="_idIndexMarker297"/>the other keys, and in that case, we moved backward using the <strong class="screenText">Multiply (Scalar)</strong> node to inverse the speed. </p>
    <p class="normal">You can notice nodes like <code class="inlineCode">If</code> that have more than one <strong class="keyWord">Flow Output </strong>pin to branch the execution of the code. </p>
    <p class="normal">You can also notice the usage of the <strong class="screenText">GetKey (Key)</strong> node, the Visual Scripting version of the same <strong class="screenText">GetKey</strong> function we used previously. When looking at this node in the <strong class="screenText">Search</strong> box, you will see all the versions of the function, and in this case, we selected the <strong class="screenText">GetKey(Key) </strong>version; the one that receives a name (string) works differently, and we are not covering that one:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.11: All versions of Input GetKey</p>
    <p class="normal">We also used the <code class="inlineCode">Or</code> node to combine the two <strong class="screenText">GetKey (Key)</strong> functions into one condition to give to the <code class="inlineCode">If</code>. These conditional operators can be found in the <strong class="screenText">Logic</strong> category of the <strong class="screenText">Search</strong> box:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.12: The Boolean Logic operators</p>
    <p class="normal">One thing to highlight is the usage of the <strong class="screenText">Multiply</strong> node to multiply the value of the speed variable by –1. We needed to create a <strong class="screenText">Float Literal</strong> node to represent the –1 value. Next, surely all programmers will notice some limitations regarding how we used the <code class="inlineCode">If</code> node’s <code class="inlineCode">True</code> and <code class="inlineCode">False</code> output pins, but we will address that in a moment. Finally, consider that this implementation has the problem of blocking the second input read if the <a id="_idIndexMarker298"/>first is successful; we will discuss a way to fix this when we add rotation to our character later in this section.</p>
    <p class="normal">Now, let’s implement the mouse controls. In this section, we will only cover rotation with mouse movement; we will shoot bullets in the next section: <em class="italic">Implementing spawning</em>. In the case of mouse movement, we can get a value saying how much the mouse has moved both horizontally and vertically. This value isn’t a Boolean but a number: a type of input usually known as an <strong class="keyWord">axis</strong>.<strong class="screenText"> </strong>The value of an axis will indicate the intensity of the movement, and the sign of that number will indicate the direction. For example, if Unity’s <code class="inlineCode">"Mouse X"</code> axis says <code class="inlineCode">0.5</code>, it means that the mouse moved to the right with a moderate speed, but if it says <code class="inlineCode">-1</code>, it moved quickly to the left, and if there is no movement, it will say <code class="inlineCode">0</code>. The same goes for sticks in gamepads; the axis named <strong class="keyWord">Horizontal</strong> represents the horizontal movement of the left stick in common joysticks, so if the player pulls the stick fully to the left, it will say <code class="inlineCode">-1</code>.</p>
    <p class="normal">We can create our own axes to map other common joystick pressure-based controls, but for our game, the default ones are enough. To detect mouse movement, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Use the <code class="inlineCode">Input.GetAxis</code> function inside <code class="inlineCode">Update</code>, next to the movement <code class="inlineCode">if</code> statements, as shown in the following screenshot, to store the value of this frame’s mouse movement into a variable:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.13: Getting the horizontal movement of the mouse</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Use the <code class="inlineCode">transform.Rotate</code> function to rotate the character. This function receives the degrees to rotate in the x, y, and z axes. In this case, we need to rotate horizontally, so we will use the mouse movement value as the y-axis rotation, as shown in the next screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.14: Rotating the object horizontally based on mouse movement</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">If you save <a id="_idIndexMarker299"/>and test this, you will notice that the character will rotate but very quickly or slowly, depending on your computer. Remember, this kind of value needs to be configurable, so let’s create a <code class="inlineCode">rotationSpeed</code> field to configure the speed of the player in the editor:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.15: The speed and rotation speed fields</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Now we need to multiply the mouse movement value by the speed, so, depending on the <code class="inlineCode">rotationSpeed</code>, we can increase or reduce the rotation amount. As an example, if we set a value of <code class="inlineCode">0.5</code> in the rotation speed, multiplying that value by the mouse movement will make the object rotate at half the previous speed, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.16: Multiplying the mouse movement by the rotation speed </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Save the <a id="_idIndexMarker300"/>code and go back to the editor to set the rotation speed value. If you don’t do this, the object won’t rotate because the default value of the float type fields is <code class="inlineCode">0</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.17: Setting the rotation speed</p>
    <p class="normal">The Visual Scripting additions to achieve rotation will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.18: Rotating in Visual Scripting</p>
    <p class="normal">The first thing to notice here is the usage of the <strong class="screenText">Sequence</strong> node. An output pin can only be attached to <a id="_idIndexMarker301"/>one other node, but in this case, <strong class="screenText">On Update</strong> needs to do two different things, to rotate and to move, each one being independent of the other. <strong class="screenText">Sequence</strong> is a node that will execute all its output pins one after the other, regardless of the results of each one. You can specify the number of output pins in the <strong class="screenText">Steps</strong> input box; in this example, two is enough.</p>
    <p class="normal">In the output pin <code class="inlineCode">0</code>, the first one, we added the rotation code, which is pretty self-explanatory given it is essentially the same as the movement code with slightly different nodes (<strong class="screenText">Rotate (X, Y, Z)</strong> and <strong class="screenText">GetAxis</strong>). Then, to Output Pin 1, we attached the <code class="inlineCode">If</code> that checks the movement input—the one we did at the beginning of this section. This will cause the rotation to be executed first and the movement second. </p>
    <p class="normal">Regarding the limitation we mentioned before, it’s basically the fact we cannot execute both <strong class="screenText">Forward</strong> and <strong class="screenText">Backward</strong> rotations, given that if the forward movement keys are pressed, the first <code class="inlineCode">If</code> will be true. Because the backward key rotation is checked in the false output pin, they won’t be checked in such cases. Of course, as our first movement script it might be enough but consider the lateral movement. If we continue the <code class="inlineCode">If</code> chaining using <code class="inlineCode">True</code> and <code class="inlineCode">False</code> output pins, we will have a scenario where we can only move in one direction. So we cannot combine, for example, <code class="inlineCode">Forward</code> and <code class="inlineCode">Right</code> to move diagonally.</p>
    <p class="normal">A simple solution to this issue is to put the <code class="inlineCode">If</code> nodes in the sequence instead of chaining them, so all the <code class="inlineCode">If</code> nodes are checked, as the original C# did. You can see an example of this in the next image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.19: Sequencing Ifs</p>
    <p class="normal">Something to <a id="_idIndexMarker302"/>consider here is that the chaining of the <code class="inlineCode">Ifs</code> and any kind of node can be removed by right-clicking the circle pins on both ends of the line that connects them. Now that we have completed our movement script, we need to refine it to work in every machine by exploring the concept of Delta Time.</p>
    <h2 id="_idParaDest-85" class="heading-2">Understanding Delta Time</h2>
    <p class="normal">Unity’s <strong class="screenText">Update</strong> <a id="_idIndexMarker303"/>loop executes as fast as the computer can. You can <a id="_idIndexMarker304"/>specify in Unity the desired frame rate, but achieving that depends exclusively on whether your computer can reach that, which depends on lots of factors, not only hardware, so you cannot expect to always have consistent FPS. You must code your scripts to handle every possible scenario. Our current script is moving at a certain speed per frame, and the <em class="italic">per frame</em> part is important here. </p>
    <p class="normal">We have set the movement speed to 0.1, so if my computer runs the game at 120 FPS, the player will move 12 meters per second. Now, what happens on a computer where the game runs at 60 FPS? As you may guess, it will move only 6 meters per second, making our game have inconsistent behavior across different computers. This is where Delta Time saves the day.</p>
    <p class="normal"><strong class="screenText">Delta Time</strong> is a value that tells us how much time has passed since the previous frame. This time depends a lot on our game’s graphics, number of entities, physics bodies, audio, and countless aspects that will dictate how fast your computer can process a frame. As an example, if your game runs at 10 FPS, it means that, in a second, your computer <a id="_idIndexMarker305"/>can process the <code class="inlineCode">Update</code> loop 10 times, meaning that each loop takes approximately <code class="inlineCode">0.1</code> seconds; in the frame, Delta Time will provide that value. In the next diagram, you can see an example of 4 frames taking different times to process, which can happen in real-life cases:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.20: Delta Time values varying in different frames of the game </p>
    <p class="normal">Here, we need to code in such a way as to change the <em class="italic">per frame</em> part of the movement to <em class="italic">per second</em>; we need to have consistent movement per second across different computers. A way to do that is to move proportionally to the Delta Time: the higher the Delta Time value, the longer that frame is, and the further the movement should be to match the real time that has passed since the last update. We can think about our <code class="inlineCode">speed</code> field’s current value in terms of <code class="inlineCode">0.1</code> meters per second; our Delta Time saying <code class="inlineCode">0.5</code> means that half a second has passed, so we should move half the speed, <code class="inlineCode">0.05</code>. </p>
    <p class="normal">After two frames a second have passed, the sum of the movements of the frames (2 x 0.05) matches the target speed, <code class="inlineCode">0.1</code>. Delta Time can be interpreted as the percentage of a second that has passed.</p>
    <p class="normal">To make the Delta Time affect our movement, we should simply multiply our speed by Delta Time every frame because the Delta Time can be different every frame, so let’s do that:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We access <a id="_idIndexMarker306"/>Delta Time using Time.deltaTime. We can start affecting the movement by multiplying the Delta Time in every Translate:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.21: Multiplying speed by Delta Time</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">We can do the same with the rotation speed, by chaining the mouse and speed multiplications:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.22: Applying Delta Time to the rotation code</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">If you save and play the game, you will notice that the movement will be slower than before. That’s because now <code class="inlineCode">0.1</code> is the movement per second, meaning <code class="inlineCode">10</code> centimeters per second, which is pretty slow; try raising those values. In my case, <code class="inlineCode">10</code> for speed and <code class="inlineCode">180</code> for rotation speed was enough, but the rotation speed depends on the player’s preferred sensibility, which can be configurable, but let’s keep that for another time.</li>
    </ol>
    <p class="normal">The Visual Scripting change for rotation will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.23: Applying Delta Time to Rotate Visual Script</p>
    <p class="normal">For movement, you can easily extrapolate from this example or remember to check the project on GitHub. We simply chained another <strong class="screenText">Multiply</strong> node with <strong class="screenText">Get Delta Time</strong>.</p>
    <p class="normal">We just learned <a id="_idIndexMarker307"/>how to mix the Input System of Unity, which tells us about the state of the keyboard, mouse, and other input devices, with the basic <code class="inlineCode">Transform</code> movement functions. This way, we can start making our game feel more dynamic. </p>
    <p class="normal">Now that we have finished the player’s movement, let’s discuss how to make the player shoot bullets using <code class="inlineCode">Instantiate</code> functions.</p>
    <h1 id="_idParaDest-86" class="heading-1">Implementing spawning</h1>
    <p class="normal">We have <a id="_idIndexMarker308"/>created lots of objects in the editor that define our level, but once the game begins, and according to the player’s actions, new objects must be created to better fit the scenarios generated by player interaction. Enemies might need to appear after a while, or bullets must be created according to the player’s input; even when enemies die, there’s a chance of spawning a power-up. This means that we cannot create all the necessary objects beforehand but should create them dynamically, and that’s done through scripting.</p>
    <p class="normal">In this section, we will examine the following spawning concepts:</p>
    <ul>
      <li class="bulletList">Spawning objects</li>
      <li class="bulletList">Timing actions</li>
      <li class="bulletList">Destroying objects</li>
    </ul>
    <p class="normal">We will start <a id="_idIndexMarker309"/>seeing the Unity <code class="inlineCode">Instantiate</code> function, which allows us to create instances of Prefabs at runtime, such as when pressing a key, or in a time-based fashion, such as making our enemy spawn bullets once every certain amount of time. Also, we will learn how to destroy these objects to prevent our scene from starting to perform badly due to too many objects being processed.</p>
    <p class="normal">Let’s start with how to shoot bullets according to the player’s input.</p>
    <h2 id="_idParaDest-87" class="heading-2">Spawning objects</h2>
    <p class="normal">To spawn an object in runtime or <strong class="screenText">Play</strong> mode, we need a description of the object, which components it has, and its settings and possible sub-objects. You might be thinking about Prefabs here, and you are right; we will use an instruction that will tell Unity to create an <a id="_idIndexMarker310"/>instance of a Prefab via scripting. Remember that an instance of a Prefab is an object created based on the Prefab—basically a clone of the original one.</p>
    <p class="normal">We will start with shooting player’s bullets, so first let’s create the bullet Prefab by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a sphere in GameObject | 3D Object | Sphere. You can replace the sphere mesh with another bullet model if you want, but we will keep the sphere in this example for now.</li>
      <li class="numberedList">Rename the sphere <code class="inlineCode">Bullet</code>.</li>
      <li class="numberedList">Create a material by clicking on the <strong class="screenText">+</strong> button of the Project window, choosing the option <strong class="screenText">Material</strong>, and calling it <code class="inlineCode">Bullet</code>. Remember to place it inside the <code class="inlineCode">Materials</code> folder.</li>
      <li class="numberedList">Check the <strong class="screenText">Emission</strong> checkbox in the material and set the <strong class="screenText">Emission Map</strong> and <strong class="screenText">Base Map</strong> colors to red. Remember, the emission color will make the bullet shine, especially with the bloom effect in our post-processing volume:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.24: Creating a red bullet material with emission color </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Apply the <strong class="screenText">Material</strong> to the <strong class="screenText">Sphere</strong> by dragging the material to it.</li>
      <li class="numberedList">Set the <a id="_idIndexMarker311"/>Scale to a smaller value—<code class="inlineCode">0.3, 0.3, 0.3</code> worked in my case.</li>
      <li class="numberedList">Create a script called <code class="inlineCode">ForwardMovement</code> to make the bullet constantly move forward at a fixed speed. You can create it both with C# and Visual Scripting, but for simplicity, we are only going to use C# in this case.<div class="packt_tip">
          <p class="normal">I suggest you try to solve this by yourself first and look at the screenshot in the next step with the solution later as a little challenge to recap the movement concepts we saw previously. If you don’t recall how to create a script, please look at <em class="chapterRef">Chapter 5</em>, <em class="italic">Introduction to C# and Visual Scripting</em>, and check the previous section to see how to move objects.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">The next screenshot shows you what the script should look like:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.25: A simple ForwardMovement script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Add the script (if not already there) to the bullet and set the speed to a value you see fit. Usually, bullets are faster than the player but that depends on the <a id="_idIndexMarker312"/>game experience you want to get. In my case, <code class="inlineCode">20</code> worked fine. Test it by placing the bullet near the player and playing the game:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.26: A ForwardMovement script in the bullet</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">Drag the bullet <code class="inlineCode">GameObject</code> instance to the <code class="inlineCode">Prefabs</code> folder to create a <strong class="screenText">Bullet </strong>Prefab. Remember that the Prefab is an asset that has a description of the created bullet, like a blueprint of how to create a bullet:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.27: Creating a Prefab</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">Remove the original bullet from the scene; we will use the Prefab to create bullets when the player presses a key (if ever).</li>
    </ol>
    <p class="normal">Now that <a id="_idIndexMarker313"/>we have our bullet Prefab, it is time to instantiate it (clone it) when the player presses a key. To do that, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create and add a script to the player’s <code class="inlineCode">GameObject</code> called <code class="inlineCode">PlayerShooting</code> and open it.</li>
      <li class="numberedList">We need a way for the script to have access to the Prefab to know which Prefab to use from probably the dozens we will have in our project. All of the data our script needs, which depends on the desired game experience, is in the form of a field, such as the speed field used so far. So in this case, we need a field of the <code class="inlineCode">GameObject</code> type—a field that can reference or point to a specific Prefab, which can be set using the editor. </li>
      <li class="numberedList">Adding the field code would look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.28: The Prefab reference field</p>
    <div class="note">
      <p class="normal">As you might have guessed, we can use the <code class="inlineCode">GameObject</code> type to not only reference Prefabs but also other objects. Imagine an enemy AI needing a reference to the player object to get its position, using <code class="inlineCode">GameObject</code> to link the two objects. The trick here is considering that Prefabs are just regular GameObjects that live outside the scene; you cannot see them, but they are in memory, ready to be copied or instantiated. You will only see them through copies or instances that are placed in the scene with scripting or via the editor, as we have done so far.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In the editor, click on the circle toward the right of the property and select the <code class="inlineCode">Bullet</code> Prefab. Another option is to just drag the <code class="inlineCode">Bullet</code> Prefab to the property. This way, we tell our script that the bullet to shoot will be that one. Remember <a id="_idIndexMarker314"/>to drag the Prefab and not the bullet in the scene (that one should be deleted by now):</li>
    </ol>
    <figure class="mediaobject"> <img src="../Images/B18585_06_29.png" alt=""/></figure>
    <figure class="mediaobject">Figure 6.29: Setting the Prefab reference to point the bullet</figure>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">We will shoot the bullet when the player presses the left mouse button, so place the proper if statement to handle that in the Update event function, like the one shown in the next screenshot: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.30: Detecting the pressure of the left mouse button </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">You will notice that this time, we used GetKeyDown instead of GetKey, the former being a way to detect the exact frame the pressure of the key started; this if statement will execute its code only in that frame, and until the key is released and re-pressed, it won’t enter again. This is one way to prevent bullets from spawning in every frame, but just for fun, you can try using GetKey instead to check how it would behave. Also, KeyCode.Mouse0 is the mouse button number that belongs to left-click, KeyCode.Mouse1 is the right-click, and KeyCode.Mouse2 is the middle click.</li>
      <li class="numberedList">Use the Instantiate function to clone the Prefab, passing the reference to it as the first parameter. This will <a id="_idIndexMarker315"/>create a clone of the previously mentioned Prefab that will be placed in the scene:<p class="packt_figref"><img src="../Images/B18585_06_31.png" alt=""/></p>
        <p class="packt_figref">Figure 6.31: Instantiating the Prefab</p>
      </li>
    </ol>
    <p class="normal">If you save the script and play the game, you will notice that when you press the mouse, a bullet will be spawning, but probably not in the place you are expecting. If you don’t see it, try to check the Hierarchy for new objects; it will be there. The problem here is that we didn’t specify the desired spawn position, and we have two ways of setting that, which we will see in the next steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The first way is to use the <code class="inlineCode">transform.position</code> and <code class="inlineCode">transform.rotation</code> inherited fields from <code class="inlineCode">MonoBehaviour</code>, which will tell us our current position and rotation. We can pass them as the second and third parameters of the <code class="inlineCode">Instantiate</code> function, which will understand that this is the place we want our bullet to appear. Remember that it is important to set the rotation to make the bullet face the same direction as the player, so it will move that way:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.32: Instantiating the Prefab in our position and rotation</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">The second way is by using the previous version of <code class="inlineCode">Instantiate</code>, but saving the reference returned by the function, which will be pointing to the clone of the Prefab. This allows us to change whatever we want from it. In this case, we will need the <a id="_idIndexMarker316"/>following three lines; the first will instantiate and capture the clone reference, the second will set the position, and the third the rotation. We will also use the <code class="inlineCode">transform.position</code> field of the clone, but this time to change its value by using the <code class="inlineCode">=</code> (assignment) operator:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.33: The longer version of instantiating a Prefab in a specific position </p>
    <p class="normal">Remember that you can check the project’s GitHub repository linked in the <em class="italic">Preface</em> to see the full script finished. Now you can save the file with one of the versions and try to shoot.</p>
    <p class="normal">If you try the script so far, you should see the bullet spawn in the player’s position, but in our case, it will probably be the floor. The problem here is that the player’s character pivot is there, and usually, every humanoid character has the pivot in their feet. We have several ways to fix that. The most flexible one is to create a <strong class="keyWord">Shoot Point</strong>, an empty GameObject child of the player, placed in the position we want the bullet to spawn. We can use the position of that object instead of the player’s position by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an empty <code class="inlineCode">GameObject</code> in <strong class="screenText">GameObject | Create Empty</strong>. Rename it <code class="inlineCode">ShootPoint</code>.</li>
      <li class="numberedList">Make it a child of the player’s GameObject and place it where you want the bullet to appear, probably a little higher and further forward:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.34: An empty ShootPoint object placed inside the character</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">As usual, to access the data of another object, we need a reference to it, such as the <a id="_idIndexMarker317"/>Prefab reference, but this time it needs to point to our shoot point. We can create another <code class="inlineCode">GameObject</code> type field, but this time drag <code class="inlineCode">ShootPoint</code> instead of the Prefab. The script and the object set would look as follows:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_35.png" alt=""/><img src="../Images/B18585_06_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.35: The Prefab and ShootPoint fields and how they are set in the editor </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">We can access the position of the <code class="inlineCode">ShootPoint</code> by using the <code class="inlineCode">transform.position</code> field of it again, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.36: The Prefab and ShootPoint fields and how they are set in the editor </p>
    <p class="normal">The Visual <a id="_idIndexMarker318"/>Scripting version of <strong class="screenText">ForwardMovement</strong> will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.37: ForwardMovement with Visual Scripting</p>
    <p class="normal">And <code class="inlineCode">PlayerShooting</code> will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.38: Instantiating in the PlayerShooting Visual Script</p>
    <p class="normal">As you can see, we added a second <strong class="screenText">Script Machine</strong> component with a new graph called <strong class="screenText">Player Shooting</strong>. We also added a new variable, <code class="inlineCode">bulletPrefab</code>, of type <code class="inlineCode">GameObject</code> and dragged the <strong class="screenText">Bullet</strong> Prefab to it, and a second <code class="inlineCode">GameObject</code> typed variable called <code class="inlineCode">shootPoint</code>, to have the reference to the bullet’s spawn position. The rest of the script is essentially <a id="_idIndexMarker319"/>the counterpart of the C# version without any major differences. Something to highlight here is how we connected the <code class="inlineCode">Transform GetPosition</code> and <code class="inlineCode">Transform GetRotation</code> nodes to the <code class="inlineCode">GetVariable</code> node belonging to the <code class="inlineCode">shootPoint</code>; in this way, we are accessing the position and rotation of the shooting point. If you don’t specify that, it will use the player’s position and rotation, which in the case of our model is in the player’s character’s feet.</p>
    <p class="normal">You will notice that now shooting and rotating with the mouse has a problem; when moving the mouse to rotate, the pointer will fall outside the <strong class="screenText">Game</strong> View, and when clicking, you will accidentally click the editor, losing the focus on the <strong class="screenText">Game</strong> View, so you will need to click the <strong class="screenText">Game</strong> View again to regain focus and use input again. A way to prevent this is to disable the cursor while playing. To do this, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a <code class="inlineCode">Start</code> event function to our Player Movement Script.</li>
      <li class="numberedList">Add the two lines you can see in the following screenshot to your script. The first one will make the cursor visible, and the second one will lock it in the middle of the screen, so it will never abandon the <strong class="screenText">Game</strong> View. Consider the latter; you will need to reenable the cursor when you switch back to the main menu or the pause menu, to allow the mouse to click the UI buttons:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.39: Disabling the mouse cursor</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Save and <a id="_idIndexMarker320"/>test this. If you want to stop the game, you could either press <em class="keystroke">Ctrl</em> + <em class="keystroke">Shift</em> + <em class="keystroke">P</em> (<em class="keystroke">Command</em> + <em class="keystroke">Shift</em> + <em class="keystroke">P</em> on Mac) or press the <em class="keystroke">Esc</em> key to reenable the mouse. Both options only work in the editor; in the real game, you will need to reset <code class="inlineCode">Cursor.visible</code> to <code class="inlineCode">true</code> and <code class="inlineCode">Cursor.lockState</code> to <code class="inlineCode">CursorLockMode.None</code>.</li>
      <li class="numberedList">The Visual Scripting equivalent will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_41.png" alt=""/></figure>
    <p class="packt_figref"> Figure 6.40: Disabling the mouse cursor in Visual Scripting</p>
    <p class="normal">Now that we have covered the basics of object spawning, let’s see an advanced example by combining it with timers.</p>
    <h2 id="_idParaDest-88" class="heading-2">Timing actions</h2>
    <p class="normal">Not entirely related to spawning, but usually used together, timing actions is a common task in video games. The idea is to schedule something to happen later; maybe we want the bullet to <a id="_idIndexMarker321"/>be destroyed after a while to prevent memory overflow, or we want to control the spawn rate of enemies or when they should spawn. That’s exactly what we are going to do in this section, starting with the second, the <strong class="keyWord">enemy waves</strong>.</p>
    <p class="normal">The idea is that we want to spawn enemies at a certain rate in different moments of the game; maybe we want to spawn enemies from second 1 to 5 at a rate of 2 per second, getting 10 enemies, and giving the player up to 20 seconds to finish them, programming another wave starting at 25 seconds. Of course, this depends a lot on the exact game you want, and you can start with an idea like this one and modify it after some testing to find the exact way you want the wave system to work. In our case, we will apply timing by implementing a simple wave system.</p>
    <p class="normal">First of all, we need an enemy, and for now, we will simply use the same 3D model we used for the player, but add a Forward Movement script to simply make it move forward; later in this book, we will add AI behavior to our enemies. I suggest you try to create this Prefab by yourself and look at the following steps once you have tried it, to check the correct answer:</p>
    <p class="normal">Drag the downloaded Character FBX model to the scene to create another instance of it, but rename it to <code class="inlineCode">Enemy</code> this time:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the <code class="inlineCode">ForwardMovement</code> script created for the bullets but this time to <code class="inlineCode">Enemy</code>, and set it at a speed of <code class="inlineCode">10</code> for now.</li>
      <li class="numberedList">Drag the <code class="inlineCode">Enemy</code> GameObject to the Project to create a Prefab based on that one; we will need to spawn it later. Remember to choose <strong class="screenText">Prefab Variant</strong>, which will keep the Prefab linked with the original model to make the changes applied to the model automatically apply to the Prefab. </li>
      <li class="numberedList">Remember also to destroy the original <code class="inlineCode">Enemy</code> from the scene.</li>
    </ol>
    <p class="normal">Now, to schedule actions, we will use the <code class="inlineCode">Invoke</code> functions to create timers. They are basic but enough for our requirements. Let’s use them by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an empty GameObject at one end of the base and call it <code class="inlineCode">Wave1a</code>.</li>
      <li class="numberedList">Create and add a script called <code class="inlineCode">WaveSpawner</code> to it.</li>
      <li class="numberedList">Our spawner will need four fields: the <code class="inlineCode">Enemy</code> <code class="inlineCode">Prefab</code> to spawn, the <code class="inlineCode">startTime</code> of the wave, the <code class="inlineCode">endTime</code>, and the spawn rate of the enemies (how much time should be between each spawn). The script and the settings will look like the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.41: The fields of the wave spawner script</p>
    <p class="normal">We will use the <code class="inlineCode">InvokeRepeating</code> function to schedule a custom function to repeat periodically. You will need to schedule the repetition just once; Unity will remember that, so don’t do it every frame. This is a good reason to use the <code class="inlineCode">Start</code> event function instead. The first <a id="_idIndexMarker322"/>argument of the function is a string (text between the quotation marks) with the name of the other function to execute periodically, and unlike <code class="inlineCode">Start</code> or <code class="inlineCode">Update</code>, you can name the function whatever you want. The second argument is the time to start repeating, our <code class="inlineCode">startTime</code> field, in this case. Finally, the third argument is the repetition rate of the function—how much time needs to happen between each repetition—this being the <code class="inlineCode">spawnRate</code> field. You can find how to call that function in the next screenshot, along with the custom <code class="inlineCode">Spawn</code> function:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_43.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.42: Scheduling a Spawn function to repeat </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Inside the <code class="inlineCode">Spawn</code> function, we can put the spawning code as we know, using the <code class="inlineCode">Instantiate</code> function. The idea is to call this function at a certain rate to spawn one enemy per call. This time, the spawn position will be in the same position as the spawner, so place it carefully:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.43: Instantiating in the Spawn function</p>
    <p class="normal">If you test this script by setting the Prefab <code class="inlineCode">startTime</code> and <code class="inlineCode">spawnRate</code> fields to some values greater than 0, you will notice that the enemies will start spawning <a id="_idIndexMarker323"/>but never stop, and you can see that we didn’t use the <code class="inlineCode">endTime</code> field so far. The idea is to call the <code class="inlineCode">CancelInvoke</code> function, the one function that will cancel all the <code class="inlineCode">InvokeRepeating</code> calls we made, but after a while. We will delay the execution of <code class="inlineCode">CancelInvoke</code> using the <code class="inlineCode">Invoke</code> function, which works similarly to <code class="inlineCode">InvokeRepeating</code>, but this one executes just once. In the next screenshot, you can see how we added an <code class="inlineCode">Invoke</code> call to the <code class="inlineCode">CancelInvoke</code> function in <code class="inlineCode">Start</code>, using the <code class="inlineCode">endTime</code> field as the time to execute <code class="inlineCode">CancelInvoke</code>. This will execute <code class="inlineCode">CancelInvoke</code> after a while, canceling the first <code class="inlineCode">InvokeRepeating</code> call that spawns the Prefab:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_45.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.44: Scheduling a Spawn repetition but canceling after a while with CancelInvoke</p>
    <div class="note">
      <p class="normal">This time, we used <code class="inlineCode">Invoke</code><strong class="screenText"> </strong>to delay the call to <code class="inlineCode">CancelInvoke</code>. We didn’t create a custom function because <code class="inlineCode">CancelInvoke</code> doesn’t receive arguments. If you need to schedule a function with arguments, you will need to create a wrapper function without parameters that calls the desired one and schedules it, as we did with <code class="inlineCode">Spawn</code>, where the only intention is to call <code class="inlineCode">Instantiate</code> with specific arguments. </p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Now you can save and set some real values to our spawner. In my case, I used the ones shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_46.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.45: Spawning enemies from second 1 to 5 of the gameplay every 0.5 seconds, 2 per second</p>
    <p class="normal">You should <a id="_idIndexMarker324"/>see the enemies being spawned one next to the other, and because they move forward, they will form a row of enemies. This behavior will change later with AI. Now, the Visual Scripting version will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_47.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.46: Spawning enemies in Visual Scripting</p>
    <p class="normal">While we could use the <code class="inlineCode">InvokeRepeating</code> approach in Visual Scripting, here we can see some benefits of the Visual approach, given it sometimes has more flexibility than coding. In this case, we used the <code class="inlineCode">Wait For Seconds</code> node at the beginning of the <code class="inlineCode">Start</code>, a node that basically will hold the execution of the flow for a couple of seconds. This will create the initial delay we had in the original script; that’s why we used the <code class="inlineCode">startTime</code> as the amount of <code class="inlineCode">Delay</code>. </p>
    <p class="normal">Now, after the wait, we used a <code class="inlineCode">For</code> loop; for this example, we changed the concept of the script, as we want to spawn a specific number of enemies instead of spawning during a time. The <code class="inlineCode">For</code> loop is essentially a classic <code class="inlineCode">For</code> that will repeat whatever is connected to the <code class="inlineCode">Body</code> output pin the number of times specified by the <code class="inlineCode">Last</code> input pin. </p>
    <p class="normal">We connected that pin to a variable to control the number of enemies we want to spawn. Then, we connected an <code class="inlineCode">Instantiate</code> to the <code class="inlineCode">Body</code> output pin of the <code class="inlineCode">For</code> loop to instantiate our enemies, and then a <code class="inlineCode">Wait For Seconds</code>, to stop the flow for a time before the loop can continue spawning enemies.</p>
    <p class="normal">Something interesting is that if you play the game now, you will receive an error in the console that will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_48.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.47: Error when using Wait nodes</p>
    <p class="normal">You can even go back to the graph editor and see that the conflicting node will be highlighted in red:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_49.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.48: Node causing the error</p>
    <p class="normal">The issue <a id="_idIndexMarker325"/>here is that in order for the <code class="inlineCode">Wait For Seconds</code> nodes to work, you need to mark the <code class="inlineCode">Start</code> event as a <strong class="keyWord">Coroutine</strong>. This will basically allow the event to be paused for an amount of time and be resumed later. The same concept exists in C#, but as it is simpler to implement here in Visual Scripting than in C#, we decided to go with this approach here. </p>
    <p class="normal">To solve this error, just select the <code class="inlineCode">On Start</code> event node and check the <strong class="screenText">Coroutine</strong> checkbox in the <strong class="screenText">Graph Inspector</strong> pane on the left of the <strong class="screenText">Script Graph</strong> editor. If you don’t see it, consider clicking the <strong class="screenText">Info</strong> button (circle with <em class="italic">i</em>) in the top-left part of the editor. </p>
    <p class="normal">A coroutine is a function that can be paused and resumed later, and that’s exactly what the <code class="inlineCode">Wait</code> node does. Coroutines also exist in <code class="inlineCode">MonoBehaviours</code>, but let’s keep things simple for now.</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_50.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.49: Marking Start as a coroutine</p>
    <p class="normal">Now that we have discussed timing and spawn, let’s discuss timing and <code class="inlineCode">Destroy</code> to prevent our bullets from living forever in the memory.</p>
    <h2 id="_idParaDest-89" class="heading-2">Destroying objects</h2>
    <p class="normal">We can use the <code class="inlineCode">Destroy</code> function to destroy object instances. The idea is to make the bullets <a id="_idIndexMarker326"/>have a script that schedules their own auto-destruction after a while to prevent them from living forever. We will create the script by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the Prefab of <code class="inlineCode">Bullet</code> and add a script called <code class="inlineCode">Autodestroy</code> to it, as you did with other objects using the <strong class="screenText">Add Component &gt; New Script</strong> option. This time, the script will be added to the Prefab, and each instance of the Prefab you spawn will have it.</li>
      <li class="numberedList">You can use the <code class="inlineCode">Destroy</code> function, as shown in the next screenshot, to destroy the object just once in <code class="inlineCode">Start</code>: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_51.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.50: Destroying an object when it starts </p>
    <p class="normal">The <code class="inlineCode">Destroy</code> function expects the object to destroy as the first argument, and here, we are using the <code class="inlineCode">gameObject</code> reference; a way to point to the GameObject our script is placed into to destroy it. If you use the <code class="inlineCode">this</code> pointer instead of <code class="inlineCode">GameObject</code>, we will be destroying only the <code class="inlineCode">Autodestroy</code> component we are creating.</p>
    <p class="normal">Of course, we don’t want the bullet to be destroyed as soon as it is spawned, so we need to delay the destruction. You may be thinking about using <code class="inlineCode">Invoke</code>, but unlike most functions in Unity, <code class="inlineCode">Destroy</code> can receive a second argument, which is the time to wait until destruction. </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a delay field to use as the second argument of <code class="inlineCode">Destroy</code>, as shown in the next screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_52.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.51: Using a field to configure the delay to destroy the object </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Set the <code class="inlineCode">delay</code> field to a proper value; in my case, 5 was enough. Now check how the <a id="_idIndexMarker327"/>bullets despawn after a while by looking at them being removed from the Hierarchy.</li>
      <li class="numberedList">The Visual Scripting equivalent will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_06_53.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.52: Destroying in Visual Scripting</p>
    <p class="normal">Regarding this version, notice how we use the <strong class="screenText">Component Destroy (Obj, T) </strong>version of the <code class="inlineCode">Destroy</code> node, which includes the delay time.</p>
    <div class="note">
      <p class="normal">Look for the <code class="inlineCode">Object Pool</code><strong class="screenText"> </strong>concept, which is a way to recycle objects instead of creating them constantly; you will learn that sometimes creating and destroying objects is not that performant.</p>
    </div>
    <p class="normal">Now, we can <a id="_idIndexMarker328"/>create and destroy objects at will, which is something very common in Unity scripting. In the next section, we will discuss how to modify the scripts we have done so far to support the new Unity Input System.</p>
    <h1 id="_idParaDest-90" class="heading-1">Using the new Input System</h1>
    <p class="normal">We have been using the <strong class="keyWord">Input</strong> class to detect the buttons and axes being pressed, and for our simple <a id="_idIndexMarker329"/>usage that is more than enough. But the default Unity input system has its limitations regarding extensibility to support new input hardware and mappings.</p>
    <p class="normal">In this section, we will explore the following concepts:</p>
    <ul>
      <li class="bulletList">Installing the new Input System</li>
      <li class="bulletList">Creating Input Mappings</li>
      <li class="bulletList">Using Mappings in scripts</li>
    </ul>
    <p class="normal">Let’s start exploring how to install the new Input System.</p>
    <h2 id="_idParaDest-91" class="heading-2">Installing the new Input System</h2>
    <p class="normal">To start using <a id="_idIndexMarker330"/>the new Input System, it needs to be installed like any other package we have installed so far, using the <strong class="keyWord">Package Manager</strong>. The package is just called <strong class="screenText">Input System</strong>, so go ahead and install it as usual. In this case we are using version 1.4.2, but a newer one may be available when you read this chapter.</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_54.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.53: Installing the new Input System package</p>
    <p class="normal">By default, when you install the Input System, it will prompt you to enable the new Input System <a id="_idIndexMarker331"/>with a window like the one in the following image. If that appears, just click <strong class="screenText">Yes</strong> and wait for Unity to restart:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_55.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.54: Switching the active Input System</p>
    <p class="normal">If for some reason that didn’t appear, the other alternative is going to <strong class="screenText">Edit | Project Settings</strong> and then going to <strong class="screenText">Player | Other Settings | Configuration</strong> to set the <strong class="screenText">Active Input Handling</strong> property to <strong class="screenText">Input System Package (New)</strong>. </p>
    <p class="normal">There’s an option called <strong class="screenText">Both</strong> to keep both enabled, but let’s stick with just one.</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_56.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.55: Switching the active Input System</p>
    <p class="normal">Now that we <a id="_idIndexMarker332"/>have the system installed and set up, let’s explore how to create the Input Mappings needed.</p>
    <h2 id="_idParaDest-92" class="heading-2">Creating Input Mappings</h2>
    <p class="normal">The new system has a way to directly request the current state of a button or thumbstick to the gamepad, mouse, keyboard, or whatever other device we have, like what we did <a id="_idIndexMarker333"/>so far with the previous Input System. But doing so would prevent us from using one of the best features of the system, the Input Mappings.</p>
    <p class="normal">The idea of an Input Mapping is to abstract the Input Actions from the Physical Input. Instead of thinking about the space bar, the left thumbstick of a gamepad, or the right click of a mouse, you think in terms of actions, like move, shoot, or jump. In code, you will ask if the <code class="inlineCode">Shoot</code> button has been pressed, or the current value of the <code class="inlineCode">Move</code> axes, like we did with the mouse axes rotatation. While the previous system supported a certain degree of Input Mapping, the one in the new Input System is way more powerful and easier to configure.</p>
    <table id="table001-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Action</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Mappings</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Shoot</p>
          </td>
          <td class="table-cell">
            <p class="normal">Left Mouse Button, Left Control, X button of the gamepad</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Jump</p>
          </td>
          <td class="table-cell">
            <p class="normal">Space, Y button of gamepad</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Horizontal Movement</p>
          </td>
          <td class="table-cell">
            <p class="normal">A and D keys, Left and Right arrows, gamepad Left Stick</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Figure 6.56: Example of the Input Mapping table</p>
    <p class="normal">The power of this idea is that the actual keys or buttons that will trigger these actions are configurable in the Unity editor, allowing any game designed to alter the exact keys to control the entire game without changing the code. </p>
    <p class="normal">We can even map more than one button to the same action, even from different devices, so we can make the mouse, keyboard, and gamepad trigger the same action, greatly simplifying our code. Another benefit is that the user can also rebind the keys with some custom UI we can add to our game, which is very common in PC games.</p>
    <p class="normal">The easiest way to start creating an Input Mapping is through the <strong class="screenText">Player Input </strong>component. This component, as the name suggests, represents the input of a particular player, allowing <a id="_idIndexMarker334"/>us to have one of those on each player in our game to support split-screen multiplayer, but let’s focus on single-player. Adding this script to our player will allow us to use the <strong class="screenText">Create Actions...</strong> button to create a default Input Mapping asset. This asset, as a material, can be used by several players, so we modify it and it will affect all of them (for example, adding the <code class="inlineCode">Jump</code> Input Mapping):</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_57.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.57: Creating Input Action assets using the Player Input component</p>
    <p class="normal">After clicking that button and saving the asset location in the save prompt, you will see the following screen:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_58.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.58: The default Input Mapping file</p>
    <p class="normal">The first part to understand from this asset is the <strong class="screenText">Action Maps</strong> section (left panel). This allows us to create <a id="_idIndexMarker335"/>separate Action Maps for different situations, for example, for driving and on-foot controls in games like GTA. By default, <strong class="screenText">Player</strong> and <strong class="screenText">UI</strong> mappings are created, to separate the mappings for the player controlling and navigating through the UI. If you check the <strong class="screenText">Player Input</strong> component again, you will see that the <strong class="screenText">Default Map </strong>property is set to <strong class="screenText">Player</strong>, which means that we will only care for the player controlling the Input Mappings in this GameObject; any UI action pressed won’t be considered. We can switch the active map in runtime at will, for example, to disable the character controller input when we are in the pause menu, or switch to the driving mappings while in a car, using the same buttons but for other purposes.</p>
    <p class="normal">If you select an Action Map in the left panel, you will see all the actions it contains in the <strong class="screenText">Actions</strong> list in the middle panel. In the case of the <strong class="screenText">Player</strong>, we have the <strong class="screenText">Move</strong>, <strong class="screenText">Look</strong>, and <strong class="screenText">Fire</strong> mappings, which are exactly the inputs we will use in our game. Bear in mind you can add more if you need to use the <strong class="screenText">+</strong> button, but for now, let’s stick with the default ones. When you select any action from the list, you will see their configurations in the <strong class="screenText">Action Properties </strong>panel, the one on the right: </p>
    <figure class="mediaobject"><img src="../Images/B18585_06_59.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.59: The Move (left) and Fire (right) action configurations</p>
    <p class="normal">As you can see, there’s a property called <strong class="screenText">Action Type</strong> that will dictate which kind of input we are talking about. If you select <strong class="screenText">Move</strong> in the middle panel, you can see it’s a <strong class="screenText">Value</strong> action type with <strong class="screenText">Control Type</strong> being <code class="inlineCode">Vector2</code>, meaning it will return the x and y axis values, the horizontal and vertical values—the kind we expect from any thumbstick in a gamepad. In the previous system, we got those values from separated 1D axes, like the <strong class="screenText">Mouse X</strong> and <strong class="screenText">Mouse Y</strong> axes, but here they are combined into a single variable for convenience. On the other hand, the <strong class="screenText">Fire</strong> action is of type <strong class="screenText">Button</strong>, which has the capacity not <a id="_idIndexMarker336"/>only to check its current state (pressed or released) but also do checks like if it has just been pressed or just released, the equivalents to <code class="inlineCode">GetKey</code>, <code class="inlineCode">GetKeyDown</code>, and <code class="inlineCode">GetKeyUp</code> from the previous system.</p>
    <p class="normal">Now that we understand which actions we have and of which type each one is, let’s discuss how the Physical Input will trigger them. You can click the arrow on the left of each action in the middle panel to see its physical mappings. Let’s start exploring the <strong class="screenText">Move</strong> Action Mappings.</p>
    <p class="normal">In this case, we have 4 mappings:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Left Stick [Gamepad]</strong>: The left stick of the gamepad</li>
      <li class="bulletList"><strong class="screenText">Primary 2D Axis [XR Controller]</strong>: The main stick of the VR controllers</li>
      <li class="bulletList"><strong class="screenText">Stick [Joystick]</strong>: Main stick for arcade-like joysticks or even flight sticks</li>
      <li class="bulletList"><strong class="screenText">WASD</strong>: A composite input simulating a stick through the W, A, S, and D keys</li>
    </ul>
    <p class="normal">If you select any of them, you can check their configurations; let’s compare the left stick and WASD as an example:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_60.png" alt=""/> </figure>
    <p class="packt_figref">Figure 6.60: The left stick mapping (left) and the WASD key mapping (right)</p>
    <p class="normal">In the case of the <strong class="screenText">Left Stick</strong>, you can see the <strong class="screenText">Path</strong> property that allows you to pick all the possible hardware physical controls that provide <code class="inlineCode">Vector2</code> values (the x and y axes). In the case of the <strong class="screenText">WASD</strong> key mapping, you can see it is a composite binding of type <strong class="screenText">2D Vector</strong>, which, as stated previously, allows us to simulate a 2D Axis with other inputs—keys in this case. If you expand the <strong class="screenText">WASD</strong> Input Mappings in the middle panel, you can see all inputs <a id="_idIndexMarker337"/>that are being composited for this 2D axis, and see their configurations by selecting them:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_61.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.61: The inputs considered for the WASD composite 2D axis</p>
    <p class="normal">In this case, it maps not only the W, A, S, and D buttons but also the 4 keyboard arrows. Each one of those mappings has a path to select the physical button, but also the <strong class="screenText">Composite Part</strong> setting, allowing us to specify which direction this input will pull the simulated stick.</p>
    <p class="normal">And with this, we have just scratched the surface of what this system is capable of, but for now, let’s keep things simple and use these settings as they are. Remember a new asset was created with the same name as our game (<em class="italic">SuperShooter</em> in our case) in the root of the project. You can reopen this Action Mapping window by double-clicking it whenever you want. Now let’s see how we can use these inputs in our code.</p>
    <h2 id="_idParaDest-93" class="heading-2">Using Mappings in our scripts</h2>
    <p class="normal">This system <a id="_idIndexMarker338"/>provides several ways to detect the input state. The <strong class="screenText">Player Input</strong> component has a <strong class="screenText">Behavior</strong> property to switch between some of the available modes. The simplest one is the one called <strong class="screenText">Send Messages</strong>, the one that we will use, which will execute methods in our code when the keys are pressed. In this mode, each action in the mappings will have its own event, and you can see <a id="_idIndexMarker339"/>all of them in the tooltip at the bottom of the component. As you add mappings, more will appear.</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_62.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.62: All the input events for the default mapping</p>
    <p class="normal">From the list, we will need three, <code class="inlineCode">OnMove</code>, <code class="inlineCode">OnLook</code>, and <code class="inlineCode">OnFire</code>. We can modify our <code class="inlineCode">PlayerMovement</code> script like in the following screenshot to use them:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_63.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.63: Player movement with the new Input System</p>
    <p class="normal">The first difference you will notice is that we don’t request the status of the input in the <code class="inlineCode">Update</code> method like we did before. Instead, we listen to the <code class="inlineCode">OnMove</code> and <code class="inlineCode">OnLook</code> events, which provide us with an <code class="inlineCode">InputValue</code> parameter containing the current state of those axes. The idea <a id="_idIndexMarker340"/>is that every time these axes change value, these events will execute, and if the values didn’t change, like when the player keeps pushing the stick all the way to the right, they won’t be executed. That’s why we need to store the current value in the <code class="inlineCode">movementValue</code> and <code class="inlineCode">lookValue</code> variables, to use the latest value of the axis later in the <code class="inlineCode">Update</code> and apply the movement in every frame. Consider those are private, meaning they won’t appear in the editor, but that’s fine for our purposes. Also, observe that we added the <code class="inlineCode">using UnityEngine.InputSystem</code> line at the top of the file to enable the usage of the new Input System in our script.</p>
    <p class="normal">In this version of the <code class="inlineCode">PlayerMovement</code> script, we used the axis input type like we did with the mouse before but also for movement, unlike the previous version that used buttons. This is the preferred option most of the time, so we will stick with that version. Observe how we use a single <code class="inlineCode">transform.Translate</code> to move; we need to use the x axis of <code class="inlineCode">movementValue</code> to move the x axis of our player but use the y axis of <code class="inlineCode">movementValue</code> to move the z axis of our player. We don’t want to move our player vertically, so that’s why we needed to split the axis this way.</p>
    <p class="normal">The <code class="inlineCode">InputValue</code> parameter has the <code class="inlineCode">Get&lt;Vector2&gt;()</code> method, which will give us the current value of both axes, given <code class="inlineCode">Vector2</code> is a variable that contains the x and y properties. Then, we multiply the vector by the movement or rotation speed according to the case. You will notice that we don’t multiply by <code class="inlineCode">Time.deltaTime</code> in the axis events, but we do that in the <code class="inlineCode">Update</code>. That’s because <code class="inlineCode">Time.deltaTime</code> can change between frames, so storing the movement value considering the <code class="inlineCode">Time.deltaTime</code> of the last time we moved the stick won’t be useful for us. Also, notice how <code class="inlineCode">movementValue</code> is a <code class="inlineCode">Vector2</code>, just a combination of the x and y axes, while <code class="inlineCode">lookValue</code> is a simple float. We did it this way because we will rotate our character only following the lateral movement of the mouse; we don’t want to rotate it up and down. Check that we do <code class="inlineCode">value.Get&lt;Vector2&gt;().x</code>, with emphasis on the <code class="inlineCode">.x</code> part, where we extract just the horizontal part of the axis for our calculations.</p>
    <p class="normal">Regarding the <code class="inlineCode">PlayerShooting</code> component, we need to change it to this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_64.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.64: PlayerShooting script using the new Input System</p>
    <p class="normal">This case is simpler, as we don’t need to execute the shooting behavior each frame, we only need <a id="_idIndexMarker341"/>to execute something at the very same moment the input is pressed, which is exactly when the <code class="inlineCode">OnFire</code> event will be executed. If you need to also detect when the key was released, you can add the <code class="inlineCode">InputValue</code> parameter as we did with <code class="inlineCode">OnMove</code> and <code class="inlineCode">OnLook</code>, and consult the <code class="inlineCode">isPressed</code> property:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_65.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.65: Getting the state of the button</p>
    <p class="normal">Regarding the Visual Script Machine version of our scripts, first, you will need to refresh the <strong class="screenText">Visual Script Node Library </strong>by going to <strong class="screenText">Edit | Project Settings | Visual Scripting</strong> and clicking the <strong class="screenText">Regenerate Nodes</strong> button. If you don’t do this, you won’t see the new Input System nodes:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_66.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.66: Regenerating Visual Scripting nodes to support the new Input System</p>
    <p class="normal">Now, the <code class="inlineCode">PlayerShooting</code> visual <a id="_idIndexMarker342"/>script would look like this:</p>
    <figure class="mediaobject"><strong class="screenText"><img src="../Images/B18585_06_67.png" alt=""/></strong></figure>
    <p class="packt_figref">Figure 6.67: Instantiating bullets with the new input system</p>
    <p class="normal">The new <strong class="screenText">On Input System Event Button</strong> node allows us to detect when an action button has been pressed and react accordingly. You can pick the specific action in the <strong class="screenText">Input Action</strong> parameter, and you can even make the node react to the pressure, release, or hold states of the button with the option right below the node’s title. There is a bug where the <strong class="screenText">Input Action</strong> property might not show any option; in such cases, try removing and adding the node again in the graph, and check that you added the <code class="inlineCode">ScriptMachine</code> component to the same GameObject that has the <code class="inlineCode">PlayerInput</code> component. Also check you have selected the Player GameObject in the hierarchy.</p>
    <p class="normal">Regarding <a id="_idIndexMarker343"/>movement, it can be achieved this way:</p>
    <figure class="mediaobject"><img src="../Images/B18585_06_68.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.68: Moving with the new Input System</p>
    <p class="normal">In this case, we used the <strong class="screenText">On Input System Event Vector2</strong> node. This time, we used the <code class="inlineCode">OnHold</code> mode, which means that, unlike the C# version, it won’t execute just when the axis changes, but all the frames when the axis is pressed act like an <code class="inlineCode">Update</code>; that, however, will only execute when the user is pressing the stick. The output pin of the node is the <code class="inlineCode">Vector2</code> value, so we multiply it by the <code class="inlineCode">speed</code> variable (declared in the <code class="inlineCode">Variables</code> component of our player) and by <code class="inlineCode">DeltaTime</code>. Finally, we use the <code class="inlineCode">Vector2</code> <code class="inlineCode">GetX</code> and <code class="inlineCode">Vector2</code> <code class="inlineCode">GetY</code> nodes to translate over the x and z axes. You may have trouble when rewiring the <strong class="screenText">Multiply</strong> nodes with the new <strong class="screenText">Input System</strong> node, given the return type is different compared to the previously used node (a <code class="inlineCode">Vector2</code> instead of a single float). I recommend just deleting all nodes in this graph and redoing it to be sure everything is fine.</p>
    <h1 id="_idParaDest-94" class="heading-1">Summary</h1>
    <p class="normal">We created our first real scripts, which provide useful behavior. We discussed how to move a GameObject based on input and instantiate Prefabs via scripting to create objects at will according to the game situation. Also, we saw how to schedule actions, in this case, spawning, but this can be used to schedule anything. We saw how to destroy the created objects, to prevent increasing the number of objects to an unmanageable level. Finally, we explored the new Input System to provide maximum flexibility to customize our game’s input. We will be using these actions to create other kinds of objects, such as sounds and effects, later in this book.</p>
    <p class="normal">Now you are able to create any type of movement or spawning logic your objects will need and make sure those objects are destroyed when needed. You might think that all games move and create shooting systems the same way, and while they are similar, being able to create your own movement and shooting scripts allows you to customize those aspects of the game to behave as intended and create the exact experience you are looking for.</p>
    <p class="normal">In the next chapter, we will be discussing how to detect collisions to prevent the player and bullets from passing through walls and much more.</p>
  </div>
</body></html>