- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unity Editor and Scene Creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll lay the groundwork for your Unity journey. You’ll familiarize
    yourself with the Unity Editor, create a basic scene, and explore essential lighting
    aspects. We’ll cover installing Unity, navigating the Editor, working with **GameObjects**,
    importing assets, and experimenting with various lighting settings. By the end,
    you’ll have a solid foundation to delve deeper into Unity and create increasingly
    complex and captivating scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics as we proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Unity development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the Unity Editor and its interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GameObjects and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic scene in Unity and adding objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the Unity Editor, it is important to ensure that your system
    meets the minimum requirements to run Unity. To successfully complete the exercises
    in this chapter, you will require a personal computer that has *Unity 2021.3*
    LTS or a more recent version installed. To ensure your hardware meets the requirements,
    you can cross-check it on the Unity website ([https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Unity development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First things first, let’s get Unity up and running on your development machine.
    Throughout this book, we’ll be harnessing the power of the Unity 3D game engine
    to create inspiring projects. Unity is an incredibly potent, cross-platform 3D
    development environment, complete with an intuitive and visually appealing editor.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not yet installed Unity on your computer, we will guide you through
    the process. Following the installation, we’ll proceed to create our initial scene.
    Let’s begin the setup and exploration of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Unity Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the course of this book, the **Unity Hub** will become your trusty command
    center for managing different Unity projects, Unity Editor versions, and modules.
    To initiate the installation process of the Unity Hub, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the official Unity website ([https://unity3d.com/get-unity/download](https://unity3d.com/get-unity/download))
    and navigate to the latest version of the Unity Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the onscreen instructions to install Unity Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Unity Hub installed, open it up and sign in using your Unity account.
    If you’re new to Unity, create an account to join the ranks of fellow creators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without having the Unity Editor installed, the Unity Hub is just as powerful
    as a CD player without a CD. The next section covers how you can install the Unity
    Editor within the Unity Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Unity Editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Unity Editor** is where the magic happens—a workspace for designing,
    building, and testing your game projects. To install it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the Unity Hub, navigate to the **Installs** tab and hit the **Add** button
    to add a new Unity Editor version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opt for the latest LTS version of the Unity Editor and click **Next** to kick
    off the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During installation, don’t forget to include the necessary platforms and modules
    tailored to your specific needs. Add the *Windows/Mac/Linux Build Support*, depending
    on the operating system of your PC. Likewise, select the *Android* or *iOS Build
    Support*, depending on the nature of your smartphone, so that you can follow along
    with the AR tutorials in this book. Lastly, if you are using a VR headset that
    runs on Android, such as the *Quest 2* or *Quest Pro*, be sure to add the *Android
    Build Support* module along with its sub-modules: *OpenJDK* and *Android SDK &*
    *NDK Tools*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we have the Unity Editor installed, it is time to create a project.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a sample scene as a new Unity project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After installing the Unity Hub and the Unity Editor, it’s time to create a new
    Unity project. For the sake of simplicity, we will first use a sample scene. A
    sample scene in Unity is a pre-built scene created by Unity to show developers
    how various functions and techniques can be implemented. Unity offers a variety
    of sample scenes, ranging from simple 2D games to complex 3D environments, that
    can be used as a starting point for your own projects. The sample scenes can be
    downloaded via the Asset Store or directly from the Unity Hub. Here’s how to do
    that directly from the Unity Hub.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.1* shows a project’s creation within the Unity Hub.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.1 – \uFEFFHow to create a project with a sample scene in the Unity\
    \ Hub](img/B20869_02_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – How to create a project with a sample scene in the Unity Hub
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a sample scene as a new project, just go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Unity Hub and go to the **Projects** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **New** button to create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **3D Sample Scene (URP)**, give your project a name, and select a location
    to save it. For this project, we’ve opted for **3D Sample Scene (URP)** as it
    provides a preconfigured environment showcasing the capabilities of the **Universal
    Render Pipeline** (**URP**), ideal for those new to Unity or seeking a reference.
    While the standard **3D (URP)** template is typically favored by developers for
    its clean slate, allowing for a customized setup, they often enhance these projects
    by importing additional packages or assets via the Package Manager or Unity Asset
    Store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button to create the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve got that out of the way, let’s look at how to choose the right
    render pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right render pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upon examining the sample scene options, you might have noticed the choice between
    the URP and the **High Definition Render Pipeline** (**HDRP**). But which one
    is better, and what exactly is a render pipeline? In essence, a render pipeline
    is a sequence of steps and processes that dictate how the engine renders graphics.
    It transforms 3D assets, lighting, and other scene components into the final 2D
    image gracing your screen. While URP and HDRP share some low-level tasks, each
    pipeline is tailored to specific project needs and target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 2.1* shows how URP and HDRP stack up against one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – A comparison between URP and HDRP](img/B20869_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – A comparison between URP and HDRP
  prefs: []
  type: TYPE_NORMAL
- en: A comfortable VR experience demands high frame rates, typically exceeding 90
    FPS. URP emphasizes performance, ensuring smooth frame rates across various VR
    devices, including standalone VR headsets, PC-based VR, and mobile VR. As the
    market sees a growing number of standalone VR headsets, URP proves invaluable
    for its adaptability and ease of project optimization.
  prefs: []
  type: TYPE_NORMAL
- en: While URP may not boast the visual prowess of HDRP, it strikes a balance between
    graphic quality and performance, making it suitable for the majority of VR projects
    where performance is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Unity’s versatility extends beyond HDRP and URP pipelines, allowing the creation
    of custom **Scriptable Render Pipeline** (**SRP**) pipelines for experienced graphics
    programmers. However, developing a custom SRP pipeline requires deep knowledge
    of 3D graphics programming, rendering pipelines, and C# language proficiency.
    For those lacking these skills, HDRP and URP offer an optimal balance between
    flexibility and ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: Given its many advantages, URP emerges as the go-to choice for most VR endeavors.
    Throughout this book, we’ll focus exclusively on URP. However, HDRP remains a
    worthy contender for those pursuing high-end PC VR experiences.
  prefs: []
  type: TYPE_NORMAL
- en: With Unity installed, the render pipeline selected, and your project at your
    fingertips, it’s time to acquaint ourselves with the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Unity Editor and its interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re new to Unity, the editor’s interface can be a bit overwhelming at
    first. But don’t worry—we’ll guide you through the Unity Editor and show you how
    to navigate its various menus and panels. Experienced users can also benefit from
    staying current with the latest best practices and techniques, as designing for
    VR presents unique challenges that may require a different approach than traditional
    game development.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Unity interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upon launching a new Unity project, you’ll be greeted by the Unity Editor. This
    multifaceted workspace is composed of several distinct windows known as panels.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* shows the window layout for the sample scene project we just
    created.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.2 – \uFEFFThe window layout for the sample scene project](img/B20869_02_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The window layout for the sample scene project
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* showcases a number of panels, namely: (*1*) **Scene** view,
    (*2*) **Game** view, (*3*) **Hierarchy**, (*4*) **Inspector**, (*5*) **Project**,
    and (*6*) **Console**.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore these essential panels that make up Unity’s interface.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the **Scene view** (*1*) as your canvas, where you’ll bring your game
    world to life, creating mesmerizing landscapes and placing your characters in
    fantastic environments. This panel is the heart of the game, where every object
    is placed and arranged to tell a compelling story. For example, you can select
    the **Safety Hat** GameObject within our sample scene and move, rotate, scale,
    or remove it.
  prefs: []
  type: TYPE_NORMAL
- en: The **Game view** (*2*) is the place where you can experience your game from
    your player’s perspective. It provides a real-time preview of the gameplay, including
    the visual rendering and user interface elements you’ve implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The **Hierarchy panel** (*3*) or **Scene Hierarchy window** is your game’s blueprint,
    showcasing the organized list of every GameObject that makes up your game world.
    It’s like an architectural plan that helps you navigate, manage, and visualize
    the relationships between game elements, ensuring a coherent and structured experience.
    Our sample scene demonstrates what a well-structured hierarchy looks like. All
    added GameObjects are subordinate to the **Example Assets** parent object. This
    includes the **Props** GameObject, which itself serves as a parent object for
    any GameObjector asset that decorates a scene and adds details and context to
    the game world—for example, Jigsaw, Hammer, Workbench, and so on. So, keep in
    mind that grouping related objects together under a parent GameObject makes it
    easier to manage and manipulate them as a single entity. Additionally, naming
    conventions can be used to make the hierarchy more readable and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The **Inspector panel** (*4*) or **Inspector window** is the control center
    for fine-tuning your game elements. It’s where you can adjust every tiny detail
    of your GameObjects or assets, making sure your game world is precisely how you
    envisioned it. From position and scale to adding components and modifying scripts,
    the **Inspector** panel is your ticket to perfection. Let’s select the **Safety
    Hat** object in the **Scene Hierarchy** window by navigating to **Example Asset**
    | **Props** | **Safety Hat**. The **Inspector** window shows all the defined components
    of the **Safety Hat** object. The **Transform** component is responsible for positioning,
    rotating, and scaling the object. You will find a gizmo representation of it in
    the Scene View, which allows us to transform objects directly there. Two other
    components that can be seen in the **Inspector** window are the **Mesh Filter**
    and **Mesh Renderer** components. The **Mesh Filter** and **Mesh Renderer** components
    provide a way to create and display 3D models in a scene. The **Mesh Filter**
    component defines the model’s geometry, while the **Mesh Renderer** component
    applies visual properties such as materials and textures. Without these components,
    you wouldn’t see the object in the Scene View.
  prefs: []
  type: TYPE_NORMAL
- en: The **Project** panel (*5*) holds all the building blocks of your game, from
    **textures** and models to sounds and scripts. It’s like a library of resources,
    where every imported or created asset is at your fingertips, waiting to be used
    in your XR project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the **Console** panel (*6*) is an essential tool, assisting in the
    identification and resolution of issues during development. It provides detailed
    logs, warnings, and error messages, allowing for efficient troubleshooting and
    ensuring the integrity of the game’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: You are now familiar with the default panels in Unity. Next, we will get to
    know the Unity Grid and Snap system, which is a game changer when building scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can keep the default layout, or customize your panels using the dropdown
    at the top right of the Unity Editor under **Layout**. We usually prefer the 2x3
    layout, but for simplicity, we will use the default layout in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Grid and Snap system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Unity Grid and Snap system** helps align and place objects in a more organized
    manner in the game environment. It allows you to snap objects to a grid and also
    to other objects for easier placement and arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.3* shows you where to find the system.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.3 – \uFEFFHow to use the Grid and Snap system](img/B20869_02_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – How to use the Grid and Snap system
  prefs: []
  type: TYPE_NORMAL
- en: To make use of this system, you will need to turn on the **Grid Snapping** button,
    which is represented by an icon with a grid and magnet (*1*). Furthermore, make
    sure to activate the **Global** handles by selecting the **Global** icon (*2*)
    positioned adjacent to the **Grid** **Snapping** field.
  prefs: []
  type: TYPE_NORMAL
- en: The `1` for all three axes (**X**, **Y**, and **Z**), meaning each grid square
    has a width, height, and depth of one unit. This setting can be adjusted as needed
    to match the scale of the objects in your scene. The **Grid Size** field determines
    the increment at which objects will snap to the grid, so a larger grid size will
    result in coarser snapping, while a smaller grid size will result in finer snapping.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Select the same stud as in *Figure 2**.3* and move it two units towards
    the **Y** direction. Activate **Grid Snapping**, and try different grid sizes
    to place the stud back on the workbench.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Try to become familiar with the navigation in the **Scene** view by moving,
    orbiting, and zooming through the scene. This documentation may help you: [https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html](https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Pick another two GameObjectsand move, scale, and rotate them as you like.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GameObjects and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GameObjects and **components** are essential building blocks of Unity projects,
    allowing developers to create interactive and dynamic content. Now, we’ll provide
    a comprehensive overview of GameObjects and components and how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the default new scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity empowers developers with the ability to create multiple scenes within
    the editor. This feature aids in managing complexity, enhancing performance, and
    fostering more modular and reusable game projects. To create a new default scene
    alongside our sample scene, access the menu at the uppermost section of the editor
    and choose `Scenes` folder with a name of your choosing. After following these
    steps, you will be presented with a new Unity scene containing a **Main Camera**
    GameObject and a **Directional Light** GameObject. Both GameObjects are located
    in the **Scene Hierarchy** window and displayed in the **Scene** window, which
    features an infinite reference ground plane grid. In Unity, GameObjects serve
    as the foundational building blocks of a game scene. They represent visible or
    interactive elements such as characters, props, light sources, or cameras. Each
    GameObject possesses a **Transform** component that defines its position, rotation,
    and scale and can be augmented with additional components for **physics**, **collision
    detection**, or **game logic**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create our first GameObject. Keep in mind that while Unity is primarily
    a game engine, it does offer some basic modeling capabilities. You can create
    simple 3D models using Unity’s built-in 3D object **primitives** or import more
    intricate models fashioned in other 3D modeling software. Third-party plugins
    are also available to further bolster Unity’s modeling prowess. However, it’s
    important to remember that Unity is no match for dedicated 3D modeling software
    such as *Blender*, *3ds Max*, or *Maya*, and it’s better suited for creating and
    manipulating models for use in game development.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating a plane primitive to act as our floor. To do so, right-click
    in the `0`,`0`,`0`) but rather at a different location. By default, newly created
    objects are parented to the active object in the `Ground`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Ground` object’s **Inspector** window, you’ll notice that besides the
    **Mesh Filter** and **Mesh Renderer** components responsible for the GameObject’s
    visual appearance, there’s also a **Mesh Collider** component. Up next, you’ll
    learn more about this and other types of colliders.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Colliders** are components that define the shape of an object and are used
    to determine physical interactions with other objects in the scene. There are
    several types of colliders available in Unity, each with its own specific use
    case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Box collider**: This type of collider defines a rectangular shape, perfect
    for objects with a box-like shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sphere collider**: This type of collider defines a spherical shape, great
    for objects with a round shape, such as a ball.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capsule collider**: This type of collider is a combination of a cylinder
    and two spheres, useful for objects that are shaped like a capsule, such as a
    character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mesh collider**: This type of collider defines the shape of an object based
    on its mesh, allowing precise collision detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wheel collider**: This type of collider is specifically designed for wheel-based
    objects, such as vehicles. It allows realistic wheel behavior and suspension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By incorporating a collider component, you can define an object’s interactions
    with other scene colliders, such as bouncing, stopping, or passing through. Additionally,
    colliders can trigger events, such as activating sound effects upon collision.
    Applying a collider to the ground is sensible, as it establishes environmental
    boundaries and enables lifelike interactions with other scene objects, preventing
    characters from falling through the ground, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Components are versatile tools that can be assigned to GameObjects, shaping
    their behavior, appearance, and functionality. Consider **Main Camera**, which
    is equipped with components such as **Transform** (defining position, rotation,
    and scale) and **Camera** (specifying settings such as **field of view** (**FOV**)
    and clipping planes). Similarly, the **Directional Light** GameObject features
    components such as **Transform** and **Light**, which determine the light’s type,
    color, and intensity, among other properties.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples of components include **Rigidbody** for incorporating physics-based
    behavior, **AudioSource** for playing sounds, and **Particle System** for crafting
    visual effects such as fire, smoke, or magical spells. Each component fulfills
    a unique function and significantly influences your game world and its interactions.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this book, we will explore and utilize an array of essential
    components, starting with the next section, where we breathe life into our initial
    basic scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic scene in Unity and adding objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will walk you through constructing the scene depicted in
    *Figure 2**.4*, which integrates elements such as primitives, materials, prefabs,
    lighting, and imported assets.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.4 – \uFEFFThe basic scene we are going to create](img/B20869_02_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The basic scene we are going to create
  prefs: []
  type: TYPE_NORMAL
- en: By engaging with this step-by-step tutorial, you will develop a strong knowledge
    of these core concepts while assembling an aesthetically striking scene. Our initial
    task involves crafting a table using primitive shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Building a table with primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primitives, as the name suggests, are simple geometric shapes that form the
    building blocks for more complex models in our scene. Imagine a chair taking shape
    as a cube forms the seat, two cylinders become the sturdy legs, and two more cylinders
    morph into supportive back legs. The backrest is crafted from a plane, its size
    and placement perfectly complementing the seat and legs.
  prefs: []
  type: TYPE_NORMAL
- en: A table for our scene can be crafted in a similar fashion—a cube takes center
    stage as the tabletop, while four cylinders rise up to serve as legs. Textures
    are applied, giving the tabletop and legs a lifelike appearance. The size and
    positioning of each primitive are adjusted, resulting in a table that looks like
    it was plucked from the real world.
  prefs: []
  type: TYPE_NORMAL
- en: To create the table, we recommend following the sequence illustrated in *Figure
    2**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.5 – \uFEFFHow to use the Grid and Snap system](img/B20869_02_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – How to use the Grid and Snap system
  prefs: []
  type: TYPE_NORMAL
- en: 'To build your table, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a single table leg by introducing a cylinder to the scene. This can be
    achieved by right-clicking into the `0.05`, `0.2`, `0.05`) and position at (`0`,
    `0.2`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The table requires four identical legs. To achieve this, reproduce the original
    leg by copying (right-click on the object in the **Scene Hierarchy** window and
    click **Copy**) and pasting it three times. Fine-tune the positions of the duplicated
    legs based on the preceding reference image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a **Cube** primitive to the scene that will serve as the tabletop.
    Rescale and position the cube so that it rests on the table legs. To achieve the
    scaling and positioning more simply, shift to **Wireframe** mode, as shown in
    *Figure 2**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 2.6 – \uFEFFHow to use Wireframe mode](img/B20869_02_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – How to use Wireframe mode
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Our advice here is to initially scale just the **Y** value and place the cube
    on top of the legs using the Grid and Snap system. Subsequently, you can shift
    your view from the scene to the top and modify the **Shading** mode from **Shaded**
    to **Wireframe**. This change reveals the cylinders and the cube, simplifying
    the task of scaling the **X** and **Z** values and positioning the **Cube** object.
  prefs: []
  type: TYPE_NORMAL
- en: To organize the table components, create a nested parent-child object hierarchy.
    First, assign appropriate names to the objects by renaming the `Table top` and
    the cylinders as their respective table legs. Subsequently, select all the legs
    (*cmd*/*Ctrl* + left-click). Click and drag them onto the `Table top` object in
    the `Table top` object, establishing a parent-child relationship.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To further refine the table structure, create an empty GameObject by selecting
    `Table`. Make the `Table top` object a child of the `Table` object. This results
    in a harmoniously structured table consisting of five interconnected primitives.
    With this arrangement, the table can be easily scaled and relocated without the
    need to individually select each GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To complete the scene, place a sphere primitive named `Table` object. You can
    use the Grid and Snap techniques discussed earlier for this. For a more refined
    look, feel free to scale the sphere to your liking. In the following section,
    we will enhance the appearance of both the `Table` and **Sphere** objects using
    materials.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the appearance of the ground, table, and sphere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, the scene consists of a ground and a table with a sphere
    placed on it, all displaying the standard gray color. Let’s enhance this by creating
    a new red material for the sphere through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Materials` folder in the `Assets` | `Materials`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Red Material`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the white square adjacent to the **Base Map** field in the **Inspector**
    window. This action will launch the **Color** window. Select the **#FF0000** hex
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can apply the `Red Material` material by dragging and dropping it on
    top of the **Sphere** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the sphere should appear in red. So far, we have used the simplest form
    of a material to apply a simple red color to a sphere geometry.
  prefs: []
  type: TYPE_NORMAL
- en: When creating materials for objects in a 3D game or application, it’s often
    necessary to add additional details and depth to the surface of the object beyond
    what can be achieved with just a single texture. This is where maps such as base
    maps, metallic maps normal maps, height maps, and occlusion maps come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us get to know each of these maps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Red Material` material) or we can assign a texture (such as a picture of a
    brick wall) that defines the color and pattern of an object’s surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metallic Map**: A Metallic Map defines the extent to which an object’s surface
    should appear to be metallic, with areas of the map that are white appearing highly
    metallic, and areas that are black appearing non-metallic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal Map**: A Normal Map is a type of texture that defines the surface
    normal vectors of an object, giving the illusion of additional depth and detail
    on the surface. Normal Maps are often used to create the appearance of bumps,
    dents, and other small details on an object’s surface, without adding extra geometry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height Map**: A Height Map is a black-and-white image that defines the height
    of an object’s surface. Height Maps are used to create the appearance of depth
    and relief on a surface, such as mountains and valleys on a terrain or the ridges
    and valleys of a fingerprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occlusion Map**: An Occlusion Map is a texture that defines which parts of
    an object are occluded, or hidden, from view. Occlusion Maps are used to create
    the appearance of shadows and ambient occlusion, giving objects a more grounded,
    realistic look by making them appear to cast shadows and have depth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To visualize these maps, imagine a piece of paper with a picture of a wall painted
    on it. The **Base Map** would be the paint on the wall, the **Normal Map** would
    add the appearance of bumps and dents to the surface, the **Height Map** would
    create the appearance of depth and relief, and the **Occlusion Map** would add
    the appearance of shadows. When these maps are combined, they can create a much
    more detailed and believable representation of a wall. You may have noticed that
    this example did not cover the **Metallic Map**. You do not have to use all of
    the maps for a material. The choice of which maps to use depends on the desired
    appearance of the material and the level of detail you want to achieve. For example,
    a simple material for a flat, single-colored object may only require a **Base
    Map** (or albedo color) to define its appearance. A more complex material, such
    as a metal object with intricate details, might require a **Base Map**, **Normal
    Map**, **Height Map**, and **Metallic Map** to achieve the desired look.
  prefs: []
  type: TYPE_NORMAL
- en: Creating maps can be a complex and time-consuming task, especially for intricate
    objects. To save time and effort, it’s often best to utilize pre-made materials
    or models from marketplaces such as the **Unity Asset Store**, **ArtStation**,
    and **Sketchfab**. These sites offer a wealth of free content to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our sample scene, we have a variety of pre-made materials available. Let’s
    use a wooden material for the tabletop. Here’s what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Materials` folder (`Assets` | `ExampleAssets` | `Materials`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the **OBS_Mat** material and drag it onto the top of the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the tabletop should exhibit a wooden texture, as illustrated in *Figure
    2**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.7 – \uFEFFThe table top with its wooden texture](img/B20869_02_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The table top with its wooden texture
  prefs: []
  type: TYPE_NORMAL
- en: Upon examining the surface inputs in the **Inspector** window, the wooden material
    consists of a base map, metallic map, normal map, and occlusion map. To preview
    each map, *cmd*/*Ctrl* + left-click the corresponding squares next to the maps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also choose an appropriate material for the ground. In the `Materials`
    folder (`Assets` | `ExampleAssets` | `Materials`) and search for the **Ground_Mat**
    material. Drag it onto the ground, and the surface should now appear more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to create a brick wall material in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a brick wall material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we explored the application of a red albedo color
    to a sphere and utilized more advanced materials for the ground and table. It’s
    worth noting that materials play a crucial role in determining how a surface is
    rendered, encompassing not only the textures of an object’s surface but also its
    interaction with light sources.
  prefs: []
  type: TYPE_NORMAL
- en: A texture is an image that is applied to a 3D model or a 2D surface to add detail
    or color. It can be thought of as skin that covers the surface of an object to
    give it a specific look or feel. Textures can be created within Unity or imported
    from external image files and then assigned to materials that are applied to GameObjects
    in a scene. This technique enhances the level of detail and realism in the rendered
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will delve into the process of creating and applying a
    more sophisticated material by developing a brick wall material and applying it
    to a wall constructed from a transformed cube. Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a wall by inserting a new cube into the scene, renaming
    it `Wall`, scaling it to (`2`, `1`, `0.1`), and positioning it at (`0.2`, `0.5`,
    `1.8`) behind the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `Assets` folder in the `Textures`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To give the `Wall` cube a brick-like appearance, download and utilize the `BrickWall.jpg`
    texture file that is provided in this book’s GitHub repository, or find a suitable
    brick wall texture through an online search. Import the image into the newly created
    `Textures` folder. This can be accomplished by simply dragging the image from
    your local filesystem and dropping it into the corresponding Unity folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Staying in the `Materials` folder. Here, generate a new material and rename
    it `Brick_Mat`. You can create the material by right-clicking within the folder,
    selecting **Create**, and then choosing **Material**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Brick_Mat` material selected, navigate to the **Inspector** window.
    Look for the small *torus symbol* situated adjacent to the **Base Map** field
    and select it. Proceed to search for and select the imported **BrickWall** image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step involves moving the `Brick_Mat` material from the `Wall` cube
    present in the **Scene** window. This can be achieved via a simple drag and drop
    maneuver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these steps, your scene should now look similar to the one shown in *Figure
    2**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.8 – \uFEFFThe brick wall in the scene](img/B20869_02_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The brick wall in the scene
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now witnessed the prowess of materials in transforming a scene’s realism.
    In the next section, we will learn about another important component of any Unity
    scene in more detail: prefabs.'
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking a prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to convert a prefab from the sample scene
    into a regular GameObject in Unity. Prefabs are reusable, prefabricated objects
    that can be utilized multiple times within a scene, acting like building blocks
    for your environment. They are master copies of objects saved in separate files,
    allowing you to create multiple instances and streamline scene management.
  prefs: []
  type: TYPE_NORMAL
- en: To import a prefab, navigate to the `Assets` | `ExampleAssets` | `Prefabs`.
    Drag and drop the **ConstructionLight_Low** object from the **Scene Hierarchy**
    window into the scene. In the **Scene Hierarchy** window, you’ll notice a blue
    cube icon, indicating it is a prefab instance.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now unpack the **ConstructionLight_Low** object to turn it into a regular
    GameObject. Right-click in the **Scene Hierarchy** window and select **Prefab**
    | **Unpack**. This way, modifications to the prefab won’t affect the unpacked
    instance. Go ahead and position it in front of the brick wall.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to remember that using prefabs in Unity is advantageous in various
    scenarios, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repeating GameObjects**: Save time and effort by creating an object once,
    converting it into a prefab, and duplicating it as needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizing GameObjects**: Manage customizations more efficiently with a
    prefab containing all possible modifications, adjusting instances as required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modular game design**: Facilitate a modular design by creating prefabs for
    individual-level components and assembling them into a complete level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using prefabs in Unity helps save time, manage complex GameObjects, and support
    an adaptable, modular game design. Next, we’ll discuss how to import assets from
    the Unity Asset Store.
  prefs: []
  type: TYPE_NORMAL
- en: Importing from the Unity Asset Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s learn how to import and use models available on the Asset Store. The Unity
    Asset Store is a marketplace where users can find, purchase, and download a variety
    of assets, including 3D models, animations, audio, visual effects, and more, to
    use in their Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to import a spotlight model from the Asset Store:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your preferred web browser and navigate to the Unity Asset Store at [https://assetstore.unity.com/](https://assetstore.unity.com/).
    Here, input `Spotlight and Structure` in the search bar. Alternatively, you can
    directly access the package page via [https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453](https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have added the package to your assets, look for the **Open in Unity**
    button and click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Unity application should open with a prompt to import the package. Proceed
    with the **Import** operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon successful import, navigate to the package’s directory in the `Assets`
    | `SpaceZeta_Spotlight` | `Assets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Spotlight.fbx` and `SpotlightStructure1.fbx` files into the scene
    and unpack them (right-click, then select **Prefab** | **Unpack**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the objects appear magenta, this typically signifies that the associated
    materials are either absent or incompatible with the render pipeline currently
    in use. To fix this, select **Spotlight** and change the shader to **Universal
    Render Pipeline** | **Lit** in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: If your `Spotlight_basecolor.png`, `Spotlight_roughness.png`, `Spotlight_normal.png`,
    and `Spotlight_emission.png` files.
  prefs: []
  type: TYPE_NORMAL
- en: Now, your `BrickWallLight` and `BrickWallLightStructure` and transform them
    according to what is shown in *Figure 2**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.9 – \uFEFFThe imported BrickWallLight model and its BrickWallLightStructure\
    \ model](img/B20869_02_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – The imported BrickWallLight model and its BrickWallLightStructure
    model
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same procedure to find and import other 3D models, animations,
    audio, and visual effects that you need for your scene. In line with the `BrickWallLight`
    model that was imported just now, the next section deals with the most crucial
    aspects of lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Unity’s lighting pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A crucial aspect to consider before implementing your project is planning the
    lighting. Here, we present a proven approach that has consistently delivered exceptional
    lighting in a wide array of XR projects over the years, closely aligning with
    Unity’s best practice lighting pipeline ([https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html](https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html)).
    This process consists of three primary steps, as shown in *Figure 2**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.10 – \uFEFFUnity’s best practice lighting pipeline](img/B20869_02_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Unity’s best practice lighting pipeline
  prefs: []
  type: TYPE_NORMAL
- en: The selection of an appropriate render pipeline for your project is your initial
    step of the overall lighting pipeline process. As noted in *Table 2.1*, we recommend
    using URP for XR projects, which establishes the groundwork for effective lighting.
  prefs: []
  type: TYPE_NORMAL
- en: The second step of the lighting pipeline is to determine how **indirect lighting**
    should be generated by selecting a suitable **Global Illumination (GI) system**
    and corresponding **lighting mode**.
  prefs: []
  type: TYPE_NORMAL
- en: Think about a room with a single window on a sunny day. The direct light is
    like the bright sunlight that’s coming straight into the room through the window—it’s
    the light you would feel directly on your skin if you stood in the path of the
    window. That’s similar to what we mean by direct lighting in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Now, look at the corners of the room or the parts not directly in front of the
    window. They aren’t in complete darkness, right? They’re lit up, but not as brightly.
    That’s because the sunlight coming in hits different surfaces—the floor, walls,
    or furniture—and bounces off to these parts. This is what we refer to as indirect
    lighting.
  prefs: []
  type: TYPE_NORMAL
- en: The GI system in Unity mimics the rules of how light bounces around in the room.
    It’s the system that calculates how much light gets to the darker parts of the
    room based on how much it reflects off the surfaces it hits.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the lighting mode in Unity is akin to choosing what kind of surfaces
    you have in the room. Is it a shiny, reflective marble floor or a dark, matte
    wood floor? Depending on what you choose, the light would bounce off differently
    and light up the room in a unique way. This is what the lighting mode controls—it
    determines how the light interacts with different surfaces to create the overall
    lighting effect in your game scene.
  prefs: []
  type: TYPE_NORMAL
- en: With the GI settings tailored to your project’s requirements, it’s time to unleash
    your artistic vision. The last step of the lighting pipeline is to integrate lights,
    emissive surfaces, reflection probes, and light probes to harmoniously weave your
    scene’s illumination. By following this approach, you will construct a cohesive
    and detailed lighting environment, enhancing the realism and engagement of your
    virtual space and ensuring a high-quality user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to implement the steps of the lighting pipeline into our scene.
    With URP already chosen for your project, let’s proceed to the second phase of
    the lighting pipeline. Here, we’ll focus on understanding and selecting the appropriate
    lighting settings for your scene. This crucial step ensures your virtual world
    is lit effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right lighting settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve selected URP for your XR project, the next task is configuring indirect
    lighting. This process entails choosing a suitable GI system and lighting mode.
    **GI** imitates indirect light in 3D environments, leading to soft shadows and
    a natural appearance as light bounces between objects and surfaces. Unity’s lighting
    mode options present a variety of settings, each balancing visual quality and
    performance differently.
  prefs: []
  type: TYPE_NORMAL
- en: For simple mobile XR scenes, the most performant option is **Subtractive** mode,
    which relies on pre-calculated lightmaps to minimize **GPU** load and boost performance.
    **Shadowmask** mode follows closely, offering **real-time lighting** and baked
    shadows for static objects, striking a balance between visual quality and performance
    by reducing GPU load with pre-calculated shadows. Alternatively, **Baked Indirect
    Lighting** mode provides an ideal mix of real-time lighting, shadowing, and baked
    indirect lighting for high-quality XR visuals.
  prefs: []
  type: TYPE_NORMAL
- en: To set up indirect lighting, navigate to `Assets` folder, where it can be renamed.
    We suggest choosing **Mixed Lighting** by default, enabling the **Baked Global
    Illumination** option in the **Lighting** settings window. For the lighting mode,
    **Shadowmask** is the optimal choice for its balance between quality and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Though **Baked Global Illumination** permits automatic lightmap generation,
    we advise against it. Instead, manually generate lightmaps before testing the
    scene or after implementing changes as it provides the flexibility to test different
    lighting scenarios and iterate on your design without the overhead of constant
    automatic updates.
  prefs: []
  type: TYPE_NORMAL
- en: With that settled, you can proceed to place light objects within your scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding lights and a skybox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Light objects** in Unity are an essential part of creating an immersive and
    believable environment. There are several different light objects to choose from,
    including Point Lights, Spot Lights, Directional Lights, and Area Lights. They
    can be categorized under **direct lighting**, which refers to the light that is
    emitted directly from a light source. Let’s take a closer look at each light object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point Lights** emit light uniformly from a single point, ideal for localized
    sources such as lamps and candles. **Spot Lights** project light in a conical
    shape, perfect for directional sources such as flashlights and headlights. **Directional
    Lights** cast light in a single direction, resembling the sun or moon, while **Area
    Lights** disperse light from a specific area, akin to ceiling light panels.'
  prefs: []
  type: TYPE_NORMAL
- en: Each light type has unique properties, and when combined, they can produce diverse
    lighting effects. Comprehending these light types is key to achieving effective
    lighting in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by selecting the **Directional Light** GameObject in the **Scene
    Hierarchy** window and unchecking the checkbox at the top of its **Inspector**
    window. You’ll observe its substantial influence on the scene’s illuminance. However,
    you might be curious why the scene remains brighter than anticipated—the reason
    lies in the active **skybox**.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, a skybox serves as a backdrop that surrounds the scene, imparting
    a sense of environment and depth, similar to the sky and surrounding landscape
    in real life. A skybox is created using a specific material applied to a large
    cube that encloses the scene, consistently appearing behind all other elements.
    This cube generates the illusion of a sky and environment extending beyond the
    scene’s actual boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Skyboxes play a crucial role in indirect lighting, as they impact the scene’s
    overall lighting ambiance. For instance, a bright sky with a blazing sun casts
    warm light over the scene, fostering a welcoming and inviting atmosphere. Conversely,
    a dark sky featuring a full moon casts cool, blue light over the scene, cultivating
    a more eerie and mysterious mood. Other examples of indirect lighting in Unity
    encompass GI, ambient light, and lightmaps, which all contribute to the final
    visual experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create and apply a totally dark skybox, following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new material, navigate to the `Materials` folder within the **Project**
    window. Right-click and choose **Create** | **Material**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new material `DarkSkybox_Mat` and select it to see its properties in
    the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the shader type by going to **Skybox** | **Procedural** and keep the
    default settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the new **Skybox** material to the sky.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your scene should now resemble the one shown in *Figure 2**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.11 – \uFEFFThe skybox applied to the scene](img/B20869_02_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The skybox applied to the scene
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see that the elements in the scene are only visible because of
    the activated spotlight emanating from the **ConstructionLightLow** object. Since
    the influences of indirect lighting conditions have been eliminated, it is time
    to experiment with the remaining different light types.
  prefs: []
  type: TYPE_NORMAL
- en: First, select the **Spot Light** child object of the **ConstructionLightLow**
    object and then go to the **Inspector** window. Here, change the light type to
    **Point**, which, while not entirely suitable for the construction light, will
    serve to illustrate the shift in behavior. A Point Light, you see, radiates its
    luminance in all directions, unlike the focused beam of a Spot Light.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us breathe life into the imported `BrickWallLight` object. To do so,
    add an empty child object to its existing child object. Rename it `Light` and
    proceed by selecting `Light`. With **Spot** as the chosen type, you are free to
    adjust **Position**, **Color**, **Intensity**, and other parameters to your heart’s
    content. To witness the full extent of your creation’s influence, momentarily
    disable the **ConstructionLightLow** object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have arrived at the last uncharted territory of light types—the
    Area Light. *Figure 2**.12* demonstrates the incorporation of an Area Light into
    our scene, elevating it to new heights of brilliance.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.12 – \uFEFFAn Area Light illuminating the scene](img/B20869_02_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – An Area Light illuminating the scene
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate an Area Light in your scene, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `1.3`, `0.75`, `0.1` ), and change its **Position** and **Rotation** parameters
    so that it is approximately aligned with the white cube light shown in *Figure
    2**.12*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the object `Cube Light`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty child object. Right-click and select `Area Light`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Light`. Now, you will find the option to change the light type to **Area
    (baked only)**. Temporarily extinguish all other sources of light within your
    scene by unchecking their respective checkboxes in the **Inspector** window. You
    may observe that the scene plunges into darkness, with the Area Light seemingly
    unable to fulfill its illuminating duties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unity offers a duo of lighting systems: **real-time lighting** and **precomputed
    lighting**. Real-time lighting illuminates the scene dynamically, shifting with
    the player’s movements through the environment. In contrast, precomputed lighting
    calculates the scene’s luminance before the game commences, delivering a stable
    and optimized lighting experience. A third, hybrid mode known as mixed lighting
    combines the best of both worlds, allowing flexibility in determining which parts
    of the scene utilize real-time and precomputed lighting.'
  prefs: []
  type: TYPE_NORMAL
- en: Area Lights only allow precomputed lighting, requiring us to first bake a lightmap
    and assign its **emissive surface** to the GameObjects illuminated by the light.
    Baking a lightmap involves pre-calculating lighting data and storing it in a texture,
    optimizing the scene’s lighting during runtime. Baking is a one-time process that’s
    repeated only when lighting conditions change.
  prefs: []
  type: TYPE_NORMAL
- en: To start, identify the GameObjects affected by the `Area Light`, such as the
    `Wall` object and `Cube Light` object itself, and activate their **Static** checkboxes
    in the **Inspector** window. Next, bake the lightmap by navigating to **Window**
    | **Rendering** | **Lighting**, and switching to the **Baked Lightmaps** tab.
    Click on **Generate Lighting** to see the transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that only the `Wall` object appears to shine, while the `Cube Light`
    object doesn’t. This occurs because there’s no object to reflect its light, as
    with the `Ground` object below.
  prefs: []
  type: TYPE_NORMAL
- en: To enhance the scene, focus on the `Ground`, `BrickWallLight`, `BrickWallLightStructure`
    objects and their respective children. Enable their **Static** checkboxes and
    bake the lightmap once more. Observe the transformation of your scene.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.13* highlights the difference when using emissive surfaces with
    Area Lights.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.13 – \uFEFFThe influence of emissive surfaces of an Area Light](img/B20869_02_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – The influence of emissive surfaces of an Area Light
  prefs: []
  type: TYPE_NORMAL
- en: The left image of *Figure 2**.13* features only the wall and Area Light as emissive
    surfaces, while the right image includes multiple GameObjects, resulting in a
    more dynamic, visually engaging experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let's reactivate the lights of the `BrickWallLight` and the **ConstructionLightLow**
    objects. By doing so, we embrace the principle of mixed lighting, merging the
    strengths of both real-time and precomputed lighting. As a result, the objects
    within our scene become illuminated in a harmonious blend.
  prefs: []
  type: TYPE_NORMAL
- en: As an XR developer, the choice of lighting is a reflection of your artistic
    vision and the demands of your scene. Real-time lighting captivates with its dynamism,
    precomputed lighting entrances with its stability, and mixed lighting enchants
    with its versatility. In the last section of this chapter, we’ll introduce light
    and reflection probes.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring light and reflection probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let’s delve into **reflection probes** and **light probes** by revisiting
    our **SampleScene** object. To access it, navigate to **Assets** | **Scenes**
    in the **Project** window and double-click on the **SampleScene** object.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, reflection probes and light probes contribute to the creation of realistic
    lighting and reflections within a scene. Reflection probes capture reflection
    data from the surrounding environment and apply it to the scene’s objects. By
    capturing a 360-degree view of the environment and storing it as a cube map, reflection
    probes enable accurate reflections on reflective surfaces in the scene. For instance,
    if you want a shiny car in a game to reflect nearby trees and the sky, place a
    reflection probe near the car to gather environmental data and apply it to the
    car’s reflections.
  prefs: []
  type: TYPE_NORMAL
- en: Light probes, conversely, capture lighting data from the surrounding environment
    and apply it to the scene’s objects. By placing probes at various points in the
    scene, they gather lighting information and store it as a texture. This texture
    is then utilized to provide realistic lighting to objects in the scene. For example,
    if a character is standing in a forest, you could place light probes around the
    character to capture lighting information from the trees and apply it to the character’s
    skin.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the **SampleScene** object in the **Scene Hierarchy** window, we can
    see it contains three reflection probes and a light probe group with numerous
    light probes. The images in *Figure 2**.14* showcase the appearance of selected
    reflection probes (left side) and light probes (right side).
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.14 – \uFEFFReflection and light probes in the sample scene](img/B20869_02_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Reflection and light probes in the sample scene
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, not using reflection probes and light probes in a scene may result
    in less realistic lighting and reflections. However, if your scene doesn’t feature
    highly reflective objects or if the lighting is mostly uniform, removing the probes
    might not create a noticeable difference in the final result. In the case of this
    **SampleScene** object, this could very well be true.
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated, reflection and light probes are potent tools for significantly
    enhancing a scene’s realism in Unity. Nevertheless, their use is not always required
    or discernible in simpler scenes, as Unity’s built-in lightmapping technology
    is adept at approximating lighting and reflections without resorting to probes.
  prefs: []
  type: TYPE_NORMAL
- en: With a grasp of these principles, you’re equipped to create immersive and visually
    captivating XR experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you constructed a fundamental scene, familiarized yourself
    with the Unity Editor, started learning how to import assets to your own project,
    and were introduced to the essential aspects of lighting.
  prefs: []
  type: TYPE_NORMAL
- en: You embarked on this journey by installing Unity through the Unity Hub and establishing
    a new project with a sample scene using URP. You then explored the Unity Editor’s
    basics, such as navigating its numerous windows and utilizing the scene editing
    options, including Grid and Snap. Moreover, you delved into GameObjects and their
    components, such as colliders.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, you crafted your very own rudimentary scene, complete with a ground
    plane, a brick wall, and a table supporting a sphere. Along the way, you discovered
    the potency of materials, applied some, and designed your own advanced brick wall
    material using an imported image as a texture. You also examined the usefulness
    of prefabs and learned how to transform them into regular GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you grasped the importance of importing assets by searching for
    and importing a spotlight from the Asset Store, addressing potential issues that
    may arise due to render pipeline incompatibilities. Finally, you delved into the
    expansive subject of lighting, understanding, and implementing Unity’s best practices
    lighting pipeline within your basic scene. In doing so, you identified the ideal
    render pipeline, selected the right lighting settings, and experimented with various
    lights, including Point Lights, Spot Lights, Directional Lights, and Area Lights.
    You also employed skyboxes and became acquainted with light and reflection probes.
  prefs: []
  type: TYPE_NORMAL
- en: Building upon this solid foundation, you are now prepared to delve deeper into
    Unity and create increasingly complex and captivating scenes. In the next chapter,
    we will construct our first VR scene, deploy it, and test it on various VR headsets
    or simulators, further expanding your understanding and mastery of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Interactive XR Applications with Custom Logic, Animations, Physics,
    Sound, and Visual Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After delving into the Unity Engine intricacies and exploring various XR technologies
    in the first part of this book, this part covers all the essentials of XR development,
    taking you from a beginner to an intermediate level. In this part, you’ll master
    the creation of your first VR and AR experiences, including deployment to different
    devices and testing without specific VR headsets or smartphones, using simulators.
    Once you have a solid understanding of creating and deploying basic XR scenes,
    you’ll progress to developing more advanced XR applications.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll add interactivity to your XR applications, utilizing no-code options
    such as button clicks, and delve into more complex logic by scripting in C#. While
    this part contains numerous coding segments, don’t worry – we’ll explain C# in
    a beginner-friendly manner. Additionally, you’ll discover how to enhance the realism
    of your XR scenes by incorporating sounds and particle effects, while ensuring
    these physical phenomena adhere to real-world physics laws.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B20869_03.xhtml#_idTextAnchor009), *VR Development in Unity*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B20869_04.xhtml#_idTextAnchor011), *AR Development in Unity*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B20869_05.xhtml#_idTextAnchor016), *Building Interactive VR Experiences*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20869_06.xhtml#_idTextAnchor020), *Building Interactive AR Experiences*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20869_07.xhtml#_idTextAnchor024), *Adding Sound and Visual Effects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
