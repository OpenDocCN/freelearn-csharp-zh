- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with ASP.NET Core Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ASP.NET Core** is a cross-platform, open-source web application framework
    for building modern, cloud-enabled web applications and APIs. It is primarily
    used with the C# programming language. ASP.NET Core provides features to help
    you build web apps in various ways – for example, through ASP.NET MVC, web APIs,
    Razor Pages, Blazor, and so on. This book will mainly cover web APIs. In this
    chapter, we will learn how to build a simple REST web API with ASP.NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple REST web API project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the MVC pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency** **injection** (**DI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide you with the necessary information to create a basic
    REST web API project with ASP.NET Core. By the end of this chapter, you should
    have a better understanding of the steps required to create your first ASP.NET
    Core web API project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are expected to know the basic concepts of **.NET Framework** or **.NET
    Core**, and **object-oriented programming** (**OOP**). You should also have a
    basic understanding of the **C#** programming language. If you are not familiar
    with these concepts, you can refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET** **fundamentals**: [https://learn.microsoft.com/en-us/dotnet/fundamentals/](https://learn.microsoft.com/en-us/dotnet/fundamentals/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C#**: [https://learn.microsoft.com/en-us/dotnet/csharp/](https://learn.microsoft.com/en-us/dotnet/csharp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OOP (****C#)**: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core is fully cross-platform and can run on Windows, Linux, and macOS,
    so you can use any of these platforms to develop ASP.NET Core applications. The
    code samples in this book are written on Windows 11\. However, you can run the
    same code on Linux and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: There are also several IDEs available for ASP.NET Core, such as Visual Studio,
    **Visual Studio Code** (**VS Code**), Visual Studio for Mac, and Rider. In this
    book, we will mainly use VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Why not Visual Studio?
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio is a powerful IDE for the .NET platform. It provides a bunch of
    tools and features to elevate and enhance every stage of software development.
    However, VS Code is more lightweight and is open-source and cross-platform. We
    will use VS Code to understand the concepts of ASP.NET Core, then migrate to Visual
    Studio to use its rich features. If you are familiar with Visual Studio or any
    other IDE, feel free to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of software, SDKs, and tools you need to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VS** **Code**: [https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET 8** **SDK**: [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both VS Code and the .NET 8 SDK are cross-platform, so please choose the correct
    one for your OS. When you install VS Code, please make sure you check the **Add
    to** **PATH** option.
  prefs: []
  type: TYPE_NORMAL
- en: If you use Windows, you may want to install **Windows Terminal** to run the
    command line. Windows Terminal is available for Windows 10 and above, and it provides
    a better user experience. But it is optional because you can also use the command
    line directly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strictly speaking, VS Code is a code editor. It cannot recognize all the coding
    languages. Therefore, you’ll need to install some extensions to support your development
    workflow. You can browse and install extensions by clicking on the **Extensions**
    icon in the **Activity** bar on the left-hand side of the VS Code interface. Then,
    you will see a list of the most popular extensions on the VS Code Marketplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The C# Dev Kit extension for VS Code](img/B18971_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Overview of the C# Dev Kit extension for VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install this extension to support .NET development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C# Dev Kit**: This is the official C# extension for VS Code provided by Microsoft.
    When you install C# Dev Kit, the following extensions will automatically be installed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C# extension**: This extension provides C# language support powered by OmniSharp'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IntelliCode for C# Dev Kit**: This extension provides AI-assisted IntelliSense
    for C#'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Runtime Install Tool**: This extension provides a unified way to install
    local, private versions of the .NET runtime'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The C# Dev Kit extension provides a lot of features to help you develop .NET
    applications. Press *Ctrl* + *Shift* + *P* (on Windows) or *Command* + *Shift*
    + *P* (on macOS) to open the Command Palette, then type `.net` to see the commands
    provided by the C# Dev Kit extension. You can use these commands to create new
    projects, generate assets for build and debug, run tests, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also install the following extensions to improve your productivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EditorConfig for VS Code**: This extension provides EditorConfig support
    for VS Code. EditorConfig helps teams of multiple developers maintain consistent
    coding styles when working on the same project across various editors and IDEs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Copilot**: GitHub Copilot is your AI pair programmer. You can get
    code suggestions in real-time based on your context and comments in VS Code. This
    extension is not free, but you can try it for free for 30 days. If you are a student,
    a teacher, or a maintainer of a popular open-source project, you can get it for
    free.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To configure EditorConfig, you can create a file named `.editorconfig` in the
    root folder of the project. You can find a sample EditorConfig file at [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options).
  prefs: []
  type: TYPE_NORMAL
- en: Checking the .NET SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you install the .NET SDK, you can check the version by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to see the version number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft releases new versions of .NET SDKs frequently. If you encounter a
    different version number, that is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list all available SDKs by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will list all the available SDKs on your machine. For
    example, it may show the following output if have multiple .NET SDKs installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Multiple versions of .NET SDKs can be installed at the same time. We can specify
    the version of the .NET SDKs in the project file.
  prefs: []
  type: TYPE_NORMAL
- en: Which version of the SDKs should I use?
  prefs: []
  type: TYPE_NORMAL
- en: Every Microsoft product has a lifecycle. .NET and .NET Core provides **Long-term
    support** (**LTS**) releases that get 3 years of patches and free support. When
    this book was written, .NET 7 is still supported, until May 2024\. Based on Microsoft's
    policy, even numbered releases are LTS releases. So .NET 8 is the latest LTS release.
    The code samples in this book are written with .NET 8.0.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about .NET support policies, please visit [https://dotnet.microsoft.com/en-us/platform/support/policy](https://dotnet.microsoft.com/en-us/platform/support/policy).
  prefs: []
  type: TYPE_NORMAL
- en: We are now prepared to start developing ASP.NET Core applications. Let’s get
    to work!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple REST web API project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the **.NET command-line interface** (**.NET CLI**)
    to create a basic web API project and see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET CLI is a command-line tool that helps you to create, develop, build,
    run, and publish .NET applications. It is included in the .NET SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have multiple ways to run .NET CLI commands. The most common way is to
    run the command in the terminal window or command prompt. Also, you can run the
    command in VS Code directly. VS Code provides an integrated terminal that starts
    at the root of your workspace. To open the terminal in VS Code, you can do any
    one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *`* (on Windows) or *Command* + *`* (on macOS) to open the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the **View** | **Terminal** menu item to open the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the Command Palette, use the **View: Toggle Terminal** command to open
    the terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the terminal, navigate to a folder where you want to create the project,
    then create a web API project by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands create a new web API project and open it in VS Code.
    `dotnet new` provides many options to create various types of projects, such as
    web APIs, console apps, class libraries, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some options we can use to specify the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-n|--name <OUTPUT_NAME>`: The name for the created output. If not specified,
    the name of the current directory is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o|--output <OUTPUT_PATH>`: The output path for the created project. If not
    specified, the current directory is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-controllers|--use-controllers`: Indicates whether to use controllers for
    actions. If not specified, the default value is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-minimal|--use-minimal-apis`: Indicates whether to use minimal APIs. The default
    value is `false`, but the `-controllers` option will override the `-minimal` option.
    If neither `-controllers` nor `-minimal` is specified, the default value of the
    `-controllers` option, which is `false`, will be used, so a minimal API will be
    created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 6.0, ASP.NET Core 6.0 provides a new way to create web API projects,
    which is called `--``use-controllers` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the `dotnet new` command, check this page: [https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new).
    We will introduce more details on the `dotnet` command in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use VS Code to open the project, the C# Dev Kit extension can create
    a solution file for you. This feature makes VS Code more friendly to C# developers.
    You can see the following structure in the Explorer view:'
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that VS 2022 will create a sln file for the project, but .NET
    CLI does not. When using VS Code to open the project, the C# DevKit will create
    the sln file. I think it's worth mentioning it here.
  prefs: []
  type: TYPE_NORMAL
- en: The C# Dev Kit extension provides a new feature, the solution explorer, which
    is located at the bottom. This feature is especially useful when working with
    multiple projects in one solution. You can drag and drop the **SOLUTION EXPLORER**
    to the top to make it more visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use VS Code to open the project, the C# Dev Kit extension can create
    a solution file for you. This feature makes VS Code more friendly to C# developers.
    You can see the following structure in the Explorer view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The solution explorer and the folder structure](img/B18971_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The solution explorer and the folder structure
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can start to build and run the project.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to build and run the project and introduce
    some useful tools to help you test the APIs. To make it compatible with all platforms,
    we will use .NET CLI commands to build and run the project. We will also learn
    how to debug the project in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to build and run the project is to use the `dotnet` command.
    You can run the following command to build the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will build the project and its dependencies and generate
    a set of binaries. You can find these binaries in the `bin` folder. The `bin`
    folder is the default output folder for the `dotnet build` command. You can use
    the `--output` option to specify the output folder. However, it is recommended
    to use the default `bin` folder. The binaries are some `.``dll` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might see the following popups when you use VS Code to open the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – VS Code prompts to restore dependencies](img/B18971_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – VS Code prompts to restore dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because VS Code inspects that the project is a .NET project, and it
    is trying to restore the dependencies. You can click the **Restore** button to
    restore the dependencies. Similarly, if you see other prompts from VS Code to
    add assets to debug the project, please select **Yes** in the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – VS Code prompts to add required assets to build and debug](img/B18971_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – VS Code prompts to add required assets to build and debug
  prefs: []
  type: TYPE_NORMAL
- en: Some commands, such as `dotnet build`, `dotnet run`, `dotnet test`, and `dotnet
    publish`, will implicitly restore dependencies. So don't worry if you missed out
    on these prompts.
  prefs: []
  type: TYPE_NORMAL
- en: If no errors or warnings are shown, that means the build is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run the following command to run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `dotnet run` command is a convenient way of running the project from the
    source code. Keep in mind that it is useful in development, but not for production.
    The reason is that if the dependencies are outside of the shared runtime, the
    `dotnet run` command will resolve the dependencies from the NuGet cache. To run
    the application in production, you need to create a deployment package with the
    `dotnet publish` command and deploy it. We will explore the deployment process
    in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be able to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a link in the output, such as `http://localhost:5247`. The port number
    was randomly generated when we created the project. In a browser, navigate to
    `http://localhost:<your_port>/swagger`. You will see the web API documentation
    with **Swagger UI**, which offers a web-based UI to provide information and tools
    to interact with the API. You can use Swagger UI to test APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Swagger UI](img/B18971_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: The API project is now running! You can see the web API template provides a
    `/WeatherForecast` endpoint. If you navigate to the `http://localhost:5247/WeatherForecast`
    link in the browser, you will see the API response.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support HTTPS, you may need to trust the HTTPS development certificate by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a dialog if the certificate was not previously trusted. Select
    **Yes** to trust the development certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Installing the certificate for local development](img/B18971_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Installing the certificate for local development
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the preceding command does not work on Linux. See your Linux
    distribution documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the port number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The port number is defined in the `launchSettings.json` file in the `Properties`
    folder. You can change the port number by editing the file. Based on the convention,
    when the web API project was created, a port from `5000` to `5300` will be selected
    for HTTP, and from `7000` to `7300` for HTTPS. Here is an example of the `launchSettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can update the port number here. Just keep in mind that the port number
    should be unique on your machine to avoid conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Hot Reload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use `dotnet run` to run the project, if you change the code, you need
    to stop the project and start it again. If your project is complicated, it takes
    time to stop and restart. To speed up development, you can use the `dotnet watch`
    command to enable the Hot Reload feature.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Hot Reload is a feature that allows you to apply code changes to a running
    app without restarting the app. It was first provided with .NET 6\. Instead of
    using `dotnet run`, you can use `dotnet watch` to activate Hot Reload in development.
    Once you update the code, the web browser will automatically refresh the page.
    However, Hot Reload does not support all code changes. In some cases, `dotnet
    watch` will ask you if you want to restart the application. There are some options:
    `Yes`, `No`, `Always`, and `Never`. Choose the appropriate option for the code
    change you want to apply, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The API project is now running, and we can start to test the API.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The browser can send a `GET` request easily, but it is not as simple for `POST`
    endpoints. There are various ways to call the API for testing purposes, such as
    Swagger UI, Postman, and other tools. In this section, we will introduce some
    tools you can use in the development stage.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We introduced how to use SwaggerHub to design APIs in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012).
    From version 5.0, ASP.NET Core enables OpenAPI support by default. It uses the
    `Swashbuckle.AspNetCore` NuGet package, which provides the Swagger UI to document
    and test the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Swagger UI to test the API directly. Expand the first `/WeatherForecast`
    API in Swagger UI and click the **Try it out** button. You will see an **Execute**
    button. Click the button, and you will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Testing an endpoint in Swagger UI](img/B18971_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Testing an endpoint in Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.7* demonstrates that the API is functioning correctly and is providing
    the expected response. To learn more about Swagger and OpenAPI, you can check
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger**: [https://swagger.io/](https://swagger.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenAPI**: [https://www.openapis.org/](https://www.openapis.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SmartBear**: [https://www.smartbear.com/](https://www.smartbear.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Postman** is a powerful API platform for building and using APIs. It is widely
    used by many individual developers and organizations. You can download it here:
    [https://www.postman.com/downloads/](https://www.postman.com/downloads/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `http://localhost:5247/WeatherForecast` as the URL. Then, click the
    **Send** button. You will see the response next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Using Postman to call the API](img/B18971_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Using Postman to call the API
  prefs: []
  type: TYPE_NORMAL
- en: 'Postman provides a rich set of features to test APIs. To learn more about Postman,
    check the official documentation: [https://learning.postman.com/docs/getting-started/introduction/](https://learning.postman.com/docs/getting-started/introduction/).'
  prefs: []
  type: TYPE_NORMAL
- en: HttpRepl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, and `PATCH` HTTP verbs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install HttpRepl, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation, you can use the following command to connect to our
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`<ROOT URL>` is the base URL of the web API, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the connection is built, you can use the `ls` or `dir` command to list
    the endpoints, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command shows the `WeatherForecast` endpoint supports a `GET`
    operation. Then, we can use the `cd` command to navigate to the endpoint, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the `get` command to test the endpoint, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Output of HttpRepl](img/B18971_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Output of HttpRepl
  prefs: []
  type: TYPE_NORMAL
- en: To disconnect, press *Ctrl* + *C* to exit.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about HttpRepl at [https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/](https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/).
  prefs: []
  type: TYPE_NORMAL
- en: Thunder Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you prefer to do everything in VS Code, **Thunder Client** is a great tool
    for testing APIs. Thunder Client is a lightweight REST API client extension for
    VS Code, allowing users to test their APIs without having to leave VS Code. This
    makes it an ideal choice for developers who want to streamline their workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – The Thunder Client extension for VS Code](img/B18971_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – The Thunder Client extension for VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, click the **Thunder Client** icon on the **Action**
    bar. From the sidebar, click the **New Request** button. The following UI will
    be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Testing the API with Thunder Client](img/B18971_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Testing the API with Thunder Client
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about Thunder Client, visit their GitHub page: [https://github.com/rangav/thunder-client-support](https://github.com/rangav/thunder-client-support).'
  prefs: []
  type: TYPE_NORMAL
- en: Using .http files in VS 2022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use Visual Studio 2022, you can use the `.http` file to test the API.
    The `.http` file is a text file that contains definitions of HTTP requests. The
    latest ASP.NET Core 8 template project provides a default `.http` file. You can
    find it in the `MyFirstApi` folder. The content of the file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines a variable named `MyFirstApi_HostAddress` with the value
    of the root URL of the API. The second line defines a `GET` request to the `/weatherforecast`
    endpoint. The third line defines an `Accept` header. In this case, it accepts
    the `application/json` content type. Open this file in Visual Studio 2022, and
    you will see the **Send Request** button on the left side of the request. Click
    the button, and you will see the response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Using the .http file to test the API in Visual Studio 2022](img/B18971_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Using the .http file to test the API in Visual Studio 2022
  prefs: []
  type: TYPE_NORMAL
- en: However, when this book was written, the `.http` files lacked some features,
    such as environment variables. Also, this feature is only available in Visual
    Studio 2022, so we will not use it in this book. But if you are interested in
    exploring this feature further, please refer to the Microsoft docs at [https://learn.microsoft.com/en-us/aspnet/core/test/http-files](https://learn.microsoft.com/en-us/aspnet/core/test/http-files)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: We have introduced some tools to test APIs. Let's now learn how to debug APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VS Code has a built-in debugging feature that allows you to debug code. Unlike
    Visual Studio, it needs a `launch.json` configuration for debugging. When you
    open an ASP.NET Core project in VS Code, it will prompt you to add some assets.
    If you choose `launch.json` file in the `.``vscode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you missed it, you can add it manually from the Debug view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Creating a launch.json file from the Debug view](img/B18971_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Creating a launch.json file from the Debug view
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot see the buttons in *Figure 2**.13*, you can open the Command
    Palette by pressing *Ctrl* + *Shift* + *P* (on Windows) or *Command* + *Shift*
    + *P* (on macOS), then type `.net` and choose `launch.json` file in the `.``vscode`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Generating a launch.json file from the Command Palette](img/B18971_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Generating a launch.json file from the Command Palette
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the default `launch.json` configuration is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This file specifies the configuration for debugging. Some important attributes
    are described next:'
  prefs: []
  type: TYPE_NORMAL
- en: The `program` attribute specifies the path to the executable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `args` attribute specifies the arguments to pass to the executable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cwd` attribute specifies the working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env` attribute specifies the environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not need to change anything in this file now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a breakpoint in the app. For example, we can set a breakpoint in the
    `Get()` method in the `WeatherForecastController.cs` file by clicking in the left
    margin of the code window. Once the breakpoint is set, you will see a red dot
    before the line number in the left margin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Setting up a breakpoint in VS Code](img/B18971_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Setting up a breakpoint in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug the app, open the **Debug** view by selecting the **Debugging** icon
    on the left-side menu. Make sure you choose the correct debugging configuration
    from the drop-down menu. For this case, please select **.NET Core Launch (web)**.
    Then, select the green arrow at the top of the pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Debugging the API in VS Code](img/B18971_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Debugging the API in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Send a request from any of the tools in the previous section, and you will
    see the program execution stops when it reaches the breakpoint, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Hitting the breakpoint in VS Code](img/B18971_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Hitting the breakpoint in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: The **Locals** section of the **VARIABLES** window will display the values of
    variables that are defined in the current context.
  prefs: []
  type: TYPE_NORMAL
- en: You can also type a variable in the **DEBUG CONSOLE** window to check the value
    directly. To execute the next step, you can use the control toolbar at the top
    of the VS Code window. You can run the code line by line to monitor its execution.
    It is helpful if we need to know how the program works.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned how to build, run, and test APIs, it is time to look at
    the code of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core MVC is a rich framework for building web applications with the
    **Model-View-Controller** (**MVC**) design pattern. The MVC pattern enables web
    applications to separate the presentation from the business logic. An ASP.NET
    Core web API project follows the basic MVC pattern, but it does not have views,
    so it only has a Model layer and a Controller layer. Let’s look at this in a bit
    more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Models**: Models are classes that represent the data that is used in the
    application. Normally, the data is stored in a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controllers` folder. *Figure 2**.18* shows an example of the MVC pattern in
    an web API project. However, the view layer is not included in the web API project.
    The request from the client will be mapped to the controller, and the controller
    will execute the business logic and return the response to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – The MVC pattern](img/B18971_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – The MVC pattern
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the code of the model and the controller in an ASP.NET
    Core web API project.
  prefs: []
  type: TYPE_NORMAL
- en: The model and the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the ASP.NET Core template project, you can find a file named `WeatherForecast.cs`.
    This file is a model. It is a pure C# class that represents a data model.
  prefs: []
  type: TYPE_NORMAL
- en: The controller is the `WeatherForecastController.cs` file located in the `Controllers`
    folder. It contains the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of the controller class has a parameter named `ILogger<WeatherForecastController>
    logger`. This parameter is used to log messages. It is injected with DI by the
    ASP.NET Core framework. We will talk about DI in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: This class has an `[ApiController]` attribute that indicates that it is a web
    API controller. It also has a `[Route("[controller]")]` attribute that indicates
    the URL of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: The `Get()` method has a `[HttpGet(Name = "GetWeatherForecast")]` attribute
    that indicates the name of the endpoint, and the `Get()` method is a `GET` operation.
    This method returns a list of weather forecasts as the response.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `[Route("[controller]")]` attribute is marked on the controller
    class. It means the path of the controller is `/WeatherForecast`. Currently, there
    is no `[Route]` attribute on the `Get()` method. We will learn more about routing
    in future sections.
  prefs: []
  type: TYPE_NORMAL
- en: We should now have a basic understanding of how ASP.NET Core web API works.
    The client sends the request to the web API, and the request will be mapped to
    the controller and the method. The controller will execute the business logic
    and return the response. We can use some methods to get, save, update, and delete
    data from the database in the controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us create a new API endpoint by adding a new model and controller.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new model and controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012), we showed an example REST
    API on [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    It returns a list of posts, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us implement a similar API. First, we need to create a new model. Create
    a new folder named `Models` in the project. Then, create a new file named `Post.cs`
    in the `Models` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: File-scoped namespace declaration
  prefs: []
  type: TYPE_NORMAL
- en: From C# 10, you can use a new form of namespace declaration, as shown in the
    previous code snippet, which is called a file-scoped namespace declaration. All
    the members in this file are in the same namespace. It saves space and reduces
    indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering why we assign an empty string to the `Title` and `Body`
    properties. This is because the properties are of type `string`. If we do not
    initialize the property, the compiler will complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Non-nullable property ''Title'' must contain a non-null value when exiting
    constructor. Consider declaring the property` `as nullable.`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the ASP.NET Core web API project template enabled the `<Nullable>enable</Nullable>`
    in the `<``PropertyGroup>` section.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types were introduced in C# 8.0\. They can minimize the likelihood
    of errors that cause the runtime to throw a `System.NullReferenceException` error.
    For example, if we forget to initialize the `Title` property, we may get a `System.NullReferenceException`
    error when we try to access a property of it, such as `Title.Length`.
  prefs: []
  type: TYPE_NORMAL
- en: With this feature enabled, any variable of a reference type is considered to
    be non-nullable. If you want to allow a variable to be nullable, you must append
    the type name with the `?` operator to declare the variable as a nullable reference
    type; for example, `public string Title? { get; set; }`, which explicitly marks
    the property as nullable.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about this feature, see [https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new file named `PostController.cs` in the `Controllers` folder.
    You can manually add it, or install the `dotnet-aspnet-codegenerator` tool to
    create it. To install the tool, run the following commands from the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands install a NuGet package required for scaffolding. The
    `dotnet-aspnet-codegenerator` tool is a scaffolding engine that is used to generate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run the following command to generate a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates an empty controller. The `-name` option specifies
    the name of the controller. The `-api` option indicates that the controller is
    an API controller. The `-outDir` option specifies the output directory. Update
    the content of the controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Target-typed new expressions
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a new `List` instance of a specific type, we will normally use
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var list =` `new List<Post>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`new Post() { Id = 1, UserId = 1, Title = "Post1", Body = "The first` `post."
    },`'
  prefs: []
  type: TYPE_NORMAL
- en: '`};`'
  prefs: []
  type: TYPE_NORMAL
- en: When the list is declared as `List<Post>`, the type is known, so it is not necessary
    to use `new Post()` here when adding new elements. The type specification can
    be omitted for constructors, such as `new()`. This feature was introduced in C#
    9.0.
  prefs: []
  type: TYPE_NORMAL
- en: The controller is named `PostsController`. The convention is the resource name
    with the `Controller` suffix. It is marked with the `ApiController` attribute,
    which indicates that the controller is a web API controller. It also has a `[Route("api/[controller]")]`
    attribute that indicates the URL of the controller. `[controller]` is like a placeholder,
    which will be replaced with the name of the controller in the routing. So, the
    route of this controller is `/api/posts`.
  prefs: []
  type: TYPE_NORMAL
- en: In this controller, we have a method named `GetPosts()`. This method returns
    a list of posts as the response. The method is marked with the `[HttpGet]` attribute,
    which indicates that this method is a `GET` operation. It does not have any route
    template, because it will match `/api/posts`. For other methods, we can use the
    `[Route("[action]")]` attribute to specify the route template.
  prefs: []
  type: TYPE_NORMAL
- en: The return type of the `GetPosts()` method is `ActionResult<IEnumerable<Post>>`.
    ASP.NET Core can automatically convert the object to JSON and return it to the
    client in the response message. Also, it can return other HTTP status codes, such
    as `NotFound`, `BadRequest`, `InternalServerError`, and so on. We will see more
    examples later.
  prefs: []
  type: TYPE_NORMAL
- en: If you run `dotnet run` or `dotnet watch`, then navigate to Swagger UI, such
    as `https://localhost:7291/swagger/index.html`, you will see the new API listed.
    The API is accessible at `/api/posts`.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the `/api/posts` endpoint returns a hardcoded list of posts. Let
    us update the controller to return a list of posts from a service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `Services` folder in the project. Then, create a new file named `PostService.cs`
    in the `Services` folder, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `PostsService` class is a simple demo service that manages the list of posts.
    It has methods to create, update, and delete posts. To simplify the implementation,
    it uses a static field to store the list of posts. This is just for demonstration
    purposes; please do not use this in production.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will follow the API design to implement CRUD operations. You can review
    the *REST-based API design* section of the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a GET operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The design for the `viewPost()` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation name** | **URL** | **HTTP method** | **Input** | **Response**
    | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `viewPost()` | `/``posts/{postId}` | `GET` | PostId | Post, 200 | View a
    post detail |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – The design for the `viewPost()` operation
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `PostController` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor method of the controller, we initialize the `_postsService`
    field. Note that we use the `new()` constructor to create an instance of the service.
    That means the controller is coupled with the `PostsService` class. We will see
    how to decouple the controller and the service in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Then, create a `GetPost()` method that returns a post with the specified ID.
    It has a `[HttpGet("{id}")]` attribute to indicate the URL of the operation. The
    URL will be mapped to `/api/posts/{id}`. `id` is a placeholder, which will be
    replaced with the ID of the post. Then, `id` will be passed to the `GetPost()`
    method as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If the post is not found, the method will return a `NotFound` response. ASP.NET
    Core provides a set of built-in response messages, such as `NotFound`, `BadRequest`,
    `InternalServerError`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you call the API now, it will return `NotFound` because we have not created
    a post.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CREATE operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The design for the `createPost()` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation name** | **URL** | **HTTP method** | **Input** | **Response**
    | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createPost()` | `/``posts` | `POST` | Post | Post, 201 | Create a new post
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.2 – The design for the `createPost()` operation
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method named `CreatePost()` in the controller. As the controller
    has been mapped to `api/posts`, we do not need to specify the route of this method.
    The content of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we call this endpoint, the `post` object will be serialized in the JSON
    format that is attached to the `POST` request body. In this method, we can get
    the post from the request and then call the `CreatePost()` method in the service
    to create a new post. Then, we will return the built-in `CreatedAtAction`, which
    returns a response message with the specified action name, route values, and post.
    For this case, it will call the `GetPost()` action to return the newly created
    post.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can test the API. For example, we can send a `POST` request in Thunder
    Client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the method to `POST`. Use the following JSON data as the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the `201 Created`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Sending a POST request](img/B18971_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Sending a POST request
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, send a `GET` request to the `api/posts/1` endpoint. We can get a response
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Sending a GET request](img/B18971_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Sending a GET request
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the post we created is stored in the memory of the service.
    Because we have not provided a database to store the data, if we restart the application,
    the post will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see how to implement an update operation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an UPDATE operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The design for the `updatePost()` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation name** | **URL** | **HTTP method** | **Input** | **Response**
    | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `updatePost()` | `/``posts/{postId}` | `PUT` | Post | Post, 200 | Update
    a new post |'
  prefs: []
  type: TYPE_TB
- en: Table 2.3 – The design for the `updatePost()` operation
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `UpdatePost()` method in the controller, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This method has a `[HttpPut("{id}")]` attribute to indicate that it is a `PUT`
    operation. Similarly, `id` is a placeholder, which will be replaced with the ID
    of the post. In the `PUT` request, we should attach the serialized content of
    the post to the request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, let us test the API with HttpRepl. Run the following command to
    connect to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can update the `GetPosts()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented `GET`, `POST`, and `PUT` operations. Next, you can try to
    implement the `DeletePost()` method using the `DELETE` operation by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example of the controller, there is a `_postsService` field
    that is initialized in the constructor method of the controller by using the `new()`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That says the `PostsController` class depends on the `PostsService` class, and
    the `PostsService` class is a dependency of the `PostsController` class. If we
    want to replace `PostsService` with a different implementation to save the data,
    we have to update the code of `PostsController`. If the `PostsService` class has
    its own dependencies, they must also be initialized by the `PostsController` class.
    When the project grows larger, the dependencies will become more complex. Also,
    this kind of implementation is not easy to test and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection** (**DI**) is one of the most well-known design patterns
    in the software development world. It helps decouple classes that depend on each
    other. You may find the following terms being used interchangeably: **Dependency
    Inversion Principle** (**DIP**), **Inversion of Control** (**IoC**), and DI. These
    terms are commonly confused even though they are related. You can find multiple
    articles and blog posts that explain them. Some say they are the same thing, but
    some say not. What are they?'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Dependency Inversion Principle is one of the *SOLID* principles in **object-oriented**
    (**OO**) design. It was defined by Robert C. Martin in his book *Agile Software
    Development: Principles, Patterns, and Practices*, *Pearson*, in 2002\. The principle
    states, “*high-level modules should not depend on low-level modules; both should
    depend on abstractions. Abstractions should not depend on details. Details should
    depend* *upon abstractions*.”'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding controller, we said `PostsController` depends on `PostsService`.
    The controller is the high-level module, and the service is the low-level module.
    When the service is changed, the controller must be changed as well. Keep in mind
    that the term *inversion* does not mean that the low-level module will depend
    on the high level. Instead, both of them should depend on abstractions that expose
    the behavior needed by high-level modules. If we invert this dependency relationship
    by creating an interface for the service, both the controller and the service
    will depend on the interface. The implementation of the service can change as
    long as it respects the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**IoC** is a programming principle that inverts the flow of control in an application.
    In traditional programming, custom code is responsible for instantiating objects
    and controlling the execution of the main function. IoC inverts the flow of control
    as compared to traditional control flow. With IoC, the framework does the instantiation,
    calling custom or task-specific code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used to differentiate a framework from a class library. Normally,
    the framework calls the application code, and the application code calls the library.
    This kind of IoC is sometimes referred to as the Hollywood principle: “*Don’t
    call us, we’ll* *call you*.”'
  prefs: []
  type: TYPE_NORMAL
- en: IoC is related to DIP, but it is not the same. DIP concerns decoupling dependencies
    between high-level modules and low-level modules through shared abstractions (interfaces).
    IoC is used to increase the modularity of the program and make it extensible.
    There are several technologies to implement IoC, such as **Service Locator**,
    DI, the template method design pattern, the strategy design pattern, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: DI is a form of IoC. This term was coined by Martin Fowler in 2004\. It separates
    the concerns of constructing objects and using them. When an object or a function
    (the client) needs a dependency, it does not know how to construct it. Instead,
    the client only needs to declare the interfaces of the dependency, and the dependency
    is injected into the client by external code (an injector). It makes it easier
    to change the implementation of the dependency. It is often similar to the strategy
    design pattern. The difference is that the strategy pattern can use different
    strategies to construct the dependency, while DI typically only uses a single
    instance of the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main types of DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor injection**: The dependencies are provided as parameters of the
    client’s constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setter injection**: The client exposes a setter method to accept the dependency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface injection**: The dependency’s interface provides an injector method
    that will inject the dependency into any client passed to it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these three terms are related, but there are some differences.
    Simply put, DI is a technique for achieving IoC between classes and their dependencies.
    ASP.NET Core supports DI as a first-class citizen.
  prefs: []
  type: TYPE_NORMAL
- en: DI in ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core uses constructor injection to request dependencies. To use it,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define interfaces and their implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the interfaces and the implementations to the service container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add services as the constructor parameters to inject the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can download the example project named `DependencyInjectionDemo` from the
    folder `samples/chapter2/ DependencyInjectionDemo/DependencyInjectionDemo` in
    the chapter's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps below to use DI in ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create an interface and its implementation. Copy the `Post.cs`
    file and the `PostService.cs` file from the previous `MyFirstApi` project to the
    `DependencyInjectionDemo` project. Create a new interface named `IPostService`
    in the `Service` folder, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may also need to update the namespace of the `Post` class and the `PostService`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we can register the `IPostService` interface and the `PostService` implementation
    to the service container. Open the `Program.cs` file, and you will find that an
    instance of `WebApplicationBuilder` named builder is created by calling the `WebApplication.CreateBuilder()`
    method. The `CreateBuilder()` method is the entry point of the application. We
    can configure the application by using the builder instance, and then call the
    `builder.Build()` method to build the `WebApplication`. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code utilizes the `AddScoped()` method, which indicates that the
    service is created once per client request and disposed of upon completion of
    the request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy the `PostsController.cs` file from the previous `MyFirstApi` project to
    the `DependencyInjectionDemo` project. Update the namespace and the `using` statements.
    Then, update the constructor method of the controller as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code uses the `IPostService` interface as the constructor parameter.
    The service container will inject the correct implementation into the controller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DI has four roles: services, clients, interfaces, and injectors. In this example,
    `IPostService` is the interface, `PostService` is the service, `PostsController`
    is the client, and `builder.Services` is the injector, which is a collection of
    services for the application to compose. It is sometimes referred to as a DI container.'
  prefs: []
  type: TYPE_NORMAL
- en: The `PostsController` class requests the instance of `IPostService` from its
    constructor. The controller, which is the client, does not know where the service
    is, nor how it is constructed. The controller only knows the interface. The service
    has been registered in the service container, which can inject the correct implementation
    into the controller. We do not need to use the `new` keyword to create an instance
    of the service. That says the client and the service are decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This DI feature is provided in a NuGet package called `Microsoft.Extensions.DependencyInjection`.
    When an ASP.NET Core project is created, this package is added automatically.
    If you create a console project, you may need to install it manually by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If we want to replace the `IPostService` with another implementation, we can
    do so by registering the new implementation to the service container. The code
    of the controller does not need to be changed. That is one of the benefits of
    DI.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us discuss the lifetime of services.
  prefs: []
  type: TYPE_NORMAL
- en: DI lifetimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, the service is registered using the `AddScoped()`
    method. In ASP.NET Core, there are three lifetimes when the service is registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient**: A transient service is created each time it is requested and
    disposed of at the end of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: In web applications, a scope means a request (connection). A scoped
    service is created once per client request and disposed of at the end of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: A singleton service is created the first time it is requested
    or when providing the implementation instance to the service container. All subsequent
    requests will use the same instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the difference between these lifetimes, we will use a simple
    demo service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new interface named `IDemoService` and its implementation named `DemoService`
    in the `Services` folder, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: 'IDemoService.cs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'DemoService.cs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The implementation will generate an ID and a time when it was created, and output
    it when the `SayHello()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can register the interface and the implementation to the service container.
    Open the `Program.cs` file and add the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a controller named `DemoController.cs`. Now, we can add the service
    as constructor parameters to inject the dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this example, if you test the `/demo` endpoint, you will see the GUID value
    and the creation time in the output change every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the lifetime to `AddSingleton()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The GUID values and the creation time values will be the same for all requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As the `DemoController` class only requests the `IDemoService` interface once
    for each request, we cannot differentiate the behavior between `scoped` and `transient`
    services. Let us look at a more complex example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the example code in the `DependencyInjectionDemo` project. There
    are three interfaces along with their implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Program.cs` file, we can register them to the service container as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a controller named `LifetimeController.cs`. The code is shown
    next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, `ScopedService` has two dependencies: `ITransientService`
    and `ISingletonService`. So, when `ScopedService` is created, it will ask for
    the instances of these dependencies from the service container. On the other hand,
    the controller also has dependencies: `IScopedService`, `ITransientService`, and
    `ISingletonService`. When the controller is created, it will ask for these three
    dependencies. That means `ITransientService` and `ISingletonService` will be needed
    twice for each request. But let us check the output of the following requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can see that in each request, `ScopedService` was created once, while `ITransientService`
    was created twice. In both requests, `SingletonService` was created only once.
  prefs: []
  type: TYPE_NORMAL
- en: Group registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the project grows, we may have more and more services. If we register all
    services in `Program.cs`, this file will be very large. For this case, we can
    use group registration to register multiple services at once. For example, we
    can create a service group named `LifetimeServicesCollectionExtensions.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an extension method for the `IServiceCollection` interface. It is used
    to register all services at once in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the `Program.cs` file will be smaller and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Action injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, one controller may need many services but may not need all of them
    for all actions. If we inject all the dependencies from the constructor, the constructor
    method will be large. For this case, we can use action injection to inject dependencies
    only when needed. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `[FromServices]` attribute enables the service container to inject dependencies
    when needed without using constructor injection. However, if you find that a service
    needs a lot of dependencies, it may indicate that the class has too many responsibilities.
    Based on the **Single Responsibility Principle** (**SRP**), consider refactoring
    the class to split the responsibilities into smaller classes.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this kind of action injection only works for actions in the
    controller. It does not support normal classes. Additionally, since ASP.NET Core
    7.0, the `[FromServices]` attribute can be omitted as the framework will automatically
    attempt to resolve any complex type parameters registered in the DI container.
  prefs: []
  type: TYPE_NORMAL
- en: Keyed services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ASP.NET Core 8.0 introduces a new feature known as keyed services, or named
    services. This feature allows developers to register services with a key, allowing
    them to access the service with that key. This makes it easier to manage multiple
    services that implement the same interface within an application, as the key can
    be used to identify and access the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have a service interface named `IDataService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This `IDataService` interface has two implementations: `SqlDatabaseService`
    and `CosmosDatabaseService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can register them to the service container using different keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can inject the service by using the `FromKeyedServices` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FromKeyedServices` attribute is used to inject the service by using the
    specified key. Test the API with HttpRepl, and you will see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyed services can be used to register singleton or transient services
    as well. Just use the `AddKeyedSingleton()` or `AddKeyedTransient()` method respectively;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that if an empty string is passed as the key, a default
    implementation for the service must be registered with a key of an empty string,
    otherwise the service container will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft releases new versions of .NET SDKs frequently. If you encounter a
    different version number, that is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will list all the available SDKs on your machine. For
    example, it may show the following output if have multiple .NET SDKs installed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Every Microsoft product has a lifecycle. .NET and .NET Core provides **Long-term
    support** (**LTS**) releases that get 3 years of patches and free support. When
    this book was written, .NET 7 is still supported, until May 2024\. Based on Microsoft’s
    policy, even numbered releases are LTS releases. So .NET 8 is the latest LTS release.
    The code samples in this book are written with .NET 8.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use VS Code to open the project, the C# Dev Kit extension can create
    a solution file for you. This feature makes VS Code more friendly to C# developers.
    You can see the following structure in the Explorer view:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses the `Swashbuckle.AspNetCore` NuGet package, which provides the Swagger
    UI to document and test the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps below to use DI in ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that in each request, `ScopedService` was created once, while `ITransientService`
    was created twice. In both requests, `SingletonService` was created only once.
  prefs: []
  type: TYPE_NORMAL
- en: Using primary constructors to inject dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Beginning with .NET 8 and C# 12, we can use the primary constructor to inject
    dependencies. A primary constructor allows us to declare the constructor parameters
    directly in the class declaration, instead of using a separate constructor method.
    For example, we can update the `PostsController` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]csharppublic class PostsController(IPostService postService) : ControllerBase'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // No need to define a private field to store the service
  prefs: []
  type: TYPE_NORMAL
- en: // No need to define a constructor method
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You can find a sample named `PrimaryConstructorController.cs` in the `Controller`
    folder of the `DependencyInjectionDemo` project.
  prefs: []
  type: TYPE_NORMAL
- en: When using the primary constructor in a class, note that the parameters passed
    to the class declaration cannot be used as properties or members. For example,
    if a class declares a parameter named `postService` in the class declaration,
    it cannot be accessed as a class member using `this.postService` or from external
    code. To learn more about the primary constructor, please refer to the documentation
    at https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors#primary-constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructors can save us from writing fields and constructor methods.
    So, we’ll use them in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use `new` to create service B, otherwise, service A will be tightly coupled
    with service B.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving a service when the app starts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we need a service in the `Program.cs` file, we cannot use constructor injection.
    For this situation, we can resolve a scoped service for a limited duration at
    app startup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a scope and resolves the `IDemoService` service from
    the service container. Then, it can use the service to do something. After the
    scope is disposed of, the service will be disposed of as well.
  prefs: []
  type: TYPE_NORMAL
- en: DI tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core uses DI heavily. The following are some tips to help you use DI:'
  prefs: []
  type: TYPE_NORMAL
- en: When designing your services, make the services as stateless as possible. Do
    not use static classes and members unless you have to do so. If you need to use
    a global state, consider using a singleton service instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carefully design dependency relationships between services. Do not create a
    cyclic dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use `new` to create a service instance in another service. For example,
    if service A depends on service B, the instance of service B should be injected
    into service A with DI. Do not use `new` to create service B, otherwise, service
    A will be tightly coupled with service B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a DI container to manage the lifetime of services. If a service implements
    the `IDisposable` interface, the DI container will dispose of the service when
    the scope is disposed of. Do not manually dispose of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When registering a service, do not use `new` to create an instance of the service.
    For example, `services.AddSingleton(new ExampleService());` registers a service
    instance that is not managed by the service container. So, the DI framework will
    not be able to dispose of the service automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using the service locator pattern. If DI can be used, do not use the `GetService()`
    method to obtain a service instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about the DI guidelines at [https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines](https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines).
  prefs: []
  type: TYPE_NORMAL
- en: Why there is no configuration method for the logger in the template project?
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core provides a built-in DI implementation for the logger. When the
    project was created, logging was registered by the ASP.NET Core framework. Therefore,
    there is no configuration method for the logger in the template project. Actually,
    there are more than 250 services that are automatically registered by the ASP.NET
    Core framework.
  prefs: []
  type: TYPE_NORMAL
- en: Can I use third-party DI containers?
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that you use the built-in DI implementation in ASP.NET
    Core. But if you need any specific features that it does not support, such as
    property injection, `Func<T>` support for lazy initialization, and so on, you
    can use third-party DI containers, such as *Autofac* ([https://autofac.org/](https://autofac.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, *Creating a simple web API project*, we created a simple
    web API project using the `dotnet new webapi -n MyFirstApi -controllers` command.
    The `-controllers` option (or `--use-controllers`) indicates that the project
    will use controller-based routing. Alternatively, the `-minimal` or `--use-minimal-apis`
    option can be used to create a project that uses minimal APIs. In this section,
    we will introduce minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs is a new feature introduced in ASP.NET Core 6.0\. It is a new way
    to create APIs without using controllers. Minimal APIs are designed to be simple
    and lightweight with minimal dependencies. They are a good choice for small projects
    or prototypes, and also for projects that do not need the full features of controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a minimal API project, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet new webapi -n` `MinimalApiDemo -minimal`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no `Controllers` folder in the project. Instead, you can find the
    following code in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `MapGet()` method to map the `GET` request to the
    `/weatherforecast` endpoint. The `MapGet()` method is an extension method of the
    `IEndpointRouteBuilder` interface. This interface is used to configure the endpoints
    in the application. Its extension method, `MapGet()`, returns an `IEndpointConventionBuilder`
    interface that allows us to use fluent APIs to configure the endpoint by using
    other extension methods, such as `WithName()` and `WithOpenApi()`. The `WithName()`
    method is used to set the name of the endpoint. The `WithOpenApi()` method is
    used to generate an OpenAPI document for the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us create a new `/posts` endpoint that supports CRUD operations. First,
    add the following code to the end of the `Program.cs` file to define a `Post`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines five endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /posts`: Get all posts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /posts`: Create a new post'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /posts/{id}`: Get a post by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /posts/{id}`: Update a post by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /posts/{id}`: Delete a post by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `WithTags` extension method to group these endpoints into a tag named
    `Posts`. In this example, a list is used to store the posts. In a real-world application,
    we should use a database to store the data.
  prefs: []
  type: TYPE_NORMAL
- en: Using DI in minimal APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Minimal APIs support DI as well. You can find the `IPostService` interface
    and its `PostService` implementation in the `Services` folder. Here is an example
    of using DI in minimal APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `IPostService` interface is used as a parameter of
    the action method. The DI container will inject the correct implementation into
    the action method. You can run the project and test the endpoints. It should have
    the same behavior as the controller-based project.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between minimal APIs and controller-based APIs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minimal APIs are simpler than controller-based APIs, allowing us to map endpoints
    to methods directly. This makes minimal APIs a good choice for quickly creating
    simple APIs or demo projects. However, minimal APIs do not support the full range
    of features that controllers provide, such as model binding, model validation,
    and so on. These features may be added in the future. Therefore, we will mainly
    use controller-based APIs and not discuss minimal APIs in detail in this book.
    If you want to learn more about minimal APIs, please refer to the official documentation
    at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a simple web API project and introduced how to run
    the project locally and call the APIs with different clients. We implemented basic
    CRUD operations using an in-memory list. Also, we explained how to use DI in ASP.NET
    Core. We explored the lifetime of services and learned some tips. In addition,
    we introduced minimal APIs. In the next chapter, we will delve further into the
    built-in components of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
