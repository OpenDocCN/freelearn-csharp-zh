<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting Up a JavaScript Environment</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we'll explore setting up your JavaScript development environment with examples in pure JavaScript and React. </p>
<p class="calibre2">In this chapter, you will gain an understanding of:</p>
<ul class="calibre7">
<li class="calibre8">Installing your IDE</li>
<li class="calibre8">How to set up your testing framework</li>
<li class="calibre8">Writing your first tests in JavaScript</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Node.js</h1>
                
            
            <article>
                
<p class="calibre2">Node.js, commonly called Node, is practically a requirement for doing modern web application development. In this section, we will discuss what Node is exactly, provide reasons why you need Node, and, finally, talk about where you can get Node installation instructions.</p>
<p class="calibre2">If you are already familiar with these subjects, then feel free to jump to the next section, where we discuss NPM in a similar fashion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is Node?</h1>
                
            
            <article>
                
<p class="calibre2">Node was created in late 2009 by Ryan Dahl. Based on Chrome's V8 engine, Node provides a JavaScript runtime built for the purpose of providing evented, non-blocking I/O (input/output) for serving web<span> </span>applications.</p>
<p class="calibre2">At the time, Chrome had created the fastest JavaScript engine available. At the same time, they had decided to open-source the code for it. For these two extremely compelling reasons, Node decided to use the V8 engine.</p>
<p class="calibre2">Ryan Dahl was unhappy with the performance, at the time, of the very popular Apache HTTP server. One of the problems with the way that Apache was handling concurrent connections was that it was creating a new thread for each connection. Task creation and task switching between these threads are both CPU-and memory-intensive. For these reasons, instead of using threads for concurrent connections, Dahl decided to write Node with the intent of using an event loop coupled with a callback paradigm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why do we need Node?</h1>
                
            
            <article>
                
<p class="calibre2">To perform TDD in JavaScript for a modern web application, we absolutely need Node. When writing a modern web application, you will very likely be using one of these popular frameworks: ReactJS, Angular, Ember.js, Vue.js, or Polymer. The majority of these applications require a compilation step in Node.</p>
<p class="calibre2">Another reason for using Node is that we want to take advantage of new features in JavaScript. Node doesn’t support these features itself, but libraries have been written that will allow you to transpile the newer versions of JavaScript, ECMAScript 2015+, into a version of JavaScript that is supported by your target browsers.</p>
<p class="calibre2">Lastly, for the purposes of this book, we need Node so that we can run our tests. Later, we will discuss how we can also run our tests continuously while we are writing our code. This is known as continuous testing and is a must-have for rapid development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing Node</h1>
                
            
            <article>
                
<p class="calibre2">There are several options for installing Node on your machine. We will cover installing manually and installing from a package management repository.</p>
<p class="calibre2">The benefits of using a package management repository are many. The main reason that you would want to install this way would be the benefit of version management. Node updates versions frequently, and using a package manager can help to notify you of available updates. It can also help install those updates in a simple and efficient manner. We will start with a manual install, followed by installing using a Linux package manager, a Mac OSX package manager, and finally a Windows package manager.</p>
<p class="calibre2">To install Node manually, open your favorite browser and go to<span> </span><a href="http://nodejs.org" class="calibre10">http://nodejs.org</a>. You should see something similar to the following screenshot. Regardless of your operating system, the Node website will have a download link for both current and <span><strong class="calibre1">Long Term Support</strong> (</span><strong class="calibre1">LTS</strong>) versions of Node installation files. For Windows and Mac, the Node website provides installers. For Linux, Node provides binaries and source code. Assuming you are familiar with your operating system, the installation process is fairly straightforward and shouldn't present any issues.</p>
<div class="cdpaligncenter"><img src="../images/00014.jpeg" class="calibre33"/></div>
<p class="calibre2">Package managers greatly simplify the installation of many applications. If you are unfamiliar with package managers in general, they are based on the concept of having a repository of applications and tools that are available for installation on the system the package manager is for. Almost every system available has a package manager for it now. Linux has a different package manager for many distributions. Mac uses a system called<span> </span><em class="calibre12">Homebrew, </em>and Windows has a package manager named<span> </span><em class="calibre12">Chocolatey</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linux</h1>
                
            
            <article>
                
<p class="calibre2">First, we will cover using the Ubuntu package manager, called <kbd class="calibre11">apt</kbd>, as Ubuntu is one of the most popular Linux systems. If you are using a different distribution, the process should be very similar. The only difference is the name of your package manager. Open a terminal window and enter the following commands to install Node for Ubuntu:</p>
<pre class="calibre19"><strong class="calibre1">$ sudo apt-get update</strong><br class="title-page-name"/><strong class="calibre1">$ sudo apt-get install nodejs</strong></pre>
<p class="calibre2">It's that simple; now the latest version of Node is installed and ready for you to begin using. These same commands will update Node when a new version is available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mac OSX</h1>
                
            
            <article>
                
<p class="calibre2">Mac doesn't come with a package manager preinstalled. To install Homebrew, you must open a Terminal and execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</strong></pre>
<p class="calibre2">Now that you have Homebrew installed, you also have one more requirement that you must fulfill. You must install Apple's Xcode, which can be found by searching the App Store. Just like any other application on a Mac, once you have found it, just click the Install application button, and Xcode will download and install:</p>
<div class="cdpaligncenter"><img src="../images/00015.jpeg" class="calibre34"/></div>
<p class="calibre2">Now that we have both prerequisites for Node installed on the system, installation is extremely simple. From a Terminal window, execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">$ brew install node</strong></pre>
<p class="calibre2">Updating Node is also just as simple. Occasionally, when you want to update, execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">$ brew update</strong><br class="title-page-name"/><strong class="calibre1">$ brew upgrade node</strong></pre>
<p class="calibre2">You now have the latest version of Node installed on your Mac.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Windows</h1>
                
            
            <article>
                
<p class="calibre2">Windows also has a package manager. Just like Mac, the Windows package manager does not come preinstalled. The package manager for Windows is named Chocolatey and can be found at<span> </span><a href="https://chocolatey.org" class="calibre10">https://chocolatey.org</a>:</p>
<div class="cdpaligncenter"><img src="../images/00016.jpeg" class="calibre35"/></div>
<p class="calibre2">To install Chocolatey, open a Command Prompt (<kbd class="calibre11">cmd.exe</kbd>) as administrator and execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">@"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"</strong></pre>
<p class="calibre2">After the Chocolatey installation has finished, you may need to restart the command window before you can use it. Restart the Command Prompt as an administrator, and then execute the following commands to install Node on windows using the Chocolatey package manager:</p>
<pre class="calibre19"><strong class="calibre1">C:\&gt;choco install nodejs</strong><br class="title-page-name"/><strong class="calibre1">C:\&gt;refreshenv</strong></pre>
<p class="calibre2">Once you've executed the first command, you will be prompted to execute a script. You will need to agree to run the script to install Node.</p>
<p class="calibre2">To upgrade Node using Chocolatey, execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">C:\&gt;choco upgrade nodejs</strong></pre>
<p class="calibre2">You may need to agree to run the installation script. If prompted, simply hit the <em class="calibre12">Y</em> key and press <em class="calibre12">Enter</em>. You now have the latest version of Node.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">NPM</h1>
                
            
            <article>
                
<p class="calibre2">NPM is a critical piece of the Node environment and community. Without NPM, Node would not have taken off quite like it has. In this section, we will discuss what NPM is, what NPM isn't, why you need NPM for doing Node development, and finally, where you can get NPM and how to install it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is NPM?</h1>
                
            
            <article>
                
<p class="calibre2">Initially released in early 2010, <strong class="calibre1">NPM</strong> (<strong class="calibre1">Node Package Manager</strong>). NPM was written by Isaac Z. Schlueter, and is now maintained by a team of developers. Although NPM has Node in the acronym, it can also be used to manage packages for the browser.</p>
<p class="calibre2">In the past few years, many package managers were created specifically for browser packages. One of the most prominent is<span> </span><em class="calibre12">Bower</em>. These secondary package managers were created because NPM was perceived as a package manager best suited for, or perhaps only suited for, managing Node packages. This belief has subsided; however, Bower’s own website now suggests that it not be used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why do we need NPM?</h1>
                
            
            <article>
                
<p class="calibre2">While you do need to install NPM, you don't necessarily have to use it. In late 2016, Facebook released an alternative package manager named <em class="calibre12">Yarn</em>, which uses the NPM registry, so all of your favorite packages are available. </p>
<p class="calibre2">There are likely other package management alternatives to NPM as well.<span> </span><span>These alternative package managers are important because they drive improvements in NPM, but ultimately, they </span>will likely fade and NPM<span> will continue to be the preferred package manager for Node, and for JavaScript in general. If you do decide to use an alternative package manager such as Yarn, you will need to install it using NPM.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing NPM?</h1>
                
            
            <article>
                
<p class="calibre2">Good news; you already have NPM installed if you have gone through the process of installing Node. You may occasionally want to upgrade NPM outside Node's release cycle. To attempt an upgrade, simply open your operating system's preferred console or Terminal window and execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install -g npm</strong></pre>
<p class="calibre2">NPM is just another executable on your computer. It takes a list of arguments or parameters. In this case, we are asking NPM to install a package. The second argument, <kbd class="calibre11">-g</kbd>, tells NPM that we want to install the requested package globally. Lastly, the package we are asking NPM to install is NPM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A quick introduction to JavaScript IDEs</h1>
                
            
            <article>
                
<p class="calibre2">While you don't need an <strong class="calibre1">IDE</strong> (<strong class="calibre1">Integrated Development Environment</strong>) per se, you will need a text editor. Why not have a text editor that does a little bit of the heavy lifting for you? There are, essentially, two types of IDEs available for JavaScript development. The first kind is really more of a text editor than anything else, whereas the second kind is a full-blown editor with compiling and source control built in.</p>
<p class="calibre2">While you can work on JavaScript with only a simple text editor and a console/Terminal window, we recommend using something with at least a little more power.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Visual Studio Code</h1>
                
            
            <article>
                
<p class="calibre2">Visual Studio Code, as described in the C# section, is a lightweight editor based on the Electron framework and developed in TypeScript, a language designed by Microsoft to extend JavaScript with static types. TypeScript compiles to JavaScript, so ultimately Visual Studio Code is a JavaScript application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why Visual Studio Code?</h1>
                
            
            <article>
                
<p class="calibre2">For working with JavaScript, there are several reasons why you might choose Visual Studio Code or one of the other Electron-based editors. VSCode is lightweight, has an extensive plugin architecture, is integrated with source control, and is very easy to set up and use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing Visual Studio Code</h1>
                
            
            <article>
                
<p class="calibre2">Installing VSCode is extremely simple. If you have already followed along in the <em class="calibre12">C#</em> section, then you likely have VSCode installed already. If not, here are some alternative ways to install it that were not discussed there.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linux</h1>
                
            
            <article>
                
<p class="calibre2">To install on Linux (again, this is an example for Ubuntu), simply execute the following commands:</p>
<pre class="calibre19"><strong class="calibre1">sudo apt-get update</strong><br class="title-page-name"/><strong class="calibre1">sudo apt-get install code # or code-insiders</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mac</h1>
                
            
            <article>
                
<p class="calibre2">Unfortunately, I don't have a fancy command-line way to install  VSCode on a Mac. Instead, go to the Visual Studio Code homepage at<span> </span><a href="https://code.visualstudio.com" class="calibre10">https://code.visualstudio.com</a><span> </span>and follow the installation instructions there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Windows</h1>
                
            
            <article>
                
<p class="calibre2">For Windows, just like with Node, we can install VSCode using Chocolatey. To install using<span> </span>Chocolatey (<a href="https://chocolatey.org/install" class="calibre10">https://chocolatey.org/install</a>), execute the following command in a console window. Remember, you may want to run the console as an administrator:</p>
<pre class="calibre19"><strong class="calibre1">C:\&gt; choco install visualstudiocode</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing the plugins you will need</h1>
                
            
            <article>
                
<p class="calibre2">The two plugins that we would recommend getting are<span> </span><kbd class="calibre11">npm</kbd> and<span> </span><kbd class="calibre11">npm-intellisense</kbd> because they will aid in the flow and provide hints when you are not 100% sure that you are using the correct package name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the testing environment</h1>
                
            
            <article>
                
<p class="calibre2">Visual Studio Code offers built-in test running capabilities. We are not going to choose those options for JavaScript development, however. For the purposes of test driving our application and demonstrating our approach to testing, we think using the available Terminal inside VSCode will be more appropriate and better suited to the flow that will be used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">WebStorm</h1>
                
            
            <article>
                
<p class="calibre2">WebStorm is a full-blown IDE written by JetBrains in Java.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why WebStorm?</h1>
                
            
            <article>
                
<p class="calibre2">WebStorm basically comes with everything you need to develop a JavaScript-based application. It also supports many of the JavaScript ecosystem alternatives to JavaScript, such as TypeScript, Flow, and React JSX. WebStorm also integrates seamlessly with many code-quality tools such as ESLine, TSLint, and JSHint.</p>
<p class="calibre2">The only downside to WebStorm is that it does cost money. But, when you look at it, a paid product is actually a good thing. The company making the paid product has a good reason to continue maintaining it. JetBrains offers the purchase of WebStorm through a single purchase or through a subscription. We suggest the subscription, as the upfront cost to you is minimized and JetBrains has more motivation to keep you happy this way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing WebStorm</h1>
                
            
            <article>
                
<p class="calibre2">To install WebStorm, we are going to use a newer program created by JetBrains called<span> </span><em class="calibre12">The JetBrains Toolbox App</em>. The Toolbox App is designed to track version updates and provide a common launching point for all JetBrains products. Once installed, it becomes very easy to install any of the JetBrains tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linux</h1>
                
            
            <article>
                
<p class="calibre2">There does not appear to be, at the time of writing, a way to install ToolBox or WebStorm from<span> </span><kbd class="calibre11">apt-get</kbd><em class="calibre12">.</em><span> </span>So, we will have to do it the hard way. Go to the ToolBox download page at<span> </span><a href="https://www.jetbrains.com/toolbox/app/" class="calibre10">https://www.jetbrains.com/toolbox/app/</a><span> </span>and download the Linux tarball. Then, open a Terminal to your download directory. Once there, execute the following commands:</p>
<pre class="calibre19"><strong class="calibre1">mv jetbrains-toolbox-&lt;version&gt;.tar.gz &lt;application directory root&gt;/jetbrains-toolbox-&lt;version&gt;.tar.gz</strong><br class="title-page-name"/><strong class="calibre1">cd &lt;application directory root&gt;</strong><br class="title-page-name"/><strong class="calibre1">tar –xj jetbrains-toolbox-&lt;version&gt;.tar.gz</strong><br class="title-page-name"/><strong class="calibre1">chmod –R 777 jetbrains-toolbox-&lt;version&gt;</strong><br class="title-page-name"/><strong class="calibre1">cd jetbrains-toolbox-&lt;version&gt;</strong><br class="title-page-name"/><strong class="calibre1">./jetbrains-toolbox</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mac</h1>
                
            
            <article>
                
<p class="calibre2">On Mac, we can again use Homebrew for installation. Just execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">brew cask install jetbrains-toolbox</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Windows</h1>
                
            
            <article>
                
<p class="calibre2">On Windows, we are able to use Chocolatey to install Toolbox. Execute the following command and then launch the app:</p>
<pre class="calibre19"><strong class="calibre1">choco install jetbrainstoolbox</strong></pre>
<p class="calibre2">Our ultimate goal when installing the Toolbox was to install WebStorm. So, with the Toolbox open, either sign in if you have purchased any JetBrains products or skip the sign in if you just want to try them out. Next, find WebStorm in the products list and click the button to install it. Once the install has finished, you will be able to click a <span>Launch</span> button that will replace the <span>Install</span> button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing the plugins you will need</h1>
                
            
            <article>
                
<p class="calibre2">We've got good news for plugins with WebStorm. WebStorm offers a great plugin community, with every plugin you could possibly want accessible through a plugin management system built into the application. For the purposes of this book, however, you don't actually need any. So, we are done installing plugins! In fact, if anything, WebStorm has too much functionality built in, and we will be ignoring or even turning off some of it so that we can work the way we want to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the testing environment</h1>
                
            
            <article>
                
<p class="calibre2">Just as in Visual Studio Code, for WebStorm we are not going to cover setting up any of the built-in test running capability. WebStorm offers a Terminal display that can be turned on and supports having multiple contexts open at the same time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Create React App</h1>
                
            
            <article>
                
<p class="calibre2">Now that you have Node and NPM installed and up-to-date, turn your attention to the application you want to test drive. Due to its constantly increasing popularity, we are choosing to explain and demonstrate Test-Driven Development by testing a React application.</p>
<p class="calibre2">According to the React website, React is <em class="calibre12">A JavaScript library for building user interfaces</em>. We are going to focus on using it for a front-end browser application, but it can be used to create mobile and desktop applications as well.</p>
<p class="calibre2">React was created and is maintained by Facebook. React was created to solve issues that Facebook had in its own user interface, and it is now taking the internet by storm. Facebook has also created a library called Create React App to quickly get a React application going.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is Create React App?</h1>
                
            
            <article>
                
<p class="calibre2">Create React App is an NPM package created by Facebook for the purpose of providing a zero-configuration way to create a react application. React requires quite a lot to get started, and it can take days to configure a React application manually. Create React App can reduce that time to under a minute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing the global module</h1>
                
            
            <article>
                
<p class="calibre2">Create React App has a global NPM package that must be installed before you can use the command-line utility to actually create a React application. To install the latest version of the Create React App global script, execute the following command in a console or Terminal window:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install -g create-react-app</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a React application</h1>
                
            
            <article>
                
<p class="calibre2">Once the global module is installed, you will be ready to start using Create React App. Creating a React application is extremely streamlined and simple. On my system, I have a directory <kbd class="calibre11">\projects</kbd> that I use to house all my front-end application projects. Open a console/Terminal window to a similarly purposed directory on your machine and execute the following command to create a new React application:</p>
<pre class="calibre19"><strong class="calibre1">\projects&gt;create-react-app &lt;projectName&gt;</strong></pre>
<p class="calibre2">In our case, the name of our test case is Speaker Meet, so as an example, my command is displayed as follows:</p>
<pre class="calibre19"><strong class="calibre1">\projects&gt;create-react-app speakermeet-spa</strong></pre>
<p class="calibre2">SpeakerMeet, as mentioned in the C# section, has both a back-end (the RESTful Web API) and a front-end (a React-based <strong class="calibre1">SPA</strong> (<strong class="calibre1">Single Page Application</strong>)). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running the Create React App script</h1>
                
            
            <article>
                
<p class="calibre2">When the <kbd class="calibre11">create-react-app</kbd> script finishes running, a list of available commands is displayed. You want to make sure that everything was successfully created. You can launch the application by executing the following command:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm start</strong></pre>
<p class="calibre2">If everything installed correctly, your default browser will open and a new React application will be running.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocha and Chai</h1>
                
            
            <article>
                
<p class="calibre2">Create React App supports testing right out of the box. Initially, Create React App uses a testing library named Jest. We want to use Mocha and Chai due to their popularity in the JavaScript community.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Jest</h1>
                
            
            <article>
                
<p class="calibre2">Jest is a testing framework written by Facebook. Just like Create React App, Jest is designed to be a zero-configuration tool. Jest also supports continuous testing and code coverage analysis.</p>
<p class="calibre2">Jest is designed to work within the common <strong class="calibre1">BDD</strong> (<strong class="calibre1">behavior-driven development</strong>) paradigms, as are many other JavaScript testing frameworks. As such, the testing functions<span> </span><kbd class="calibre11">describe</kbd> and<span> </span><kbd class="calibre11">it</kbd><span> </span>can both be used to write your tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocha</h1>
                
            
            <article>
                
<p class="calibre2">Mocha is another JavaScript testing framework and is the one we would like to use. As for library interaction differences, there doesn't appear to be much different in terms of base interactions. The differences come down to the assertion library and the mocking library.</p>
<div class="packt_infobox">Mocking, which will be covered in detail in <a target="_blank" href="part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195" class="calibre22">Chapter 4</a>, <em class="calibre20">What to Know Before Getting Started</em>, is essentially a way to provide alternative implementations of objects, classes, and functions, specifically to aid the testing process.</div>
<p class="calibre2">Mocha itself doesn't come with an assertion library, so one must be provided. The assertion library is what controls test results and how to verify that your code is executing correctly. Most developers who use Mocha rely on Chai for assertions.</p>
<p class="calibre2">As mentioned previously, another consideration is what<span> </span>mocking<span> </span>library you want to use. For many Mocha users, that library is unquestionably<span> </span><em class="calibre12">Sinon</em>.</p>
<p class="calibre2">We will explain the purpose of any and all parts of Mocha that we use in this book. If you want to know more or want the documentation for quick reference while you are developing, you can go to the Mocha home page at<span> </span><a href="https://mochajs.org" class="calibre10">https://mochajs.org</a>.</p>
<p class="calibre2">Mocha can be installed into a JavaScript application using the following command:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install mocha</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Chai</h1>
                
            
            <article>
                
<p class="calibre2">Chai is a BDD assertion library. Chai uses a fluent API to allow for extremely flexible assertions. The two most popular ways that Chai is used are through the<span> </span><em class="calibre12">should</em><span> </span>and<span> </span><em class="calibre12">expect</em><span> </span>interfaces provided. The way that Chai works, and in fact, the way that every testing frameworks assertion works, is by throwing an exception when the check done by the assertion fails.</p>
<p class="calibre2">For instance, if you had a variable named<span> </span><kbd class="calibre11">foo</kbd><span> </span>with a value<span> </span><em class="calibre12">3</em><span> </span>and your assertion was<span> </span><kbd class="calibre11">expect(foo).to.equal(5)</kbd><span> </span>when the test ran, that assertion would throw an exception with a message that says<span> </span><kbd class="calibre11">expected 3 to equal 5</kbd>.</p>
<p class="calibre2">To install Chai into your project, run the following command:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install chai</strong></pre>
<p class="calibre2">Once you have Chai installed, there is one more step that must be taken to be able to use it within your project. You must include the following import at the top of each test file in your application:</p>
<pre class="calibre19">import { expect } from ‘chai’;</pre>
<p class="calibre2">If you wish to use should assertions, you can either replace<span> </span><kbd class="calibre11">expect</kbd><span> </span>with<span> </span><kbd class="calibre11">should</kbd><span> </span>or add<span> </span><kbd class="calibre11">should</kbd><span> </span>inside the curly braces, separating it from<span> </span><kbd class="calibre11">expect</kbd><span> </span>with a comma.</p>
<p class="calibre2">For more information or to refer to the documentation, the Chai home page is<span> </span><a href="https://chaijs.com" class="calibre10">https://chaijs.com</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sinon</h1>
                
            
            <article>
                
<p class="calibre2">We won't be getting into mocking until <a target="_blank" href="part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 4</a>, <em class="calibre12">What to Know Before Getting Started</em>, but Sinon is the generally preferred mocking library among Mocha + Chai users. Some testing frameworks, such as Jest and Jasmine, come with their own mocking library features, but Mocha does not, and Sinon provides an excellent mocking experience.</p>
<p class="calibre2">To install Sinon into your project, execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install sinon</strong></pre>
<p class="calibre2">Once installed, you will need to import Sinon before you can use it. Use the following import statement to enable the use of Sinon:</p>
<pre class="calibre19">import sinon from ‘sinon’;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enzyme</h1>
                
            
            <article>
                
<p class="calibre2">Enzyme is a library designed to aid in the testing of React components.</p>
<p class="calibre2">To install Enzyme into your project, execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install enzyme react-test-renderer react-dom</strong></pre>
<p class="calibre2">The extra libraries listed,<span> </span><kbd class="calibre11">react-test-renderer</kbd><span> </span>and<span> </span><kbd class="calibre11">react-dom</kbd><span>, </span>are dependencies of Enzyme that it needs to function correctly.</p>
<p class="calibre2">As with the other testing utilities mentioned in this section, we will get into usage as needed, while we discuss the topics covered in this book. But here is a quick example of a test using Enzyme from the Enzyme documentation at<span> </span><a href="https://github.com/airbnb/enzyme" class="calibre10">https://github.com/airbnb/enzyme</a>:</p>
<pre class="calibre19">import React from 'react';<br class="title-page-name"/>import { expect } from 'chai';<br class="title-page-name"/>import { render } from 'enzyme';<br class="title-page-name"/>import Foo from './Foo';<br class="title-page-name"/><br class="title-page-name"/>describe('&lt;Foo /&gt;', () =&gt; {<br class="title-page-name"/>  it('renders three `.foo-bar`s', () =&gt; {<br class="title-page-name"/>    const wrapper = render(&lt;Foo /&gt;);<br class="title-page-name"/> <br class="title-page-name"/>    expect(wrapper.find('.foo-bar').length).to.equal(3);<br class="title-page-name"/>   });<br class="title-page-name"/> <br class="title-page-name"/>   it('renders the title', () =&gt; {<br class="title-page-name"/>      const wrapper = render(&lt;Foo title="unique" /&gt;);<br class="title-page-name"/>    <br class="title-page-name"/>      expect(wrapper.text()).to.contain('unique');<br class="title-page-name"/>   });}); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ejecting the React app</h1>
                
            
            <article>
                
<p class="calibre2">Unfortunately, this is where we part company with Create React App. In order to use Mocha, we will need to find an alternative way to work with the application. Because of the zero-configuration setup of Create React App, we cannot simply update the testing framework being used, and that is a problem for us.</p>
<p class="calibre2">Thankfully, Create React App gives us an out in the form of ejecting the application. Ejecting the React application will install all the necessary configuration files and utilities into our project and remove Create React App.  Once the ejection process is finished, we will have access to all the configuration files and we will have the ability to switch to using Mocha.</p>
<p class="calibre2">To eject Create React App, execute the following command:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm run eject</strong></pre>
<p class="calibre2">If you take a look at the <kbd class="calibre11">package.json</kbd> in the root of the project, you will see that a lot of information and configuration have been added.</p>
<div class="packt_tip">
<p class="calibre36">After any major modification to <kbd class="calibre37">package.json</kbd>, it is a good idea to delete <kbd class="calibre37">node_modules</kbd> and <kbd class="calibre37">package-lock.json</kbd> and then re-run <kbd class="calibre37">npm install</kbd>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring to use Mocha and Chai</h1>
                
            
            <article>
                
<p class="calibre2">After you have ejected the React app, before you make any further modifications, you should make sure everything still works. Execute the following command before making any further modifications:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm start</strong></pre>
<p class="calibre2">Now check that a browser launched and that the application is running correctly. You will have to <em class="calibre12">Ctrl</em> + <em class="calibre12">C</em> to exit the running process:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm run build</strong></pre>
<p class="calibre2">After this command, check that a build folder was created at the root of your project and that there were no errors displayed in the console:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm test</strong></pre>
<p class="calibre2">Even though you are about to change the test configuration, you will be using some of the libraries that were provided by Create React App. You want to make sure that those prerequisites transitioned properly when you ejected. As with<span> </span><kbd class="calibre11">npm start</kbd><span>, </span>you will have to <em class="calibre12">Ctrl</em> + <em class="calibre12">C</em> to exit this process.</p>
<p class="calibre2">Assuming all of the commands executed without issues, you can now start the process of switching the test environment over to Mocha. Execute the following command to ensure the installation of the necessary dependencies:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install mocha chai sinon enzyme</strong></pre>
<p class="calibre2">Open<span> </span><kbd class="calibre11">package.json</kbd><span> </span>and update the following lines:</p>
<pre class="calibre19">"babel": {<br class="title-page-name"/>   "presets": [<br class="title-page-name"/>     "react-app"<br class="title-page-name"/>   ]<br class="title-page-name"/> },</pre>
<p class="calibre2">Change the preceding code to:</p>
<pre class="calibre19">"babel": {<br class="title-page-name"/>   "presets": [<br class="title-page-name"/>     "react",<br class="title-page-name"/>     "es2015"<br class="title-page-name"/>   ]<br class="title-page-name"/> },</pre>
<p class="calibre2">You will also need to install the BabelJS preset for ES2015:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install babel-preset-es2015</strong></pre>
<p class="calibre2">Next, find and delete the<span> </span><kbd class="calibre11">jest</kbd><span> </span>setting in<span> </span><kbd class="calibre11">package.json</kbd>. You are now ready to change the<span> </span><kbd class="calibre11">test</kbd><span> </span>script to execute Mocha instead of Jest. Find NPM scripts and update the test script as follows:</p>
<pre class="calibre19">"test": "node scripts/test.js --env=jsdom"</pre>
<p class="calibre2">Change the preceding code to:</p>
<pre class="calibre19">"test": "mocha --require babel-core/register ./scripts/test.js --require babel-core/register ./src/**/*.spec.js"</pre>
<p class="calibre2">The change you just made will cause Mocha to execute all of your tests. It will only execute them once, though. You want a way to have your tests running continuously while you work, so you need to add an additional script. Add a comma to the end of the line you just modified and then add the following script just beneath<span> </span><kbd class="calibre11">test</kbd><em class="calibre12">:</em></p>
<pre class="calibre19">"test:watch": "npm test -- -w"</pre>
<p class="calibre2">Now, you need to update the<span> </span><kbd class="calibre11">test.js</kbd><span> </span>file provided when you ejected. Open<span> </span><kbd class="calibre11">&lt;project root&gt;/scripts/test.js</kbd><span> </span>and replace all the code inside with the following:</p>
<pre class="calibre19">'use strict';<br class="title-page-name"/><br class="title-page-name"/>import jsdom from 'jsdom';<br class="title-page-name"/><br class="title-page-name"/>global.document = jsdom.jsdom('&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;');<br class="title-page-name"/>global.window = document.defaultView;<br class="title-page-name"/>global.navigator = window.navigator;<br class="title-page-name"/><br class="title-page-name"/>function noop() {<br class="title-page-name"/>  return {};<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// prevent mocha tests from breaking when trying to require a css file<br class="title-page-name"/>require.extensions['.css'] = noop;<br class="title-page-name"/>require.extensions['.svg'] = noop;</pre>
<p class="calibre2">This file just sets up the base environment for your tests to execute inside. Make note of the<span> </span><kbd class="calibre11">noop</kbd><span> </span>function and usage. Currently, you are ignoring the <kbd class="calibre11">css</kbd> and <kbd class="calibre11">svg</kbd> extensions that are required by your production code when you are testing. In the course of testing, if you run into issues while requiring a different extension, you might have to come back to this file and add the troublesome extension to the list.</p>
<p class="calibre2">You are almost done; you only have one more modification to make before you are officially switched over to Mocha. Find the file<span> </span><kbd class="calibre11">App.test.js</kbd><span> </span>in your<span> </span><kbd class="calibre11">src</kbd><span> </span>directory, and change its name to<span> </span><kbd class="calibre11">App.spec.js</kbd><span>, </span>then update the contents to the following:</p>
<pre class="calibre19">import React from 'react';<br class="title-page-name"/>import ReactDOM from 'react-dom';<br class="title-page-name"/>import { expect } from 'chai';<br class="title-page-name"/> <br class="title-page-name"/>import App from './App';<br class="title-page-name"/> <br class="title-page-name"/>describe('(Component) App', () =&gt; {<br class="title-page-name"/>  it('renders without crashing', () =&gt; {<br class="title-page-name"/>    const div = document.createElement('div');<br class="title-page-name"/>    ReactDOM.render(&lt;App /&gt;, div);<br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="calibre2">All you have really done here is import Chai and add a<span> </span><kbd class="calibre11">describe</kbd><span> </span>block. The rest of this test has remained unchanged and is the default test provided with Create React App.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A quick kata to check our test setup</h1>
                
            
            <article>
                
<p class="calibre2">For this setup test, you are going to do the Palindrome code kata. This code kata can get complex, but you are only going to concern yourself with the most basic form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The requirements</h1>
                
            
            <article>
                
<p class="calibre2">The requirements for this kata are as follows:</p>
<pre class="calibre19"><strong class="calibre1">Given</strong><span> </span>a string value<br class="title-page-name"/> <strong class="calibre1">And Given</strong><span> </span>the provided string is not a palindrome<br class="title-page-name"/> <strong class="calibre1">When</strong><span> </span>checked<br class="title-page-name"/> <strong class="calibre1">Then</strong><span> </span>return false<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">Given</strong><span> </span>a string value<br class="title-page-name"/> <strong class="calibre1">And Given</strong><span> </span>the provided string is a palindrome<br class="title-page-name"/> <strong class="calibre1">When</strong><span> </span>checked<br class="title-page-name"/> <strong class="calibre1">Then</strong><span> </span>return true</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The execution</h1>
                
            
            <article>
                
<p class="calibre2">As you always should, you will begin with a templated test file designed to verify that the unit testing framework is configured correctly:</p>
<pre class="calibre19">import { expect } from 'chai';<br class="title-page-name"/> <br class="title-page-name"/>describe('Test Framework', () =&gt;  {<br class="title-page-name"/>  it('is configured correctly', () =&gt; {<br class="title-page-name"/>    expect(1).to.equal(0);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have shown a failing version of this template. Before you begin writing the tests that are actually for the kata, run the<span> </span><kbd class="calibre11">test:watch</kbd><span> </span>NPM script and verify that the test fails. Also, verify that it fails for the right reason. It should fail because<span> </span><em class="calibre12">1</em><span> </span>was expected but<span> </span><em class="calibre12">0</em><span> </span>was the actual result. After the test properly fails, change the zero to a one and verify that the test now passes. As long as these two validations work correctly, we will continue and begin working through the code kata.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Starting the kata</h1>
                
            
            <article>
                
<p class="calibre2">The first thing you will do for the kata is write an<span> </span><kbd class="calibre11">ItExists</kbd><span> </span>test. Again, these types of test help to get the ball rolling and prevent writer's block. You will replace the code for checking the framework with the following.</p>
<p class="calibre2"><em class="calibre12">Red phase</em>; write a failing test that expects an <kbd class="calibre11">isPalindrome</kbd> function to exist: </p>
<pre class="calibre19">describe('Is Palindrome', () =&gt; {<br class="title-page-name"/>  it('exists', () =&gt; {<br class="title-page-name"/>    expect(isPalindrome).to.exist;<br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="calibre2">Verify that this test fails. It's important to see a failure before moving on to making the test pass. This will help confirm that your test setup is working properly.</p>
<p class="calibre2">And now the <em class="calibre12">green phase</em>; make the test pass. Define an <kbd class="calibre11">isPalindrome</kbd> function and run the test once more to see it pass.</p>
<pre class="calibre19">function isPalindrome() {<br class="title-page-name"/>}</pre>
<p class="calibre2">For the next test, we want to think of the simplest test case that would produce a result. Again, we are skipping bad data issues. The simplest test case we can think of that would product a result is a single letter. For the definition of palindrome that you will be using for these tests, a single letter is a palindrome. Add the following test under the previous one:</p>
<pre class="calibre19">it('a single letter is a palindrome', () =&gt; {<br class="title-page-name"/>  // arrange<br class="title-page-name"/>  const value = 'a';<br class="title-page-name"/> <br class="title-page-name"/>  // act<br class="title-page-name"/>  const result = isPalindrome(value);<br class="title-page-name"/> </pre>
<pre class="calibre19">  // assert<br class="title-page-name"/>  expect(result).to.be.true;<br class="title-page-name"/>});</pre>
<p class="calibre2">Now, to make it pass:</p>
<pre class="calibre19">function isPalindrome() {<br class="title-page-name"/>  return true;<br class="title-page-name"/>}</pre>
<p class="calibre2">Now you have a passing test, but you are always returning true. You want the next test to fail when you write it. So, you should write a test for when the value passed in is not a palindrome. The simplest non-palindrome would be two letters that are not the same:</p>
<pre class="calibre19">it('two non-matching letters is not a palindrome', () =&gt; {<br class="title-page-name"/>  // arrange<br class="title-page-name"/>  const value = 'at';<br class="title-page-name"/> <br class="title-page-name"/>  // act<br class="title-page-name"/>  const result = isPalindrome(value);<br class="title-page-name"/> <br class="title-page-name"/>  // assert<br class="title-page-name"/>  expect(result).to.be.false;<br class="title-page-name"/>});</pre>
<p class="calibre2">Now, make it pass:</p>
<pre class="calibre19">function isPalindrome(value) {<br class="title-page-name"/>  if(value.length === 1) {<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  return false;<br class="title-page-name"/>}</pre>
<p class="calibre2">Okay, so now you only return true single letters. This opens us up for our next test, flipping back to something that is a palindrome; write a test for two letters that are the same:</p>
<pre class="calibre19">it('two matching letters are a palindrome', () =&gt; {<br class="title-page-name"/>  // arrange<br class="title-page-name"/>  const value = 'oo';<br class="title-page-name"/> <br class="title-page-name"/>  // act<br class="title-page-name"/>  const result = isPalindrome(value);<br class="title-page-name"/> <br class="title-page-name"/>  // assert<br class="title-page-name"/>  expect(result).to.be.true;<br class="title-page-name"/>});</pre>
<p class="calibre2">Now, to make it pass:</p>
<pre class="calibre19">function isPalindrome(value) {<br class="title-page-name"/>  if(value.length === 1) {<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  if(value.length === 2 &amp;&amp; value[0] === value[1]) {<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  return false;<br class="title-page-name"/>}</pre>
<p class="calibre2">The next test is to have a three-letter word that is a palindrome. Currently, this should fail:</p>
<pre class="calibre19">it('three letter palindrome', () =&gt; {<br class="title-page-name"/>  // arrange<br class="title-page-name"/>  const value = 'mom';<br class="title-page-name"/> <br class="title-page-name"/>  // act<br class="title-page-name"/>  const result = isPalindrome(value);<br class="title-page-name"/> <br class="title-page-name"/>  // assert<br class="title-page-name"/>  expect(result).to.be.true;<br class="title-page-name"/>});</pre>
<p class="calibre2">To make this test pass, think about what you have so far. One algorithm for checking a palindrome is to simply start on the outsides and check the two outermost letters. If those two letters are a match, then move in one letter on each side. Repeat this check until you get to the center of the word or phrase. If the center is one letter, then it's a palindrome; otherwise, check if the two center-most characters are a match. Let's try this concept out by using recursion to make the latest test pass:</p>
<pre class="calibre19">function isPalindrome(value) {<br class="title-page-name"/>  if(value.length === 1) {<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  if(value.length === 2 &amp;&amp; value[0] === value[1]) {<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  if(value[0] === value[value.length -1]) {<br class="title-page-name"/>    return isPalindrome(value.substring(1, value.length - 1));<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  return false;<br class="title-page-name"/>}</pre>
<p class="calibre2">We now need to check if a four-letter palindrome will pass:</p>
<pre class="calibre19">it('four letter palindrome', () =&gt; {<br class="title-page-name"/>  // arrange<br class="title-page-name"/>  const value = 'abba';<br class="title-page-name"/> <br class="title-page-name"/>  // act<br class="title-page-name"/>  const result = isPalindrome(value);<br class="title-page-name"/> <br class="title-page-name"/>  // assert<br class="title-page-name"/>  expect(result).to.be.true;<br class="title-page-name"/>});</pre>
<p class="calibre2">It passes; excellent! We will end this code kata with two<span> </span>exercises<span> </span>for you. The first exercise is to add a test for "a man a plan a canal panama" and make it pass. The second exercise is to refactor the code for <kbd class="calibre11">isPalindrome</kbd>. While this is a small function, it could still do with some tidying up, and potentially some optimizations. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">You should now have Node installed and your JavaScript development environment configured. JavaScript examples throughout the rest of the book will assume your use of WebStorm. </p>
<p class="calibre2">But, before diving right in, <a target="_blank" href="part0142.html#47DFS0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 4</a>, <em class="calibre12">What to Know Before Getting Started</em>, will focus on what more you need to know before getting started.</p>


            </article>

            
        </section>
    </body></html>