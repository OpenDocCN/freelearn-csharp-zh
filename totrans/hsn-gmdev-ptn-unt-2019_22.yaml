- en: Service Locator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器
- en: 'The Service Locator is a very straightforward pattern, and its name implies
    perfectly its purpose, which is locating services. In game development, services
    are usually game-mechanics-related systems that provide specific functionality—for
    example: spawners, save states, and online connectivity. Because games are mainly
    composed of layers of in-game systems communicating, functioning, and synchronizing
    with one another to simulate an interactive experience, the Service Locator creates
    a large number of dependencies between system components.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器是一个非常简单的模式，其名称完美地暗示了其目的，即定位服务。在游戏开发中，服务通常是提供特定功能的游戏机制相关的系统——例如：生成器、保存状态和在线连接。因为游戏主要由游戏内系统层组成，这些系统层相互通信、运行和同步以模拟交互式体验，所以服务定位器在系统组件之间创建了大量的依赖关系。
- en: 'So, having a way for services to find one another through a central locator
    can streamline communication between components, while avoiding explicit references
    to the location of dependencies that a system might need to be able to run correctly.
    And that''s what the Service Locator pattern offers: a global access point and
    registry to the core services of a program.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过一个中央定位器让服务相互查找可以简化组件之间的通信，同时避免显式引用系统可能需要以正确运行所需的依赖项的位置。这正是服务定位器模式所提供的：程序核心服务的全局访问点和注册表。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of the Service Locator pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器模式的基本原理
- en: Implementing a global service locator that will act as a runtime linker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个作为运行时链接器的全局服务定位器
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following chapter is hands on, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是实践性的，因此你需要对Unity和C#有一个基本的了解。
- en: 'We will be using the following Unity-specific engine and C# language concepts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Unity特定的引擎和C#语言概念：
- en: Generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Singleton
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: If you are unfamiliar with these concepts, please review [Chapter 6](b8d60568-5961-4e57-b722-36028db5d1a9.xhtml), *Singleton*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请回顾第6章，*单例*。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：
- en: '[http://bit.ly/2U8Mb6H](http://bit.ly/2U8Mb6H)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2U8Mb6H](http://bit.ly/2U8Mb6H)'
- en: An overview of the Service Locator
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器概述
- en: The Service Locator is a straightforward pattern and doesn't have much academic
    theory behind it, so we can safely say it falls into the category of pragmatic
    patterns. As its name implies, it locates services for a client; it achieves this
    by maintaining a central registry of classes that offer specific services. This
    registry can be updated dynamically at runtime by having services register themselves
    when available.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器是一个简单的模式，它背后没有太多的学术理论，所以我们可以说它属于实用模式的范畴。正如其名称所暗示的，它为客户端定位服务；它通过维护一个提供特定服务的类别的中央注册表来实现这一点。这个注册表可以在运行时通过服务在可用时注册自己来动态更新。
- en: Another common component of the Service Locator is its local cache, which uses
    the same principles as the Object Pool. A Service Locator might hold instances
    of its most-requested services in memory to avoid using too much memory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器的另一个常见组件是其本地缓存，它使用与对象池相同的原理。服务定位器可能会在内存中保留其最常请求的服务实例，以避免使用过多的内存。
- en: 'Let''s review a diagram of a typical Service Locator implementation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个典型服务定位器实现的图解：
- en: '![](img/a7a4dcba-0fc5-432d-a9e7-67707cca2edc.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7a4dcba-0fc5-432d-a9e7-67707cca2edc.png)'
- en: As we can see, we could easily say that the **Service Locator** is acting like
    a proxy between the clients (requestors) and the service providers, and this means
    that the relationship between both is a decoupled one. A client will only need
    to call the **Service Locator** when it has a dependency to resolve.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以很容易地说，**服务定位器**在客户端（请求者）和服务提供者之间充当代理，这意味着两者之间的关系是解耦的。客户端只有在需要解决依赖项时才需要调用**服务定位器**。
- en: It's important to remember that the software architecture term *client* is often
    used to describe a class using the functionalities of another class, or other
    classes—it has nothing to do with the end user of an application. Systems can
    be clients of other systems without any human input.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，软件架构术语“客户端”通常用来描述使用另一个类或其他类的功能性的类，它与应用程序的最终用户无关。系统可以是其他系统的客户端，而不需要任何人为输入。
- en: Benefits and drawbacks
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和缺点
- en: The Service Locator is a young pattern; its reputation in the industry is quite
    limited compared to more traditional patterns.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器是一个较新的模式；与更传统的模式相比，它在行业中的声誉相当有限。
- en: 'The following are the benefits of using the Service Locator:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Service Locator的好处：
- en: '**Runtime optimization**: A Service Locator can optimize an application at
    runtime by dynamically detecting better libraries or components to use, depending
    on the context.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时优化**：Service Locator可以通过动态检测根据上下文更好的库或组件来优化应用程序。'
- en: '**Contextual run-time locators**: It''s possible to have multiple Service Locators
    in memory, each configured for a specific runtime context, such as testing, staging,
    and production.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文运行时定位器**：内存中可以存在多个Service Locators，每个Service Locator都针对特定的运行时上下文进行配置，例如测试、预发布和生产。'
- en: '**Simpler than Dependency Injection**: A Service Locator is simpler to implement
    than a **Dependency Injection** (**DI**)-driven architecture, mainly because it''s
    a centralized approach to managing dependencies.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比依赖注入更简单**：Service Locator比依赖注入（DI）驱动的架构更容易实现，主要是因为它是一种集中式管理依赖的方法。'
- en: 'The following are the drawbacks of using the Service Locator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Service Locator的缺点：
- en: '**Blackboxing**: Services contained in the registry can become invisible to
    other components in a system. This approach can make it harder to detect errors
    or regressions.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑盒化**：注册表中的服务可能对系统中的其他组件不可见。这种方法可能会使检测错误或回归变得更困难。'
- en: '**Security hole**: Depending on the overall architecture of the code base,
    the Service Locator could permit the injection code that could exploit your systems.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全漏洞**：根据代码库的整体架构，Service Locator可能会允许注入代码，这些代码可能会利用您的系统。'
- en: '**Globally accessible**: If implemented as a Singleton, the Service Locator
    can suffer from the same issues of globally accessible managers and components,
    making them harder to unit test.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局可访问**：如果实现为Singleton，Service Locator可能会遭受与全局可访问的管理器和组件相同的问题，使得它们更难进行单元测试。'
- en: Use case example
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: 'Our use case will be straightforward, and we will not focus on a specific in-game
    system. Instead, we will concentrate on building a simple Service Locator that
    will offer the ability to *link* a client to the following services dynamically:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的使用案例将非常直接，我们不会专注于特定的游戏内系统。相反，我们将专注于构建一个简单的Service Locator，它将能够动态地将客户端与服务链接起来：
- en: '**Currency converter**: A service that converts in-game currency to a real-world
    value'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**货币转换器**：一个将游戏内货币转换为现实世界价值的服务'
- en: '**Lighting** **coordinator**: A system that manages the lights in our scenes'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**照明协调员**：一个管理我们场景中灯光的系统'
- en: '**Lobby coordinator**: A service that coordinates with the multiplayer lobby
    to set up "death matches"'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大厅协调员**：一个与多人大厅协调以设置“死亡比赛”的服务'
- en: But, of course, we could add many available services to the registry, but for
    this example, we will focus on just those three.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，我们可以向注册表中添加许多可用的服务，但在这个例子中，我们将专注于这三个。
- en: Code example
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'As we are going to see from the following code example, implementing a basic
    Service Locator is a straightforward process:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从下面的代码示例中将要看到的，实现一个基本的Service Locator是一个简单直接的过程：
- en: 'Let''s start by implementing the most important ingredient: the `ServiceLocator`
    class:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先从实现最重要的成分开始：`ServiceLocator`类：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This version of a Service Locator has two primary responsibilities:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个版本的Service Locator有两个主要职责：
- en: Managing the registry with the `FillRegistry()` function
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FillRegistry()`函数管理注册表
- en: Returning a specified service to the client with the `GetService(T)` function
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GetService(T)`函数向客户端返回指定的服务
- en: Those two functions refer to the central registry that's in the form of a `Dictionary`.
    Of course, we could separate these responsibilities into individual classes, instead
    of encapsulating them inside local functions, but for this example, we are keeping
    it simple.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数指的是以`Dictionary`形式存在的中央注册表。当然，我们可以将这些职责分离到单独的类中，而不是将它们封装在局部函数中，但在这个例子中，我们将保持简单。
- en: Now that we have our Service Locator set up, we can now start implementing some
    services for our clients.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了服务定位器，我们现在可以开始为我们的客户端实现一些服务。
- en: 'Our first service is `Currencyconverter`; this is essential for modern games
    when we consider that they usually include an in-game purchase and lootbox mechanics:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一项服务是`货币转换器`；这在现代游戏中是必不可少的，考虑到它们通常包括游戏内购买和宝箱机制：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our second service is `LightingCoordinator`; it''s responsible for managing
    all the lights in our scenes:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第二项服务是`照明协调器`；它负责管理场景中的所有灯光：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our last service is `LobbyCoordinator`; this is responsible for making sure
    that our player can join an active lobby when required:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一项服务是`大厅协调器`；这确保了我们的玩家在需要时可以加入一个活跃的大厅：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now have three services, each with specific responsibilities, available
    to our clients if need be. But we have an apparent limitation: at the moment,
    we are adding services to the central registry only by hand, and this is, of course,
    not the best approach for production code; however, it is acceptable for us to
    test our first pass implementation of a Service Locator. Later on, as a practical
    exercise, it would be wise to add the option for service providers to register
    themselves dynamically into the service registry:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个服务，每个服务都有特定的职责，如果需要的话，可供客户端使用。但我们有一个明显的限制：目前，我们只能手动将服务添加到中央注册表，当然，这不是生产代码的最佳方法；然而，对于我们测试服务定位器的第一次实现来说，这是可以接受的。稍后，作为一个实际练习，明智的做法是为服务提供者添加动态注册到服务注册表的功能：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now, for our final class, we are going to implement the client:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于我们的最后一个类，我们将实现客户端：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we have implemented the client-side code, we can appreciate the benefits
    of the Service Locator. We are now able to have access to any core service of
    our code base without having to know the location of its class or how to initialize
    it. We have a global but straightforward interface that we can query from anywhere
    that dynamically links a client with a service while decoupling the entire process
    of localizing a service and initializing it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了客户端代码，我们就能欣赏到服务定位器的优势。我们现在能够访问代码库中的任何核心服务，而无需知道其类的位置或如何初始化它。我们有一个全局但简单的接口，可以从任何地方查询，它动态地将客户端与服务链接起来，同时解耦整个定位服务和初始化的过程。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the Service Locator, a pattern that is a global
    solution that can resolve the recurring challenge of managing dependencies between
    objects that rely on services (functionalities) that other objects offer. In its
    simplest form, the Service Locator decouples the relationship between a client
    (requester) and a service provider. But in its most advanced form, it can also
    optimize memory usage if extended with a local cache that will reuse instances
    of providers when required.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了服务定位器模式，这是一种全局解决方案，可以解决依赖服务（功能）的对象之间管理的重复挑战。在其最简单形式中，服务定位器解耦了客户端（请求者）与服务提供者之间的关系。但在其最先进形式中，如果扩展到具有本地缓存的本地缓存，它还可以优化内存使用，当需要时可以重用提供者的实例。
- en: In the next chapter, we will explore the DI pattern, which we could say is somewhat
    the opposite of the Service Locator in its approach but has a similar intent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨依赖注入（DI）模式，可以说它在方法上与服务定位器相反，但具有相似的目的。
- en: Exercise
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In the code example, we implemented a simple version of the Service Locator
    so we could have a clear overview of its core intent and design. But for an exercise,
    I would recommend you take this basic draft of the Service Locator and expand
    it into something that could be production ready, by doing the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们实现了一个简单的服务定位器版本，以便我们可以清楚地了解其核心意图和设计。但作为一个练习，我建议你将这个基本的服务定位器草案扩展成一个可以投入生产的版本，方法如下：
- en: Encapsulate the registry and cache components into self-contained classes.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将注册表和缓存组件封装到自包含的类中。
- en: Implement the cache with a combination of the Factory and Prototype patterns.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂模式和原型模式组合实现缓存。
- en: Implement the ability for services to add themselves dynamically to the registry.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务动态添加到注册表的能力。
- en: Write a standard interface for your service providers so you can effectively
    manage them.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的服务提供者编写一个标准接口，以便你可以有效地管理它们。
- en: It's good practice to approach design patterns like a jazz musician approaches
    a melody. Once you understand the core theme of a pattern, extend it, improvise
    on it, and make it your own, while staying accurate to its fundamental design.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将设计模式视为爵士乐手对待旋律的做法是一种良好的实践。一旦你理解了一个模式的核心理念，就扩展它，即兴发挥，使其成为你自己的，同时保持对其基本设计的准确性。
- en: Further reading
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Inversion of Control Containers and the Dependency Injection* *pattern*, by
    Martin Fowler([https://martinfowler.com/articles/injection.html#UsingAServiceLocator](https://martinfowler.com/articles/injection.html#UsingAServiceLocator))'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制反转容器和依赖注入* 模式，由马丁·福勒撰写([https://martinfowler.com/articles/injection.html#UsingAServiceLocator](https://martinfowler.com/articles/injection.html#UsingAServiceLocator))'
