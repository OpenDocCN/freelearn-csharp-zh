<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Snap it! Adding Filters to Pictures</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will create an application that will allow us to add an overlay over a person's head. If this application sounds familiar, that is because there are many applications that are on the market that do just this, and today, you will learn how to do so as well.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>OpenCV</li>
<li>Setting up OpenCV</li>
<li>Incorporating OpenCV into Unity</li>
<li>Creating a prototype project using OpenCV and Unity</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project overview</h1>
                </header>
            
            <article>
                
<p>This project makes heavy use of facial recognition-and-detection algorithms, which requires knowledge of OpenCV. </p>
<p>Build time: two hours</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>In this section, we will cover a few things that you will need and some optional items for more in depth building from source requirements.</p>
<ul>
<li>OpenCV 3.4.1, which you can find at <a href="https://opencv.org/releases.html">https://opencv.org/releases.html</a>, is the library itself in pure source form or in library form. If you want the Unity specific plugin, you can purchase it from <a href="https://assetstore.unity.com/packages/tools/integration/opencv-for-unity-21088">https://assetstore.unity.com/packages/tools/integration/opencv-for-unity-21088</a>, along with the sister library file at <a href="https://enoxsoftware.com/dlibfacelandmarkdetector/">https://enoxsoftware.com/dlibfacelandmarkdetector/</a>.</li>
<li>Unity 2018 can be download from <a href="https://store.unity.com/">https://store.unity.com/</a>.</li>
<li>Visual Studio, a requirement for writing or compiling source code, can be downloaded from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</li>
<li>CMake, which you can download from <a href="https://cmake.org/download/">https://CMake.org/download/</a>, is required when building your own version of the library, the plugin, and the source for OpenCV.</li>
<li>Python, which is a requirement if you need to build your own library for OpenCV, can be downloaded from <a href="https://www.python.org/getit/">https://www.python.org/getit/</a>.</li>
</ul>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is OpenCV?</h1>
                </header>
            
            <article>
                
<p><strong>OpenCV</strong> stands for <strong>Open Computer Vision</strong>. OpenCV is an open source computer vision and machine learning software library that was built with C++ and has C++, Python, Java, and Matlab interfaces to support Windows, Linux, Android, and macOS.</p>
<p>OpenCV mainly focuses on real-time vision applications, although it can be used for machine learning very nicely. The library has many optimized algorithms and functions to compose or support such algorithms for state-of-the-art computer vision and machine learning, with roughly 2,500. To break down the ratio here, there are roughly 500 algorithms, and the rest are functions to compose or support these algorithms.</p>
<p>Talking about algorithms is fun and all, but I’m sure you are more interested in knowing what these algorithms are capable of doing. The algorithms are designed to be used to detect faces, recognize faces, identify objects, detect and classify human actions in video feeds, track camera movements, move object tracking, extraction of 3D models from objects, produce point clouds from stereo cameras in 3D, stitch images together for high resolution images, quickly find the same or similar images from an image database, red-eye removal, eye tracking, detect scenery, and establish markers for augmented reality overlay, and so much more.</p>
<p>OpenCV can work with TensorFlow, Caffe, Torch, Yolo, Vuforia, ARCore, and ARKit with ease. OpenCV can be used for <strong>Augmented Reality</strong> (<strong>AR</strong>), <strong>Virtual Reality</strong> (<strong>VR</strong>), and <strong>Mixed Reality</strong> (<strong>MR</strong>). You can use visual scripting options, such as PlayMaker, and have access to all methods available in OpenCV. OpenCV also works with tons of different hardware, such as HoloLens, Oculus Rift, Telepathy, Kinect, and Raspberry Pi, to name a few.</p>
<p>We have two different options for gaining access to OpenCV. The first one is to build from source and create our own wrappers to create a Unity plugin for OpenCV. The second option is to purchase OpenCV for Unity from the Unity Asset Store.</p>
<p>If you want to go the easy route and purchase the Unity extension, it will cost 70 dollars, unless you have a Unity Plus/Pro membership, which will decrease the cost to 56 dollars. The good news is that it supports Unity Version 5.6 or greater and is based on OpenCV 3.4.1.</p>
<p>There are sample assets packs that you can download from the Unity Asset Store or from GitHub that will give you prebuilt examples for working with HoloLens Face Detection Overlay, FaceLandmark Detection, Facemasking, Real-time Face Recognition, Markerless AR. Face Swapping, Kinect with OpenCV, Facetracking, working with Vuforia and OpenCV, and marker-based AR.</p>
<p>Now, the other option, in other words, the cheap route, because, let's be honest, the Unity plugin is rather pricey, especially for younger developers or those who just want to try out OpenCV to see whether it is a good fit, is to build from source. What benefits do we gain from build from source, besides the low cost?</p>
<p>We get to decide which aspects of the library we need, for one. This is a huge bonus, as we can remove bloat to reduce the file and compile size. However, even when doing this, you can have the same features, or even more than the Unity plugin, since you are building from source.</p>
<p>The downside is that there are many things you need to get the full compilation of the source taken care of, which is dependent on whether you want to use prebuilt binaries or building your own library from scratch.</p>
<p>To build from scratch, you will need Visual Studio with C++ modules installed, CMake, Python Version 2.7 or later, Numpy, <strong>Intel Threading Building Blocks</strong> (<strong>TBB</strong>), <strong>Intel Integrated Performance Primitives</strong> (<strong>IPP</strong>), Intel IPP Asynchronous C/C++, Eigen, CUDA Toolkit, OpenEXR, OpenNI Framework, and Doxygen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the project with paid assets</h1>
                </header>
            
            <article>
                
<p>In this section, we will use the Unity asset files, as they are a bit shorter to set up. The Dlib FaceLandmark Detector costs 40 dollars, and OpenCV for Unity costs 70 dollars. That means to build this project, you will need to have spent 110 dollars. Sadly, there are no free alternatives in the Unity Asset store, and if you want to build the project without purchasing the assets, you will need to build the wrappers and implementations on your own. Now, follow these steps:</p>
<ol>
<li>Create a brand new Unity Project. I will call mine <kbd>Snap</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/64f7bcea-1fb3-4ca0-b3e8-2b5e35ce97c3.png"/></div>
<ol start="2">
<li>Make sure your <kbd>Assets</kbd> directory is completely empty:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3f324d43-9919-4ab8-8c67-1ab91427bc03.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>The text in this screenshot is not important. It indicates that the Assets directory is empty.</span></div>
<ol start="3">
<li>We will start by importing OpenCV into Unity. This will take some time to complete:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/890e2dc0-d64b-4681-be2e-6393cfc91f44.png"/></div>
<ol start="4">
<li>You will have many examples that include some very nice shaders that can be used in other projects, so import everything:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/524a3073-d311-4eb9-afad-05e1f3fb44df.png"/></div>
<ol start="5">
<li>Your <kbd>Assets</kbd> directory should have an <kbd>OpenCVForUnity</kbd> and a <kbd>Realistic_Water_Fountain</kbd> folder:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f6005e6e-6c14-4336-b053-eaa6ec51ed9d.png"/></div>
<ol start="6">
<li>Now, we will need to import the Dlib Facelandmark Detector.</li>
<li>The last asset we will need is the <span class="packt_screen">FaceMask</span> <span class="packt_screen">Example</span>. Click on this link: <a href="https://assetstore.unity.com/packages/templates/tutorials/facemask-example-79999">https://assetstore.unity.com/packages/templates/tutorials/facemask-example-79999</a>.<a href="https://assetstore.unity.com/packages/templates/tutorials/facemask-example-79999"><br/></a></li>
<li>This package contains some additional scripts, as well as some examples of how to apply face masking to the camera, to be able to record videos or take a picture.</li>
<li>Use the <span class="packt_screen">FaceMask</span> <span class="packt_screen"><span class="packt_screen">E</span>xample</span> scene, and this will create our basic prototype.</li>
</ol>
<p>We now have a working prototype for Snap it. You can add more features such as different items to cover the face, cover only a small portion of the head, add shader effects to the scene, and so much more to create your own feature-rich AR application based on OpenCV and the <span>Dlib Facelandmark Detector.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and building OpenCV</h1>
                </header>
            
            <article>
                
<p>Now, what if you don’t have the funds to build this project with paid assets that would make your life easier? Well, the option is to build from scratch. It is much more involved and is generally a rabbit hole that more experienced developers tend to go down than beginners.</p>
<p>This isn’t to say that beginners can’t follow along and build from scratch themselves; in fact, I suggest that if you are a beginner, follow along, as there are many new things to learn from this exercise, from dealing with other people’s source files, to incorporating them into your own projects with an understanding of that code base. </p>
<p>To get OpenCV set up to run with Unity, we have a few steps we need to go through. We need to download OpenCV and CMake. OpenCV is the library we will be heavily utilizing, and CMake is the software that allows us to manage the build process in any given operating system and compiler with independence in mind. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Downloading OpenCV</h1>
                </header>
            
            <article>
                
<p>Let's get started by first downloading OpenCV. We could go down the route of getting the pure source files or by getting the prebuilt binaries, both of which have their own pros and cons associated with them. For example, the pure source files version would require us to have every library used within OpenCV and language associated installed and configured to be able to build our own binaries. We will simplify the process just a hair, by going with the prebuilt binaries approach. Follow these steps:</p>
<ol>
<li class="CDPAlignLeft CDPAlign">To get started with building OpenCV from prebuilt binaries, we first need to download the files we need. There are two possibilities for this, <a href="https://opencv.org/opencv-3-3.html">https://opencv.org/opencv-3-3.html</a><span> </span>or <a href="https://sourceforge.net/projects/opencvlibrary/">https://sourceforge.net/projects/opencvlibrary/</a>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e809b27c-d8c5-4827-b9c7-15e9deb929ab.png"/></p>
<ol start="2">
<li>We need to choose the installation version we want; in this case, I am going to go with the latest version, which is <kbd>3.4.1</kbd>, as it is the same as the Unity extension version:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/db0ce217-96bd-4d8a-b2da-8a1eb5777a33.png"/></div>
<ol start="3">
<li>The executable file is 172 MB in size, so, depending on your internet connection speeds, you could have a long download time:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5ba285fe-7f10-473c-b197-64858e3846b9.png"/></div>
<ol start="4">
<li>Create a new folder to house the extracted OpenCV files:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/da706ce1-662a-43fa-bc2e-308d8bebb54f.png"/></div>
<ol start="5">
<li>Now, we have our OpenCV self-extracting file:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0c4aa73f-92da-4d5a-a5d1-ac538038b2f2.png"/></div>
<ol start="6">
<li>Right-click on the installer file, and select <span class="packt_screen">Run as administrator</span>. We need to have elevated privileges to make sure the project extracts correctly:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d5a4224b-4f59-4e2e-ae9b-fdebf4a02a5f.png"/></div>
<ol start="7">
<li>Select the folder you created as the installation location:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c2b5cffa-114f-4302-952c-38e4d5b6f868.png"/></div>
<ol start="8">
<li>Extracting the files should not take long:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a4c8b69-656f-40d7-90de-6c598a0dc69b.png"/></div>
<ol start="9">
<li>Now, we have extracted OpenCV.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">
Downloading CMake</h1>
                </header>
            
            <article>
                
<p><br/>
Now that OpenCV has been download, it is time to do the same for CMake, as both of these files are integral to continuing properly.</p>
<div class="packt_tip">This is only the case if you decided to go with the source direction instead of the binaries method, so I will touch on these steps a little as well.</div>
<p>Downloading CMake is a rather quick and painless process, regardless of whether you are using Linux, macOS, or Windows. Since I want to build with Windows, I will showcase the steps with that particular OS in mind.</p>
<ol>
<li>Go to<span> </span><a href="http://cmake.org">CMake.org</a>; click on download latest, and scroll down to latest release to download CMake:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa543085-c027-4290-969c-00071cb4f76f.png"/></div>
<ol start="2">
<li>Double-click on CMake to run the setup wizard:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/81fb3d13-abaa-45b1-a644-b1675689ef39.png" style="width:31.42em;height:24.50em;"/></div>
<ol start="3">
<li>Put a check mark in the <em>License Agreement</em> block and click <span class="packt_screen">Next</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/503a8932-2986-4376-940f-225476bca0c8.png" style="width:30.08em;height:23.33em;"/></div>
<ol start="4">
<li>Make sure to <span class="packt_screen">Add CMake to the system PATH for current or all users</span>, depending on your preference. Just make sure that it is set to the system path before clicking <span class="packt_screen">Next</span><strong>:</strong></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f6792e1-5178-40bd-b1c6-219b29b9bd80.png" style="width:29.42em;height:22.83em;"/></div>
<ol start="5">
<li>Click <span class="packt_screen">Next</span> to install CMake to whatever folder you want:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/895b373b-3549-4e5d-9c85-04075fc19475.png" style="width:30.17em;height:23.83em;"/></div>
<ol start="6">
<li>To install CMake, it requires elevated privilges, so if you have UAC enabled and don't have admin rights, make sure you have someone nearby that can give you access to install:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1dc79725-65c3-4e93-b1b0-415709c97e70.png" style="width:30.58em;height:23.83em;"/></div>
<ol start="7">
<li>Installation will take a few minutes to complete:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7638fe0b-cd20-4ced-9cd4-03beb389e82b.png" style="width:30.08em;height:23.50em;"/></div>
<ol start="8">
<li>Click <span class="packt_screen">Finish</span> to complete the installation process:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e33cc4b8-c7ec-4b02-b02c-79215c18c6cf.png" style="width:31.42em;height:24.58em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the CMake and OpenCV source files</h1>
                </header>
            
            <article>
                
<p>Now, we can move on to configuring CMake and getting everything set up to build OpenCV as a library to utilize within Unity. Now, to do this, you need the full-on source code of OpenCV, instead of the binaries, which you can grab from <a href="https://github.com/opencv/opencv/archive/3.3.0.zip">https://github.com/opencv/opencv/archive/3.3.0.zip</a>. or <a href="https://github.com/opencv/opencv/archive/3.3.0.zip">https://github.com/opencv/opencv/archive/3.3.0.zip</a>.</p>
<p><span>Start </span><em>CMake (</em><kbd>CMake-gui</kbd><em>)</em><span>. You may again enter it in the start menu search or get it from </span><span class="packt_screen">All</span> <span class="packt_screen">Programs</span> | <span class="packt_screen">CMake</span> <span class="packt_screen">2.8</span> | <span class="packt_screen">CMake</span> (<kbd>CMake-gui</kbd>)<span>. First, select the directory for the source files of the OpenCV library (1). Then, specify a directory where you will build the binary files for OpenCV library (2).</span></p>
<p>Press the <span class="packt_screen">Configure</span> button to specify the compiler (and the<span> </span>IDE) you want to use. Note that you can choose between different compilers for making either 64 bit or 32 bit libraries. Select the one you use in your application development.</p>
<p><span>CMake will start based on your system variables and will try to automatically locate as many packages as possible. You can modify the packages to use for the build in the </span><em>WITH ‣ WITH_X</em><span> menu points (where </span><em>X</em><span> is the package abbreviation). </span></p>
<p><span>Select all the packages you want to use, and again press the </span><span class="packt_screen">Configure </span><span>button. For an easier overview of the build options, make sure the </span><span class="packt_screen">Grouped </span><span>option under the binary directory selection is turned on. For some of the packages, CMake may not find all of the required files or directories. If it doesn't find all of them, CMake will throw an error in its output window (located at the bottom of the GUI) and set its field values to not-found constants.</span></p>
<p>Press the<span> </span><span class="packt_screen">Configure </span>button again and ensure that no errors are reported. CMake will create the project files by pushing the<span> </span><span class="packt_screen">Generate </span>button. Go to the build directory and open the created<span> </span>OpenCV<strong> </strong>solution. Depending on just how many options you have selected, the solution may contain quite a lot of projects, so be tolerant on the IDE at the startup. Now, you need to build both the<span> </span><span class="packt_screen">Release </span>and the<span> </span><span class="packt_screen">Debug </span>binaries. Use the drop-down menu on your IDE to change to another of these after building for one of them.</p>
<p><span>In the end, you can observe the built binary files inside the bin directory.</span></p>
<p><span>To collect the header and the binary files, which you will use during your own projects, into a separate directory (similarly to how the pre-built binaries ship), you need to explicitly build the </span><span class="packt_screen">Install </span><span>project.</span></p>
<p><span>To test your build, just go into the </span><span class="pre">Build/bin/Debug</span><span> or the </span><span class="pre">Build/bin/Release</span><span> directory and start a couple of applications, such as </span><kbd>contours.exe</kbd><span>. If they run, you are done.</span></p>
<p>For more in-depth information on this, go to <a href="https://docs.opencv.org/3.0-beta/doc/tutorials/introduction/windows_install/windows_install.html">https://docs.opencv.org/3.0-beta/doc/tutorials/introduction/windows_install/windows_install.html</a>. The OpenCV documentation will go into this in more detail, along with the other tools you will need to install to go down this route.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenCV with Unity</h1>
                </header>
            
            <article>
                
<p>We can now move on to importing our dlls into Unity and writing our wrapper classes to handle interfacing with OpenCV and Unity. That way, we can then create our scripts to build our project:</p>
<ol>
<li>Create a folder. I will call mine <kbd>ConfigureOpenCV</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3edd7e61-e7b6-4d7b-b13f-955a660da48e.png"/></div>
<ol start="2">
<li>We need to create a new empty C++ project in Visual Studio. I will call mine <kbd>ConfigureOpenCV</kbd>, with the location being set in the <kbd>ConfigureOpenCV</kbd> folder:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d660bf5-5a49-44cf-9ef0-ebc1f10cbc98.png"/></div>
<ol start="3">
<li>Set the platform to be <span class="packt_screen">x64</span> in Visual Studio:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4f55c008-b1d3-409a-a190-d25f909da730.png"/></div>
<ol start="4">
<li>Right-click on the project properties file and select <span class="packt_screen">Properties</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb89f7de-2ded-4b07-b162-e323f75f57bb.png"/></div>
<ol start="5">
<li>This will open our properties window:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae69cc62-b35f-4c71-b226-a6ace13773cd.png"/></div>
<ol start="6">
<li>The first thing we need to do is change <span class="packt_screen">Target Extension</span> in the <span class="packt_screen">General</span> tab from <kbd>.exe</kbd> to <kbd>.dll</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0689343f-c04e-4bd8-b999-4f3da3d80307.png"/></div>
<ol start="7">
<li>We need to change the <span class="packt_screen">Configuration Type</span> from <span class="packt_screen">Application (.exe)</span> to <span class="packt_screen">Dynamic Library (.dll)</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1f7f6cfb-5012-4327-8ea9-e881014a1c40.png" style="width:33.00em;height:21.00em;"/></div>
<ol start="8">
<li>Over in <span class="packt_screen">VC++ Directories</span>, add our <kbd>OPENCV_DIRs</kbd> to include it in <span class="packt_screen">Include Directories</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/598d5514-5071-4414-8a86-c8e04593f4e5.png" style="width:45.33em;height:24.08em;"/></div>
<ol start="9">
<li>Over in Linker’s <span class="packt_screen">General</span> Tab, add <kbd>$(OPENCV_DIR)\lib\Debug</kbd> to the <span class="packt_screen">Additional Library Directories</span> option:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ce80415d-0e19-4f1f-8506-144a981ddc66.png"/></div>
<ol start="10">
<li>Finally, in the Linker’s <span class="packt_screen">Input</span> tab, we need to add a few items to the <span class="packt_screen">Additional Dependencies</span> option. Those items will be the following:
<ul>
<li><span><kbd>opencv_core310.lib</kbd> (or <kbd>opencv_world330.lib</kbd>, depending on your OpenCV version)</span></li>
<li><kbd><span>opencv_highgui310.lib</span></kbd></li>
<li><kbd>opencv_objdetect310.lib</kbd></li>
<li><kbd><span>opencv_videoio310.lib</span></kbd></li>
<li><kbd><span>opencv_imgproc310.lib</span></kbd></li>
</ul>
</li>
</ol>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a184e3dd-cefb-4278-a556-710f1ac4fe0e.png" style="width:57.92em;height:26.75em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure shows the location of Additional Dependencies in the Linker's Input tab with opencv_core added.</div>
<ol start="11">
<li>Now, we can create a new CPP file:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/065b7a6c-3440-4dd3-bfc3-7b5c91533284.png" style="width:42.00em;height:29.08em;"/></p>
<p>We will now incorporate the headers and namespaces we absolutely need here:</p>
<pre>#include "opencv2/objdetect.hpp"<br/>#include "opencv2/highgui.hpp"<br/>#include "opencv2/imgproc.hpp"<br/>#include &lt;iostream&gt;<br/>#include &lt;stdio.h&gt;<br/>using namespace std;<br/>using namespace cv;</pre>
<ol start="1">
<li>Declare a <kbd>struct</kbd> that will<span> </span><span>be used to pass data from C++ to Mono:</span></li>
</ol>
<pre style="padding-left: 60px">struct Circle<br/>{<br/>Circle(int x, int y, int radius) : X(x), Y(y), Radius(radius) {}<br/>int X, Y, Radius;<br/>};</pre>
<ol start="2">
<li><kbd>CascadeClassifer</kbd><span> </span>is a class used for object detection:</li>
</ol>
<pre style="padding-left: 60px">CascadeClassifier _faceCascade;</pre>
<ol start="3">
<li>Create a string that will serve as the name of the window:</li>
</ol>
<pre style="padding-left: 60px">String _windowName = "OpenCV";</pre>
<ol start="4">
<li>Video Capture is a class used to open a video file, or capture a device or an IP video stream for video capture:</li>
</ol>
<pre style="padding-left: 60px">VideoCapture _capture;</pre>
<ol start="5">
<li>Create an integer value to store the scale:</li>
</ol>
<pre style="padding-left: 60px">int _scale = 1;</pre>
<ol start="6">
<li><kbd>extern "C"</kbd><span>, </span>as a refresher, will avoid name mangling from C++. Our first method is <kbd>Init</kbd> for initialization:</li>
</ol>
<pre style="padding-left: 60px">extern "C" int __declspec(dllexport) __stdcall  Init(int&amp; outCameraWidth, int&amp; outCameraHeight)<br/>{</pre>
<ol start="7">
<li>We will create an <kbd>if</kbd> statement to load the LBP face <kbd>cascade.xml</kbd> file that is part of <kbd>CVFeatureParams</kbd>; if it cannot load, then it will exit with a return code of <kbd>-1</kbd>:</li>
</ol>
<pre style="padding-left: 60px">if (!_faceCascade.load("lbpcascade_frontalface.xml"))<br/>return -1;</pre>
<p class="mce-root"/>
<ol start="8">
<li>Now, we will open the video capture stream:</li>
</ol>
<pre style="padding-left: 60px">_capture.open(0);</pre>
<ol start="9">
<li>If the video stream is not opened, then we will exit with a return code of <kbd>-2</kbd>:</li>
</ol>
<pre style="padding-left: 60px">if (!_capture.isOpened())<br/>return -2;</pre>
<ol start="10">
<li>We will set the camera width:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">outCameraWidth = _capture.get(CAP_PROP_FRAME_WIDTH);</pre>
<ol start="11">
<li>And we also need to set the camera height:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">outCameraHeight = _capture.get(CAP_PROP_FRAME_HEIGHT);<br/>return 0;<br/>}</pre>
<ol start="12">
<li>Now, we need to make sure that we create a method to close the capture stream and release the video capture device:</li>
</ol>
<pre style="padding-left: 60px">extern "C" void __declspec(dllexport) __stdcall  Close()<br/>{<br/>_capture.release();<br/>}</pre>
<ol start="13">
<li>The next step is to create a method that sets the video scale:</li>
</ol>
<pre style="padding-left: 60px">extern "C" void __declspec(dllexport) __stdcall SetScale(int scale)<br/>{<br/>_scale = scale;<br/>}</pre>
<ol start="14">
<li>Next up, we will create a method that allows us to detect an object:</li>
</ol>
<pre style="padding-left: 60px">extern "C" void __declspec(dllexport) __stdcall Detect(Circle* outFaces, int maxOutFacesCount, int&amp; outDetectedFacesCount)<br/>{<br/>Mat frame;<br/>_capture &gt;&gt; frame;</pre>
<ol start="15">
<li>Next up, if the frame is empty, we need to guard against possible errors from this by exiting from the method:</li>
</ol>
<pre style="padding-left: 60px">if (frame.empty())<br/>return;</pre>
<ol start="16">
<li>Create a vector called <kbd>faces</kbd><em>:</em></li>
</ol>
<pre style="padding-left: 60px">std::vector&lt;Rect&gt; faces;</pre>
<ol start="17">
<li>We will create <span class="packt_screen">Mat</span>, which is one of the various constructors that forms a matrix with the name of <kbd>grayscaleFrame</kbd>:</li>
</ol>
<pre style="padding-left: 60px">Mat grayscaleFrame;</pre>
<ol start="18">
<li>We then need to convert the frame<span> </span><span>to grayscale from RGB colorspace for proper cascade detection:</span></li>
</ol>
<pre style="padding-left: 60px">cvtColor(frame, grayscaleFrame, COLOR_BGR2GRAY);<br/>Mat resizedGray;</pre>
<ol start="19">
<li>The next step is to scale down for better performance:</li>
</ol>
<pre style="padding-left: 60px">resize(grayscaleFrame, resizedGray, Size(frame.cols / _scale, frame.rows / _scale));<br/>equalizeHist(resizedGray, resizedGray);</pre>
<ol start="20">
<li>Next up, we will detect the <kbd>faces</kbd>:</li>
</ol>
<pre style="padding-left: 60px">_faceCascade.detectMultiScale(resizedGray, faces);</pre>
<ol start="21">
<li>We will now create a for loop to draw the faces:</li>
</ol>
<pre style="padding-left: 60px">for (size_t i = 0; i &lt; faces.size(); i++)<br/>{<br/>Point center(_scale * (faces[i].x + faces[i].width / 2), _scale * (faces[i].y + faces[i].height / 2));<br/>ellipse(frame, center, Size(_scale * faces[i].width / 2, _scale * faces[i].height / 2), 0, 0, 360, Scalar(0, 0, 255), 4, 8, 0);</pre>
<ol start="22">
<li>Now, we will send this information to the application:</li>
</ol>
<pre style="padding-left: 60px">outFaces[i] = Circle(faces[i].x, faces[i].y, faces[i].width / 2);<br/>outDetectedFacesCount++;</pre>
<ol start="23">
<li>Since we have a matrix, we need to make sure that we don't exceed the limits of the array. To do this, we will break if the faces count is equal to the max amount of faces count we have allocated; if it is, exit from the loop:</li>
</ol>
<pre style="padding-left: 60px">if (outDetectedFacesCount == maxOutFacesCount)<br/>break;<br/>}</pre>
<ol start="24">
<li>The last thing we need to do is display the debug output:</li>
</ol>
<pre style="padding-left: 60px">imshow(_windowName, frame);</pre>
<ol start="25">
<li class="mce-root">Now, build the <kbd>dll</kbd> file, and we can now begin to work in Unity.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenCV and Unity</h1>
                </header>
            
            <article>
                
<p>Now, we can finally start working in Unity in this section. This is the easier part, where we just need to create our wrapper and our <kbd>MonoBehaviour</kbd> script to attach to an object.</p>
<p>Navigate to the <kbd>dll</kbd> file that we created. This should be in the <span class="packt_screen">x64</span> | <span class="packt_screen">Debug</span> folder of the source project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/38201014-b86b-40bc-ab33-12366254ab8a.png"/></p>
<p>Create two folder called <kbd>Plugins</kbd> and <kbd>Scripts</kbd> in Unity, just as we did in <kbd>Chapter3</kbd>.</p>
<p>Now, we will create two scripts. One for our <kbd>Wrapper</kbd> class, and the other for our <kbd>MonoBehaviour</kbd>. The <kbd>Wrapper</kbd> class will be called <kbd>OpenCVWrapper</kbd>, and the <kbd>MonoBehaviour</kbd> class will be called <kbd>OpenCVFaceDetection</kbd>.</p>
<p>Open the <kbd>OpenCVWrapper</kbd> class in Visual Studio. It is time to write some more code.</p>
<p>We only need to use the <kbd>InteropServices</kbd> namespace for this class:</p>
<pre>using System.Runtime.InteropServices;</pre>
<p>We will create an <kbd>internal static class</kbd> this time around:</p>
<pre class="mce-root">internal static class OpenCVWrapper<br/>{</pre>
<p class="mce-root"/>
<p>We will import the <kbd>Init</kbd> function that we created in the last step, and we need to make sure that we reference the parameters. The<span> </span><kbd>ref</kbd><span> </span>keyword is very similar to the<span> </span><kbd>&amp;</kbd><span> </span>keyword in C++:</p>
<pre class="mce-root"> [DllImport("UnityOpenCVSample")]<br/> internal static extern int Init(ref int outCameraWidth, ref int outCameraHeight);</pre>
<p>We will import the <kbd>Close</kbd> function, which closes the connection and will avoid memory leaks when we use the functions that we've created:</p>
<pre class="mce-root">[DllImport("UnityOpenCVSample")]<br/> internal static extern int Close();</pre>
<p>We will import the <kbd>SetScale</kbd> function we created, along with keeping the parameters that we required in C++:</p>
<pre class="mce-root">[DllImport("UnityOpenCVSample")]<br/> internal static extern int SetScale(int downscale);</pre>
<p>We will import the <kbd>Detect</kbd> function, and this one is a bit different, as we are actually using a pointer; this will be very important very soon, as this deals with unsafe code in C# and Unity. If you aren't familiar, the<span> </span><kbd>*</kbd><span> </span>keyword denotes a pointer, which is the address of the object in memory:</p>
<pre class="mce-root">[DllImport("UnityOpenCVSample")]<br/> internal unsafe static extern void Detect(CvCircle* outFaces, int maxOutFacesCount, ref int outDetectedFacesCount);<br/> }</pre>
<p class="mce-root">Lastly, we will create a structure that needs to be sequential and with the correct byte size (3 ints = 4 bytes * 3 = 12 bytes) for CvCircle:</p>
<pre class="mce-root"> [StructLayout(LayoutKind.Sequential, Size = 12)]<br/> public struct CvCircle<br/> {<br/> public int X, Y, Radius;<br/> }</pre>
<p>This takes care of the wrapper class, and we can now move over to our <kbd>MonoBehaviour</kbd> class. </p>
<p>We need a few namespaces, as they will be fully utilized in this script:</p>
<pre>using UnityEngine;<br/>using System.Collections;<br/>using System.Collections.Generic;</pre>
<p>We have our class named the same as the file in the Unity Editor and inherit from <kbd>MonoBehaviour</kbd>:</p>
<pre class="mce-root">public class OpenCVFaceDetection : MonoBehaviour<br/>{</pre>
<p>The main thing to notice here is that I have a reference to the camera and a <kbd>WebCamTexture</kbd>. This is because we will feed the data from the webcam to the camera:</p>
<pre class="mce-root"> public Camera camera;<br/> public static List&lt;Vector2&gt; NormalizedFacePositions { get; private set; }<br/> public static Vector2 CameraResolution;<br/> private const int DetectionDownScale = 1;<br/> private bool _ready;<br/> private int _maxFaceDetectCount = 5;<br/> private CvCircle[] _faces;<br/> private Quaternion baseRotation;<br/> private WebCamTexture webCamTexture;</pre>
<p>In this <kbd>Start</kbd> method, we get everything set up and running. We also check to make sure that the <kbd>cascades.xml</kbd> file is able to be found (more on that in the next section):</p>
<pre class="mce-root">void Start()<br/> {<br/> int camWidth = 0, camHeight = 0;<br/> webCamTexture = new WebCamTexture();<br/> Renderer renderer = GetComponent&lt;Renderer&gt;();<br/> renderer.material.mainTexture = webCamTexture;<br/> baseRotation = transform.rotation;<br/> webCamTexture.Play();<br/> camWidth = webCamTexture.width;<br/> camHeight = webCamTexture.height;<br/>int result = OpenCVWrapper.Init(ref camWidth, ref camHeight);<br/> if (result &lt; 0)<br/> {<br/> if (result == -1)<br/> {<br/> Debug.LogWarningFormat("[{0}] Failed to find cascades definition.", GetType());<br/> }<br/> else if (result == -2)<br/> {<br/> Debug.LogWarningFormat("[{0}] Failed to open camera stream.", GetType());<br/> }<br/> return;<br/> }<br/>CameraResolution = new Vector2(camWidth, camHeight);<br/> _faces = new CvCircle[_maxFaceDetectCount];<br/> NormalizedFacePositions = new List&lt;Vector2&gt;();<br/> OpenCVWrapper.SetScale(DetectionDownScale);<br/> _ready = true;<br/>}</pre>
<p>This method will make sure that the connections are closed to the webcam. This will free up the resources and make sure that we don't leak any memory: </p>
<pre class="mce-root">void OnApplicationQuit()<br/> {<br/> if (_ready)<br/> {<br/> OpenCVWrapper.Close();<br/> }<br/> }</pre>
<p>This <kbd>Update</kbd> method makes sure that the orientation of the webcam is corrected, checks whether the camera is read or not, and actively tracks for face detection:</p>
<pre class="mce-root">void Update()<br/> {<br/> if (!_ready)<br/> {<br/> return;<br/> }<br/> transform.rotation = baseRotation * Quaternion.AngleAxis(webCamTexture.videoRotationAngle, Vector3.up);<br/><br/>int detectedFaceCount = 0;<br/> unsafe<br/> {<br/> fixed (CvCircle* outFaces = _faces)<br/> {<br/> OpenCVWrapper.Detect(outFaces, _maxFaceDetectCount, ref detectedFaceCount);<br/> }<br/> }<br/><br/>NormalizedFacePositions.Clear();<br/> for (int i = 0; i &lt; detectedFaceCount; i++)<br/> {<br/> NormalizedFacePositions.Add(new Vector2((_faces[i].X * DetectionDownScale) / CameraResolution.x, 1f - ((_faces[i].Y * DetectionDownScale) / CameraResolution.y)));<br/> }<br/> }<br/>}</pre>
<p>Save the script and go back to the Unity Editor. You will immediately notice that Unity will show an error along the lines of <em>unsafe code needs to be allowed</em>. Let's go ahead and enable this feature. To do this, go to your <span class="packt_screen">Player Settings</span>, which is located inside the <span class="packt_screen">Build Settings.</span></p>
<p>Inside the <span class="packt_screen">Player Settings</span>, look down at the configuration inside <span class="packt_screen">Other Settings</span>, and there is a checkbox called <span class="packt_screen">Allow 'unsafe' Code</span>. Make sure that it is checked:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f76df7c-042d-4539-9be0-99b572b37bb9.png" style="width:29.00em;height:46.42em;"/></p>
<p>In the <kbd>Scripts</kbd> folder, you need one more file to be added; in my example file that you can download, I have quite a few more <kbd>.xml</kbd> files than what I am going to tell you to add. The reason for this is to allow you to play around with the different <kbd>.xml</kbd> files to see their results. You will have to update the C++ plugin to account for the proper <kbd>.xml</kbd> file you want to use; alternatively, you can update the<span> </span><span><kbd>Init</kbd> function </span>to take a string parameter to be able to change the <kbd>.xml</kbd> file in the Unity Editor.</p>
<p>In your <kbd>OpenCV</kbd> folder, navigate to <kbd>OpenCV\opencv\build\etc\lbpcascades</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/018651ad-d491-4274-8547-159c82b3f5ef.png"/></p>
<p>You want to copy <kbd>lbpcascade_frontalface.xml</kbd> into the scripts folder in Unity. (My project has everything in an <kbd>XML</kbd> folder, as I have many more <kbd>.xml</kbd> files to play with.)</p>
<p>Finally, we just need to create a plane to face the camera.</p>
<p>The last step is to attach the <kbd>OpenCVFaceDetection</kbd> script to the plane.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, the project will compile and run appropriately (if you get a dll import error, make sure you have the dll set to <span class="packt_screen">x86-x64</span> and that the project is built for <span class="packt_screen">Windows</span>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3f110ed7-1497-4c1b-ae33-1cd683788c50.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to use CMake to build OpenCV from source, to import it into Unity, and create an AR application similar to many on the market that are able to add images over a person's face and track their movements reliably, by using OpenCV and DLib FaceLandmark Detector, using Dlib C++Library.</p>
<p>In the next, and final, chapter, we will look into building for MR devices such as HoloLens. As a short teaser, MR incorporates elements from AR and VR into a single game or application, which can prove to have massive and interesting effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>OpenCV is cross-platform and can work with Android, Linux, MacOS, iOS, Windows, HoloLens, and Oculus Rift:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="2">
<li>The Dlib C++ Library is required to make OpenCV work on Windows:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="3">
<li>OpenCV cannot be built from source:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="4">
<li>Unity is not compatible with OpenCV:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="5">
<li>You can use OpenCV with ARKit, ARCore, and Vuforia:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="6">
<li> OpenCV is a library designed for machine learning and computer vision:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="7">
<li>OpenCV can be used with AR, VR, and MR project types:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>For the free assets that give you deeper insight into how to use OpenCV with Unity, you can download them from this GitHub link: <a href="https://github.com/EnoxSoftware/OpenCVForUnity">https://github.com/EnoxSoftware/OpenCVForUnity</a></li>
<li>To read the documentation on the Dlib C++ library, go to <a href="http://dlib.net/">http://dlib.net/</a><span>.</span></li>
<li>To learn about the methods, properties, fields, and OpenCV tutorials in C++, Python, and Javascript, and to gain deeper understanding of how OpenCV is put together, you can go to this link: <a href="https://docs.opencv.org/3.4.1/">https://docs.opencv.org/3.4.1/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>