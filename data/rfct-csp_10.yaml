- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Defensive Coding Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御性编码技术
- en: Code is almost organic and evolves over its lifetime as new features are added,
    fixes are implemented, and refactorings occur at regular intervals. As code changes
    and developers enter and leave the project, there’s a chance that some of these
    changes may introduce bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎是有机的，在其生命周期中随着新功能的添加、修复的实施以及定期发生的重构而演变。随着代码的变化和开发者的加入与离开，有些变化可能会引入错误。
- en: In *Part 2* of this book, we discussed testing strategies for detecting these
    bugs before they reach production. In this chapter, we’ll talk about a few additional
    techniques that help developers catch and resolve bugs during development. Along
    the way, we’ll also explore a few newer features in C# and their roles in keeping
    your code stable and healthy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的**第2部分**中，我们讨论了在这些问题达到生产之前检测这些错误的测试策略。在本章中，我们将讨论一些额外的技术，这些技术有助于开发者在开发过程中捕获和解决错误。在这个过程中，我们还将探讨C#的一些新功能及其在保持代码稳定和健康中的作用。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Validating inputs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入
- en: Protecting against null
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止空值
- en: Moving beyond classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越类
- en: Advanced type usage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级类型使用
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter10/Ch10BeginningCode` folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可以从GitHub的[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)中的`Chapter10/Ch10BeginningCode`文件夹获取。
- en: The code in this chapter talks to a REST API, which will require an active internet
    connection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码与REST API通信，这将需要一个活跃的互联网连接。
- en: Introducing the Cloudy Skies API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍多云天空API
- en: Our fictitious sample organization, Cloudy Skies, has a pre-existing set of
    web services in the form of a public **REST API**. This API intends to allow interested
    organizations to pull information about Cloudy Skies flights through the API.
    However, a steady amount of support tickets has proven that organizations are
    having a hard time adopting the API and using it in approved ways.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们虚构的示例组织“多云天空”已经存在一套以公共**REST API**形式存在的网络服务。这个API旨在允许感兴趣的机构通过API获取关于多云天空航班的详细信息。然而，大量的支持工单证明，组织在使用API和以批准的方式使用它时遇到了困难。
- en: In response, Cloudy Skies has built a .NET library to help others more easily
    use the API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，多云天空构建了一个.NET库，以帮助其他人更容易地使用API。
- en: Early testing of this library is promising, but some developers are still encountering
    confusing errors that ultimately appear to be related to the data they’re passing
    the library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的早期测试很有希望，但一些开发者仍然遇到一些令人困惑的错误，最终似乎与传递给库的数据有关。
- en: The development team decided that validating parameters to public methods would
    help improve the adoption of their library by finding issues sooner. We’ll explore
    this change in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队决定，通过提前验证公共方法的参数，可以帮助他们更快地发现并解决问题，从而提高他们库的采用率。我们将在下一节中探讨这个变化。
- en: Validating inputs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证输入
- en: '**Input validation** is the act of verifying that any inputs to your code,
    such as parameters or current property values, are correct before performing the
    requested work. We validate inputs to public methods to detect potential issues
    early on.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入验证**是在执行请求的工作之前验证代码的任何输入（如参数或当前属性值）是否正确的行为。我们通过验证公共方法来早期检测潜在问题。'
- en: 'To illustrate the importance of this, let’s look at a method that doesn’t validate
    its inputs:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点的重要性，让我们看看一个没有验证其输入的方法：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `GetFlight` method takes in an `id` parameter indicating a flight number,
    such as “CSA1234,” whereas the `apiKey` parameter represents a token that must
    be supplied to interact with the API and get a response. Think of the token as
    something like a digital keycard that Cloudy Skies issues to interested organizations
    that want to interact with its APIs. Every request that goes to the Cloudy Skies
    API must include a token to authenticate and get a result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlight`方法接受一个`id`参数，表示航班号，例如“CSA1234”，而`apiKey`参数代表一个必须提供的令牌，用于与API交互并获取响应。将令牌想象成多云天空向希望与其API交互的感兴趣机构发放的数字钥匙卡。每个发送到多云天空API的请求都必须包含一个令牌以进行身份验证并获取结果。'
- en: The `id` parameter is important because it is used to identify the flight that
    we’re interested in. This parameter gets added to the URL that the code makes
    an HTTP GET request to using the RestSharp library, which is one of many ways
    of interacting with web services in modern .NET.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`参数很重要，因为它用于识别我们感兴趣的航班。此参数通过使用RestSharp库向URL添加，该库是现代.NET中与Web服务交互的许多方式之一，用于向代码执行HTTP
    GET请求。'
- en: Don’t panic!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不要慌张！
- en: If any of the web services code or handling of authentication tokens is beyond
    your comfort zone, don’t worry. While these are concepts you should learn as you
    grow, the actual mechanics of the web API are not important for this chapter.
    Instead, we’re focusing on parameter validation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何Web服务代码或身份验证令牌的处理超出了你的舒适区，不要担心。虽然这些是在你成长过程中应该学习的概念，但Web API的实际机制对于本章来说并不重要。相反，我们专注于参数验证。
- en: Now that we’ve established what this method is doing, let’s talk about how it
    could be better.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了这个方法的作用，让我们谈谈它如何可以做得更好。
- en: 'First of all, any value for a string is valid here for both `id` and `apiKey`.
    This includes values such as null and empty or whitespace strings. While you might
    not think that a developer might try those values for those parameters, I can
    think of compelling reasons someone might try either one:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于字符串的任何值都是有效的，无论是`id`还是`apiKey`。这包括null、空或空白字符串等值。虽然你可能认为开发者不会尝试这些参数的值，但我可以想到一些合理的理由，某人可能会尝试其中一个：
- en: Someone might try to pass null for the `id` parameter, thinking that it would
    get the next flight, all flights, or possibly even a random flight
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人可能会尝试为`id`参数传递null，认为这将获取下一班航班、所有航班，甚至可能是随机航班。
- en: A developer without an API key may think that API keys are only required for
    requests that modify data on the server or that you can interact with the API
    in low volumes without an API key
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有API密钥的开发者可能会认为API密钥仅适用于修改服务器上数据的请求，或者在没有API密钥的情况下以低量与API交互。
- en: While both assumptions are incorrect for this API, I could see someone without
    knowledge of the system trying either one. In the case of Cloudy Skies, not providing
    a valid API key will result in a 401 unauthorized error coming back from the server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个假设对于这个API都是不正确的，但我可以想象一个不了解系统的人会尝试其中任何一个。在Cloudy Skies的情况下，不提供有效的API密钥将导致服务器返回401未授权错误。
- en: 'On the other hand, not providing an `id` parameter results in a `NullReferenceException`
    error when the code tries to convert `id` into lowercase, as shown in *Figure
    10**.1*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不提供`id`参数会导致代码在尝试将`id`转换为小写时出现`NullReferenceException`错误，如图*图10.1*所示：
- en: '![Figure 10.1 – A NullReferenceException error due to id being null when ToLower
    was called](img/B21324_10_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 当调用ToLower时，由于id为null导致的NullReferenceException错误](img/B21324_10_1.jpg)'
- en: Figure 10.1 – A NullReferenceException error due to id being null when ToLower
    was called
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 当调用ToLower时，由于id为null导致的NullReferenceException错误
- en: Both of these errors are things that a developer trying to interact with this
    code could encounter, and neither one of these errors adequately tells the developer
    that they made a mistake in the parameters they passed in. Let’s fix this with
    validation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个错误都是试图与该代码交互的开发者可能会遇到的问题，而且这两个错误都没有充分地告诉开发者他们在传递的参数中犯了错误。让我们通过验证来修复这个问题。
- en: Performing basic validation
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行基本验证
- en: The goal of validation is to detect bad inputs early on and explicitly point
    out these issues before bad data gets deeper into our system. In building a library,
    this means that we want to validate parameters sent to our code as early as possible,
    preferably in the public methods other developers will interact with.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的目标是在早期检测到不良输入，并在不良数据进一步进入我们的系统之前明确指出这些问题。在构建库时，这意味着我们希望在代码中尽可能早地验证发送给我们的参数，最好是在其他开发人员将与之交互的公共方法中。
- en: 'Here’s a version of `GetFlight` that performs some additional validation steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`GetFlight`的一个版本，它执行了一些额外的验证步骤：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we check if `apiKey` or `id` are either null or empty strings. If that’s
    true, we throw an `ArgumentNullException` error to tell whoever called this method
    that they are not providing a valid value for a specific parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查`apiKey`或`id`是否为null或空字符串。如果是这样，我们抛出一个`ArgumentNullException`错误，告诉调用此方法的任何人他们没有为特定参数提供有效的值。
- en: We also perform a check on `id` to determine whether it refers to a flight with
    a Cloudy Skies Airline prefix. If it doesn’t, this flight will never be found
    since it isn’t tracked by the system. In this case, it makes sense to alert the
    caller with an `ArgumentOutOfRangeException` error. This exception type is also
    commonly used with numbers or dates that are outside of acceptable ranges for
    a method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查 `id` 是否指向带有 Cloudy Skies Airline 前缀的航班。如果不是，由于系统没有跟踪这个航班，这个航班将永远不会被找到。在这种情况下，使用
    `ArgumentOutOfRangeException` 错误来提醒调用者是有意义的。这种异常类型也常与超出方法可接受范围的数字或日期一起使用。
- en: Should we really throw exceptions here?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的应该在这里抛出异常吗？
- en: Many new developers think that exceptions are bad. Most developers hate encountering
    exceptions, and throwing exceptions can indeed be relatively slow. Keeping these
    things in mind, when you get invalid values, sometimes, the best option is to
    throw a specific exception that highlights the issue. This helps catch mistakes
    quickly and prevents errors that can occur from letting invalid values deeper
    into a system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新开发者认为异常是坏事。大多数开发者都讨厌遇到异常，抛出异常确实可能相对较慢。考虑到这些因素，当你得到无效值时，有时，最佳选择是抛出一个突出问题的特定异常。这有助于快速捕获错误，并防止无效值进一步进入系统。
- en: You may have noticed that the revised code has a lot of validation relative
    to the other logic in the method. There are a few ways of improving this, as we’ll
    see in the upcoming sections, but let’s work toward that goal incrementally. We’ll
    start by looking at a better way of referring to bad parameter values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，修改后的代码与该方法中的其他逻辑相比有很多验证。有几种方法可以改进这一点，我们将在接下来的章节中看到，但让我们逐步实现这个目标。我们将从查看引用不良参数值的好方法开始。
- en: Using the nameof keyword
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 nameof 关键字
- en: 'Right now, the code validates parameters and throws exceptions with code like
    this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，代码使用如下方式验证参数并抛出异常：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `"apiKey"` refers to the name of the parameter, which helps
    developers identify which parameter the exception is complaining about.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`"apiKey"` 指的是参数的名称，这有助于开发者识别异常所抱怨的参数。
- en: Now, what happens if someone renames that parameter later to `apiToken`? This
    change wouldn’t cause any compiler errors and the exception could still be thrown.
    Unfortunately, the exception would reference the old `apiKey` parameter name that
    was no longer present, which would confuse the developer encountering the error.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人后来将那个参数重命名为 `apiToken`，会发生什么？这个更改不会导致编译器错误，异常仍然可以抛出。不幸的是，异常将引用不再存在的旧
    `apiKey` 参数名称，这可能会让遇到错误的开发者感到困惑。
- en: 'To help with this, C# gives us the `nameof` keyword, which looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，C# 提供了 `nameof` 关键字，其语法如下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When your code is compiled, the `nameof` keyword evaluates the name of the parameter,
    method, or class it is used on. A string with the result of that `nameof` evaluation
    is then included in the compiled code. In other words, it’s identical to the code
    we had before – except that if the parameter is ever renamed, our code no longer
    compiles until the `nameof` keyword is updated to refer to the renamed parameter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码编译时，`nameof` 关键字会评估它所使用的参数、方法或类的名称。然后，包含该 `nameof` 评估结果的字符串将被包含在编译后的代码中。换句话说，它与之前的代码相同——只不过如果参数被重命名，我们的代码将无法编译，直到
    `nameof` 关键字更新为引用重命名的参数。
- en: This allows us to rely on the compiler to help ensure our parameter validation
    uses the correct parameter names, even if those parameters are renamed in the
    future.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们依赖编译器来帮助我们确保我们的参数验证使用了正确的参数名称，即使这些参数在未来被重命名。
- en: Let’s introduce a more concise way of throwing exceptions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一种更简洁的抛出异常的方法。
- en: Validation with guard clauses
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用守卫子句进行验证
- en: Right now, our validation logic consists of an `if` statement followed by a
    conditional `throw` statement. This validation is so common and can take up many
    lines of code when validation is complex that .NET now gives us a more concise
    way of interacting with it in the form of **guard clauses**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的验证逻辑由一个 `if` 语句和一个条件 `throw` 语句组成。这种验证非常常见，当验证复杂时，它可能会占用很多代码行。因此，.NET
    现在以 **守卫子句** 的形式提供了一种更简洁的与之交互的方式。
- en: 'We can take our validation down to a single line of code by calling `ArgumentException.ThrowIfNullOrEmpty`,
    as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `ArgumentException.ThrowIfNullOrEmpty` 将验证简化为单行代码，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method will check the value of the parameter it is passed in and will throw
    either an `ArgumentNullException` error if the value is null or an `ArgumentException`
    error if the value is an empty string.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将检查传入参数的值，如果值为空，则抛出`ArgumentNullException`错误；如果值为空字符串，则抛出`ArgumentException`错误。
- en: There aren’t a lot of these validations built into .NET right now, but if you
    like the idea and want validations for things such as negative values or numeric
    or date ranges, you’ll love Steve Smith’s excellent **GuardClauses library**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前.NET中内置的这些验证并不多，但如果你喜欢这个想法，并且想要对负值或数字或日期范围等进行验证，你将喜欢Steve Smith的优秀的**GuardClauses库**。
- en: Guard clauses with the GuardClauses library
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GuardClauses库的保护子句
- en: To help augment the built-in guard clauses, Steve Smith created the **Ardalis.GuardClauses**
    library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助增强内置的保护子句，Steve Smith创建了**Ardalis.GuardClauses**库。
- en: To use the GuardClauses library, install the latest version of Ardallis.GuardClauses
    via NuGet Package Manager, as we’ve done in prior chapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GuardClauses库，通过NuGet包管理器安装Ardallis.GuardClauses的最新版本，就像我们在前面的章节中所做的那样。
- en: Next, add `using Ardalis.GuardClauses;` to the top of your `.``cs` file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`using Ardalis.GuardClauses;`添加到你的`.cs`文件顶部。
- en: 'Once that’s been installed and referenced, you’ll be able to use guard syntax,
    as shown in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装并引用，你将能够使用保护语法，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the GuardClauses library provides various static methods inside `Guard.Against`
    syntax that allow you to validate a great many things.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，GuardClauses库在`Guard.Against`语法内部提供了各种静态方法，允许你验证许多事物。
- en: If a validation condition is met – for example, if `maxMiles` is `4` when `NegativeOrZero`
    is called – the program continues as normal. However, if the condition is not
    met, an `ArgumentException` error will be thrown containing the name of the parameter
    that violated the condition.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证条件满足——例如，当调用`NegativeOrZero`时`maxMiles`为`4`——程序将正常继续。然而，如果条件不满足，将抛出一个包含违反条件参数名称的`ArgumentException`错误。
- en: I’ve found this library to be intuitive to write and read, and it also leads
    to efficient and effective guard clauses that require a minimal amount of effort.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这个库易于编写和阅读，它还导致了高效且有效的保护子句，这些子句需要最少的努力。
- en: The full extent of the GuardClauses library is well beyond the scope of this
    book, but you can install it and see the methods available or check out the documentation
    referenced in the *Further reading* section at the end of this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GuardClauses库的完整范围超出了本书的范围，但你可以安装它并查看可用的方法，或者查看本章末尾*进一步阅读*部分中引用的文档。
- en: But wait – there’s more!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等——还有更多！
- en: This book’s wonderful technical reviewers rightly pointed out the popular **FluentValidation
    library**, which offers a rich set of validation rules that can be applied to
    your classes. You can learn more about this library in the *Further* *reading*
    section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本书出色的技术审稿人正确地指出了流行的**FluentValidation库**，该库提供了一组丰富的验证规则，可以应用于你的类。你可以在*进一步阅读*部分了解更多关于这个库的信息。
- en: Before we move on, I want to point out one aspect of the `Ardalis.GuardClauses`
    library that you might not have noticed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想指出`Ardalis.GuardClauses`库的一个你可能没有注意到的方面。
- en: Let’s say you call a guard clause with `Guard.Against.Null(apiKey);`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用`Guard.Against.Null(apiKey);`调用保护子句。
- en: If this validation rule fails it will throw an `ArgumentException` error. This
    exception will have a `ParamName` property with a value of `apiKey`. Additionally,
    the resulting message will mention the `apiKey` parameter by name, *even though
    you didn’t provide the name when you called the* *guard clause*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个验证规则失败，它将抛出一个`ArgumentException`错误。这个异常将有一个`ParamName`属性，其值为`apiKey`。此外，生成的消息将按名称提及`apiKey`参数，*即使你在调用*
    *保护子句*时没有提供该名称。
- en: This works due to the library’s use of the `CallerArgumentExpression` attribute,
    which we’ll explore next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为库使用了`CallerArgumentExpression`属性，我们将在下一节中探讨。
- en: Using CallerMemberInformation attributes
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CallerMemberInformation属性
- en: The `nameof` keyword proved so successful in eliminating strings referring to
    things that were later renamed that C# grew to accompany four separate attributes
    that can tell you things about any given method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`关键字在消除后来被重命名的字符串引用方面取得了如此成功，以至于C#发展出了四个独立的属性，可以告诉你关于任何给定方法的信息。'
- en: Each of these attributes is applied to a method parameter. Like the `nameof`
    keyword, these attributes are evaluated at compile time and result in a `string`
    or `int` type being used in the final compiled code in their place.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性都应用于方法参数。像 `nameof` 关键字一样，这些属性在编译时进行评估，并在最终编译代码中用 `string` 或 `int` 类型替换。
- en: 'The four available caller member attributes are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的四个调用者成员属性如下：
- en: '**CallerFilePath** contains a string with the name and path of the file of
    the code calling to the method on the machine compiling the code'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CallerFilePath** 包含一个字符串，包含在编译代码的机器上调用方法的代码文件的名称和路径'
- en: '`int` type with the line number for the method call'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 类型的行号用于方法调用'
- en: '**CallerMemberName** contains the name of the method or property where the
    method call occurred'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CallerMemberName** 包含发生方法调用时的方法或属性名称'
- en: '**CallerArgumentExpression** converts the expression passed into the method
    into a string, before evaluating the expression'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CallerArgumentExpression** 在评估表达式之前，将传递给方法的表达式转换为字符串'
- en: 'Let’s look at `LogApiCall` for an example of this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `LogApiCall` 为例来展示这一点：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method takes in five parameters, where the first is a standard string parameter
    and the other four use the various caller member information attributes. Notice
    how these attributes all have a default value specified. When values are not specified
    for these parameters, the compiler will replace each parameter with values it
    detected during compilation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受五个参数，其中第一个是标准字符串参数，其余四个使用各种调用者成员信息属性。注意这些属性都指定了默认值。当未指定这些参数的值时，编译器将用它在编译期间检测到的值替换每个参数。
- en: 'Let’s look at an example call:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例调用：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how when `LogApiCall` is invoked, only the string parameter is specified.
    The remaining parameters are provided values during compilation due to the attributes
    on each parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当 `LogApiCall` 被调用时，只指定了字符串参数。其余参数由于每个参数上的属性，在编译期间提供了值。
- en: Also, note that the expression that was used to get that string is `request.Resource`.
    This expression is what `CallerArgumentExpression` uses to generate its string
    because the `CallerArgumentExpression` attribute requires the name of another
    parameter. In this case, we specified `[CallerArgumentExpression(nameof(url))]`
    to have it look at the expression that was passed into the `url` parameter – the
    first parameter the method takes in.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意用于获取该字符串的表达式是 `request.Resource`。这个表达式是 `CallerArgumentExpression` 属性用来生成其字符串的原因，因为
    `CallerArgumentExpression` 属性需要另一个参数的名称。在这种情况下，我们指定了 `[CallerArgumentExpression(nameof(url))]`，以便它查看传递给
    `url` 参数的表达式——方法是接受的第一个参数。
- en: 'When this code runs, we will see the following message logged in the console:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码运行时，我们将在控制台中看到以下消息记录：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, it logged the full path to the file on my hard drive, as well
    as the line number of the `LogApiCall` method call.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它记录了我硬盘上文件的完整路径，以及 `LogApiCall` 方法调用的行号。
- en: 'The expression of `request.Resource` is the exact string of code that’s used
    to call that method, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.Resource` 的表达式是用于调用该方法的精确代码字符串，如下所示：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Caller member information attributes are very handy for certain types of things,
    such as logging and validation, or certain specialized scenarios such as raising
    `INotifyProperty` changed in **Windows Presentation Foundation** (**WPF**) applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者成员信息属性对于某些类型的事情非常有用，例如日志记录和验证，或者某些特定的场景，例如在 **Windows Presentation Foundation**
    （**WPF**）应用程序中引发 `INotifyProperty` 改变。
- en: Now that we’ve sufficiently explored working with parameters for our methods,
    let’s look at how modern C# lets us work safely with null values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经充分探讨了与我们的方法参数一起工作，让我们看看现代 C# 如何让我们安全地处理空值。
- en: Protecting against null
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止空值
- en: British computer scientist, Tony Hoare, is generally credited as the inventor
    of the null reference in programming. In 2008, he famously apologized for it,
    calling it his “billion-dollar mistake.” This was due to the countless bugs and
    crashes that have occurred in various programming languages when code attempted
    to interact with variables currently holding null values. While I can’t fault
    Tony Hoare, nulls can certainly be dangerous.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 英国计算机科学家托尼·霍尔（Tony Hoare）通常被认为是编程中空引用的发明者。2008年，他因它而著名地道歉，称其为他的“十亿美元的错误”。这是由于在多种编程语言中，当代码尝试与当前持有空值的变量交互时，发生了无数的错误和崩溃。虽然我不能责怪托尼·霍尔，但空引用确实可能很危险。
- en: In .NET, this comes in the form of a `NullReferenceException` error, as we saw
    earlier in this chapter. You get a `NullReferenceException` error any time you
    attempt to invoke a method or evaluate a property on a variable that currently
    holds a null value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，这以 `NullReferenceException` 错误的形式出现，正如我们在本章前面所看到的。每次尝试调用包含 null 值的变量的方法或评估其属性时，都会出现
    `NullReferenceException` 错误。
- en: 'Before C# 8, developers needed to be explicitly aware that any reference type
    could hold a null value and write conditional logic, such as the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8 之前，开发者需要明确意识到任何引用类型都可能包含 null 值，并编写条件逻辑，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This pattern of checking for nullability and then conditionally acting became
    prevalent in C# because when it didn’t, developers encountered `NullReferenceException`
    errors. Unfortunately, this led to null checks occurring throughout the code,
    including in many places where nulls would never be encountered.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种检查可空性然后条件性采取行动的模式在 C# 中变得普遍，因为当它没有这样做时，开发者会遇到 `NullReferenceException` 错误。不幸的是，这导致了代码中到处都有
    null 检查，包括许多永远不会遇到 null 的地方。
- en: In C# 8, nullable reference types were introduced, which helped developers understand
    when and where they were likely to encounter null values so that they would have
    active reminders to guard against null values in those places. Additionally, these
    improvements made it easier to remove unnecessary null checks in places where
    nulls were not expected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8 中，引入了可空引用类型，这有助于开发者了解何时何地可能会遇到 null 值，以便他们会有积极的提醒来防止在这些地方出现 null 值。此外，这些改进使得在预期不会出现
    null 的地方移除不必要的 null 检查变得更加容易。
- en: 'In C# 8 and beyond, when nullability analysis is enabled, you can indicate
    that any reference type may be null by adding `?` after the type indicator, as
    shown here for `FlightInfo`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8 及更高版本中，当启用可空性分析时，您可以通过在类型指示符后添加 `?` 来指示任何引用类型可能是 null，就像这里对 `FlightInfo`
    所示的那样：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, this indicates that the `GetFlight` method will return either
    a `FlightInfo` instance or a null value. Additionally, this indicates that the
    `id` and `apiKey` parameters will always have a string that is not null. If these
    accepted null values, they would be declared as `string? Id, string?` `apiKey`
    instead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这表示 `GetFlight` 方法将返回一个 `FlightInfo` 实例或一个 null 值。此外，这也表示 `id` 和 `apiKey`
    参数将始终有一个非 null 的字符串。如果这些参数接受 null 值，它们将被声明为 `string? Id, string? apiKey`。
- en: Important note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Nullability analysis in C# does not prevent you from passing null to things
    that say they do not accept null values, nor does it prevent you from returning
    null values from methods that claim to return a non-null return type. Instead,
    nullability analysis flags these cases as warnings, which will help you address
    these issues. We’ll talk more about code analysis warnings in [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的可空性分析不会阻止您将 null 传递给声明不接受 null 值的对象，也不会阻止您从声明返回非 null 返回类型的方法中返回 null 值。相反，可空性分析将这些情况标记为警告，这将帮助您解决这些问题。我们将在
    [*第 12 章*](B21324_12.xhtml#_idTextAnchor259) 中更多地讨论代码分析警告。
- en: 'If we wanted to say that `GetFlight` could never return null, we would remove
    `?` from the `FlightInfo` return type and validate that the result from the API
    was not null:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想表示 `GetFlight` 永远不会返回 null，我们需要从 `FlightInfo` 返回类型中移除 `?` 并验证 API 的结果不是
    null：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The request to the API via `_client.Get` still might return a nullable value,
    so the code must now check for null and conditionally throw an exception if a
    null value is encountered. However, this guarantees that the code returns only
    a non-null value, which is what the return type of `FlightInfo` indicates with
    nullability analysis active.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `_client.Get` 对 API 的请求仍然可能返回一个可空值，因此代码现在必须检查 null，并在遇到 null 值时条件性地抛出异常。然而，这保证了代码只返回非
    null 值，这是在启用可空性分析时 `FlightInfo` 返回类型所指示的。
- en: Let’s look at how to enable and disable nullability analysis in Visual Studio.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Visual Studio 中启用和禁用可空性分析。
- en: Enabling nullability analysis in C#
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 中启用可空性分析
- en: Since .NET 6, nullable reference types are enabled by default in new projects
    going forward.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自 .NET 6 以来，新的项目默认启用可空引用类型。
- en: 'However, you can enable nullable reference types in any project using C# 8
    or above by adding a `<Nullable>enable</Nullable>` node to your project’s `.``csproj`
    file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以通过在项目的 `.csproj` 文件中添加 `<Nullable>enable</Nullable>` 节点来在任何使用 C# 8 或更高版本的项目中启用可空引用类型：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can edit this file either in a text editor such as Notepad, or you can double-click
    on the project node in **Solution Explorer** to edit the file inside Visual Studio.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用文本编辑器（如记事本）或双击**解决方案资源管理器**中的项目节点来在Visual Studio内部编辑此文件。
- en: 'If you don’t want nullability analysis enabled for your entire project, you
    can enable and disable nullability analysis with preprocessor statements such
    as `#nullable enable` and `#nullable disable`. For example, the following code
    temporarily disables nullability analysis for a class definition:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望在整个项目中启用空值分析，您可以使用预处理语句如`#nullable enable`和`#nullable disable`来启用和禁用空值分析。例如，以下代码暂时禁用了类定义的空值分析：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I’d encourage you to use project-level nullability analysis and avoid using
    `#nullable` when possible. I’ve known many developers who get nauseated every
    time they see a preprocessor statement. My opinion is that `#nullable` should
    be reserved for when you are moving a larger project to use nullability analysis
    but are not yet ready to enable it for the entire project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您使用项目级别的空值分析，并在可能的情况下避免使用`#nullable`。我认识很多开发者每次看到预处理语句都会感到恶心。我的观点是，`#nullable`应该保留在您将大型项目迁移到使用空值分析，但尚未准备好在整个项目中启用它的情况下使用。
- en: Using nullability operators
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用空值运算符
- en: Earlier, we talked about how `?` indicates that a type may contain a null value,
    but there are several other operators related to nullability you should be aware
    of in C#.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了`?`如何表示一个类型可能包含null值，但在C#中还有几个与空值相关的运算符您应该了解。
- en: First of all, the non-null assertion operator of `!` tells C# that something
    is not going to be null and to ignore nullability warnings on that value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`!`非空断言运算符告诉C#某个值不会是null，并忽略该值的空值警告。
- en: 'One common place I use this is when working with `Console.ReadLine()`. This
    method indicates it may return a null value, but in practice, it never does in
    normal operation. This can be suppressed using `!`, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我常用这个功能是在处理`Console.ReadLine()`时。此方法指示它可能返回null值，但在实际操作中，在正常操作中它永远不会返回null。这可以通过`!`来抑制，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are taking `ReadLine`, which is defined as having a `string?` result
    and storing it in `string`. The `!` operator says that the `string?` result should
    be treated as if it was `string`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`ReadLine`（定义为具有`string?`结果并将其存储在`string`中）作为例子。`!`运算符表示`string?`结果应被视为`string`。
- en: 'Other nullability operators include the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其他空值运算符包括以下内容：
- en: The `?`), which conditionally calls methods only if the object they’re being
    invoked on is not null. For example, `_conn?.Dispose()` calls the `Dispose` method
    only if `_conn` is not null.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`运算符仅在对象不是null时才条件性地调用方法。例如，`_conn?.Dispose()`仅在`_conn`不是null时调用`Dispose`方法。'
- en: The `??`), which uses a backup value in case something is null. For example,
    `int miles = flight?.Miles ?? 0;` uses null-conditional and null coalescing operators
    to safely get `Miles` out of a flight or use `0` when no flight is present.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`??`运算符在某个值可能为null的情况下使用备份值。例如，`int miles = flight?.Miles ?? 0;`使用空条件运算符和空合并运算符安全地从航班中获取`Miles`，或者在不存在航班时使用`0`。'
- en: The `??=`) assigns a value to a variable only if the variable is null already.
    For example, `message ??= "An unexpected error has occurred";` will only set the
    new error message in `message` if `message` is null. This allows us to effectively
    replace null values with backup values.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`??=`运算符仅在变量已经是null时才将值赋给变量。例如，`message ??= "An unexpected error has occurred";`仅在`message`是null时才设置新的错误消息。这允许我们有效地用备份值替换null值。'
- en: The combination of nullability analysis and nullability operators helps us make
    intelligent decisions around null values in concise ways. This keeps our code
    efficient and focused while guiding us toward having a cohesive strategy around
    handling null values in code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 空值分析和空值运算符的组合帮助我们以简洁的方式就null值做出明智的决策。这使我们的代码保持高效和专注，同时引导我们围绕处理代码中的null值制定一致的战略。
- en: Let’s take a broader look at changes we can make at the class level to help
    design more robust applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更广泛地看看我们可以在类级别进行哪些更改，以帮助设计更健壮的应用程序。
- en: Moving beyond classes
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越类
- en: In C# 9 and beyond, Microsoft has made concerted efforts to give developers
    new options for working with classes through things such as record types, init-only
    properties, primary constructors, and more.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 9及更高版本中，微软通过记录类型、只读属性、主构造函数等方式，为开发者提供了更多与类一起工作的选项。
- en: In this section, we’ll explore how these newer C# constructs can improve the
    design of your classes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨这些新的C#结构如何改进你的类的设计。
- en: Preferring immutable classes
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倾向于使用不可变类
- en: In recent years, immutable classes have become more and more popular. This immutability
    refers to the inability to change an object after it has been created.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，不可变类越来越受欢迎。这种不可变性指的是在对象创建后无法更改对象的能力。
- en: What this means is that once an object exists, you cannot modify its state and
    instead are limited to creating new objects that are like the original. If you’re
    familiar with working with string and DateTime objects in .NET, you’ve seen this
    concept with methods such as `ToLower` on string and `AddDays` on DateTime returning
    a new object instead of modifying the original object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦对象存在，你无法修改其状态，而是只能创建新的对象，这些新对象与原始对象类似。如果你熟悉在.NET中使用字符串和DateTime对象，你已经在字符串的`ToLower`方法和DateTime的`AddDays`方法上看到了这个概念，这些方法返回一个新对象而不是修改原始对象。
- en: 'Let’s look at a small class representing a boarding pass that is currently
    mutable (changeable) and then convert it into an immutable class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个小类，它代表一个当前可变的登机牌，然后将其转换为不可变类：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a “plain old C# object” with properties with getters and setters. Thinking
    about the class logically, there are several problems:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个“普通的C#对象”，具有具有获取器和设置器的属性。从逻辑上考虑这个类，有几个问题：
- en: There’s nothing preventing `Flight`, `Passenger`, or `Seat` from having a null
    value.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何东西阻止`Flight`、`Passenger`或`Seat`具有空值。
- en: Once a pass is created, properties such as `passenger`, `boarding group`, `seat`,
    and even `flight` can be changed. This doesn’t make sense in the context of an
    airline business where a new boarding pass would need to be issued to change these.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦创建了一个登机牌，属性如`passenger`、`boarding group`、`seat`甚至`flight`都可以被更改。在航空业务中，这并不合理，因为需要发放新的登机牌来更改这些信息。
- en: 'We can change this object so that it’s immutable and requires valid values
    for these parameters by removing their setters and adding a constructor with validation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过移除设置器并添加一个带有验证的构造函数来改变这个对象，使其不可变并要求这些参数有有效的值：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This constructor now requires that valid values are present for all properties
    on the object in object creation. Meanwhile, the removal of setters for the properties
    ensures that the class stays valid and cannot be changed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个构造函数要求在对象创建时所有属性都存在有效值。同时，属性设置器的移除确保了类保持有效且不能被更改。
- en: If we needed to, we could add new methods to the `BoardingPass` class that create
    and return a new `BoardingPass` object with similar characteristics to the original
    in a similar manner to how various string and DateTime methods work. However,
    `with expressions` give us a more interesting way of doing this, as we’ll see
    later in this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以在`BoardingPass`类中添加新方法，以类似各种字符串和DateTime方法的方式创建并返回一个具有与原始对象类似特征的新`BoardingPass`对象。然而，“with表达式”给我们提供了一个更有趣的方式来做到这一点，正如我们将在本章后面看到的。
- en: 'While using immutability may seem more inconvenient than beneficial at first,
    there are a few key advantages of using immutable classes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始使用不可变性可能看起来比有益更不方便，但使用不可变类有几个关键优势：
- en: Immutable classes can be validated during creation and ensured that they are
    in a valid state. Once created, this valid state cannot change.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变类可以在创建时进行验证，并确保它们处于有效状态。一旦创建，这种有效状态就不会改变。
- en: When objects can be modified anywhere in your code, this makes it harder to
    track down what changed an object when multiple other classes may have a reference
    to it. Immutable objects prevent this from occurring.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象可以在你的代码的任何地方被修改时，这会使追踪一个对象何时被多个其他类引用变得更加困难。不可变对象防止这种情况发生。
- en: Some concepts just make more sense as immutable objects, such as a prior version
    of a document or a boarding pass for a passenger at an airport.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些概念作为不可变对象更有意义，例如文档的早期版本或机场乘客的登机牌。
- en: Since immutable objects don’t change, they can be reliably worked with in multi-threaded
    applications. Without immutability, you’d need to rely on using `Interlocked`,
    the `lock` keyword, or thread-safe collections to avoid bugs.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于不可变对象不会改变，它们可以在多线程应用程序中可靠地使用。如果没有不可变性，你需要依赖使用`Interlocked`、`lock`关键字或线程安全集合来避免错误。
- en: Of course, having to specify all the properties of an object in its constructor
    can be cumbersome for classes with many properties. Additionally, not every class
    in your project needs to be immutable. For those classes that would benefit from
    immutability, C#’s required keyword and init-only properties help alleviate this
    burden.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于具有许多属性的类，必须在构造函数中指定所有属性可能会很繁琐。此外，你的项目中的每个类都不需要是不可变的。对于那些将受益于不可变性的类，C# 的必需关键字和只读属性有助于减轻这种负担。
- en: Using required and init-only properties
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用必需和只读属性
- en: The downside of adding every property as a parameter to class constructors is
    that your constructors can start to become larger than you’d like. Additionally,
    creating objects that require many constructor parameters is tedious and error-prone
    and the creation of individual objects can be tedious and confusing, particularly
    when many constructor parameters are needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个属性作为参数添加到类构造函数中的缺点是，你的构造函数可能会变得比你想要的更大。此外，创建需要许多构造函数参数的对象既繁琐又容易出错，并且创建单个对象可能会很繁琐和令人困惑，尤其是当需要许多构造函数参数时。
- en: On the other hand, object initializers can be more readable, but until recently,
    they lacked a way of ensuring properties are present.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对象初始化器可能更易读，但直到最近，它们还没有一种确保属性存在的方法。
- en: 'Look at the two ways of creating a `BoardingPass` object and see which appears
    more readable to you:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看看创建 `BoardingPass` 对象的两种方式，看看哪一种对你来说更易读：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The object initializer version used in `p2` is more readable and maintainable,
    particularly as the number of properties you might want to set in the class grows
    over time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `p2` 中使用的对象初始化器版本更易读且易于维护，尤其是随着你想要在类中设置的属性数量随着时间的推移而增长。
- en: 'The traditional downside of this approach was that a developer using the object
    initializer might forget to set important required properties. C# 11 introduced
    the `required` keyword, which will fail to compile if a required property is not
    explicitly initialized during object initialization or in the constructor when
    the `Passenger` property is omitted, as shown in *Figure 10**.2*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '这种方法的传统缺点是，使用对象初始化器的开发者可能会忘记设置重要的必需属性。C# 11 引入了 `required` 关键字，如果在对象初始化或构造函数中省略了
    `Passenger` 属性时没有显式初始化必需属性，则编译将失败，如 *图10.2* 所示。2*:'
- en: '![Figure 10.2 – A compiler error due to Passenger not being set](img/B21324_10_2.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 由于未设置Passenger属性导致的编译错误](img/B21324_10_2.jpg)'
- en: Figure 10.2 – A compiler error due to Passenger not being set
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 由于未设置Passenger属性导致的编译错误
- en: 'To achieve this, we can add `required` to any property definitions on the class
    that we want to make sure they are explicitly set by the time the object-initializer
    completes. The following version of `BoardingPass` features required properties:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以在类中添加 `required` 到任何我们想要确保在对象初始化器完成时显式设置的属性定义。以下版本的 `BoardingPass`
    特性具有必需属性：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may have also noticed that this class definition defines these properties
    as `{get; init;}` instead of `{get;}` or `{get; set;}`. While the traditional
    `get; set;` combination allows a property to be changed at any time, this violates
    immutability. The `get;` version removes the ability to set the property anywhere
    but the constructor, which means properties defined as `get;` cannot be set in
    object initializers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，这个类定义将这些属性定义为 `{get; init;}` 而不是 `{get;}` 或 `{get; set;}`。虽然传统的 `get;
    set;` 组合允许在任意时间更改属性，但这违反了不可变性。`get;` 版本移除了在除构造函数之外的地方设置属性的能力，这意味着定义为 `get;` 的属性不能在对象初始化器中设置。
- en: The newer `get; init;` combination that was added in C# 9 allows the property
    to be set in the constructor or initializer, but no longer allows setting after
    the object is initialized. This helps us support our immutable class design while
    not restricting the user to using constructors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 9 中添加的新 `get; init;` 组合允许在构造函数或初始化器中设置属性，但不再允许在对象初始化后设置。这有助于我们支持我们的不可变类设计，同时不限制用户使用构造函数。
- en: I believe that object initializers are the future of .NET and nowadays tend
    to favor required properties with `get; init;` when designing classes for immutability.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为对象初始化器是 .NET 的未来，如今在设计用于不可变性的类时，往往更倾向于使用 `get; init;` 的必需属性。
- en: 'Speaking of the future, let’s look at a brand-new feature in C# 12: primary
    constructors for reference types.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 说到未来，让我们看看 C# 12 中的一个全新的特性：引用类型的主构造函数。
- en: Primary constructors
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主构造函数
- en: '**Primary constructors** are constructors that must be called to initialize
    the class and provide a way of automatically creating fields in your class. We’ll
    talk more about what that “must be called” phrase entails in a moment, but let’s
    start by looking at a simple example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**主构造函数**是必须调用来初始化类并提供在类中自动创建字段的方法的构造函数。我们稍后会详细讨论“必须调用”这个短语的含义，但让我们先来看一个简单的例子：'
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This version of `BoardingPass` has parentheses and a parameter list immediately
    following the class declaration. This is the primary constructor for the class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`BoardingPass`在类声明后立即有括号和参数列表。这是类的首选构造函数。
- en: 'Any parameters declared in the primary constructor are available as if they
    were init-only properties. This makes a primary constructor roughly equivalent
    to the following C# code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在主构造函数中声明的任何参数都可以作为只读属性使用。这使得主构造函数大致等同于以下C#代码：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The advantage of primary constructors is that they are very concise and do not
    require you to define a constructor or field definitions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数的优势在于它们非常简洁，不需要你定义构造函数或字段定义。
- en: 'Primary constructors can work with other constructors, though any other constructor
    you declare must call the primary constructor using the `this` keyword, as shown
    here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数可以与其他构造函数一起使用，尽管你声明的任何其他构造函数都必须使用`this`关键字调用主构造函数，如下所示：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Essentially, your primary constructor must always be called – either on its
    own or from another constructor via the `this` keyword.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你的主构造函数必须始终被调用——要么单独调用，要么通过`this`关键字从另一个构造函数中调用。
- en: Primary constructors are not unique to classes and exist for records starting
    in C# 9.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数不仅限于类，从C# 9开始，也存在于记录中。
- en: Converting classes into record classes
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类转换为记录类
- en: Throughout this book, I’ve alluded to **record classes** several times without
    defining them or going into detail on why you’d want to use one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我多次提到了**记录类**，但没有定义它们，也没有详细说明为什么你想使用一个。
- en: To understand record classes, let’s talk briefly about equality in classes.
    By default, two objects are considered equal if they both live in the same memory
    address in the heap.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解记录类，让我们简要谈谈类中的相等性。默认情况下，如果两个对象都位于堆中的相同内存地址，则认为它们相等。
- en: 'This means that, by default, two separate objects with identical properties
    are not equal. For example, the following code would evaluate these two boarding
    passes as different from each other:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着默认情况下，具有相同属性的两个单独对象不相等。例如，以下代码将这两个登机牌评估为彼此不同：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can change this behavior by overriding `Equals` and `GetHashCode` on the
    `BoardingPass` class, as we did in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101).
    However, record types give us an easier way of managing this.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`BoardingPass`类上重写`Equals`和`GetHashCode`来改变这种行为，就像我们在[*第五章*](B21324_05.xhtml#_idTextAnchor101)中所做的那样。然而，记录类型为我们提供了一种更简单的方式来管理这一点。
- en: Record classes are like normal C# classes except equality works by comparing
    all properties to each other. In other words, record classes are like normal C#
    classes that have overridden `Equals` and `GetHashCode`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类类似于正常的C#类，除了相等性是通过比较所有属性来实现的。换句话说，记录类就像是重写了`Equals`和`GetHashCode`的正常C#类。
- en: 'Let’s redeclare our boarding pass as a record class:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新声明登机牌为一个记录类：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can successfully compare two boarding passes using just their values:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需使用它们的值就可以成功比较两个登机牌：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These two classes are considered equal because they carry the same values. Note
    that the `Flight` property refers to a `FlightInfo` object, which is still a standard
    C# class and uses traditional reference equality. This means that boarding passes
    must point to the same `FlightInfo` object in memory; otherwise, they will not
    be considered equal. This can be changed by making `FlightInfo` a record class
    as well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类被认为是相等的，因为它们携带相同的值。请注意，`Flight`属性引用一个`FlightInfo`对象，它仍然是一个标准的C#类，并使用传统的引用相等性。这意味着登机牌必须指向内存中的相同`FlightInfo`对象；否则，它们将不被视为相等。这可以通过将`FlightInfo`也改为记录类来改变。
- en: I recommend using record classes for small objects that you might want to compare
    to each other. They also might be helpful for classes that might be frequently
    instantiated, such as objects coming from the database or an external API call.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用记录类来比较小型对象。它们也可能对那些可能频繁实例化的类有所帮助，例如来自数据库或外部API调用的对象。
- en: 'Let’s move on to talk about my favorite new way of creating objects: `with`
    expressions.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续谈谈我最喜欢的创建对象的新方法：`with`表达式。
- en: Cloning objects using with expressions
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`with`表达式克隆对象
- en: '`with` expressions work very well with immutable records by allowing you to
    clone and slightly tweak the source record without making any modifications to
    the original record.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`表达式与不可变记录配合得非常好，它允许您在不修改原始记录的情况下克隆并稍微调整源记录。'
- en: 'Let’s say that Hamlet’s boarding pass for seat 2B on the flight needed to be
    changed. The system could instantiate a new boarding pass that was just like the
    original one except for seat 2C using the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设哈姆雷特在航班上2B座的登机牌需要更改。系统可以使用以下代码实例化一个新的登机牌，它与原始登机牌完全一样，只是座位是2C：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This creates a new boarding pass based on the original one but with one property
    slightly different.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基于原始登机牌创建一个新的登机牌，但有一个属性略有不同。
- en: 'If we wanted to move Hamlet to have a new seat but an earlier boarding group,
    we could do that as well by listing an additional property, as shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将哈姆雷特移动到新的座位但更早的登机组，我们也可以通过列出额外的属性来实现，如下所示：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I find `with` expressions to be one of the most exciting things about working
    with record classes in C# and I love the direction the language is going in to
    streamline the creation of objects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为`with`表达式是使用C#中的记录类工作时最令人兴奋的事情之一，我非常喜欢语言在简化对象创建方面的方向。
- en: This style of referring to property values is not unique to the `with` expression,
    as we’ll see in the next section with pattern matching.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种引用属性值的方式并不仅限于`with`表达式，正如我们将在下一节中通过模式匹配看到的那样。
- en: Advanced type usage
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类型使用
- en: In this final section of this chapter, we’ll see how new and old language features
    help you build better types.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将看到新旧语言特性如何帮助您构建更好的类型。
- en: Exploring pattern matching
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索模式匹配
- en: It turns out that we can use the same style of syntax we used with expressions
    earlier to conditionally match different objects through **pattern matching**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们可以使用之前在表达式中使用的相同语法风格，通过模式匹配有条件地匹配不同的对象。
- en: 'To explain what I mean, let’s start with an example that loops over different
    boarding passes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释我的意思，让我们从一个遍历不同登机牌的例子开始：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code loops over a collection of boarding passes and does one of three
    things:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遍历一组登机牌，并执行以下三种操作之一：
- en: If the flight is `Pending` and the passenger is in group 1, 2, or 3, we tell
    them to board
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果航班状态是`Pending`且乘客在1、2或3组，我们会告诉他们登机。
- en: If the flight is `Active` or `Completed`, we tell the passenger they missed
    their flight
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果航班状态是`Active`或`Completed`，我们会告诉乘客他们错过了航班。
- en: If neither of these cases is true, the flight must be `Pending`, but the passenger’s
    group is not boarding, so we tell them to wait
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两种情况都不成立，则航班状态必须是`Pending`，但乘客的组没有登机，因此我们会告诉他们等待。
- en: The code is a little arbitrary, particularly in how it deals with the boarding
    group, but it illustrates some of the capabilities of pattern matching.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有点随意，尤其是在处理登机组方面，但它展示了模式匹配的一些功能。
- en: Using pattern matching, you can evaluate one or more properties on an object
    in an `if` statement to concisely check multiple things at once.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配，您可以在`if`语句中评估对象的一个或多个属性，以简洁地同时检查多个事项。
- en: 'While you can use pattern matching in `if` statements, they are also commonly
    used in switch expressions, as we saw in [*Chapter 3*](B21324_03.xhtml#_idTextAnchor045).
    We could rewrite our code from earlier into a switch expression, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在`if`语句中使用模式匹配，但它们也常用于`switch`表达式，正如我们在[第3章](B21324_03.xhtml#_idTextAnchor045)中看到的。我们可以将之前的代码重写为`switch`表达式，如下所示：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we can see the switch expressions concept combined with the power of pattern
    matching to set a string in the `message` variable. Note that the code uses `not
    FlightStatus.Pending` instead of `FlightStatus.Active or FlightStatus.Completed`
    for brevity and to illustrate the usage of the `not` keyword in negating or inverting
    pattern matching expressions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`switch`表达式概念与模式匹配的强大功能相结合，以设置`message`变量中的字符串。请注意，为了简洁和说明`not`关键字在否定或反转模式匹配表达式中的用法，代码使用`not
    FlightStatus.Pending`而不是`FlightStatus.Active or FlightStatus.Completed`。
- en: While this code takes some adjustment to learn to read, there’s also very little
    “waste” in this syntax. Almost the entirety of every line of code is centered
    around either the conditions that must be true or the value to use when they are
    true. Additionally, this syntax can handle more complex scenarios such as or and
    not statements more easily than normal C# logic can.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码需要一些调整才能学会阅读，但在这个语法中几乎没有“浪费”。几乎每一行代码都是围绕必须为真的条件或当它们为真时要使用的值来组织的。此外，这种语法比正常的C#逻辑更容易处理更复杂的场景，例如或和不是语句。
- en: Of course, as with any new C# language feature, if the readability cost is too
    high for you and your team, you are free to avoid switch expressions and pattern
    matching entirely.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像任何新的C#语言特性一样，如果你和你团队的可读性成本太高，你可以自由地完全避免switch表达式和模式匹配。
- en: 'Now that we’ve seen how pattern matching and switch expressions work together
    in the latest versions of C#, let’s look at one of C#’s earliest enhancements:
    generics.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了模式匹配和switch表达式在C#最新版本中的协同工作方式，让我们来看看C#最早期的增强功能之一：泛型。
- en: Using generics to reduce duplication
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型来减少重复
- en: '**Generics** are a concept that every .NET developer encounters and works with
    daily.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型**是每个.NET开发者每天都会遇到并与之工作的一个概念。'
- en: When you work with `List<string>` (pronounced “list of strings”), you are working
    with a generic `List` object that can hold something of a specific type – in this
    case, strings.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与`List<string>`（发音为“字符串列表”）一起工作时，你正在使用一个泛型`List`对象，它可以持有特定类型的对象——在这种情况下，字符串。
- en: Generics work by specifying at least one type parameter that goes into either
    a class or a method and allows the class or method to be structured around that
    type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型通过指定至少一个类型参数来实现，该参数进入类或方法中，并允许类或方法围绕该类型进行结构化。
- en: 'To illustrate the advantage of generics, let’s look at a very simple `FlightDictionary`
    class that stores `FlightInfo` objects by their identifiers using a dictionary
    and incorporates some light console logging:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明泛型的优势，让我们看看一个非常简单的`FlightDictionary`类，它使用字典存储通过其标识符的`FlightInfo`对象，并包含一些简单的控制台日志记录：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This class is the beginning of a new collection class, like the `Dictionary`
    class provided by .NET. It allows external callers to add, retrieve, and check
    for `FlightInfo` by a string identifier.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是新的集合类的一个起点，就像.NET提供的`Dictionary`类一样。它允许外部调用者通过字符串标识符添加、检索和检查`FlightInfo`。
- en: 'While this code is very simple and missing several features I’d expect from
    a real collection class, it should serve to illustrate the need for generics by
    asking the following question: What happens if we like this class so much for
    `FlightInfo` objects that we want to use something like it for `BoardingPass`
    objects?'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码非常简单，并且缺少了我期望从真实集合类中看到的一些功能，但它足以说明通过提出以下问题来体现泛型的必要性：如果我们非常喜欢这个类来处理`FlightInfo`对象，那么我们是否希望用它来处理`BoardingPass`对象？
- en: 'Often, this would result in someone copying and pasting the `FlightDictionary`
    class to create a new `BoardingPassDictionary`, as shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会出现这样的情况，有人会复制粘贴`FlightDictionary`类来创建一个新的`BoardingPassDictionary`类，如下所示：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The only difference between these two classes is the type of item being stored.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类之间的唯一区别是存储的项目类型。
- en: What generics let us do is declare a class that takes in parameters of the types
    it should use for different operations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型让我们能够声明一个类，它接受用于不同操作的类型的参数。
- en: 'Now, let’s look at a more reusable version of this class that accepts generic
    type parameters for the type used as a key for each item, as well as the type
    used as a value:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个类的更可重用版本，它接受用于每个项目键的类型以及用于值的泛型类型参数：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This implementation of the class depends on two generic type arguments: `TKey`
    and `TValue`. These parameters can be whatever names you want them to be, but
    the convention is to use `T`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实现依赖于两个泛型类型参数：`TKey`和`TValue`。这些参数可以是任何你想要的名字，但惯例是使用`T`。
- en: 'With this class, a new `LoggingDictionary` can be created for any types you
    might want to support using the following syntax:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，可以创建一个新的`LoggingDictionary`，以支持你可能想要支持的任何类型，语法如下：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Generics are something that has been around since .NET Framework 2.0 but still
    offers value today in adding reusability to classes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是自.NET Framework 2.0以来就存在的东西，但今天它仍然为类添加可重用性提供了价值。
- en: 'Let’s close this chapter out with a brief look into a new C# 12 feature: **type
    aliases**.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以对C# 12的一个新功能：**类型别名**的简要概述来结束这一章。
- en: Introducing type aliases with the using directive
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 using 指令引入类型别名
- en: Let’s say you’re developing a system and you need to work with a set of data
    types you’re not certain about and may need to change in the future. Alternatively,
    you might have a routine need for some hideous-looking types, such as needing
    to deal with `List<string, Dictionary<Passenger, List<FlightInfo>>>` throughout
    a class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个系统，你需要处理一组不确定的类型，并且可能在未来需要更改这些类型。或者，你可能有一个常规需求，需要一些看起来很糟糕的类型，例如在整个类中处理
    `List<string, Dictionary<Passenger, List<FlightInfo>>>`。
- en: While one approach for the latter problem might be to introduce your class to
    hide away some of this complexity, a new option in C# 12 is to use `using` statement.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后一个问题的一个方法可能是将你的类引入以隐藏一些这种复杂性，但在 C# 12 中有一个新的选项是使用 `using` 语句。
- en: 'Let’s look at simplifying some of the code in `CloudySkiesFlightProvider.cs`
    to reduce the places where `IEnumerable<FlightInfo>` appears. We’ll use the `GetFlightsByMiles`
    method as an example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何简化 `CloudySkiesFlightProvider.cs` 中的某些代码，以减少 `IEnumerable<FlightInfo>`
    出现的地方。我们将使用 `GetFlightsByMiles` 方法作为示例：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code isn’t bad, but imagine that you felt very strongly that you didn’t
    like looking at `IEnumerable<FlightInfo>` everywhere and you’d rather have a custom
    type defined for this.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不差，但想象一下，如果你非常强烈地不喜欢在所有地方看到 `IEnumerable<FlightInfo>`，你更愿意为这个定义一个自定义类型。
- en: 'Using C# 12, you could add the following line to the `using` statements in
    the file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 12，你可以在文件的 `using` 语句中添加以下行：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With this one change, you can now change your method to use your new type alias:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一变化，你现在可以将你的方法更改为使用你的新类型别名：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code doesn’t change that you’re dealing with `IEnumerable<FlightInfo>`
    in this method, but it does reduce the amount of code you have to type and simplifies
    the code for reading.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有改变你在该方法中处理 `IEnumerable<FlightInfo>`，但它确实减少了你需要输入的代码量，并简化了读取代码。
- en: Additionally, if you ever wanted to change to a different type in these places,
    you now just need to modify the `using` statement to use a different type instead.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想要在这些地方更改到不同的类型，你现在只需要修改 `using` 语句来使用不同的类型。
- en: I’m not sure if obscuring the underlying type offers more benefit than potential
    confusion, but I could see some places where it might be helpful, particularly
    in dealing with complex generic types or working with tuples (collections of multiple
    values).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定隐藏底层类型是否比潜在的混淆更有益，但我可以想象一些可能有所帮助的地方，尤其是在处理复杂的泛型类型或与元组（多个值的集合）一起工作时。
- en: Time will tell on the effectiveness of type aliases and the best places to use
    them, but I’m glad we now have the option.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 时间将证明类型别名的效果以及它们最佳的使用位置，但我很高兴我们现在有了这个选项。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a variety of ways of ensuring your classes are
    safe and reusable through means such as argument validation, caller member information,
    nullability analysis, and using modern C# features such as record classes, primary
    constructors, pattern matching, and enhanced properties with the `required` and
    `init` keywords.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了确保你的类通过诸如参数验证、调用者成员信息、可空性分析以及使用现代 C# 功能（如记录类、主构造函数、模式匹配和带有 `required`
    和 `init` 关键字的增强属性）等手段安全且可重用的各种方法。
- en: These language features help you detect issues earlier in development, work
    with objects more effectively, and write fewer lines of code overall.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言特性帮助你更早地检测问题，更有效地处理对象，并总体上减少代码行数。
- en: This concludes *Part 2* of this book. In *Part 3*, we’ll look at how AI and
    code analysis tools can help you and your team sustainably build better software.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的 *第2部分* 结束了。在 *第3部分* 中，我们将探讨人工智能和代码分析工具如何帮助你和你团队可持续地构建更好的软件。
- en: Questions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answers the following questions to test your knowledge of this chapter:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: How can throwing exceptions be beneficial to your code?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出异常如何对你的代码有益？
- en: What are the various ways you can declare a property in C#?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用哪些不同的方式在 C# 中声明一个属性？
- en: What are the various ways you can instantiate an object in C#?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用哪些不同的方式在 C# 中实例化一个对象？
- en: What are the differences between classes and record classes?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类和记录类之间的区别是什么？
- en: Further reading
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about features discussed in this chapter at these
    URLs:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 URL 中找到有关本章讨论的功能的更多信息：
- en: '*Guard Clauses* *library*: [https://github.com/ardalis/GuardClauses](https://github.com/ardalis/GuardClauses)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*守卫子句* 库：[https://github.com/ardalis/GuardClauses](https://github.com/ardalis/GuardClauses)'
- en: '*Fluent Validation* *library*: [https://github.com/FluentValidation/FluentValidation](https://github.com/FluentValidation/FluentValidation)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fluent Validation* *库*: [https://github.com/FluentValidation/FluentValidation](https://github.com/FluentValidation/FluentValidation)'
- en: '*Caller Member* *Information*: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用成员* *信息*: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information)'
- en: '*Primary constructors and using* *aliases*: [https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/](https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主构造函数和别名使用*: [https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/](https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/)'
- en: '*Safer Nullability in Modern* *C#*: [https://newdevsguide.com/2023/02/25/csharp-nullability/](https://newdevsguide.com/2023/02/25/csharp-nullability/)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现代* *C#中的安全空值*: [https://newdevsguide.com/2023/02/25/csharp-nullability/](https://newdevsguide.com/2023/02/25/csharp-nullability/)'
- en: '*Classes, structs, and records in* *C#*: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的类、结构和记录*: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/)'
- en: '*Choosing Between Exceptions or* *Validation:* [https://ardalis.com/guard-clauses-and-exceptions-or-validation/](https://ardalis.com/guard-clauses-and-exceptions-or-validation/)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择异常或* *验证*: [https://ardalis.com/guard-clauses-and-exceptions-or-validation/](https://ardalis.com/guard-clauses-and-exceptions-or-validation/)'
- en: 'Part 3: Advanced Refactoring with AI and Code Analysis'
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：使用AI和代码分析的高级重构
- en: The third part of this book focuses on advanced refactoring techniques using
    artificial intelligence and modern code analysis capabilities built into Visual
    Studio.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第三部分专注于使用人工智能和Visual Studio内置的现代代码分析功能的高级重构技术。
- en: This chapter introduces GitHub Copilot Chat as a way to refactor, generate,
    inspect, document, and test code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了GitHub Copilot Chat作为重构、生成、检查、文档化和测试代码的方法。
- en: We then extensively cover the code analysis capabilities of Visual Studio by
    introducing the code analysis tooling and rulesets as well as some third-party
    tools that can help catch additional issues. Finally, we explore how Visual Studio’s
    code analysis is based on Roslyn Analyzers by building and deploying our own Roslyn
    Analyzer as both a Visual Studio extension and as a NuGet package.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着通过介绍代码分析工具和规则集以及一些可以帮助捕获额外问题的第三方工具，广泛地覆盖了Visual Studio的代码分析功能。最后，我们探讨了Visual
    Studio的代码分析如何基于Roslyn分析器，通过构建和部署我们自己的Roslyn分析器作为Visual Studio扩展和NuGet包来展开。
- en: This chapter will give you a deep understanding of code analysis issues as well
    as new productivity tools to help detect and resolve issues in their code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入理解代码分析问题，以及新的生产力工具，帮助检测和解决代码中的问题。
- en: 'This part contains the following chapters:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B21324_11.xhtml#_idTextAnchor236)*, AI-Assisted Refactoring
    with GitHub Copilot*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21324_11.xhtml#_idTextAnchor236)*，使用GitHub Copilot进行AI辅助重构*'
- en: '[*Chapter 12*](B21324_12.xhtml#_idTextAnchor259)*, Code Analysis in Visual
    Studio*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21324_12.xhtml#_idTextAnchor259)*，Visual Studio中的代码分析*'
- en: '[*Chapter 13*](B21324_13.xhtml#_idTextAnchor275)*, Creating a Roslyn Analyzer*'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21324_13.xhtml#_idTextAnchor275)*，创建Roslyn分析器*'
- en: '[*Chapter 14*](B21324_14.xhtml#_idTextAnchor297)*, Refactoring Code with Roslyn
    Analyzers*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21324_14.xhtml#_idTextAnchor297)*，使用Roslyn分析器重构代码*'
