<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>12 Behavioral Patterns</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>
<section class="level1 pkt" data-number="13" id="behavioral-patterns">
<h1 data-number="13"><span class="koboSpan" id="kobo.1.1" xmlns="http://www.w3.org/1999/xhtml">12 Behavioral Patterns</span></h1>
<section class="level2" data-number="13.1" id="before-you-begin-join-our-book-community-on-discord-11">
<h2 data-number="13.1"><span class="koboSpan" id="kobo.2.1" xmlns="http://www.w3.org/1999/xhtml">Before you begin: Join our book community on Discord</span></h2>
<p><span class="koboSpan" id="kobo.3.1" xmlns="http://www.w3.org/1999/xhtml">Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</span></p>
<p><a href="https://packt.link/EarlyAccess"><span class="koboSpan" id="kobo.4.1" xmlns="http://www.w3.org/1999/xhtml">https://packt.link/EarlyAccess</span></a></p>
<p><span class="koboSpan" id="kobo.5.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Qr code Description automatically generated" src="../media/file67.png" style="width:10em"/></span></p>
<p><span class="koboSpan" id="kobo.6.1" xmlns="http://www.w3.org/1999/xhtml">This chapter explores two new design patterns from the well-known </span><strong><span class="koboSpan" id="kobo.7.1" xmlns="http://www.w3.org/1999/xhtml">Gang of Four</span></strong><span class="koboSpan" id="kobo.8.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.9.1" xmlns="http://www.w3.org/1999/xhtml">GoF</span></strong><span class="koboSpan" id="kobo.10.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.10.2" xmlns="http://www.w3.org/1999/xhtml">They are behavioral patterns, meaning they help simplify system behavior management.Often, we need to encapsulate some core algorithm while allowing other pieces of code to extend that implementation. </span><span class="koboSpan" id="kobo.10.3" xmlns="http://www.w3.org/1999/xhtml">That is where the </span><strong><span class="koboSpan" id="kobo.11.1" xmlns="http://www.w3.org/1999/xhtml">Template Method</span></strong><span class="koboSpan" id="kobo.12.1" xmlns="http://www.w3.org/1999/xhtml"> pattern comes into play.Other times, we have a complex process with multiple algorithms that all apply to one or more situations, and we need to organize it in a testable and extensible fashion. </span><span class="koboSpan" id="kobo.12.2" xmlns="http://www.w3.org/1999/xhtml">This is where the </span><strong><span class="koboSpan" id="kobo.13.1" xmlns="http://www.w3.org/1999/xhtml">Chain of Responsibility</span></strong><span class="koboSpan" id="kobo.14.1" xmlns="http://www.w3.org/1999/xhtml"> pattern can help. </span><span class="koboSpan" id="kobo.14.2" xmlns="http://www.w3.org/1999/xhtml">For example, the ASP.NET Core middleware pipeline is a Chain of Responsibility where all the middleware inspects and acts on the request.In this chapter, we cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1" xmlns="http://www.w3.org/1999/xhtml">Implementing the Template Method pattern</span></li>
<li><span class="koboSpan" id="kobo.16.1" xmlns="http://www.w3.org/1999/xhtml">Implementing the Chain of Responsibility pattern</span></li>
<li><span class="koboSpan" id="kobo.17.1" xmlns="http://www.w3.org/1999/xhtml">Mixing the Template Method and Chain of Responsibility patterns</span></li>
</ul>
</section>
<section class="level2" data-number="13.2" id="implementing-the-template-method-pattern">
<h2 data-number="13.2"><span class="koboSpan" id="kobo.18.1" xmlns="http://www.w3.org/1999/xhtml">Implementing the Template Method pattern</span></h2>
<p><span class="koboSpan" id="kobo.19.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.20.1" xmlns="http://www.w3.org/1999/xhtml">Template Method</span></strong><span class="koboSpan" id="kobo.21.1" xmlns="http://www.w3.org/1999/xhtml"> is a GoF behavioral pattern that uses inheritance to share code between the base class and its subclasses. </span><span class="koboSpan" id="kobo.21.2" xmlns="http://www.w3.org/1999/xhtml">It is a very powerful yet simple design pattern.</span></p>
<section class="level3" data-number="13.2.1" id="goal-11">
<h3 data-number="13.2.1"><span class="koboSpan" id="kobo.22.1" xmlns="http://www.w3.org/1999/xhtml">Goal</span></h3>
<p><span class="koboSpan" id="kobo.23.1" xmlns="http://www.w3.org/1999/xhtml">The goal of the Template Method pattern is to encapsulate the outline of an algorithm in a base class while leaving some parts of that algorithm open for modification by the subclasses, which adds flexibility at a low cost.</span></p>
</section>
<section class="level3" data-number="13.2.2" id="design-11">
<h3 data-number="13.2.2"><span class="koboSpan" id="kobo.24.1" xmlns="http://www.w3.org/1999/xhtml">Design</span></h3>
<p><span class="koboSpan" id="kobo.25.1" xmlns="http://www.w3.org/1999/xhtml">First, we need to define a base class that contains the </span><code><span class="koboSpan" id="kobo.26.1" xmlns="http://www.w3.org/1999/xhtml">TemplateMethod</span></code><span class="koboSpan" id="kobo.27.1" xmlns="http://www.w3.org/1999/xhtml"> method and then define one or more sub-operations that need to be implemented by its subclasses (</span><code><span class="koboSpan" id="kobo.28.1" xmlns="http://www.w3.org/1999/xhtml">abstract</span></code><span class="koboSpan" id="kobo.29.1" xmlns="http://www.w3.org/1999/xhtml">) or that can be overridden (</span><code><span class="koboSpan" id="kobo.30.1" xmlns="http://www.w3.org/1999/xhtml">virtual</span></code><span class="koboSpan" id="kobo.31.1" xmlns="http://www.w3.org/1999/xhtml">).Using UML, it looks like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.32.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 12.1: Class diagram representing the Template Method pattern" src="../media/file68.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.33.1" xmlns="http://www.w3.org/1999/xhtml">Figure 12.1: Class diagram representing the Template Method pattern</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.34.1" xmlns="http://www.w3.org/1999/xhtml">How does this work?</span></p>
<ul>
<li><code><span class="koboSpan" id="kobo.35.1" xmlns="http://www.w3.org/1999/xhtml">AbstractClass</span></code><span class="koboSpan" id="kobo.36.1" xmlns="http://www.w3.org/1999/xhtml"> implements the shared code: the algorithm in its </span><code><span class="koboSpan" id="kobo.37.1" xmlns="http://www.w3.org/1999/xhtml">TemplateMethod</span></code><span class="koboSpan" id="kobo.38.1" xmlns="http://www.w3.org/1999/xhtml"> method.</span></li>
<li><code><span class="koboSpan" id="kobo.39.1" xmlns="http://www.w3.org/1999/xhtml">ConcreteClass</span></code><span class="koboSpan" id="kobo.40.1" xmlns="http://www.w3.org/1999/xhtml"> implements its specific part of the algorithm in its inherited </span><code><span class="koboSpan" id="kobo.41.1" xmlns="http://www.w3.org/1999/xhtml">Operation</span></code><span class="koboSpan" id="kobo.42.1" xmlns="http://www.w3.org/1999/xhtml"> method.</span></li>
<li><code><span class="koboSpan" id="kobo.43.1" xmlns="http://www.w3.org/1999/xhtml">Client</span></code><span class="koboSpan" id="kobo.44.1" xmlns="http://www.w3.org/1999/xhtml"> calls </span><code><span class="koboSpan" id="kobo.45.1" xmlns="http://www.w3.org/1999/xhtml">TemplateMethod()</span></code><span class="koboSpan" id="kobo.46.1" xmlns="http://www.w3.org/1999/xhtml">, which calls the subclass implementation of one or more specific algorithm elements (the </span><code><span class="koboSpan" id="kobo.47.1" xmlns="http://www.w3.org/1999/xhtml">Operation</span></code><span class="koboSpan" id="kobo.48.1" xmlns="http://www.w3.org/1999/xhtml"> method in this case).</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.49.1" xmlns="http://www.w3.org/1999/xhtml">We could also extract an interface from </span><code><span class="koboSpan" id="kobo.50.1" xmlns="http://www.w3.org/1999/xhtml">AbstractClass</span></code><span class="koboSpan" id="kobo.51.1" xmlns="http://www.w3.org/1999/xhtml"> to allow even more flexibility, but that’s beyond the scope of the Template Method pattern.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.52.1" xmlns="http://www.w3.org/1999/xhtml">Let’s now get into some code to see the Template Method pattern in action.</span></p>
</section>
<section class="level3" data-number="13.2.3" id="project-building-a-search-machine">
<h3 data-number="13.2.3"><span class="koboSpan" id="kobo.53.1" xmlns="http://www.w3.org/1999/xhtml">Project – Building a search machine</span></h3>
<p><span class="koboSpan" id="kobo.54.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start with a simple, classic example to demonstrate how the Template Method pattern works.</span><strong><span class="koboSpan" id="kobo.55.1" xmlns="http://www.w3.org/1999/xhtml">Context</span></strong><span class="koboSpan" id="kobo.56.1" xmlns="http://www.w3.org/1999/xhtml">: Depending on the collection, we want to use a different search algorithm. </span><span class="koboSpan" id="kobo.56.2" xmlns="http://www.w3.org/1999/xhtml">We want to use a </span><em><span class="koboSpan" id="kobo.57.1" xmlns="http://www.w3.org/1999/xhtml">binary search</span></em><span class="koboSpan" id="kobo.58.1" xmlns="http://www.w3.org/1999/xhtml"> for sorted collections, but we want to use a </span><em><span class="koboSpan" id="kobo.59.1" xmlns="http://www.w3.org/1999/xhtml">linear search</span></em><span class="koboSpan" id="kobo.60.1" xmlns="http://www.w3.org/1999/xhtml"> for unsorted collections.Let’s start with the consumer, a REST endpoint in the </span><code><span class="koboSpan" id="kobo.61.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.62.1" xmlns="http://www.w3.org/1999/xhtml"> file that returns </span><code><span class="koboSpan" id="kobo.63.1" xmlns="http://www.w3.org/1999/xhtml">plain/text</span></code><span class="koboSpan" id="kobo.64.1" xmlns="http://www.w3.org/1999/xhtml"> results:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.65.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddSingleton&lt;SearchMachine&gt;(x
        =&gt; new LinearSearchMachine(1, 10, 5, 2, 123, 333, 4))
    .AddSingleton&lt;SearchMachine&gt;(x
        =&gt; new BinarySearchMachine(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
;
var app = builder.Build();
app.MapGet("/", (IEnumerable&lt;SearchMachine&gt; searchMachines) =&gt;
{
    var sb = new StringBuilder();
    var elementsToFind = new int[] { 1, 10, 11 };
    foreach (var searchMachine in searchMachines)
    {
        var typeName = searchMachine.GetType().Name;
        var heading = $"Current search machine is {typeName}";
        sb.AppendLine("".PadRight(heading.Length, '='));
        sb.AppendLine(heading);
        foreach (var value in elementsToFind)
        {
            var index = searchMachine.IndexOf(value);
            var wasFound = index.HasValue;
            if (wasFound)
            {
                sb.AppendLine($"The element '{value}' was found at index {index!.Value}.");
            }
            else
            {
                sb.AppendLine($"The element '{value}' was not found.");
            }
        }
    }
    return sb.ToString();
});
app.Run(); </span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.66.1" xmlns="http://www.w3.org/1999/xhtml">As highlighted in the first few lines, we configure </span><code><span class="koboSpan" id="kobo.67.1" xmlns="http://www.w3.org/1999/xhtml">LinearSearchMachine</span></code><span class="koboSpan" id="kobo.68.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.69.1" xmlns="http://www.w3.org/1999/xhtml">BinarySearchMachine</span></code><span class="koboSpan" id="kobo.70.1" xmlns="http://www.w3.org/1999/xhtml"> as two </span><code><span class="koboSpan" id="kobo.71.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.72.1" xmlns="http://www.w3.org/1999/xhtml"> implementations. </span><span class="koboSpan" id="kobo.72.2" xmlns="http://www.w3.org/1999/xhtml">We initialize each instance using a different sequence of numbers.Afterward, we inject all registered </span><code><span class="koboSpan" id="kobo.73.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.74.1" xmlns="http://www.w3.org/1999/xhtml"> services into the endpoint (highlighted in the code block). </span><span class="koboSpan" id="kobo.74.2" xmlns="http://www.w3.org/1999/xhtml">That handler iterates all </span><code><span class="koboSpan" id="kobo.75.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.76.1" xmlns="http://www.w3.org/1999/xhtml"> instances and tries to find all elements of the </span><code><span class="koboSpan" id="kobo.77.1" xmlns="http://www.w3.org/1999/xhtml">elementsToFind</span></code><span class="koboSpan" id="kobo.78.1" xmlns="http://www.w3.org/1999/xhtml"> array before outputting the </span><code><span class="koboSpan" id="kobo.79.1" xmlns="http://www.w3.org/1999/xhtml">text/plain</span></code><span class="koboSpan" id="kobo.80.1" xmlns="http://www.w3.org/1999/xhtml"> results.Next, let’s explore the </span><code><span class="koboSpan" id="kobo.81.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.82.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.83.1" xmlns="http://www.w3.org/1999/xhtml">namespace TemplateMethod;
public abstract class SearchMachine
{
    protected int[] Values { get; }
    protected SearchMachine(params int[] values)
    {
        Values = values ?? </span><span class="koboSpan" id="kobo.83.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(values));
    }
    public int? </span><span class="koboSpan" id="kobo.83.3" xmlns="http://www.w3.org/1999/xhtml">IndexOf(int value)
    {
        if (Values.Length == 0) { return null; }
        var result = Find(value);
        return result;
    }
    protected abstract int? </span><span class="koboSpan" id="kobo.83.4" xmlns="http://www.w3.org/1999/xhtml">Find(int value);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.84.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.85.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.86.1" xmlns="http://www.w3.org/1999/xhtml"> class represents </span><code><span class="koboSpan" id="kobo.87.1" xmlns="http://www.w3.org/1999/xhtml">AbstractClass</span></code><span class="koboSpan" id="kobo.88.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.88.2" xmlns="http://www.w3.org/1999/xhtml">It exposes the </span><code><span class="koboSpan" id="kobo.89.1" xmlns="http://www.w3.org/1999/xhtml">IndexOf</span></code><span class="koboSpan" id="kobo.90.1" xmlns="http://www.w3.org/1999/xhtml"> template method, which uses the required hook represented by the </span><code><span class="koboSpan" id="kobo.91.1" xmlns="http://www.w3.org/1999/xhtml">abstract</span></code> <code><span class="koboSpan" id="kobo.92.1" xmlns="http://www.w3.org/1999/xhtml">Find</span></code><span class="koboSpan" id="kobo.93.1" xmlns="http://www.w3.org/1999/xhtml"> method (see highlighted code). </span><span class="koboSpan" id="kobo.93.2" xmlns="http://www.w3.org/1999/xhtml">The hook is required because each subclass must implement that method, thereby making that method a required extension point (or hook).Next, we explore our first implementation of </span><code><span class="koboSpan" id="kobo.94.1" xmlns="http://www.w3.org/1999/xhtml">ConcreteClass</span></code><span class="koboSpan" id="kobo.95.1" xmlns="http://www.w3.org/1999/xhtml">, the </span><code><span class="koboSpan" id="kobo.96.1" xmlns="http://www.w3.org/1999/xhtml">LinearSearchMachine</span></code><span class="koboSpan" id="kobo.97.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.98.1" xmlns="http://www.w3.org/1999/xhtml">namespace TemplateMethod;
public class LinearSearchMachine : SearchMachine
{
    public LinearSearchMachine(params int[] values)
        : base(values) { }
    protected override int? </span><span class="koboSpan" id="kobo.98.2" xmlns="http://www.w3.org/1999/xhtml">Find(int value)
    {
        for (var i = 0; i &lt; Values.Length; i++)
        {
            if (Values[i] == value) { return i; }
        }
        return null;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.99.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.100.1" xmlns="http://www.w3.org/1999/xhtml">LinearSearchMachine</span></code><span class="koboSpan" id="kobo.101.1" xmlns="http://www.w3.org/1999/xhtml"> class is a </span><code><span class="koboSpan" id="kobo.102.1" xmlns="http://www.w3.org/1999/xhtml">ConcreteClass</span></code><span class="koboSpan" id="kobo.103.1" xmlns="http://www.w3.org/1999/xhtml"> representing the linear search implementation used by </span><code><span class="koboSpan" id="kobo.104.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.105.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.105.2" xmlns="http://www.w3.org/1999/xhtml">It contributes a part of the </span><code><span class="koboSpan" id="kobo.106.1" xmlns="http://www.w3.org/1999/xhtml">IndexOf</span></code><span class="koboSpan" id="kobo.107.1" xmlns="http://www.w3.org/1999/xhtml"> algorithm through its </span><code><span class="koboSpan" id="kobo.108.1" xmlns="http://www.w3.org/1999/xhtml">Find</span></code><span class="koboSpan" id="kobo.109.1" xmlns="http://www.w3.org/1999/xhtml"> method.Finally, we move on to the </span><code><span class="koboSpan" id="kobo.110.1" xmlns="http://www.w3.org/1999/xhtml">BinarySearchMachine</span></code><span class="koboSpan" id="kobo.111.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.112.1" xmlns="http://www.w3.org/1999/xhtml">namespace TemplateMethod;
public class BinarySearchMachine : SearchMachine
{
    public BinarySearchMachine(params int[] values)
        : base(values.OrderBy(v =&gt; v).ToArray()) { }
    protected override int? </span><span class="koboSpan" id="kobo.112.2" xmlns="http://www.w3.org/1999/xhtml">Find(int value)
    {
        var index = Array.BinarySearch(Values, value);
        return index &lt; 0 ? </span><span class="koboSpan" id="kobo.112.3" xmlns="http://www.w3.org/1999/xhtml">null : index;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.113.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.114.1" xmlns="http://www.w3.org/1999/xhtml">BinarySearchMachine</span></code><span class="koboSpan" id="kobo.115.1" xmlns="http://www.w3.org/1999/xhtml"> class is a </span><code><span class="koboSpan" id="kobo.116.1" xmlns="http://www.w3.org/1999/xhtml">ConcreteClass</span></code><span class="koboSpan" id="kobo.117.1" xmlns="http://www.w3.org/1999/xhtml"> representing the binary search implementation of </span><code><span class="koboSpan" id="kobo.118.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.119.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.119.2" xmlns="http://www.w3.org/1999/xhtml">As you may have noticed, we skipped the binary search algorithm’s implementation by delegating it to the built-in </span><code><span class="koboSpan" id="kobo.120.1" xmlns="http://www.w3.org/1999/xhtml">Array.BinarySearch</span></code><span class="koboSpan" id="kobo.121.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.121.2" xmlns="http://www.w3.org/1999/xhtml">Thanks to the .NET team!</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.122.1" xmlns="http://www.w3.org/1999/xhtml">The binary search algorithm requires an ordered collection to work; hence the sorting done in the constructor when passing the values to the base class (</span><code><span class="koboSpan" id="kobo.123.1" xmlns="http://www.w3.org/1999/xhtml">OrderBy</span></code><span class="koboSpan" id="kobo.124.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.124.2" xmlns="http://www.w3.org/1999/xhtml">That may not be the most performant way of ensuring the array is sorted (precondition/guard), but it is a very fast to write and readable way to write it. </span><span class="koboSpan" id="kobo.124.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, in our case, performance is not an issue.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.125.1" xmlns="http://www.w3.org/1999/xhtml">If you must optimize such an algorithm to work with a large data set, you can leverage parallelism (multithreading) to help out. </span><span class="koboSpan" id="kobo.125.2" xmlns="http://www.w3.org/1999/xhtml">In any case, run a proper benchmark to ensure you optimize the right thing and assess your real gains. </span><span class="koboSpan" id="kobo.125.3" xmlns="http://www.w3.org/1999/xhtml">Look at BenchmarkDotNet (</span><a href="https://adpg.link/C5E9"><span class="koboSpan" id="kobo.126.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/C5E9</span></a><span class="koboSpan" id="kobo.127.1" xmlns="http://www.w3.org/1999/xhtml">) if you are looking at benchmarking .NET code.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.128.1" xmlns="http://www.w3.org/1999/xhtml">Now that we have defined the actors and explored the code, let’s see what is happening in our consumer (the </span><code><span class="koboSpan" id="kobo.129.1" xmlns="http://www.w3.org/1999/xhtml">Client</span></code><span class="koboSpan" id="kobo.130.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<ol>
<li><span class="koboSpan" id="kobo.131.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.132.1" xmlns="http://www.w3.org/1999/xhtml">Client</span></code><span class="koboSpan" id="kobo.133.1" xmlns="http://www.w3.org/1999/xhtml"> uses the registered </span><code><span class="koboSpan" id="kobo.134.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.135.1" xmlns="http://www.w3.org/1999/xhtml"> instances and searches for values 1, 10, and 11.</span></li>
<li><span class="koboSpan" id="kobo.136.1" xmlns="http://www.w3.org/1999/xhtml">Afterward, </span><code><span class="koboSpan" id="kobo.137.1" xmlns="http://www.w3.org/1999/xhtml">Client</span></code><span class="koboSpan" id="kobo.138.1" xmlns="http://www.w3.org/1999/xhtml"> displays to the user whether the numbers were found or not.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.139.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.140.1" xmlns="http://www.w3.org/1999/xhtml">Find</span></code><span class="koboSpan" id="kobo.141.1" xmlns="http://www.w3.org/1999/xhtml"> method returns </span><code><span class="koboSpan" id="kobo.142.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.143.1" xmlns="http://www.w3.org/1999/xhtml"> when it does not find a value and, by extension, the </span><code><span class="koboSpan" id="kobo.144.1" xmlns="http://www.w3.org/1999/xhtml">IndexOf</span></code><span class="koboSpan" id="kobo.145.1" xmlns="http://www.w3.org/1999/xhtml"> method.By running the program, we get the following output:</span></p>
<div class="C0-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.146.1" xmlns="http://www.w3.org/1999/xhtml">=============================================
Current search machine is LinearSearchMachine
The element '1' was found at index 0.
</span><span class="koboSpan" id="kobo.146.2" xmlns="http://www.w3.org/1999/xhtml">The element '10' was found at index 1.
</span><span class="koboSpan" id="kobo.146.3" xmlns="http://www.w3.org/1999/xhtml">The element '11' was not found.
</span><span class="koboSpan" id="kobo.146.4" xmlns="http://www.w3.org/1999/xhtml">=============================================
Current search machine is BinarySearchMachine
The element '1' was found at index 0.
</span><span class="koboSpan" id="kobo.146.5" xmlns="http://www.w3.org/1999/xhtml">The element '10' was found at index 9.
</span><span class="koboSpan" id="kobo.146.6" xmlns="http://www.w3.org/1999/xhtml">The element '11' was not found.</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.147.1" xmlns="http://www.w3.org/1999/xhtml">The preceding output shows the two algorithms at play. </span><span class="koboSpan" id="kobo.147.2" xmlns="http://www.w3.org/1999/xhtml">Both </span><code><span class="koboSpan" id="kobo.148.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.149.1" xmlns="http://www.w3.org/1999/xhtml"> implementations did not contain the value </span><code><span class="koboSpan" id="kobo.150.1" xmlns="http://www.w3.org/1999/xhtml">11</span></code><span class="koboSpan" id="kobo.151.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.151.2" xmlns="http://www.w3.org/1999/xhtml">They both contained the values </span><code><span class="koboSpan" id="kobo.152.1" xmlns="http://www.w3.org/1999/xhtml">1</span></code><span class="koboSpan" id="kobo.153.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.154.1" xmlns="http://www.w3.org/1999/xhtml">10</span></code><span class="koboSpan" id="kobo.155.1" xmlns="http://www.w3.org/1999/xhtml"> placed at different positions. </span><span class="koboSpan" id="kobo.155.2" xmlns="http://www.w3.org/1999/xhtml">Here is a reminder of the values:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.156.1" xmlns="http://www.w3.org/1999/xhtml">new LinearSearchMachine(1, 10, 5, 2, 123, 333, 4)
new BinarySearchMachine(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.157.1" xmlns="http://www.w3.org/1999/xhtml">The consumer was iterating the </span><code><span class="koboSpan" id="kobo.158.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.159.1" xmlns="http://www.w3.org/1999/xhtml"> registered with the IoC container. </span><span class="koboSpan" id="kobo.159.2" xmlns="http://www.w3.org/1999/xhtml">The base class implements the </span><code><span class="koboSpan" id="kobo.160.1" xmlns="http://www.w3.org/1999/xhtml">IndexOf</span></code><span class="koboSpan" id="kobo.161.1" xmlns="http://www.w3.org/1999/xhtml"> but delegates the search (</span><code><span class="koboSpan" id="kobo.162.1" xmlns="http://www.w3.org/1999/xhtml">Find</span></code><span class="koboSpan" id="kobo.163.1" xmlns="http://www.w3.org/1999/xhtml">) algorithm to the subclasses. </span><span class="koboSpan" id="kobo.163.2" xmlns="http://www.w3.org/1999/xhtml">The preceding output shows that each </span><code><span class="koboSpan" id="kobo.164.1" xmlns="http://www.w3.org/1999/xhtml">SearchMachine</span></code><span class="koboSpan" id="kobo.165.1" xmlns="http://www.w3.org/1999/xhtml"> could execute the expected task by implementing only the </span><code><span class="koboSpan" id="kobo.166.1" xmlns="http://www.w3.org/1999/xhtml">Find</span></code><span class="koboSpan" id="kobo.167.1" xmlns="http://www.w3.org/1999/xhtml"> piece of the algorithm.And voilà! </span><span class="koboSpan" id="kobo.167.2" xmlns="http://www.w3.org/1999/xhtml">We have covered the Template Method pattern, as easy as that. </span><span class="koboSpan" id="kobo.167.3" xmlns="http://www.w3.org/1999/xhtml">Of course, our algorithm was trivial, but the concept remains.To ensure the correctness of the implementation, I also created two tests, one per class. </span><span class="koboSpan" id="kobo.167.4" xmlns="http://www.w3.org/1999/xhtml">Here’s a test for the </span><code><span class="koboSpan" id="kobo.168.1" xmlns="http://www.w3.org/1999/xhtml">LinearSearchMachine</span></code><span class="koboSpan" id="kobo.169.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.170.1" xmlns="http://www.w3.org/1999/xhtml">namespace TemplateMethod;
public class LinearSearchMachineTest
{
    public class IndexOf
    {
        [Theory]
        [InlineData(1, 0)]
        [InlineData(2, 4)]
        [InlineData(3, 2)]
        [InlineData(7, null)]
        public void Should_return_the_expected_result(
            int value, int? </span><span class="koboSpan" id="kobo.170.2" xmlns="http://www.w3.org/1999/xhtml">expectedIndex)
        {
            // Arrange
            var sorter = new LinearSearchMachine(1, 5, 3, 4, 2);
            // Act
            var index = sorter.IndexOf(value);
            // Assert
            Assert.Equal(expectedIndex, index);
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.171.1" xmlns="http://www.w3.org/1999/xhtml">The preceding test ensures that the correct values are found or not by the </span><code><span class="koboSpan" id="kobo.172.1" xmlns="http://www.w3.org/1999/xhtml">IndexOf</span></code><span class="koboSpan" id="kobo.173.1" xmlns="http://www.w3.org/1999/xhtml"> method of the </span><code><span class="koboSpan" id="kobo.174.1" xmlns="http://www.w3.org/1999/xhtml">LinearSearchMachine</span></code><span class="koboSpan" id="kobo.175.1" xmlns="http://www.w3.org/1999/xhtml"> class.Next is a similar test for the </span><code><span class="koboSpan" id="kobo.176.1" xmlns="http://www.w3.org/1999/xhtml">BinarySearchMachine</span></code><span class="koboSpan" id="kobo.177.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.178.1" xmlns="http://www.w3.org/1999/xhtml">namespace TemplateMethod;
public class BinarySearchMachineTest
{
    public class IndexOf
    {
        [Theory]
        [InlineData(1, 0)]
        [InlineData(8, 5)]
        [InlineData(3, 2)]
        [InlineData(7, null)]
        public void Should_return_the_expected_result(int value, int? </span><span class="koboSpan" id="kobo.178.2" xmlns="http://www.w3.org/1999/xhtml">expectedIndex)
        {
            // Arrange
            var sorter = new BinarySearchMachine(1, 2, 3, 4, 5, 8);
            // Act
            var index = sorter.IndexOf(value);
            // Assert
            Assert.Equal(expectedIndex, index);
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.179.1" xmlns="http://www.w3.org/1999/xhtml">The preceding test does a similar job of ensuring that the correct values are found or not by the </span><code><span class="koboSpan" id="kobo.180.1" xmlns="http://www.w3.org/1999/xhtml">IndexOf</span></code><span class="koboSpan" id="kobo.181.1" xmlns="http://www.w3.org/1999/xhtml"> method of the </span><code><span class="koboSpan" id="kobo.182.1" xmlns="http://www.w3.org/1999/xhtml">BinarySearchMachine</span></code><span class="koboSpan" id="kobo.183.1" xmlns="http://www.w3.org/1999/xhtml"> class.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.184.1" xmlns="http://www.w3.org/1999/xhtml">We can add </span><code><span class="koboSpan" id="kobo.185.1" xmlns="http://www.w3.org/1999/xhtml">virtual</span></code><span class="koboSpan" id="kobo.186.1" xmlns="http://www.w3.org/1999/xhtml"> methods in the base class to create optional hooks. </span><span class="koboSpan" id="kobo.186.2" xmlns="http://www.w3.org/1999/xhtml">Those methods would become optional extension points that subclasses can implement or not. </span><span class="koboSpan" id="kobo.186.3" xmlns="http://www.w3.org/1999/xhtml">That would allow a more complex and more versatile scenario to be supported. </span><span class="koboSpan" id="kobo.186.4" xmlns="http://www.w3.org/1999/xhtml">We will not cover this here because it is not part of the pattern itself, even if very similar. </span><span class="koboSpan" id="kobo.186.5" xmlns="http://www.w3.org/1999/xhtml">There are many examples in the .NET </span><strong><span class="koboSpan" id="kobo.187.1" xmlns="http://www.w3.org/1999/xhtml">base class library</span></strong><span class="koboSpan" id="kobo.188.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.189.1" xmlns="http://www.w3.org/1999/xhtml">BCL</span></strong><span class="koboSpan" id="kobo.190.1" xmlns="http://www.w3.org/1999/xhtml">), like most methods of the </span><code><span class="koboSpan" id="kobo.191.1" xmlns="http://www.w3.org/1999/xhtml">ComponentBase</span></code><span class="koboSpan" id="kobo.192.1" xmlns="http://www.w3.org/1999/xhtml"> class (in the </span><code><span class="koboSpan" id="kobo.193.1" xmlns="http://www.w3.org/1999/xhtml">Microsoft.AspNetCore.Components</span></code><span class="koboSpan" id="kobo.194.1" xmlns="http://www.w3.org/1999/xhtml"> namespace). </span><span class="koboSpan" id="kobo.194.2" xmlns="http://www.w3.org/1999/xhtml">For example, when overriding the </span><code><span class="koboSpan" id="kobo.195.1" xmlns="http://www.w3.org/1999/xhtml">OnInitialized</span></code><span class="koboSpan" id="kobo.196.1" xmlns="http://www.w3.org/1999/xhtml"> method in a Blazor component, we leverage an optional extension hook. </span><span class="koboSpan" id="kobo.196.2" xmlns="http://www.w3.org/1999/xhtml">The base method does nothing and is there only for extensibility purposes, allowing us to run code as part of the component’s lifecycle. </span><span class="koboSpan" id="kobo.196.3" xmlns="http://www.w3.org/1999/xhtml">You can consult the </span><code><span class="koboSpan" id="kobo.197.1" xmlns="http://www.w3.org/1999/xhtml">ComponentBase</span></code><span class="koboSpan" id="kobo.198.1" xmlns="http://www.w3.org/1999/xhtml"> class code in the official .NET repo on GitHub: </span><a href="https://adpg.link/1WYq"><span class="koboSpan" id="kobo.199.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/1WYq</span></a><span class="koboSpan" id="kobo.200.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.201.1" xmlns="http://www.w3.org/1999/xhtml">This concludes our study of another simple yet powerful design pattern.</span></p>
</section>
<section class="level3" data-number="13.2.4" id="conclusion-19">
<h3 data-number="13.2.4"><span class="koboSpan" id="kobo.202.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.203.1" xmlns="http://www.w3.org/1999/xhtml">The Template Method is a powerful and easy-to-implement design pattern allowing subclasses to reuse the algorithm’s skeleton while implementing (abstract) or overriding (virtual) subparts. </span><span class="koboSpan" id="kobo.203.2" xmlns="http://www.w3.org/1999/xhtml">It allows implementation-specific classes to extend the core algorithm. </span><span class="koboSpan" id="kobo.203.3" xmlns="http://www.w3.org/1999/xhtml">It can reduce the duplication of logic and improve maintainability while not cutting out any flexibility in the process. </span><span class="koboSpan" id="kobo.203.4" xmlns="http://www.w3.org/1999/xhtml">There are many examples in the .NET BCL, and we leverage this pattern at the end of the chapter based on a real-world scenario.Now, let’s see how the Template Method pattern can help us follow the </span><strong><span class="koboSpan" id="kobo.204.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.205.1" xmlns="http://www.w3.org/1999/xhtml"> principles:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.206.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.207.1" xmlns="http://www.w3.org/1999/xhtml">: The Template Method pushes algorithm-specific portions of the code to subclasses while keeping the core algorithm in the base class. </span><span class="koboSpan" id="kobo.207.2" xmlns="http://www.w3.org/1999/xhtml">Doing that helps follow the </span><strong><span class="koboSpan" id="kobo.208.1" xmlns="http://www.w3.org/1999/xhtml">single responsibility principle</span></strong><span class="koboSpan" id="kobo.209.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.210.1" xmlns="http://www.w3.org/1999/xhtml">SRP</span></strong><span class="koboSpan" id="kobo.211.1" xmlns="http://www.w3.org/1999/xhtml">) by distributing responsibilities.</span></li>
<li><strong><span class="koboSpan" id="kobo.212.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.213.1" xmlns="http://www.w3.org/1999/xhtml">: By opening extension hooks, it opens the template for extensions (allowing subclasses to extend it) and closes it from modifications (no need to modify the base class since the subclasses can extend it).</span></li>
<li><strong><span class="koboSpan" id="kobo.214.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.215.1" xmlns="http://www.w3.org/1999/xhtml">: As long as the subclasses are the implementations and do not alter the base class per se, following the </span><strong><span class="koboSpan" id="kobo.216.1" xmlns="http://www.w3.org/1999/xhtml">Liskov substitution principle</span></strong><span class="koboSpan" id="kobo.217.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.218.1" xmlns="http://www.w3.org/1999/xhtml">LSP</span></strong><span class="koboSpan" id="kobo.219.1" xmlns="http://www.w3.org/1999/xhtml">) should not be a problem. </span><span class="koboSpan" id="kobo.219.2" xmlns="http://www.w3.org/1999/xhtml">However, this principle is tricky, so it is possible to break it; by throwing a new type of exception or altering the state of a more complex base class in a way that changes its behavior, for example.</span></li>
<li><strong><span class="koboSpan" id="kobo.220.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.221.1" xmlns="http://www.w3.org/1999/xhtml">: As long as the base class implements the smallest cohesive surface possible, using the Template Method pattern should not negatively impact the program. </span><span class="koboSpan" id="kobo.221.2" xmlns="http://www.w3.org/1999/xhtml">On top of this, having a smaller interface surface in classes diminishes the chances of breaking the LSP.</span></li>
<li><strong><span class="koboSpan" id="kobo.222.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.223.1" xmlns="http://www.w3.org/1999/xhtml">: The Template Method pattern is based on an abstraction, so as long as consumers depend on that abstraction, it should help to get in line with the </span><strong><span class="koboSpan" id="kobo.224.1" xmlns="http://www.w3.org/1999/xhtml">dependency inversion principle</span></strong><span class="koboSpan" id="kobo.225.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.226.1" xmlns="http://www.w3.org/1999/xhtml">DIP</span></strong><span class="koboSpan" id="kobo.227.1" xmlns="http://www.w3.org/1999/xhtml">).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.228.1" xmlns="http://www.w3.org/1999/xhtml">Next, we move to the Chain of Responsibility design pattern before mixing the Template Method and the Chain of Responsibility pattern to improve our code.</span></p>
</section>
</section>
<section class="level2" data-number="13.3" id="implementing-the-chain-of-responsibility-pattern">
<h2 data-number="13.3"><span class="koboSpan" id="kobo.229.1" xmlns="http://www.w3.org/1999/xhtml">Implementing the Chain of Responsibility pattern</span></h2>
<p><span class="koboSpan" id="kobo.230.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.231.1" xmlns="http://www.w3.org/1999/xhtml">Chain of Responsibility</span></strong><span class="koboSpan" id="kobo.232.1" xmlns="http://www.w3.org/1999/xhtml"> is a GoF behavioral pattern that chains classes to handle complex scenarios efficiently, with limited effort. </span><span class="koboSpan" id="kobo.232.2" xmlns="http://www.w3.org/1999/xhtml">Once again, the goal is to take a complex problem and break it into multiple smaller units.</span></p>
<section class="level3" data-number="13.3.1" id="goal-12">
<h3 data-number="13.3.1"><span class="koboSpan" id="kobo.233.1" xmlns="http://www.w3.org/1999/xhtml">Goal</span></h3>
<p><span class="koboSpan" id="kobo.234.1" xmlns="http://www.w3.org/1999/xhtml">The Chain of Responsibility pattern aims to chain multiple handlers that each solve a limited number of problems. </span><span class="koboSpan" id="kobo.234.2" xmlns="http://www.w3.org/1999/xhtml">If a handler cannot solve the specific problem, it passes the resolution to the chain’s next handler.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.235.1" xmlns="http://www.w3.org/1999/xhtml">We often create a default handler that executes logic at the end of the chain as the terminal handler. </span><span class="koboSpan" id="kobo.235.2" xmlns="http://www.w3.org/1999/xhtml">Such a handler can throw an exception (for example, </span><code><span class="koboSpan" id="kobo.236.1" xmlns="http://www.w3.org/1999/xhtml">OperationNotHandledException</span></code><span class="koboSpan" id="kobo.237.1" xmlns="http://www.w3.org/1999/xhtml">) to cascade the issue up the call stack to a consumer who knows how to handle and react to it. </span><span class="koboSpan" id="kobo.237.2" xmlns="http://www.w3.org/1999/xhtml">Another strategy is creating a terminal handler that does the opposite and ensures nothing happens.</span></p>
</blockquote>
</section>
<section class="level3" data-number="13.3.2" id="design-12">
<h3 data-number="13.3.2"><span class="koboSpan" id="kobo.238.1" xmlns="http://www.w3.org/1999/xhtml">Design</span></h3>
<p><span class="koboSpan" id="kobo.239.1" xmlns="http://www.w3.org/1999/xhtml">The most basic Chain of Responsibility starts by defining an interface that handles a request (</span><code><span class="koboSpan" id="kobo.240.1" xmlns="http://www.w3.org/1999/xhtml">IHandler</span></code><span class="koboSpan" id="kobo.241.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.241.2" xmlns="http://www.w3.org/1999/xhtml">Then we add classes that handle one or more scenarios (</span><code><span class="koboSpan" id="kobo.242.1" xmlns="http://www.w3.org/1999/xhtml">Handler1</span></code><span class="koboSpan" id="kobo.243.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.244.1" xmlns="http://www.w3.org/1999/xhtml">Handler2</span></code><span class="koboSpan" id="kobo.245.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<figure>
<span class="koboSpan" id="kobo.246.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 12.2: Class diagram representing the Chain of Responsibility pattern" src="../media/file69.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.247.1" xmlns="http://www.w3.org/1999/xhtml">Figure 12.2: Class diagram representing the Chain of Responsibility pattern</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.248.1" xmlns="http://www.w3.org/1999/xhtml">A difference between the Chain of Responsibility pattern and many other patterns is that no central dispatcher knows the handlers; all handlers are independent. </span><span class="koboSpan" id="kobo.248.2" xmlns="http://www.w3.org/1999/xhtml">The consumer receives a handler and tells it to handle the request. </span><span class="koboSpan" id="kobo.248.3" xmlns="http://www.w3.org/1999/xhtml">Each handler determines if it can process the request. </span><span class="koboSpan" id="kobo.248.4" xmlns="http://www.w3.org/1999/xhtml">If it can, it processes it. </span><span class="koboSpan" id="kobo.248.5" xmlns="http://www.w3.org/1999/xhtml">In both cases, it also evaluates if it should forward the request to the next handler in the chain. </span><span class="koboSpan" id="kobo.248.6" xmlns="http://www.w3.org/1999/xhtml">The handler can execute these two tasks in any order, like executing some logic, sending the request down the chain, then executing more logic when the request comes back (like a pipeline).This pattern allows us to divide complex logic into multiple pieces that handle a single responsibility, improving testability, reusability, and extensibility in the process. </span><span class="koboSpan" id="kobo.248.7" xmlns="http://www.w3.org/1999/xhtml">Since no orchestrator exists, each chain element is independent, leading to a cohesive and loosely coupled design.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.249.1" xmlns="http://www.w3.org/1999/xhtml">When creating the chain of responsibility, you can order the handlers so that the most requested handlers are closer to the beginning of the chain and the least requested handlers are closer to the end. </span><span class="koboSpan" id="kobo.249.2" xmlns="http://www.w3.org/1999/xhtml">This helps limit the number of “chain links” that are visited for each request before reaching the right handler.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.250.1" xmlns="http://www.w3.org/1999/xhtml">Enough theory; let’s look at some code.</span></p>
</section>
<section class="level3" data-number="13.3.3" id="project-message-interpreter">
<h3 data-number="13.3.3"><span class="koboSpan" id="kobo.251.1" xmlns="http://www.w3.org/1999/xhtml">Project – Message interpreter</span></h3>
<p><strong><span class="koboSpan" id="kobo.252.1" xmlns="http://www.w3.org/1999/xhtml">Context</span></strong><span class="koboSpan" id="kobo.253.1" xmlns="http://www.w3.org/1999/xhtml">: We need to create the receiving end of a messaging application where each message is unique, making it impossible to create a single algorithm to handle them all.After analyzing the problem, we decided to build a chain of responsibility where each handler can manage a single message. </span><span class="koboSpan" id="kobo.253.2" xmlns="http://www.w3.org/1999/xhtml">The pattern seems more than perfect!</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.254.1" xmlns="http://www.w3.org/1999/xhtml">This project is based on something that I built years ago. </span><span class="koboSpan" id="kobo.254.2" xmlns="http://www.w3.org/1999/xhtml">IoT devices were sending bytes (messages) due to limited bandwidth. </span><span class="koboSpan" id="kobo.254.3" xmlns="http://www.w3.org/1999/xhtml">Then, we had to associate those bytes with real values in a web application. </span><span class="koboSpan" id="kobo.254.4" xmlns="http://www.w3.org/1999/xhtml">Each message had a fixed header size but a variable body size. </span><span class="koboSpan" id="kobo.254.5" xmlns="http://www.w3.org/1999/xhtml">The headers were handled in a base handler (template method), and each handler in the chain managed a different message type. </span><span class="koboSpan" id="kobo.254.6" xmlns="http://www.w3.org/1999/xhtml">For the current example, we keep it simpler than parsing bytes, but the concept is the same.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.255.1" xmlns="http://www.w3.org/1999/xhtml">For our demo application, the messages are as simple as this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.256.1" xmlns="http://www.w3.org/1999/xhtml">namespace ChainOfResponsibility;
public record class Message(string Name, string? </span><span class="koboSpan" id="kobo.256.2" xmlns="http://www.w3.org/1999/xhtml">Payload);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.257.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.258.1" xmlns="http://www.w3.org/1999/xhtml">Name</span></code><span class="koboSpan" id="kobo.259.1" xmlns="http://www.w3.org/1999/xhtml"> property is used as a discriminator to differentiate messages, and each handler is responsible for doing something with the </span><code><span class="koboSpan" id="kobo.260.1" xmlns="http://www.w3.org/1999/xhtml">Payload</span></code><span class="koboSpan" id="kobo.261.1" xmlns="http://www.w3.org/1999/xhtml"> property.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.262.1" xmlns="http://www.w3.org/1999/xhtml">We won’t do anything with the payload as it is irrelevant to the pattern, but conceptually, that is the logic that should happen.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.263.1" xmlns="http://www.w3.org/1999/xhtml">The handlers are very simple, here’s the interface:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.264.1" xmlns="http://www.w3.org/1999/xhtml">namespace ChainOfResponsibility; 
public interface IMessageHandler
{
    void Handle(Message message);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.265.1" xmlns="http://www.w3.org/1999/xhtml">The only thing a handler can do is handle a message. </span><span class="koboSpan" id="kobo.265.2" xmlns="http://www.w3.org/1999/xhtml">Our initial application can handle the following messages:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.266.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.267.1" xmlns="http://www.w3.org/1999/xhtml">AlarmTriggeredHandler</span></code><span class="koboSpan" id="kobo.268.1" xmlns="http://www.w3.org/1999/xhtml"> class handles </span><code><span class="koboSpan" id="kobo.269.1" xmlns="http://www.w3.org/1999/xhtml">AlarmTriggered</span></code><span class="koboSpan" id="kobo.270.1" xmlns="http://www.w3.org/1999/xhtml"> messages.</span></li>
<li><span class="koboSpan" id="kobo.271.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.272.1" xmlns="http://www.w3.org/1999/xhtml">AlarmPausedHandler</span></code><span class="koboSpan" id="kobo.273.1" xmlns="http://www.w3.org/1999/xhtml"> class handles </span><code><span class="koboSpan" id="kobo.274.1" xmlns="http://www.w3.org/1999/xhtml">AlarmPaused</span></code><span class="koboSpan" id="kobo.275.1" xmlns="http://www.w3.org/1999/xhtml"> messages.</span></li>
<li><span class="koboSpan" id="kobo.276.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.277.1" xmlns="http://www.w3.org/1999/xhtml">AlarmStoppedHandler</span></code><span class="koboSpan" id="kobo.278.1" xmlns="http://www.w3.org/1999/xhtml"> class handles </span><code><span class="koboSpan" id="kobo.279.1" xmlns="http://www.w3.org/1999/xhtml">AlarmStopped</span></code><span class="koboSpan" id="kobo.280.1" xmlns="http://www.w3.org/1999/xhtml"> messages.</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.281.1" xmlns="http://www.w3.org/1999/xhtml">The real-world logic is that a machine can send an alarm to a REST API indicating it has reached a certain threshold. </span><span class="koboSpan" id="kobo.281.2" xmlns="http://www.w3.org/1999/xhtml">Then the REST API can push that information to a UI, send an email, a text message, or whatnot.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.282.1" xmlns="http://www.w3.org/1999/xhtml">An alerted human can then pause the alarm while investigating the issue so other people know the alarm is getting handled.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.283.1" xmlns="http://www.w3.org/1999/xhtml">Finally, a human can go to the physical device and stop the alarm because the person has resolved the issue.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.284.1" xmlns="http://www.w3.org/1999/xhtml">We could extrapolate on many more sub-scenarios, but this is the gist.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.285.1" xmlns="http://www.w3.org/1999/xhtml">The three handlers are very similar and share quite a bit of logic, but we fix that later. </span><span class="koboSpan" id="kobo.285.2" xmlns="http://www.w3.org/1999/xhtml">In the meantime, we have the following handlers:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.286.1" xmlns="http://www.w3.org/1999/xhtml">namespace ChainOfResponsibility;
public class AlarmTriggeredHandler : IMessageHandler
{
    private readonly IMessageHandler? </span><span class="koboSpan" id="kobo.286.2" xmlns="http://www.w3.org/1999/xhtml">_next;
    public AlarmTriggeredHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.286.3" xmlns="http://www.w3.org/1999/xhtml">next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (message.Name == "AlarmTriggered")
        {
            // Do something clever with the Payload
        }
        else
        {
            _next?.Handle(message);
        }
    }
}
public class AlarmPausedHandler : IMessageHandler
{
    private readonly IMessageHandler? </span><span class="koboSpan" id="kobo.286.4" xmlns="http://www.w3.org/1999/xhtml">_next;
    public AlarmPausedHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.286.5" xmlns="http://www.w3.org/1999/xhtml">next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (message.Name == "AlarmPaused")
        {
            // Do something clever with the Payload
        }
        else
        {
            _next?.Handle(message);
        }
    }
}
public class AlarmStoppedHandler : IMessageHandler
{
    private readonly IMessageHandler? </span><span class="koboSpan" id="kobo.286.6" xmlns="http://www.w3.org/1999/xhtml">_next;
    public AlarmStoppedHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.286.7" xmlns="http://www.w3.org/1999/xhtml">next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (message.Name == "AlarmStopped")
        {
            // Do something clever with the Payload
        }
        else
        {
            _next?.Handle(message);
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.287.1" xmlns="http://www.w3.org/1999/xhtml">Each handler does two things:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.288.1" xmlns="http://www.w3.org/1999/xhtml">It receives an optional “next handler” from its constructor (highlighted in the code). </span><span class="koboSpan" id="kobo.288.2" xmlns="http://www.w3.org/1999/xhtml">This creates a chain similar to a singly linked list.</span></li>
<li><span class="koboSpan" id="kobo.289.1" xmlns="http://www.w3.org/1999/xhtml">It handles only the request it knows about, delegating the others to the next handler in the chain.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.290.1" xmlns="http://www.w3.org/1999/xhtml">Let’s use </span><code><span class="koboSpan" id="kobo.291.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.292.1" xmlns="http://www.w3.org/1999/xhtml"> as the consumer of the Chain of Responsibility (the Client) and use a POST requests to interface with our REST API and build the message.Here is the first part of our REST API:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.293.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;IMessageHandler&gt;(
    new AlarmTriggeredHandler(
        new AlarmPausedHandler(
            new AlarmStoppedHandler())));</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.294.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, we manually create the Chain of Responsibility and register it as a singleton bound to the </span><code><span class="koboSpan" id="kobo.295.1" xmlns="http://www.w3.org/1999/xhtml">IMessageHandler</span></code><span class="koboSpan" id="kobo.296.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.296.2" xmlns="http://www.w3.org/1999/xhtml">In that registration code, each handler is manually injected in the previous constructor (created with the </span><code><span class="koboSpan" id="kobo.297.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.298.1" xmlns="http://www.w3.org/1999/xhtml"> keyword).The next code represents the second half of the </span><code><span class="koboSpan" id="kobo.299.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.300.1" xmlns="http://www.w3.org/1999/xhtml"> file:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.301.1" xmlns="http://www.w3.org/1999/xhtml">var app = builder.Build();
app.MapPost(
    "/handle",
    (Message message, IMessageHandler messageHandler) =&gt;
    {
        messageHandler.Handle(message);
        return $"Message '{message.Name}' handled successfully.";
    });
app.Run();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.302.1" xmlns="http://www.w3.org/1999/xhtml">The consuming endpoint is reachable through the </span><code><span class="koboSpan" id="kobo.303.1" xmlns="http://www.w3.org/1999/xhtml">/handle</span></code><span class="koboSpan" id="kobo.304.1" xmlns="http://www.w3.org/1999/xhtml"> URL and expects a </span><code><span class="koboSpan" id="kobo.305.1" xmlns="http://www.w3.org/1999/xhtml">Message</span></code><span class="koboSpan" id="kobo.306.1" xmlns="http://www.w3.org/1999/xhtml"> object in its body. </span><span class="koboSpan" id="kobo.306.2" xmlns="http://www.w3.org/1999/xhtml">It then uses the injected implementation of the </span><code><span class="koboSpan" id="kobo.307.1" xmlns="http://www.w3.org/1999/xhtml">IMessageHandler</span></code><span class="koboSpan" id="kobo.308.1" xmlns="http://www.w3.org/1999/xhtml"> interface and passes it the message. </span><span class="koboSpan" id="kobo.308.2" xmlns="http://www.w3.org/1999/xhtml">If we run any of the HTTP requests in the </span><code><span class="koboSpan" id="kobo.309.1" xmlns="http://www.w3.org/1999/xhtml">ChainOfResponsibility.http</span></code><span class="koboSpan" id="kobo.310.1" xmlns="http://www.w3.org/1999/xhtml"> file, we get a successful result similar to this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.311.1" xmlns="http://www.w3.org/1999/xhtml">Message 'AlarmTriggered' handled successfully.</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.312.1" xmlns="http://www.w3.org/1999/xhtml">The problem is that even if we send an invalid message, there is no way to know from the consumer, so it is always valid even when no handler picks up the message.To handle this scenario, let’s add a fourth handler (terminal handler) that notifies the consumers of invalid requests:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.313.1" xmlns="http://www.w3.org/1999/xhtml">public class DefaultHandler : IMessageHandler
{
    public void Handle(Message message)
    {
        throw new NotSupportedException(
            $"Messages named '{message.Name}' are not supported.");
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.314.1" xmlns="http://www.w3.org/1999/xhtml">This new terminal handler throws an exception that notifies the consumers about the error.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.315.1" xmlns="http://www.w3.org/1999/xhtml">We can create custom exceptions to make differentiating between system and application errors easier. </span><span class="koboSpan" id="kobo.315.2" xmlns="http://www.w3.org/1999/xhtml">In this case, throwing a system exception is good enough. </span><span class="koboSpan" id="kobo.315.3" xmlns="http://www.w3.org/1999/xhtml">In a real-world application, I recommend creating a custom exception that represents the end of the chain and contains the relevant information for the consumers to react to it according to your use case.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.316.1" xmlns="http://www.w3.org/1999/xhtml">Next, let’s register it in our chain (highlighted):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.317.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddSingleton&lt;IMessageHandler&gt;(
    new AlarmTriggeredHandler(
        new AlarmPausedHandler(
            new AlarmStoppedHandler(
                new DefaultHandler()
            ))));</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.318.1" xmlns="http://www.w3.org/1999/xhtml">If we send a POST request with the name </span><code><span class="koboSpan" id="kobo.319.1" xmlns="http://www.w3.org/1999/xhtml">SomeUnhandledMessageName</span></code><span class="koboSpan" id="kobo.320.1" xmlns="http://www.w3.org/1999/xhtml">, the endpoint now yields the following exception:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.321.1" xmlns="http://www.w3.org/1999/xhtml">System.NotSupportedException: Messages named 'SomeUnhandledMessageName' are not supported.
   </span><span class="koboSpan" id="kobo.321.2" xmlns="http://www.w3.org/1999/xhtml">at ChainOfResponsibility.DefaultHandler.Handle(Message message) in C12\src\ChainOfResponsibility\DefaultHandler.cs:line 7
   at ChainOfResponsibility.AlarmStoppedHandler.Handle(Message message) in C12\src\ChainOfResponsibility\AlarmStoppedHandler.cs:line 19
   at ChainOfResponsibility.AlarmPausedHandler.Handle(Message message) in C12\src\ChainOfResponsibility\AlarmPausedHandler.cs:line 19
   at ChainOfResponsibility.AlarmTriggeredHandler.Handle(Message message) in C12\src\ChainOfResponsibility\AlarmTriggeredHandler.cs:line 19
   at Program.&lt;&gt;c.&lt;&lt;Main&gt;$&gt;b__0_0(Message message, IMessageHandler messageHandler) in C12\src\ChainOfResponsibility\Program.cs:line 22
   at lambda_method1(Closure, Object, HttpContext, Object)
   at Microsoft.AspNetCore.Http.RequestDelegateFactory.&lt;&gt;c__DisplayClass100_2.&lt;&lt;HandleRequestBodyAndCompileRequestDelegateForJson&gt;b__2&gt;d.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)
HEADERS
=======
Host: localhost:10001
Content-Type: application/json
traceparent: 00-5d737fdbb1018d5b7d060b74baf26111-2805f137fe1541af-00
Content-Length: 77</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.322.1" xmlns="http://www.w3.org/1999/xhtml">So far, so good, but the experience is not great, so let’s add a try-catch block to handle this in the endpoint:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.323.1" xmlns="http://www.w3.org/1999/xhtml">app.MapPost(
    "/handle",
    (Message message, IMessageHandler messageHandler) =&gt;
    {
        try
        {
            messageHandler.Handle(message);
            return $"Message '{message.Name}' handled successfully.";
        }
        catch (NotSupportedException ex)
        {
            return ex.Message;
        }
    });</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.324.1" xmlns="http://www.w3.org/1999/xhtml">Now, when we send an invalid message, the API gently returns the following message to us:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.325.1" xmlns="http://www.w3.org/1999/xhtml">Messages named 'SomeUnhandledMessageName' are not supported.</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.326.1" xmlns="http://www.w3.org/1999/xhtml">Of course, when you expect machines to consume your APIs, you should produce a data structure that is easier to parse, like using JSON.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.327.1" xmlns="http://www.w3.org/1999/xhtml">And voilà. </span><span class="koboSpan" id="kobo.327.2" xmlns="http://www.w3.org/1999/xhtml">We have built a simple Chain of Responsibility that handles messages.</span></p>
</section>
<section class="level3" data-number="13.3.4" id="conclusion-20">
<h3 data-number="13.3.4"><span class="koboSpan" id="kobo.328.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.329.1" xmlns="http://www.w3.org/1999/xhtml">The Chain of Responsibility pattern is another great GoF pattern. </span><span class="koboSpan" id="kobo.329.2" xmlns="http://www.w3.org/1999/xhtml">It divides a large problem into smaller, cohesive units, each doing one job: handling its specific request(s).Now, let’s see how the Chain of Responsibility pattern can help us follow the </span><strong><span class="koboSpan" id="kobo.330.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.331.1" xmlns="http://www.w3.org/1999/xhtml"> principles:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.332.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.333.1" xmlns="http://www.w3.org/1999/xhtml">: The Chain of Responsibility pattern aims to this exact principle: create a single unit of logic per class!</span></li>
<li><strong><span class="koboSpan" id="kobo.334.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.335.1" xmlns="http://www.w3.org/1999/xhtml">: The Chain of Responsibility pattern allows the addition, removal, and reordering of handlers without touching the code but by altering the chain's composition in the composition root.</span></li>
<li><strong><span class="koboSpan" id="kobo.336.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.337.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.338.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.339.1" xmlns="http://www.w3.org/1999/xhtml">: The Chain of Responsibility pattern helps with the ISP if we create a small interface. </span><span class="koboSpan" id="kobo.339.2" xmlns="http://www.w3.org/1999/xhtml">The handler interface is not limited to a single method; it can expose multiple.</span></li>
<li><strong><span class="koboSpan" id="kobo.340.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.341.1" xmlns="http://www.w3.org/1999/xhtml">: By using the handler interface, no element of the chain, nor the consumers, depends on a specific handler; they only depend on the interface that represents the chain, which helps invert the dependency flow.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.342.1" xmlns="http://www.w3.org/1999/xhtml">Next, let’s use the Template Method and Chain of Responsibility patterns to encapsulate our handlers’ duplicated logic.</span></p>
</section>
</section>
<section class="level2" data-number="13.4" id="mixing-the-template-method-and-chain-of-responsibility-patterns">
<h2 data-number="13.4"><span class="koboSpan" id="kobo.343.1" xmlns="http://www.w3.org/1999/xhtml">Mixing the Template Method and Chain of Responsibility patterns</span></h2>
<p><span class="koboSpan" id="kobo.344.1" xmlns="http://www.w3.org/1999/xhtml">This section explores a combination of two powerful design patterns: the Template Method and the Chain of Responsibility. </span><span class="koboSpan" id="kobo.344.2" xmlns="http://www.w3.org/1999/xhtml">As we are about to explore, those two patterns fit together well. </span><span class="koboSpan" id="kobo.344.3" xmlns="http://www.w3.org/1999/xhtml">We use the Template Method pattern as the base structure, providing the handlers' blueprint. </span><span class="koboSpan" id="kobo.344.4" xmlns="http://www.w3.org/1999/xhtml">Meanwhile, the Chain of Responsibility pattern manages the handling sequence, ensuring each request is routed to the correct handler.When these two patterns work in tandem, they form a robust framework that facilitates easy management, maintains order, and increases the adaptability of our system.</span></p>
<section class="level3" data-number="13.4.1" id="project-improved-message-interpreter">
<h3 data-number="13.4.1"><span class="koboSpan" id="kobo.345.1" xmlns="http://www.w3.org/1999/xhtml">Project – Improved message interpreter</span></h3>
<p><span class="koboSpan" id="kobo.346.1" xmlns="http://www.w3.org/1999/xhtml">Now that we know both the </span><strong><span class="koboSpan" id="kobo.347.1" xmlns="http://www.w3.org/1999/xhtml">Chain of Responsibility</span></strong><span class="koboSpan" id="kobo.348.1" xmlns="http://www.w3.org/1999/xhtml"> and the </span><strong><span class="koboSpan" id="kobo.349.1" xmlns="http://www.w3.org/1999/xhtml">Template Method</span></strong><span class="koboSpan" id="kobo.350.1" xmlns="http://www.w3.org/1999/xhtml"> patterns, it is time to </span><em><span class="koboSpan" id="kobo.351.1" xmlns="http://www.w3.org/1999/xhtml">DRY</span></em><span class="koboSpan" id="kobo.352.1" xmlns="http://www.w3.org/1999/xhtml"> out our handlers by extracting the shared logic into an abstract base class using the Template Method pattern and providing extension points to the subclasses.OK, so what logic is duplicated?</span></p>
<ul>
<li><span class="koboSpan" id="kobo.353.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.354.1" xmlns="http://www.w3.org/1999/xhtml">next</span></code><span class="koboSpan" id="kobo.355.1" xmlns="http://www.w3.org/1999/xhtml"> handler injection code is the same in all but the terminal handlers. </span><span class="koboSpan" id="kobo.355.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, this is an important part of the pattern we should encapsulate in the base class.</span></li>
<li><span class="koboSpan" id="kobo.356.1" xmlns="http://www.w3.org/1999/xhtml">The logic testing whether the current handler can handle the message is also the same in all but the terminal handlers.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.357.1" xmlns="http://www.w3.org/1999/xhtml">Let’s create a new base class that implements the Template Method pattern and a large part of the logic of our chain of responsibility:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.358.1" xmlns="http://www.w3.org/1999/xhtml">namespace ImprovedChainOfResponsibility; 
public abstract class MessageHandlerBase : IMessageHandler
{
    private readonly IMessageHandler? </span><span class="koboSpan" id="kobo.358.2" xmlns="http://www.w3.org/1999/xhtml">_next;
    public MessageHandlerBase(IMessageHandler? </span><span class="koboSpan" id="kobo.358.3" xmlns="http://www.w3.org/1999/xhtml">next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (CanHandle(message))
        {
            Process(message);
        }
        else if (HasNext())
        {
            _next.Handle(message);
        }
    }
    [MemberNotNullWhen(true, nameof(_next))]
    private bool HasNext()
    {
        return _next != null;
    }
    protected virtual bool CanHandle(Message message)
    {
        return message.Name == HandledMessageName;
    }
    protected abstract string HandledMessageName { get; }
    protected abstract void Process(Message message);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.359.1" xmlns="http://www.w3.org/1999/xhtml">Based on those few changes, what is the template method, and what are the extension points (hooks)?The </span><code><span class="koboSpan" id="kobo.360.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.361.1" xmlns="http://www.w3.org/1999/xhtml"> class adds the </span><code><span class="koboSpan" id="kobo.362.1" xmlns="http://www.w3.org/1999/xhtml">Handle</span></code><span class="koboSpan" id="kobo.363.1" xmlns="http://www.w3.org/1999/xhtml"> template method. </span><span class="koboSpan" id="kobo.363.2" xmlns="http://www.w3.org/1999/xhtml">Then, the </span><code><span class="koboSpan" id="kobo.364.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.365.1" xmlns="http://www.w3.org/1999/xhtml"> class exposes the following extension points:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.366.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.367.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.368.1" xmlns="http://www.w3.org/1999/xhtml"> method tests whether </span><code><span class="koboSpan" id="kobo.369.1" xmlns="http://www.w3.org/1999/xhtml">HandledMessageName</span></code><span class="koboSpan" id="kobo.370.1" xmlns="http://www.w3.org/1999/xhtml"> is equal to the value of the </span><code><span class="koboSpan" id="kobo.371.1" xmlns="http://www.w3.org/1999/xhtml">message.Name</span></code><span class="koboSpan" id="kobo.372.1" xmlns="http://www.w3.org/1999/xhtml"> property. </span><span class="koboSpan" id="kobo.372.2" xmlns="http://www.w3.org/1999/xhtml">A subclass can override this method if it requires a different comparison logic. </span><span class="koboSpan" id="kobo.372.3" xmlns="http://www.w3.org/1999/xhtml">This method is an optional hook.</span></li>
<li><span class="koboSpan" id="kobo.373.1" xmlns="http://www.w3.org/1999/xhtml">All subclasses must implement the </span><code><span class="koboSpan" id="kobo.374.1" xmlns="http://www.w3.org/1999/xhtml">HandledMessageName</span></code><span class="koboSpan" id="kobo.375.1" xmlns="http://www.w3.org/1999/xhtml"> property, which is the key driver of the </span><code><span class="koboSpan" id="kobo.376.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.377.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.377.2" xmlns="http://www.w3.org/1999/xhtml">This property is a mandatory hook.</span></li>
<li><span class="koboSpan" id="kobo.378.1" xmlns="http://www.w3.org/1999/xhtml">All subclasses must implement the </span><code><span class="koboSpan" id="kobo.379.1" xmlns="http://www.w3.org/1999/xhtml">Process</span></code><span class="koboSpan" id="kobo.380.1" xmlns="http://www.w3.org/1999/xhtml"> method, allowing them to run their logic against the message. </span><span class="koboSpan" id="kobo.380.2" xmlns="http://www.w3.org/1999/xhtml">This method is a mandatory hook.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.381.1" xmlns="http://www.w3.org/1999/xhtml">To understand how these hooks play out, let’s take a look at the three simplified alarm handlers:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.382.1" xmlns="http://www.w3.org/1999/xhtml">public class AlarmTriggeredHandler : MessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmTriggered";
    public AlarmTriggeredHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.382.2" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmPausedHandler : MessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmPaused";
    public AlarmPausedHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.382.3" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmStoppedHandler : MessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmStopped";
    public AlarmStoppedHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.382.4" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.383.1" xmlns="http://www.w3.org/1999/xhtml">As we can see from the updated alarm handlers, they are now limited to a single responsibility: processing the messages they can handle. </span><span class="koboSpan" id="kobo.383.2" xmlns="http://www.w3.org/1999/xhtml">In contrast, </span><code><span class="koboSpan" id="kobo.384.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.385.1" xmlns="http://www.w3.org/1999/xhtml"> now handles the chain of responsibility’s plumbing. </span><span class="koboSpan" id="kobo.385.2" xmlns="http://www.w3.org/1999/xhtml">We left the </span><code><span class="koboSpan" id="kobo.386.1" xmlns="http://www.w3.org/1999/xhtml">DefaultHandler</span></code><span class="koboSpan" id="kobo.387.1" xmlns="http://www.w3.org/1999/xhtml"> class unchanged since it is the end of the chain and does not support having a next handler, nor processing messages.Mixing those two patterns created a complex messaging system that divides responsibilities into handlers. </span><span class="koboSpan" id="kobo.387.2" xmlns="http://www.w3.org/1999/xhtml">There is one handler per message, and the chain logic is pushed into a base class.The beauty of such a system is that we don’t have to think about all the messages simultaneously; we can focus on just one message at a time. </span><span class="koboSpan" id="kobo.387.3" xmlns="http://www.w3.org/1999/xhtml">When dealing with a new type of message, we can focus on that precise message, implement its handler, and forget about the other </span><em><span class="koboSpan" id="kobo.388.1" xmlns="http://www.w3.org/1999/xhtml">N</span></em><span class="koboSpan" id="kobo.389.1" xmlns="http://www.w3.org/1999/xhtml"> types. </span><span class="koboSpan" id="kobo.389.2" xmlns="http://www.w3.org/1999/xhtml">The consumers can also be super dumb, sending the request into the pipe without knowing about the Chain of Responsibility, and like magic, the right handler shall prevail!Nonetheless, have you noticed an issue with this design? </span><span class="koboSpan" id="kobo.389.3" xmlns="http://www.w3.org/1999/xhtml">Let’s have a look next.</span></p>
</section>
<section class="level3" data-number="13.4.2" id="project-a-final-finer-grained-design">
<h3 data-number="13.4.2"><span class="koboSpan" id="kobo.390.1" xmlns="http://www.w3.org/1999/xhtml">Project – A final, finer-grained design</span></h3>
<p><span class="koboSpan" id="kobo.391.1" xmlns="http://www.w3.org/1999/xhtml">In the last example, we used </span><code><span class="koboSpan" id="kobo.392.1" xmlns="http://www.w3.org/1999/xhtml">HandledMessageName</span></code><span class="koboSpan" id="kobo.393.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.394.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.395.1" xmlns="http://www.w3.org/1999/xhtml"> to decide whether a handler could handle a request. </span><span class="koboSpan" id="kobo.395.2" xmlns="http://www.w3.org/1999/xhtml">There is one problem with that code: if a subclass decides to override </span><code><span class="koboSpan" id="kobo.396.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.397.1" xmlns="http://www.w3.org/1999/xhtml">, and then decides that it no longer requires </span><code><span class="koboSpan" id="kobo.398.1" xmlns="http://www.w3.org/1999/xhtml">HandledMessageName</span></code><span class="koboSpan" id="kobo.399.1" xmlns="http://www.w3.org/1999/xhtml">, we would end up having a lingering, unused property in our system.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.400.1" xmlns="http://www.w3.org/1999/xhtml">There are worse situations, but we are talking component design here, so why not push that system a little further toward a better design?</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.401.1" xmlns="http://www.w3.org/1999/xhtml">One way to fix this is to create a finer-grained class hierarchy, as follows:</span></p>
<figure>
<span class="koboSpan" id="kobo.402.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 12.4: Class diagram representing the design of the finer-grained project that implements the Chain of Responsibility and Template Method patterns" src="../media/file70.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.403.1" xmlns="http://www.w3.org/1999/xhtml">Figure 12.4: Class diagram representing the design of the finer-grained project that implements the Chain of Responsibility and Template Method patterns</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.404.1" xmlns="http://www.w3.org/1999/xhtml">The preceding diagram looks more complicated than it is. </span><span class="koboSpan" id="kobo.404.2" xmlns="http://www.w3.org/1999/xhtml">But let’s look at our refactored code first, starting with the new </span><code><span class="koboSpan" id="kobo.405.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.406.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.407.1" xmlns="http://www.w3.org/1999/xhtml">namespace FinalChainOfResponsibility;
public interface IMessageHandler
{
    void Handle(Message message);
}
public abstract class MessageHandlerBase : IMessageHandler
{
    private readonly IMessageHandler? </span><span class="koboSpan" id="kobo.407.2" xmlns="http://www.w3.org/1999/xhtml">_next;
    public MessageHandlerBase(IMessageHandler? </span><span class="koboSpan" id="kobo.407.3" xmlns="http://www.w3.org/1999/xhtml">next = null)
    {
        _next = next;
    }
    public void Handle(Message message)
    {
        if (CanHandle(message))
        {
            Process(message);
        }
        else if (HasNext())
        {
            _next.Handle(message);
        }
    }
    [MemberNotNullWhen(true, nameof(_next))]
    private bool HasNext()
    {
        return _next != null;
    }
    protected abstract bool CanHandle(Message message);
    protected abstract void Process(Message message);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.408.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.409.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.410.1" xmlns="http://www.w3.org/1999/xhtml"> class manages the Chain of Responsibility by handling the next handler logic and by exposing two hooks (the Template Method pattern) for subclasses to extend:</span></p>
<ul>
<li><code><span class="koboSpan" id="kobo.411.1" xmlns="http://www.w3.org/1999/xhtml">bool CanHandle(Message message)</span></code></li>
<li><code><span class="koboSpan" id="kobo.412.1" xmlns="http://www.w3.org/1999/xhtml">void Process(Message message)</span></code></li>
</ul>
<p><span class="koboSpan" id="kobo.413.1" xmlns="http://www.w3.org/1999/xhtml">This class is similar to the previous one, but the </span><code><span class="koboSpan" id="kobo.414.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.415.1" xmlns="http://www.w3.org/1999/xhtml"> method is now abstract, and we removed the </span><code><span class="koboSpan" id="kobo.416.1" xmlns="http://www.w3.org/1999/xhtml">HandledMessageName</span></code><span class="koboSpan" id="kobo.417.1" xmlns="http://www.w3.org/1999/xhtml"> property leading to a better responsibility segregation and better hooks.Next, let’s look at the </span><code><span class="koboSpan" id="kobo.418.1" xmlns="http://www.w3.org/1999/xhtml">SingleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.419.1" xmlns="http://www.w3.org/1999/xhtml"> class, which replaces the logic we removed from the </span><code><span class="koboSpan" id="kobo.420.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.421.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.422.1" xmlns="http://www.w3.org/1999/xhtml">public abstract class SingleMessageHandlerBase : MessageHandlerBase
{
    public SingleMessageHandlerBase(IMessageHandler? </span><span class="koboSpan" id="kobo.422.2" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override bool CanHandle(Message message)
    {
        return message.Name == HandledMessageName;
    }
    protected abstract string HandledMessageName { get; }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.423.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.424.1" xmlns="http://www.w3.org/1999/xhtml">SingleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.425.1" xmlns="http://www.w3.org/1999/xhtml"> class inherits from the </span><code><span class="koboSpan" id="kobo.426.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.427.1" xmlns="http://www.w3.org/1999/xhtml"> class and overrides the </span><code><span class="koboSpan" id="kobo.428.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.429.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.429.2" xmlns="http://www.w3.org/1999/xhtml">It implements the logic related to it and adds the </span><code><span class="koboSpan" id="kobo.430.1" xmlns="http://www.w3.org/1999/xhtml">HandledMessageName</span></code><span class="koboSpan" id="kobo.431.1" xmlns="http://www.w3.org/1999/xhtml"> property that subclasses must define for the </span><code><span class="koboSpan" id="kobo.432.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.433.1" xmlns="http://www.w3.org/1999/xhtml"> method to work (a required extension point).The </span><code><span class="koboSpan" id="kobo.434.1" xmlns="http://www.w3.org/1999/xhtml">AlarmPausedHandler</span></code><span class="koboSpan" id="kobo.435.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.436.1" xmlns="http://www.w3.org/1999/xhtml">AlarmStoppedHandler</span></code><span class="koboSpan" id="kobo.437.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.438.1" xmlns="http://www.w3.org/1999/xhtml">AlarmTriggeredHandler</span></code><span class="koboSpan" id="kobo.439.1" xmlns="http://www.w3.org/1999/xhtml"> classes now inherit from </span><code><span class="koboSpan" id="kobo.440.1" xmlns="http://www.w3.org/1999/xhtml">SingleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.441.1" xmlns="http://www.w3.org/1999/xhtml"> instead of </span><code><span class="koboSpan" id="kobo.442.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.443.1" xmlns="http://www.w3.org/1999/xhtml">, but nothing else has changed. </span><span class="koboSpan" id="kobo.443.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the code as a reminder:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.444.1" xmlns="http://www.w3.org/1999/xhtml">namespace FinalChainOfResponsibility;
public class AlarmPausedHandler : SingleMessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmPaused";
    public AlarmPausedHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.444.2" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmStoppedHandler : SingleMessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmStopped";
    public AlarmStoppedHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.444.3" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}
public class AlarmTriggeredHandler : SingleMessageHandlerBase
{
    protected override string HandledMessageName =&gt; "AlarmTriggered";
    public AlarmTriggeredHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.444.4" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.445.1" xmlns="http://www.w3.org/1999/xhtml">Those subclasses of </span><code><span class="koboSpan" id="kobo.446.1" xmlns="http://www.w3.org/1999/xhtml">SingleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.447.1" xmlns="http://www.w3.org/1999/xhtml"> implement the </span><code><span class="koboSpan" id="kobo.448.1" xmlns="http://www.w3.org/1999/xhtml">HandledMessageName</span></code><span class="koboSpan" id="kobo.449.1" xmlns="http://www.w3.org/1999/xhtml"> property, which returns the message name they can handle, and they implement the handling logic by overriding the </span><code><span class="koboSpan" id="kobo.450.1" xmlns="http://www.w3.org/1999/xhtml">Process</span></code><span class="koboSpan" id="kobo.451.1" xmlns="http://www.w3.org/1999/xhtml"> method as before.Next, we look at the </span><code><span class="koboSpan" id="kobo.452.1" xmlns="http://www.w3.org/1999/xhtml">MultipleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.453.1" xmlns="http://www.w3.org/1999/xhtml"> class, which enables its sub-types to handle more than one message type:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.454.1" xmlns="http://www.w3.org/1999/xhtml">public abstract class MultipleMessageHandlerBase : MessageHandlerBase
{
    public MultipleMessageHandlerBase(IMessageHandler? </span><span class="koboSpan" id="kobo.454.2" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override bool CanHandle(Message message)
    {
        return HandledMessagesName.Contains(message.Name);
    }
    protected abstract string[] HandledMessagesName { get; }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.455.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.456.1" xmlns="http://www.w3.org/1999/xhtml">MultipleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.457.1" xmlns="http://www.w3.org/1999/xhtml"> class does the same as </span><code><span class="koboSpan" id="kobo.458.1" xmlns="http://www.w3.org/1999/xhtml">SingleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.459.1" xmlns="http://www.w3.org/1999/xhtml">, but it uses a string array instead of a single string, supporting multiple handler names.The </span><code><span class="koboSpan" id="kobo.460.1" xmlns="http://www.w3.org/1999/xhtml">DefaultHandler</span></code><span class="koboSpan" id="kobo.461.1" xmlns="http://www.w3.org/1999/xhtml"> class has not changed. </span><span class="koboSpan" id="kobo.461.2" xmlns="http://www.w3.org/1999/xhtml">For demonstration purposes, let’s add the </span><code><span class="koboSpan" id="kobo.462.1" xmlns="http://www.w3.org/1999/xhtml">SomeMultiHandler</span></code><span class="koboSpan" id="kobo.463.1" xmlns="http://www.w3.org/1999/xhtml"> class that simulates a message handler that can handle </span><code><span class="koboSpan" id="kobo.464.1" xmlns="http://www.w3.org/1999/xhtml">"Foo"</span></code><span class="koboSpan" id="kobo.465.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.466.1" xmlns="http://www.w3.org/1999/xhtml">"Bar"</span></code><span class="koboSpan" id="kobo.467.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.468.1" xmlns="http://www.w3.org/1999/xhtml">"Baz"</span></code><span class="koboSpan" id="kobo.469.1" xmlns="http://www.w3.org/1999/xhtml"> messages:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.470.1" xmlns="http://www.w3.org/1999/xhtml">namespace FinalChainOfResponsibility;
public class SomeMultiHandler : MultipleMessageHandlerBase
{
    public SomeMultiHandler(IMessageHandler? </span><span class="koboSpan" id="kobo.470.2" xmlns="http://www.w3.org/1999/xhtml">next = null)
        : base(next) { }
    protected override string[] HandledMessagesName
        =&gt; new[] { "Foo", "Bar", "Baz" };
    protected override void Process(Message message)
    {
        // Do something clever with the Payload
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.471.1" xmlns="http://www.w3.org/1999/xhtml">This class hierarchy may sound complicated, but what we did was to allow extensibility without the need to keep any unnecessary code in the process, leaving each class with a single responsibility:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.472.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.473.1" xmlns="http://www.w3.org/1999/xhtml">MessageHandlerBase</span></code><span class="koboSpan" id="kobo.474.1" xmlns="http://www.w3.org/1999/xhtml"> class handles </span><code><span class="koboSpan" id="kobo.475.1" xmlns="http://www.w3.org/1999/xhtml">_next</span></code><span class="koboSpan" id="kobo.476.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.477.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.478.1" xmlns="http://www.w3.org/1999/xhtml">SingleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.479.1" xmlns="http://www.w3.org/1999/xhtml"> class handles the </span><code><span class="koboSpan" id="kobo.480.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.481.1" xmlns="http://www.w3.org/1999/xhtml"> method of handlers supporting a single message.</span></li>
<li><span class="koboSpan" id="kobo.482.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.483.1" xmlns="http://www.w3.org/1999/xhtml">MultipleMessageHandlerBase</span></code><span class="koboSpan" id="kobo.484.1" xmlns="http://www.w3.org/1999/xhtml"> class handles the </span><code><span class="koboSpan" id="kobo.485.1" xmlns="http://www.w3.org/1999/xhtml">CanHandle</span></code><span class="koboSpan" id="kobo.486.1" xmlns="http://www.w3.org/1999/xhtml"> method of handlers supporting multiple messages.</span></li>
<li><span class="koboSpan" id="kobo.487.1" xmlns="http://www.w3.org/1999/xhtml">Other classes implement their version of </span><code><span class="koboSpan" id="kobo.488.1" xmlns="http://www.w3.org/1999/xhtml">Process</span></code><span class="koboSpan" id="kobo.489.1" xmlns="http://www.w3.org/1999/xhtml"> method to handle one or more messages.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.490.1" xmlns="http://www.w3.org/1999/xhtml">And voilà! </span><span class="koboSpan" id="kobo.490.2" xmlns="http://www.w3.org/1999/xhtml">This is another example demonstrating the strength of the Template Method and Chain of Responsibility patterns working together. </span><span class="koboSpan" id="kobo.490.3" xmlns="http://www.w3.org/1999/xhtml">That last example also emphasizes the importance of the SRP by allowing greater flexibility while keeping the code reliable and maintainable.Another strength of that design is the interface at the top. </span><span class="koboSpan" id="kobo.490.4" xmlns="http://www.w3.org/1999/xhtml">Anything that does not fit the class hierarchy can be implemented directly from the interface instead of trying to adapt logic from inappropriate structures. </span><span class="koboSpan" id="kobo.490.5" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.491.1" xmlns="http://www.w3.org/1999/xhtml">DefaultHandler</span></code><span class="koboSpan" id="kobo.492.1" xmlns="http://www.w3.org/1999/xhtml"> class is a good example of that.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.493.1" xmlns="http://www.w3.org/1999/xhtml">Tricking code into doing your bidding instead of properly designing that part of the system leads to half-baked solutions that become hard to maintain.</span></p>
</blockquote>
</section>
<section class="level3" data-number="13.4.3" id="conclusion-21">
<h3 data-number="13.4.3"><span class="koboSpan" id="kobo.494.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.495.1" xmlns="http://www.w3.org/1999/xhtml">Mixing the Template Method and the Chain of Responsibility patterns leads to smaller classes with a single responsibility each.We removed the lingering property while keeping that logic out of the handlers. </span><span class="koboSpan" id="kobo.495.2" xmlns="http://www.w3.org/1999/xhtml">We even extended the logic to more use cases.</span></p>
</section>
</section>
<section class="level2" data-number="13.5" id="summary-11">
<h2 data-number="13.5"><span class="koboSpan" id="kobo.496.1" xmlns="http://www.w3.org/1999/xhtml">Summary</span></h2>
<p><span class="koboSpan" id="kobo.497.1" xmlns="http://www.w3.org/1999/xhtml">In this chapter, we covered two GoF behavioral patterns. </span><span class="koboSpan" id="kobo.497.2" xmlns="http://www.w3.org/1999/xhtml">These patterns can help us create flexible yet easy-to-maintain systems. </span><span class="koboSpan" id="kobo.497.3" xmlns="http://www.w3.org/1999/xhtml">As the name suggests, behavioral patterns aim at encapsulating application behaviors into cohesive pieces.First, we looked at the Template Method pattern, which allows us to encapsulate an algorithm’s outline inside a base class, leaving some parts open for modification by subclasses. </span><span class="koboSpan" id="kobo.497.4" xmlns="http://www.w3.org/1999/xhtml">The subclasses then fill in the gaps and extend that algorithm at those predefined locations. </span><span class="koboSpan" id="kobo.497.5" xmlns="http://www.w3.org/1999/xhtml">These locations can be required (</span><code><span class="koboSpan" id="kobo.498.1" xmlns="http://www.w3.org/1999/xhtml">abstract</span></code><span class="koboSpan" id="kobo.499.1" xmlns="http://www.w3.org/1999/xhtml">) or optional (</span><code><span class="koboSpan" id="kobo.500.1" xmlns="http://www.w3.org/1999/xhtml">virtual</span></code><span class="koboSpan" id="kobo.501.1" xmlns="http://www.w3.org/1999/xhtml">).Then, you learned about the Chain of Responsibility pattern, which opens the possibility of chaining multiple small handlers into a chain of processing, inputting the message to be processed at the beginning of the chain (the interface), and waiting for one or more handlers to execute the logic related to that message against it.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.502.1" xmlns="http://www.w3.org/1999/xhtml">You don’t have to stop the chain’s execution at the first handler. </span><span class="koboSpan" id="kobo.502.2" xmlns="http://www.w3.org/1999/xhtml">The Chain of Responsibility can become a pipeline instead of associating one message to one handler, as we explored.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.503.1" xmlns="http://www.w3.org/1999/xhtml">Lastly, leveraging the Template Method pattern to encapsulate the Chain of Responsibility’s chaining logic led us to a simpler, robust, flexible, and testable implementation without any sacrifices. </span><span class="koboSpan" id="kobo.503.2" xmlns="http://www.w3.org/1999/xhtml">The two design patterns fits very well together.In the next chapter, we dig into the Operation Result design pattern to discover efficient ways of managing return values.</span></p>
</section>
<section class="level2" data-number="13.6" id="questions-11">
<h2 data-number="13.6"><span class="koboSpan" id="kobo.504.1" xmlns="http://www.w3.org/1999/xhtml">Questions</span></h2>
<p><span class="koboSpan" id="kobo.505.1" xmlns="http://www.w3.org/1999/xhtml">Let’s take a look at a few practice questions:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.506.1" xmlns="http://www.w3.org/1999/xhtml">What is the main goal of the Template Method pattern?</span></li>
<li><span class="koboSpan" id="kobo.507.1" xmlns="http://www.w3.org/1999/xhtml">What is the main goal of the Chain of Responsibility pattern?</span></li>
<li><span class="koboSpan" id="kobo.508.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that we can only add one </span><code><span class="koboSpan" id="kobo.509.1" xmlns="http://www.w3.org/1999/xhtml">abstract</span></code><span class="koboSpan" id="kobo.510.1" xmlns="http://www.w3.org/1999/xhtml"> method when implementing the Template Method design pattern?</span></li>
<li><span class="koboSpan" id="kobo.511.1" xmlns="http://www.w3.org/1999/xhtml">Can we use the Strategy pattern in conjunction with the Template Method pattern?</span></li>
<li><span class="koboSpan" id="kobo.512.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that there is a limit of 32 handlers in a Chain of Responsibility?</span></li>
<li><span class="koboSpan" id="kobo.513.1" xmlns="http://www.w3.org/1999/xhtml">In a Chain of Responsibility, can multiple handlers process the same message?</span></li>
<li><span class="koboSpan" id="kobo.514.1" xmlns="http://www.w3.org/1999/xhtml">In what way can the Template Method help implement the Chain of Responsibility pattern?</span></li>
</ol>
</section>
<section class="level2" data-number="13.7" id="answers-8">
<h2 data-number="13.7"><span class="koboSpan" id="kobo.515.1" xmlns="http://www.w3.org/1999/xhtml">Answers</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.516.1" xmlns="http://www.w3.org/1999/xhtml">The Template Method pattern encapsulates an algorithm's outline in a base class while leaving some parts of that algorithm open for modification by its subclasses.</span></li>
<li><span class="koboSpan" id="kobo.517.1" xmlns="http://www.w3.org/1999/xhtml">The Chain of Responsibility pattern divides a larger problem into small pieces (handlers). </span><span class="koboSpan" id="kobo.517.2" xmlns="http://www.w3.org/1999/xhtml">Each piece is self-governed, while the chain's existence is abstracted from its consumers.</span></li>
<li><span class="koboSpan" id="kobo.518.1" xmlns="http://www.w3.org/1999/xhtml">False; you can create as many </span><code><span class="koboSpan" id="kobo.519.1" xmlns="http://www.w3.org/1999/xhtml">abstract</span></code><span class="koboSpan" id="kobo.520.1" xmlns="http://www.w3.org/1999/xhtml"> (required) or </span><code><span class="koboSpan" id="kobo.521.1" xmlns="http://www.w3.org/1999/xhtml">virtual</span></code><span class="koboSpan" id="kobo.522.1" xmlns="http://www.w3.org/1999/xhtml"> (optional) extension points (hooks) as you need.</span></li>
<li><span class="koboSpan" id="kobo.523.1" xmlns="http://www.w3.org/1999/xhtml">Yes, there is no reason not to.</span></li>
<li><span class="koboSpan" id="kobo.524.1" xmlns="http://www.w3.org/1999/xhtml">No, there is no greater limit than with any other code.</span></li>
<li><span class="koboSpan" id="kobo.525.1" xmlns="http://www.w3.org/1999/xhtml">Yes, you can have one handler per message or multiple handlers per message. </span><span class="koboSpan" id="kobo.525.2" xmlns="http://www.w3.org/1999/xhtml">It is up to you and your requirements.</span></li>
<li><span class="koboSpan" id="kobo.526.1" xmlns="http://www.w3.org/1999/xhtml">It helps divide responsibilities between classes by encapsulating the shared logic into one or more base classes.</span></li>
</ol>
</section>
</section>
</body>
</html>
