- en: Integration Techniques and Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成技术和微服务
- en: 'In the previous chapter, we developed microservices using a .NET monolithic
    application. These services are independent of each other and are located on different
    servers. What would be a better way to have inter-service communication, where
    one service interacts/communicates with the other? In this chapter, we will discuss
    the various patterns and methods that will help us foster this communication.
    We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用.NET单体应用程序开发了微服务。这些服务彼此独立，位于不同的服务器上。那么，有什么更好的方法来实现服务之间的交互/通信呢？在这一章中，我们将讨论各种模式和技巧，帮助我们促进这种通信。我们将涵盖以下主题：
- en: Communication between services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间的通信
- en: Styles of collaboration
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作风格
- en: Integration patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成模式
- en: The API gateway
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关
- en: The event-driven pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动模式
- en: Azure Service Bus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure服务总线
- en: Communication between services
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务之间的通信
- en: In the case of a .NET monolithic application, if there is a need to access third-party
    components or external services, we use the HTTP client or another client framework
    to access the resources. In[Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml),
    *Implementing Microservices*, we developed the **Product service** in such a way
    that it would work independently. But this was not the case; we mandatorily required
    a few services to interact with each other.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET单体应用程序的情况下，如果需要访问第三方组件或外部服务，我们使用HTTP客户端或另一个客户端框架来访问资源。在第2章《实现微服务》中，我们以独立工作的方式开发了**产品服务**。但情况并非如此；我们强制要求一些服务相互交互。
- en: So this is a challenge—having services communicate with each other. Both the **Product
    service** and **Order service** are hosted on separate servers. Both these servers
    are independent of each other, are based on **REST**, and have their own endpoints
    via which they communicate with each other (when a service interacts with another
    service and vice versa, we refer to it as an inter-service communication as well).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个挑战——让服务相互通信。**产品服务**和**订单服务**都托管在不同的服务器上。这两个服务器彼此独立，基于**REST**，并通过各自的端点相互通信（当服务与另一个服务交互时，我们称之为服务间通信）。
- en: 'There are ways in which services communicate with each other; let''s discuss
    them briefly:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 服务之间有几种通信方式；让我们简要地讨论一下：
- en: 'Synchronous: In this case, the client makes a request to the remote service
    (called a **service**) for a specific functionality and waits until it gets the
    response:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步：在这种情况下，客户端向远程服务（称为**服务**）请求特定功能，并等待直到收到响应：
- en: '![](img/296fffe7-bfbc-4fc5-9f22-def20a1251a3.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/296fffe7-bfbc-4fc5-9f22-def20a1251a3.png)'
- en: In the preceding diagram (pictorial view, not complete), you can see our different
    microservices communicate with each other. All our services are RESTful. They
    are based on the ASP.NET Core Web API. In the upcoming section, we will discuss
    in detail how exactly a service is called. This is known as the synchronous method,
    where clients have to wait for a response from the service. In this case, the
    client had to wait until it got a complete response.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中（图示视图，不完整），你可以看到我们的不同微服务正在相互通信。我们所有的服务都是RESTful的。它们基于ASP.NET Core Web
    API。在接下来的部分，我们将详细讨论服务是如何被调用的。这被称为同步方法，客户端必须等待来自服务的响应。在这种情况下，客户端必须等待直到收到完整的响应。
- en: 'Asynchronous: In this,'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步：在这种情况下，
- en: Styles of collaboration
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作风格
- en: 'In the preceding section, we discussed two different modes of how services
    intercommunicate. These modes are nothing but styles of collaborations, which
    are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了两种不同的服务间通信模式。这些模式不过是协作风格，具体如下：
- en: 'Request/response: In this case, the client sends a request and waits for the
    response from the server. This is an implementation of synchronous communication.
    But it is not true that request/response is only an implementation of synchronous
    communication; we can use it for asynchronous communication as well.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求/响应：在这种情况下，客户端发送一个请求并等待来自服务器的响应。这是一个同步通信的实现。但请求/响应并不只是同步通信的一种实现；我们也可以用它来进行异步通信。
- en: 'Let''s consider an example to understand the concept. In [Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml)*,* *Implementing
    Microservices*, we developed `ProductService`. This service has the `GetProduct` method,
    which is synchronous. The client has to wait for a response whenever it calls
    this method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个概念。在[第2章](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml)*，* *实现微服务*中，我们开发了`ProductService`服务。这个服务有一个`GetProduct`方法，它是同步的。客户端每次调用此方法时都必须等待响应：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As per the preceding code snippet, whenever this method is called by the client
    (who is requesting this), they will have to wait for the response. In other words,
    they will have to wait until the `ToViewModel()` extension method is executed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码片段，每当客户端（请求此服务的客户端）调用此方法时，他们必须等待响应。换句话说，他们必须等待`ToViewModel()`扩展方法执行完毕：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code snippet, we can see that our method is implemented in
    such a way that whenever a client makes a request, they will have to wait until
    the `async` method is executed. Here, we call `async` in the `sync` way.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到我们的方法是以这种方式实现的，即每当客户端发起请求时，他们必须等待`async`方法执行。在这里，我们以`sync`的方式调用`async`。
- en: 'To make our code short, we added extension methods to the already existing
    code written in [Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml), *Implementing
    Microservices*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更简洁，我们在[第2章](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml)中编写的*实现微服务*相关代码的基础上添加了扩展方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To sum up, we can say that the collaboration style request/response does not
    mean that it can be implemented only synchronously; we can use asynchronous calls
    for this as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以这样说，协作风格的请求/响应并不意味着它只能同步实现；我们也可以使用异步调用来实现。
- en: 'Event-based: The implementation of this collaborative style is purely asynchronous.
    This is a method of implementation in which clients that emit an event do not
    know exactly how to react.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的：这种协作风格的实现完全是异步的。这是一种实现方法，其中发出事件的客户端不知道如何确切地做出反应。
- en: 'In the preceding section, we discussed `ProductService` in a synchronous manner.
    Let''s look at an example of how users/customers can place an order; here is a pictorial
    overview of the functionality:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们以同步的方式讨论了`ProductService`。让我们看看用户/客户如何下订单的例子；以下是功能性的图示概述：
- en: '![](img/333b8129-c5f2-4f51-b29f-2a5b4119fac0.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/333b8129-c5f2-4f51-b29f-2a5b4119fac0.png)'
- en: 'The preceding diagram shows that the process of purchasing a book has a few
    main functions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了购买书籍的过程有几个主要功能：
- en: With the help of the search functionality, customers can find a specific book.
  id: totrans-31
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过搜索功能，客户可以找到特定的书籍。
- en: After getting the results for the searched book, customers can view the details
    of the book.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取搜索书籍的结果后，客户可以查看书籍的详细信息。
- en: As soon as they proceed to **Checkout**, our system will make sure that the
    display (available books to purchase) shows the right quantity. For example, the available
    quantity is 10 copies of *Microservices for .NET* and the customer checks out
    with one book. In this case, the available quantity should now show nine copies.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦用户进入**结账**环节，我们的系统将确保显示（可供购买的书本）显示正确的数量。例如，可供购买的数量是10本*微服务与.NET*，而顾客购买了一本书。在这种情况下，可供购买的数量现在应该显示为九本。
- en: The system will generate an invoice for the purchased book and send it to the customer,
    to their registered email.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统将为购买的书籍生成发票并发送给客户，发送到他们注册的电子邮件。
- en: 'Conceptually, this looks easy; however, when we talk about implementing microservices,
    we are talking about services that are hosted separately and have their own REST
    API, database, and so on. This is now sounding more complex. There are many aspects
    involved, for example, how a service will call or invoke another service upon
    a successful response from one or more services. This is where the event-driven
    architecture comes into the picture:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这似乎很简单；然而，当我们谈论实现微服务时，我们是在谈论那些分别托管并拥有自己的REST API、数据库等的服务。这听起来更复杂了。涉及到的方面很多，例如，一个服务如何在从一个或多个服务成功响应后调用或调用另一个服务。这就是事件驱动架构出现的地方：
- en: '![](img/d1af219a-eae1-4041-8674-bbdc855c2f58.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1af219a-eae1-4041-8674-bbdc855c2f58.png)'
- en: In the preceding diagram, we can see that **Invoice service** and **Product
    service** are triggered when **Order service** is executed. These services further
    call internal asynchronous methods to complete their functionalities.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到当 **订单服务** 执行时，会触发 **发票服务** 和 **产品服务**。这些服务进一步调用内部异步方法以完成其功能。
- en: We are using Azure API management as our API gateway. In the upcoming sections,
    we will discuss this in detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Azure API 管理作为我们的 API 网关。在接下来的部分中，我们将详细讨论这一点。
- en: Integration patterns
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成模式
- en: Until now, we have discussed inter-service communication and have gone through
    the practical implementation of `ProductService` with the use of synchronous and
    asynchronous communication. We've also implemented microservices using different
    styles of collaboration. Our *FlixOne bookstore* (developed as per the microservice
    architectural style) required more interaction, therefore it required more patterns.
    In this section, we will discuss the implementation of various integration patterns
    required for our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了服务间通信，并通过使用同步和异步通信实现了 `ProductService` 的实际实现。我们还使用不同的协作风格实现了微服务。我们的
    *FlixOne 书店*（按照微服务架构风格开发）需要更多的交互，因此需要更多的模式。在本节中，我们将讨论为我们的应用程序所需的集成模式的实现。
- en: The complete application of the *FlixOne bookstore* is available in [Chapter
    10](bcd6e14a-bd2b-4964-94f4-dcf93cc9d756.xhtml)*, Creating a Complete Microservice
    Solution.*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*FlixOne 书店*（按照微服务架构风格开发）的完整应用可在 [第 10 章](bcd6e14a-bd2b-4964-94f4-dcf93cc9d756.xhtml)
    *创建完整的微服务解决方案* 中找到。'
- en: The API gateway
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 网关
- en: 'In the *Styles of collaboration* section, we discussed two styles we can use
    to foster intercommunication between microservices. Our application is split into
    various microservices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *协作风格* 部分，我们讨论了我们可以用来促进微服务之间交互的两种风格。我们的应用程序被分割成各种微服务：
- en: Product service
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品服务
- en: Order service
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单服务
- en: Invoice service
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发票服务
- en: Customer service
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户服务
- en: 'In our *FlixOne bookstore* (user interface), we need to show a few details:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *FlixOne 书店*（用户界面）中，我们需要显示以下详细信息：
- en: Book title, author name, price, discount, and so on
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书名、作者姓名、价格、折扣等
- en: Availability
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Book reviews
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书评
- en: Book ratings
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍评分
- en: Publisher ranking and so on
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者排名等
- en: Before we check out the implementation, let's discuss the API gateway.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查实现之前，让我们先讨论 API 网关。
- en: The API gateway is nothing but an implementation of **Backend For Frontend**
    (**BFF**). Sam Newman introduced this pattern. It acts as a proxy between client
    applications and services. In our example, we are using **Azure API management**
    as our API gateway.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关不过是 **Backend For Frontend**（**BFF**）的实现。Sam Newman 介绍了这个模式。它充当客户端应用程序和服务之间的代理。在我们的例子中，我们使用
    **Azure API 管理作为我们的 API 网关**。
- en: 'It is responsible for the following functionalities:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它负责以下功能：
- en: Accepting API calls and routing them to your backends
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 API 调用并将它们路由到您的后端
- en: Verifying API keys, JWT tokens, and certificates
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 API 密钥、JWT 令牌和证书
- en: Supporting Auth through Azure AD and the OAuth 2.0 access token
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Azure AD 和 OAuth 2.0 访问令牌支持身份验证
- en: Enforcing usage quotas and rate limits
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行使用配额和速率限制
- en: Transforming your API on the fly without code modifications
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需代码修改即可动态转换您的 API
- en: Caching backend responses wherever they are set up
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置的地方缓存后端响应
- en: Logging call metadata for analytics purposes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分析目的记录调用元数据
- en: Refer to *Azure API management* ([https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx](https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx))
    to learn more about the process of setting up the API Azure portal and working
    with REST APIs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下链接了解有关设置 API Azure 门户和与 REST API 一起工作的更多过程：*Azure API 管理* ([https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx](https://social.technet.microsoft.com/wiki/contents/articles/31923.azure-create-and-deploy-asp-net-webapi-to-azure-and-manage-using-azure-api-management.aspx))。
- en: '![](img/7725c9c9-fe57-4d71-922c-f772ab138148.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7725c9c9-fe57-4d71-922c-f772ab138148.png)'
- en: In the preceding diagram, we have different clients, such as a mobile and desktop
    application and a web application, that are using microservices. Here, Azure API
    management is working as an API gateway.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到了不同的客户端，例如移动和桌面应用程序以及 Web 应用程序，它们正在使用微服务。在这里，Azure API 管理正在充当 API
    网关。
- en: Our client does not know the actual server in which our services are located.
    The API gateway provides them with the address of its own server, and internally,
    it authenticates the request from clients with the use of a valid `Ocp-Apim-Subscription-Key`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端不知道我们的服务实际位于哪个服务器。API 网关为他们提供了其自己服务器的地址，并且内部使用有效的 `Ocp-Apim-Subscription-Key`
    对客户端的请求进行身份验证。
- en: 'Our `ProductService` has a REST API. Refer to the following table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ProductService` 有一个 REST API。请参考以下表格：
- en: '| **API resource** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **API 资源** | **描述** |'
- en: '| `GET /api/product` | Gets a list of products |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `GET /api/product` | 获取产品列表 |'
- en: '| `GET /api/product{id}` | Gets a product |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `GET /api/product{id}` | 获取产品 |'
- en: '| `PUT /api/product{id}` | Updates an existing product |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `PUT /api/product{id}` | 更新现有产品 |'
- en: '| `DELETE /api/product{id}` | Deletes an existing product |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE /api/product{id}` | 删除现有产品 |'
- en: '| `POST /api/product` | Adds a new product |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `POST /api/product` | 添加新产品 |'
- en: 'We have already created `ProductClient`, a .NET console application. It makes
    a request to Azure API management bypassing the subscription key. Here is the
    code snippet for this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为 `ProductClient` 的 .NET 控制台应用程序。它通过绕过订阅密钥向 Azure API 管理发送请求。以下是该功能的代码片段：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, our client is requesting a REST API to get all the products.
    Here a brief description of the terms that appear in the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的客户端正在请求 REST API 以获取所有产品。以下是代码中出现的术语的简要说明：
- en: '| `BaseUrl` | This is the address of the proxy server. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `BaseUrl` | 这是代理服务器的地址。 |'
- en: '| `Ocp-Apim-Subscription-Key` | This is a key assigned by API management to
    a specific product the client has opted for. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Ocp-Apim-Subscription-Key` | 这是 API 管理为客户端选择的特定产品分配的密钥。 |'
- en: '| `Resource` | This is our API resource, which is configured over Azure API
    management. It will be different from our actual REST API resource. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `Resource` | 这是我们的 API 资源，它是在 Azure API 管理中配置的。它将不同于我们的实际 REST API 资源。 |'
- en: '| `Response` | This refers to the response to a specific request, in our case
    the default JSON format. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `Response` | 这指的是对特定请求的响应，在我们的案例中是默认的 JSON 格式。 |'
- en: 'Since we''re using Azure API management as an API gateway, there are certain
    benefits we''ll enjoy:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Azure API 管理作为 API 网关，我们将享受到某些好处：
- en: We can manage our various APIs from a single platform, for example, `ProductService`,
    `OrderService`, and other services can be easily managed and called by many clients
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从单个平台管理我们的各种 API，例如，`ProductService`、`OrderService` 以及其他服务可以轻松地被许多客户端管理和调用
- en: Because we're using API management, it does not only provide us with a proxy
    server, but also provides the facility to create and maintain documentation for
    our APIs
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用 API 管理，它不仅为我们提供了一个代理服务器，还提供了创建和维护我们 API 文档的便利性
- en: It provides a built-in facility to define various policies for quota, output
    formats, and format conversions, such as XML to JSON or vice versa
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个内置的设施来定义各种配额、输出格式和格式转换的策略，例如 XML 到 JSON 或相反
- en: So, with the help of the API gateway, we can have access to some great features.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，借助 API 网关，我们可以访问一些出色的功能。
- en: The event-driven pattern
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动模式
- en: 'The microservice architecture has the database per service pattern, which means
    it has an independent database for every dependent or independent service:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构具有每个服务一个数据库的模式，这意味着每个依赖或独立的服务都有自己的独立数据库：
- en: 'Dependent service: Our application would require a few external services (third-
    party services or components, and so on) and/or internal services (these are our
    own services) to work or function as expected. For instance, **CHECKOUT-SERVICE** requires **CUSTOMER-SERVICE**;
    also, **CHECKOUT-SERVICE** requires an external (third-party) service to verify
    a customer''s identity (such as Aadhaar card ID in the case of Indian customers).
    Here, our **CHECKOUT-SERVICE** is a dependent service, as it requires two services (an
    internal service and external service) to function as expected. Dependent services
    do not work if any or all the services on which the service is dependent on do
    not work properly (there are a lot of reasons a service would not work, including
    network failure, unhandled exception, and so on).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖服务：我们的应用程序需要一些外部服务（第三方服务或组件等）和/或内部服务（这些是我们自己的服务）才能按预期工作或运行。例如，**结账服务**需要**客户服务**；此外，**结账服务**需要外部（第三方）服务来验证客户的身份（例如，在印度客户的情况下，需要Aadhaar卡ID）。在这里，我们的**结账服务**是一个依赖服务，因为它需要两个服务（一个内部服务和外部服务）才能按预期工作。如果依赖的服务中的任何或所有服务工作不正常，依赖服务将无法工作（服务无法工作的原因有很多，包括网络故障、未处理的异常等）。
- en: 'Independent service: In our application, we have services that do not require
    any other service to work properly. Services that do not need any other service
    to work in order to function are called independent services; these services can
    be self-hosted. Our **CUSTOMER-SERVICE** does not require any other service to
    function properly, but other services may or may not require this service.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立服务：在我们的应用程序中，我们有一些服务不需要其他服务正常工作。不需要其他服务即可正常工作的服务被称为独立服务；这些服务可以自行托管。我们的**客户服务**不需要其他服务即可正常工作，但其他服务可能需要或不需要此服务。
- en: The main challenge is to maintain business transactions to ensure data consistency
    across these services. For instance, when and how **CUSTOMER-SERVICE** would know
    that **CHECKOUT-SERVICE** has functioned; now it requires the functionality of
    **CUSTOMER-SERVICE**. There may be several services in an application (services
    may be self-hosted). In our case, when **CHECKOUT-SERVICE** is triggered and **CUSTOMER-SERVICE** is
    not invoked, then how will our application identify the customer’s details?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 主要挑战是维护业务事务以确保这些服务之间的数据一致性。例如，何时以及如何**客户服务**知道**结账服务**已经工作；现在它需要**客户服务**的功能。一个应用程序中可能有几个服务（服务可能是自行托管的）。在我们的案例中，当**结账服务**被触发而**客户服务**未被调用时，我们的应用程序将如何识别客户的详细信息？
- en: ASP.NET WebHooks can also be used for providing event notifications; refer to
    the WebHooks documentation for more information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET WebHooks也可以用于提供事件通知；有关更多信息，请参阅WebHooks文档。
- en: To overcome the related problems/challenges we've discussed (for **CHECKOUT-SERVICE**
    and **CUSTOMER-SERVICE**), we can use an event-driven pattern (or the eventual
    consistency approach) and use distributed transactions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服我们讨论的相关问题/挑战（针对**结账服务**和**客户服务**），我们可以使用事件驱动模式（或最终一致性方法）并使用分布式事务。
- en: 'A document on MSDN ([https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx))
    says the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN上的文档（[https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681205(v=vs.85).aspx)）说明了以下内容：
- en: A distributed transaction is a transaction that updates data on two or more
    networked computer systems. Distributed transactions extend the benefits of transactions
    to applications that must update distributed data. Implementing robust distributed
    applications is difficult because these applications are subject to multiple failures,
    including failure of the client, the server, and the network connection between
    the client and server. In the absence of distributed transactions, the application
    program itself must detect and recover from these failures.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式事务是更新两个或更多网络化计算机系统上数据的交易。分布式事务将事务的好处扩展到必须更新分布式数据的应用程序。实现健壮的分布式应用程序很困难，因为这些应用程序容易受到多个故障的影响，包括客户端、服务器以及客户端和服务器之间的网络连接故障。在没有分布式事务的情况下，应用程序程序本身必须检测并从这些故障中恢复。
- en: 'The following diagram describes an actual implementation of the event-driven
    pattern in our application, where **PRODUCT-SERVICE** subscribes to the events
    and **Event-Manager** manages all the events:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了我们在应用程序中实际实现的事件驱动模式，其中 **PRODUCT-SERVICE** 订阅事件，**Event-Manager** 管理所有事件：
- en: '![](img/fa3994cc-83d1-4f0e-a417-5d72d06fe3f0.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa3994cc-83d1-4f0e-a417-5d72d06fe3f0.png)'
- en: In an event-driven pattern, we implement a service in such a way that it publishes
    an event whenever a service updates its data, and another service (dependent service)
    subscribes to this event. Now, whenever a dependent service receives an event,
    it updates its data. This way, our dependent services can get and update their
    data if required. The preceding diagram shows an overview of how services subscribe
    to and publish events. In the diagram, **Event-Manager** could be a program running
    on a service or a mediator helping you manage all the events of the subscribers
    and publishers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动模式中，我们以这种方式实现服务，即每当服务更新其数据时，它都会发布一个事件，另一个服务（依赖服务）订阅此事件。现在，每当依赖服务接收到事件时，它会更新其数据。这样，我们的依赖服务可以在需要时获取和更新其数据。以下图概述了服务如何订阅和发布事件。在图中，**Event-Manager**
    可以是运行在服务上的程序或帮助您管理所有订阅者和发布者事件的调解者。
- en: It registers an event of the **Publisher** and notifies a **Subscriber** whenever
    a specific event occurs/is triggered. It also helps you to form a queue and wait
    for events. In our implementation, we will use Azure Service Bus queues for this
    activity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它注册了 **Publisher** 的事件，并在特定事件发生/触发时通知 **Subscriber**。它还帮助您形成队列并等待事件。在我们的实现中，我们将使用
    Azure Service Bus 队列来完成这项活动。
- en: 'Let''s consider an example. In our application, this is how our services will publish
    and receive an event:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。在我们的应用程序中，我们的服务将这样发布和接收事件：
- en: '**CUSTOMER-SERVICE** performs a few checks for the users, namely login check,
    customer details check, and so on; after these necessary checks are conducted,
    the service publishes an event called `CustomerVerified`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CUSTOMER-SERVICE** 对用户执行一些检查，例如登录检查、客户详情检查等；在这些必要的检查完成后，服务会发布一个名为 `CustomerVerified`
    的事件。'
- en: '**CHECKOUT-SERVICE** receives this event and, after performing the necessary
    operations, it publishes an event called `ReadyToCheckout`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CHECKOUT-SERVICE** 接收此事件，并在执行必要的操作后，发布一个名为 `ReadyToCheckout` 的事件。'
- en: '**ORDER-SERVICE** receives this event and updates the quantity.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ORDER-SERVICE** 接收此事件并更新数量。'
- en: As soon as the checkout is performed, **CHECKOUT-SERVICE** publishes an event.
    Whatever result is received from the external service, either `CheckedoutSuccess`
    or `CheckedoutFailed`, it is used by **CHECKOUT-SERVICE**.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦完成结账，**CHECKOUT-SERVICE** 就会发布一个事件。无论从外部服务接收到的结果是什么，无论是 `CheckedoutSuccess`
    还是 `CheckedoutFailed`，它都会被 **CHECKOUT-SERVICE** 使用。
- en: When `InventoryService` receives these events, it updates the data to make sure
    the exact item is added or removed.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `InventoryService` 接收到这些事件时，它会更新数据以确保确切的项目被添加或删除。
- en: With the use of event-driven patterns, services can automatically update the
    database and publish an event.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件驱动模式，服务可以自动更新数据库并发布事件。
- en: Event sourcing
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源
- en: This pattern helps us ensure that the service will publish an event whenever
    the state changes. In this pattern, we take a business entity (product, customer,
    and so on) as a sequence of state-changing events. The **Event Store** persists
    the events and these events are available for subscription or as other services.
    This pattern simplifies our tasks by avoiding the requirement to synchronize the
    data model and the business domain. It improves performance, scalability, and
    responsiveness.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式帮助我们确保服务将在状态更改时发布事件。在此模式中，我们将业务实体（产品、客户等）视为一系列状态更改事件。**Event Store** 持久化事件，这些事件可用于订阅或作为其他服务。此模式通过避免同步数据模型和业务域的要求来简化我们的任务。它提高了性能、可扩展性和响应速度。
- en: This simply defines an approach indicating how we can handle the various operations
    on our data by a sequence of events; these events are recorded in a store.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只是简单地定义了一种方法，说明我们如何通过一系列事件来处理我们数据上的各种操作；这些事件记录在存储中。
- en: An event represents a set of changes made to the data, for example, `InvoiceCreated`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件代表对数据所做的更改集合，例如，`InvoiceCreated`。
- en: '![](img/83ac2541-af63-4f39-8f0b-498d655c9028.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83ac2541-af63-4f39-8f0b-498d655c9028.png)'
- en: 'The preceding diagram describes how an event would work for **ORDERSERVICE**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了事件在 **ORDERSERVICE** 上的工作方式：
- en: The commands issue a book from the **User Interface** to be ordered
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令从**用户界面**发出，以订购书籍
- en: '**ORDERSERVICE** queries (from the **Event Store**) and populates the results
    with the `CreateOrder` event'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ORDERSERVICE**（从**事件存储**）查询并使用`CreateOrder`事件填充结果'
- en: Then, the command handler raises an event to order the book
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，命令处理器引发一个事件来订购书籍
- en: Our service performs the related operations
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的服务执行相关操作
- en: Finally, the system appends the event to the event store
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，系统将事件附加到事件存储
- en: Eventual consistency
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终一致性
- en: Eventual consistency is nothing but an implementation of the data consistency
    approach. This suggests implementation, so the system would be a scalable system
    with high availability.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性不过是数据一致性方法的一种实现。这表明实现，因此系统将是一个具有高可用性的可扩展系统。
- en: 'A document on MSDN ([https://msdn.microsoft.com/en-us/library/dn589800.aspx](https://msdn.microsoft.com/en-us/library/dn589800.aspx))
    says the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN 上的文档（[https://msdn.microsoft.com/en-us/library/dn589800.aspx](https://msdn.microsoft.com/en-us/library/dn589800.aspx)）说明了以下内容：
- en: '"Eventual consistency is unlikely to be specified as an explicit requirement
    of a distributed system. Instead it is often a result of implementing a system
    that must exhibit scalability and high availability, which precludes most common
    strategies for providing strong consistency."'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “最终一致性不太可能被明确指定为分布式系统的显式要求。相反，它通常是实现必须展示可扩展性和高可用性的系统的一个结果，这排除了提供强一致性的大多数常见策略。”
- en: 'According to this distributed data, stores are subject to the CAP theorem.
    The CAP theorem is also known as Brewer''s theorem. **Consistency**, **Availability**,
    **(network) Partition tolerance** (**CAP**). According to this theorem, in a distributed
    system, we can only choose two out of these three:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些分布式数据存储，它们受到CAP定理的约束。CAP定理也被称为布赖尔定理。**一致性**、**可用性**、**（网络）分区容错**（**CAP**）。根据这个定理，在分布式系统中，我们只能从这三个中选择两个：
- en: Consistency
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性
- en: Availability
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Partition tolerance
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区容错
- en: Compensating transactions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补偿性事务
- en: Compensating transactions provides a way to roll back or undo all the tasks
    performed in a series of steps. Suppose one or more services have implemented
    operations in a series and one or more of them have failed. What would be your
    next step then? Would you reverse all the steps or commit to a half-completed
    functionality?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 补偿性事务提供了一种方法，可以回滚或撤销一系列步骤中执行的所有任务。假设一个或多个服务已经实施了一系列操作，其中之一或多个失败了。那么你的下一步是什么？你会撤销所有步骤还是提交一个半完成的特性？
- en: In our case, in which a customer orders a book and `ProductService` marks the
    ordered book as sold temporarily, after the confirmation of the order, `OrderService`
    calls an external service for completing the payment process. If the payment fails,
    we would need to undo our previous tasks, which means we will have to check `ProductService`
    so it will mark the specific book as unsold.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，当客户订购一本书并且`ProductService`暂时标记已订购的书籍后，在订单确认后，`OrderService`调用外部服务来完成支付过程。如果支付失败，我们需要撤销之前的任务，这意味着我们必须检查`ProductService`，以便它将特定书籍标记为未售出。
- en: Competing consumers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争消费者
- en: Competing consumers provides a way to process messages for multiple concurrent
    consumers, so they receive these messages on the same channel. This application
    is meant for handling a large number of requests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争消费者
- en: 'It can be implemented by passing a messaging system to another service (a consumer
    service), and it can be handled asynchronously, like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过将消息系统传递给另一个服务（消费者服务）来实现，并且可以异步处理，如下所示：
- en: '![](img/22642a53-34b3-4d54-8c41-cf4a622ce690.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22642a53-34b3-4d54-8c41-cf4a622ce690.png)'
- en: This scenario can be implemented with the use of Azure Service Bus queues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该场景可以通过使用 Azure Service Bus 队列来实现。
- en: Azure Service Bus
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Service Bus
- en: In the event-driven pattern, we discussed services publishing and subscribing
    events. We used an **Event-Manager** to manage all the events. In this section,
    we will see how Azure Service Bus manages events and provides the facility to
    work with microservices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动模式中，我们讨论了服务发布和订阅事件。我们使用**事件管理器**来管理所有事件。在本节中，我们将看到 Azure Service Bus 如何管理事件并提供与微服务一起工作的便利。
- en: 'Azure Service Bus is an information delivery service. It is used to make communication
    easier between two or more components/services. In our case, whenever services
    need to exchange information, they will communicate using this service. Azure
    Service Bus plays an important role here. There are two main types of service
    provided by Azure Service Bus:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Azure服务总线是一个信息传递服务。它用于使两个或更多组件/服务之间的通信更加容易。在我们的案例中，每当服务需要交换信息时，它们将通过此服务进行通信。Azure服务总线在这里发挥着重要作用。Azure服务总线提供两种主要的服务类型：
- en: Brokered communication: This service can also be called **hired service**. It
    works similarly to the postal service in the real world. Whenever a person wants
    to send messages/information, he/she can send a letter to another person. In this
    way, one can send various types of messages in the form of letters, packages,
    gifts, and so on. This type of messaging service ensures delivery of a message
    even when both the sender and receiver are not online at the same time. This is
    a messaging platform with components such as queues, topics, subscriptions, and
    so on.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介通信：此服务也可以称为**雇佣服务**。它的工作方式类似于现实世界中的邮政服务。每当一个人想要发送消息/信息时，他/她可以向另一个人发送一封信。这样，人们可以通过信件、包裹、礼物等形式发送各种类型的消息。这种消息服务确保即使在发送者和接收者不在同一时间在线的情况下，消息也能被传递。这是一个具有队列、主题、订阅等组件的消息平台。
- en: Non-brokered communication: This is similar to making a phone call. In this
    case, the caller (sender) calls a person (receiver) without any confirmation indicating
    whether he/she will answer the call or not. In this way, the sender sends information,
    and it purely depends on the receiver to receive the communication and pass the
    message back to the sender.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非中介通信：这类似于打电话。在这种情况下，呼叫者（发送者）给一个人（接收者）打电话，而不需要任何确认来表明他/她是否会接听电话。这样，发送者发送信息，而接收者是否接收通信并将信息传回发送者完全取决于接收者。
- en: 'Take a look at the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表：
- en: '![](img/ccf94a49-9fc8-4062-bae3-e9ddf4a8a767.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccf94a49-9fc8-4062-bae3-e9ddf4a8a767.png)'
- en: 'The documentation on Microsoft Azure ([https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions))
    says:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure 的文档（[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-fundamentals-hybrid-solutions)）说明：
- en: '"Service Bus is a multi-tenant cloud service, which means that the service
    is shared by multiple users. Each user, such as an application developer, creates
    a namespace, then defines the communication mechanisms she needs within that namespace."'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: “服务总线是一个多租户云服务，这意味着服务被多个用户共享。每个用户，例如应用程序开发者，都会创建一个命名空间，然后在那个命名空间内定义她需要的通信机制。”
- en: 'The preceding diagram is a pictorial view of Azure Service Bus and it depicts
    four different communication mechanisms. Everyone has their own taste in terms
    of which it connects application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是Azure服务总线的一个图形视图，它描绘了四种不同的通信机制。每个人在连接应用程序方面都有自己的喜好：
- en: 'Queues: These allow one-directional communication, and act as brokers.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列：这些允许单向通信，并充当经纪人。
- en: 'Topics: These provide one-directional communication where a single topic can
    have multiple subscriptions.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题：这些提供单向通信，一个主题可以有多个订阅。
- en: 'Relays: These provide bi-directional communication. They do not store messages
    (as queues and topics do). Relays pass messages to the destination application.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中继：这些提供双向通信。它们不存储消息（如队列和主题所做的那样）。中继将消息传递到目标应用程序。
- en: Azure queues
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure队列
- en: Azure queues are nothing but cloud storage accounts that use Azure Table. They
    provide a way to queue a message between applications. In the upcoming sections,
    we will implement message queues, which is part of Azure Service Bus.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Azure队列实际上就是使用Azure表的云存储账户。它们提供了一种在应用程序之间排队消息的方法。在接下来的章节中，我们将实现消息队列，这是Azure服务总线的一部分。
- en: Implementing an Azure Service Bus queue
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Azure服务总线队列
- en: 'In this section, we will look at the actual implementation of an Azure Service
    Bus queue by creating the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建以下内容来查看Azure服务总线队列的实际实现：
- en: A Service Bus namespace
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务总线命名空间
- en: A Service Bus messaging queue
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务总线消息队列
- en: A console application to send a message to
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于发送消息的控制台应用程序
- en: A console application to receive a message
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于接收消息的控制台应用程序
- en: Prerequisites
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'We need the following to implement this solution:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下内容来实现此解决方案：
- en: Visual Studio 2017 update 3 or later
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017更新3或更高版本
- en: A valid Azure subscription
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的Azure订阅
- en: If you do not have an Azure subscription, you can get it for free by signing
    in here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有Azure订阅，可以通过在此处登录免费获取：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: 'If you have everything mentioned, you can start by following these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您拥有上述所有内容，您可以从以下步骤开始：
- en: Log on to the Azure portal ([https://portal.azure.com/](https://portal.azure.com/)).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Azure门户([https://portal.azure.com/](https://portal.azure.com/))。
- en: In the left navigation bar, click on Service Bus. If unavailable, you can find
    it by clicking on More Services.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航栏中，点击“服务总线”。如果不可用，可以通过点击“更多服务”来找到它。
- en: 'Click on Add:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加”：
- en: '![](img/71213eda-bd77-4603-9eb7-431638542d09.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71213eda-bd77-4603-9eb7-431638542d09.png)'
- en: 'In the Create namespace dialog, enter a namespace, say, `flixone`. Select the
    pricing tier next: `Basic`, `Standard`, or `Premium`.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“创建命名空间”对话框中，输入一个命名空间，例如，`flixone`。选择下一个定价层：`基本`、`标准`或`高级`。
- en: Select your Subscription.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的订阅。
- en: Choose an existing resource or create a new one.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个现有资源或创建一个新的资源。
- en: Select the location where you want to host the namespace.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要托管命名空间的位置。
- en: Open a newly created namespace (we just created `flixone`).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新创建的命名空间（我们刚刚创建了`flixone`）。
- en: Now click on Shared access policies.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击“共享访问策略”。
- en: 'Click on RootManageSharedAccessKey. Refer to the following screenshot:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“根管理共享访问密钥”。请参考以下截图：
- en: '![](img/f73bc19a-6d5c-400c-b757-89ba34977789.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f73bc19a-6d5c-400c-b757-89ba34977789.png)'
- en: Click on Queues in the main dialog of the `flixone` namespace.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`flixone`命名空间的“主对话框”中点击“队列”。
- en: 'From the Policy: RootManageSharedAccessKey window, note the primary key connection
    string for further use. Refer to the following screenshot:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“根管理共享访问密钥”窗口中，注意主密钥连接字符串以供进一步使用。请参考以下截图：
- en: '![](img/10cf14b5-942d-4621-ae5b-d3f4fec8e090.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10cf14b5-942d-4621-ae5b-d3f4fec8e090.png)'
- en: 'Click on Name to add a queue (say, `flixonequeue`), and click on Create (we''re
    using REST values as default values). Refer to the following screenshot:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“名称”以添加一个队列（例如，`flixonequeue`），然后点击“创建”（我们使用默认的REST值）。请参考以下截图：
- en: '![](img/011610d4-9e56-4b85-80b9-7990d89dc4cd.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/011610d4-9e56-4b85-80b9-7990d89dc4cd.png)'
- en: The preceding image is of Create Queue dialog. In the Create Queue dialog we
    can create a queue for example in above image we are creating a queue with the
    name of floxonequeue. Queues can be verified by visiting the Queues dialog.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片是创建队列对话框。在创建队列对话框中，我们可以创建一个队列，例如，在上面的图片中，我们正在创建一个名为floxxonequeue的队列。可以通过访问队列对话框来验证队列。
- en: Now we are ready to create our sender and receiver applications for messages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已准备好创建我们的消息发送者和接收者应用程序。
- en: Sending messages to the queue
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向队列发送消息
- en: 'In this section, we will create a console application that will actually send
    messages to the queue. To create this application, follow these steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个控制台应用程序，该程序实际上会向队列发送消息。要创建此应用程序，请按照以下步骤操作：
- en: 'Create a new console application and name it `FlixOne.BookStore.MessageSender` using
    Visual Studio''s new project (C#) template:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Visual Studio的新项目（C#）模板创建一个新的控制台应用程序，并将其命名为`FlixOne.BookStore.MessageSender`：
- en: '![](img/e272b2c4-8ecb-42f6-9eca-95c30afc5974.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e272b2c4-8ecb-42f6-9eca-95c30afc5974.png)'
- en: Add the NuGet package Microsoft Azure Service Bus by right-clicking on the project.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目上右键单击添加NuGet包Microsoft Azure Service Bus。
- en: 'Write the code to send the message to the queue, and your `Program.cs` file
    will contain the following `MainAsync()` method:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以向队列发送消息，您的`Program.cs`文件将包含以下`MainAsync()`方法：
- en: '[PRE4]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we are creating our queue client by providing `ConnectionString`
    and `QueueName` that we have already set in our Azure portal. It calls the `SendMessagesAsync()`
    method that accepts a parameter containing the count of the number of messages
    needed to be sent.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过提供`ConnectionString`和`QueueName`来创建我们的队列客户端，这些我们在Azure门户中已经设置。它调用接受包含需要发送的消息数量的参数的`SendMessagesAsync()`方法。
- en: 'Create a `SendMessagesAsync()` method and add the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`SendMessagesAsync()`方法，并添加以下代码：
- en: '[PRE5]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the program and wait for a while. You will get the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并等待一段时间。您将得到以下结果：
- en: '![](img/82510dd4-ecba-4221-adfb-32e32a171306.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82510dd4-ecba-4221-adfb-32e32a171306.png)'
- en: Go to the Azure portal and then go to the created queue to check whether it
    displays a message. The below image is showing overview of flixonequeue where
    we can see Active Message Count etc.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Azure 门户，然后转到创建的队列，检查是否显示消息。以下图像显示了 flixonequeue 的概述，我们可以看到活动消息计数等。
- en: '![](img/5dc0366b-bb78-4c9c-abec-09dcaeb2c909.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dc0366b-bb78-4c9c-abec-09dcaeb2c909.png)'
- en: Adding configuration settings
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置设置
- en: In the previous example, we used constant values for both `ConnectionString`
    and `QueueName`. If we need to change these settings, we have to make changes
    to the code. But why should we make code changes for this small change? To overcome
    this situation, we have configuration settings. You can learn more about configuration
    at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration).
    In this section, we will add configurations with the help of the `IConfigurationRoot`
    of the `Microsoft.Extensions.Configuration` namespace.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们为 `ConnectionString` 和 `QueueName` 两个都使用了常量值。如果我们需要更改这些设置，我们必须修改代码。但为什么我们要为了这个小小的更改而修改代码呢？为了克服这种情况，我们有配置设置。您可以在
    [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration)
    中了解更多关于配置的信息。在本节中，我们将使用 `Microsoft.Extensions.Configuration` 命名空间中的 `IConfigurationRoot`
    添加配置。
- en: 'First of all, right-click on the project and click on Manage NuGet packages.
    Search for the `Microsoft.Extensions.Configuration` NuGet package. Refer to the
    following screenshot:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，右键单击项目，然后单击管理 NuGet 包。搜索 `Microsoft.Extensions.Configuration` NuGet 包。参考以下截图：
- en: '![](img/15c3fa44-c91d-4eae-806b-7c0dd52655b1.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15c3fa44-c91d-4eae-806b-7c0dd52655b1.png)'
- en: 'Now, locate and search for the `Microsoft.Extensions.Configuration.Json` NuGet
    package. Refer to the following screenshot:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定位并搜索 `Microsoft.Extensions.Configuration.Json` NuGet 包。参考以下截图：
- en: '![](img/7a9e843d-06bf-4de0-b9d6-507243a81bac.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a9e843d-06bf-4de0-b9d6-507243a81bac.png)'
- en: 'Add the following `ConfigureBuilder()` method to the `Program.cs` file:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `ConfigureBuilder()` 方法添加到 `Program.cs` 文件中：
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, add the `appsettings.json` file to the project, and the following properties:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `appsettings.json` 文件添加到项目中，并包含以下属性：
- en: '[PRE7]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code to the `main()` method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main()` 方法中：
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After adding the preceding code, we added a way to get the `connectionstring`
    and `queuename` from the `.json` file. Now, if we need to change any of these
    fields, we do not need to make changes to the code files.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加前面的代码后，我们添加了一种从 `.json` 文件中获取 `connectionstring` 和 `queuename` 的方法。现在，如果我们需要更改这些字段中的任何一个，我们不需要修改代码文件。
- en: Receiving messages from the queue
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收队列中的消息
- en: 'In this section, we will create a console application that will receive messages
    from the queue. To create this application, follow these steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个控制台应用程序，该程序将从队列中接收消息。要创建此应用程序，请按照以下步骤操作：
- en: Create a new console application (C#) and name it `FlixOne.BookStore.MessageReceiver`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序（C#），并将其命名为 `FlixOne.BookStore.MessageReceiver`。
- en: Add the NuGet package for Azure Service Bus (as added in the previous application).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Azure Service Bus 的 NuGet 包（如前一个应用程序中添加的）。
- en: 'Write the code to receive messages from the Azure Bus Service queue, so your
    `program.cs` file contains the method `ProcessMessagesAsync()`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写从 Azure Bus 服务队列接收消息的代码，因此您的 `program.cs` 文件包含 `ProcessMessagesAsync()` 方法：
- en: '[PRE9]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the application and look at the result. Refer to the following screenshot:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并查看结果。参考以下截图：
- en: '![](img/3f1c2b74-34a0-425f-a02f-83af7f56e1f5.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f1c2b74-34a0-425f-a02f-83af7f56e1f5.png)'
- en: 'The console window will display the message and its ID. Now, go to the Azure
    portal and verify the message. It should be zero. Refer to the following screenshot:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台窗口将显示消息及其 ID。现在，前往 Azure 门户并验证消息。它应该是零。参考以下截图：
- en: '![](img/75afb60c-ebb1-45e2-9e9e-5d376a0966b0.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75afb60c-ebb1-45e2-9e9e-5d376a0966b0.png)'
- en: The preceding example demonstrates how we can use the Azure Bus Service to send/receive
    messages for our microservices.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了如何使用 Azure Bus 服务为我们微服务发送/接收消息。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Inter-service communication is possible with synchronous or asynchronous communication,
    which are styles of collaboration. Microservices should have asynchronous APIs.
    The API gateway is a proxy server that provides a way to allow various clients
    to interact with APIs. API management, as an API gateway, provides plenty of features
    to manage/host various RESTful APIs. There are various patterns that help us communicate
    with microservices. With the use of Azure Bus Service, we can easily manage and
    play with inter-service communication using the Azure Bus Service message queue;
    services can easily send or receive messages between themselves through this.
    Eventual consistency talks about scalable systems with high scalability, and it
    is proven by the CAP theorem.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的间通信可以通过同步或异步通信实现，这些是协作的风格。微服务应该拥有异步API。API网关是一个代理服务器，它提供了一种允许各种客户端与API交互的方式。API管理，作为一个API网关，提供了许多功能来管理/托管各种RESTful
    API。存在各种模式帮助我们与微服务进行通信。通过使用Azure总线服务，我们可以轻松地管理和玩转服务间的通信，使用Azure总线服务的消息队列；服务可以通过这种方式轻松地相互发送或接收消息。最终一致性讨论的是具有高可扩展性的可伸缩系统，并且这一点通过CAP定理得到了证明。
- en: In the next chapter, we will discuss various testing strategies to test an application
    and build on the microservice architectural style.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论各种测试策略来测试应用程序，并基于微服务架构风格进行构建。
