<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.2.1">Building Resilient Microservices</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Coming off the heels of the Saga pattern, we can appreciate the value of having fail-safes built into our microservices application. </span><span class="koboSpan" id="kobo.3.2">We need to ensure that we adequately handle inevitable failures.</span></p>
<p><span class="koboSpan" id="kobo.4.1">We can’t assume that our distributed microservices will always be up and running. </span><span class="koboSpan" id="kobo.4.2">We also can’t assume that our supporting infrastructure will be reliable. </span><span class="koboSpan" id="kobo.4.3">These considerations lead us down a path where we must anticipate the occurrence of failures, whether prolonged or transient.</span></p>
<p><span class="koboSpan" id="kobo.5.1">A prolonged outage can be due to a downed server or service, some generally important part of the infrastructure. </span><span class="koboSpan" id="kobo.5.2">These tend to be easier to detect and mitigate since they have a more obvious impact on the runtime of the application. </span><span class="koboSpan" id="kobo.5.3">Transient failures are far more difficult to detect since they can last a few seconds to a few minutes at a time and aren’t usually tied to any obvious issue in the infrastructure. </span><span class="koboSpan" id="kobo.5.4">Something as simple as a service taking 5 seconds extra to respond can be seen as a transient failure.</span></p>
<p><span class="koboSpan" id="kobo.6.1">It is very important that we not only write code that doesn’t break the application because of a transient issue but also know when to break that application when we have a more serious failure. </span><span class="koboSpan" id="kobo.6.2">This is an important part of gauging the user’s experience with our application.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will look at various scenarios and countermeasures that we can implement when navigating possible failures in our microservices architecture.</span></p>
<p><span class="koboSpan" id="kobo.8.1">After reading this chapter, we will understand how to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Build resilient microservice communication</span></li>
<li><span class="koboSpan" id="kobo.10.1">Implement a caching layer</span></li>
<li><span class="koboSpan" id="kobo.11.1">Implement retry and circuit breaker policies</span></li>
</ul>
<h1 id="_idParaDest-135"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">Code references used in this chapter can be found in the project repository, which is hosted on GitHub at this URL: </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09"><span class="koboSpan" id="kobo.14.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09</span></a><span class="koboSpan" id="kobo.15.1">.</span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.16.1">The importance of service resiliency</span></h1>
<p><span class="koboSpan" id="kobo.17.1">Before we get into</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.18.1"> technical explanations, let us try to understand what it means to be resilient. </span><span class="koboSpan" id="kobo.18.2">The word </span><em class="italic"><span class="koboSpan" id="kobo.19.1">resilient</span></em><span class="koboSpan" id="kobo.20.1"> is the base word for </span><em class="italic"><span class="koboSpan" id="kobo.21.1">resiliency</span></em><span class="koboSpan" id="kobo.22.1">, and it refers to how impervious an entity is to negative factors. </span><span class="koboSpan" id="kobo.22.2">It refers to how well an entity reacts to an inevitable failure and how well an entity can resist future failures.</span></p>
<p><span class="koboSpan" id="kobo.23.1">In the context of our microservices architecture, our entities are our services, and we know that failures will happen. </span><span class="koboSpan" id="kobo.23.2">A failure can be as simple as a timeout during an internal operation, a loss of communication, or an unexpected outage of an important resource for the service.</span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.24.1">Possible failure scenarios and how to handle them</span></h2>
<p><span class="koboSpan" id="kobo.25.1">Using the</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.26.1"> example of our healthcare booking system, let us say that our appointments service needs to retrieve the details of the related patient. </span><span class="koboSpan" id="kobo.26.2">The </span><em class="italic"><span class="koboSpan" id="kobo.27.1">appointments service</span></em><span class="koboSpan" id="kobo.28.1"> will make a synchronous HTTP call to the </span><em class="italic"><span class="koboSpan" id="kobo.29.1">patients service</span></em><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">The steps in this communication step may look like this:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.31.1">The </span><em class="italic"><span class="koboSpan" id="kobo.32.1">appointments service</span></em><span class="koboSpan" id="kobo.33.1"> makes an HTTP request to the </span><em class="italic"><span class="koboSpan" id="kobo.34.1">patients service</span></em><span class="koboSpan" id="kobo.35.1">, passing the patient ID (</span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">AppointmentsController.cs</span></strong><span class="koboSpan" id="kobo.37.1">).</span></li>
<li><span class="koboSpan" id="kobo.38.1">The </span><em class="italic"><span class="koboSpan" id="kobo.39.1">patients service</span></em><span class="koboSpan" id="kobo.40.1"> receives the HTTP request and executes a query to look up the patient’s record (</span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">PatientsController.cs</span></strong><span class="koboSpan" id="kobo.42.1">).</span></li>
<li><span class="koboSpan" id="kobo.43.1">The </span><em class="italic"><span class="koboSpan" id="kobo.44.1">patients service</span></em><span class="koboSpan" id="kobo.45.1"> responds to the </span><em class="italic"><span class="koboSpan" id="kobo.46.1">appointment booking service</span></em><span class="koboSpan" id="kobo.47.1"> with the appropriate data.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.48.1">So far, we have come to expect this from our </span><em class="italic"><span class="koboSpan" id="kobo.49.1">synchronous service</span></em><span class="koboSpan" id="kobo.50.1"> communication flow. </span><span class="koboSpan" id="kobo.50.2">This, however, is the ideal flow where everything works as expected, and based on your infrastructure, you can guarantee a certain degree of success each time. </span><span class="koboSpan" id="kobo.50.3">What we need to account for is the balance—the few times that the flow might get interrupted and not complete the chain of operations successfully. </span><span class="koboSpan" id="kobo.50.4">It could be because of a failure, or maybe we just need a little more time. </span><span class="koboSpan" id="kobo.50.5">It could also be that we need to cut the call short because it is taking too long.</span></p>
<p><span class="koboSpan" id="kobo.51.1">Now, let us review the same kind of service call where something fails along the way:</span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.52.1">The </span><em class="italic"><span class="koboSpan" id="kobo.53.1">patients service</span></em><span class="koboSpan" id="kobo.54.1"> makes an HTTP request to the </span><em class="italic"><span class="koboSpan" id="kobo.55.1">appointment booking service</span></em><span class="koboSpan" id="kobo.56.1">, passing the patient ID.</span></li>
<li><span class="koboSpan" id="kobo.57.1">The </span><em class="italic"><span class="koboSpan" id="kobo.58.1">appointment booking service</span></em><span class="koboSpan" id="kobo.59.1"> responds with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">BAD GATEWAY (502)</span></strong><span class="koboSpan" id="kobo.61.1"> error code.</span></li>
<li><span class="koboSpan" id="kobo.62.1">The </span><em class="italic"><span class="koboSpan" id="kobo.63.1">patients service</span></em><span class="koboSpan" id="kobo.64.1"> throws an exception immediately when given the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">BAD GATEWAY</span></strong><span class="koboSpan" id="kobo.66.1"> response.</span></li>
<li><span class="koboSpan" id="kobo.67.1">The user receives an error message.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.68.1">In this situation, we received a premature termination of the appointment booking service call. </span><span class="koboSpan" id="kobo.68.2">HTTP responses in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">5xx</span></strong><span class="koboSpan" id="kobo.70.1"> range indicate that there is an issue with the resource or server associated with the appointment booking service. </span><span class="koboSpan" id="kobo.70.2">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">5xx</span></strong><span class="koboSpan" id="kobo.72.1"> errors may be temporary, and an immediate follow-up request would work. </span><span class="koboSpan" id="kobo.72.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">BAD GATEWAY</span></strong><span class="koboSpan" id="kobo.74.1"> error, specifically, can be due to poor server configuration, proxy server outage, or a simple response to one too many requests at that moment.</span></p>
<p><span class="koboSpan" id="kobo.75.1">In addressing these issues, sometimes we can retry the requests, or have an alternative data source on standby. </span><span class="koboSpan" id="kobo.75.2">While we will be discussing retry logic later in the book, we explore using</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.76.1"> some form of caching layer that allows us to maintain a stable data layer from which we can pull the information we require.</span></p>
<p><span class="koboSpan" id="kobo.77.1">Let us review how we can implement a caching layer to assist with this.</span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.78.1">Implementing resiliency with caching and message brokers</span></h1>
<p><span class="koboSpan" id="kobo.79.1">We will be diving into how we can make our services</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.80.1"> resilient using </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">retry policies</span></strong><span class="koboSpan" id="kobo.82.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">circuit breaker pattern</span></strong><span class="koboSpan" id="kobo.84.1">, but </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.85.1">we are not limited to these methods in our microservices architecture. </span><span class="koboSpan" id="kobo.85.2">We can help to support service resiliency using </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">caching</span></strong><span class="koboSpan" id="kobo.87.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">message broker</span></strong><span class="koboSpan" id="kobo.89.1"> mechanisms. </span><span class="koboSpan" id="kobo.89.2">Adding a caching layer allows us to create a temporary intermediary data store, which becomes useful when we are attempting to retrieve data from a service that is offline at the moment. </span><span class="koboSpan" id="kobo.89.3">Our message brokers help to ensure that messages will get delivered, which is mostly useful for write operations.</span></p>
<p><span class="koboSpan" id="kobo.90.1">Let us discuss message brokers and how they help us with our resiliency.</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.91.1">Using a message broker</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.92.1">Message brokers</span></strong><span class="koboSpan" id="kobo.93.1"> have a </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.94.1">higher guarantee of data </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.95.1">delivery, which increases resiliency. </span><span class="koboSpan" id="kobo.95.2">This is built on the foundation that the message broker will not be unavailable for an extended period, but once a message is placed on the message bus, it will not matter if the listening service(s) is not online. </span><span class="koboSpan" id="kobo.95.3">As we discussed earlier, we can almost guarantee that data will be posted successfully through asynchronous communication, since message brokers are designed to retain the information until it is consumed.</span></p>
<p><span class="koboSpan" id="kobo.96.1">Message brokers also support retry logic where if a message is not processed successfully for whatever reason, it is returned to the queue for processing later. </span><span class="koboSpan" id="kobo.96.2">We want to manage the number of message delivery retries, so we should configure our message broker to transfer a</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.97.1"> message to a </span><em class="italic"><span class="koboSpan" id="kobo.98.1">dead-letter</span></em><span class="koboSpan" id="kobo.99.1"> queue, where </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.100.1">we store </span><em class="italic"><span class="koboSpan" id="kobo.101.1">poisoned</span></em><span class="koboSpan" id="kobo.102.1"> messages.</span></p>
<p><span class="koboSpan" id="kobo.103.1">We also need to consider how we handle message duplications. </span><span class="koboSpan" id="kobo.103.2">This could happen if we send a message to the queue that does not get processed immediately for some reason, and then the message gets sent to the queue again from a retry. </span><span class="koboSpan" id="kobo.103.3">This would result in the same message in the queue twice and not necessarily in the correct order, or one behind the other. </span><span class="koboSpan" id="kobo.103.4">We must ensure that our messages contain enough information to allow us to adequately develop redundancy checks in our message consumers.</span></p>
<p><span class="koboSpan" id="kobo.104.1">We explored integrating with message brokers in earlier chapters as we discussed asynchronous communication between services. </span><span class="koboSpan" id="kobo.104.2">Now, let us explore implementing a caching layer.</span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.105.1">Using a caching layer</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.106.1">Caching</span></strong><span class="koboSpan" id="kobo.107.1"> can </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.108.1">be a valuable part of the resiliency </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.109.1">strategy. </span><span class="koboSpan" id="kobo.109.2">We can incorporate a caching strategy where we fall back on this cache if a service is offline. </span><span class="koboSpan" id="kobo.109.3">This means that we can use the caching layer as a fallback data source and create an illusion to the end user that all services are up and running. </span><span class="koboSpan" id="kobo.109.4">This cache would get periodically updated and maintained each time data is modified in the database of the source service. </span><span class="koboSpan" id="kobo.109.5">This will help with keeping the cached data fresh.</span></p>
<p><span class="koboSpan" id="kobo.110.1">Of course, with this strategy, we need to accept the implications of having potentially stale data. </span><span class="koboSpan" id="kobo.110.2">If the source service is offline and the supporting database is being updated (possibly by other jobs), then the cache will eventually become a stale data source. </span><span class="koboSpan" id="kobo.110.3">The more measures we put in place to ensure its freshness, the more complexity we introduce to our application.</span></p>
<p><span class="koboSpan" id="kobo.111.1">Notwithstanding the potential pros and cons of adding a caching layer, we can see where it will be a great addition to our microservices application and reduce the number of errors that a user might see, stemming from transient and even longer-term failures.</span></p>
<p><span class="koboSpan" id="kobo.112.1">The most effective way to implement a caching layer is as a distributed cache. </span><span class="koboSpan" id="kobo.112.2">This means that all systems in the architecture will be able to access the central cache, which exists as an external and standalone service. </span><span class="koboSpan" id="kobo.112.3">This implementation can increase speed and support </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.113.1">scaling. </span><span class="koboSpan" id="kobo.113.2">We can use Redis Cache as</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.114.1"> our distributed cache technology, and we will investigate how we can integrate this into an ASP.NET Core application.</span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.115.1">Using Redis Cache</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.116.1">Redis Cache</span></strong><span class="koboSpan" id="kobo.117.1"> is a</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.118.1"> popular caching database</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.119.1"> technology. </span><span class="koboSpan" id="kobo.119.2">It is an open source in-memory data store that can also be used as a message broker. </span><span class="koboSpan" id="kobo.119.3">It can be implemented on a local machine for local development efforts but is also at times deployed on a central server for more distributed systems. </span><span class="koboSpan" id="kobo.119.4">Redis Cache is a key-value store that uses a unique key to index a value, and no two values can have the same key. </span><span class="koboSpan" id="kobo.119.5">This makes it very easy to store and retrieve data from this type of data store. </span><span class="koboSpan" id="kobo.119.6">In addition to that, values may be stored in very simple data types such as strings, numbers, and lists, but JSON format is popularly used for more complex object types. </span><span class="koboSpan" id="kobo.119.7">This way, we can serialize and deserialize this string in our code and proceed as needed.</span></p>
<p><span class="koboSpan" id="kobo.120.1">There is also extensive support for Redis Cache on cloud providers such as Microsoft Azure</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.121.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.123.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.124.1">AWS</span></strong><span class="koboSpan" id="kobo.125.1">). </span><span class="koboSpan" id="kobo.125.2">For this exercise, you may install the Redis Cache locally, or use a </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Docker</span></strong><span class="koboSpan" id="kobo.127.1"> container. </span><span class="koboSpan" id="kobo.127.2">To start using Redis Cache in our project, we need to run the following command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.128.1">
dotnet add package Microsoft.Extensions.Caching
  .StackExchangeRedis</span></pre>
<p><span class="koboSpan" id="kobo.129.1">We then need to register our cache in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">Program.cs</span></strong><span class="koboSpan" id="kobo.131.1"> file, like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
// Register the RedisCache service
services.AddStackExchangeRedisCache(options =&gt;
{
    options.Configuration = "Configuration.GetSection
        ("Redis")["ConnectionString"]
});</span></pre>
<p><span class="koboSpan" id="kobo.133.1">You may configure your connection string in either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.135.1"> file or in application secrets. </span><span class="koboSpan" id="kobo.135.2">It will look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.136.1">
"Redis": {
  "ConnectionString": "CONNECTION_STRING_HERE"
}</span></pre>
<p><span class="koboSpan" id="kobo.137.1">These steps add caching support to our application. </span><span class="koboSpan" id="kobo.137.2">Now, we can read from and write to the cache as needed in our application. </span><span class="koboSpan" id="kobo.137.3">Generally, we want to write to the cache when data is</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.138.1"> augmented. </span><span class="koboSpan" id="kobo.138.2">New data should be written to</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.139.1"> the cache—we can remove the old version and create a new version for modified data; for deleted data, we also delete the data from the cache.</span></p>
<p><span class="koboSpan" id="kobo.140.1">We can create a singular </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">CacheProvider</span></strong><span class="koboSpan" id="kobo.142.1"> interface and implementation as a wrapper around our desired cache operations. </span><span class="koboSpan" id="kobo.142.2">Our interface will look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
public interface ICacheProvider
{
    Task ClearCache(string key);
    Task&lt;T&gt; GetFromCache&lt;T&gt;(string key) where T : class;
    Task SetCache&lt;T&gt;(string key, T value,
      DistributedCacheEntryOptions options) where T :
        class;
}</span></pre>
<p><span class="koboSpan" id="kobo.144.1">Our</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.145.1"> implementation looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
public class CacheProvider : ICacheProvider
{
    private readonly IDistributedCache _cache;
    public CacheProvider(IDistributedCache cache)
    {
        _cache = cache;
    }
    public async Task&lt;T&gt; GetFromCache&lt;T&gt;(string key) where
        T : class
    {
        var cachedResponse = await
            _cache.GetStringAsync(key);
        return cachedResponse == null ? </span><span class="koboSpan" id="kobo.146.2">null :
            JsonSerializer.Deserialize&lt;T&gt;(cachedResponse);
    }
    public async Task SetCache&lt;T&gt;(string key, T value,
        DistributedCacheEntryOptions options) where T :
            class
    {
        var response = JsonSerializer.Serialize(value);
        await _cache.SetStringAsync(key, response,
            options);
    }
    public async Task ClearCache(string key)
    {
        await _cache.RemoveAsync(key);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.147.1">This code allows us to interact with our distributed caching service and retrieve, set, or remove values based on their associated key. </span><span class="koboSpan" id="kobo.147.2">This service can be registered in our </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">inversion of control</span></strong><span class="koboSpan" id="kobo.149.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.150.1">IoC</span></strong><span class="koboSpan" id="kobo.151.1">) container</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.152.1"> and injected into our controllers and repositories as needed.</span></p>
<p><span class="koboSpan" id="kobo.153.1">The idea here is that we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">GetFromCache</span></strong><span class="koboSpan" id="kobo.155.1"> method when we need to read the values from the cache. </span><span class="koboSpan" id="kobo.155.2">The key allows us to narrow down to the entry we are interested in, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">T</span></strong><span class="koboSpan" id="kobo.157.1"> generic parameter allows us to define the desired data type. </span><span class="koboSpan" id="kobo.157.2">If we need to update the data in the cache, we can clear the cache record associated with the appropriate key and then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">SetCache</span></strong><span class="koboSpan" id="kobo.159.1"> to place new data with an associated key. </span><span class="koboSpan" id="kobo.159.2">We will parse the new data to JSON to ensure that we do not violate the supported data types while maintaining the ability to store complex data. </span><span class="koboSpan" id="kobo.159.3">When we are adding new data, we simply need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">SetCache</span></strong><span class="koboSpan" id="kobo.161.1"> and add the new data.</span></p>
<p><span class="koboSpan" id="kobo.162.1">We also want to ensure that we maintain the freshness of the data as much as possible. </span><span class="koboSpan" id="kobo.162.2">A popular pattern involves clearing the cache and making a fresh entry each time data is entered or updated.</span></p>
<p><span class="koboSpan" id="kobo.163.1">We can use these bits of code in our application and implement a caching layer to improve not only</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.164.1"> performance but resiliency and stability. </span><span class="koboSpan" id="kobo.164.2">We still have the issue of retrying operations when they fail the initial call. </span><span class="koboSpan" id="kobo.164.3">In the next section, we will look at how we can implement our retry logic.</span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.165.1">Implementing retry and circuit breaker policies</span></h1>
<p><span class="koboSpan" id="kobo.166.1">Services fail for </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.167.1">various reasons. </span><span class="koboSpan" id="kobo.167.2">A typical response to a service failure is </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.168.1">an HTTP response in the </span><em class="italic"><span class="koboSpan" id="kobo.169.1">5xx</span></em><span class="koboSpan" id="kobo.170.1"> range. </span><span class="koboSpan" id="kobo.170.2">These typically highlight an issue with the hosting server or a temporary outage in the network hosting the service. </span><span class="koboSpan" id="kobo.170.3">Without trying to pinpoint the exact cause of the failure at the time it happens, we need to add some fail-safes to ensure the continuity of the application when these types of errors occur.</span></p>
<p><span class="koboSpan" id="kobo.171.1">For this reason, we should use retry logic in our service calls. </span><span class="koboSpan" id="kobo.171.2">These will automatically resubmit the initial request if an error code is returned, which might be enough time for a transient error to resolve itself and reduce the effects that the initial error might have on the entire system and operation. </span><span class="koboSpan" id="kobo.171.3">In this policy, we generally allow for some time to pass between each request attempt. </span><span class="koboSpan" id="kobo.171.4">This sums up our retry policy.</span></p>
<p><span class="koboSpan" id="kobo.172.1">What we don’t want to do with our retries is to continue to execute them without some form of exit condition. </span><span class="koboSpan" id="kobo.172.2">This would be like implementing an infinite loop if the target service remains unresponsive and inadvertently </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.173.1">executing a </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">denial-of-service</span></strong><span class="koboSpan" id="kobo.175.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.176.1">DoS</span></strong><span class="koboSpan" id="kobo.177.1">) attack on our own service. </span><span class="koboSpan" id="kobo.177.2">For this reason, we implement the circuit breaker pattern, which acts as an orchestrator for our service calls.</span></p>
<p><span class="koboSpan" id="kobo.178.1">We will need to implement a </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">retry policy</span></strong><span class="koboSpan" id="kobo.180.1"> to at least make the call several times before concluding a definite failure. </span><span class="koboSpan" id="kobo.180.2">This will make our service more resilient to a potentially fleeting error and allow the application to ensure that the user’s experience isn’t directly affected by such an issue. </span><span class="koboSpan" id="kobo.180.3">Now, retries are not always the answer. </span><span class="koboSpan" id="kobo.180.4">A retry here makes sense since the service is responding with a clear-cut failure, and we are deciding to try again. </span><span class="koboSpan" id="kobo.180.5">We need to decide how many retries are too many and stop accordingly.</span></p>
<p><span class="koboSpan" id="kobo.181.1">We can use </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.182.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">circuit breaker pattern</span></strong><span class="koboSpan" id="kobo.184.1"> to control the number of retries and set parameters that will govern how long a connection should stay open and listen for a response. </span><span class="koboSpan" id="kobo.184.2">This simple technique helps to reduce the number of retries and provides better control over how retries occur.</span></p>
<p><span class="koboSpan" id="kobo.185.1">A </span><em class="italic"><span class="koboSpan" id="kobo.186.1">circuit breaker</span></em><span class="koboSpan" id="kobo.187.1"> sits in between the client and the server. </span><span class="koboSpan" id="kobo.187.2">In our microservices application, the service making the call is the client, and the target service is the server receiving the request. </span><span class="koboSpan" id="kobo.187.3">Initially, it allows all calls to go through. </span><span class="koboSpan" id="kobo.187.4">We call this the </span><em class="italic"><span class="koboSpan" id="kobo.188.1">closed state</span></em><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">If an error is detected, which can be in the form of an error response or a delayed response, the </span><em class="italic"><span class="koboSpan" id="kobo.190.1">circuit breaker opens</span></em><span class="koboSpan" id="kobo.191.1">. </span><span class="koboSpan" id="kobo.191.2">Once the circuit breaker is open, subsequent calls will fail faster. </span><span class="koboSpan" id="kobo.191.3">This will shorten the time spent waiting for a response. </span><span class="koboSpan" id="kobo.191.4">It will wait for a configured timeout period and then allow the calls again, in case the target service has recovered. </span><span class="koboSpan" id="kobo.191.5">If there is no improvement, then the circuit breaker will break the transmission.</span></p>
<p><span class="koboSpan" id="kobo.192.1">Using these two techniques, we can both counter transient failures and ensure that longer-term failures do not surface in the form of a poor user experience. </span><span class="koboSpan" id="kobo.192.2">In .NET Core, we have the benefit </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.193.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Polly</span></strong><span class="koboSpan" id="kobo.195.1">, which is a package that allows us to almost support natively both retry and circuit break policies and implement resilient web service calls. </span><span class="koboSpan" id="kobo.195.2">We will </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.196.1">explore </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.197.1">integrating Polly into our app next.</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.198.1">Retry policy with Polly</span></h2>
<p><span class="koboSpan" id="kobo.199.1">Polly is a framework</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.200.1"> that </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.201.1">allows us to add a new layer of resilience to our applications. </span><span class="koboSpan" id="kobo.201.2">It acts as a layer between two services that stores the details of an initiated request and monitors the response time and/or the response code. </span><span class="koboSpan" id="kobo.201.3">It can be configured with parameters that it uses to determine what a failure looks like, and we can further configure the type of action we would like to take. </span><span class="koboSpan" id="kobo.201.4">This action can be in the form of a retry or a cancellation of the request.</span></p>
<p><span class="koboSpan" id="kobo.202.1">Polly is conveniently available in .NET Core and is widely used and trusted around the world. </span><span class="koboSpan" id="kobo.202.2">Let us review the steps needed to implement this framework in our application and monitor the calls the </span><em class="italic"><span class="koboSpan" id="kobo.203.1">Patients API</span></em><span class="koboSpan" id="kobo.204.1"> will make to the </span><em class="italic"><span class="koboSpan" id="kobo.205.1">Documents API</span></em><span class="koboSpan" id="kobo.206.1">.</span></p>
<p><span class="koboSpan" id="kobo.207.1">To add it to </span><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.208.1">our .NET Core application and allow us to write extension code for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">HttpClient</span></strong><span class="koboSpan" id="kobo.210.1"> objects, we start by adding these packages via NuGet:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
Install-Package Polly
Install-Package Microsoft.Extensions.Http.Polly</span></pre>
<p><span class="koboSpan" id="kobo.212.1">Now, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Program.cs</span></strong><span class="koboSpan" id="kobo.214.1"> file, we can configure our typed HTTP client for our </span><em class="italic"><span class="koboSpan" id="kobo.215.1">Documents API</span></em><span class="koboSpan" id="kobo.216.1"> to use our extension code for its Polly-defined policies. </span><span class="koboSpan" id="kobo.216.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">Program.cs</span></strong><span class="koboSpan" id="kobo.218.1"> file, we can define the registration of our typed client like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
builder.Services.AddHttpClient&lt;IDocumentService,
     DocumentService&gt;()
.AddPolicyHandler(GetRetryPolicy());</span></pre>
<p><span class="koboSpan" id="kobo.220.1">We have added a policy handler to our HTTP client, so it will automatically be invoked for all calls made using this client. </span><span class="koboSpan" id="kobo.220.2">We now need to define a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">GetRetryPolicy()</span></strong><span class="koboSpan" id="kobo.222.1"> that will build our policy:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
static IAsyncPolicy&lt;HttpResponseMessage&gt; GetRetryPolicy()
        {
            return HttpPolicyExtensions
                .HandleTransientHttpError()
                .OrResult(r =&gt; !r.IsSuccessStatusCode)
                .Or&lt;HttpRequestException&gt;()
                .WaitAndRetryAsync(5, retryAttempt =&gt;
                   TimeSpan.FromSeconds(Math.Pow(2,
                     retryAttempt)), (exception, timeSpan,
                         context) =&gt; {
                    // Add logic to be executed before each
                    retry, such as logging or
                      reauthentication
                });
        }</span></pre>
<p><span class="koboSpan" id="kobo.224.1">It may seem</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.225.1"> complicated </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.226.1">because of the use of the builder pattern, but it is simple to understand and flexible enough to customize to your needs. </span><span class="koboSpan" id="kobo.226.2">Firstly, we define the return type or the method to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">IAsyncPolicy&lt;HttpResponseMessage&gt;</span></strong><span class="koboSpan" id="kobo.228.1">, which corresponds with the return type of our calls from our HTTP client. </span><span class="koboSpan" id="kobo.228.2">We then allow the policy to observe for transient HTTP errors, which the framework can determine by default, and we can extend that logic with more conditions such as observing the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">IsSuccessStatusCode</span></strong><span class="koboSpan" id="kobo.230.1">, which returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">true</span></strong><span class="koboSpan" id="kobo.232.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">false</span></strong><span class="koboSpan" id="kobo.234.1"> for the success of an operation, or even if </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">HttpRequestException</span></strong><span class="koboSpan" id="kobo.236.1"> has been returned.</span></p>
<p><span class="koboSpan" id="kobo.237.1">These few parameters cover the general worst-case scenarios of an HTTP response. </span><span class="koboSpan" id="kobo.237.2">We then set the parameters for our retries. </span><span class="koboSpan" id="kobo.237.3">We want to retry at most 5 more times, and each retry should be done at a rolling interval starting at 2 seconds from the previous call. </span><span class="koboSpan" id="kobo.237.4">This way, we allow a little time between each retry. </span><span class="koboSpan" id="kobo.237.5">This is the concept of a </span><em class="italic"><span class="koboSpan" id="kobo.238.1">backoff</span></em><span class="koboSpan" id="kobo.239.1">.</span></p>
<p><span class="koboSpan" id="kobo.240.1">Finally, we can define what action would like to take between each retry. </span><span class="koboSpan" id="kobo.240.2">This could include some error handling or reauthentication logic.</span></p>
<p><span class="koboSpan" id="kobo.241.1">Retry policies can have negative effects on your system where we might have high concurrency and high contention for resources. </span><span class="koboSpan" id="kobo.241.2">We need to ensure that we have a solid policy and define our delays and retries efficiently. </span><span class="koboSpan" id="kobo.241.3">Recall that a carelessly configured retry policy may well result in a DoS attack on your own service, opening the application to significant performance issues.</span></p>
<p><span class="koboSpan" id="kobo.242.1">Given the possibility of implementing something that could have negative effects in this manner, we now need</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.243.1"> a </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.244.1">defense barrier that will mitigate this risk and break the retry cycle if the errors never stop. </span><span class="koboSpan" id="kobo.244.2">The best defense strategy comes in the form of the circuit breaker, which we will configure using Polly next.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.245.1">Circuit breaker policy with Polly</span></h2>
<p><span class="koboSpan" id="kobo.246.1">As we have</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.247.1"> discussed for this chapter, we should handle faults </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.248.1">that take a bit longer to resolve and define a policy that abandons retry calls to a service when we have concluded that it is unresponsive for a longer term than hoped for.</span></p>
<p><span class="koboSpan" id="kobo.249.1">We can continue from our code that added the retry policy using Polly by defining a circuit breaker policy and adding it as an HTTP handler to our client. </span><span class="koboSpan" id="kobo.249.2">We modify the client’s registration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Program.cs</span></strong><span class="koboSpan" id="kobo.251.1"> file, like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
builder.Services.AddHttpClient&lt;IDocumentService,
    DocumentService&gt;().AddPolicyHandler(GetRetryPolicy())
.AddPolicyHandler(GetCircuitBreakerPolicy());</span></pre>
<p><span class="koboSpan" id="kobo.253.1">Now, we can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">GetCircuitBreakerPolicy()</span></strong><span class="koboSpan" id="kobo.255.1"> method as this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
static IAsyncPolicy&lt;HttpResponseMessage&gt;
    GetCircuitBreakerPolicy()
{
    return HttpPolicyExtensions
        .HandleTransientHttpError()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));
}</span></pre>
<p><span class="koboSpan" id="kobo.257.1">This policy defines a circuit breaker that opens the circuit when there have been </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">5</span></strong><span class="koboSpan" id="kobo.259.1"> consecutive retry failures. </span><span class="koboSpan" id="kobo.259.2">Once that threshold is reached, the circuit will break for 30 seconds and automatically fail all subsequent calls, which will be interpreted as HTTP failure responses.</span></p>
<p><span class="koboSpan" id="kobo.260.1">With these two policies in place, you can orchestrate your service retries and significantly reduce the effects that unplanned outages might have on your application and the end user’s experience. </span><span class="koboSpan" id="kobo.260.2">The circuit breaker policy also adds a layer of protection from any </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.261.1">potential </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.262.1">adverse effects of the retry policy.</span></p>
<p><span class="koboSpan" id="kobo.263.1">Now, let us summarize what we have learned about implementing resilient web services.</span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.264.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.265.1">The contents of this chapter help us to be more mindful of the potential for failures in our microservices application. </span><span class="koboSpan" id="kobo.265.2">These concepts help us not only construct powerful and stable web services but also supercharge the communication mechanisms that exist between them.</span></p>
<p><span class="koboSpan" id="kobo.266.1">We see that service outages are not always due to faulty code or the database and server of the initial web service, but we are facilitating inter-service communication as well, which leads to greater dependence on the network, third-party service, and general infrastructure uptime. </span><span class="koboSpan" id="kobo.266.2">This leads down a path where we implement contingencies that assist in ensuring</span><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.267.1"> that our application </span><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.268.1">gives our users as good an experience as possible.</span></p>
<p><span class="koboSpan" id="kobo.269.1">We looked at several techniques for increasing service reliability, such as using a caching layer with technology such as Redis Cache for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">GET</span></strong><span class="koboSpan" id="kobo.271.1"> operations, a message broker for our write operations, and writing more foolproof code using frameworks such as Polly. </span><span class="koboSpan" id="kobo.271.2">With Polly, we looked at how we can automatically retry service calls and use a circuit breaker to prevent these retries from being too liberal and causing other problems.</span></p>
<p><span class="koboSpan" id="kobo.272.1">Since services fail and we need a retry method, we also need a way to monitor the health of the services so that we can be aware of why the retries are not effective. </span><span class="koboSpan" id="kobo.272.2">This means that we need to introduce </span><em class="italic"><span class="koboSpan" id="kobo.273.1">health checks</span></em><span class="koboSpan" id="kobo.274.1"> that alert us to outages in a service’s infrastructure. </span><span class="koboSpan" id="kobo.274.2">We will explore this in the next chapter.</span></p>
</div>
</body></html>