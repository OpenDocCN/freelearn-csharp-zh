- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Implementing External Assets, APIs, and Pre-Built Components with C# in Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中使用C#实现外部资产、API和预构建组件
- en: Welcome to [*Chapter 8*](B22017_08.xhtml#_idTextAnchor127), where we will delve
    into essential aspects of game development using C#. We will begin by exploring
    the integration of pre-built assets, a fundamental skill for enhancing game visuals
    and performance. Then, we will delve into the integration of rendering pipelines,
    which is crucial for optimizing game visuals and achieving better performance.
    After that, we will discuss the significance of backend services in game development,
    focusing on authentication logic as a prime example of their importance. Lastly,
    we will explore analytics APIs and their pivotal role in understanding player
    behavior and optimizing game performance. Throughout this chapter, I’ll demonstrate
    how to implement these key components into our game, empowering you to create
    immersive and engaging gaming experiences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第8章*](B22017_08.xhtml#_idTextAnchor127)，我们将深入探讨使用C#进行游戏开发的关键方面。我们将从探索预构建资产的集成开始，这是增强游戏视觉和性能的基本技能。然后，我们将深入研究渲染管道的集成，这对于优化游戏视觉和实现更好的性能至关重要。之后，我们将讨论后端服务在游戏开发中的重要性，重点关注身份验证逻辑作为其重要性的主要例子。最后，我们将探索分析API及其在理解玩家行为和优化游戏性能中的关键作用。在本章中，我将演示如何将这些关键组件集成到我们的游戏中，让您能够创建沉浸式和引人入胜的游戏体验。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Leveraging pre-built assets with C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用C#预构建资产
- en: Integrating backend services with C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用C#集成后端服务
- en: Integrating analytics APIs with C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用C#集成分析API
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code files of this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2008](B22017_08.xhtml#_idTextAnchor127).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2008](B22017_08.xhtml#_idTextAnchor127)。
- en: Leveraging pre-built assets with C#
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用C#预构建资产
- en: In the vast world of game development, time is as valuable as the pixels on
    our screens. Every moment counts, and each bit of code shapes the worlds players
    will explore. This is where third-party assets come in handy—they are efficient
    tools that enhance creativity in the changing landscape of game design.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的广阔世界中，时间与屏幕上的像素一样宝贵。每一刻都至关重要，每一行代码都塑造着玩家将要探索的世界。这就是第三方资产发挥作用的地方——它们是提高游戏设计变化中创造力的有效工具。
- en: 'Imagine this: you’re a new game developer with a bright vision. You dream of
    vast landscapes, detailed character animations, and sounds that take players to
    faraway lands. However, the journey from idea to reality is full of challenges,
    and time is hard to come by.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：你是一位拥有光明前景的新游戏开发者。你梦想着广阔的景观、细致的角色动画和能把玩家带到遥远土地的声音。然而，从想法到现实的旅程充满了挑战，时间难以捉摸。
- en: Third-party assets, often underappreciated in game development, play a crucial
    role. These readily available resources form the backbone of game creation, bringing
    virtual worlds to fruition. From grand landscapes to subtle environmental details,
    third-party assets simplify the complex task of asset creation, allowing us to
    focus on refining gameplay and improving player experiences.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方资产，在游戏开发中常常被低估，但发挥着至关重要的作用。这些现成的资源构成了游戏创作的基石，将虚拟世界变为现实。从宏伟的景观到微妙的细节，第三方资产简化了复杂的资产创建任务，使我们能够专注于优化游戏玩法和提升玩家体验。
- en: '*But why are they so important?* Firstly, third-party assets offer a wealth
    of resources created by experts. Whether you need stunning environments, realistic
    characters, or chilling sound effects, the vast array of third-party assets has
    it all. These assets fuel creativity, sparking imagination and helping us turn
    ideas into reality quickly.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*但为什么它们如此重要呢？* 首先，第三方资产提供了由专家创建的大量资源。无论你需要令人惊叹的环境、逼真的角色还是令人毛骨悚然的音效，第三方资产的庞大阵容应有尽有。这些资产激发创造力，激发想象力，帮助我们快速将想法变为现实。'
- en: Furthermore, the benefits go beyond convenience. By using pre-built assets,
    we can focus on the core of our games—the gameplay itself. Free from creating
    assets, they can craft immersive worlds, compelling stories, and unforgettable
    experiences that capture players’ hearts and endure over time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，好处远不止便利性。通过使用预构建资产，我们可以专注于游戏的核心——游戏玩法本身。摆脱了创建资产的重担，他们可以打造沉浸式的世界、引人入胜的故事和难以忘怀的体验，这些都能抓住玩家的心并随着时间的推移而持久。
- en: In this section, we’ll explore the utilization of pre-built assets available
    in Unity’s Package Manager, such as **URP**, which provides advanced rendering
    options. Let’s begin our exploration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Unity包管理器中可用的预构建资源的利用，例如**URP**，它提供了高级渲染选项。让我们开始我们的探索之旅。
- en: Universal Render Pipeline (URP)
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用渲染管线（URP）
- en: In this section, we’ll explore the **Universal Render Pipeline** (**URP**),
    a powerful tool that helps create stunning visuals and optimize performance in
    our Unity projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨**通用渲染管线**（URP），这是一个强大的工具，有助于在我们的Unity项目中创建令人惊叹的视觉效果并优化性能。
- en: URP is a rendering solution provided by Unity Technologies. It’s designed to
    strike a balance between visual quality and performance, making it suitable for
    a wide range of platforms and devices, including mobile, consoles, and PCs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: URP是由Unity Technologies提供的渲染解决方案。它旨在在视觉质量和性能之间取得平衡，使其适用于包括移动、游戏机和PC在内的广泛平台和设备。
- en: URP offers a flexible and efficient rendering pipeline that allows for the creation
    of visually appealing games while ensuring smooth performance across different
    hardware configurations. Whether you’re creating a stylized indie game or a realistic
    AAA title, URP provides the tools and features needed to bring your vision to
    life.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: URP提供了一个灵活且高效的渲染管线，允许创建视觉上吸引人的游戏，同时确保在不同硬件配置上保持流畅的性能。无论你是创建风格化的独立游戏还是现实主义的AAA游戏，URP都提供了将你的愿景变为现实所需的工具和功能。
- en: Choosing between Unity’s render pipelines – URP versus HDRP
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Unity的渲染管线之间进行选择——URP与HDRP
- en: Unity offers two distinct rendering pipelines, URP and the **High-Definition
    Render Pipeline** (**HDRP**), each tailored to different needs and requirements
    in game development. Let’s explore the key differences between the two and the
    reasons why you might choose one over the other for your game.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了两种不同的渲染管线，URP和**高清渲染管线**（HDRP），它们分别针对游戏开发中的不同需求和需求量身定制。让我们探讨这两者之间的关键差异以及为什么你可能会选择其中一个而不是另一个来为你的游戏服务。
- en: In the following table, I’ve outlined a comparison between Unity’s render pipelines,
    highlighting key points to assist you in determining the most suitable pipeline
    for your project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表格中，我概述了Unity渲染管线的比较，突出了关键点，以帮助您确定最适合您项目的管线。
- en: '| **Aspect** | **URP** | **HDRP** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **方面** | **URP** | **HDRP** |'
- en: '| Graphics Fidelity | URP is designed for optimized rendering performance while
    maintaining a balance between visual quality and efficiency. It supports features
    such as real-time lighting, shadows, and post-processing effects. | HDRP aims
    to deliver high-quality visuals and graphical fidelity, especially for high-end
    platforms such as PCs and consoles. It offers advanced rendering features such
    as physically based rendering and volumetric lighting. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 图形保真度 | URP旨在优化渲染性能，同时保持视觉质量和效率之间的平衡。它支持实时照明、阴影和后期处理效果等功能。 | HDRP旨在提供高质量的视觉效果和图形保真度，尤其是在PC和游戏机等高端平台上。它提供基于物理的渲染和体积照明等高级渲染功能。
    |'
- en: '| Platform Compatibility | URP is optimized for cross-platform development,
    making it suitable for a diverse range of devices and platforms, including mobile
    devices, consoles, and PCs. | HDRP is tailored for high-end platforms and may
    require more powerful hardware to achieve optimal performance. It may not be as
    suitable for mobile devices or lower-end PCs due to its higher demands |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 平台兼容性 | URP针对跨平台开发进行了优化，使其适用于各种设备和平台，包括移动设备、游戏机和PC。 | HDRP针对高端平台，可能需要更强大的硬件才能实现最佳性能。由于其更高的要求，它可能不适合移动设备或低端PC。
    |'
- en: '| Art Style and Visual Direction | URP is versatile and accommodates a wide
    range of art styles and visual directions, including stylized, cartoonish, or
    realistic art styles. It allows for visually appealing results across different
    genres and themes. | HDRP is well suited for projects aiming for photorealistic
    graphics and immersive visual experiences. It offers advanced rendering features
    and high-fidelity effects enhancing realism and immersion. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 艺术风格和视觉方向 | URP具有多功能性，可以适应广泛的风格和视觉方向，包括风格化、卡通化或现实风格的艺术。它允许在不同类型和主题中实现视觉上吸引人的结果。
    | HDRP非常适合追求照片级图形和沉浸式视觉体验的项目。它提供高级渲染功能和高保真效果，增强了现实感和沉浸感。 |'
- en: '| Development Time and Resources | URP provides a balance between visual quality
    and development efficiency with a streamlined workflow and easier setup. It is
    accessible to developers with limited resources or time constraints. | HDRP offers
    advanced features and graphical capabilities, but it may require additional development
    time and resources to fully leverage its potential. It needs careful optimization
    and tuning for desired performance. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 开发时间和资源 | URP通过简化的工作流程和更简单的设置，在视觉质量和开发效率之间提供了平衡。它适用于资源有限或时间受限的开发者。HDRP提供了高级功能和图形能力，但要充分发挥其潜力，可能需要额外的时间和资源。它需要仔细优化和调整以达到期望的性能。|'
- en: In summary, the choice between URP and HDRP depends on various factors, including
    your project’s target platforms, desired graphical fidelity, art style, and available
    development resources. If you prioritize performance, cross-platform compatibility,
    and a balance between visual quality and efficiency, URP may be the preferable
    option. On the other hand, if your project demands high-end visuals, photorealism,
    and advanced graphical effects, HDRP may be the better choice, provided you have
    the necessary resources and hardware to support it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，URP和HDRP之间的选择取决于各种因素，包括你的项目目标平台、期望的图形保真度、艺术风格和可用的开发资源。如果你优先考虑性能、跨平台兼容性以及视觉质量和效率之间的平衡，URP可能是更好的选择。另一方面，如果你的项目需要高端视觉、逼真度和高级图形效果，HDRP可能是更好的选择，前提是你有必要的资源和硬件来支持它。
- en: Now that we have understood the contrast between the two distinct rendering
    pipelines in Unity, let’s proceed to install URP.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Unity中两个不同渲染管道之间的对比，让我们继续安装URP。
- en: Installing URP into our project
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将URP安装到我们的项目中
- en: Important note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Before upgrading to a custom render pipeline, it’s essential to back up your
    project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级到自定义渲染管道之前，备份你的项目是至关重要的。
- en: 'We’ve already chosen the URP package for our project. However, if it hasn’t
    been configured in your project yet, you can simply access **Package Manager**
    and select the **Universal RP** option, as you can see in *Figure 8**.1*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的项目选择了URP包。然而，如果它还没有在你的项目中配置，你可以简单地访问**包管理器**并选择**通用RP**选项，正如你在*图8**.1*中看到的那样：
- en: '![Figure 8.1 – Installing the URP package](img/B22017_08_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 安装URP包](img/B22017_08_01.jpg)'
- en: Figure 8.1 – Installing the URP package
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 安装URP包
- en: When you click on **Install**, Unity will install the package and its dependencies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**安装**时，Unity将安装该包及其依赖项。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are migrating from the built-in pipeline to URP or High-Definition RP,
    there are specific instructions to adhere to. You’ll need to adjust all materials
    to utilize the new shaders provided by these packages. However, given that our
    game has been utilizing these packages from the outset, imported files such as
    model materials will already be configured to use the shaders provided by those
    packages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在从内置管道迁移到URP或高清RP，有一些特定的说明需要遵守。你需要调整所有材质以利用这些包提供的新着色器。然而，鉴于我们的游戏从一开始就使用这些包，导入的文件，如模型材质，已经配置为使用这些包提供的着色器。
- en: 'Since migrating from the built-in is not our primary objective, I won’t delve
    into upgrading to URP. You can explore additional possibilities by referring to
    the official documentation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于迁移到内置管道不是我们的主要目标，所以不会深入探讨升级到URP。你可以通过参考官方文档来探索其他可能性：
- en: 'If you are using URP version 13.1 or newer, there is a built-in converter available.
    Please refer to this page for more information on how to utilize this converter:
    **https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/features/rp-converter.html**.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是13.1或更高版本的URP，有一个内置的转换器可用。请参考此页面以获取有关如何使用此转换器的更多信息：**https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/features/rp-converter.html**。
- en: 'If you are using a URP version prior to 13.1, you need to refer to this link:
    **https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.0/manual/upgrading-your-shaders.html**.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是13.1之前的URP版本，你需要参考这个链接：**https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.0/manual/upgrading-your-shaders.html**。
- en: In the next subsection, we will discover the power of Unity’s URP, a versatile
    package offering optimized rendering, custom shaders, and enhanced lighting for
    creating visually stunning projects across multiple platforms.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将发现Unity的URP的强大之处，这是一个提供优化渲染、自定义着色器和增强光照的多平台视觉项目包。
- en: Exploring URP in Unity – features and functionality
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索Unity中的URP（通用渲染管线）- 特性和功能
- en: 'The URP package in Unity provides developers with a range of features and functionalities
    to enhance the rendering capabilities of their projects. Here are some key aspects
    of the URP package and its usage:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的URP包为开发者提供了一系列功能和功能，以增强项目的渲染能力。以下是URP包及其使用的一些关键方面：
- en: '**Optimized rendering pipeline**: URP offers an optimized rendering pipeline
    designed to balance performance and visual quality across various platforms and
    devices. It includes features such as deferred and forward rendering paths, allowing
    us to choose the rendering technique that best suits their project’s requirements.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化渲染管线**：URP提供了一个优化的渲染管线，旨在在各种平台和设备上平衡性能和视觉质量。它包括诸如延迟渲染和前向渲染路径等功能，使我们能够选择最适合项目需求渲染技术。'
- en: '**Lightweight rendering**: URP is designed to be lightweight, making it suitable
    for projects targeting mobile devices, lower-end hardware, and performance-conscious
    applications. It optimizes rendering processes to achieve smooth performance while
    maintaining visual fidelity.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级渲染**：URP设计得轻量级，使其适合针对移动设备、低端硬件和性能敏感型应用程序的项目。它优化渲染过程以实现流畅的性能，同时保持视觉保真度。'
- en: '**Shader graph integration**: URP seamlessly integrates with Unity’s Shader
    Graph tool, allowing us to create custom shaders and visual effects without writing
    code. Shader Graph empowers us to design complex materials, lighting effects,
    and post-processing effects through a node-based interface.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器图集成**：URP无缝集成Unity的着色器图工具，使我们能够在不编写代码的情况下创建自定义着色器和视觉效果。着色器图通过基于节点的界面使我们能够设计复杂材料、照明效果和后处理效果。'
- en: '**Custom rendering features**: URP provides support for custom rendering features
    through **Scriptable Render Pipeline** (**SRP**) extensions. We can extend and
    customize the rendering pipeline by implementing custom render passes, post-processing
    effects, and shader variants.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义渲染功能**：URP通过**可脚本化渲染管线**（**SRP**）扩展提供了对自定义渲染功能的支持。我们可以通过实现自定义渲染通道、后处理效果和着色器变体来扩展和自定义渲染管线。'
- en: '**Enhanced lighting system**: URP includes a flexible lighting system that
    supports real-time lighting, shadows, and reflections. It offers features such
    as per-object and per-pixel lighting, dynamic shadows, and light probes for realistic
    lighting effects.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的照明系统**：URP包括一个灵活的照明系统，支持实时照明、阴影和反射。它提供诸如对象级和像素级照明、动态阴影和用于逼真照明效果的光探针等功能。'
- en: '**Post-processing effects**: URP includes built-in support for post-processing
    effects, allowing us to enhance the visual quality of their scenes. It provides
    a range of post-processing effects such as bloom, depth of field, color grading,
    and ambient occlusion.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后处理效果**：URP内置了对后处理效果的支持，使我们能够增强场景的视觉质量。它提供了一系列后处理效果，如光晕、景深、色彩分级和环境遮挡。'
- en: '**Cross-platform compatibility**: URP is designed for cross-platform compatibility,
    enabling us to create games and applications for various platforms, including
    mobile devices, consoles, and PCs. It optimizes rendering performance across different
    hardware configurations and platform specifications.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台兼容性**：URP旨在实现跨平台兼容性，使我们能够为各种平台创建游戏和应用程序，包括移动设备、游戏机和PC。它优化了不同硬件配置和平台规范下的渲染性能。'
- en: In summary, the URP package in Unity provides us with a lightweight, flexible,
    and optimized rendering solution for creating visually stunning and performance-efficient
    projects. From lighting and shading to post-processing effects and custom rendering
    features, URP empowers us to bring their creative visions to life while ensuring
    optimal performance across different platforms and devices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Unity中的URP包为我们提供了一个轻量级、灵活且优化的渲染解决方案，用于创建视觉上令人惊叹且性能高效的项目。从照明和着色到后处理效果和自定义渲染功能，URP使我们能够将创意愿景变为现实，同时确保在不同平台和设备上实现最佳性能。
- en: Next, we’ll explore more advanced topics, such as render callbacks and custom
    render features.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨更多高级主题，例如渲染回调和自定义渲染功能。
- en: Mastering visual modifications in Unity – advanced techniques with URP and C#
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掌握Unity中的视觉修改 - 使用URP和C#的高级技术
- en: 'Introducing advanced techniques in URP using C# can greatly modify the visual
    quality and performance of your Unity projects. Two key features that we can explore
    and discuss in this section are Custom Render Passes and Render Pipeline Callbacks:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在URP中使用C#引入高级技术可以极大地改变您Unity项目的视觉质量和性能。本节中我们可以探索和讨论的两个关键特性是自定义渲染通道和渲染管线回调：
- en: '**Custom** **Render Passes**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义** **渲染通道**：'
- en: Custom Render Passes allow you to inject custom rendering logic into the render
    pipeline, enabling you to implement specialized effects or optimizations beyond
    the built-in features of URP.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义渲染通道允许您将自定义渲染逻辑注入到渲染管线中，使您能够实现超出URP内置功能的专用效果或优化。
- en: With Custom Render Passes, you have fine-grained control over the rendering
    process at various stages, such as before or after opaque rendering, before or
    after transparent rendering, or even in between specific render queues.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义渲染通道，您可以在渲染过程的各个阶段进行精细控制，例如在透明或非透明渲染之前或之后，或者在特定的渲染队列之间。
- en: You can use Custom Render Passes to implement effects like outline rendering,
    screen-space effects, custom post-processing, or optimizations such as rendering
    additional buffers for custom shaders or computations.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用自定义渲染通道实现轮廓渲染、屏幕空间效果、自定义后期处理或优化，例如为自定义着色器或计算渲染额外的缓冲区。
- en: '**Render** **Pipeline Callbacks**:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染** **管线回调**：'
- en: Render Pipeline Callbacks provide a mechanism for hooking into specific events
    and stages within the render pipeline to execute custom C# code.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染管线回调提供了一种机制，可以在渲染管线中的特定事件和阶段执行自定义C#代码。
- en: Using Render Pipeline Callbacks, you can perform tasks such as modifying materials,
    adjusting rendering settings dynamically, or injecting custom rendering logic
    at specific points in the rendering process.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用渲染管线回调，您可以执行诸如修改材质、动态调整渲染设置或在渲染过程中的特定点注入自定义渲染逻辑等任务。
- en: Render Pipeline Callbacks can be used to implement advanced features such as
    dynamic material modifications based on game events, procedural generation of
    textures or geometry, or applying custom shader effects based on runtime conditions.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染管线回调可用于实现基于游戏事件动态修改材质、纹理或几何形状的生成，或根据运行时条件应用自定义着色器效果等高级功能。
- en: Next, let’s explore an example that demonstrates the application of these advanced
    techniques within our project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索一个示例，演示如何在项目中应用这些高级技术。
- en: Illustration of implementing advanced techniques
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施高级技术的说明
- en: 'Here is a step-by-step guide, illustrated with examples, on how to utilize
    these advanced techniques to create and control the outline effect:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个逐步指南，通过示例说明如何利用这些高级技术创建和控制轮廓效果：
- en: 'Before creating the renderer feature, ensure that your project is configured
    to use the URP renderer data in your **Quality and Graphics** settings within
    the **Project Settings**. Right-click in your **Project** tab and navigate to
    **Create | Rendering | URP Renderer Feature** to generate a new feature script.
    You can name it **OutlineEffect**:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建渲染器功能之前，请确保您的项目已配置为在**项目设置**中的**质量和图形**设置中使用URP渲染器数据。在**项目**选项卡中右键单击，然后导航到**创建
    | 渲染 | URP渲染器功能**以生成一个新的功能脚本。您可以将其命名为**OutlineEffect**：
- en: '![Figure 8.2 – Creating an URP Renderer Feature script](img/B22017_08_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 创建URP渲染器功能脚本](img/B22017_08_02.jpg)'
- en: Figure 8.2 – Creating an URP Renderer Feature script
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 创建URP渲染器功能脚本
- en: 'Next, we open the **OutlineEffect** script and make modifications as outlined
    in the following code block:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打开**OutlineEffect**脚本，并根据以下代码块中的说明进行修改：
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down the previous code to explain what each part does:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们分解之前的代码，解释每个部分的作用：
- en: The `OutlineEffect` class defines a custom renderer feature that adds an outline
    effect to objects in the scene by utilizing a custom render pass (`OutlineRenderPass`)
    with a list of outline materials. The `OutlineRenderPass` class implements the
    rendering logic for applying the outline effect to objects during the rendering
    process.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutlineEffect`类定义了一个自定义渲染器功能，通过使用带有轮廓材质列表的自定义渲染通道（`OutlineRenderPass`）来为场景中的对象添加轮廓效果。`OutlineRenderPass`类实现了在渲染过程中应用轮廓效果到对象的渲染逻辑。'
- en: 'Next, you can integrate the feature into your URP data scriptable object. You
    can customize the settings according to your game’s requirements. For our demonstration,
    I’ve retained the default settings, as depicted in *Figure 8**.3*:'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你可以将此功能集成到你的URP数据可脚本对象中。你可以根据游戏需求自定义设置。在我们的演示中，我保留了默认设置，如图*图8**.3*所示：
- en: '![Figure 8.3 – Adding OutlineEffect Feature](img/B22017_08_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 添加OutlineEffect功能](img/B22017_08_03.jpg)'
- en: Figure 8.3 – Adding OutlineEffect Feature
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 添加OutlineEffect功能
- en: 'You can include additional features to achieve your desired visual effects.
    Furthermore, you can refer to Unity’s official documentation for further details
    using the following link: `https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@16.0/manual/index.html`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以包括额外的功能以实现你期望的视觉效果。此外，你可以通过以下链接参考Unity的官方文档以获取更多详细信息：`https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@16.0/manual/index.html`。
- en: 'In the following figure, you will observe the disparity before and after applying
    the feature:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你将观察到应用此功能前后的差异：
- en: '![Figure 8.4 –OutlineEffect feature effect](img/B22017_08_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – OutlineEffect功能效果](img/B22017_08_04.jpg)'
- en: Figure 8.4 –OutlineEffect feature effect
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – OutlineEffect功能效果
- en: Discover the significant impact and benefits of leveraging the render pass feature
    for optimizing rendering and enhancing visual effects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 探索利用渲染通道功能优化渲染和增强视觉效果的重要影响和好处。
- en: What is the purpose of utilizing the render pass feature?
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用渲染通道功能的目的是什么？
- en: 'Using render passes in conjunction with the URP offers several benefits for
    implementing an outline effect:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用URP（Universal Render Pipeline）结合渲染通道可以为实现轮廓效果提供多项优势：
- en: '**Modularity and extensibility**: By utilizing render passes, you can modularize
    your rendering pipeline and separate specific rendering tasks into distinct passes.
    This makes your rendering pipeline more flexible and easier to maintain. You can
    add or remove passes as needed without affecting other parts of the pipeline.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化和可扩展性**：通过使用渲染通道，你可以模块化你的渲染管道，并将特定的渲染任务分离成独立的通道。这使得你的渲染管道更加灵活且易于维护。你可以根据需要添加或删除通道，而不会影响管道的其他部分。'
- en: '**Performance optimization**: Render passes in URP allow you to control the
    order in which rendering tasks are executed. This enables you to optimize performance
    by efficiently batching and sorting objects, reducing overdraw, and minimizing
    unnecessary render calls. For the outline effect, you can ensure that only the
    necessary objects are rendered with the outline material, reducing the computational
    overhead.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：URP中的渲染通道允许你控制渲染任务执行的顺序。这使你能够通过高效地批处理和排序对象、减少过度绘制和最小化不必要的渲染调用来优化性能。对于轮廓效果，你可以确保只有必要的对象使用轮廓材质进行渲染，从而减少计算开销。'
- en: '**Integration with URP’s rendering pipeline**: URP provides a streamlined rendering
    pipeline optimized for performance across various platforms. By integrating your
    custom rendering effects, such as the outline effect, into URP’s pipeline using
    render passes, you ensure compatibility and consistency with URP’s rendering features
    and optimizations.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与URP渲染管道的集成**：URP提供了一个优化性能的简化渲染管道，适用于各种平台。通过使用渲染通道将你的自定义渲染效果（如轮廓效果）集成到URP的管道中，你确保了与URP的渲染功能和优化的兼容性和一致性。'
- en: '**Consistency across platforms**: URP is designed to provide consistent rendering
    results across different platforms and devices, including desktop, mobile, and
    consoles. By leveraging URP’s features, you can ensure that your outline effect
    behaves predictably and performs optimally across a wide range of target platforms.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台一致性**：URP旨在为不同平台和设备（包括桌面、移动和游戏机）提供一致的渲染结果。通过利用URP的功能，你可以确保你的轮廓效果在各种目标平台上表现可预测且性能最优。'
- en: '**Shader graph integration**: URP seamlessly integrates with Unity’s Shader
    Graph tool, allowing you to create custom shaders visually without writing code.
    You can use Shader Graph to design the outline shader and easily incorporate it
    into your render pass, making the implementation process more accessible and intuitive.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器图集成**：URP无缝集成Unity的Shader Graph工具，允许你通过视觉方式创建自定义着色器而无需编写代码。你可以使用Shader
    Graph来设计轮廓着色器，并轻松将其集成到渲染通道中，使实现过程更加易于访问和直观。'
- en: Overall, while it’s possible to apply the outline effect directly without utilizing
    URP’s render pass feature, integrating it with URP offers advantages in terms
    of performance optimization, modularity, consistency, and compatibility with Unity’s
    rendering pipeline. It provides a more robust and flexible solution for implementing
    custom rendering effects in your Unity projects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，虽然可以在不利用URP的渲染通道功能的情况下直接应用轮廓效果，但将其与URP集成在性能优化、模块化、一致性和与Unity渲染管线兼容性方面提供了优势。它为在Unity项目中实现自定义渲染效果提供了一个更强大和灵活的解决方案。
- en: Game development benefits from pre-built assets and C# scripts, saving time
    and enhancing creativity. Unity’s URP optimizes visuals and performance. Understanding
    URP versus HDRP aids pipeline selection. URP setup involves package installation
    and configuration. URP features include lightweight rendering, Shader Graph integration,
    and advanced techniques such as Custom Render Passes. Render passes in URP offer
    modularity and performance optimization.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发得益于预构建资源和C#脚本，节省了时间并提高了创造力。Unity的URP优化了视觉效果和性能。了解URP与HDRP的区别有助于选择管线。URP的设置涉及包安装和配置。URP的功能包括轻量级渲染、Shader
    Graph集成以及自定义渲染通道等高级技术。URP中的渲染通道提供了模块化和性能优化。
- en: In the upcoming section, we’ll explore integrating backend services, understanding
    their significance in game development, and the reasons for their necessity. Additionally,
    I’ll illustrate their usage through an example featuring one of the available
    services.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨后端服务的集成，了解其在游戏开发中的重要性以及其必要性的原因。此外，我将通过一个包含可用服务之一的示例来说明它们的用法。
- en: Integrating backend services with C#
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将后端服务与C#集成
- en: In this section, we will understand how the integration of backend APIs with
    C# provides us with a potent tool to enrich our projects with robust functionalities.
    Through the utilization of these APIs, we can seamlessly link their Unity projects
    to external services, facilitating features such as user authentication, data
    storage, and leaderboards.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何通过将后端API与C#集成，为我们提供一种强大的工具，以丰富我们的项目功能。通过使用这些API，我们可以无缝地将他们的Unity项目链接到外部服务，从而实现用户身份验证、数据存储和排行榜等功能。
- en: Let’s explore backend services and understand their significance in games.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索后端服务，并了解它们在游戏中的重要性。
- en: Backend services
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端服务
- en: 'Backend services refer to the set of functionalities and infrastructure components
    that support the operation of software applications, including games, from the
    server-side perspective. In the context of game development, backend services
    encompass various features and capabilities designed to enhance gameplay experiences,
    manage player data, and facilitate online interactions. Here are some key aspects
    of backend services in game development:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务指的是支持软件应用程序（包括游戏）从服务器端视角运行的一组功能性和基础设施组件。在游戏开发背景下，后端服务包括旨在增强游戏体验、管理玩家数据和促进在线互动的各种功能和能力。以下是游戏开发中后端服务的一些关键方面：
- en: '**Data storage**: Provides storage solutions for game-related data, including
    player profiles, game progress, achievements, inventory, and other persistent
    game state information. This data is typically stored in databases or cloud storage
    systems, ensuring reliability, scalability, and accessibility across different
    platforms and devices.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：为游戏相关数据提供存储解决方案，包括玩家资料、游戏进度、成就、库存以及其他持久化游戏状态信息。这些数据通常存储在数据库或云存储系统中，确保在不同平台和设备上具有可靠性、可扩展性和可访问性。'
- en: '**User authentication**: Offers authentication mechanisms to verify the identity
    of players and ensure secure access to game features and content. Authentication
    processes typically involve user registration, login, and session management,
    employing encryption and secure protocols to protect user credentials and prevent
    unauthorized access.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户身份验证**：提供身份验证机制以验证玩家的身份并确保对游戏功能和内容的安全访问。身份验证过程通常涉及用户注册、登录和会话管理，采用加密和安全的协议来保护用户凭据并防止未经授权的访问。'
- en: '**Multiplayer functionality**: Enables the implementation of multiplayer features
    in games, allowing players to connect, interact, and compete with each other in
    real time. This includes functionalities such as matchmaking, lobby management,
    game session orchestration, and synchronization of player actions across networked
    environments.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多人功能**：使游戏实现多人功能成为可能，允许玩家实时连接、交互和竞争。这包括匹配、大厅管理、游戏会话编排和网络环境中玩家动作的同步等功能。'
- en: '**Real-time communication**: Facilitate real-time communication between game
    clients and servers, supporting features such as in-game chat, messaging, notifications,
    and real-time updates. These communication channels enable players to engage with
    each other, receive important game updates, and participate in collaborative or
    competitive gameplay experiences.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时通信**：促进游戏客户端和服务器之间的实时通信，支持游戏内聊天、消息、通知和实时更新等功能。这些通信渠道使玩家能够相互交流，接收重要的游戏更新，并参与协作或竞技游戏体验。'
- en: '**Analytics and insights**: Provides analytics tools and capabilities to track
    player behavior, monitor game performance, and gain insights into player engagement,
    retention, and monetization patterns. Analytics data helps us make informed decisions,
    optimize game mechanics, and tailor experiences to meet player preferences.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析和洞察**：提供分析工具和能力，以跟踪玩家行为、监控游戏性能，并深入了解玩家的参与度、留存率和货币化模式。分析数据帮助我们做出明智的决策，优化游戏机制，并针对玩家偏好定制体验。'
- en: '**Live operations and content management**: Supports live operations and content
    management, allowing us to deploy updates, patches, and new content to games seamlessly.
    This includes features such as **content delivery networks** (**CDNs**), version
    control, A/B testing, and live event management, enabling dynamic and evolving
    gameplay experiences.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时运营和内容管理**：支持实时运营和内容管理，使我们能够无缝部署更新、补丁和新内容到游戏中。这包括**内容分发网络**（**CDNs**）、版本控制、A/B测试和实时事件管理等功能，使游戏体验动态且不断进化。'
- en: In summary, backend services form the foundation of modern game development,
    providing essential infrastructure and functionalities to support online multiplayer
    gaming, manage player data, analyze player behavior, and deliver engaging and
    immersive gameplay experiences across different platforms and devices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，后端服务是现代游戏开发的基础，提供必要的基础设施和功能，以支持在线多人游戏、管理玩家数据、分析玩家行为，并在不同平台和设备上提供引人入胜和沉浸式的游戏体验。
- en: Introduction of backend service providers and their features
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端服务提供商及其功能的介绍
- en: 'Several backend service providers offer comprehensive solutions tailored to
    the needs of game developers, each with its own set of features and capabilities.
    Here are some available services, and these are the most commonly used options
    at the time of writing this book:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 几个后端服务提供商提供针对游戏开发者需求的全面解决方案，每个都有一套自己的特性和功能。以下是可用的服务，这些是在撰写本书时的常用选项：
- en: '**Firebase**: Developed by Google, Firebase offers a suite of backend services
    including real-time database, authentication, cloud storage, and hosting. It provides
    seamless integration with Unity, making it an ideal choice for us seeking a robust
    and scalable backend solution.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firebase**：由谷歌开发，Firebase提供一系列后端服务，包括实时数据库、身份验证、云存储和托管。它提供了与Unity的无缝集成，使我们寻求强大且可扩展的后端解决方案的理想选择。'
- en: '**PlayFab**: PlayFab offers a comprehensive backend platform specifically designed
    for game developers. Its features include player authentication, data storage,
    in-game analytics, virtual currency management, and live operations tools. PlayFab’s
    flexible APIs and SDKs support easy integration with Unity, empowering us to build
    engaging multiplayer experiences and live service features.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PlayFab**：PlayFab提供专为游戏开发者设计的全面后端平台。其功能包括玩家身份验证、数据存储、游戏内分析、虚拟货币管理和实时运营工具。PlayFab的灵活API和SDK支持与Unity的轻松集成，使我们能够构建引人入胜的多人体验和实时服务功能。'
- en: '**Amazon Web Services (AWS)**: AWS provides a wide range of cloud-based services
    including databases, authentication, content delivery, and analytics. With offerings
    such as Amazon DynamoDB, Amazon Cognito, and Amazon GameLift, AWS offers scalable
    solutions for game developers looking to build, deploy, and manage backend infrastructure
    with flexibility and reliability.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚马逊网络服务 (AWS)**：AWS 提供了包括数据库、身份验证、内容交付和数据分析在内的广泛基于云的服务。通过提供 Amazon DynamoDB、Amazon
    Cognito 和 Amazon GameLift 等服务，AWS 为寻求以灵活性和可靠性构建、部署和管理后端基础设施的游戏开发者提供了可扩展的解决方案。'
- en: We’ll use PlayFab in this chapter and in the next section, we will implement
    it in our project accordingly. Let’s begin integrating PlayFab.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用 PlayFab，并在下一节中相应地将其实现到我们的项目中。让我们开始集成 PlayFab。
- en: Integrating PlayFab
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成 PlayFab
- en: In this guide, I’ll walk you through the process of implementing PlayFab and
    setting it up in your project. Then, we’ll create a sample authentication logic
    to demonstrate its usage.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南中，我将向您介绍实现 PlayFab 并在您的项目中设置它的过程。然后，我们将创建一个示例身份验证逻辑来演示其用法。
- en: 'To begin, you’ll need to download the PlayFab Unity package. I’ve utilized
    PlayFab SDK 2.188 for this purpose, which you can obtain from the following link:
    [https://github.com/PlayFab/UnitySDK/releases](https://github.com/PlayFab/UnitySDK/releases).
    Once you download it, follow these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要下载 PlayFab Unity 包。我为此使用了 PlayFab SDK 2.188，您可以从以下链接获取：[https://github.com/PlayFab/UnitySDK/releases](https://github.com/PlayFab/UnitySDK/releases)。下载后，按照以下步骤操作：
- en: In*Figure 8**.5*, as you can see, we’re extracting the PlayFab SDK into our
    project. Simply click **Import** to initiate the process of importing files and
    compiling them.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图 8.5**中，如您所见，我们将 PlayFab SDK 提取到我们的项目中。只需点击**导入**即可启动导入文件和编译的过程。
- en: '![Figure 8.5 – Importing PlayFab SDK](img/B22017_08_05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 导入 PlayFab SDK](img/B22017_08_05.jpg)'
- en: Figure 8.5 – Importing PlayFab SDK
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 导入 PlayFab SDK
- en: 'Wait for Unity to finish compiling, then navigate to **Assets** | **PlayFabSDK**
    | **Shared** | **Public** | **Resources**. From there, you can select the Scriptable
    Object **PlayFabSharedSettings** to configure it for your project. In *Figure
    8**.6*, you can observe the settings of PlayFab that we can configure:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 Unity 编译完成，然后导航到**资产** | **PlayFabSDK** | **共享** | **公共** | **资源**。从那里，您可以选择可脚本对象**PlayFabSharedSettings**以配置它以适应您的项目。在**图
    8.6**中，您可以观察到我们可以配置的 PlayFab 设置：
- en: '![Figure 8.6 – PlayFab Shared Settings](img/B22017_08_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – PlayFab 共享设置](img/B22017_08_06.jpg)'
- en: Figure 8.6 – PlayFab Shared Settings
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – PlayFab 共享设置
- en: For **Request Type**, you can select **Unity Web Request** or choose the option
    appropriate for your project. However, for our project, I will opt for **Unity**
    **Web Request**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**请求类型**，您可以选择**Unity 网络请求**或选择适合您项目的选项。然而，对于我们的项目，我将选择**Unity 网络请求**。
- en: We will include the **Title ID** value, which you can obtain from your PlayFab
    game project dashboard. If you don’t have a project yet, you can create one and
    use its key in your project. *Figure 8**.7* shows where you can locate the ID
    needed for PlayFab settings.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将包括**标题 ID**值，您可以从您的 PlayFab 游戏项目仪表板中获取。如果您还没有项目，您可以创建一个并使用其密钥在您的项目中。**图 8.7**显示了您可以在哪里找到用于
    PlayFab 设置的 ID。
- en: '![Figure 8.7 – PlayFab title ID](img/B22017_08_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – PlayFab 标题 ID](img/B22017_08_07.jpg)'
- en: Figure 8.7 – PlayFab title ID
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – PlayFab 标题 ID
- en: 'Next, access the project to retrieve the secret key; to do that, click on the
    settings icon and select **Title settings**:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，访问项目以检索密钥；为此，点击设置图标并选择**标题设置**：
- en: '![Figure 8.8 – PlayFab Title settings](img/B22017_08_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – PlayFab 标题设置](img/B22017_08_08.jpg)'
- en: Figure 8.8 – PlayFab Title settings
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – PlayFab 标题设置
- en: 'The preceding step will open the settings tabs and from here, we can navigate
    to the **Secret Keys** tab to retrieve the secret key, as depicted in *Figure
    8**.9*:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一步将打开设置选项卡，从这里，我们可以导航到**密钥**选项卡以检索密钥，如图 8.9 所示：
- en: '![Figure 8.9 –  Title secret key](img/B22017_08_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 标题密钥](img/B22017_08_09.jpg)'
- en: Figure 8.9 – Title secret key
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 标题密钥
- en: Click on **Show** to reveal the secret key. You can then copy it and paste it
    into the **Developer Secret Key** field in the PlayFab settings in our game.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示**以显示密钥。然后您可以复制它并将其粘贴到我们游戏中的 PlayFab 设置中的**开发者密钥**字段。
- en: 'That’s it! You now have the PlayFab SDK integrated into your project. In the
    next steps, we will begin using it and learn through an example. While this example
    is just a sample, it will cover the full flow of using this package. There are
    numerous possibilities for utilizing this package, so feel free to explore their
    documentation for further insights: [https://learn.microsoft.com/en-us/gaming/playfab/](B22017_08.xhtml#_idTextAnchor138).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在你已经将PlayFab SDK集成到你的项目中了。在接下来的步骤中，我们将开始使用它，并通过示例来学习。虽然这个示例只是一个样本，但它将涵盖使用这个包的完整流程。这个包有无数的使用可能性，所以请自由探索它们的文档以获取更多信息：[https://learn.microsoft.com/en-us/gaming/playfab/](B22017_08.xhtml#_idTextAnchor138)。
- en: Developing a sample login system
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发一个示例登录系统
- en: There are various methods for user login in games, such as using email, guest
    accounts, and, for mobile platforms, utilizing Play services for Android and Game
    Center for iOS. PlayFab offers a variety of options to facilitate user login based
    on the game platform.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中用户登录有多种方法，例如使用电子邮件、访客账户，以及对于移动平台，利用Android的Play服务和iOS的Game Center。PlayFab提供了各种选项，以方便根据游戏平台进行用户登录。
- en: 'For this system, we can establish a well-organized structure by following these
    steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个系统，我们可以通过以下步骤建立一个有组织的结构：
- en: 'We will begin by creating an interface for the login method. In the following
    code block, you will find a login method along with callbacks for the login state:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先为登录方法创建一个接口。在下面的代码块中，你将找到一个登录方法以及登录状态的回调：
- en: '[PRE1]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we can create a class for each login method. For guest login, we will
    utilize the device ID for authentication. In the following code block, we have
    implemented the **ILogin** interface with the **DeviceLogin** class and incorporated
    the logic for logging in with the device ID.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以为每种登录方法创建一个类。对于访客登录，我们将使用设备ID进行身份验证。在下面的代码块中，我们已经实现了**ILogin**接口，并使用**DeviceLogin**类实现了使用设备ID进行登录的逻辑。
- en: '[PRE2]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can follow these steps and create additional login logic, especially if
    you are targeting mobile platforms, as there will be alternative login methods
    specific to mobile devices.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以遵循这些步骤并创建额外的登录逻辑，特别是如果你针对的是移动平台，因为将会有针对移动设备的特定登录方法。
- en: 'Then, we can create a **LoginManager** class, which will be responsible for
    invoking the appropriate login method, as demonstrated in the following code block:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个**LoginManager**类，它将负责调用适当的登录方法，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the next step, we will implement a **PlayfabManager** script to manage
    the login methods and handle user input, subsequently triggering appropriate actions:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一步，我们将实现一个**PlayfabManager**脚本，用于管理登录方法并处理用户输入，从而触发适当的操作：
- en: '[PRE4]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In `PlayFabManager`, you’ll discover methods to log in using email and device
    ID, along with callbacks indicating login status. Additionally, I’ve included
    an example of how to handle successful user logins by loading their data. This
    enables us to execute further logic based on the data stored in PlayFab.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`PlayFabManager`中，你会发现使用电子邮件和设备ID进行登录的方法，以及表示登录状态的回调。此外，我还包括了一个处理成功用户登录的示例，通过加载他们的数据来实现。这使得我们可以根据PlayFab中存储的数据执行进一步的逻辑。
- en: 'That concludes this example, which may seem simple but encompasses the complete
    process of utilizing PlayFab. This package offers extensive capabilities, including
    leaderboard management, remote settings configuration, analytics, and matchmaking.
    As mentioned earlier, explore their documentation for further insights and possibilities:
    [https://learn.microsoft.com/en-us/gaming/playfab/](B22017_08.xhtml#_idTextAnchor138).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例就结束了，它可能看起来很简单，但它涵盖了使用PlayFab的完整过程。这个包提供了广泛的功能，包括排行榜管理、远程设置配置、分析和匹配。如前所述，探索它们的文档以获取更多信息和建议：[https://learn.microsoft.com/en-us/gaming/playfab/](B22017_08.xhtml#_idTextAnchor138)。
- en: In conclusion, we have gained insight into the significance of backend services
    for our games. We successfully integrated PlayFab into our project and learned
    to develop a login system through this process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们深入了解了后端服务对我们游戏的重要性。我们成功地将PlayFab集成到我们的项目中，并通过这个过程学习了如何开发登录系统。
- en: In the next section, we will delve into analytics APIs, their benefits in games,
    and the reasons behind their necessity in our game development endeavors.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解分析API，它们在游戏中的好处以及它们在我们游戏开发努力中的必要性。
- en: Integrating analytics APIs with C#
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将分析API与C#集成
- en: 'Analytics APIs are software interfaces that enable us to integrate analytics
    functionality into our applications, including games. These APIs allow us to collect,
    analyze, and interpret data related to user interactions, behaviors, and performance
    metrics within our games. Here are some key aspects of analytics APIs:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 分析API是软件接口，使我们能够将分析功能集成到我们的应用程序中，包括游戏。这些API允许我们收集、分析和解释与游戏内用户交互、行为和性能指标相关的数据。以下是分析API的一些关键方面：
- en: '**Data collection**: Analytics APIs facilitate the collection of various types
    of data generated by user interactions within the game. This includes information
    such as player actions, session durations, in-game purchases, progression milestones,
    and user demographics.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据收集**：分析API简化了收集游戏内用户交互产生的各种类型数据的流程。这包括诸如玩家行为、会话时长、游戏内购买、进度里程碑和用户人口统计信息等数据。'
- en: '**Event tracking**: We can use analytics APIs to track specific events or actions
    within the game, such as level completions, item acquisitions, quest achievements,
    and social interactions. By defining and tracking custom events, we can gain insights
    into how players engage with different aspects of the game.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件跟踪**：我们可以使用分析API跟踪游戏中的特定事件或行为，例如关卡完成、物品获取、任务成就和社交互动。通过定义和跟踪自定义事件，我们可以深入了解玩家如何与游戏的不同方面互动。'
- en: '**Performance monitoring**: Analytics APIs provide tools for monitoring and
    analyzing the performance of the game, including metrics related to frame rates,
    loading times, network latency, and device specifications. This data helps us
    identify performance bottlenecks, optimize game performance, and ensure smooth
    gameplay experiences for players.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能监控**：分析API提供监控和分析游戏性能的工具，包括与帧率、加载时间、网络延迟和设备规格相关的指标。这些数据帮助我们识别性能瓶颈，优化游戏性能，并确保玩家获得流畅的游戏体验。'
- en: '**User behavior analysis**: Analytics APIs enable us to analyze user behavior
    patterns and trends, helping them understand how players navigate the game, which
    features they engage with the most, and what factors influence their retention
    and engagement. This information informs game design decisions and helps us tailor
    the game experience to better meet player expectations.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户行为分析**：分析API使我们能够分析用户行为模式和趋势，帮助他们了解玩家如何导航游戏，他们最常参与哪些功能，以及哪些因素影响他们的留存和参与度。这些信息有助于游戏设计决策，并帮助我们调整游戏体验以更好地满足玩家期望。'
- en: '**Retention and monetization analysis**: Analytics APIs allow us to track player
    retention rates over time and analyze factors that contribute to player churn.
    Additionally, we can analyze monetization metrics, such as revenue per user, conversion
    rates, and **average revenue per paying user** (**ARPPU**), to optimize monetization
    strategies and maximize revenue opportunities.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**留存和货币化分析**：分析API使我们能够跟踪玩家留存率随时间的变化，并分析导致玩家流失的因素。此外，我们还可以分析货币化指标，如每用户收入、转化率和**平均每付费用户收入**（**ARPPU**），以优化货币化策略并最大化收入机会。'
- en: '**Real-time reporting and insights**: Analytics APIs provide real-time reporting
    and visualization tools that enable us to access actionable insights and make
    data-driven decisions. Interactive dashboards, charts, and reports allow us to
    monitor **key performance indicators** (**KPIs**), track progress toward goals,
    and identify opportunities for improvement.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时报告和洞察**：分析API提供实时报告和可视化工具，使我们能够获取可操作的洞察并做出数据驱动的决策。交互式仪表板、图表和报告使我们能够监控**关键绩效指标**（**KPIs**），跟踪目标进展，并识别改进的机会。'
- en: In summary, analytics APIs empower us to gain valuable insights into player
    behavior, performance, and monetization, enabling them to optimize game design,
    enhance player experiences, and drive business success. By integrating analytics
    functionality into their games, we can make informed decisions and continuously
    improve the quality and performance of their games.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，分析API使我们能够深入了解玩家的行为、性能和货币化，使他们能够优化游戏设计，提升玩家体验，并推动商业成功。通过将分析功能集成到他们的游戏中，我们可以做出明智的决策，并持续改进游戏的质量和性能。
- en: Integrating GameAnalytics
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成GameAnalytics
- en: '**GameAnalytics** is a popular package for Unity game development that provides
    analytics and insights into player behavior and game performance. It allows us
    to track various metrics, such as player progression, retention rates, in-game
    events, and monetization data, to optimize their games and improve player engagement.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameAnalytics** 是一个流行的 Unity 游戏开发包，它提供了对玩家行为和游戏性能的分析和洞察。它允许我们跟踪各种指标，例如玩家进度、留存率、游戏内事件和货币化数据，以优化他们的游戏并提高玩家参与度。'
- en: 'Here are some key features and capabilities of the GameAnalytics package for
    Unity:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 GameAnalytics Unity 包的关键功能和能力：
- en: '**Event tracking**: GameAnalytics enables us to track custom events within
    their games, such as level completions, item purchases, achievements unlocked,
    and tutorial progress. This data helps us understand how players interact with
    their games and identify areas for improvement.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件跟踪**：GameAnalytics 使我们能够在他们的游戏中跟踪自定义事件，例如关卡完成、物品购买、解锁成就和教程进度。这些数据帮助我们了解玩家如何与他们的游戏互动，并确定改进的领域。'
- en: '**User analytics**: The package provides insights into user behavior and demographics,
    including active users, session lengths, retention rates, and user segmentation.
    We can analyze this data to tailor their games to specific player preferences
    and demographics.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户分析**：该包提供了对用户行为和人口统计数据的洞察，包括活跃用户、会话长度、留存率和用户细分。我们可以分析这些数据，以根据特定玩家的偏好和人口统计数据调整他们的游戏。'
- en: '**Monetization tracking**: GameAnalytics allows us to track in-app purchases,
    advertising revenue, and other monetization metrics. By analyzing revenue data
    alongside player behavior, we can optimize their monetization strategies and maximize
    revenue generation.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**货币化跟踪**：GameAnalytics 允许我们跟踪应用内购买、广告收入和其他货币化指标。通过分析收入数据与玩家行为的结合，我们可以优化他们的货币化策略并最大化收入生成。'
- en: '**Real-time dashboards**: The package offers real-time dashboards and reporting
    tools that visualize game analytics data, making it easy for us to monitor game
    performance and make data-driven decisions. We can customize dashboards to focus
    on specific metrics and KPIs.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时仪表板**：该包提供实时仪表板和报告工具，可视化游戏分析数据，使我们能够轻松监控游戏性能并做出数据驱动的决策。我们可以自定义仪表板，专注于特定的指标和关键绩效指标（KPI）。'
- en: '**Integration with Unity**: GameAnalytics provides a Unity SDK that seamlessly
    integrates with Unity projects, allowing for easy implementation and tracking
    of analytics events and metrics. The SDK supports both Unity Editor and runtime
    environments, enabling us to test and analyze their games throughout the development
    lifecycle.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与 Unity 集成**：GameAnalytics 提供了一个 Unity SDK，它可以无缝集成到 Unity 项目中，使得分析事件和指标的实施和跟踪变得简单。SDK
    支持Unity 编辑器和运行时环境，使我们能够在整个开发周期中测试和分析他们的游戏。'
- en: '**Cross-platform support**: GameAnalytics supports multiple platforms, including
    PC, mobile, console, and web, allowing us to track analytics data across various
    devices and platforms. This cross-platform support enables us to gain insights
    into player behavior across different environments.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台支持**：GameAnalytics 支持多个平台，包括 PC、移动、游戏机和网页，使我们能够在各种设备和平台上跟踪分析数据。这种跨平台支持使我们能够深入了解不同环境中的玩家行为。'
- en: Overall, GameAnalytics is a valuable tool for gaining insights into player behavior,
    optimizing game performance, and maximizing revenue through data-driven decisions.
    Its user-friendly interface, robust feature set, and cross-platform support make
    it a popular choice among game developers worldwide.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，GameAnalytics 是一个有价值的工具，可以帮助我们深入了解玩家行为，优化游戏性能，并通过数据驱动的决策最大化收入。其用户友好的界面、强大的功能集和跨平台支持使其成为全球游戏开发者中的热门选择。
- en: 'In the subsequent steps, we will integrate GameAnalytics and configure our
    initial event:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续步骤中，我们将集成 GameAnalytics 并配置我们的初始事件：
- en: 'We will utilize Version 7.8 of the GameAnalytics Unity SDK, which you can download
    using the following link: [https://download.gameanalytics.com/unity/7.8.0/GA_SDK_UNITY.unitypackage](B22017_08.xhtml#_idTextAnchor137).'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 GameAnalytics Unity SDK 的 7.8.0 版本，您可以通过以下链接下载：[https://download.gameanalytics.com/unity/7.8.0/GA_SDK_UNITY.unitypackage](B22017_08.xhtml#_idTextAnchor137)。
- en: After downloading the package, implement it into your project by clicking on
    **Import**, as illustrated in *Figure 8**.10*.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载包后，通过点击**导入**将其实现到您的项目中，如图 *图 8**.10* 所示。
- en: '![Figure 8.10 – Importing the GameAnalytics package](img/B22017_08_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 导入 GameAnalytics 包](img/B22017_08_10.jpg)'
- en: Figure 8.10 – Importing the GameAnalytics package
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 导入 GameAnalytics 包
- en: After waiting for Unity to compile the files, navigate to **Window | GameAnalytics
    | Select Settings**, as demonstrated in *Figure 8**.11*.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在等待Unity编译文件后，导航到**窗口 | 游戏分析 | 选择设置**，如图*图8.11*所示。
- en: '![Figure 8.11 – Opening the GameAnalytics settings](img/B22017_08_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 打开游戏分析设置](img/B22017_08_11.jpg)'
- en: Figure 8.11 – Opening the GameAnalytics settings
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 打开游戏分析设置
- en: Following the preceding step will display the GameAnalytics settings. Then,
    you can log in with your account or sign up and create a project if you haven’t
    already done so, as illustrated in *Figure 8**.12.*
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照前面的步骤操作，将显示游戏分析设置。然后，你可以使用你的账户登录或注册并创建一个项目（如果你还没有这样做），如图*图8.12*所示。
- en: '![Figure 8.12 – GameAnalytics settings](img/B22017_08_12.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 游戏分析设置](img/B22017_08_12.jpg)'
- en: Figure 8.12 – GameAnalytics settings
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 游戏分析设置
- en: After successfully logging in and having a project in your GameAnalytics dashboard,
    you’ll find the option to link your project and implement it with the appropriate
    platform, be it Android, iOS, or Windows. For our game, I selected Windows as
    we are working on a PC game. In *Figure 8**.13*, you’ll see information related
    to the project, such as the game and organization, and the important elements,
    the game key and secret key, which are automatically added upon successful login.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功登录并拥有GameAnalytics仪表板中的项目后，你将找到链接你的项目并使用适当的平台实现它的选项，无论是Android、iOS还是Windows。对于我们的游戏，我选择了Windows，因为我们正在制作PC游戏。在*图8.13*中，你可以看到与项目相关的信息，例如游戏和组织，以及重要的元素，游戏密钥和密钥，这些在成功登录后会自动添加。
- en: '![Figure 8.13 – Link our game with GameAnalytics](img/B22017_08_13.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 将我们的游戏与游戏分析链接](img/B22017_08_13.jpg)'
- en: Figure 8.13 – Link our game with GameAnalytics
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 将我们的游戏与游戏分析链接
- en: Then, you need to add the GameAnalytics game object to our scene. Remember,
    it’s a persistent game object, so there’s no need to implement it in all scenes.
    Simply add one game object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将游戏分析游戏对象添加到我们的场景中。记住，它是一个持久化的游戏对象，所以不需要在所有场景中实现它。只需添加一个游戏对象。
- en: You should navigate to **Window | GameAnalytics | Create GameAnalytics Object**,
    and the game object will be added to your scene, as shown in *Figure 8**.14*.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该导航到**窗口 | 游戏分析 | 创建游戏分析对象**，游戏对象将被添加到你的场景中，如图*图8.14*所示。
- en: '![Figure 8.14 – Adding a GameAnalytics object to our scene](img/B22017_08_14.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 将游戏分析对象添加到我们的场景](img/B22017_08_14.jpg)'
- en: Figure 8.14 – Adding a GameAnalytics object to our scene
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 将游戏分析对象添加到我们的场景
- en: Now, we need to begin implementing events into our code, which will depend on
    what you need to track. Allow me to provide you with an example for clarification.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要开始在代码中实现事件，这取决于你需要跟踪的内容。让我提供一个例子来澄清。
- en: Example of GameAnalytics usage
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏分析使用示例
- en: 'You can now initialize GameAnalytics and start using events in your code, as
    demonstrated in the following code block:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以初始化游戏分析并开始在代码中使用事件，如下面的代码块所示：
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can add this in the `GameManager` script as an example, or if you have a
    script to handle the initialization of services in your game.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`GameManager`脚本中添加这个示例，或者如果你有一个处理游戏服务初始化的脚本。
- en: 'You can utilize it as shown in the following code block. Don’t forget to include
    the `GameAnalyticsSDK` namespace:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像以下代码块中所示那样使用它。别忘了包含`GameAnalyticsSDK`命名空间：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And there are various types of events available for better data collection.
    For more detailed information, you can refer to the GameAnalytics documentation:
    [https://docs.gameanalytics.com/event-types](B22017_08.xhtml#_idTextAnchor136).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有各种类型的事件可供更好的数据收集。有关更详细的信息，你可以参考游戏分析文档：[https://docs.gameanalytics.com/event-types](B22017_08.xhtml#_idTextAnchor136)。
- en: You need to build the scene containing the GameAnalytics game object first to
    start sending events. It may take a few minutes before results start appearing
    on the website.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要首先构建包含游戏分析游戏对象的场景，然后开始发送事件。结果可能需要几分钟才能在网站上显示。
- en: You can visit your game on the GameAnalytics website and then navigate to the
    real-time section to view the data, as depicted in *Figure 8**.15*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问游戏分析网站上的你的游戏，然后导航到实时部分来查看数据，如图*图8.15*所示。
- en: '![Figure 8.15 – Real-time data from our game](img/B22017_08_15.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 我们游戏的实时数据](img/B22017_08_15.jpg)'
- en: Figure 8.15 – Real-time data from our game
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 我们游戏的实时数据
- en: Now that we’ve integrated an analytics API, specifically GameAnalytics, into
    our project, we’ve successfully incorporated it and put it to use.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将分析API，特别是GameAnalytics，整合到我们的项目中，我们已经成功整合并投入使用。
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ve integrated any package, don’t spend too much time on its possibilities
    initially. Simply integrate it, check for errors, create a sample, and then explore
    its full potential gradually. Don’t complicate things unnecessarily at the outset.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经整合了任何包，最初不要在它的可能性上花费太多时间。简单地进行整合，检查错误，创建一个示例，然后逐步探索其全部潜力。一开始不要无谓地使事情复杂化。
- en: Incorporating third-party assets is a valuable skill for any developer. Many
    successful games rely on external resources to save time and ensure top-notch
    quality that might be challenging to achieve independently.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将第三方资产整合是一项对任何开发者都非常有价值的技能。许多成功的游戏都依赖于外部资源来节省时间并确保可能难以独立实现的顶级质量。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the integration of pre-built assets and APIs
    using C# in Unity, a pivotal aspect of game development. We began by exploring
    the utilization of pre-built assets to enhance game visuals and optimize performance,
    followed by the integration of rendering pipelines to achieve better visual fidelity.
    The discussion then shifted to the importance of backend services, highlighting
    the significance of authentication logic as an example of their utility in game
    development. Additionally, we explored analytics APIs and their role in understanding
    player behavior and optimizing game performance, demonstrating how to implement
    them effectively into our game projects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了使用Unity中的C#整合预构建资源和API，这是游戏开发的一个关键方面。我们首先探讨了利用预构建资源来增强游戏视觉效果和优化性能的方法，接着整合了渲染管线以实现更好的视觉效果。讨论随后转向了后端服务的重要性，以身份验证逻辑为例，强调了它们在游戏开发中的实用性。此外，我们还探讨了分析API及其在理解玩家行为和优化游戏性能中的作用，展示了如何有效地将它们整合到我们的游戏项目中。
- en: Looking ahead to [*Chapter 9*](B22017_09_split_000.xhtml#_idTextAnchor139),
    we will focus on optimizing game performance using Unity’s profiling tools. You’ll
    learn to leverage tools like the Profiler, Frame Debugger, and Memory Profiler
    to identify and address performance bottlenecks, optimize rendering, and manage
    memory usage. Through hands-on exercises and practical insights, you’ll gain mastery
    over optimization techniques to ensure your game runs smoothly and efficiently.
    Get ready to elevate your game’s performance in the upcoming chapter!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 展望[第9章](B22017_09_split_000.xhtml#_idTextAnchor139)，我们将专注于使用Unity的剖析工具优化游戏性能。你将学习如何利用Profiler、帧调试器和内存剖析器等工具来识别和解决性能瓶颈，优化渲染和管理内存使用。通过实际练习和实用见解，你将掌握优化技术，以确保你的游戏运行顺畅且高效。准备好在下一章提升你游戏的表现力吧！
