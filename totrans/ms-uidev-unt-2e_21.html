<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-269"><a id="_idTextAnchor461" class="pcalibre pcalibre1 calibre6"/>17</h1>
<h1 id="_idParaDest-270" class="calibre5"><a id="_idTextAnchor462" class="pcalibre pcalibre1 calibre6"/>Optimizing Unity UI</h1>
<p class="calibre3"><strong class="bold"><a id="_idTextAnchor463" class="pcalibre pcalibre1 calibre6"/>Optimization</strong> is the process that we use to make sure that our game runs smoothly and the framerate is consistent. Through optimization we first locate resources within our game that are reducing our game’s performance and then implement solutions that will improve that performance.</p>
<p class="calibre3">There are lots of things that can cause a game to have poor performance or low framerate. This can include things like unoptimized lighting, poorly written scripts, large assets, and improper UI construction. Since this is a UI book, we’ll focus only on how improving your UI construction can improve your performance.</p>
<p class="calibre3">In this chapter, I will discuss the following:</p>
<ul class="calibre16">
<li class="calibre14">Key terms and basic information related to optimization</li>
<li class="calibre14">An overview of the tools provided within unity that can help you determine how performant your game is</li>
<li class="calibre14">Various optimization strategies for UI</li>
</ul>
<p class="calibre3">Before you can optimize your UI, you need to learn how to tell if it is performant or not. Let’s review some basic terms and principles of graphics rendering.</p>
<p class="callout-heading">Note</p>
<p class="callout">This chapter will only cover performance profiling on a basic level and its focus will be more on things you can do to build better UI. If, by the end of the chapter, you’d like more information on performance profiling, I suggest the following resource: <a href="https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound" class="pcalibre pcalibre1 calibre6">https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound</a></p>
<h1 id="_idParaDest-271" class="calibre5"><a id="_idTextAnchor464" class="pcalibre pcalibre1 calibre6"/>Optimization basics</h1>
<p class="calibre3">As I stated earlier, optimization is the process that we use to make sure that our application runs smoothly, and the <a id="_idIndexMarker987" class="pcalibre pcalibre1 calibre6"/>framerate is consistent. We want to optimize our game to ensure that all players have the same experience regardless of the conditions in which they are playing. So, for example, if we are making a PC game, we want to make sure that every player has the same experience regardless of the power of their machine. We also want to make sure if a player has many things rendering on the screen, the game does not lag compared to when there were less things rendering on the screen.</p>
<p class="calibre3">We do not want the frame rate to reduce, and we do not want the inputs to lag. This is extremely important for things like games. In something like a first-person shooter or platform this could a lag in input could mean a player loses a match or falls off a cliff.</p>
<p class="calibre3">Let’s review some basic terminology that you hear often when discussing optimization. First, we’ll start with a common metric for determining an application’s performance.</p>
<h2 id="_idParaDest-272" class="calibre7"><a id="_idTextAnchor465" class="pcalibre pcalibre1 calibre6"/>Frame Rate</h2>
<p class="calibre3"><strong class="bold">Framerate</strong> is one metric in which we measure<a id="_idIndexMarker988" class="pcalibre pcalibre1 calibre6"/> our application’s optimization. It’s a good metric, because it’s <a id="_idIndexMarker989" class="pcalibre pcalibre1 calibre6"/>not just something that is happening in the background that the user never notices. Users can see and notice changes in framerate, so measuring its performance measures how our users experience our games.</p>
<p class="calibre3">Framerate can be measured in <strong class="bold">frames per second</strong> (<strong class="bold">fps</strong>) or time in milliseconds. The goal is to have a consistent framerate<a id="_idIndexMarker990" class="pcalibre pcalibre1 calibre6"/> regardless of what is happening in the game.</p>
<p class="calibre3">When measuring framerate in frames per second, each individual frame renders out in a certain amount of time. Let’s say you have a goal of 60 fps. You would need to make sure that all aspects of your application can run at 60 fps. So, your goal is to have a consistent number of frames per second. Therefore, when we set a fps benchmark, that means we want our application to run at that fps consistently across all parts of the application. We don’t want our game to run at 60 fps at the beginning and then dip when our UI opens.</p>
<p class="calibre3">Another way to measure framerate is time in milliseconds. Every frame takes some amount of time to render. We want that amount of time to be as low as possible for each frame. 10 ms per frame is the equivalent of 60 fps and is a good time in milliseconds.</p>
<p class="calibre3">Now that we’ve discussed <a id="_idIndexMarker991" class="pcalibre pcalibre1 calibre6"/>what frame rate is, let’s talk about where resources are used on our computer.</p>
<h2 id="_idParaDest-273" class="calibre7"><a id="_idTextAnchor466" class="pcalibre pcalibre1 calibre6"/>GPU and CPU</h2>
<p class="calibre3">When trying to optimize<a id="_idIndexMarker992" class="pcalibre pcalibre1 calibre6"/> your game, you will investigate your game’s resources to determine where the most resources are being used. You will want to identify whether the issues are on<a id="_idIndexMarker993" class="pcalibre pcalibre1 calibre6"/> the GPU or CPU. The <strong class="bold">Central Processing Unit</strong> (<strong class="bold">CPU</strong>) is the brain of the computer. The <strong class="bold">Graphics Processing Unit</strong> (<strong class="bold">GPU</strong>), is what renders<a id="_idIndexMarker994" class="pcalibre pcalibre1 calibre6"/> images. Whether our resources are on the GPU or CPU will determine the optimization solution.</p>
<p class="calibre3">Examples of problems on the<a id="_idIndexMarker995" class="pcalibre pcalibre1 calibre6"/> CPU are too many instructions, meaning too many scripts are running or the scripts take too long to run. Problems with the GPU tend to mean too many things are being rendered. The CPU does still play a part in rendering, however, as the CPU gives out the instructions and tells the GPU what to render. Often when discussing GPU and CPU, you’ll hear the term <strong class="bold">draw calls</strong>. A draw call is when the <a id="_idIndexMarker996" class="pcalibre pcalibre1 calibre6"/>CPU tells the GPU it needs to draw (or display) something on the screen. In general, you want to reduce the number of draw calls your game makes.</p>
<p class="calibre3">We’ll discuss GPU and CPU and how various choices we make designing our UI are affected by GPU and CPU more thoroughly in future sections of this chapter.</p>
<p class="calibre3">Now that we’ve covered some basic concepts of optimization, let’s review some tools provided by Unity that help us with optimization.</p>
<h1 id="_idParaDest-274" class="calibre5"><a id="_idTextAnchor467" class="pcalibre pcalibre1 calibre6"/>Tools for determining performance</h1>
<p class="calibre3">When determining your game’s <a id="_idIndexMarker997" class="pcalibre pcalibre1 calibre6"/>performance, you may use what is called benchmarking. <strong class="bold">Benchmarking</strong> allows you to see how well your app is running at various<a id="_idIndexMarker998" class="pcalibre pcalibre1 calibre6"/> times under given conditions. When benchmarking, you collect performance metrics and establish a baseline, or benchmark metric. You then compare subsequent results to that benchmark to see if the metric has improved or worsened. This lets you know if changes you have made have affected your game’s performance.</p>
<p class="calibre3">There are a few tools provided by Unity that can help you assess the performance of your game by providing you <a id="_idIndexMarker999" class="pcalibre pcalibre1 calibre6"/>performance metrics. Let’s look at those tools now.</p>
<p class="callout-heading">Note</p>
<p class="callout">Be aware of the environment and what you are benchmarking. It’s recommended that you benchmark on your target platform. That way you can determine the minimum standard device you plan to run your game on. The performance of your game will only get better with a better device.</p>
<h2 id="_idParaDest-275" class="calibre7"><a id="_idTextAnchor468" class="pcalibre pcalibre1 calibre6"/>Statistics window</h2>
<p class="calibre3">One simple way to view the <a id="_idIndexMarker1000" class="pcalibre pcalibre1 calibre6"/>performance of your game<a id="_idIndexMarker1001" class="pcalibre pcalibre1 calibre6"/> is through the <strong class="bold">Statistics</strong> window (or <strong class="bold">Stats</strong> windows) of the <strong class="bold">Game</strong> view.</p>
<div><div><img alt="Figure 17.1: Analyzing the Stats Window" src="img/B18327_17_01.jpg" class="calibre572"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 17.1: Analyzing the Stats Window</p>
<p class="calibre3">If you select the <strong class="bold">Stats</strong> button in the top right corner of your <strong class="bold">Game</strong> view, you’ll see various information about your project. Under the <strong class="bold">Graphics</strong> section, you’ll see frame rate in both frames per second <a id="_idIndexMarker1002" class="pcalibre pcalibre1 calibre6"/>and time in milliseconds. This will continuously change as it is based on each frame. You also see information about the CPU main thread and render thread.</p>
<p class="calibre3">If you’re using frame rate as <a id="_idIndexMarker1003" class="pcalibre pcalibre1 calibre6"/>your benchmark, you can watch the framerate values here and see how they change over time. Remember, the goal is consistency.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about the stats window, here: <a href="https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#" class="pcalibre pcalibre1 calibre6">https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#</a></p>
<p class="calibre3">The <strong class="bold">Stats</strong> window gives some at a glance basic information about your game’s performance. However, if you want<a id="_idIndexMarker1004" class="pcalibre pcalibre1 calibre6"/> a more in-depth breakdown of how your game is running, you can use the Unity Profiler.</p>
<h2 id="_idParaDest-276" class="calibre7"><a id="_idTextAnchor469" class="pcalibre pcalibre1 calibre6"/>Unity Profiler</h2>
<p class="calibre3">The Profiler shows you detailed information <a id="_idIndexMarker1005" class="pcalibre pcalibre1 calibre6"/>about your game’s<a id="_idIndexMarker1006" class="pcalibre pcalibre1 calibre6"/> performance. To view the Profiler, select <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> | <strong class="bold">Profiler</strong>. When you play the game, you can then see which items are responsible for performance issues.</p>
<div><div><img alt="Figure 17.2: Viewing the Unity Profiler" src="img/B18327_17_02.jpg" class="calibre573"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 17.2: Viewing the Unity Profiler</p>
<p class="calibre3">Within the <strong class="bold">Profiler</strong>, you can <a id="_idIndexMarker1007" class="pcalibre pcalibre1 calibre6"/>select the UI Modules only to narrow down how each of your individual UI elements are affecting your performance.</p>
<div><div><img alt="Figure 17.3: Enabling only the UI Profiler Modules" src="img/B18327_17_03.jpg" class="calibre574"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 17.3: Enabling only the UI Profiler Modules</p>
<p class="calibre3">After doing so, you can see information <a id="_idIndexMarker1008" class="pcalibre pcalibre1 calibre6"/>about each individual <a id="_idIndexMarker1009" class="pcalibre pcalibre1 calibre6"/>Canvas.</p>
<div><div><img alt="Figure 17.4: Observing the UI Objects in the Profiler" src="img/B18327_17_04.jpg" class="calibre575"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 17.4: Observing the UI Objects in the Profiler</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about the Unity Profiler and how to use it here: <a href="https://docs.unity3d.com/Manual/Profiler.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/Manual/Profiler.xhtml</a></p>
<p class="calibre3">If you’re interested in how<a id="_idIndexMarker1010" class="pcalibre pcalibre1 calibre6"/> items in your game are<a id="_idIndexMarker1011" class="pcalibre pcalibre1 calibre6"/> being batched, you can use the Unity Frame Debugger.</p>
<h2 id="_idParaDest-277" class="calibre7"><a id="_idTextAnchor470" class="pcalibre pcalibre1 calibre6"/>Unity Frame Debugger</h2>
<p class="calibre3">The Frame Debugger can help you<a id="_idIndexMarker1012" class="pcalibre pcalibre1 calibre6"/> troubleshoot<a id="_idIndexMarker1013" class="pcalibre pcalibre1 calibre6"/> batching issues with your UI. You can access the Frame Debugger via <strong class="bold">Window</strong> | <strong class="bold">Analysis</strong> | <strong class="bold">Frame Debugger</strong>.</p>
<div><div><img alt="Figure 17.5: Reviewing the Frame Debugger" src="img/B18327_17_05.jpg" class="calibre576"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 17.5: Reviewing the Frame Debugger</p>
<p class="calibre3">Enabling the Frame Debugger will allow you to see various rendering events. Clicking on them will step forward in the Game window, giving you a preview of the event. This will show you which items are being combined into batches.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about the Frame Debugger here: <a href="https://docs.unity3d.com/Manual/frame-debugger-window.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/Manual/frame-debugger-window.xhtml</a></p>
<p class="calibre3">Now that we’ve discussed the basics of optimization, we can start talking about ways to optimize your UI.</p>
<h1 id="_idParaDest-278" class="calibre5"><a id="_idTextAnchor471" class="pcalibre pcalibre1 calibre6"/>Basic Unity UI Optimization Strategies</h1>
<p class="calibre3">Remember, each Canvas has its own Canvas Renderer component. Canvases combine all their elements into batches that are rendered together. A Canvas is considered <strong class="bold">dirty</strong>, if its geometry needs to be rebuilt. One of the<a id="_idIndexMarker1014" class="pcalibre pcalibre1 calibre6"/> main goals of optimizing UI is to reduce the number of times a Canvas or its elements are considered dirty, to reduce the number of times that the Canvas needs to be rebatched. With that in mind, let’s look at some techniques for optimizing Unity UI.</p>
<h2 id="_idParaDest-279" class="calibre7"><a id="_idTextAnchor472" class="pcalibre pcalibre1 calibre6"/>Using multiple Canvases and Canvas Hierarchies</h2>
<p class="calibre3">Whenever an element<a id="_idIndexMarker1015" class="pcalibre pcalibre1 calibre6"/> on a Canvas is modified, the Canvas is considered dirty, and a draw call is sent to the GPU. If there are multiple items on the Canvas, all the items on the Canvas will need to be reanalyzed to determine how best they should be drawn. So, changing one element on the Canvas requires the CPU to rebuild every element on the Canvas, potentially causing a sudden surge in CPU usage. Due to this, you should put your UI on multiple Canvases.</p>
<p class="calibre3">When determining how to group your Canvases, consider how often the items on the Canvas will need to be changed. It is good practice to group all static UI element on separate Canvases from items that are dynamic. This will stop the static items from having to be redrawn whenever the dynamic items change. Additionally, split dynamic elements into Canvases based on when they will update, trying to keep ones that update at the same time together.</p>
<p class="calibre3">Other aspects to consider when attempting to reduce draw calls on Canvases are the elements z-coordinates, textures, and materials. Grouping UI elements based on these properties can also reduce your CPU usage with regards to UI.</p>
<h2 id="_idParaDest-280" class="calibre7"><a id="_idTextAnchor473" class="pcalibre pcalibre1 calibre6"/>Minimizing the use of Layout Groups</h2>
<p class="calibre3"><code>GetComponent</code> for each parent object that has a Layout Groups. This makes nested Layout Groups very non-performant.</p>
<p class="calibre3">To avoid this, you could simply not use Layout Groups. Instead, you could use Anchors and write your own layout code for dynamically placing items.</p>
<p class="calibre3">Avoiding them entirely isn’t necessarily the best solution for everyone, however, so if you do choose to use them, try to<a id="_idIndexMarker1017" class="pcalibre pcalibre1 calibre6"/> avoid nested Layout Groups or layout groups with very large amounts of children. You can also choose to use layout groups for dynamic elements only and avoid them with static elements. You can also disable them as soon as dynamic UI has been properly positioned.</p>
<h2 id="_idParaDest-281" class="calibre7"><a id="_idTextAnchor474" class="pcalibre pcalibre1 calibre6"/>Hiding objects appropriately</h2>
<p class="calibre3">If you want to hide elements on a <a id="_idIndexMarker1018" class="pcalibre pcalibre1 calibre6"/>Canvas, it is best to disable the entire Canvas component if possible. Remember, the Canvas component is what renders the UI, so disabling the Canvas component will cause it to stop rendering. It is recommended you disable the Canvas component rather than simply changing the visibility of the Canvas, because the Canvas component will continue to make draw calls, even if it is not visible. Disabling the component does not cause the Canvas to rebuild. This is less expensive than enabling and disabling the Canvas GameObject, as that will trigger the <code>OnEnable</code> and <code>OnDisable</code> methods.</p>
<p class="calibre3">If you want to hide everything in your game with UI, for example you have a pause menu that completely covers your screen, you should stop the camera from rendering anything in your game other than the UI. For example, if you have a menu that completely covers the screen, even though you cannot see the items behind the menu, they are still being rendered.</p>
<h2 id="_idParaDest-282" class="calibre7"><a id="_idTextAnchor475" class="pcalibre pcalibre1 calibre6"/>Appropriately time object pooling enabling and disabling</h2>
<p class="calibre3"><strong class="bold">Object pooling</strong> is an optimization <a id="_idIndexMarker1019" class="pcalibre pcalibre1 calibre6"/>technique used to <a id="_idIndexMarker1020" class="pcalibre pcalibre1 calibre6"/>reduce the number of times repeatable objects are created (or instantiated). When object pooling, you place a collection of disabled objects in a pool at the start of the game and then, rather that instantiating those objects while the game is playing, you pull them from the pool.</p>
<p class="calibre3">Object pooling is a great way to improve the performance of your game, because it reduces the number of times an object has to be created by creating a collection of objects that can be reused.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information on the concept of object pooling, visit the following site: <a href="https://learn.unity.com/tutorial/introduction-to-object-pooling" class="pcalibre pcalibre1 calibre6">https://learn.unity.com/tutorial/introduction-to-object-pooling</a></p>
<p class="calibre3">Because reparenting UI objects causes a Canvas to be marked as dirty, you want to carefully time your disabling, enabling, and reparenting when using an object pool. Since dynamic changes to elements within a Canvas cause the Canvas to send a draw call to the GPU, inappropriately<a id="_idIndexMarker1021" class="pcalibre pcalibre1 calibre6"/> parenting items before or after disabling them, can double up your draw calls unnecessarily. The goal, is to not cause the objects in the pool to send any draw calls to the GPU. So, objects in the pool should only ever be parented to the pool in a disabled state.</p>
<p class="calibre3">If you are placing an object in<a id="_idIndexMarker1022" class="pcalibre pcalibre1 calibre6"/> an object pool, disable it, then reparent it into the pool. By making sure it is disabled before being placed in the pool, you will remove the need for the pool to need rebuilding. Conversely, if you want to remove an object from the pool, reparent it, then enable it. This too will remove the need for the pool to send a draw call.</p>
<h2 id="_idParaDest-283" class="calibre7"><a id="_idTextAnchor476" class="pcalibre pcalibre1 calibre6"/>Reducing Raycast computations</h2>
<p class="calibre3">Every UI Image<a id="_idIndexMarker1023" class="pcalibre pcalibre1 calibre6"/> component has the property <strong class="bold">Raycast Target</strong>. By default, this is selected. If you do not wish for your UI element to block raycasts, disable this to reduce raycasting checks.</p>
<div><div><img alt="Figure 17.6: The Raycast Target property" src="img/B18327_17_06.jpg" class="calibre577"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 17.6: The Raycast Target property</p>
<p class="calibre3">Additionally, if your UI is not interactable at all, you can remove the Graphic Raycaster component to remove the unnecessary calculation it causes.</p>
<div><div><img alt="Figure 17.7: The Graphic Raycaster component" src="img/B18327_17_07.jpg" class="calibre578"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 17.7: The Graphic Raycaster component</p>
<p class="calibre3">Using the basic Unity UI <a id="_idIndexMarker1024" class="pcalibre pcalibre1 calibre6"/>optimization strategies covered in this chapter will have you well on your way to creating UI that does not inversely affect<a id="_idTextAnchor477" class="pcalibre pcalibre1 calibre6"/> the performance of your game.</p>
<h1 id="_idParaDest-284" class="calibre5"><a id="_idTextAnchor478" class="pcalibre pcalibre1 calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we discussed the basics of optimizing Unity UI. We reviewed some fundamental concepts of optimizing in Unity, looked at the tools that allow us to assess our game’s performance, and then discussed strategies for creating performant UI.</p>
<p class="callout-heading">Note</p>
<p class="callout">This chapter focused only on how to improve the performance of your game through UI. But remember there are multiple aspects of your game that can cause it to have performance issues. For a good resource on improving the performance of all aspects of your game, I suggest reviewing the free ebook provided by unity on optimization: <a href="https://resources.unity.com/games/performance-optimization-e-book-console-pc" class="pcalibre pcalibre1 calibre6">https://resources.unity.com/games/performance-optimization-e-book-console-pc</a></p>
<p class="calibre3">In the next chapter, we’ll talk about a new UI system created by unity called the new unity UI toolkit. It can be used to create UI not only during runtime but also within the editor. Thus, it can be used to help you create tools to improve your workflow.</p>
<h1 id="_idParaDest-285" class="calibre5"><a id="_idTextAnchor479" class="pcalibre pcalibre1 calibre6"/>Further reading</h1>
<p class="calibre3">For more information on optimizing UI, I recommend the following resources:</p>
<ul class="calibre16">
<li class="calibre14"><a href="https://learn.unity.com/tutorial/optimizing-unity-ui#" class="pcalibre pcalibre1 calibre6">https://learn.unity.com/tutorial/optimizing-unity-ui#</a></li>
<li class="calibre14"><a href="https://unity.com/how-to/unity-ui-optimization-tips" class="pcalibre pcalibre1 calibre6">https://unity.com/how-to/unity-ui-optimization-tips</a></li>
<li class="calibre14"><a href="https://www.youtube.com/watch?v=FPotgj_NHK4" class="pcalibre pcalibre1 calibre6">https://www.youtube.com/watch?v=FPotgj_NHK4</a></li>
</ul>
</div>
</div></body></html>