<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Optimizing with the Object Pool Pattern
                </header>
            
            <article>
                
<p class="mce-root">In most video games, there are a lot of things happening on the screen. Bullets are flying around, enemies are spawning around the map, particles are popping up around the player, and these various objects are loaded and rendered on the screen in the blink of an eye. So, to avoid putting strain on the <strong>Central Processing Unit</strong> (<strong>CPU</strong>) while maintaining a consistent frame rate, it's a good practice to reserve some memory for our frequently spawned entities. So, instead of releasing recently destroyed enemies from memory, we add them to an object pool to recycle them for later use. With this technique, we avoid the initial initialization cost of loading a new instance of an entity. In addition, because we are not destroying reusable entities, the <strong>Garbage Collector</strong> (<strong>GC</strong><span>) </span>won't waste cycles cleaning a set of regularly reinitialized objects.</p>
<p class="mce-root">And this is what we are going to do in this chapter, but we are fortunate as, since Unity version 2021, object pooling has been natively integrated into the <strong>Application Programming Interface</strong> (<strong>API</strong>). Therefore, we will not need to implement the pattern by hand as we have done in previous chapters; instead, we will focus on learning how to use it and let the engine do all the work.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding the Object Pool pattern</li>
<li>Implementing the Object Pool pattern</li>
<li>Reviewing alternative solutions</li>
</ul>
<div class="packt_infobox">A GC functions as an automated memory manager and is an essential component of most modern object-oriented languages such as C#. It's not necessary to understand how it works to continue with this chapter, but if you are curious, you can get more information on the subject matter here: <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/<span>.</span></a></div>
<h1 id="uuid-64e7905a-cf8c-431e-8b46-031962908169">Technical requirements</h1>
<p><span>This chapter is hands-on, so you will need to have a basic understanding of Unity and C#.</span></p>
<p>The code files of this chapter can be found on<span> </span>GitHub, at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08"><span>https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08.</span></a></p>
<p class="mce-root">Check out the following video to see the code in<span> </span>action: </p>
<p><a href="https://bit.ly/3yTLcI7">https://bit.ly/3yTLcI7</a></p>
<div class="packt_infobox">It's important to note that the code example in the next section will not work in a version of Unity that's below 2021.1, as we are using recently added API features.</div>
<h1 id="uuid-606990a8-6cb6-4c78-bd06-7cc0767ba3ea">Understanding the Object Pool pattern</h1>
<p>The core concept of this pattern is simple—a pool in the form of a container holds a collection of initialized objects in memory. Clients can request an Object Pool for an object instance of a specific type; if one is available, it will be removed from the pool and given to the client. If there are not enough pooled instances at a given time, new ones will be dynamically created.</p>
<p class="mce-root">Objects that exit the pool will attempt to return to it once they are not used anymore by the client. If the Object Pool has no more space, it will destroy instances of objects that attempt to return. Therefore, the pool constantly gets refilled, can only be temporarily drained, but never overflows. Hence, its memory usage is consistent.</p>
<p class="mce-root">The following diagram illustrates the back and forth between a client and an Object Pool:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9355c03f-fadf-4748-af73-7b54075cd42c.png" style="width:43.67em;height:27.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 8.1 – <span><span>Unified Modeling Language (UML) diagram of the Object Pool pattern</span></span></div>
<p>In the diagram, we can see that the Object Pool serves the client by offering it access to a pool of object instances of a specific type—so, for example, a client could be a spawner asking the Object Pool for instances of a particular enemy type. </p>
<h2 id="uuid-9072bd1d-97b4-43e2-86be-e7676fc033d3">Benefits and drawbacks of the Object Pool pattern</h2>
<p><span>These are some of the benefits of the Object Pool pattern:</span></p>
<ul>
<li><strong><span>Predictable memory usage</span></strong><span>: With the Object Pool, we can allocate in a predictable manner some memory to hold a specific amount of instances of certain type of object.</span></li>
<li><strong><span>Performance boost</span></strong><span>: By having objects already initialized in memory, you avoid the loading cost of initializing new ones.</span></li>
</ul>
<p><span>These are some potential drawbacks of the Object Pool pattern:</span></p>
<ul>
<li><strong><span>Layering on already managed memory</span></strong>:<span> Some people criticize the Object Pool pattern as being unnecessary in most cases because modern managed programming languages such as C# already optimally control memory allocation. However, this statement might be true in some contexts but false in others.</span></li>
<li><strong><span>Unpredictable object states</span></strong>:<span> A potential pitfall of the Object Pool pattern is that if it is incorrectly handled, objects can be returned to the pool in their current state instead of their initial one. This situation can be an issue when the pooled entity is damageable or destructible. For instance, if you have an enemy entity that just got killed by the player, if you return it to the pool without restoring its health, and when the Object Pool pulls it back out for a client, it will spawn back into the scene in an already damaged state.</span></li>
</ul>
<h2 id="uuid-f5f933de-7bcb-472b-b94f-523fbe9cfbf8">When to use the Object Pool pattern</h2>
<p>To better understand when to use the Object Pool pattern, let's review when not to use it. For instance, if you have entities that need to be spawned once on your map, such as a final boss, putting it in an Object Pool is a waste of memory that you could use for something more useful.</p>
<p class="mce-root">Also, we should keep in mind that an Object Pool is not a cache. It has a similar purpose—the reuse of objects. The core difference is that an Object Pool has a mechanism in which entities are automatically returned to the pool after being used, and an Object Pool, if well implemented, handles the creation and deletion of objects depending on the available size of the pool.</p>
<p class="mce-root">But suppose we have entities such as bullets, particles, and enemy characters that are frequently spawned and destroyed during a gameplay sequence. In that case, the Object Pool can relieve some of the strain we are putting on the CPU by reducing repetitious lifespan calls such as create and destroy, thus the CPU will be able to reserve processing power for more critical tasks.</p>
<p>In the next section, we are going to take the concepts just learned and translate them into code.</p>
<h1 id="uuid-2889e0c3-0fdc-4b3a-a536-737beeaff73c">Implementing the Object Pool pattern</h1>
<p>Before starting this section, it would be a good idea to read the official API documentation for the <kbd>IObjectPool&lt;T0&gt;</kbd> class under the <kbd>UnityEngine.Pool</kbd> namespace at the following link:</p>
<p><a href="https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Pool.ObjectPool_1.html">https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1.html</a></p>
<p class="mce-root">We will try to avoid getting bogged down by API specifications while implementing the following code example. Instead, we will focus on critical elements directly related to the core concepts of object pooling. Also, native object pooling is a relatively new Unity API feature, hence it might be subject to changes and updates. Thus, it would be wise to keep an eye on the documentation in the short term.</p>
<h2 id="uuid-58a70479-dadf-4b6e-b678-5dd803566267">Steps for implementing the Object Pool pattern</h2>
<p>This section's code example should be relatively straightforward and we should be able to complete it in two steps, as follows:</p>
<ol>
<li class="mce-root">Let's start by implementing our drone, as this is the entity that we will pool. Because it is such a lengthy class, we are going to split it into two segments. You can see the first segment here: </li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span>using </span><span>UnityEngine</span><span>.</span><span>Pool</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Collections</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>ObjectPool <br/></span><span>{<br/></span><span>    </span><span>public class </span><span>Drone </span>: <span>MonoBehaviour <br/></span><span>    </span><span>{<br/></span><span>        </span><span>public </span><span>IObjectPool</span><span>&lt;</span><span>Drone</span><span>&gt; </span><span>Pool </span><span>{ </span><span>get</span><span>; </span><span>set</span><span>; }<br/></span><span><br/></span><span>        </span><span>public float </span><span>_currentHealth</span><span>;<br/></span><span><br/></span><span>        [</span><span>SerializeField</span><span>] <br/></span><span>        </span><span>private float </span><span>maxHealth </span><span>= </span><span>100.0f</span><span>;<br/><br/>        </span><span>[</span><span>SerializeField</span><span>] <br/></span><span>        </span><span>private float </span><span>timeToSelfDestruct </span><span>= </span><span>3.0f</span><span>;<br/><br/>        </span><span>void </span><span>Start</span><span>() <br/></span><span>        {<br/></span><span>            </span><span>_currentHealth </span><span>= </span><span>maxHealth</span><span>;<br/></span><span>        }<br/><br/>        </span><span>void </span><span>OnEnable</span><span>() <br/></span><span>        {<br/></span><span>            </span><span>AttackPlayer</span><span>();<br/></span><span>            </span><span>StartCoroutine</span><span>(</span><span>SelfDestruct</span><span>());<br/></span><span>        }<br/><br/>        </span><span>void </span><span>OnDisable</span><span>() <br/></span><span>        </span><span>{</span><span><br/></span><span>            </span><span>ResetDrone</span><span>();<br/></span><span>        </span><span>}</span></pre>
<p style="padding-left: 60px">It's essential to observe that we call the <kbd>ResetDrone()</kbd> method in the <kbd>OnDisable()</kbd> event function in this class segment. We are doing this because we want to reset the drone back to its initial state before returning it to the pool.</p>
<p style="padding-left: 60px">And as we are going to see when we implement the Object Pool pattern, when a GameObject returns to the pool it gets disabled, including all its child components. Therefore, if we have any reinitialization code to execute, we can do this at the <kbd>OnDisable()</kbd> call.</p>
<p style="padding-left: 60px">In the context of this chapter, we are keeping things simple; we are only restoring the health of the drone. But in an advanced implementation, we might have to reset visual markers, such as removing damaged decals.</p>
<ol start="2">
<li>In the final segment of our <kbd>Drone</kbd> class, we will implement the core behaviors, as follows:</li>
</ol>
<pre style="padding-left: 60px">        <span>IEnumerator </span><span>SelfDestruct</span><span>() <br/>        {<br/></span><span>            </span><span>yield return new </span><span>WaitForSeconds</span><span>(</span><span>timeToSelfDestruct</span><span>);<br/></span><span>            </span><span>TakeDamage</span><span>(</span><span>maxHealth</span><span>);<br/></span><span>        }<br/><br/>        </span><span>private void </span><span>ReturnToPool</span><span>() <br/>        {<br/></span><span>            </span><span>Pool</span><span>.</span><span>Release</span><span>(</span><span>this</span><span>);<br/></span><span>        }<br/><br/>        </span><span>private void </span><span>ResetDrone</span><span>() <br/>        {<br/></span><span>            </span><span>_currentHealth </span><span>= </span><span>maxHealth</span><span>;<br/></span><span>        }<br/><br/>        </span><span>public void </span><span>AttackPlayer</span><span>() <br/>        {<br/></span><span>            </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Attack player!"</span><span>);<br/></span><span>        }<br/><br/>        </span><span>public void </span><span>TakeDamage</span><span>(</span><span>float </span><span>amount) <br/>        {<br/></span><span>            </span><span>_currentHealth </span><span>-= amount;<br/><br/>            </span><span>if </span><span>(</span><span>_currentHealth </span><span>&lt;= </span><span>0.0f</span><span>)<br/></span><span>                </span><span>ReturnToPool</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p style="padding-left: 60px" class="mce-root"><span>Our drone has two key behaviors, outlined as follows:</span></p>
<ul>
<li><strong>Self-destruction</strong>: Our drone has a short lifespan; when it's enabled, the <kbd>SelfDestruct()</kbd> coroutine is called. After several seconds, the drone self-destructs by depleting its health meter and returning itself to the pool by calling the <kbd>ReturnToPool()</kbd> method. </li>
<li><strong>Attack</strong>: The logic inside the method is not implemented, for brevity reasons. But imagine that once the drone is spawned, it seeks and attacks the player.</li>
</ul>
<ol start="3">
<li class="mce-root">Next up is our <kbd>ObjectPool</kbd> class, which has the responsibility of managing a pool of drone instances. Because it's a lengthy class, we will review it in two segments, with the first segment available to view here:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span>using </span><span>UnityEngine</span><span>.</span><span>Pool</span><span>;<br/><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>ObjectPool <br/></span><span>{<br/>    </span><span>public class </span><span>DroneObjectPool </span>: <span>MonoBehaviour<br/></span><span>    </span><span>{<br/>        </span><span>public int </span><span>maxPoolSize </span><span>= </span><span>10</span><span>;<br/></span><span>        </span><span>public int </span><span>stackDefaultCapacity </span><span>= </span><span>10</span><span>;<br/><br/>        </span><span>public </span><span>IObjectPool</span><span>&lt;</span><span>Drone</span><span>&gt; </span><span>Pool <br/></span><span>        </span><span>{<br/></span><span>            </span><span>get <br/></span><span>            </span><span>{<br/></span><span>                </span><span>if </span><span>(</span><span>_pool </span><span>== </span><span>null</span><span>)<br/></span><span>                    </span><span>_pool </span><span>= <br/></span><span>                        </span><span>new </span><span>ObjectPool</span><span>&lt;</span><span>Drone</span><span>&gt;(<br/></span><span>                            </span><span>CreatedPooledItem</span><span>, <br/></span><span>                            </span><span>OnTakeFromPool</span><span>, <br/></span><span>                            </span><span>OnReturnedToPool</span><span>, <br/></span><span>                            </span><span>OnDestroyPoolObject</span><span>, <br/></span><span>                            </span><span>true</span><span>, <br/></span><span>                            </span><span>stackDefaultCapacity</span><span>,<br/></span><span>                            </span><span>maxPoolSize</span><span>);<br/></span><span>                </span><span>return </span><span>_pool</span><span>;<br/></span><span>            }<br/></span><span>        }<br/><br/>        </span><span>private </span><span>IObjectPool</span><span>&lt;</span><span>Drone</span><span>&gt; </span><span>_pool</span><span>;</span></pre>
<p style="padding-left: 60px">In this first part of the script, we are setting a critical variable named <kbd>maxPoolSize</kbd>; as its name implies, this sets the maximum number of drone instances we will keep in the pool. The <kbd>stackDefaultCapacity</kbd> variable sets the default stack capacity; this is a property related to the stack data structure we are using to store our drone instance. We can ignore it for the moment as it's not critical to our implementation.</p>
<p style="padding-left: 60px">In the following code snippet, we are initializing the object pool, which is the most crucial part of our class:</p>
<pre style="padding-left: 60px"><span>public </span><span>IObjectPool</span><span>&lt;</span><span>Drone</span><span>&gt; </span><span>Pool <br/></span><span>{</span><span><br/></span><span> </span><span>get <br/></span><span> </span><span>{<br/></span><span> </span><span>if</span><span> </span><span>(</span><span>_pool </span><span>== </span><span>null</span><span>)<br/></span><span>            </span><span>_pool </span><span>= <br/></span><span>                </span><span>new </span><span>ObjectPool</span><span>&lt;</span><span>Drone</span><span>&gt;(<br/></span><span>                    </span><span>CreatedPooledItem</span><span>, <br/></span><span>                    </span><span>OnTakeFromPool</span><span>, <br/></span><span>                    </span><span>OnReturnedToPool</span><span>, <br/></span><span>                    </span><span>OnDestroyPoolObject</span><span>, <br/></span><span>                    </span><span>true</span><span>, <br/></span><span>                    </span><span>stackDefaultCapacity</span><span>,<br/></span><span>                    </span><span>maxPoolSize</span><span>);<br/></span><span>        </span><span>return </span><span>_pool</span><span>;<br/></span><span>    }<br/></span><span>}</span></pre>
<p style="padding-left: 60px" class="mce-root">It's important to note that we are passing callback methods in the constructor of the <kbd>ObjectPool&lt;T&gt;</kbd> class, and it's in these callbacks that we will implement the logic that will drive our Object Pool.</p>
<ol start="4">
<li class="mce-root">In the last segment of the <kbd>DroneObjectPool</kbd> class, we will implement the callbacks we declared in the <span><kbd>ObjectPool&lt;T&gt;</kbd> constructor, as follows:</span></li>
</ol>
<pre style="padding-left: 60px">        <span>private </span><span>Drone </span><span>CreatedPooledItem</span><span>() <br/></span><span>        {<br/></span><span>            </span><span>var </span><span>go = <br/></span><span>                </span><span>GameObject</span><span>.</span><span>CreatePrimitive</span><span>(</span><span>PrimitiveType</span><span>.</span><span>Cube</span><span>);<br/><br/>            </span><span>Drone </span><span>drone = go.</span><span>AddComponent</span><span>&lt;</span><span>Drone</span><span>&gt;();<br/><br/>            </span><span>go.</span><span>name </span><span>= </span><span>"Drone"</span><span>;<br/></span><span>            drone.</span><span>Pool </span><span>= </span><span>Pool</span><span>;<br/><br/>            </span><span>return </span><span>drone;<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>private void </span><span>OnReturnedToPool</span><span>(</span><span>Drone </span><span>drone) <br/></span><span>        {<br/></span><span>            drone.</span><span>gameObject</span><span>.</span><span>SetActive</span><span>(</span><span>false</span><span>);<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>private void </span><span>OnTakeFromPool</span><span>(</span><span>Drone </span><span>drone) <br/></span><span>        {<br/></span><span>            drone.</span><span>gameObject</span><span>.</span><span>SetActive</span><span>(</span><span>true</span><span>);<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>private void </span><span>OnDestroyPoolObject</span><span>(</span><span>Drone </span><span>drone) <br/></span><span>        {<br/></span><span>            </span><span>Destroy</span><span>(drone.</span><span>gameObject</span><span>);<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>public void </span><span>Spawn</span><span>() <br/></span><span>        {<br/></span><span>            </span><span>var </span><span>amount = </span><span>Random</span><span>.</span><span>Range</span><span>(</span><span>1</span><span>, </span><span>10</span><span>);<br/></span><span><br/></span><span>            </span><span>for </span><span>(</span><span>int </span><span>i = </span><span>0</span><span>; i &lt; amount; ++i) <br/>            {<br/></span><span>                </span><span>var </span><span>drone = </span><span>Pool</span><span>.</span><span>Get</span><span>();<br/><br/>                </span><span>drone.</span><span>transform</span><span>.</span><span>position </span><span>= <br/></span><span>                    </span><span>Random</span><span>.</span><span>insideUnitSphere </span><span>* </span><span>10</span><span>;<br/></span><span>            }<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p style="padding-left: 30px" class="mce-root">Here's a short explanation of each callback that the <kbd>ObjectPool</kbd> class will call at specific times:</p>
<ul>
<li><kbd>CreatedPooledItem()</kbd>: In this callback, we are initializing our drone instances. In the context of this chapter, we are creating a GameObject from scratch for simplicity reasons, but in a more practical context, we would probably just load a prefab.</li>
<li><kbd>OnReturnedToPool()</kbd>: The name of the method implies its use. Notice we are not destroying the GameObject; we simply deactivate it to remove it from the scene.</li>
<li><kbd>OnTakeFromPool()</kbd>: This is called when the client requests an instance of the drone. The instance is not actually returned—the GameObject is enabled.</li>
<li><kbd>OnDestroyPoolObject()</kbd>: This an important method to understand. It's called when there's no more space in the pool. In that case, the returned instance is destroyed to free up memory.</li>
</ul>
<p style="padding-left: 30px" class="mce-root">Our <kbd>DroneObjectPool</kbd> class has taken on extra responsibilities and acts as a spawner, as we can see in the <kbd>Spawn()</kbd> method. When requested, it will get a <kbd>drone</kbd> instance from the pool and spawn it at a random location in the scene within a specific range.</p>
<h2 id="uuid-3f6fc170-9840-4fb8-8d88-35dd18ad5fa0">Testing the Object Pool implementation</h2>
<p>To test our implementation of the Object Pool in your own instance of Unity, you need to carry out the following steps:</p>
<ol>
<li>Create a new empty Unity scene.</li>
<li>Copy all the scripts we just reviewed and save them in your project.</li>
<li>Add an empty GameObject to the scene.</li>
<li class="mce-root"><span>Attach the following client script to your empty GameObject:</span></li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>ObjectPool<br/></span><span>{</span><span><br/></span><span>    </span><span>public class </span><span>ClientObjectPool </span>: <span>MonoBehaviour<br/></span><span>    </span><span>{<br/></span><span>        </span><span>private </span><span>DroneObjectPool </span><span>_pool;<br/><br/>        </span><span>void </span><span>Start</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>_pool </span><span>= </span><span>gameObject</span><span>.</span><span>AddComponent</span><span>&lt;</span><span>DroneObjectPool</span><span>&gt;();<br/></span><span>        }<br/><br/>        </span><span>void </span><span>OnGUI</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>if </span><span>(</span><span>GUILayout</span><span>.</span><span>Button</span><span>(</span><span>"Spawn Drones"</span><span>))<br/></span><span>                </span><span>_pool</span><span>.</span><span>Spawn</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>Once you start your scene, you should see a <strong>graphical user interface</strong> (<strong>GUI</strong>) button named <strong><span class="packt_screen">Spawn Drones</span></strong> in the top-left corner, as we can see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4c618be6-fbe6-4ccb-aef1-ba042b8f4195.png" style="width:62.58em;height:38.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 8.2 <span>–</span><span> </span><span>Screenshot of the code example in action</span></div>
<p><span>By pressing the </span><strong><span><span class="packt_screen">Spawn Drones</span></span></strong><span> button, you can now spawn drones at random positions in the scene. If you want to see the Object Pool mechanism in action, keep an eye on the scene hierarchy—you will be able to see</span> Drone <span>entities get enabled and disabled as they come in and out of the pool.</span></p>
<h2 id="uuid-31437d5b-bc6a-4f7f-bd57-b8e559a46a3a">Reviewing the Object Pool implementation</h2>
<p>By using the Object Pool pattern, we automated the process of creating, destroying, and pooling drone instances. We can now reserve an amount of memory to spawn waves of drones while avoiding burdening the CPU. We added optimization and scalability to our code by implementing this pattern without losing readability or adding complexity.</p>
<p>In the next section, we will review some alternative solutions to consider; it's always a good practice to consider other options before deciding on a specific pattern.</p>
<h1 id="uuid-346ae39e-089d-4048-bf57-a6ab150d5c2d">Reviewing alternative solutions</h1>
<p>A close cousin of the Object Pool pattern is the <strong>Prototype</strong> pattern; both of these are considered creational patterns. With the Prototype pattern, you can avoid the inherent cost of creating new objects by using a cloning mechanism. Therefore, instead of initializing new objects, you clone them from a reference object called a prototype. But in the context of the use case presented in this chapter, object pooling offers better optimization benefits.</p>
<div class="packt_infobox">Creational-type patterns are concerned with the mechanism of object creation. <strong>Factory</strong>, <strong>Build</strong>, <strong>Singleton</strong>, <strong>Object Pool</strong>, and <strong>Prototype</strong> are all creational design patterns.</div>
<h1 id="uuid-be4e7122-7e62-420e-be28-96a3879798c1">Summary</h1>
<p><span>We have just added the Object Pool pattern to our toolkit—this is one of the most valuable patterns for Unity developers. As we saw in our code examples, we can easily recycle instances of frequently used objects. When dealing with a large set of entities that need to spawn quickly and repeatedly, this pattern can help us avoid CPU spikes and lags. These benefits can only help make our game better, as players do enjoy a game that runs smoothly.</span></p>
<p><span>In the next chapter, we are going to decouple components from each other with the Observer pattern.</span></p>


            </article>

            
        </section>
    </body></html>