<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-312"><a id="_idTextAnchor350"/>9. Creating API Services</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">In modern software development, most logic is served through distinct web services. This is essential to be able to both call and make new web services as a developer. </p>
<p class="callout">In this chapter, you will be creating your own RESTful web service using the ASP.NET Core Web API template. You will learn not only how to do it but also some of the best practices for designing and building a Web API. You will also learn how to protect an API using Azure Active Directory (AAD), centralize error handling, troubleshoot errors, generate documentation, and more.</p>
<p class="callout">By the end of this chapter, you will be able to create professional Web APIs that are secured with AAD, hosted on the cloud, scalable, and able to serve thousands of users.</p>
<h1 id="_idParaDest-313"><a id="_idTextAnchor351"/>Introduction</h1>
<p>ASP.NET Core is a part of the .NET Core framework that is targeted at creating web apps. Using it, you can create both frontend (such as Razor or Blazor) and backend (such as Web API or gRPC) applications. However, in this chapter, you will be focusing on creating RESTful Web APIs. Creating a new web service for the first time might sound like a daunting task, but don't worry too much; for most scenarios, there is a template to get you started. In this chapter, you will create a few Web APIs using ASP.NET Core 6.0.</p>
<h1 id="_idParaDest-314"><a id="_idTextAnchor352"/>ASP.NET Core Web API</h1>
<p>In <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, you learned how to call RESTful APIs. In this chapter, you will be making one. Web API is a template for creating RESTful Web APIs in .NET. It contains routing, Dependency Injection (DI), an example controller, logging, and other useful components to get you started.</p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor353"/>Creating a New Project</h2>
<p>In order to create a new Web API, follow these steps:</p>
<ol>
<li>Create a new directory.</li>
<li>Name it after a project you want to create.</li>
<li>Navigate to that directory using the <code>cd</code> command.</li>
<li>Execute the following at the command line:<pre>dotnet new webapi</pre></li>
</ol>
<p>That is all it takes to get started.</p>
<ol>
<li value="5">To see whether this is executing as expected, run the following and see your application come to life (<em class="italic">Figure 9.1</em>):<pre>dotnet run --urls=https://localhost:7021/</pre><div><img alt="Figure 9.1: Terminal window showing the port the application is hosted on " height="147" src="img/B16835_09_01.jpg" width="1199"/></div></li>
</ol>
<p> </p>
<p class="figure-caption">Figure 9.1: Terminal window showing the port the application is hosted on</p>
<p>In <em class="italic">Figure 9.1</em>, you will see port 7021 for the <code>https</code> version of the application. There may be multiple ports, especially if you are hosting both <code>HTTP</code> and <code>HTTPs</code> versions of an application. However, the key thing to remember is that you can the port where an application runs (for example, through the command line).</p>
<p>A port is a channel through which you allow a certain application to be called by all other applications. It is a number that appears after a base URL and it allows a single application through. Those applications don't have to be outsiders; the same rules also apply to internal communication.</p>
<p>Localhost refers to an application hosted locally. Later in this chapter, you will configure the service to bind to whatever port you want.</p>
<p class="callout-heading">Note</p>
<p class="callout">There are 65,535 ports available on a single machine. Ports zero through 1023 are called well-known ports because usually, the same parts of the system listen on them. Typically, if a single application is hosted on one machine, the port will be 80 for <code>http</code> and 443 for <code>https</code>. If you are hosting multiple applications, the ports will vary drastically (usually starting from port 1024).</p>
<h3 id="_idParaDest-316"><a id="_idTextAnchor354"/>Web API Project Structure</h3>
<p>Every Web API is made of at least two classes—<code>Program</code> and one or more controllers (<code>WeatherForecastController</code> in this case):</p>
<ul>
<li>Program: This is the <strong class="bold">starting point</strong> of an application. It serves as a low-level runner of an application and manages dependencies.</li>
<li>Controller: This is a <code>[Model]Controller</code>. In this example case, <code>WeatherForecastController</code> will be called using a <code>/weatherforecast</code> endpoint.</li>
</ul>
<div><div><img alt="Figure 9.2: The newly created MyProject structure in VS Code with key parts highlighted " height="507" src="img/B16835_09_02.jpg" width="1255"/>
</div>
</div>
<p class="figure-caption">Figure 9.2: The newly created MyProject structure in VS Code with key parts highlighted</p>
<h3 id="_idParaDest-317"><a id="_idTextAnchor355"/>An In-Depth Look at WeatherForecastController</h3>
<p>The controller from the default template is preceded by two attributes:</p>
<ul>
<li><code>[ApiController]</code>: This attribute adds common, convenient (yet opinionated) Web API functionality.</li>
<li><code>[Route("[controller]")]</code>: This attribute is used to provide a routing pattern of a given controller.</li>
</ul>
<p>For example, in cases where these attributes are absent or the request is complex, you would need to validate an incoming HTTP request yourself without routing out of the box:</p>
<pre>[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{</pre>
<p>This controller has <code>/WeatherForecast</code> as the route. The route is usually made of the word that precedes the word <code>Controller</code> unless specified otherwise. When developing APIs professionally, or when you have a client- and server-side application, it is recommended to preappend <code>/api</code> to the route, making it <code>[Route("api/[controller]")]</code>.</p>
<p>Next, you'll learn about the controller class declaration. Common controller functions come from a derived <code>ControllerBase</code> class and a few components (usually a logger) and services. The only interesting bit here is that, instead of <code>Ilogger</code>, you use <code>ILogger&lt;WeatherForecastController&gt;</code>:</p>
<pre>    private readonly ILogger&lt;WeatherForecastController&gt; _logger;
    public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)
    {
        _logger = logger;
    }</pre>
<p>The reason behind using the generic part is solely for getting the context from the place where the log was called. Using a generic version of a logger, you use a fully qualified name of a class that is supplied as a generic argument. Calling <code>logger.Log</code> will prefix it with a context; in this case, it will be <code>Chapter09.Service.Controllers.WeatherForecastController[0]</code>.</p>
<p>Lastly, look at the following controller method:</p>
<pre>    [HttpGet]
    public IEnumerable&lt;WeatherForecast&gt; Get()
    {
        return new List&lt;WeatherForecast&gt;(){new WeatherForecast()};
    }
}</pre>
<p>The <code>[HttpGet]</code> attribute binds the <code>Get</code> method with the root controller endpoint's (<code>/WeatherForecast</code>) HTTP GET method. There is a version of that attribute for every HTTP method, and they are <code>HttpGet</code>, <code>HttpPost</code>, <code>HttpPatch</code>, <code>HttpPut</code>, and <code>HttpDelete</code>. To check whether the service works, run the application using the following command:</p>
<pre>dotnet run --urls=https://localhost:7021/</pre>
<p>Here, the <code>-urls=https://localhost:7021/</code> argument is not a requirement. This argument simply makes sure that the port picked by .NET is the same as is indicated in this example during execution.</p>
<p>To see the output, navigate to <code>https://localhost:7021/weatherforecast/</code> in the browser. This will return a single default <code>WeatherForecast</code> upon calling HTTP GET:</p>
<p><code>[{"date":"0001-01-01T00:00:00","temperatureC":0,"temperatureF":32,"summary":null}].</code></p>
<p class="callout-heading">Note</p>
<p class="callout">When <code>https://localhost:7021/weatherforecast/</code> displays an error message (<code>localhost refused to connect</code>), it means that the application is likely running, but on a different port. So, always remember to specify a port as described in the <em class="italic">Creating a New Project</em> section (<em class="italic">Step 5</em>).</p>
<h3 id="_idParaDest-318"><a id="_idTextAnchor356"/>Responding with Different Status Codes</h3>
<p>Find out what status codes can <code>public IEnumerable&lt;WeatherForecast&gt; Get()</code> respond with. Using the following steps, you can play around with it and inspect what happens in the browser:</p>
<ol>
<li value="1">Navigate to <code>https://localhost:7021/weatherforecast/</code> in the browser.</li>
<li>Click on <code>More tools</code>.</li>
<li>Select the <code>Developer tools</code> option. Alternatively, you can use the <code>F12</code> key to launch the developer tools.</li>
<li>Next, click on the <code>Network</code> tab.</li>
<li>Click on the <code>Headers</code> tab. You will see that <code>https://localhost:7021/weatherforecast/</code> responds with <code>200</code> <code>Status Code</code>:</li>
</ol>
<div><div><img alt="Figure 9.3: Dev tools Network tab—inspecting response headers of a successful response " height="653" src="img/B16835_09_03.jpg" width="1514"/>
</div>
</div>
<p class="figure-caption">Figure 9.3: Dev tools Network tab—inspecting response headers of a successful response</p>
<ol>
<li value="6">Create a new endpoint called <code>GetError</code> that throws an exception if a rare circumstance arises while a program is running:<pre>        [HttpGet("error")]
        public IEnumerable&lt;WeatherForecast&gt; GetError()
        {
            throw new Exception("Something went wrong");
        }</pre></li>
<li>Now, call <code>https://localhost:7021/weatherforecast/error</code>. It responds with a status code of <code>500</code>:</li>
</ol>
<div><div><img alt="Figure 9.4: Dev tools Network tab—inspecting a response with an exception " height="655" src="img/B16835_09_04.jpg" width="1255"/>
</div>
</div>
<p class="figure-caption">Figure 9.4: Dev tools Network tab—inspecting a response with an exception</p>
<p>What should you do if you want a different status code to be returned? For that, the <code>BaseController</code> class contains utility methods for returning any kind of status code you require. For example, if you wanted to explicitly return an OK response, instead of returning a value right away, you could return <code>Ok(value)</code>. However, if you try changing the code, you will get the following error:</p>
<pre>Cannot implicitly convert type 'Microsoft.AspNetCore.Mvc.OkObjectResult' to 'Chapter09.Service.Models.WeatherForecast'</pre>
<p>This does not work because you do not return an HTTP status code from a controller; you either return some value or throw some error. To return any status code of your choice, you need to change the return type. For that reason, a controller should never have a return type of some value. It should always return the <code>IActionResult</code> type—a type that supports all status codes.</p>
<p>Create one more method for getting the weather for any day of the week. If the day is not found (a value less than <code>1</code> or more than <code>7</code>), you will explicitly return <code>404 – not found</code>:</p>
<pre>[HttpGet("weekday/{day}")]
public IActionResult GetWeekday(int day)
{
    if (day &lt; 1 || day &gt; 7)
    {
        return NotFound($"'{day}' is not a valid day of a week.");
    }
    return Ok(new WeatherForecast());
}</pre>
<p>Here, you added one new <code>{day}</code> at the end of the endpoint. This is a placeholder value, which comes from a matching function argument (in this case, <code>day</code>). Rerunning the service and navigating to <code>https://localhost:7021/weatherforecast/weekday/8</code> will result in a <code>404 – not found</code> status code because it is more than the max allowed day value, which is <code>7</code>:</p>
<div><div><img alt="Figure 9.5: The response to finding a weather forecast for a non-existent day of the week " height="658" src="img/B16835_09_05.jpg" width="1142"/>
</div>
</div>
<p class="figure-caption">Figure 9.5: The response to finding a weather forecast for a non-existent day of the week</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/SCudR">https://packt.link/SCudR</a>.</p>
<p>This concludes the theoretical portion of this topic. In the following section, you will put this into practice with an exercise.</p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor357"/>Exercise 9.01: .NET Core Current Time Service</h2>
<p>Once you have managed to run a Web API once, adding new controllers should be trivial. Often, whether a service is running or not, it is checked using the most basic logic; whether it is returning OK or getting the current <code>DateTime</code> value. In this exercise, you will create a simple current time service returning the current time in ISO standard. Perform the following steps to do so:</p>
<ol>
<li value="1">Create a new controller called <code>TimeController</code> to get the local time and further add functions for testing purposes:<pre>    [ApiController]
    [Route("[controller]")]
    public class TimeController : ControllerBase
    {</pre></li>
</ol>
<p>The controller shown here isn't just for testing; it acts as business logic too.</p>
<ol>
<li value="2">Add an endpoint for HTTP GET called <code>GetCurrentTime</code> that points to the <code>time/current</code> route. You will use it to get the current time:<pre>        [HttpGet("current")]
        public IActionResult GetCurrentTime()
        {</pre></li>
<li>Return the current <code>DateTime</code> converted to a string in ISO format:<pre>            return Ok(DateTime.Now.ToString("o"));
        }
    }</pre></li>
<li>Navigate to <code>https://localhost:7021/time/current</code> and you should see the following response:<pre>2022-07-30T15:06:28.4924356+03:00</pre></li>
</ol>
<p>As mentioned in the <em class="italic">Web API Project Structure</em> section, you can use the endpoint to determine whether a service is running or not. If it is running, then you will get the <code>DateTime</code> value, which you saw in the preceding output. If it is not running, then you would get a response with a status code of <code>404 – not found</code>. If it is running but with problems, then you would get the <code>500</code> status code.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/OzaTd">https://packt.link/OzaTd</a>.</p>
<p>So far, all your focus was on a controller. It's time you shift your attention to another crucial part of a Web API—the <code>Program</code> class.</p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor358"/>Bootstrapping a Web API</h2>
<p>The <code>Program</code> class wires up the whole API together. In layman's terms, you register the implementations for all the abstractions used by controllers and add all the necessary middleware.</p>
<h3 id="_idParaDest-321"><a id="_idTextAnchor359"/>Dependency Injection</h3>
<p>In <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>, you explored the concept of DI. In <em class="italic">Chapter 7</em>, <em class="italic">Creating Modern Web Applications with ASP.NET</em>, you had a look at an example of DI for logging services. In this chapter, you will get hands-on experience in DI and the Inversion of Control (IoC) container—a component used to wire up and resolve all the dependencies in a central place. In .NET Core and later, the default container is <code>Microsoft.Extensions.DependencyInjection</code>. You will learn more about that a bit later.</p>
<h3 id="_idParaDest-322"><a id="_idTextAnchor360"/>Program.cs and Minimal API</h3>
<p>The simplest Web API in .NET 6 looks like this:</p>
<pre>// In<a id="_idTextAnchor361"/>ject dependencies (DI)
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
// Add middleware
var app = builder.Build();
if (builder.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
app.MapControllers();
app.Run();</pre>
<p>This is a minimal API because it makes use of the top-level statements feature. Prior to .NET 6, you would have two methods within a <code>Startup</code> class (<code>Configure</code> and <code>ConfigureService</code>) and a <code>Program</code> class. Now you have a single file, <code>Program.cs</code>, and no classes or methods. You can still use the old way of starting an application. In fact, .NET 6 will generate similar classes under the hood. However, if you are making a new app in .NET 6, then using a minimal API should be preferred.</p>
<p>Break down the preceding code snippet. To start the application, you first need to build it. So, you will create a builder using the following line of code:</p>
<pre>var builder = WebApplication.CreateBuilder(args);</pre>
<p><code>builder.Services</code> specifies which services are to be injected. In this case, you registered the implementation of the controllers. So, here you have just one controller calling—that is, <code>WeatherForecastController</code>:</p>
<pre>builder.Services.AddControllers();</pre>
<p>When you use <code>builder.Build()</code>, you can access the <code>app</code> object and further configure the application by adding middleware. For example, to add controller routing, call the following:</p>
<pre>app.MapControllers();</pre>
<p>Lastly, <code>builder.Environment.IsDevelopment()</code> checks whether the environment is developed. If it is developed, it calls <code>app.UseDeveloperExceptionPage();</code>, which adds detailed errors when something fails.</p>
<p>Logging is not mentioned anywhere; yet you still use it. A common pattern is to group all the related injections under the same extension method for <code>IServiceCollection</code>. An example of an extension method for all the controller-related functionality, including logging, is the <code>AddControllers</code> method.</p>
<p>You already saw the logging messages sent through the console logger right after you ran the API. Under the hood, the <code>builder.Services.AddLogging</code> method is called. This method clears all the logging providers:</p>
<pre>builder.Services.AddLogging(builder =&gt;
{
    builder.ClearProviders();
});</pre>
<p>If you run the application now, you will not see anything appear in the console (<em class="italic">Figure 9.6</em>):</p>
<div><div><img alt="Figure 9.6: Running an application with no logs displayed " height="111" src="img/B16835_09_06.jpg" width="1424"/>
</div>
</div>
<p class="figure-caption">Figure 9.6: Running an application with no logs displayed</p>
<p>However, if you modify <code>AddLogging</code> to include <code>Console</code> and <code>Debug</code> logging in the following way, you will see the logs as in <em class="italic">Figure 9.7</em>:</p>
<pre>builde<a id="_idTextAnchor362"/>r.Services.AddLogging(builder =&gt;
{
    builder.ClearProviders();
    builder.AddConsole();
    builder.AddDebug();
});</pre>
<p>Now, add an error logging functionality to the error endpoint of <code>WeatherForecastController</code>. This will throw an exception when a rare circumstance arises while a program is running:</p>
<pre>[HttpGet("error")]
public IEnumerable&lt;WeatherForecast&gt; GetError()
{
    _logger.LogError("Whoops");
    throw new Exception("Something went wrong");
}</pre>
<p>Restart the API with the following command:</p>
<pre>dotnet run --urls=https://localhost:7021/</pre>
<p>Now, call <code>https://localhost:7021/weatherforecast/error</code> and this will show the logged message (compare <em class="italic">Figure 9.6</em> and <em class="italic">Figure 9.7</em>):</p>
<div><div><img alt="Figure 9.7: The error message, Whoops, displayed on the terminal " height="274" src="img/B16835_09_07.jpg" width="1591"/>
</div>
</div>
<p class="figure-caption">Figure 9.7: The error message, Whoops, displayed on the terminal</p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor363"/>The Inner Workings of the AddLogging Method</h2>
<p>How does the <code>AddLogging</code> method work? The decompiled code of the <code>AddLogging</code> method looks like this:</p>
<pre>services.AddSingleton&lt;ILoggerFactory, LoggerFactory&gt;();</pre>
<p>It is best practice not to initialize loggers by yourself. <code>ILoggerFactory</code> provides that functionality as a single place from which you may create loggers. While <code>ILoggerFactory</code> is an interface, <code>LoggerFactory</code> is an implementation of that interface. <code>AddSingleton</code> is a method that specifies that a single instance of <code>LoggerFactory</code> will be created and used whenever <code>ILoggerFactory</code> is referenced.</p>
<p>Now the question arises: why wasn't <code>ILoggerFactory</code> used in a controller? <code>ILoggerFactory</code> is used under the hood when resolving an implementation of a controller. When exposing a controller dependency such as a <code>logger</code>, you no longer need to care about how it gets initialized. This is a great benefit because it makes the class holding a dependency both more simple and more flexible.</p>
<p>If you do want to use <code>ILoggerFactory</code> instead of <code>Ilogger</code>, you could have a constructor accepting the factory, as follows:</p>
<pre>public WeatherForecastController(ILoggerFactory logger)</pre>
<p>You can then use it to create a <code>logger</code>, as follows:</p>
<pre>_logger = logger.CreateLogger(typeof(WeatherForecastController).FullName);</pre>
<p>This latter <code>logger</code> functions the same as the former.</p>
<p>This section dealt with the <code>AddSingleton</code> method for managing service dependencies in a central place. Proceed to the next section to solve dependency complexities with DI.</p>
<h3 id="_idParaDest-324"><a id="_idTextAnchor364"/>The Lifetime of an Injected Component</h3>
<p>The <code>AddSingleton</code> method is useful because complex applications have hundreds, if not thousands, of dependencies often shared across different components. It would be quite a challenge to manage the initialization of each. DI solves that problem by providing a central place for managing dependencies and their lifetimes. Before proceeding further, you'll need to learn more about DI lifetimes.</p>
<p>There are three injected object lifetimes in .NET:</p>
<ul>
<li>Singleton: Object initialized once per application lifetime</li>
<li>Scoped: Object initialized once per request</li>
<li>Transient: Object initialized every time it is referenced</li>
</ul>
<p>To better illustrate DI and different service lifetimes, the next section will refactor the existing <code>WeatherForecastController</code> code.</p>
<h2 id="_idParaDest-325"><a id="_idTextAnchor365"/>DI Examples within a Service</h2>
<p>A service is a holder for logic at the highest level. By itself, a controller should not do any business logic and just delegate a request to some other object that is able to handle it. Apply this principle and refactor the <code>GetWeekday</code> method using DI.</p>
<p>First, create an interface for the service to which you will move all the logic. This is done to create an abstraction for which you will later provide an implementation. An abstraction is needed because you want to move out as much logic as possible from the controller into other components:</p>
<pre>public interface IWeatherForecastService
{
    WeatherForecast GetWeekday(int day);
}</pre>
<p>As you move a portion away from a controller, you would like to handle error scenarios as well. In this case, if a provided day is not between <code>1</code> and <code>7</code>, you will return a <code>404 – not found</code> error. However, at the service level, there is no concept of HTTP status codes. Therefore, instead of returning an HTTP message, you will be throwing an exception. For the exception to be handled properly, you will create a custom exception called <code>NoSuchWeekdayException</code>:</p>
<pre>public class NoSuchWeekdayException : Exception
{
    public NoSuchWeekdayException(int day) 
        : base($"'{day}' is not a valid day of a week.") { }
}</pre>
<p>Next, create a class that implements the service. You will move your code here:</p>
<pre>public class WeatherForecastService : IWeatherForecastService
{
    public WeatherForecast GetWeekday(int day)
    {
        if (day &lt; 1 || day &gt; 7)
        {
            throw new NoSuchWeekdayException(day);
        }
        return new WeatherForecast();
    }
}</pre>
<p>The only difference here as compared to the previous code is that, instead of returning <code>NotFound</code>, you have used <code>throw new NoSuchWeekdayException</code>.</p>
<p>Now, inject the service into a controller:</p>
<pre>private readonly IWeatherForecastService _weatherForecastService;
private readonly Ilogger _logger;
public WeatherForecastController(IloggerFactory logger, IWeatherForecastService weatherForecastService)
{
    _weatherForecastService = weatherForecastService;
    _logger = logger.CreateLogger(typeof(WeatherForecastController).FullName);
}</pre>
<p>The cleaned-up controller method, in the <em class="italic">Responding with Different Status Codes</em> section, with minimum business logic, now looks like this:</p>
<pre>[HttpGe<a id="_idTextAnchor366"/>t("weekday/{day}")]
public IActionResult GetWeekday(int day)
{
    try<a id="_idTextAnchor367"/>
    {
        var result = _weatherForecastService.GetWeekday(day);
        return Ok(result);
    }
    catch(NoSuchWeekdayException exception)
    {
        return NotFound(exception.Message);
    }
}</pre>
<p>It might still seem like the same code; however, the key point here is that the controller no longer does any business logic. It simply maps results from the service back to an HTTP response.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the <em class="italic">Error Handling</em> section, you will return to this and further remove code from the controller, making it as light as possible.</p>
<p>If you run this code, you would get the following exception when calling any of the controller's endpoints:</p>
<pre>Unable to resolve service for type 'Chapter09.Service.Examples.TemplateApi.Services.IweatherForecastService' while attempting to activate 'Chapter09.Service.Examples.TemplateApi.Controllers.WeatherForecastController'</pre>
<p>This exception shows that there is no way that <code>WeatherForecastController</code> can figure out the implementation for <code>IWeatherForecastService</code>. So, you need to specify which implementation fits the needed abstraction. For example, this is done inside the <code>Program</code> class as follows:</p>
<pre>builder.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
<p>The <code>AddSingleton</code> method reads this as for the <code>IWeatherForecastService</code>, <code>WeatherForecastService</code> <strong class="bold">implementation</strong>. In the following paragraphs, you will learn how exactly it works.</p>
<p>Now that you have a service to be injected, you can explore what effect each injection has on service calls when calling the following controller method. For that point, you will slightly modify <code>WeatherForecastService</code> and <code>WeatherForecastController</code>.</p>
<p>Within <code>WeatherForecastService</code>, do the following:</p>
<ol>
<li value="1">Inject a <code>logger</code>:<pre>        private readonly ILogger&lt;WeatherForecastService&gt; _logger;
        public WeatherForecastService(ILogger&lt;WeatherForecastService&gt; logger)
        {
            _logger = logger;
        }</pre></li>
<li>When the service is initialized, log a random <code>Guid</code> that changes the constructor to look like this:<pre>        public WeatherForecastService(ILogger&lt;WeatherForecastService&gt; logger)
        {
            _logger = logger;
            _logger.LogInformation(Guid.NewGuid().ToString());
        }</pre></li>
</ol>
<p>Within <code>WeatherForecastController</code>, do the following:</p>
<ol>
<li value="1">Inject the second instance of <code>WeatherForecastService</code>:<pre>    public class WeatherForecastController : ControllerBase
    {
        private readonly IWeatherForecastService _weatherForecastService1;
        private readonly IWeatherForecastService _weatherForecastService2;
        private readonly ILogger _logger;
        public WeatherForecastController(ILoggerFactory logger, IWeatherForecastService weatherForecastService1, IWeatherForecastService weatherForecastService2)
        {
            _weatherForecastService1 = weatherForecastService1;
            _weatherForecastService2 = weatherForecastService2;
            _logger = logger.CreateLogger(typeof(WeatherForecastController).FullName);
        }</pre></li>
<li>Call both instances when getting a weekday:<pre>        [HttpGet("weekday/{day}")]
        public IActionResult GetWeekday(int day)
        {
            try
            {
                var result = _weatherForecastService1.GetWeekday(day);
                result = _weatherForecastService1.GetWeekday(day);
                return Ok(result);
            }
            catch (NoSuchWeekdayException exception)
            {
                return NotFound(exception.Message);
            }
        }</pre></li>
</ol>
<p>The <code>GetWeekday</code> method is called twice because it will help illustrate DI lifetimes better. Now it is time to explore different DI lifetimes.</p>
<h2 id="_idParaDest-326"><a id="_idTextAnchor368"/>Singleton</h2>
<p>Register the service as a singleton in <code>Program.cs</code> in the following way:</p>
<pre>builder.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
<p>After calling the application, you will see the following logs generated while running the code:</p>
<pre>info: Chapter09.Service.Services.WeatherForecastService[0]
      2b0c4e0c-97ff-4472-862a-b6326992d9a6
info: Chapter09.Service.Services.WeatherForecastService[0]
      2b0c4e0c-97ff-4472-862a-b6326992d9a6</pre>
<p>If you call the application again, you will see the same GUID logged:</p>
<pre>info: Chapter09.Service.Services.WeatherForecastService[0]
      2b0c4e0c-97ff-4472-862a-b6326992d9a6
info: Chapter09.Service.Services.WeatherForecastService[0]
      2b0c4e0c-97ff-4472-862a-b6326992d9a6</pre>
<p>This proves that the service was initialized only once.</p>
<h2 id="_idParaDest-327"><a id="_idTextAnchor369"/>Scoped</h2>
<p>Register the service as scoped in <code>Program.cs</code> in the following way:</p>
<pre>builder.Services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
<p>After calling the application, you will see the following logs generated while running the code:</p>
<pre>info: Chapter09.Service.Services.WeatherForecastService[0]
      921a29e8-8f39-4651-9ffa-2e83d2289f29
info: Chapter09.Service.Services.WeatherForecastService[0]
      921a29e8-8f39-4651-9ffa-2e83d2289f29</pre>
<p>On calling <code>WeatherForecastService</code> again, you will see the following:</p>
<pre>info: Chapter09.Service.Services.WeatherForecastService[0]
      974e082d-1ff5-4727-93dc-fde9f61d3762
info: Chapter09.Service.Services.WeatherForecastService[0]
      974e082d-1ff5-4727-93dc-fde9f61d3762</pre>
<p>This is a different GUID that has been logged. This proves that the service was initialized once per request, but a new instance was initialized on a new request.</p>
<h2 id="_idParaDest-328"><a id="_idTextAnchor370"/>Transient</h2>
<p>Register the service as transient in <code>Program.cs</code> in the following way:</p>
<pre>builder.Services.AddTransient&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
<p>After calling the application, you should see the following in the logs generated while running the code:</p>
<pre>info: Chapter09.Service.Services.WeatherForecastService[0]
      6335a0aa-f565-4673-a5c4-0590a5d0aead
info: Chapter09.Service.Services.WeatherForecastService[0]
      4074f4d3-5e50-4748-9d6f-15fb6a782000</pre>
<p>That there are two different GUIDs logged proves that both services were initialized using different instances. It is possible to use DI and IoC outside of the Web API. DI through IoC is just another library with a few extras given by the Web API template.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you want to use IoC outside of ASP.NET Core, install the following NuGet (or other IoC container): <code>Microsoft.Extensions.DependencyInjection</code>.</p>
<h3 id="_idParaDest-329"><a id="_idTextAnchor371"/>TryAdd</h3>
<p>So far, you have wired implementations to their abstractions using an <code>Add[Lifetime]</code> function. However, that is not the best practice in most cases. Usually, you'll want a single implementation to be wired for a single abstraction. However, if you repeatedly call <code>Add[Lifetime]</code>, for example, the <code>AddSingleton</code> function, you will create a collection of implementing instances (duplicates) underneath. This is rarely the intention and therefore you should protect yourself against that.</p>
<p>The cleanest way to wire dependencies is through the <code>TryAdd[Lifetime]</code> method. In the case of a duplicate dependency, it will simply not add a duplicate. To illustrate the difference between the two versions of DIs, compare the injected service counts using different methods. Here, you will inject two identical services as a singleton.</p>
<p>Here you are using the <code>Add[Lifetime]</code> service as a singleton:</p>
<pre>builder.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();
Debug.WriteLine("Services count: " + services.Count);
builder.services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();
Debug.WriteLine("Services count: " + services.Count);</pre>
<p>The command will display the following output:</p>
<pre>Services count: 156
Services count: 157</pre>
<p>Here you are using the <code>TryAdd[Lifetime]</code> service as a singleton:</p>
<pre>builder.Services.TryAddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();
Debug.WriteLine("Services count: " + services.Count);
builder.Services.TryAddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();
Debug.WriteLine("Services count: " + services.Count);</pre>
<p>The command will display the following output:</p>
<pre>Services count: 156
Services count: 156</pre>
<p>Observe that <code>Add[Lifetime]</code> added a duplicate in the output, while <code>TryAdd[Lifetime]</code> did not. Since you don't want duplicate dependencies, it's recommended that you use the <code>TryAdd[Lifetime]</code> version.</p>
<p>You can do an injection for a concrete class as well. Calling <code>builder.Services.AddSingleton&lt;WeatherForecastService, WeatherForecastService&gt;();</code> is a valid C# code; however, it does not make much sense. DI is used to inject an implementation into an abstraction. This will not work when bootstrapping the service because the following error will be displayed:</p>
<pre>Unable to resolve a controller</pre>
<p>The error occurs because there is still an abstraction-implementation binding to be provided. It would only work if a concrete implementation, rather than an abstraction, were exposed in the constructor of the controller. In practice, this scenario is rarely used.</p>
<p>You have learned that the cleanest way of wiring dependencies is through the <code>TryAdd[Lifetime]</code> method. You will now create a service that accepts primitive arguments (<code>int</code> and <code>string</code>) and see how it manages its non-primitive dependencies in an IoC container.</p>
<h3 id="_idParaDest-330"><a id="_idTextAnchor372"/>Manual Injection Using an IoC Container</h3>
<p>There are scenarios in which you will need to create an instance of a service before injecting it. An example use case could be a service with primitive arguments in a constructor, in other words, a weather forecast service for a specific city with a configured interval for forecast refreshes. So, here, you cannot inject a string or an integer, but you can create a service with an integer and a string and inject that instead.</p>
<p>Modify <code>WeatherForecastService</code> with the said features:</p>
<pre>public <a id="_idTextAnchor373"/>class WeatherForecastServiceV2 : IWeatherForecastService
{
    pri<a id="_idTextAnchor374"/>vate readonly string _city;
    private readonly int _refreshInterval;
    public WeatherForecastService(string city, int refreshInterval)
    {
        _city = city;
        _refreshInterval = refreshInterval;
    }</pre>
<p>Return to the <code>Program</code> class and try to inject a service for <code>New York</code> with a refresh interval of <code>5</code> (hours):</p>
<pre>builder<a id="_idTextAnchor375"/>.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;(BuildWeatherForecastService);
static <a id="_idTextAnchor376"/>WeatherForecastServiceV2 BuildWeatherForecastService(IServiceProvider _)
{
    return new WeatherForecastServiceV2("New York", 5);
}</pre>
<p>In order to inject the service, as always, you use a version of the <code>builder.Services.Add[Lifetime]</code> method. However, on top of that, you provided an argument—a delegate specifying how a service should be created. The service provider can be accessed by calling the <code>BuildServices</code> method on <code>IServiceCollection</code>. This delegate takes <code>IServiceProvider</code> as input and uses it to build a new service.</p>
<p>In this case, you did not use it and thus named the argument after the discard operator (<code>_</code>). The remaining contents of the function are just a simple return with the values from the previous paragraph (for brevity, you will not add any extra logic to use the new values). If you had a more complex service, for example, a service that requires another service, you could call the <code>.GetService&lt;ServiceType&gt;</code> method from <code>IServiceProvider</code>.</p>
<p><code>Build</code> and <code>Create</code> are two common method names. However, they should not be used interchangeably. Use <code>Build</code> when building a single dedicated object, while <code>Create</code> is used when the intention is to produce many objects of diverse types.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/fBFRQ">https://packt.link/fBFRQ</a>.</p>
<h2 id="_idParaDest-331"><a id="_idTextAnchor377"/>Exercise 9.02: Displaying Current Time in a Country API Time Zone</h2>
<p>In this exercise, you are tasked with creating a Web API that provides the date and time at different time zones of UTC. Through a URL, you will pass a number between <code>-12</code> and <code>+12</code> and return the time in that time zone.</p>
<p>Perform the following steps:</p>
<ol>
<li value="1">Create an interface called <code>ICurrentTimeProvider</code> with a method called <code>DateTime GetTime(string timezone)</code>:<pre>public interface ICurrentTimeProvider
{
    DateTime GetTime(string timezoneId);
}</pre></li>
<li>Create a class called <code>CurrentTimeUtcProvider</code> implementing <code>ICurrentTimeProvider</code> to implement the logic required for the application:<pre>public class CurrentTimeUtcProvider : ICurrentTimeProvider
{</pre></li>
<li>Implement the method of converting the current <code>DateTime</code> to <code>Utc</code> and then offsetting that based on the time zone passed:<pre>    public DateTime GetTime(string timezoneId)
    {
        var timezoneInfo = TimeZoneInfo.FindSystemTimeZoneById(timezoneId);
        var time = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, timezoneInfo);
        return time;
    }
}</pre></li>
<li>Create a <code>CurrentTimeProviderController</code> controller to make sure it accepts <code>ICurrentTimeProvider</code> in the constructor:<pre>[ApiController]
[Route("[controller]")]
public class CurrentTimeController : ControllerBase
{
    private readonly ICurrentTimeProvider _currentTimeProvider;
    public CurrentTimeController(ICurrentTimeProvider currentTimeProvider)
    {
        _currentTimeProvider = currentTimeProvider;
    }</pre></li>
<li>Create an <code>HttpGet</code> endpoint called <code>IActionResult Get(string timezoneId)</code>, which calls the current time provider and returns the current time:<pre>    [HttpGet]
    public IActionResult Get(string timezoneId)
    {
        var time = _currentTimeProvider.GetTime(timezoneId);
        return Ok(time);
    }
}</pre></li>
</ol>
<p>Please note that <code>{timezoneId}</code> is not specified in the <code>HttpGet</code> attribute. This is because the pattern is used for REST parts on an endpoint; however, in this scenario, it is passed as an argument of a query string. If a string contains whitespaces or other special characters, it should be encoded before being passed. You can URL-encode a string using this tool: <a href="https://meyerweb.com/eric/tools/dencoder/">https://meyerweb.com/eric/tools/dencoder/</a>.</p>
<ol>
<li value="6">In the <code>Program</code> class, inject the service:<pre>builder.Services.AddSingleton&lt;ICurrentTimeProvider, CurrentTimeUtcProvider&gt;();</pre></li>
</ol>
<p>Here, you injected the service as a singleton because it is stateless.</p>
<ol>
<li value="7">Call the <code>https://localhost:7021/CurrentTime?timezone=[yourtimezone]</code> endpoint with a <code>timezoneid</code> value of your choice. For example, you can call the following endpoint: <code>https://localhost:7021/CurrentTime?timezoneid=Central%20Europe%20Standard%20Time</code>.</li>
</ol>
<p>You will get the response showing the date and time at that time zone:</p>
<pre>"2021-09-18T20:32:29.1619999"</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/iqGJL">https://packt.link/iqGJL</a>.</p>
<h2 id="_idParaDest-332"><a id="_idTextAnchor378"/>OpenAPI and Swagger</h2>
<p>OpenAPI is a <strong class="bold">REST API</strong> description format. It is a specification of an API with the endpoints it has, the authentication methods it supports, the arguments it accepts, and the example requests and responses it informs. The REST API works with both JSON and XML formats; however, JSON is chosen frequently. Swagger is a collection of tools and libraries implementing the OpenAPI standard. Swagger generates two things:</p>
<ul>
<li>A web page to make calls to your API</li>
<li>Generate client code</li>
</ul>
<p>In .NET, there are two libraries for working with Swagger:</p>
<ul>
<li><code>NSwag</code></li>
<li><code>Swashbuckle</code></li>
</ul>
<h3 id="_idParaDest-333"><a id="_idTextAnchor379"/>Using Swagger Swashbuckle</h3>
<p>In this section, you will use <code>Swashbuckle</code> to demonstrate one of many ways to test APIs and generate API documentation. So, install the <code>Swashbuckle.AspNetCore</code> package by running the following command:</p>
<pre>dotnet add package Swashbuckle.AspNetCore</pre>
<p>Just before the <code>builder.Build()</code> call, add the following line of code in <code>Program.cs</code>:</p>
<pre>builder.Services.AddSwaggerGen();</pre>
<p>This injects the Swagger services needed to generate the Swagger schema and the documentation test page.</p>
<p>After <code>builder.Build()</code> in <code>Program.cs</code>, add the following:</p>
<pre>app.UseSwagger();
app.UseSwaggerUI(c =&gt; { c.SwaggerEndpoint("/swagger/v1/swagger.json", "My API V1"); }); </pre>
<p>The first line supports reaching the OpenAPI Swagger specification and the second one allows accessing the specification on a user-friendly web page.</p>
<p>Now, run the program as follows:</p>
<pre>dotnet run --urls=https://localhost:7021/</pre>
<p>When you navigate to <code>https://localhost:7021/swagger/</code>, you will see the following screen:</p>
<div><div><img alt="Figure 9.8: A user-friendly Swagger endpoint " height="941" src="img/B16835_09_08.jpg" width="1615"/>
</div>
</div>
<p class="figure-caption">Figure 9.8: A user-friendly Swagger endpoint</p>
<p>Clicking on any of the endpoints will allow you to send an HTTP request to them. This page can be configured to include common information about the project, such as the contact information, licenses it is under, description, terms of services, and more.</p>
<p>The benefits of Swagger do not end here. If you had comments, you could include them on this page as well. You could also include all the possible response types that the endpoint produces. You can even include example requests and set them as defaults when calling an API.</p>
<p>Create a new endpoint to save a weather forecast and then another one to retrieve it. Document both the methods one by one. So, first, update the <code>IWeatherForecastService</code> interface to include the two new methods, <code>GetWeekday</code> and <code>GetWeatherForecast</code>, as follows:</p>
<pre>    public interface IWeatherForecastService
    {
        WeatherForecast GetWeekday(int day);
        void SaveWeatherForecast(WeatherForecast forecast);
        WeatherForecast GetWeatherForecast(DateTime date);
    }</pre>
<p>Next, add implementations of those methods to <code>WeatherForecastService</code>. To save the weather forecast, you will need storage, and the simplest storage would be <code>IMemoryCache</code>. Here, you will need a new field for <code>IMemoryCache</code>:</p>
<pre>private readonly IMemoryCache _cache;</pre>
<p>Now, update the constructor to inject <code>IMemoryCache</code>:</p>
<pre>public WeatherForecastService(ILogger&lt;WeatherForecastService&gt; logger, string city, int refreshInterval, IMemoryCache cache)
        {
            _logger = logger;
            _city = city;
            _refreshInterval = refreshInterval;
            _serviceIdentifier = Guid.NewGuid();
            _cache = cache;
        }</pre>
<p>Then, create the <code>SaveWeatherForecast</code> method to save a weather forecast:</p>
<pre>        public void SaveWeatherForecast(WeatherForecast forecast)
        {
            _cache.Set(forecast.Date.ToShortDateString(), forecast);
        }</pre>
<p>Create a <code>GetWeatherForecast</code> method to get a weather forecast:</p>
<pre>        public WeatherForecast GetWeatherForecast(DateTime date)
        {
            var shortDateString = date.ToShortDateString();
            var contains = _cache.TryGetValue(shortDateString, out var entry);
            return !contains ? null : (WeatherForecast) entry;
        }</pre>
<p>Now, go back to <code>WeatherForecastController</code> and create an endpoint for each method so that you can test it using the HTTP requests:</p>
<pre>        <a id="_idTextAnchor380"/>[HttpGet("{date}")]
        public IActionResult GetWeatherForecast(DateTime date)
        {
            var weatherForecast = _weatherForecastService1.GetWeatherForecast(date);
            if (weatherForecast == null) return NotFound();
            return Ok(weatherForecast);
        }
        [HttpPost]
        public IActionResult SaveWeatherForecast(WeatherForecast weatherForecast)
        {
            _weatherForecastService1.SaveWeatherForecast(weatherForecast);
            return CreatedAtAction("GetWeatherForecast", new { date = weatherForecast.Date.ToShortDateString()}, weatherForecast);
        }</pre>
<p>Please note that when creating a new weather forecast, you return a <code>CreatedAtAction</code> result. This returns an HTTP status code of <code>201</code> with a URI used to get the created resource. It was specified that, in order to get the created forecast later, you can use <code>GetWeatherForecast</code>. The anonymous <code>new { date = weatherForecast.Date.ToShortDateString()}</code> object specifies the arguments needed to call that action. You passed <code>Date.ToShortDateString()</code> and not just a date because a full <code>DateTime</code> contains more than what you need. Here, you need only a date; therefore, you explicitly cut what you don't need.</p>
<p>Document each method by describing what it does and what status codes it can return. You will then add this information above each endpoint:</p>
<pre>        /// &lt;summary&gt;
        /// Gets weather forecast at a specified date.
        /// &lt;/summary&gt;
        /// &lt;param name="date"&gt;Date of a forecast.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A forecast at a specified date.
        /// If not found - 404.
        /// &lt;/returns&gt;
        [HttpGet("{date}")]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public IActionResult GetWeatherForecast(DateTime date)
        /// &lt;summary&gt;
        /// Saves a forecast at forecast date.
        /// &lt;/summary&gt;
        /// &lt;param name="weatherForecast"&gt;Date which identifies a forecast. Using short date time string for identity.&lt;/param&gt;
        /// &lt;returns&gt;201 with a link to an action to fetch a created forecast.&lt;/returns&gt;
        [HttpPost]
        [ProducesResponseType(StatusCodes.Status201Created)]
        public IActionResult SaveWeatherForecast(WeatherForecast weatherForecast)</pre>
<p>You have now added XML docs to the two endpoints. Using <code>ProducesResponseType</code>, you specified what status codes the endpoints could return. If you refresh the Swagger page, you will see the <code>SaveWeatherForecast</code> endpoint in Swagger:</p>
<div><div><img alt="Figure 9.9: SaveWeatherForecast endpoint in Swagger " height="644" src="img/B16835_09_09.jpg" width="1604"/>
</div>
</div>
<p class="figure-caption">Figure 9.9: SaveWeatherForecast endpoint in Swagger</p>
<p>If you refresh the Swagger page, you will see the <code>GetWeatherForecast</code> endpoint in Swagger:</p>
<div><div><img alt="Figure 9.10: GetWeatherForecast endpoint in Swagger " height="890" src="img/B16835_09_10.jpg" width="1598"/>
</div>
</div>
<p class="figure-caption">Figure 9.10: GetWeatherForecast endpoint in Swagger</p>
<p>You can see the status code addition, but where did the comments go? By default, Swagger does not pick XML docs. You need to specify what it has to do by configuring your project file. To do so, add the following piece of code inside <code>&lt;Project&gt;</code> below the property group of a target framework:</p>
<pre>  &lt;PropertyGroup&gt;
    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
    &lt;NoWarn&gt;$(NoWarn);1591&lt;/NoWarn&gt;
  &lt;/PropertyGroup&gt;</pre>
<p> </p>
<div><div><img alt="Figure 9.11: Swagger configuration to include XML docs " height="449" src="img/B16835_09_11.jpg" width="1474"/>
</div>
</div>
<p class="figure-caption">Figure 9.11: Swagger configuration to include XML docs</p>
<p>Lastly, go to the <code>Program.cs</code> file and replace <code>service.AddSwaggerGen()</code> with this:</p>
<pre>            builder.Services.AddSwaggerGen(cfg =&gt;
            {
                var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                cfg.IncludeXmlComments(xmlPath);
            });</pre>
<p>This is the last piece of code needed to include XML comments in the Swagger docs. Now, refresh the page and you should see the comments included:</p>
<div><div><img alt="Figure 9.12: WeatherForecast Swagger docs with XML docs included " height="519" src="img/B16835_09_12.jpg" width="1618"/>
</div>
</div>
<p class="figure-caption">Figure 9.12: WeatherForecast Swagger docs with XML docs included</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/iQK5X">https://packt.link/iQK5X</a>.</p>
<p>There is a lot more that you can do with Swagger; you can include an example request and response and give default values to parameters. You can even create your own API specification standards and decorate a project namespace to apply the same conventions to every controller and their endpoints, but that is beyond the scope of this book.</p>
<p>The last thing to mention is the ability to generate a client out of the Swagger docs. To do so, follow these steps:</p>
<ol>
<li value="1">In order to download the <code>swagger.json</code> OpenAPI documentation artifact, navigate to <code>https://localhost:7021/swagger/v1/swagger.json</code>.</li>
<li>Right-click anywhere on the page and select the <code>Save as</code> option.</li>
<li>Then, press the <code>Enter</code> key.</li>
<li>Next, you will use this JSON to generate client code. So, register and log in to <a href="https://app.swaggerhub.com/home">https://app.swaggerhub.com/home</a> (you can use your GitHub account).</li>
<li>In the new window, click the <code>Create New</code> button (<code>1</code>):</li>
</ol>
<div><div><img alt="Figure 9.13: SwaggerHub and the Import API window " height="693" src="img/B16835_09_13.jpg" width="1413"/>
</div>
</div>
<p class="figure-caption">Figure 9.13: SwaggerHub and the Import API window</p>
<ol>
<li value="6">Select the <code>Import and document API</code> option.</li>
<li>Select the Swagger file you have just downloaded by clicking the <code>Browse</code> button (<code>2</code>).</li>
<li>Then, hit the <code>UPLOAD FILE</code> button:<p class="callout-heading">Note</p><p class="callout">When you select the file, the <code>IMPORT</code> button (<code>3</code> in <em class="italic">Figure 9.13</em>) changes to the <code>UPLOAD FILE</code> button (<code>3</code> in <em class="italic">Figure 9.14</em>).</p></li>
</ol>
<div><div><img alt="Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button " height="547" src="img/B16835_09_14.jpg" width="1065"/>
</div>
</div>
<p class="figure-caption">Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button</p>
<ol>
<li value="9">On the next screen, leave the name of the service and the version with default values.</li>
<li>Next, click the <code>IMPORT DEFINITION</code> button:</li>
</ol>
<div><div><img alt="Figure 9.15: SwaggerHub import Swagger service definition " height="480" src="img/B16835_09_15.jpg" width="950"/>
</div>
</div>
<p class="figure-caption">Figure 9.15: SwaggerHub import Swagger service definition</p>
<ol>
<li value="11">Now that the <code>Swagger.json</code> API scheme is imported, you can use it to generate a strongly typed C# client code to call the API. So, click the <code>Export</code> option (<code>1</code>).</li>
<li>Then, click the <code>Client SDK</code> option (<code>2</code>).</li>
<li>Select the <code>csharp</code> option (<code>3</code>):<div><img alt="Figure 9.16: Exporting a new client in the C# client from SwaggerHub " height="643" src="img/B16835_09_16.jpg" width="1232"/></div></li>
</ol>
<p> </p>
<p class="figure-caption">Figure 9.16: Exporting a new client in the C# client from SwaggerHub</p>
<p>A <code>csharp-client-generated.zip</code> file will be downloaded.</p>
<ol>
<li value="14">Extract the <code>csharp-client-generated.zip</code> file.</li>
<li>Navigate the extracted folder and open the <code>IO.Swagger.sln</code> file. You should see the following:</li>
</ol>
<div><div><img alt="Figure 9.17: Files generated for the client using SwaggerHub " height="691" src="img/B16835_09_17.jpg" width="1309"/>
</div>
</div>
<p class="figure-caption">Figure 9.17: Files generated for the client using SwaggerHub</p>
<p>The generated client code not only has a strongly typed HTTP client but also includes tests. It also has a <code>README.md</code> file on how to call the client and many more common development scenarios.</p>
<p>Now, the question that arises is whether you should use Swagger when you already have Postman. While Postman is one of the most popular tools used for testing different kinds of Web APIs, Swagger is so much more than just a client to test whether the API works. Primarily, Swagger is a tool for documenting the API. From a conventional code, it allows you to generate all that you might need to:</p>
<ul>
<li>Test page</li>
<li>Test the client code</li>
<li>Test the documentation page</li>
</ul>
<p>Till now, you have learned that Swagger is a collection of tools and libraries implementing OpenAPI standards that are helpful for testing and documenting your APIs. You can now proceed to grasp error handling.</p>
<h2 id="_idParaDest-334"><a id="_idTextAnchor381"/>Error Handling</h2>
<p>You have already learned that the code within a controller should be as minimalistic as possible due to it being the highest level in code (direct call). Specific error handling should not be included in the controller code because it adds complexity to already-complex code. Fortunately, there is a way to map exceptions to HTTP status codes and set up all of them in one place—that is, via the <code>Hellang.Middleware.ProblemDetails</code> package. To do so, first install the package by running this command:</p>
<pre>dotnet add package <code>Hellang.Middleware.ProblemDetails</code></pre>
<p>Map <code>NoSuchWeekdayException</code> to HTTP status code <code>404</code>. In the <code>Program.cs</code> file, before <code>builder.Build()</code>, add the following code:</p>
<pre>            builder.Services.AddProblemDetails(opt =&gt;
            {
                opt.MapToStatusCode&lt;NoSuchWeekdayException&gt;(404);
                opt.IncludeExceptionDetails = (context, exception) =&gt; false;
            });</pre>
<p>This not only converts an exception to the right status code but also uses <code>ProblemDetails</code>—a standard response model based on RFC 7807—to provide faults in an HTTP response. Also, this excludes exception details in the error message.</p>
<p>When developing a service locally, knowing what went wrong is invaluable. However, exposing the stack trace and other information needed to determine the error can expose exploits of your Web API. Thus, it's better to hide it when moving toward the release stage. By default, the <code>Hellang</code> library already excludes the exception details in upper environments, so it is better that you don't include that line. For demo purposes and a simplified response message, it was included here.</p>
<p>Before you build a demo, you also need to turn off the default developer exceptions page because it overrides the exceptions in <code>ProblemDetails</code>. Simply remove the following block of code from the <code>Configure</code> method:</p>
<pre>        if (builder.Environment.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }</pre>
<p>Since you already have a central place for handling <code>NoSuchWeekdayException</code>, you can simplify the controller method for getting <code>WeatherForecast</code> for a given date:</p>
<pre>        [HttpGet("weekday/{day}")]
        public IActionResult GetWeekday(int day)
        {
            var result = _weatherForecastService.GetWeekday(day);
            return Ok(result);
        }</pre>
<p>When calling the endpoint with an invalid day value (for example, <code>9</code>), you get the following response:</p>
<pre>{
    "type": "/weatherforecast/weekday/9",
    "title": "Not Found",
    "status": 404,
    "traceId": "|41dee286-4c5efb72e344ee2d."
}</pre>
<p>This centralized error handling approach allows the controllers to be rid of all the <code>try-catch</code> blocks.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/CntW6">https://packt.link/CntW6</a>.</p>
<p>You can now map exceptions to HTTP status codes and set them all up in one place. This next section will take a look at another addition to an API, which is request validation.</p>
<h2 id="_idParaDest-335"><a id="_idTextAnchor382"/>Request Validation</h2>
<p>Another useful addition to an API is request validation. By default, ASP.NET Core has a request validator based on the required attributes. However, there might be complex scenarios where a combination of properties results in an invalid request or a custom error message for which validation is required.</p>
<p>.NET has a great NuGet package for that: <code>FluentValidation.AspNetCore</code>. Perform the following steps to learn how to carry out request validation. Before you continue, install the package by running the following command:</p>
<pre>dotnet add package <code>FluentValidation.AspNetCore</code></pre>
<p>This package allows registering custom validators per model. It makes use of existing ASP.NET Core middleware, so all you must do is inject a new validator. Create a validator for <code>WeatherForecast</code>.</p>
<p>A validator should inherit the <code>AbstractValidator</code> class. This is not obligatory, but it is highly recommended because it implements the common methods for functionality and has a default implementation for generic validation:</p>
<pre>public class WeatherForecastValidator : AbstractValidator&lt;WeatherForecast&gt;</pre>
<p>Through a generic argument, you specified that this is a validator for <code>WeatherForecast</code>.</p>
<p>Next is the validation itself. This is done in a constructor of a validator:</p>
<pre>        public WeatherForecastValidator()
        {
            RuleFor(p =&gt; p.Date)
                .LessThan(DateTime.Now.AddMonths(1))
                .WithMessage("Weather forecasts in more than 1 month of future are not supported");
            RuleFor(p =&gt; p.TemperatureC)
                .InclusiveBetween(-100, 100)
                .WithMessage("A temperature must be between -100 and +100 C.");
        }</pre>
<p><code>FluentValidation</code> is a .NET library and is all about fluent API, with self-explanatory methods. Here, you require a weather forecast date to be no more than one month in the future. The next validation is to have the temperature between <code>-100 C</code> and <code>100 C</code>.</p>
<p>If you ping your API through Swagger, the following request gets displayed:</p>
<pre>{
  "date": "2022-09-19T19:34:34.511Z",
  "temperatureC": -111,
  "summary": "string"
}</pre>
<p>The response will be displayed as follows:</p>
<pre>{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "traceId": "|ade14b9-443aaaf79026feec.",
  "errors": {
    "Date": [
      "Weather forecasts in more than 1 month of future are not supported"
    ],
    "TemperatureC": [
      "A temperature must be between -100 and +100 C."
    ]
  }
}</pre>
<p>You don't have to use <code>FluentValidation</code>, especially if your API is simple and does not have complex rules. But in an enterprise setting, it is highly recommended that you do use it because the level of detail you can add to your validation is unlimited.</p>
<p>You learned about <code>FluentValidation</code> and the scenarios where it is useful. The next section will touch upon the two options for reading configuration in ASP.NET.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/uOGOe">https://packt.link/uOGOe</a>.</p>
<h2 id="_idParaDest-336"><a id="_idTextAnchor383"/>Configuration</h2>
<p>In ASP.NET Core Web API, you have two options for reading configuration:</p>
<ul>
<li><code>IConfiguration</code>: This is a global configuration container. Even though it allows access to all the configuration properties, injecting it directly into other components is inefficient. This is because it is weakly typed and has a risk of you trying to get a non-existing configuration property.</li>
<li><code>IOptions</code>: This is strongly typed and convenient because the configuration is fragmented into just the pieces that a component needs.</li>
</ul>
<p>You can choose either of the two options. It is best practice to use <code>IOptions</code> in ASP.NET Core, as the configuration examples will be based on it. Whichever option you choose, you need to store the configuration in the <code>appsettings.json</code> file.</p>
<p>Move the hardcoded configuration from a constructor (weather forecast city and refresh interval) and move it into a configuration section in the <code>appsettings.json</code> file:</p>
<pre>  "WeatherForecastConfig": {
    "City": "New York",
    "RefreshInterval":  5 
  }</pre>
<p>Create a model representing this configuration section:</p>
<pre>    public class WeatherForecastConfig
    {
        public string City { get; set; }
        public int RefreshInterval { get; set; }
    }</pre>
<p>You no longer have to inject the two primitive values into the component. Instead, you will inject <code>IOptions&lt;WeatherForecastConfig&gt;</code>:</p>
<pre>public WeatherForecastService(Ilogger&lt;WeatherForecastService&gt; logger, Ioptions&lt;WeatherForecastConfig&gt; config, ImemoryCache cache)</pre>
<p>Before the JSON section is useable, you need to bind to it. This can be done by finding the section through <code>IConfiguration</code> (via the <code>builder.Configuration</code> property):</p>
<pre>builder.Services.Configure&lt;WeatherForecastConfig&gt;(builder.Configuration.GetSection(nameof(WeatherForecastConfig)));</pre>
<p>In this case, <code>WeatherForecastConfig</code> has a matching section in the configuration file. Therefore, <code>nameof</code> was used. So, <code>nameof</code> should be preferred when using the alternative <code>string</code> type. That way, if the name of a type changes, the configuration will change consistently (or else the code won't compile).</p>
<p>Remember the <code>BuildWeatherForecastService</code> method you used previously? The beauty of it all is that the method can be removed altogether because the service can be created without the need for custom initialization. If you compile and run the code, you will get the same response.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/xoB0K">https://packt.link/xoB0K</a>.</p>
<p>ASP.NET Core Web API is just a collection of libraries on top of the .NET Core framework. You can use <code>appsettings.json</code> in other types of applications as well. It is better to use individual libraries regardless of the project type you choose. In order to use the configuration through JSON, all you need to do is to install the following NuGet packages:</p>
<ul>
<li><code>Microsoft.Extensions.Configuration</code></li>
<li><code>Microsoft.Extensions.Configuration.EnvironmentVariables</code></li>
<li><code>Microsoft.Extensions.Configuration.FileExtensions</code></li>
<li><code>Microsoft.Extensions.Configuration.Json</code></li>
<li><code>Microsoft.Extensions.Options</code></li>
</ul>
<p>In this section, you learned how to use <code>IConfiguration</code> and <code>IOptions</code>. Your API is now ready, and it already includes many standard components of a typical Web API. The next section will detail how you can handle this complexity in code.</p>
<h3 id="_idParaDest-337"><a id="_idTextAnchor384"/>Development Environments and Configuration</h3>
<p>Applications often need to have two environments—production and development. You want the application development environment to have premade settings, more detailed error messages (if possible), more detailed logging, and lastly, debugging enabled. All of that is not needed for a production environment and you would want to keep it clean.</p>
<p>Other than the build configuration, you manage environments through different configuration files. The <code>appsettings.json</code> file is a base configuration file and is used across all environments. This configuration file should contain the configuration you would like for production.</p>
<p>The <code>Appsettings.development.json</code> file is a configuration file that will be applied when you build your application in debug mode. Here, <code>appsettings.json</code> will still be used with the development settings overriding the matching sections. A common example is described here.</p>
<p>Say <code>appsettings.json</code> has the following:</p>
<pre>{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "WeatherForecastConfig": {
    "City": "New York",
    "RefreshInterval": 5
  },
  "WeatherForecastProviderUrl": "https://community-open-weather-map.p.rapidapi.com/",
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "ClientId": "2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb",
    "TenantId": "ddd0fd18-f056-4b33-88cc-088c47b81f3e",
    "Audience": "api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"
  }
}</pre>
<p>And <code>appsettings.development.json</code> has the following:</p>
<pre>{
  "Logging": {
    "LogLevel": {
      "Default": "Trace",
      "Microsoft": "Trace",
      "Microsoft.Hosting.Lifetime": "Trace"
    }
  }
}</pre>
<p>Then, the settings used will be the merged file with override matching sections, as shown here:</p>
<pre>{
  "Logging": {
    "LogLevel": {
      "Default": "Trace",
      "Microsoft": "Trace",
      "Microsoft.Hosting.Lifetime": "Trace"
    }
  },
  "AllowedHosts": "*",
  "WeatherForecastConfig": {
    "City": "New York",
    "RefreshInterval": 5
  },
  "WeatherForecastProviderUrl": "https://community-open-weather-map.p.rapidapi.com/",
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "ClientId": "2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb",
    "TenantId": "ddd0fd18-f056-4b33-88cc-088c47b81f3e",
    "Audience": "api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"
  }
}</pre>
<p>In the next section, you will learn how to manage DI more cleanly.</p>
<h2 id="_idParaDest-338"><a id="_idTextAnchor385"/>Bootstrapping</h2>
<p>Complexity needs to be handled and the complexity referred to here is the <code>Program</code> class. You'll need to break it out into smaller pieces and form a Bootstrapping directory specifying the components the service is made of.</p>
<p>When breaking down code within <code>Program.cs</code>, it is recommended to use a fluent API pattern. This is a pattern where you can chain multiple function calls from a single root object. In this case, you will create several extension methods for the <code>IServiceCollection</code> type and chain all the module injections one by one.</p>
<p>To reduce the complexity of the <code>Program</code> class, move the DI of different logical sections into different files. Each step that follows will do just that. So, split the controller and API baseline setup to a new file named <code>ControllersConfigurationSetup.cs</code>:</p>
<pre>    public static class ControllersConfigurationSetup
    {
        public static IserviceCollection AddControllersConfiguration(this IserviceCollection services)
        {
            services
                .AddControllers()
                .AddFluentValidation();
            return services;
        }
    }</pre>
<p>Now, move the code for logging to a new file named <code>LoggingSetup.cs</code>:</p>
<pre>    public static class LoggingSetup
    {
        public static IServiceCollection AddLoggingConfiguration(this IServiceCollection services)
        {
            services.AddLogging(builder =&gt;
            {
                builder.ClearProviders();
                builder.AddConsole();
                builder.AddDebug();
            });
            return services;
        }
    }</pre>
<p>Next, move the request validation logic to a new file named <code>RequestValidatorsSetup.cs</code>:</p>
<pre>    public static class RequestValidatorsSetup
    {
        public static IServiceCollection AddRequestValidators(this IServiceCollection services)
        {
            services.AddTransient&lt;Ivalidator&lt;WeatherForecast&gt;, WeatherForecastValidator&gt;();
            return services;
        }
    }</pre>
<p>Move the Swagger setup logic to a new file named <code>SwaggerSetup.cs</code>:</p>
<pre>    public static class SwaggerSetup
    {
        public static IServiceCollection AddSwagger(this IServiceCollection services)
        {
            services.AddSwaggerGen(cfg =&gt;
            {
                var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                cfg.IncludeXmlComments(xmlPath);
            });
            return services;
        }
    }</pre>
<p>Move the injection of the <code>WeatherForecast</code>-related classes' code to a new file named  <code>WeatherServiceSetup.cs</code>:</p>
<pre>    public static class WeatherServiceSetup
    {
        public static IServiceCollection AddWeatherService(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;(BuildWeatherForecastService);
            services.AddSingleton&lt;ICurrentTimeProvider, CurrentTimeUtcProvider&gt;();
            services.AddSingleton&lt;ImemoryCache, MemoryCache&gt;();
            services.Configure&lt;WeatherForecastConfig&gt;(configuration.GetSection(nameof(WeatherForecastConfig)));
            return services;
        }
        private static WeatherForecastService BuildWeatherForecastService(IserviceProvider provider)
        {
            var logger = provider
                .GetService&lt;IloggerFactory&gt;()
                .CreateLogger&lt;WeatherForecastService&gt;();
            var options = provider.GetService&lt;Ioptions&lt;WeatherForecastConfig&gt;&gt;();
            return new WeatherForecastService(logger, options, provider.GetService&lt;ImemoryCache&gt;());
        }
    }</pre>
<p>Finally, move the exception mapping of HTTP status codes to a new file named <code>ExceptionMappingSetup.cs</code>:</p>
<pre>    public static class ExceptionMappingSetup
    {
        public static IServiceCollection AddExceptionMappings(this IServiceCollection services)
        {
            services.AddProblemDetails(opt =&gt;
            {
                opt.MapToStatusCode&lt;NoSuchWeekdayException&gt;(404);
            });
            return services;
        }
    }</pre>
<p>Now move all the new classes under <code>/Bootstrap</code> folder:</p>
<div><div><img alt="Figure 9.18: Bootstrap folder with the fragmented services injection " height="461" src="img/B16835_09_18.jpg" width="1274"/>
</div>
</div>
<p> </p>
<p class="figure-caption">Figure 9.18: Bootstrap folder with the fragmented services injection</p>
<p><em class="italic">Figure 9.18</em> displays the <code>Bootstrap</code> folder. This project structure itself demonstrates what the API is made up of. So, DI becomes as simple as the following:</p>
<pre>builder.Services
    .AddControllersConfiguration()
    .AddLoggingConfiguration()
    .AddRequestValidators()
    .AddSwagger()
    .AddWeatherService(builder.Configuration)
    .AddExceptionMappings();</pre>
<p>In some cases, you may want to pass the configuration or environment from a builder to other bootstrap methods or app methods multiple times. If you find yourself repeatedly calling <code>builder.X</code>, then consider storing each property in a local variable, as shown here:</p>
<pre>var services = builder.Services;
var configuration = builder.Configuration;
var environment = builder.Environment;</pre>
<p>With this, you will no longer repeatedly access the builder and will instead be able to use the needed builder properties directly. This is especially useful if you migrate from .NET Core to .NET 6. <code>Environment</code> and <code>Configuration</code> used to be properties of a <code>Program</code> class, while <code>Services</code> would be injected into the <code>ConfigureServices</code> method. In .NET 6, <code>Services</code> is accessed through a <code>builder</code> object. However, with this approach, you can still use those properties or arguments as they were.</p>
<p>From now on, when referring to services, environments, or configurations, you will assume that you are accessing them from <code>builder.Services</code>, <code>builder.Environment</code>, and <code>builder.Configuration</code>, accordingly.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/iQK5X">https://packt.link/iQK5X</a>.</p>
<h2 id="_idParaDest-339"><a id="_idTextAnchor386"/>Calling Another API</h2>
<p>A working product is usually made of many APIs communicating with each other. To communicate effectively, one web service often needs to call another service. For example, a hospital may have a website (frontend) that calls a Web API (backend). This Web API orchestrates things by making calls to a booking Web API, a billing Web API, and a staff Web API. A staff Web API may make calls to an inventory API, holidays API, etc.</p>
<h3 id="_idParaDest-340"><a id="_idTextAnchor387"/>RapidAPI</h3>
<p>As discussed in <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, there are various ways of making HTTP calls to other services (though HTTP is not the only way to call another service). This time, you will try to get weather forecasts from an existing API and format it in your way. For doing so, you will use the RapidAPI Weather API, which can be found at <a href="https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/">https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">RapidAPI is a platform that supports many APIs. The site <a href="https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/">https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/</a> is just one example. Many of the APIs present there are free; however, be aware that an API that is free today might become paid tomorrow. If that happens by the time you read this chapter, go through the examples, and explore the <em class="italic">Weather APIs</em> section at <a href="https://rapidapi.com/category/Weather">https://rapidapi.com/category/Weather</a>. You should be able to find similar alternatives there.</p>
<p>This API requires a GitHub account for use. Perform the following steps to use the RapidAPI Weather API:</p>
<ol>
<li value="1">Log in to the website <a href="https://rapidapi.com/community/api/open-weather-map/">https://rapidapi.com/community/api/open-weather-map/</a>.<p class="callout-heading">Note</p><p class="callout">You can navigate to <a href="https://rapidapi.com/community/api/open-weather-map/">https://rapidapi.com/community/api/open-weather-map/</a> only if you are logged in. So, signup at <a href="https://rapidapi.com/">https://rapidapi.com/</a> and create an account. This is required if you need an API key. Next login and select <code>Weather</code> category and choose <code>Open Weather</code> link.</p></li>
</ol>
<p>After you log in to the website, you will see the following window:</p>
<div><div><img alt="Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on rapidapi.com " height="622" src="img/B16835_09_19.jpg" width="1313"/>
</div>
</div>
<p class="figure-caption">Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on rapidapi.com</p>
<ol>
<li value="2">Click the <code>Subscribe to Test</code> button to get access (for free) to making calls to the Web API. A new window will open.</li>
<li>Select the <code>Basic</code> option, which will allow you to make 500 calls a month to that API. For educational purposes, the basic plan should be enough:</li>
</ol>
<div><div><img alt="Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted " height="580" src="img/B16835_09_20.jpg" width="1349"/>
</div>
</div>
<p class="figure-caption">Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted</p>
<p>You will be redirected to the test page with the <code>Test Endpoint</code> button available (instead of the <code>Subscribe to Test</code> button).</p>
<ol>
<li value="4">Now, configure the request. The first configuration asks you to enter the intervals for getting the weather forecast. You want an hourly forecast, so enter <code>1</code> hour beside <code>aggregateHours</code> (<code>1</code>).</li>
<li>Next up is the <code>location</code> address (<code>2</code>).</li>
</ol>
<p>In <em class="italic">Figure 9.21</em>, you can observe that the city, state, and country are specified. These fields ask you to enter your address. However, typing your city name would also work.</p>
<ol>
<li value="6">Choose the default <code>contentType</code> option as <code>csv</code> for this API (<code>3</code>):</li>
</ol>
<div><div><img alt="Figure 9.21: GET weather forecast data request configuration " height="674" src="img/B16835_09_21.jpg" width="1432"/>
</div>
</div>
<p class="figure-caption">Figure 9.21: GET weather forecast data request configuration</p>
<p>This API is interesting because it allows you to return data in different formats—JSON, XML, and CSV. It is still a Web API and not so RESTful because the data response type is natively CSV. If you choose JSON, it will look unnatural and significantly more difficult to work with.</p>
<ol>
<li value="7">On the next screen, click <code>Code Snippets</code> (<code>1</code>) and then <code>(C#) HttpClient</code> (<code>2</code>) to see the example client code generated for you.</li>
<li>Next, click <code>Test Endpoint</code> (<code>3</code>) to send a request.</li>
<li>Click the <code>Results</code> tab (<code>4</code>) to view the response (in <em class="italic">Figure 9.22</em>, other endpoints are collapsed):</li>
</ol>
<div><div><img alt="Figure 9.22: rapidapi.com with test request page and example code  in C# for making the request " height="576" src="img/B16835_09_22.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 9.22: rapidapi.com with test request page and example code in C# for making the request</p>
<p>This window provides a nice API. It is also a great way to learn how to make calls to it by giving multiple examples of creating clients using a variety of languages and technologies.</p>
<p>As always, you will not initialize this client directly in a client but inject the client somehow. In <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, it was mentioned that to have a static <code>HttpClient</code> over one constantly disposed is an efficient practice. However, for a Web API, there is an even better alternative—<code>HttpClientFactory</code>.</p>
<ol>
<li value="10">Before you do all that, you need to prepare a few things. First, update the <code>appsettings.json</code> file with the inclusion of the base URL of an API:<pre>"WeatherForecastProviderUrl": "https://visual-crossing-weather.p.rapidapi.com/"</pre></li>
</ol>
<p>Next, you will need to create another class for fetching the weather details from the said API. For that purpose, you will need an API key. You can find it in the example code snippet on the API website:</p>
<div><div><img alt="Figure 9.23: RapidAPI API key in the example code snippet " height="606" src="img/B16835_09_23.jpg" width="1124"/>
</div>
</div>
<p class="figure-caption">Figure 9.23: RapidAPI API key in the example code snippet</p>
<ol>
<li value="11">Save the API key as an environment variable because it is a secret and storing secrets in code is bad practice. So, name it as <code>x-rapidapi-key</code>.</li>
<li>Lastly, the returned weather forecast might be quite different from yours. You can see the example response by clicking the <code>Test Endpoint</code> button:</li>
</ol>
<div><div><img alt="Figure 9.24: RapidAPI example response from GET current weather data endpoint " height="372" src="img/B16835_09_24.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 9.24: RapidAPI example response from GET current weather data endpoint</p>
<ol>
<li value="13">Copy the results received after clicking the <code>Test Endpoint</code> button.</li>
<li>Paste the results in <a href="https://toolslick.com/generation/code/class-from-csv">https://toolslick.com/generation/code/class-from-csv</a>.</li>
<li>Give the class name as <code>WeatherForecast</code> and leave the rest of the settings as the defaults.</li>
<li>Finally, press the <code>GENERATE</code> button:</li>
</ol>
<div><div><img alt="Figure 9.25: Response content pasted to  https://toolslick.com/generation/code/class-from-csv " height="739" src="img/B16835_09_25.jpg" width="1377"/>
</div>
</div>
<p class="figure-caption">Figure 9.25: Response content pasted to <a href="https://toolslick.com/generation/code/class-from-csv">https://toolslick.com/generation/code/class-from-csv</a></p>
<p>This will create two classes, <code>WeatherForecast</code> and <code>WeatherForecastClassMap</code>:</p>
<div><div><img alt="Figure 9.26: Generated data model and mapping classes (simplified for brevity) " height="278" src="img/B16835_09_26.jpg" width="1005"/>
</div>
</div>
<p class="figure-caption">Figure 9.26: Generated data model and mapping classes (simplified for brevity)</p>
<p><code>WeatherForecast</code> represents the object to which the data from this API will be loaded.</p>
<ol>
<li value="17">Create a file called <code>WeatherForecast.cs</code> under the <code>Dtos</code> folder (DTO will be described in detail in the <em class="italic">DTO and Mapping Using AutoMapper</em> section) and paste the class there.</li>
<li>Remove the bits that do not have a connection to an already-existing <code>WeatherForecast</code> model. The cleaned-up model will look as follows:<pre>public class WeatherForecast
{
    public DateTime Datetime { get; set; }
    public string Temperature { get; set; }
    public string Conditions { get; set; }
}</pre></li>
</ol>
<p>You should know that <code>WeatherForecastClassMap</code> is a special class. It is used by the <code>CsvHelper</code> library, which is used for parsing CSV files. You could parse CSV files yourself; however, <code>CsvHelper</code> makes it a lot easier to parse.</p>
<ol>
<li value="19">To use <code>CsvHelper</code>, install its NuGet package:<pre>dotnet add package CsvHelper</pre></li>
</ol>
<p><code>WeatherForecastCsv</code> represents a mapping from a CSV to a C# object.</p>
<ol>
<li value="20">Now, create a file called <code>WeatherForecastClassMap.cs</code> under the <code>ClassMaps</code> folder and paste the class there.</li>
<li>Keep only the mappings that match the <code>WeatherForecast</code> class that was edited in <em class="italic">Step 17</em>:<pre>public class WeatherForecastClassMap : ClassMap&lt;WeatherForecast&gt;
{
    public WeatherForecastClassMap()
    {
        Map(m =&gt; m.Datetime).Name("Date time");
        Map(m =&gt; m.Temperature).Name("Temperature");
        Map(m =&gt; m.Conditions).Name("Conditions");
    }
}</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this example at <a href="https://packt.link/dV6wX">https://packt.link/dV6wX</a> and <a href="https://packt.link/mGJMW">https://packt.link/mGJMW</a>.</p></li>
</ol>
<p>In the previous section, you learned how to get weather forecasts from an existing API and format them your way using the RapidAPI Weather API. Now it is time to proceed to the service client and use the models created, along with the settings, parse the API response, and return the current time weather.</p>
<h3 id="_idParaDest-341"><a id="_idTextAnchor388"/>Service Client</h3>
<p>Now you have all the ingredients that are needed to create the provider class. You learned in <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, that when communicating with another API, it's best to create a separate component for it. So, here you will start from an interface abstraction, <code>IWeatherForecastProvider</code>:</p>
<pre>    public interface IWeatherForecastProvider
    {
        Task&lt;WeatherForecast&gt; GetCurrent(string location);
    }</pre>
<p>Next, create an implementation of that interface—that is, a class taking <code>HttpClient</code> for DI:</p>
<pre>public class WeatherForecastProvider : IWeatherForecastProvider
    {
        private readonly HttpClient _client;
        public WeatherForecastProvider(HttpClient client)
        {
            _client = client;
        }</pre>
<p>To implement an interface, start with writing a method definition for getting the current weather:</p>
<pre>public async Task&lt;WeatherForecast&gt; GetCurrent(string location)
{</pre>
<p>Next, create a request to call HTTP GET with a relative URI for getting a forecast of the CSV type at a given location:</p>
<pre>var request = new HttpRequestMessage
{
    	Method = HttpMethod.Get,
    	RequestUri = new Uri($"forecast?aggregateHours=1&amp;location={location}&amp;contentType=csv", UriKind.Relative),
};</pre>
<p>Now, send a request and verify that it was a success:</p>
<pre>using var response = await _client.SendAsync(request);
response.EnsureSuccessStatusCode();</pre>
<p>If the status code is not in the range of <code>200-300</code>, the <code>response.EnsureSuccessStatusCode();</code> throws an exception. Set up a CSV reader to prepare for deserializing weather forecasts:</p>
<pre>var body = await response.Content.ReadAsStringAsync();
using var reader = new StringReader(body);
using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
csv.Context.RegisterClassMap&lt;WeatherForecastClassMap&gt;();</pre>
<p>You are adding a <code>using</code> statement to <code>StringReader</code> and <code>CsvReader</code> because both implement the <code>IDisposable</code> interface for disposing unmanaged resources. This happens when you use the <code>using</code> statement within a function after it returns.</p>
<p>Lastly, deserialize the forecasts:</p>
<pre>var forecasts = csv.GetRecords&lt;WeatherForecast&gt;();</pre>
<p>This way, you request the API to return forecasts starting from today and stopping a few days in the future with 1-hour intervals. The first returned forecast is the forecast of the current hour—that is, the forecast that you need:</p>
<pre>return forecasts.First();
}</pre>
<p>Now, you will use <code>Newtonsoft.Json</code> for deserialization. Install the following package to do so:</p>
<pre>dotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson</pre>
<p>Update the <code>AddControllersConfiguration</code> method by appending the following line on the services object:</p>
<pre>.AddNewtonsoftJson();</pre>
<p>This line replaces the default serializer with <code>Newtonsoft.Json</code>. Now, <code>Newtonsoft.Json</code> doesn't have to be used; however, it is a much more popular and complete library for serialization compared to the default one.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/jmSwi">https://packt.link/jmSwi</a>.</p>
<p>Till now, you have learned how to create a service client and make basic HTTP calls using it. It's effective for grasping the basics; however, the classes the API uses should be coupled with the classes of the APIs it consumes. In the next section, you will learn how to decouple the API from third-party API models using a DTO and mapping via <code>AutoMapper</code>.</p>
<h3 id="_idParaDest-342"><a id="_idTextAnchor389"/>DTO and Mapping Using AutoMapper</h3>
<p>The weather forecast model from RapidAPI is a Date Transfer Object (DTO)—a model used just for transferring data and convenient serialization. RapidAPI may change its data model and, if that happens, the DTO will change as well. If you are just presenting the data you had received and don't need to perform any logical operations on it, then any change may be alright.</p>
<p>However, you will usually apply business logic to a data model. You already know that references to a data model are scattered across multiple classes. With every change to a DTO, a class may have to change as well. For example, the DTO property that was called <code>weather</code> has now changed to <code>weathers</code>. Another example is of a property that was previously called <code>description</code> will now be called a <code>message</code>. So, renaming a DTO property like this will require you to make changes everywhere they are referenced. The bigger the project, the worse of an issue this becomes.</p>
<p>The advice of the SOLID principles is to avoid such changes (refer to <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>). One of the ways to achieve this is by having two kinds of models—one for domain and the other for outside calls. This will require a mapping between foreign objects (coming from outside APIs) into your own.</p>
<p>Mapping can be done either manually or by using some popular libraries. One of the most popular mapping libraries is AutoMapper. It allows you to map from one object to another using property names. You can also make your own mappings. Now, you will use this library to configure a mapping between a weather forecast DTO and a weather forecast model.</p>
<p>So, first install NuGet:</p>
<pre>dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection</pre>
<p>This library allows you to inject <code>AutoMapper</code> into <code>ServiceCollection</code>. Here, <code>AutoMapper</code> uses the <code>Profile</code> class to define a mapping.</p>
<p>A new mapping should inherit the <code>Profile</code> class. So, inside the constructor of the new profile, use a <code>CreateMap</code> method to provide a mapping:</p>
<pre>    public class WeatherForecastProfile : Profile
    {
        public WeatherForecastProfile()
        {
            CreateMap&lt;Dtos.WeatherForecast, Models.WeatherForecast&gt;()</pre>
<p>Next, in order to map every property from the <code>CreateMap</code> method, call the <code>ForMember</code> method and specify how to do a mapping:</p>
<pre>                .ForMember(to =&gt; to.TemperatureC, opt =&gt; opt.MapFrom(from =&gt; from.main.temp));</pre>
<p>Here, the value of <code>TemperatureC</code> comes from <code>main.temp</code> inside the DTO.</p>
<p>For the other property, you will concatenate all the weather descriptions into one string and call that a summary (<code>BuildDescription</code>):</p>
<pre>        private static string BuildDescription(Dtos.WeatherForecast forecast)
        {
            return string.Join(",",
                forecast.weather.Select(w =&gt; w.description));
        }</pre>
<p>Now, use the lambda method, <code>ForMember</code>, when building a weather forecast summary mapping:</p>
<pre>.ForMember(to =&gt; to.Summary, opt =&gt; opt.MapFrom(from =&gt; BuildDescription(from)))</pre>
<p>Create a <code>MapperSetup</code> class and inject <code>AutoMapper</code> from the <code>AddModelMappings</code> method to provide different mapping profiles:</p>
<pre>public static class MapperSetup
{
    public static IServiceCollection AddModelMappings(this IServiceCollection services)
    {
        services.AddAutoMapper(cfg =&gt;
        {
            cfg.AddProfile&lt;WeatherForecastProfile&gt;();
        });
        return services;
    }
}</pre>
<p>Append <code>.AddModelMappings()</code> to the <code>services</code> object calls. With this, you can call <code>mapper.Map&lt;Model.WeatherForecast&gt;(dtoForecast);</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/fEfdw">https://packt.link/fEfdw</a> and <a href="https://packt.link/wDqK6">https://packt.link/wDqK6</a>.</p>
<p>The <code>AutoMapper</code> mapping library allows you to map from one object to another by default mapping matching property names. The next section will detail how you can use DI to reuse <code>HttpClient</code>.</p>
<h3 id="_idParaDest-343"><a id="_idTextAnchor390"/>HttpClient DI</h3>
<p>Continuing with DI, you now want to get into the habit of using the fragmented <code>ConfigureServices</code> approach. So, first, create a class called <code>HttpClientsSetup</code> and then create a method for adding the configured <code>HttpClients</code>:</p>
<pre>    public static class HttpClientsSetup
    {
        public static IServiceCollection AddHttpClients(IServiceCollection services)
        {</pre>
<p>Next, for the injection itself, use the <code>AddHttpClient</code> method:</p>
<pre>services.AddHttpClient&lt;IWeatherForecastProvider, WeatherForecastProvider&gt;((provider, client) =&gt;
            {</pre>
<p>In the preceding section, it was mentioned that the keys should be hidden and stored in environment variables. To set a default start URI of every call, set <code>BaseAddress</code> (<code>WeatherForecastProviderUrl</code> used in <em class="italic">Step 10</em> of the <em class="italic">RapidAPI</em> section).</p>
<p>To append the API key on every request, get the API key that you stored in environment variables and assign it to default headers as <code>x-rapidapi-key</code>:</p>
<pre>                client.BaseAddress = new Uri(config["WeatherForecastProviderUrl"]);
                var apiKey = Environment.GetEnvironmentVariable("x-rapidapi-key", EnvironmentVariableTarget.User);
                client.DefaultRequestHeaders.Add("x-rapidapi-key", apiKey);
            });</pre>
<p>To finish the injection-builder pattern, you need to return the <code>services</code> object, as follows:</p>
<pre>return services;</pre>
<p>Now, go back to <code>services</code> in <code>Program</code> and append the following:</p>
<pre>.AddHttpClients(Configuration)</pre>
<p>To integrate the client you have just set up, go to <code>WeatherForecastService</code>, and inject the <code>mapper</code> and <code>provider</code> components:</p>
<pre>public WeatherForecastService(..., IWeatherForecastProvider provider, IMapper mapper)</pre>
<p>Change the <code>GetWeatherForecast</code> method to either get the cached forecast of this hour or fetch a new one from the API:</p>
<pre>        public async Task&lt;WeatherForecast&gt; GetWeatherForecast(DateTime date)
        {
            const string DateFormat = "yyyy-MM-ddthh";
            var contains = _cache.TryGetValue(date.ToString(DateFormat), out var entry);
            if(contains){return (WeatherForecast)entry;}
            
            var forecastDto = await _provider.GetCurrent(_city);
            var forecast = _mapper.Map&lt;WeatherForecast&gt;(forecastDto);
            forecast.Date = DateTime.UtcNow;
            _cache.Set(DateTime.UtcNow.ToString(DateFormat), forecast);
            return forecast;
        }</pre>
<p>This method, just like the preceding one, first tries to get a value from the cache. If the value exists, then the method returns a value. However, if the value does not exist, the method calls the API for the preconfigured city, maps the DTO forecast to the model forecast, and saves it in the cache.</p>
<p>If you send an HTTP GET request to <code>https://localhost:7021/WeatherForecast/</code>, you should see the following response:</p>
<pre>{"date":"2021-09-21T20:17:47.410549Z","temperatureC":25,"temperatureF":76,"summary":"clear sky"}</pre>
<p>Calling the same endpoint results in the same response. However, the response times are significantly faster due to the cache being used rather than repeating a call to the forecast API.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/GMFmm">https://packt.link/GMFmm</a>.</p>
<p>This concludes the theoretical portion of this topic. In the following section, you will put this into practice with an exercise.</p>
<h2 id="_idParaDest-344"><a id="_idTextAnchor391"/>Exercise 9.03: Performing File Operations by Calling Azure Blob Storage</h2>
<p>A common task with a Web API is to perform a variety of operations on files, such as download, upload, or delete. In this exercise, you will reuse a portion of <code>FilesClient</code> from <em class="italic">Activity 8.04</em> of <em class="italic">Chapter 8</em>, <em class="italic">Building Quality Object-Oriented Code</em>, to serve as a baseline client for calling Azure Blob storage and call its methods via REST endpoints to do the following operations on a file:</p>
<ul>
<li>Download a file.</li>
<li>Get a shareable link with expiration time.</li>
<li>Upload a file.</li>
<li>Delete a file.</li>
</ul>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Extract an interface for <code>FilesClient</code> and call it <code>IFilesService</code>:<pre>public interface IFilesService
    {
        Task Delete(string name);
        Task Upload(string name, Stream content);
        Task&lt;byte[]&gt; Download(string filename);
        Uri GetDownloadLink(string filename);
    }</pre></li>
</ol>
<p>The new interface is simplified as you will work on a single container. However, as per the requirements, you have added a few new methods: <code>Delete</code>, <code>Upload</code>, <code>Download</code>, and <code>GetDownloadLink</code>. The <code>Download</code> method is for downloading a file in its raw form—that is, bytes.</p>
<ol>
<li value="2">Create a new class called <code>Exercises/Exercise03/FilesService.cs</code>.</li>
<li>Copy the following parts of <a href="https://packt.link/XC9qG%20">https://packt.link/XC9qG </a>there.</li>
<li>Rename <code>Client</code> to <code>Service</code>.</li>
<li>Also change the <code>Exercise04</code> reference (used in <em class="italic">Chapter 8</em>, <em class="italic">Building Quality Object-Oriented Code</em>) to <code>Exercise03</code> (a new one to be used for this chapter):<pre>FilesService.cs
public class FilesService : IFilesService
    {
        private readonly BlobServiceClient _blobServiceClient;
        private readonly BlobContainerClient _defaultContainerClient;
        public FilesClient()
        {
            var endpoint = "https://packtstorage2.blob.core.windows.net/";
            var account = "packtstorage2";
            var key = Environment.GetEnvironmentVariable("BlobStorageKey", EnvironmentVariableTarget.User);
            var storageEndpoint = new Uri(endpoint);
            var storageCredentials = new StorageSharedKeyCredential(account, key);
            _blobServiceClient = new BlobServiceClient(storageEndpoint, storageCredentials);
            _defaultContainerClient = CreateContainerIfNotExists("Exercise03).Result;
        }
        private async Task&lt;BlobContainerClient&gt; CreateContainerIfNotExists(string container)</pre></li>
</ol>
<pre>You can find the complete code here: <a href="https://packt.link/fNQAX">https://packt.link/fNQAX</a>.</pre>
<p>The constructor initializes <code>blobServiceClient</code> to get <code>blobClient</code>, which allows you to do operations in the <em class="italic">Exercice03</em> directory in the Azure Blob Storage Account. If the folder doesn't exist, <code>blobServiceClient</code> will create it for you:</p>
<pre>        {
            var lowerCaseContainer = container.ToLower();
            var containerClient = _blobServiceClient.GetBlobContainerClient(lowerCaseContainer);
            if (!await containerClient.ExistsAsync())
            {
                containerClient = await _blobServiceClient.CreateBlobContainerAsync(lowerCaseContainer);
            }
            return containerClient;
        }</pre>
<p class="callout-heading">Note</p>
<p class="callout">For the preceding step to work, you will need an Azure Storage Account. So, refer to <em class="italic">Activity 8.04</em> of <em class="italic">Chapter 8</em>, <em class="italic">Building Quality Object-Oriented Code</em>.</p>
<ol>
<li value="6">Create the <code>ValidateFileExists</code> method to validate whether a file exists in the storage, else throw an exception (a small helper method that did not exist before):<pre>private static void ValidateFileExists(BlobClient blobClient)
{
    if (!blobClient.Exists())
    {
        throw new FileNotFoundException($"File {blobClient.Name} in default blob storage not found.");
    }
}</pre></li>
<li>Now, create the <code>Delete</code> method to delete a file:<pre>public Task Delete(string name)
{
    var blobClient = _defaultContainerClient.GetBlobClient(name);
    ValidateFileExists(blobClient);
    return blobClient.DeleteAsync();
}</pre></li>
</ol>
<p>Here, you will first get a client for the file and then check whether the file exists. If not, then you will throw a <code>FileNotFoundException</code> exception. If the file exists, then you will delete the file.</p>
<ol>
<li value="8">Create the <code>UploadFile</code> method to upload a file:<pre>public Task UploadFile(string name, Stream content)
{
    var blobClient = _defaultContainerClient.GetBlobClient(name);
    return blobClient.UploadAsync(content, headers);
}</pre></li>
</ol>
<p>Once again, you first get a client that allows you to perform operations on a file. Then, feed the content and headers to it to upload.</p>
<ol>
<li value="9">Create the <code>Download</code> method to download a file in bytes:<pre>        public async Task&lt;byte[]&gt; Download(string filename)
        {
            var blobClient = _defaultContainerClient.GetBlobClient(filename);
            var stream = new MemoryStream();
            await blobClient.DownloadToAsync(stream);
            return stream.ToArray();
        }</pre></li>
</ol>
<p>This method creates a memory stream and downloads the file to it. Please note that this is not going to work on large files.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you would like to learn more on how to process large files, please refer to <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming">https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming</a>.</p>
<p>There is a way to present raw downloaded bytes as an image or JSON, rather than as generic downloadable content. With an HTTP request or response, you can send a header specifying the way the content should be interpreted. This header is called Content-Type. Each application will process this differently. In the context of Swagger, <code>image/png</code> will be displayed as an image, while <code>application/json</code> will be shown as JSON.</p>
<ol>
<li value="10">Create a <code>GetUri</code> method to get a URI of <code>blobClient</code>:<pre>        private Uri GetUri(BlobClient blobClient)
        {
            var sasBuilder = new BlobSasBuilder
            {
                BlobContainerName = _defaultContainerClient.Name,
                BlobName = blobClient.Name,
                Resource = "b",
                ExpiresOn = DateTimeOffset.UtcNow.AddHours(1)
            };
            sasBuilder.SetPermissions(BlobSasPermissions.Read);
            var sasUri = blobClient.GenerateSasUri(sasBuilder);
            return sasUri;
        }</pre></li>
</ol>
<p>Getting a URI requires the use of <code>BlobSasBuilder</code>, through which you can generate a shareable URL to a blob. Through the builder, specify the kind of resource you are trying to share (<code>"b"</code> stands for blob) and the expiry time. You need to set the permissions (to read) and pass the <code>sasBuilder</code> builder to the <code>blobClient</code> client to generate <code>sasUri</code>.</p>
<ol>
<li value="11">Now, use a filename to create a file download link:<pre>        public Uri GetDownloadLink(string filename)
        {
            var blobClient = _defaultContainerClient.GetBlobClient(filename);
            var url = GetUri(blobClient);
            return url;
        }</pre></li>
<li>Inside the <code>ExceptionMappingSetup</code> class and the <code>AddExceptionMappings</code> method, add the following mapping:<pre>opt.MapToStatusCode&lt;FileNotFoundException&gt;(404);</pre></li>
<li>Create an extension method to inject a module of <code>FileUploadService</code>:<pre>public static class FileUploadServiceSetup
{
    public static IServiceCollection AddFileUploadService(this IServiceCollection services)
    {
        services.AddScoped&lt;IFilesService, FilesService&gt;();
        return services;
    }
}</pre></li>
</ol>
<p>An extension method is a simplified way of showing a new method to an existing interface.</p>
<ol>
<li value="14">Append it to <code>services</code> in <code>Program.cs</code> to use the <code>FileUploadService</code> module:<pre>.AddFileUploadService();</pre></li>
<li>Now, create a controller for files:<pre>    [Route("api/[controller]")]
    [ApiController]
    public class FileController : ControllerBase
    {</pre></li>
</ol>
<p>Controller creation is standard on MVC architecture, and this allows users to access <code>FileService</code> through HTTP requests.</p>
<ol>
<li value="16">Then, inject <code>IFilesService</code> to provide an interface through which file-related functionality could be accessed:<pre>        private readonly IFilesService _filesService;
        public FileController(IFilesService filesService)
        {
            _filesService = filesService;
        }</pre></li>
<li>Next, create an endpoint to delete a file:<pre>        [HttpDelete("{file}")]
        public async Task&lt;IActionResult&gt; Delete(string file)
        {
            await _filesService.Delete(file);
            return Ok();
        }</pre></li>
<li>Create an endpoint to download a file:<pre>  [HttpGet("Download/{file}")]
        public async Task&lt;IActionResult&gt; Download(string file)
        {
            var content = await _filesService.Download(file);
            return new FileContentResult(content, "application/octet-stream ");
        }</pre></li>
<li>Create an endpoint for getting a shareable file download link:<pre>        [HttpGet("Link")]
        public IActionResult GetDownloadLink(string file)
        {
            var link = _filesService.GetDownloadLink(file);
            return Ok(link);
        }</pre></li>
<li>Create an endpoint for uploading a file:<pre>        [HttpPost("upload")]
        public async Task&lt;IActionResult&gt; Upload(IFormFile file)
        {
            await _filesService.UploadFile(file.FileName, file.OpenReadStream());
            return Ok();
        }</pre></li>
</ol>
<p><code>IFormFile</code> is a common way of passing small files to a controller. However, from <code>IFormFile</code>, you need file contents as a stream. You can get this using the <code>OpenReadStream</code> method. Swagger allows you to use the File Explorer window to choose the file you want to upload.</p>
<ol>
<li value="21">Now you run the API.</li>
</ol>
<p>Your Swagger documentation will have a new section with the controller methods. Here are the responses of each:</p>
<ul>
<li>Upload file request:</li>
</ul>
<div><div><img alt="Figure 9.27: Upload file request in Swagger " height="769" src="img/B16835_09_27.jpg" width="1275"/>
</div>
</div>
<p class="figure-caption">Figure 9.27: Upload file request in Swagger</p>
<ul>
<li>Upload file response:</li>
</ul>
<div><div><img alt="Figure 9.28: Upload file response in Swagger " height="298" src="img/B16835_09_28.jpg" width="1015"/>
</div>
</div>
<p class="figure-caption">Figure 9.28: Upload file response in Swagger</p>
<ul>
<li>Get download link request:</li>
</ul>
<div><div><img alt="Figure 9.29: Get download link request in Swagger " height="564" src="img/B16835_09_29.jpg" width="1084"/>
</div>
</div>
<p class="figure-caption">Figure 9.29: Get download link request in Swagger</p>
<ul>
<li>Get download link response:</li>
</ul>
<div><div><img alt="Figure 9.30: Get download link response in Swagger " height="501" src="img/B16835_09_30.jpg" width="1023"/>
</div>
</div>
<p class="figure-caption">Figure 9.30: Get download link response in Swagger</p>
<ul>
<li>Download file request:</li>
</ul>
<div><div><img alt="Figure 9.31: Download file request in Swagger " height="542" src="img/B16835_09_31.jpg" width="1072"/>
</div>
</div>
<p class="figure-caption">Figure 9.31: Download file request in Swagger</p>
<ul>
<li>Download file response:</li>
</ul>
<div><div><img alt="Figure 9.32: Download file response in Swagger " height="404" src="img/B16835_09_32.jpg" width="1013"/>
</div>
</div>
<p class="figure-caption">Figure 9.32: Download file response in Swagger</p>
<ul>
<li>Delete file request:</li>
</ul>
<div><div><img alt="Figure 9.33: Delete file request in Swagger " height="551" src="img/B16835_09_33.jpg" width="1065"/>
</div>
</div>
<p class="figure-caption">Figure 9.33: Delete file request in Swagger</p>
<ul>
<li>Delete file response:</li>
</ul>
<div><div><img alt="Figure 9.34: Delete file response in Swagger " height="300" src="img/B16835_09_34.jpg" width="1006"/>
</div>
</div>
<p class="figure-caption">Figure 9.34: Delete file response in Swagger</p>
<p>This exercise illustrated the remaining aspects of what you can do with a Web API.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/cTa4a">https://packt.link/cTa4a</a>.</p>
<p>The volume of functionality you can serve through the web is immense. However, this comes with its own big problem. How do you ensure that your API is consumed only by the intended identities? In the next section, you will explore how to secure a Web API.</p>
<h2 id="_idParaDest-345"><a id="_idTextAnchor392"/>Securing a Web API</h2>
<p>Every now and then, you'll hear about a major security breach on the news. In this section, you will learn how to protect a public API using AAD.</p>
<h3 id="_idParaDest-346"><a id="_idTextAnchor393"/>Azure Active Directory</h3>
<p>Azure Active Directory (AAD) is Microsoft's cloud identity and access management service that is used to sign in to well-known applications, such as Visual Studio, Office 365, and Azure, and to internal resources. AAD uses OpenID to provide user identity through a JavaScript Web Token.</p>
<h3 id="_idParaDest-347"><a id="_idTextAnchor394"/>JWT</h3>
<p>A JavaScript Web Token (JWT) is a collection of personal data encoded and sent over as a mechanism of authentication. A single field encoded in a JWT is called a claim.</p>
<h3 id="_idParaDest-348"><a id="_idTextAnchor395"/>OpenID Connect</h3>
<p>OpenID Connect (OIDC) is the protocol used for getting the ID token, which provides user identity or an access token. It's a layer on top of OAuth 2 to get an identity.</p>
<p>OAuth serves as a means of getting an access token on behalf of some user. With OIDC, you get an identity; this has a role and access comes from that role. When a user wants to log in to a website, OpenID might require them to input their credentials. This might sound exactly the same as OAuth; however, don't mix the two. OpenID is all about acquiring and verifying the user's identity and granting access coming with a role. OAuth, on the other hand, gives access to a user to do a limited set of functionalities.</p>
<p>A real-life analogy would be as follows:</p>
<ul>
<li>OpenID: You come to an airport and present your passport (which is issued by the government) confirming your role (passenger) and identity that way. You are <strong class="bold">granted</strong> a <strong class="bold">passenger</strong> role and allowed to board an airplane.</li>
<li>OAuth: You come to an airport and the staff asks you to take part in an emotional state tracking event. With your <strong class="bold">consent</strong>, the staff (<strong class="bold">others</strong>) at the airport can now track more of your personal data.</li>
</ul>
<p>The following is a summary:</p>
<ul>
<li>OpenID provides authentication and <strong class="bold">verifies who you are</strong>.</li>
<li>OAuth is authorization that allows others to do <strong class="bold">things on your behalf</strong>.</li>
</ul>
<h2 id="_idParaDest-349"><a id="_idTextAnchor396"/>Application Registration</h2>
<p>The first step in securing a Web API using Azure is to create an application registration in AAD. Perform the following steps to do so:</p>
<ol>
<li value="1">Navigate to <code>Azure Active Directory</code> by typing <code>active dir</code> in the search bar:</li>
</ol>
<div><div><img alt="Figure 9.35: Azure Active Directory being searched in portal.azure " height="795" src="img/B16835_09_35.jpg" width="1299"/>
</div>
</div>
<p class="figure-caption">Figure 9.35: Azure Active Directory being searched in portal.azure</p>
<ol>
<li value="2">In the new window, click the <code>App registrations</code> option (<code>1</code>).</li>
<li>Then, click the <code>New registration</code> button (<code>2</code>):</li>
</ol>
<div><div><img alt="Figure 9.36: Azure app registration " height="452" src="img/B16835_09_36.jpg" width="1515"/>
</div>
</div>
<p class="figure-caption">Figure 9.36: Azure app registration</p>
<ol>
<li value="4">In the new window, enter <code>Chapter09WebApi</code> as the name.</li>
<li>Keep the other settings as the default and click the <code>Register</code> button:</li>
</ol>
<div><div><img alt="Figure 9.37: The new app registration named Chapter09WebApi " height="740" src="img/B16835_09_37.jpg" width="913"/>
</div>
</div>
<p class="figure-caption">Figure 9.37: The new app registration named Chapter09WebApi</p>
<ol>
<li value="6">To access an API, you need at least one scope or role. In this example, you will create a scope called <code>access_as_user</code>.</li>
<li>Scopes in general can be used to control which part of an API is accessible to you. For the scope to be available for all users, you will need to select <code>Admins and users</code>.</li>
<li>In this trivial example, given the token is valid, you will allow access to everything. So, select the <code>Access all as a user</code> option. The exact values of the other fields do not matter:</li>
</ol>
<div><div><img alt="Figure 9.38: The access_as_user scope available for all users " height="723" src="img/B16835_09_38.jpg" width="789"/>
</div>
</div>
<p class="figure-caption">Figure 9.38: The access_as_user scope available for all users</p>
<p>The first step in securing a Web API using Azure was to create an application registration in AAD. The next topic will cover how you can implement security within a Web API in .NET.</p>
<h2 id="_idParaDest-350"><a id="_idTextAnchor397"/>Implementing Web API Security</h2>
<p>This section will focus on the details of how, programmatically, you can get the token and work with it. So, first, install NuGet, which does JWT validation using the Microsoft identity platform:</p>
<pre>dotnet add package Microsoft.Identity.Web</pre>
<p>In the Bootstrap folder, create the <code>SecuritySetup</code> class:</p>
<pre>    public static class SecuritySetup
    {
        public static IServiceCollection AddSecurity(this IServiceCollection services, IConfiguration configuration, IWebHostEnvironment env)
        {
            services.AddMicrosoftIdentityWebApiAuthentication(configuration);
            return services;
        }
    }</pre>
<p>Then, in <code>Program.cs</code>, append this to <code>services</code>:</p>
<pre>.AddSecurity()</pre>
<p>The injected services are needed by the authorization middleware. So, add the following on an <code>app</code> to add authorization middleware:</p>
<pre>    app.UseAuthentication();
    app.UseAuthorization();</pre>
<p>This will be triggered on all endpoints decorated with the <code>[Authorize]</code> attribute. Make sure the preceding two lines are placed before <code>app.MapControllers();</code> or else the middleware will not be wired with your controllers.</p>
<p>Within <code>appsettings.json</code>, add the following configuration to link to your <code>AzureAd</code> security configuration:</p>
<pre>  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "ClientId": "2d8834d3-6a27-47c9-84f1-0c9db3eeb4ba",
    "TenantId": "ddd0fd18-f056-4b33-88cc-088c47b81f3e",
    "Audience": "api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"
  }</pre>
<p>Lastly, add the <code>Authorize</code> attribute above each controller for any kind of security you choose:</p>
<pre>    [Authorize]
    [ApiController]
    [RequiredScope("access_as_user")]
    [Route("[controller]")]
    public class WeatherForecastController : ControllerBase</pre>
<p>The <code>Authorize</code> attribute is essential for any type of security implementation. This attribute will perform the generic token validation, while <code>[RequiredScope("access_as_user")]</code> will check whether the <code>access_as_user</code> scope was included or not. What you now have is a secured API. If you try calling the <code>WeatherForecast</code> endpoints, you will get a <code>401 – Unauthorised</code> error.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ruj9o">https://packt.link/ruj9o</a>.</p>
<p>In the next section, you will learn how to generate a token through the token generator app and use it to securely access your API.</p>
<h3 id="_idParaDest-351"><a id="_idTextAnchor398"/>Token Generator App</h3>
<p>To call the API, you need to generate a token by creating a console application. Before you do that, however, you need to configure one more thing in your app registration. Your console application is considered a desktop app. So, when signing in, you need a redirect URI. This URI, returned with the code, is used to get the access token. To achieve this, perform the following steps:</p>
<ol>
<li value="1">From the left pane in AAD, select the <code>Authentication</code> option (<code>1</code>) to view all configurations with outside applications.</li>
<li>Next, click the <code>Add a platform</code> button (<code>2</code>) to configure a new application (token generator):</li>
</ol>
<div><div><img alt="Figure 9.39: Authentication window with options to configure a new application " height="515" src="img/B16835_09_39.jpg" width="1552"/>
</div>
</div>
<p class="figure-caption">Figure 9.39: Authentication window with options to configure a new application</p>
<ol>
<li value="3">In the <code>Configure platforms</code> section, select the <code>Mobile and desktop applications</code> button (<code>3</code>) to register a console application token generator:</li>
</ol>
<div><div><img alt="Figure 9.40: Selecting the Mobile and desktop applications platform for authentication " height="686" src="img/B16835_09_40.jpg" width="1163"/>
</div>
</div>
<p class="figure-caption">Figure 9.40: Selecting the Mobile and desktop applications platform for authentication</p>
<p>A new window will open on the screen.</p>
<ol>
<li value="4">Type your <code>Custom redirect URIs</code> that specify where you will return after the successful login to AAD when requesting the token. In this case, it doesn't matter so much. So, type any URL.</li>
<li>Then, click the <code>Configure</code> button (<code>4</code>):</li>
</ol>
<div><div><img alt="Figure 9.41: Configuring the redirect URI " height="486" src="img/B16835_09_41.jpg" width="1173"/>
</div>
</div>
<p class="figure-caption">Figure 9.41: Configuring the redirect URI</p>
<p>That completes the configuration of AAD. Now that you have all the infrastructure for security, build a console application to generate an access token from AAD:</p>
<ol>
<li value="1">First, create a new project called <code>Chapter09.TokenGenerator</code>. It will allow you to generate authorization tokens needed to call your API.</li>
<li>Then, make it a console app on .NET Core to keep it simple and display a generated token.</li>
<li>Add <code>Microsoft.Identity.Client</code> by running the following command:<pre>dotnet add package Microsoft.Identity.Client</pre></li>
</ol>
<p>This will allow you to request a token later.</p>
<ol>
<li value="4">Next, in <code>Program.cs</code>, create a method to initialize an AAD application client. This will be used to prompt browser login, as if you were to log in to the Azure portal:<pre>static IPublicClientApplication BuildAadClientApplication()
{
    const string clientId = "2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"; // Service
    const string tenantId = "ddd0fd18-f056-4b33-88cc-088c47b81f3e";
    const string redirectUri = "http://localhost:7022/token";
    string authority = string.Concat("https://login.microsoftonline.com/", tenantId);
    var application = PublicClientApplicationBuilder.Create(clientId)
        .WithAuthority(authority)
        .WithRedirectUri(redirectUri)
        .Build();
    return application;
}</pre><p class="callout-heading">Note</p><p class="callout">The values used in the preceding code will differ, depending upon the AAD subscription.</p></li>
</ol>
<p>As you can see, the application uses the <code>clientId</code> and <code>tenantId</code> configured in AAD.</p>
<ol>
<li value="5">Create another method to use the application that requires a user login on Azure to get an auth token:<pre>static async Task&lt;string&gt; GetTokenUsingAzurePortalAuth(IPublicClientApplication application)
{</pre></li>
<li>Now, define the scopes you need:<pre>            var scopes = new[] { $"api://{clientId}/{scope}" };</pre></li>
</ol>
<p>Replace <code>api://{clientId}/{scope}</code> with your own application ID URI if you are not using a default value.</p>
<ol>
<li value="7">Then, attempt to get a cached token:<pre>            AuthenticationResult result;
            try
            {
                var accounts = await application.GetAccountsAsync();
                result = await application.AcquireTokenSilent(scopes, accounts.FirstOrDefault()).ExecuteAsync();
            }</pre></li>
</ol>
<p>The cached token retrieval is required if the login was done earlier. If you haven't signed in before to get a token, you will need to log in to Azure AD:</p>
<pre>            catch (MsalUiRequiredException ex)
            {
                result = await application.AcquireTokenInteractive(scopes)
                    .WithClaims(ex.Claims)
                    .ExecuteAsync();
            }</pre>
<ol>
<li value="8">Return the access token as the result of a logged-in user so that you can use it later to access your APIs:<pre>            return result.AccessToken;</pre></li>
<li>Now, call the two methods and print the result (using the minimal API):<pre>var application = BuildAadClientApplication();
var token = await GetTokenUsingAzurePortalAuth(application);
Console.WriteLine($"Bearer {token}");</pre></li>
<li>Finally, when you run the token app, it will ask you to sign in:</li>
</ol>
<div><div><img alt="Figure 9.42: Sign-in request from Azure " height="685" src="img/B16835_09_42.jpg" width="1166"/>
</div>
</div>
<p class="figure-caption">Figure 9.42: Sign-in request from Azure</p>
<p>A successful sign-in redirects you to a configured redirect URI with the following message:</p>
<pre>Authentication complete. You can return to the application. Feel free to close this browser tab.</pre>
<p>You will see that the token will be returned in the console window:</p>
<div><div><img alt="Figure 9.43: Generated token from the app registration in the console app " height="475" src="img/B16835_09_43.jpg" width="1591"/>
</div>
</div>
<p class="figure-caption">Figure 9.43: Generated token from the app registration in the console app</p>
<p>Now, you can inspect the token using the <a href="https://jwt.io/">https://jwt.io/</a> website. The following screen is displayed, showing two parts: <code>Encoded</code> and <code>Decoded</code>. The <code>Decoded</code> part is divided into the following sections:</p>
<ul>
<li><code>HEADER</code>: This contains a type of token and the algorithm used to encrypt the token.</li>
<li><code>PAYLOAD</code>: The claims encoded within the token contain information, such as who requested the token and what access has been granted:</li>
</ul>
<p> </p>
<div><div><img alt="Figure 9.44: Encoded and decoded JWT version on the jwt.io website  using your app registration " height="658" src="img/B16835_09_44.jpg" width="1157"/>
</div>
</div>
<p class="figure-caption">Figure 9.44: Encoded and decoded JWT version on the jwt.io website using your app registration</p>
<p>In this section, you learned how to secure an unsecured API. Security is not limited to just an authorization token. As a professional developer, you must be aware of the most common vulnerabilities in APIs. A list of the top 10 most common security issues is updated every four years based on the trends in the industry. This list is called the Open Web Application Security Project (OWASP) and can be reached at <a href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a>.</p>
<p>In the next section, you will apply the changes needed for Swagger to work with the authorization token.</p>
<h3 id="_idParaDest-352"><a id="_idTextAnchor399"/>Configuring Swagger Auth</h3>
<p>To pass an authorization header through Swagger, you will need to add some configuration. Follow these steps to do so:</p>
<ol>
<li value="1">In order to render an authorization button, add the following block of code inside the <code>SwaggerSetup</code> class, the <code>AddSwagger</code> method, and the <code>services.AddSwaggerGen(cfg =&gt;</code> section:<pre>                cfg.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme()
                {
                    Name = "Authorization",
                    Type = SecuritySchemeType.ApiKey,
                    Scheme = "Bearer",
                    BearerFormat = "JWT",
                    In = ParameterLocation.Header,
                    Description = $"Example: \"Bearer YOUR_TOKEN&gt;\"",
                });</pre></li>
<li>In order to forward the value of a bearer token with an authorization header, add the following code snippet:<pre>                cfg.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id = "Bearer"
                            }
                        },
                        new string[] {}
                    }
                });</pre></li>
<li>When you navigate to <a href="https://localhost:7021/index.xhtml">https://localhost:7021/index.xhtml</a>, you will see that it now contains the <code>Authorize</code> button:</li>
</ol>
<p> </p>
<div><div><img alt="Figure 9.45: Swagger docs with Authorize button " height="363" src="img/B16835_09_45.jpg" width="897"/>
</div>
</div>
<p class="figure-caption">Figure 9.45: Swagger docs with Authorize button</p>
<ol>
<li value="4">Click the <code>Authorize</code> button to allow you to input the bearer token:</li>
</ol>
<p> </p>
<div><div><img alt="Figure 9.46: Bearer token input after clicking the Authorize button " height="511" src="img/B16835_09_46.jpg" width="1096"/>
</div>
</div>
<p class="figure-caption">Figure 9.46: Bearer token input after clicking the Authorize button</p>
<ol>
<li value="5">Now, send a request:</li>
</ol>
<p> </p>
<div><div><img alt="Figure 9.47: Swagger-generated request with a status of 200 generated in response " height="840" src="img/B16835_09_47.jpg" width="895"/>
</div>
</div>
<p class="figure-caption">Figure 9.47: Swagger-generated request with a status of 200 generated in response</p>
<p>You will see that the authorization header is added, and the <code>ok</code> response (HTTP status code <code>200</code>) is returned.</p>
<p>In this section, you added some configuration to pass an authorization header through Swagger.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/hMc2t">https://packt.link/hMc2t</a>.</p>
<p>If you make a mistake and your token validation fails, you will get either a <code>401 – unauthorized</code> or <code>403 – forbidden</code> status code returned (often without any details). Fixing this error might be a headache. However, it is not too difficult to get more information on what went wrong. The next section provides more details.</p>
<h3 id="_idParaDest-353"><a id="_idTextAnchor400"/>Troubleshooting Token Validation Errors</h3>
<p>To simulate this scenario, try invalidating the client-id in <code>appsettings.json</code> by changing any single symbol (for example, the last letter to <code>b</code>). Run the request and see how the response is displayed as <code>401</code>, with nothing else appearing in the logs.</p>
<p>All the validations and incoming and outcoming requests can be tracked through a pipeline. All you must do is change the default minimum logged level from <code>info</code> to <code>Trace</code>. You can do this by replacing the <code>appsettings.development.json</code> file contents with the following:</p>
<pre>{
  "Logging": {
    "LogLevel": {
      "Default": "Trace",
      "Microsoft": "Trace",
      "Microsoft.Hosting.Lifetime": "Trace"
    }
  }
}</pre>
<p>Do not mix <code>appsettings.development.json</code> with <code>appsettings.json</code>. The former is used for configuration as a whole and the latter overrides the configuration but only in certain environments—development (local) in this case.</p>
<p>If you run the same request again, you will now see a verbose log in the console:</p>
<pre>Audience validation failed. Audiences: 'api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb'. Did not match: validationParameters.ValidAudience: 'api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bc' or validationParameters.ValidAudiences: 'null'.</pre>
<p>Inspecting it deeper reveals the error as the following:</p>
<p><code>Audience validation failed; Audiences: 'api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb'. Did not match validationParameters</code></p>
<p>This error indicates a mismatched audience configured in the JWT:</p>
<div><div><img alt="Figure 9.48: Token validation error with the error highlighted " height="892" src="img/B16835_09_48.jpg" width="1194"/>
</div>
</div>
<p class="figure-caption">Figure 9.48: Token validation error with the error highlighted</p>
<p>Now it is time for you to learn about the SOA architecture where components of a system are hosted as separate services.</p>
<h2 id="_idParaDest-354"><a id="_idTextAnchor401"/>Service-Oriented Architecture</h2>
<p>Software architecture has come a long way—evolving from monolithic to Service-Oriented Architecture (SOA). SOA is an architecture where major layers of applications are hosted as separate services. For example, there would be one or more Web APIs for data access, one or more Web APIs for business logic, and one or more client applications consuming it all. The flow would be like this: the client app calls the business Web API, which calls another business Web API or a data access Web API.</p>
<p>However, modern software architecture goes one step further to bring a more evolved architecture, called microservice architecture.</p>
<h3 id="_idParaDest-355"><a id="_idTextAnchor402"/>Microservice Architecture</h3>
<p>Microservice architecture is SOA with a single-responsibility principle applied. This means that, instead of service-as-a-layer, you now have hosted self-contained modules that have a single responsibility. A self-contained service has both data access and business logic layers. Instead of many services per layer, in this approach, you have many services per module.</p>
<p>The purpose of those self-contained modules is to allow multiple teams to work on different parts of the same system simultaneously without ever stepping on each other's toes. On top of that, parts in a system can be scaled and hosted independently and there is no single point of failure. Also, each team is free to use whatever technology stack they are most familiar with, as all the communication happens through HTTP calls.</p>
<p>This concludes the theoretical portion of this topic. In the following section, you will put all that you have learned into practice with an activity.</p>
<h2 id="_idParaDest-356"><a id="_idTextAnchor403"/>Activity 9.01: Implementing the File Upload Service Using Microservice Architecture</h2>
<p>A microservice should be self-contained and do just one thing. In this activity, you will sum up the steps needed for extracting a piece of code into a microservice that manages how you work with files through the web (delete, upload, and download). This should serve as an overall effective checklist of what needs to be done when creating a new microservice.</p>
<p>Perform the following steps to do this:</p>
<ol>
<li value="1">Create a new project. In this case, it will be a <code>.NET Core Web API</code> project on the .NET 6.0 framework.</li>
<li>Name it <code>Chapter09.Activity.9.01</code>.</li>
<li>Now, add the commonly used NuGet packages:<ul><li><code>AutoMapper.Extensions.Microsoft.DependencyInjection</code></li>
<li><code>FluentValidation.AspNetCore</code></li>
<li><code>Hellang.Middleware.ProblemDetails</code></li>
<li><code>Microsoft.AspNetCore.Mvc.NewtonsoftJson</code></li>
<li><code>Microsoft.Identity.Web</code></li>
<li><code>Swashbuckle.AspNetCore</code></li>
</ul></li>
<li>Next, include the Azure Blobs Client package as <code>Azure.Storage.Blobs</code>.</li>
<li>Create one or more controllers for communication with the Web API. In this case, you will move <code>FileController</code> to the <code>Controllers</code> folder.</li>
<li>In order to create one or more services for business logic, move <code>FilesService</code> to the <code>Services</code> folder and <code>FileServiceSetup</code> to the <code>Bootstrap</code> folder.</li>
<li>Then document API using XML docs and Swagger.</li>
<li>Update the <code>csproj</code> file to include XML docs.</li>
<li>Copy <code>SwaggerSetup</code> to the <code>Bootstrap</code> folder.</li>
<li>Configure <code>Controllers</code>. In this scenario, it will be a plain one-line <code>services.AddControllers()</code> under the <code>ControllersConfigurationSetup</code> class and the <code>AddControllersConfiguration</code> method.</li>
<li>Configure the problem details error mappings. In this case, there are no exceptions that you will explicitly handle. So, you will keep it as a one-liner within the <code>ExceptionMappingSetup</code> class and the <code>AddExceptionMappings</code> and <code>services.AddProblemDetails()</code> methods.</li>
<li>Secure the API.</li>
<li>Create AAD app registration for the new service. Refer to the <em class="italic">Application Registration</em> subsection in the <em class="italic">Securing the Web API</em> section.</li>
<li>Update the configuration of the new service based on the Azure AD app registration client, <code>tenant</code>, and <code>app</code> IDs.</li>
<li>Inject the needed services and configure the API pipeline.</li>
<li>Copy the <code>Program</code> class.</li>
<li>Since the <code>ConfigureServices</code> method contains extra services, you don't need to remove them. Leave the <code>Configure</code> method as is.</li>
<li>Run the service through Swagger and upload a test file. Don't forget to generate a bearer token first using the token generator app from the updated values learned earlier.</li>
<li>After that, try to get a test file that you just uploaded. You should see the status code <code>200</code>:<ul><li>Get download link request:</li>
</ul></li>
</ol>
<div><div><img alt="Figure 9.49: Get download link request in Swagger " height="351" src="img/B16835_09_49.jpg" width="675"/>
</div>
</div>
<p class="figure-caption">Figure 9.49: Get download link request in Swagger</p>
<ul>
<li>Get download link response:</li>
</ul>
<div><div><img alt="Figure 9.50: Get download link response in Swagger " height="331" src="img/B16835_09_50.jpg" width="676"/>
</div>
</div>
<p class="figure-caption">Figure 9.50: Get download link response in Swagger</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>All the services that have been created so far require considerations such as hosting, scaling, and availability. In the following section, you will learn about serverless and Azure Functions.</p>
<h2 id="_idParaDest-357"><a id="_idTextAnchor404"/>Azure Functions</h2>
<p>In the preceding section, you learned that microservice architecture is a self-contained service with both data access and business logic layers. With this approach, you have many services per module. However, working with microservices, especially at the start, might seem like a hassle. It might raise doubts such as the following:</p>
<ul>
<li>What does not big enough mean?</li>
<li>Should you host on different servers or on the same machine?</li>
<li>Is another cloud hosting model better?</li>
</ul>
<p>These questions might be overwhelming. So, a simple way of calling your code through HTTP is by using Azure Functions. Azure Functions is a serverless solution that allows you to call your functions on the cloud. Serverless does not mean that there is no server; you just do not need to manage it by yourself. In this section, you will try to port <code>CurrentTimeController</code> from <em class="italic">Exercise 9.02</em> to an Azure Function.</p>
<p class="callout-heading">Note</p>
<p class="callout">Before proceeding with the steps, install Azure Functions Core Tools first using the instructions here: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools">https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools</a>. Azure Functions Core Tools also requires the Azure CLI to be installed (if you want to publish an Azure Functions application and not on a server). Follow the instructions here: <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli</a>.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">In VS Code, click the <code>Extenstions</code> icon (<code>1</code>).</li>
<li>Then search for <code>azure function</code> in the search text box (<code>2</code>).</li>
<li>Then, install the <code>Azure Functions</code> extension (<code>3</code>):</li>
</ol>
<div><div><img alt="Figure 9.51: Searching for the Azure Functions extension in VS Code " height="607" src="img/B16835_09_51.jpg" width="1176"/>
</div>
</div>
<p class="figure-caption">Figure 9.51: Searching for the Azure Functions extension in VS Code</p>
<p>A new Azure tab will appear on the left.</p>
<ol>
<li value="4">Click the new Azure tab.</li>
<li>On the new page, click the <code>Add</code> button (<code>1</code>).</li>
<li>Select the <code>Create Function…</code> option (<code>2</code>):</li>
</ol>
<div><div><img alt="Figure 9.52: The new Azure Functions extension in VS Code  with the Create Function… button " height="273" src="img/B16835_09_52.jpg" width="976"/>
</div>
</div>
<p class="figure-caption">Figure 9.52: The new Azure Functions extension in VS Code with the Create Function… button</p>
<ol>
<li value="7">In the Create Function window, select <code>HTTP trigger</code>.</li>
<li>Enter the name <code>GetCurrentTime.Get</code>.</li>
<li> Name the project where it is held <code>Pact.AzFunction</code>.</li>
<li>On the last screen, select <code>anonymous</code>.</li>
</ol>
<p>At this point, there is no need to go into too much detail about this configuration. The key point to be considered here is that the function will be reachable publicly, through HTTP requests. A new project created through these steps will include the new Azure Function.</p>
<ol>
<li value="11">Now, navigate to the root of the new project folder to run the project.</li>
<li>Next, press <code>F5</code> or click the <code>Start debugging to update this list…</code> message:</li>
</ol>
<div><div><img alt="Figure 9.53: Azure Extension window with the to-be-built project " height="193" src="img/B16835_09_53.jpg" width="1132"/>
</div>
</div>
<p class="figure-caption">Figure 9.53: Azure Extension window with the to-be-built project</p>
<p>You will notice that upon a successful build, the message changes to the function name:</p>
<div><div><img alt="Figure 9.54: Azure Extension window with post-build project " height="185" src="img/B16835_09_54.jpg" width="1134"/>
</div>
</div>
<p class="figure-caption">Figure 9.54: Azure Extension window with post-build project</p>
<p>The terminal output window, displayed at the bottom of VS Code, shows the following details:</p>
<div><div><img alt="Figure 9.55: The terminal output after a successful build " height="509" src="img/B16835_09_55.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 9.55: The terminal output after a successful build</p>
<ol>
<li value="13">Next, in VS Code Explorer, open <code>GetCurrentTime.cs</code>:</li>
<li>Note that in <em class="italic">Exercise 9.01</em>, you worked with the <code>GetCurrentTime</code> code. You will reuse the same code here:<pre>namespace Pact.Function
{
    public static class GetCurrentTime
    {
        [Function("GetCurrentTime")]
        public static HttpResponseData Run([HttpTrigger(AuthorizationLevel.Anonymous, "get", "post")] HttpRequestData request,
            FunctionContext executionContext)</pre></li>
</ol>
<p>The template names are generated based on your configuration from before. An Azure Function is bound to an HTTP endpoint through the <code>[Function("GetCurrentTime")]</code> attribute.</p>
<p>Before you proceed, you might have noticed that, even though the function for getting the current time consumed a variable for <code>timezoneid</code>, there is no such variable here (yet). Unlike the previous REST APIs you created to pass parameters to an Azure Function, here you pass it through either a request body or query variables. The only problem here is that you will have to parse it yourself, as there are no bindings through attributes just like with the controller methods. The argument you need is just a simple string that can be passed as a query argument. This line parses the URI from the request and gets a <code>timezoneId</code> variable from the query string.</p>
<ol>
<li value="15">Use the <code>timezoneId</code> variable to get the current time in a specific zone:<pre>        {
            var timezoneId = HttpUtility.ParseQueryString(request.Url.Query).Get("timezoneId");</pre></li>
<li>Next up is the business logic. So, use the <code>timezoneId</code> variable to get the current time in a specified time zone:<pre>var timezoneInfo = TimeZoneInfo.FindSystemTimeZoneById(timezoneId);
            var time = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, timezoneInfo);</pre></li>
<li>Finally, serialize the results in <code>HTTP 200 Ok</code> as the <code>text/plain</code> content type:<pre>var response = request.CreateResponse(HttpStatusCode.OK);
            response.Headers.Add("Content-Type", "text/plain; charset=utf-8");
            response.WriteString(time.ToString());
            return response;
}</pre></li>
<li>Run this code and navigate to <code>http://localhost:7071/api/GetCurrentTime?timezoneId=Central%20European%20Standard%20Time</code>.</li>
</ol>
<p>You will get the current time of that time zone, as follows:</p>
<pre>2022-08-07 16:02:03</pre>
<p>You have now grasped the workings of Azure Functions—a serverless solution to call your functions on the cloud.</p>
<p>It has been a long path through this book, but with the conclusion of this final activity, you have mastered all the concepts and skills required to create your own modern C# applications.</p>
<h1 id="_idParaDest-358"><a id="_idTextAnchor405"/>Summary</h1>
<p>In this chapter, you learned how to build your own REST Web API using the ASP.NET Core Web API template. You learned how to tackle the ever-growing complexity of configuration using bootstrap classes. You were introduced to the OpenAPI standard and Swagger, a tool used for calling an API to see whether it has successfully rendered the documentation. You also delved into mapping exceptions to specific HTTP status codes, along with how to map DTOs to domain objects and vice versa. In the second half of the chapter, you practiced securing the Web API using AAD, learned the concept of microservices, and created one yourself—both through a new dedicated Web API and through an Azure Function.</p>
<p>Knowing how to create and consume Web APIs is important because that's what most of the software development is all about. You either consume or create Web APIs at some point. Even if you don't have to create one yourself, grasping the ins and outs of it will help you as a professional developer.</p>
<p>This brings a close to <em class="italic">The C# Workshop</em>. Throughout this book, you have learned the basics of programming in C#, starting with simple programs that used arithmetic and logical operators, followed by the increasingly complex concepts of clean coding, delegates and lambdas, multithreading, client and server Web APIs, and Razor Pages applications.</p>
<p>This concludes the print copy of this book, but it is not the end of your journey. Visit the GitHub repository at <a href="https://packt.link/sezEm">https://packt.link/sezEm</a> for bonus chapters—<em class="italic">Chapter 10</em>, <em class="italic">Automated Testing</em>, and <em class="italic">Chapter 11</em>, <em class="italic">Production-Ready C#: From Development to Deployment</em>—covering such topics as different forms of testing before you take an in-depth look at unit testing using Nunit (the most popular third-party testing library for C#), getting acquainted with Git and using GitHub to keep a remote backup of your code, enabling Continuous Deployment (CD) and deployment from your code to the cloud, studying the cloud using Microsoft Azure, in addition to learning how to use GitHub Actions to perform CI and CD to push application changes live in production.</p>
</div>
</div>


<div><div><div></div>
</div>
<div><div><div><img alt="Rayon" height="187" src="img/Jason_Hales.png" width="244"/>
</div>
<div><p class="Paragraph-Style-1"><strong class="bold">Jason Hales</strong></p>
</div>
</div>
</div>
<div><div><div><img alt="Rayon" height="187" src="img/Almantas_Karpavicius.png" width="244"/>
</div>
<div><p class="Paragraph-Style-1"><strong class="bold">Almantas Karpavicius</strong></p>
</div>
</div>
</div>
<div><div><div><img alt="Rayon" height="187" src="img/Mateus_Viegas.png" width="244"/>
</div>
<div><p class="Paragraph-Style-1"><strong class="bold">Mateus Viegas</strong></p>
</div>
</div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><h2 id="_idParaDest-359"><a id="_idTextAnchor406"/>Hey!</h2>
<p>We are Jason Hales, Almantas Karpavicius, and Mateus Viegas the authors of this book. We really hope you enjoyed reading our book and found it useful for learning C#.</p>
<p>It would really help us (and other potential readers!) if you could leave a review on Amazon sharing your thoughts on <em class="italic">The C# Workshop</em>.</p>
<p>Go to the link <a href="https://packt.link/r/1800566492">https://packt.link/r/1800566492</a>.</p>
<p>OR</p>
<p>Scan the QR code to leave your review.</p>
<div><div><img alt="Barcode" height="150" src="img/qrcode.jpg" width="516"/>
</div>
</div>
<p>Your review will help us to understand what's worked well in this book and what could be improved upon for future editions, so it really is appreciated.</p>
<p>Best wishes,</p>
<p>Jason Hales, Almantas Karpavicius, and Mateus Viegas</p>
</div>
<div><div><img alt="Packt Logo" height="55" src="img/Packt_Logo-1.png" width="218"/>
</div>
</div>
</div>
</body></html>