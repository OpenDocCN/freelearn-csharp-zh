<html><head></head><body>
		<div><h1 id="_idParaDest-14" class="chapter-number"><a id="_idTextAnchor013"/>1</h1>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Getting Started with Functional Programming</h1>
			<p>Functional programming<a id="_idIndexMarker000"/> is a way of thinking about software based on treating computation as the evaluation of mathematical functions. It avoids changing state and mutable data, focusing instead on pure functions, immutability, and composing functions to solve complex problems. By sticking to these principles, functional programming creates code that is more predictable, easier to understand, and less prone to bugs.</p>
			<p>But why should you consider adopting functional programming in your projects? The benefits<a id="_idIndexMarker001"/> are many, including the following:</p>
			<ul>
				<li><strong class="bold">Increased readability and maintainability</strong>: Functional code is often more concise and expressive, making it easier to read and maintain. By focusing on what needs to be done rather than how to do it, functional programming promotes clearer and more readable code.</li>
				<li><strong class="bold">Enhanced testability</strong>: Pure functions always produce the same output for a given input and have no side effects, making them easier to test. This leads to more comprehensive and reliable unit testing, resulting in higher code quality and fewer bugs.</li>
				<li><strong class="bold">Improved concurrency and parallelism</strong>: The emphasis on immutability and avoiding shared state in functional programming makes it well suited for concurrent and parallel processing. It reduces the risks associated with race conditions and allows safer and more efficient use of multi-core processors.</li>
				<li><strong class="bold">Reusability and composability</strong>: Functional programming encourages the creation of small, focused functions that can be easily combined and reused throughout the code base. This promotes code reuse, modularity, and the ability to build <a id="_idIndexMarker002"/>complex systems from simple building blocks.</li>
			</ul>
			<p>As we progress through this book, we’ll explore these benefits in greater detail, making it more compelling to use functional programming in your projects.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Functional versus imperative versus object-oriented programming</h1>
			<p>To fully appreciate the power of functional programming, it’s essential to understand how it differs from other paradigms, such as imperative and object-oriented programming.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Imperative programming</h2>
			<p>Imperative programming<a id="_idIndexMarker003"/> is the traditional approach in many languages. It focuses on explicitly specifying the sequence of steps to solve a problem. This style relies heavily on mutable state and side effects, which can make code more prone to bugs and harder to understand as the code base grows.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Object-oriented programming</h2>
			<p><strong class="bold">Object-oriented programming</strong> (<strong class="bold">OOP</strong>) organizes<a id="_idIndexMarker004"/> code around objects, which encapsulate data and behavior. OOP is great for modeling real-world entities and promoting encapsulation. However, it can sometimes lead to complex hierarchies and tight coupling between objects, making code harder to modify and test.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Functional programming</h2>
			<p>Functional programming, in <a id="_idIndexMarker005"/>contrast, emphasizes pure functions and immutable data. It treats computation as the evaluation of expressions rather than a sequence of state changes. By minimizing side effects and focusing on the input-output relationship of functions, functional programming enables more declarative and composable code.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Blending paradigms</h2>
			<p>It’s important to note that these paradigms are not mutually exclusive. Modern programming languages such as C# support a mix of imperative, object-oriented, and functional programming styles. The key is to understand the strengths and weaknesses of each paradigm and apply them wisely based on the problem at hand.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>How functional programming is supported in C#</h1>
			<p>C# has evolved significantly over the years, incorporating a range of functional programming features that make it a powerful language for this paradigm. Let’s take a closer look at some of these features and how they support functional programming:</p>
			<ul>
				<li><strong class="bold">Lambda expressions</strong>: These<a id="_idIndexMarker006"/> provide a <a id="_idIndexMarker007"/>concise syntax for creating anonymous functions, enabling easy creation of higher-order functions</li>
				<li><strong class="bold">LINQ</strong>: This <a id="_idIndexMarker008"/>provides a set of extension methods<a id="_idIndexMarker009"/> that enable functional-style operations such as filtering, mapping, and reducing collections</li>
				<li><strong class="bold">Immutable data types</strong>: Data <a id="_idIndexMarker010"/>types such as<a id="_idIndexMarker011"/> strings and tuples guarantee that once created, their values cannot be changed</li>
				<li><strong class="bold">Pattern matching</strong>: This<a id="_idIndexMarker012"/> allows us to test<a id="_idIndexMarker013"/> values against patterns and extract data based on those patterns</li>
				<li><strong class="bold">Delegates and events</strong>: These<a id="_idIndexMarker014"/> allow you<a id="_idIndexMarker015"/> to treat functions as first-class citizens, passing them as<a id="_idIndexMarker016"/> arguments and storing them in variables</li>
			</ul>
			<p>Throughout this book, we’ll explore how to utilize these features to write code in a functional approach. Let’s look at what I mean by a functional approach next.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>How to write functional code in C#</h1>
			<p>Writing functional code in C# means the implementation of functional concepts and techniques that will help us write functional code:</p>
			<ul>
				<li><strong class="bold">Expressions</strong>: By <a id="_idIndexMarker017"/>favoring expressions<a id="_idIndexMarker018"/> over statements, we can write more declarative code that focuses on the desired result rather than the steps to achieve it.</li>
				<li><strong class="bold">Pure functions</strong>: A pure function<a id="_idIndexMarker019"/> always produces the same output for a<a id="_idIndexMarker020"/> given input and has no side effects. It relies solely on its input parameters and does not modify any external state. Using pure functions, we can create easier code to reason about, test, and parallelize.</li>
				<li><strong class="bold">Honest functions</strong>: Honest functions<a id="_idIndexMarker021"/> are an extension of pure functions that<a id="_idIndexMarker022"/> provide a clear and unambiguous contract. They explicitly communicate their input requirements and potential output scenarios, including error cases. Honest functions enhance code readability, maintainability, and error handling.</li>
				<li><strong class="bold">Higher-order functions</strong>: These <a id="_idIndexMarker023"/>functions can accept other functions as arguments <a id="_idIndexMarker024"/>or return functions as results. They enable powerful abstractions and allow you to create reusable and composable code.</li>
				<li><strong class="bold">Functors and monads</strong>: Functors<a id="_idIndexMarker025"/> and monads<a id="_idIndexMarker026"/> are abstractions that help you manage and compose computations in a functional<a id="_idIndexMarker027"/> way. A functor<a id="_idIndexMarker028"/> is a type that defines a mapping operation, allowing you to apply a function to the values inside the functor while preserving its structure. Monads, on the other hand, provide a way to chain computations together, handling complexities such as error propagation and state management.</li>
			</ul>
			<p>Don’t worry if any of these concepts and techniques are not familiar to you. Throughout this book, we’ll explore them in detail and use practical coding examples to help you understand how to use them in your code.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>A practical example – a book publishing system</h1>
			<p>Let’s examine an example<a id="_idIndexMarker029"/> that demonstrates functional programming concepts using a book publishing system scenario:</p>
			<pre class="source-code">
public record Book(string Title, string Author, int Year, string Content);
// Pure function to validate a book
private static bool IsValid(Book book) =&gt;
     !string.IsNullOrEmpty(book.Title) &amp;&amp;
     !string.IsNullOrEmpty(book.Author) &amp;&amp;
     book.Year &gt; 1900 &amp;&amp;
     !string.IsNullOrEmpty(book.Content);
// Pure function to format a book
private static string FormatBook(Book book) =&gt;
     $"{book.Title} by {book.Author} ({book.Year})";
// Higher-order function for processing books
private static IEnumerable&lt;T&gt; ProcessBooks&lt;R&gt;(
     IEnumerable&lt;Book&gt; books,
     Func&lt;Book, bool&gt; validator,
     Func&lt;Book, T&gt; formatter) =&gt;
     books.Where(validator).Select(formatter);
public static void Main()
{
    var books = new List&lt;Book&gt;
         {
              new Book("The Great Gatsby", "F. Scott Fitzgerald", 1925, "In my younger and more vulnerable years..."),
              new Book("To Kill a Mockingbird", "Harper Lee", 1960, "When he was nearly thirteen, my brother Jem..."),
              new Book("Invalid Book", "", 1800, ""),
              new Book("1984", "George Orwell", 1949, "It was a bright cold day in April, and the clocks were striking thirteen.")
         };
    // Using our higher-order function to process books
    var formattedBooks = ProcessBooks(books, IsValid, FormatBook);
    Console.WriteLine("Processed books:");
    foreach (var book in formattedBooks)
    {
         Console.WriteLine(book);
    }
}</pre>			<p>This example <a id="_idIndexMarker030"/>demonstrates several key functional programming concepts:</p>
			<ul>
				<li><code>record</code> for the <code>Book</code> type, which is<a id="_idIndexMarker031"/> immutable by default.</li>
				<li><code>IsValid</code> and <code>FormatBook</code> are pure functions. They always return the same<a id="_idIndexMarker032"/> output for the same input and have no side effects.</li>
				<li><code>ProcessBooks</code> is a higher-order function that takes two functions as<a id="_idIndexMarker033"/> parameters (a validator and a formatter).</li>
				<li><code>ProcessBooks</code> function.</li>
				<li><strong class="bold">Declarative style</strong>: We<a id="_idIndexMarker035"/> describe what we want (valid, formatted books) rather than how to do it step by step.</li>
				<li><code>Where</code> and <code>Select</code>) that align well with functional programming principles.</li>
			</ul>
			<p>This example shows how functional programming can be applied to a real-world scenario such as a book publishing system.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>How to combine functional and object-oriented paradigms</h1>
			<p>One of the strengths of C# is its ability to seamlessly combine functional and object-oriented programming paradigms. By leveraging the best of both worlds, we can create code that is modular, reusable, and expressive. Here are some strategies for combining functional and object-oriented programming:</p>
			<ul>
				<li><strong class="bold">Immutable objects</strong>: Immutable <a id="_idIndexMarker037"/>objects are thread-safe, easier to reason about, and align well with functional programming principles</li>
				<li><strong class="bold">Extension methods</strong>: These <a id="_idIndexMarker038"/>allow us to enhance the functionality of types without modifying their original implementation, promoting a more functional and compositional approach</li>
				<li><strong class="bold">Higher-order functions as instance methods</strong>: This approach helps us to encapsulate<a id="_idIndexMarker039"/> behavior and provide a fluent and expressive API for working with objects in a functional manner</li>
				<li><strong class="bold">Dependency injection and composition</strong>: By injecting functional dependencies<a id="_idIndexMarker040"/> and composing objects based on their behavior, you can achieve a more modular and flexible design that aligns with functional programming principles</li>
			</ul>
			<p>These tools help us combine functional and object-oriented programming techniques, making our code more expressive and easier to maintain.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Meet Steve and Julia</h1>
			<p>To make our journey through functional programming in C# more engaging and relatable, let’s introduce our main characters: Steve and Julia.</p>
			<p>Steve is a middle-level C# software developer who has heard that functional programming can help him write better code, become more valuable at his current job, and gain an advantage over other candidates if he decides to pursue a new opportunity. He’s eager to learn but unsure where to start.</p>
			<p>Julia, on the other hand, is already an expert in functional programming in C#. She’s passionate about the paradigm and enjoys sharing her knowledge with others. Throughout the book, Julia will provide Steve with advice, guidance, and practical examples to help him master functional programming concepts.</p>
			<p>As we progress through the chapters, we’ll follow Steve’s journey as he learns from Julia and applies functional programming techniques to real-world scenarios.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Summary</h1>
			<p>Congratulations on taking the first step toward mastering functional programming in C#! In this chapter, we’ve explored the differences between functional, imperative, and object-oriented programming paradigms. We’ve also delved into the functional features of C#, such as lambda expressions, LINQ, immutable data types, pattern matching, and delegates, and how they support functional programming.</p>
			<p>Furthermore, we’ve introduced the concepts and techniques for writing functional code in C# such as expressions, pure functions, honest functions, higher-order functions, functors, and monads. Finally, we’ve discussed strategies for combining functional and object-oriented programming in C#, allowing us to leverage the best of both paradigms in our projects.</p>
			<p>As we progress through the next chapters, we’ll dive deeper into each of these concepts, learning how to write cleaner, more modular, and more testable code using functional principles.</p>
			<p>Let’s get started!</p>
		</div>
	</body></html>