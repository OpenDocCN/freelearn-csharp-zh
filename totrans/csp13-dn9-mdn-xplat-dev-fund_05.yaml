- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Your Own Types with Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about making your own types using **object-oriented programming**
    (**OOP**). You will learn about all the different categories of members that a
    *type* can have, including fields to store data and methods to perform actions.
    You will use OOP concepts such as aggregation and encapsulation. You will also
    learn about language features such as tuple syntax support, `out` variables, inferred
    tuple names, and default literals. Finally, you will learn about pattern matching
    and defining records to make the equality of variables and immutability easier
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Talking about OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building class libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data in fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with methods and tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling access with properties and indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with record types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talking about OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object in the real world is a thing, such as a car or a person, whereas an
    object in programming often represents something in the real world, such as a
    product or bank account, but it can also be something more abstract.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, we use the C# keywords `class`, `record`, and `struct` to define a type
    of object. You will learn about `struct` types in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*. You can think of a type as being a blueprint or template
    for an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts of OOP are briefly described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** is the combination of the data and actions that are related
    to an object. For example, a `BankAccount` type might have data, such as `Balance`
    and `AccountName`, as well as actions, such as `Deposit` and `Withdraw`. When
    encapsulating, you often want to control what can access those actions and the
    data, for example, restricting how the internal state of an object can be accessed
    or modified from the outside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition** is about what an object is made of. For example, a `Car` is
    composed of different parts, such as four `Wheel` objects, several `Seat` objects,
    and an `Engine`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation** is about what can be combined with an object. For example,
    a `Person` is not part of a `Car` object, but they could sit in the driver’s `Seat`
    and then become the car’s `Driver`—two separate objects that are aggregated together
    to form a new component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance** is about reusing code by having a **subclass** derive from
    a **base** or **superclass**. All functionality in the base class is inherited
    by, and becomes available in, the **derived** class. For example, the base or
    super `Exception` class has some members that have the same implementation across
    all exceptions, and the sub or derived `SqlException` class inherits those members
    and has extra members that are only relevant when a SQL database exception occurs,
    like a property for the database connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction** is about capturing the core idea of an object and ignoring
    the details or specifics. C# has the `abstract` keyword that formalizes this concept
    but do not confuse the concept of abstraction with the use of the `abstract` keyword
    because it is more than that. The concept of abstraction can also be achieved
    using interfaces. If a class is not explicitly **abstract**, then it can be described
    as being **concrete**. Bases or superclasses are often abstract; for example,
    the superclass `Stream` is abstract, and its subclasses, like `FileStream` and
    `MemoryStream`, are concrete. Only concrete classes can be used to create objects;
    abstract classes can only be used as the base for other classes because they are
    missing some implementation. Abstraction is a tricky balance. If you make a class
    more abstract, more classes will be able to inherit from it, but at the same time,
    there will be less functionality to share. A real-world example of abstraction
    is the approach car manufacturers have taken to **electric vehicles** (**EVs**).
    They create a common “platform” (basically just the battery and wheels) that is
    an abstraction of what all EVs need, and then add on top of that to build different
    vehicles like cars, trucks, vans, and so on. The platform on its own is not a
    complete product, like an abstract class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism** is about allowing a derived class to override an inherited
    action to provide custom behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot to cover in the next two chapters about OOP, and some parts of
    it are difficult to learn. At the end of *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*, I have written a summary of the categories of custom
    types and their capabilities with example code. This will help you review the
    most important facts and highlight the differences between choices, like an `abstract`
    class or an `interface`, and when to use them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Building class libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Class library** assemblies group types together into easily deployable units
    (DLL files). Apart from when you learned about unit testing, you have only created
    console apps to contain your code. To make the code that you write reusable across
    multiple projects, you should put it in class library assemblies, just like Microsoft
    does.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first task is to create a reusable .NET class library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PacktLibraryNet2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter05`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the `PacktLibraryNet2.csproj` file, and note that, by default, class libraries
    created by the .NET 9 SDK target .NET 9 and, therefore, can only be referenced
    by other .NET 9-compatible assemblies, as highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the framework to target .NET Standard 2.0, add an entry to explicitly
    use the C# 13 compiler, and statically import the `System.Console` class for all
    C# files, as highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although we can use the C# 13 compiler, some modern compiler features require
    a modern .NET runtime. For example, we cannot use default implementations in an
    interface (introduced in C# 8) because it requires .NET Standard 2.1\. We cannot
    use the `required` keyword (introduced in C# 11) because it requires an attribute
    introduced in .NET 7\. But many useful modern compiler features, like raw literal
    strings, will be available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Save and close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the file named `Class1.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the project so that other projects can reference it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Build** | **Build PacktLibraryNet2**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In VS Code, enter the following command: `dotnet build`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good practice**: To use all the latest C# language and .NET platform features,
    put types in a .NET 9 class library. To support legacy .NET platforms, like .NET
    Core, .NET Framework, and Xamarin, put types that you might reuse in a .NET Standard
    2.0 class library. By default, targeting .NET Standard 2.0 uses the C# 7 compiler,
    but this can be overridden so you get the benefits of the newer SDK and compiler
    even though you are limited to .NET Standard 2.0 APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding file-scoped namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, you define types like a class nested in a namespace, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you define multiple types in the same code file, then they can be in different
    namespaces, since the types must be explicitly inside the curly braces for each
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use C# 10 or later, you can simplify your code by ending a namespace
    declaration with a semicolon and removing the curly braces, so the type definitions
    do not need to be indented, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is known as a **file-scoped namespace** declaration. You can only have
    one file-scoped namespace per file. This feature is especially useful for book
    writers who have limited horizontal space.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Put each type that you create in its own code file, or at
    least put types in the same namespace in the same code file so that you can use
    file-scoped namespace declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class in a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next task is to define a class that will represent a person:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryNet2` project, add a new class file named `Person.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Person.cs`, delete any existing statements and set the namespace to `Packt.Shared`,
    and for the `Person` class, set the access modifier to `public`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: We’re doing this because it is important to put your classes
    in a logically named namespace. A better namespace name would be domain-specific,
    for example, `System.Numerics` for types related to advanced numbers. In this
    case, the types we will create are `Person`, `BankAccount`, and `WondersOfTheWorld`,
    and they do not have a typical domain, so we will use the more generic `Packt.Shared`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Understanding type access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that the C# keyword `public` is applied before `class`. This keyword is
    an **access modifier**, and it allows for any other code to access this class
    even outside this class library.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not explicitly apply the `public` keyword, then it will only be accessible
    within the assembly that defined it. This is because the implicit access modifier
    for a class is `internal`. We need this class to be accessible outside the assembly,
    so we must make sure it is `public`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have nested classes, meaning a class defined in another class, then the
    inner class could have the `private` access modifier, which would mean it is not
    accessible outside its parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced with .NET 7, the `file` access modifier applied to a type means that
    type can only be used within its code file. This would only be useful if you define
    multiple classes in the same code file, which is rarely good practice but is used
    with source generators.
  prefs: []
  type: TYPE_NORMAL
- en: '**More information**: You can learn more about the `file` access modifier at
    the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: The two most common access modifiers for a class are `public`
    and `internal` (the default access modifier for a class if not specified). Always
    explicitly specify the access modifier for a class to make it clear what it is.
    Other access modifiers include `private` and `file`, but they are rarely used.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Person` type does not yet have any members encapsulated within it. We
    will create some over the following pages. Members can be fields, methods, or
    specialized versions of both. You’ll find a description of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fields** are used to store data. You can think of fields as variables that
    belong to a type. There are also three specialized categories of field, as shown
    in the following bullets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant**: The data never changes. The compiler literally copies the data
    into any code that reads it. For example, `byte.MaxValue` is always `255`. Constants
    must be set to a literal value. Literal values can only be a `string` surrounded
    by `""`, a `char` surrounded with single quotes, a Boolean like `true` or `false`,
    or a number like `3`, `3L`, `3.0`, `3.0F`, or `3.0M`. Non-literal values are not
    supported, so you cannot have a constant date/time value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-only**: The data cannot change after the class is instantiated, but
    the data can be calculated or loaded from an external source at the time of instantiation.
    For example, `String.Empty` is `""`, `Guid.Empty` is a **GUID** (**globally unique
    identifier**) with all zeros, `TimeSpan.Zero` is a time interval of zero, `DateTime.MinValue`
    is `00:00:00.0000000 UTC, January 1, 0001` in the Gregorian calendar, and `Path.DirectorySeparatorChar`
    is `\` on Windows.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTime.UnixEpoch` is `00:00:00.0000000 UTC, January 1, 1970,` in the Gregorian
    calendar but this field was introduced after .NET Standard 2.0, so you won’t be
    able to try it in your current class library.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Event**: The data references one or more methods that you want to execute
    when something happens, such as clicking on a button or responding to a request
    from some other code. Events will be covered in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*. For example, `Console.CancelKeyPress` happens when *Ctrl*
    + *C* or *Ctrl* + *Break* are pressed in a console app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods** are used to execute statements. You saw some examples when you
    learned about functions in *Chapter 4*, *Writing, Debugging, and Testing Functions*.
    There are also four specialized categories of methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor**: The statements execute when you use the `new` keyword to allocate
    memory to instantiate a class. For example, to instantiate Christmas Day, 2023,
    you could write the following code: `new DateTime(2023, 12, 25)`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property**: The statements execute when you get or set data. The data is
    commonly stored in a field but can be stored externally or calculated at runtime.
    Properties are the preferred way to encapsulate fields unless the memory address
    of the field needs to be exposed; for example, `Console.ForegroundColor` to set
    the current color of text in a console app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexer**: The statements execute when you get or set data using “array”
    syntax `[]`. For example, use `name[0]` to get the first character in the `name`
    variable, which is a `string`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator**: The statements execute when you apply an operator like `+` and
    `/` to operands of your type. For example, use `a + b` to add two variables together.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a namespace to use a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will make an instance of the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can instantiate a class, we need to reference the assembly that contains
    it from another project. We will use the class in a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` named
    `PeopleApp` to the `Chapter05` solution. Make sure you *add* the new project to
    the existing `Chapter05` solution because you are about to reference from the
    console app project to the existing class library project so both projects must
    be in the same solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you use Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the startup project for the solution to the current selection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Solution Explorer**, select the `PeopleApp` project, navigate to **Project**
    | **Add Project Reference…**, check the box to select the `PacktLibraryNet2` project,
    and then click **OK**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `PeopleApp.csproj`, add an entry to statically import the `System.Console`
    class, as shown in the following markup:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to **Build** | **Build PeopleApp**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you use VS Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `PeopleApp.csproj` to add a project reference to `PacktLibraryNet2`, and
    add an entry to statically import the `System.Console` class, as highlighted in
    the following markup:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In a terminal, compile the `PeopleApp` project and its dependency `PacktLibraryNet2`
    project, as shown in the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In the `PeopleApp` project, add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, delete any existing statements, and define a `partial
    Program` class with a method to configure the console to enable special symbols,
    like the euro currency, and to control the current culture, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By the end of this chapter, you will understand how the preceding method uses
    C# features like partial classes, optional parameters, and so on. If you would
    like to learn more about working with languages and cultures, as well as dates,
    times, and time zones, then there is a chapter about globalization and localization
    in my companion book, *Apps and Services with .NET 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are ready to write statements to instantiate the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PeopleApp` project, in the `Program.cs` file, delete the existing statements,
    then add statements to import the namespace for our `Person` class, and then call
    the `ConfigureConsole` method without any arguments so that it sets the current
    culture to US English, allowing all readers to see the same output, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although we could import the `Packt.Shared` namespace globally, it will be clearer
    to anyone reading this code where we import the types we use from if the `import`
    statement is at the top of the file, and the `PeopleApp` project will only have
    this one `Program.cs` file that needs the namespace imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Person` type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Output the instance using a textual description of itself.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `new` keyword allocates memory for the object and initializes any internal
    data, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might be wondering, “Why does the `bob` variable have a method named `ToString`?
    The `Person` class is empty!” Don’t worry, we’re about to find out!
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from System.Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although our `Person` class did not explicitly choose to inherit from a type,
    all types ultimately inherit directly or indirectly from a special type named
    `System.Object`. The implementation of the `ToString` method in the `System.Object`
    type outputs the full namespace and type name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the original `Person` class, we could have explicitly told the compiler
    that `Person` inherits from the `System.Object` type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When class B is inherited from class A, we say that A is the base or superclass,
    and B is the derived or subclass. In this case, `System.Object` is the base or
    superclass, and `Person` is the derived or subclass. You can also use the C# keyword
    `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make our class explicitly inherit from `object` and then review what
    members all objects have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `Person` class to explicitly inherit from `object`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click inside the `object` keyword and press *F12*, or right-click on the `object`
    keyword and choose **Go to Definition**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the Microsoft-defined `System.Object` type and its members. This
    is something you don’t need to understand the details of yet, but note that the
    class is in a .NET Standard 2.0 class library assembly, as shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The System.Object class definition in .NET Standard 2.0'
  prefs: []
  type: TYPE_NORMAL
- en: If you scroll down the class code file, note that the `Object` class has a method
    named `ToString`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Assume other programmers know that if inheritance is not
    specified, the class will inherit from `System.Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding a namespace conflict with a using alias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to learn a bit more about namespaces and their types. It is possible
    that there are two namespaces that contain the same type name, and importing both
    namespaces causes ambiguity. For example, `JsonOptions` exists in multiple Microsoft-defined
    namespaces. If you use the wrong one to configure JSON serialization, then it
    will be ignored and you’ll be confused as to why!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review a made-up example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we build this project, then the compiler would complain with the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define an alias for one of the namespaces to differentiate it, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Renaming a type with a using alias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another situation where you might want to use an alias is if you would like
    to rename a type. For example, if you use the `Environment` class in the `System`
    namespace a lot, you could rename it with an alias to make it shorter, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Starting with C# 12, you can alias any type. This means you can rename existing
    types or give a type name to unnamed types like tuples, as you will see later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn how to refactor your code using alias any type at the following
    link: [https://devblogs.microsoft.com/dotnet/refactor-your-code-using-alias-any-type/](https://devblogs.microsoft.com/dotnet/refactor-your-code-using-alias-any-type/).'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will define a selection of fields in the class to store
    information about a person.
  prefs: []
  type: TYPE_NORMAL
- en: Defining fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that we have decided that a person is composed of a name and a date
    and time of birth. We will encapsulate these two values inside a person, and the
    values will be visible outside it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Person` class, write statements to declare two public fields to
    store a person’s name and the date of when they were born, as highlighted in the
    following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have multiple choices for the data type of the `Born` field. .NET 6 introduced
    the `DateOnly` type. This would store only the date without a time value. `DateTime`
    stores the date and time when the person was born, but it varies between local
    and **Universal Coordinated Time** (**UTC**). The best choice is `DateTimeOffset`,
    which stores the date, time, and hours offset from **UTC**, which is related to
    the time zone. The choice depends on how much detail you need to store.
  prefs: []
  type: TYPE_NORMAL
- en: Types for fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since C# 8, the compiler has had the ability to warn you if a reference type,
    like a `string`, could have a `null` value and, therefore, potentially throw a
    `NullReferenceException`. Since .NET 6, the SDK enables those warnings by default.
    You can suffix the `string` type with a question mark, `?`, to indicate that you
    accept this, and the warning disappears. You will learn more about nullability
    and how to handle it in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: You can use any type for a field, including arrays and collections, such as
    lists and dictionaries. These would be used if you needed to store multiple values
    in one named field. In this example, a person only has one name and one date and
    time of birth.
  prefs: []
  type: TYPE_NORMAL
- en: Member access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of encapsulation is choosing how visible members are to other code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, as we did with the class, we explicitly applied the `public` keyword
    to these fields. If we hadn’t, then they would be implicitly `private` to the
    class, which means they are accessible only inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four **member access modifier** keywords, and two combinations of
    access modifier keywords that you can apply to a class member, like a field or
    method. Member access modifiers apply to an individual member. They are similar
    to but separate from type access modifiers that apply to the whole type. The six
    possible combinations are shown in *Table 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member Access Modifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `private` | The member is accessible inside the type only. This is the default.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `internal` | The member is accessible inside the type and any type in the
    same assembly. |'
  prefs: []
  type: TYPE_TB
- en: '| `protected` | The member is accessible inside the type and any type that
    inherits from the type. |'
  prefs: []
  type: TYPE_TB
- en: '| `public` | The member is accessible everywhere. |'
  prefs: []
  type: TYPE_TB
- en: '| `internal protected` | The member is accessible inside the type, any type
    in the same assembly, and any type that inherits from the type. Equivalent to
    a fictional access modifier named `internal_or_protected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `private protected` | The member is accessible inside the type and any type
    that inherits from the type and is in the same assembly. Equivalent to a fictional
    access modifier named `internal_and_protected`. This combination is only available
    with C# 7.2 or later. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Six member access modifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Explicitly apply one of the access modifiers to all type
    members, even if you want to use the implicit access modifier for members, which
    is `private`. Additionally, fields should usually be `private` or `protected`,
    and you should then create `public` properties to get or set the field values.
    This is because the property then controls access. You will do this later in the
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting and outputting field values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will use those fields in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, after instantiating `bob`, add statements to set his name
    and date and time of birth, and then output those fields formatted nicely, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The format code for `arg1` is one of the standard date and time formats. `D`
    means a long date format and `d` would mean a short date format. You can learn
    more about standard date and time format codes at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you change the call to `ConfigureConsole` to use your local computer culture
    or a specified culture, like French in France (`"``fr-FR"`), then your output
    will look different.
  prefs: []
  type: TYPE_NORMAL
- en: Setting field values using object initializer syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also initialize fields using a shorthand **object initializer** syntax
    with curly braces, which was introduced with C# 3\. Let’s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements underneath the existing code to create another new person named
    Alice. Note the different standard format code for the date and time of birth
    when writing her to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could have used string interpolation to format the output, but for long strings,
    it will wrap over multiple lines, which can be harder to read in a printed book.
    In the code examples in this book, remember that `{0}` is a placeholder for `arg0`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Use named parameters to pass arguments, so it is clearer
    what the values mean, especially for types like `DateTimeOffset` where there are
    a bunch of numbers one after the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing a value using an enum type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, a value needs to be one of a limited set of options. For example,
    there are seven ancient wonders of the world, and a person may have one favorite.
  prefs: []
  type: TYPE_NORMAL
- en: At other times, a value needs to be a combination of a limited set of options.
    For example, a person may have a bucket list of ancient world wonders they want
    to visit. We can store this data by defining an `enum` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `enum` type is a very efficient way of storing one or more choices because,
    internally, it uses integer values in combination with a lookup table of `string`
    descriptions. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file to the `PacktLibraryNet2` project named `WondersOfTheAncientWorld.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `WondersOfTheAncientWorld.cs` contents, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, define a field to store a person’s favorite ancient world wonder,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, set Bob’s favorite ancient wonder of the world and output
    it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `enum` value is internally stored as an `int` for efficiency. The `int`
    values are automatically assigned, starting at `0`, so the third world wonder
    in our `enum` has a value of `2`. You can assign `int` values that are not listed
    in the `enum`. They will output as the `int` value instead of a name since a match
    will not be found.
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values using an enum type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the bucket list, we could create an array or collection of instances of
    the `enum`, and collections as fields will be shown later in this chapter, but
    there is a better approach for this scenario. We can combine multiple choices
    into a single value using `enum` flags. Let’s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `enum` by decorating it with the `[Flags]` attribute, and explicitly
    set a `byte` value for each wonder that represents different bit columns, as highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The integer types that an `enum` is allowed to inherit from are `Byte`, `SByte`,
    `Int16`, `Int32`, `Int64`, `UInt16`, `UInt32`, and `UInt64`. The new integer types
    `Int128` and `UInt128` are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: We assign explicit values for each choice that will not overlap when looking
    at the bits stored in memory. We should also decorate the `enum` type with the
    `System.Flags` attribute so that when the value is returned, it can automatically
    match with multiple values as a comma-separated `string` instead of returning
    an `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, an `enum` type uses an `int` variable internally, but since we don’t
    need values that big, we can reduce memory requirements by 75%, that is, 1 byte
    per value instead of 4 bytes, by telling it to use a `byte` variable. As another
    example, if you wanted to define an `enum` for days of the week, there will only
    ever be seven of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to indicate that our bucket list includes the *Hanging Gardens of
    Babylon* and the *Mausoleum at Halicarnassus* ancient world wonders, then we would
    want the `16` and `2` bits set to `1`. In other words, we would store the value
    `18`, as shown in *Table 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: Storing 18 as bits in an enum'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, leave the existing field to store a single favorite ancient
    world wonder and add the following statement to your list of fields to store multiple
    ancient world wonders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to set the bucket list using the `|` operator
    (the bitwise logical `OR`) to combine the `enum` values. We could also set the
    value using the number `18` cast into the `enum` type, as shown in the comment,
    but we shouldn’t because that would make the code harder to understand, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Use the `enum` values to store combinations of discrete
    options. Derive an `enum` type from `byte` if there are up to eight options, from
    `ushort` if there are up to 16 options, from `uint` if there are up to 32 options,
    and from `ulong` if there are up to 64 options.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have decorated the `enum` with the `[Flags]` attribute, combinations
    of values can be stored in a single variable or field. Now, a programmer could
    store a combination of values in the `FavoriteAncientWonder` too when it should
    only store one value. To enforce this, we should convert the field into a property
    that allows us to take control over how other programmers can get and set the
    value. You will see how to do this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Changing an enum base type for performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding section was about storing multiple values using an `enum` type.
    It’s about `enum` types decorated with the `[Flags]` attribute that use bitwise
    operations to efficiently store those multiple values. In the code example, we
    defined an `enum` for the Seven Wonders of the Ancient World, so it only needed
    seven combinable values (and `0` for `None`).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding section was not about making all your `enum` types derive from
    `byte` to make your code faster because that would be bad advice.
  prefs: []
  type: TYPE_NORMAL
- en: 'On March 18, 2024, Nick Chapsas posted a YouTube video titled, *Turn All Your
    Enums Into Bytes Now! | Code Cop #014*, which you can watch at the following link:
    [https://www.youtube.com/watch?v=1gWzE9SIGkQ](https://www.youtube.com/watch?v=1gWzE9SIGkQ).
    He criticized blog articles that recommend changing the default base integer type
    of `enum` types from `int` to `byte` to improve performance.'
  prefs: []
  type: TYPE_NORMAL
- en: The original designers of the C# language spent effort on implementing the ability
    for `enum` types to derive from other integers than just the default `int`. For
    example, you can use fewer bytes by using a positive integer like `byte` or `ushort`,
    or the same or more bytes by using a positive integer like `uint` or `ulong`.
    They implemented this feature because sometimes a .NET developer will need this
    capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think it is important that my readers know that they can do it when necessary.
    Microsoft’s official guidance states, “Even though you can change this underlying
    type, it is not necessary or recommended for most scenarios. No significant performance
    gain is achieved by using a data type that is smaller than `Int32`.”, as you can
    read at the following link: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1028](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1028).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For those developers who object to changing any `enum` from `int` to some other
    integer, there is a compiler code analysis warning that I linked to above. If
    enabled, it will trigger if you set an `enum` to anything other than `int`: “CA1028:
    Enum storage should be Int32.” This warning is not enabled by default because
    Microsoft knows that there are legitimate reasons why a developer might need to
    use it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some real-life examples of when you would need to change an `enum`
    from deriving from `int` to deriving from another integer type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to increase the size of the integer to store more than 16 options
    in a flag `enum`. The default `int` only allows 16 options: 0, 1, 2, 4, 8, 16,
    32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, and 16384\. Changing to `uint`
    would double the number of choices to 32 without using any more space in memory.
    Changing to `ulong` would give 64 options. Changing to `ushort` would allow the
    same 16 options in half the bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to transfer data as a binary stream via a serial connection to an embedded
    device and you must carefully follow the protocol, or you are defining your own
    serial messaging protocol, and you want to reduce the packet size to make the
    best use of your available bandwidth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have SQL tables with millions of records where some of the columns are
    `enum` values. Setting those columns to `tinyint` with a matching `enum` : `byte`
    property in the C# entity class can make indexes perform better by being smaller
    and reducing the number of page reads from disk. Some developers will work on
    systems that are 30 or more years old with spinning metal disks. Not everyone
    is deploying to a modern 64-bit OS with modern hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to reduce the size of a `struct` because it will be created 100,000
    times per second on resource-constrained hardware, or you have game code that
    is set to use `byte` and `short` because you have millions of them in contiguous
    arrays for the game’s data. You would gain a fair bit of performance doing this,
    especially from a cache point of view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s see how to store multiple values using collections.
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values using collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now add a field to store a person’s children. This is an example of aggregation
    because children are instances of a class that is related to the current person,
    but they are not part of the person itself. We will use a generic `List<T>` collection
    type that can store an ordered collection of any type. You will learn more about
    collections in *Chapter 8*, *Working with Common .NET Types*. For now, just follow
    along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, declare a new field to store multiple `Person` instances that
    represent the children of this person, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`List<Person>` is read aloud as “list of `Person`,” for example, “the type
    of the property named `Children` is a list of `Person` instances.”'
  prefs: []
  type: TYPE_NORMAL
- en: We must ensure the collection is initialized to a new instance before we can
    add items to it; otherwise, the field will be `null` and throw runtime exceptions
    when we try to use any of its members, like `Add`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generic collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The angle brackets in the `List<T>` type is a feature of C# called **generics**
    that was introduced in 2005 with C# 2\. It’s a fancy term for making a collection
    **strongly typed**, that is, the compiler knows specifically what type of object
    can be stored in the collection. Generics improve the performance and correctness
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strongly typed** has a different meaning than **statically typed**. The old
    `System.Collection` types are statically typed to contain weakly typed `System.Object`
    items. The newer `System.Collection.Generic` types are statically typed to contain
    strongly typed `<T>` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Ironically, the term *generics* means we can use a more specific static type!
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add three children for `Bob`, and then show
    how many children he has and what their names are, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could also use a `foreach` statement to enumerate over the collection. As
    an optional challenge, change the `for` statement to output the same information
    using `foreach`.
  prefs: []
  type: TYPE_NORMAL
- en: Making a field static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fields that we have created so far have all been **instance** members, meaning
    that a different value of each field exists for each instance of the class that
    is created. The `alice` and `bob` variables have different `Name` values.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you want to define a field that only has one value that is shared
    across all instances.
  prefs: []
  type: TYPE_NORMAL
- en: These are called **static members** because fields are not the only members
    that can be static. Let’s see what can be achieved using `static` fields using
    a bank account as an example. Each instance of `BankAccount` will have its own
    `AccountName` and `Balance` values, but all instances will share a single `InterestRate`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryNet2` project, add a new class file named `BankAccount.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class to give it three fields – two instance fields and one static
    field – as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to set the shared interest rate, and then create
    two instances of the `BankAccount` type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the additional output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that `C` is a format code that tells .NET to use the current culture’s
    currency format for the decimal numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Fields are not the only members that can be static. Constructors, methods, properties,
    and other members can also be static.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods do not need an object instance to be called. For example, `Console.WriteLine`
    does not need an object instance; the method is called directly from the class
    name. Static methods are covered in *Chapter 6, Implementing Interfaces and Inheriting
    Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Making a field constant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the value of a field will never change, you can use the `const` keyword
    and assign a literal value at compile time. Any statement that changes the value
    will cause a compile-time error. Let’s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add a `string` constant for the species of a person, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the value of a constant field, you must write the name of the class,
    not the name of an instance of the class. In `Program.cs`, add a statement to
    write Bob’s name and species to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Examples of `const` fields in Microsoft types include `System.Int32.MaxValue`
    and `System.Math.PI` because neither value will ever change, as you can see in
    *Figure 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Examples of constants in the System.Math class'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Constants are not always the best choice for two important
    reasons: the value must be known at compile time, and it must be expressible as
    a literal `string`, `Boolean`, or number value. Every reference to the `const`
    field is replaced with the literal value at compile time, which will, therefore,
    not be reflected if the value changes in a future version and you do not recompile
    any assemblies that reference it to get the new value.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a field read-only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, a better choice for fields that should not change is to mark them as
    read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add a statement to declare an instance read-only field to store
    a person’s home planet, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to write Bob’s name and home planet to the
    console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Use read-only fields over constant fields for two important
    reasons: the value can be calculated or loaded at runtime and can be expressed
    using any executable statement. So, a read-only field can be set using a constructor
    or a field assignment. Every reference to the read-only field is a live reference,
    so any future changes will be correctly reflected by the calling code.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare `static` `readonly` fields whose values will be shared
    across all instances of the type.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring fields to be set during instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# 11 introduced the `required` modifier. If you use it on a field or property,
    the compiler will ensure that you set the field or property to a value when you
    instantiate it. It requires targeting .NET 7 or later, so we need to create a
    new class library first:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chapter05` solution, add a new class library project named `PacktLibraryModern`
    that targets .NET 9\. (The oldest supported version for the `required` modifier
    is .NET 7.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project, rename `Class1.cs` to `Book.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the code file contents to give the class four fields, with two set as
    `required`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that all `three` string properties are nullable. Setting a property or
    field to be `required` does not mean that it cannot be `null`. It just means that
    it must be explicitly set to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PeopleApp` console app project, add a reference to the `PacktLibraryModern`
    class library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use Visual Studio, then in **Solution Explorer**, select the `PeopleApp`
    project, navigate to **Project** | **Add Project Reference…**, check the box to
    select the `PacktLibraryModern` project, and then click **OK**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you use VS Code, then edit `PeopleApp.csproj` to add a project reference
    to `PacktLibraryModern`, as highlighted in the following markup:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Build the `PeopleApp` project. This will compile its referenced dependencies
    and copy the class library `.dll` to the correct subdirectory in the local `bin`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PeopleApp` project, in `Program.cs`, attempt to instantiate a `Book`
    without setting the `Isbn` and `Title` fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that you will see a compiler error, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, modify the statement to set the two required properties using
    object initialization syntax, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the statement now compiles without errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to output information about the book, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we run the project and view the output, let’s talk about an alternative
    way that we could initialize fields (or properties) for a type.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing fields with constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fields often need to be initialized at runtime. You can do this in a constructor
    that will be called when you make an instance of a class using the `new` keyword.
    Constructors execute before any fields are set by the code that uses the type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements after the existing read-only `HomePlanet` field
    to define a second read-only field, and then set the `Name` and `Instantiated`
    fields in a constructor, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to instantiate a new person and then output
    its initial field values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result from both the code about the
    book as well as the blank person, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining multiple constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can have multiple constructors in a type. This is especially useful to
    encourage developers to set initial values for fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a second constructor that allows a
    developer to set initial values for the person’s name and home planet, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create another person using the constructor
    with two parameters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting required fields with a constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s return to the `Book` class example with its `required` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibraryModern` project, in `Book.cs`, add statements to define
    a pair of constructors, one that supports object initializer syntax and one to
    set the two required properties, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the statement that instantiates a book using object
    initializer syntax, add a statement to instantiate a book using the constructor,
    and then set the non-`required` properties for the book, as highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you will see a compiler error as before because the compiler cannot
    automatically tell that calling the constructor will have set the two `required`
    properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PacktLibraryModern` project, in `Book.cs`, import the namespace to
    perform code analysis and then decorate the constructor with the attribute to
    tell the compiler that it sets all the required properties and fields, as highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, note the statement that calls the constructor now compiles
    without errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Optionally, run the `PeopleApp` project to confirm it behaves as expected,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More information**: You can learn more about `required` fields and how to
    set them using a constructor at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required).'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors are a special category of method. Let’s look at methods in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Working with methods and tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Methods** are members of a type that execute a block of statements. They
    are functions that belong to a type.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning values from methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can return a single value or nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: A method that performs some actions but does not return a value indicates this
    with the `void` type before the name of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method that performs some actions and returns a value indicates this with
    the type of the return value before the name of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the next task, you will create two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteToConsole`: This will perform an action (writing some text to the console),
    but it will return nothing from the method, indicated by the `void` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetOrigin`: This will return a text value, indicated by the `string` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define the two methods that I described earlier,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the two methods, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining and passing parameters to methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can have parameters passed to them to change their behavior. Parameters
    are defined a bit like variable declarations but inside the parentheses of the
    method declaration, as you saw earlier in this chapter with constructors. Let’s
    see more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define two methods, the first without parameters
    and the second with one parameter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the two methods, and write the return
    value to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When typing a statement that calls a method, IntelliSense shows a tooltip with
    the name, the type of any parameters, and the return type of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of having two different method names, we could give both methods the
    same name. This is allowed because the methods each have a different signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **method signature** is a list of parameter types that can be passed when
    calling the method. Overloaded methods must differ in their list of parameter
    types. Two overloaded methods cannot have the same list of parameter types and
    differ only in their return types. Let’s code an example:'
  prefs: []
  type: TYPE_NORMAL
- en: In `Person.cs`, change the name of the `SayHelloTo` method to `SayHello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, change the method call to use the `SayHello` method, and note
    that the quick info for the method tells you that it has an additional overload,
    **1 of 2**, as well as **2 of 2**, in Visual Studio, although other code editors
    may be different, as shown in *Figure 5.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: An IntelliSense tooltip for an overloaded method'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Use overloaded methods to simplify your class by making
    it appear to have fewer methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing optional parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to simplify methods is to make parameters optional. You make a parameter
    optional by assigning a default value inside the method parameter list. Optional
    parameters must always come last in the list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a method with three optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define the method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to call the method and write its return value
    to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Watch IntelliSense appear as you type the code. You will see a tooltip showing
    the three optional parameters with their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and see the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default values for the `command` and `number` parameters have been replaced,
    but the default for `active` is still `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Naming parameter values when calling methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optional parameters are often combined with naming parameters when you call
    the method because naming a parameter allows the values to be passed in a different
    order than how they were declared:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, but using named parameters,
    so that the order they are passed through can be swapped around, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can even use named parameters to skip over optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter using positional order, skip the `number` parameter, and use the named
    `active` parameter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Although you can mix named and positional parameter values,
    most developers prefer to read code that uses one or the other within the same
    method call.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mixing optional and required parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, all the parameters in the `OptionalParameters` method are optional.
    What if one of them is required?
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add a fourth parameter without a default value to the `OptionalParameters`
    method, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the project and note the compiler error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `OptionalParameters` method, move the `count` parameter before the optional
    parameters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, modify all the calls to the `OptionalParameters` method to
    pass an `int` value as the first argument, for example, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember that if you name the arguments, then you can change their positions,
    for example: `bob.OptionalParameters(number: 52.7, command: "Hide!", count: 3)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you call the `OptionalParameters` method, note the tooltip that shows the
    one required, three optional parameters, and their default values in Visual Studio,
    as shown in *Figure 5.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: IntelliSense showing the required and optional parameters as you
    type code'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling how parameters are passed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a parameter is passed into a method, it can be passed in one of several
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By **value** (this is the default): Think of these as being *in-only*. Although
    the value can be changed, this only affects the parameter in the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an `out` parameter: Think of these as being *out-only*. `out` parameters
    cannot have a default value assigned in their declaration and cannot be left uninitialized.
    They must be set inside the method; otherwise, the compiler will give an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By **reference** as a `ref` parameter: Think of these as being *in-and-out*.
    Like `out` parameters, `ref` parameters also cannot have default values, but since
    they can already be set outside the method, they do not need to be set inside
    the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an `in` parameter: Think of these as being a reference parameter that is
    *read-only*. `in` parameters cannot have their values changed and the compiler
    will show an error if you try.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some examples of passing parameters in and out of a method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method with three parameters, one
    `in` parameter, one `ref` parameter, and one `out` parameter, as shown in the
    following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to declare some `int` variables and pass them
    into the method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following about the preceding output:'
  prefs: []
  type: TYPE_NORMAL
- en: When passing a variable as a parameter by default, its current value gets passed,
    not the variable itself. Therefore, `w` has a copy of the value of the `a` variable.
    The `a` variable retains its original value of `10` even after `w` is incremented
    to 11.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing a variable as an `in` parameter, a reference to the variable gets
    passed into the method. Therefore, `x` is a reference to `b`. If the `b` variable
    gets incremented by some other process while the method is executing, then the
    `x` parameter would show that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing a variable as a `ref` parameter, a reference to the variable gets
    passed into the method. Therefore, `y` is a reference to `c`. The `c` variable
    gets incremented when the `y` parameter gets incremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing a variable as an `out` parameter, a reference to the variable gets
    passed into the method. Therefore, `z` is a reference to `d`. The value of the
    `d` variable gets replaced by whatever code executes inside the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could simplify the code in the `Main` method by not assigning the value `40`
    to the `d` variable since it will always be replaced anyway. In C# 7 and later,
    we can simplify code that uses the `out` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare some more variables, including an
    `out` parameter named `h` declared inline, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Passing a variable number of parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `params` keyword in C# is used to specify a method parameter that takes
    a variable number of arguments. It allows you to pass an array of arguments to
    a method, or to pass a list of arguments that the compiler will automatically
    convert to an array.
  prefs: []
  type: TYPE_NORMAL
- en: With C# 13 and later, as well as passing an array, you can pass any type that
    can be constructed via a collection expression, for example, a `List<T>` or `IEnumerable<T>`.
    Collection expressions are covered in detail in *Chapter 8, Working with Common
    .NET Types*, but basically, you can define a collection of items by surrounding
    a comma-separated list of items in square brackets `[ ]`.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using `params` include flexibility. It allows methods to accept
    any number of arguments and is easy to use because it simplifies the method signature
    by avoiding the need to explicitly create an array before calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some considerations when using the `params` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: The `params` keyword can only be used for one parameter in a method, and it
    must be the last parameter if the method has more than one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass individual arguments, and the compiler will automatically package
    them into an array. Alternatively, you can pass an array or collection expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using `params`, you can call the method without passing any arguments for
    that parameter, and an empty array will be passed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method with two parameters, one
    normal parameter and one `params` parameter, as shown in the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With C# 12 and earlier, `params int[]` must be an array, although the items
    can by any data type, not just `int`. With C# 13 and later, `params int[]` could
    be any data type supported by collection expressions, like `params List<int>`
    or `IEnumerable<int>`, although the items can by any data type, not just `int`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to pass a string and some numbers into the
    method in various ways, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `params` keyword is a powerful feature in C# that enhances the flexibility
    and readability of your code by allowing methods to accept a variable number of
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ref returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C# 7 or later, the `ref` keyword is not just for passing parameters into
    a method; it can also be applied to the `return` value. This allows an external
    variable to reference an internal variable and modify its value after the method
    call. This might be useful in advanced scenarios, for example, passing placeholders
    into big data structures, but it’s beyond the scope of this book. If you are interested
    in learning more, then you can read the information at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#reference-return-values](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#reference-return-values).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s return to looking at more advanced scenarios of methods that return
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Combining multiple returned values using tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each method can only return a single value that has a single type. That type
    could be a simple type, such as `string` in the previous example; a complex type,
    such as `Person`; or a collection type, such as `List<Person>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to define a method named `GetTheData` that needs to return
    both a `string` value and an `int` value. We could define a new class named `TextAndNumber`
    with a `string` field and an `int` field, and return an instance of that complex
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: But defining a class just to combine two values is unnecessary because, in modern
    versions of C#, we can use **tuples**. Tuples are an efficient way to combine
    two or more values into a single unit. I pronounce them as *tuh-ples* but I have
    heard other developers pronounce them as *too-ples*. To-may-toe, to-mah-toe, po-tay-toe,
    po-tah-toe, I guess.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples have been a part of some languages, such as F#, since their first version,
    but .NET only added support for them with .NET 4 in 2010, using the `System.Tuple`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: It was only with C# 7 in 2017 that C# added language syntax support for tuples
    using the parentheses characters `()`, and at the same time, .NET added a new
    `System.ValueTuple` type that is more efficient in some common scenarios than
    the old .NET 4 `System.Tuple` type. The C# tuple syntax uses the more efficient
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method that returns a tuple combining
    a `string` and `int`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the `GetFruit` method, and then output
    the tuple’s fields, which are automatically named `Item1` and `Item2`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Naming the fields of a tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the fields of a tuple, the default names are `Item1`, `Item2`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly specify the field names:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method that returns a tuple with
    named fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the method and output the tuple’s named
    fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use `var` to shorten the following full syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you construct a tuple from another object, you can use a feature introduced
    in C# 7.1 called **tuple name inference**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create two tuples, each made of a `string` and `int` value,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In C# 7, both things would use the `Item1` and `Item2` naming schemes. In C#
    7.1 and later, `thing2` can infer the names `Name` and `Count`.
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to alias a tuple was introduced in C# 12 so that you could name
    the type and use that as the type name when declaring variables and parameters,
    for example, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: When aliasing tuples, use the title case naming convention for its parameters,
    for example, `Name`, `Number`, and `BirthDate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, at the top of the file, define a named tuple type, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, copy and paste the statement that calls the `GetNamedFruit`
    method and change `var` to `Fruit`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `PeopleApp` project and note the result is the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deconstructing tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also deconstruct tuples into separate variables. The deconstructing
    declaration has the same syntax as named field tuples but without a named variable
    for the tuple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Deconstruction has the effect of splitting the tuple into its parts and assigning
    those parts to new variables. Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to deconstruct the tuple returned from the
    `GetFruit` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deconstructing other types using tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tuples are not the only type that can be deconstructed. Any type can have special
    methods, named `Deconstruct`, that break down an object into parts. You can have
    as many `Deconstruct` methods as you like as long as they have different signatures.
    Let’s implement some for the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add two `Deconstruct` methods with `out` parameters defined
    for the parts we want to deconstruct into, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to deconstruct `bob`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You do not explicitly call the `Deconstruct` method. It is called implicitly
    when you assign an object to a tuple variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing functionality using local functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A language feature introduced in C# 7 is the ability to define a **local function**.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions are the method equivalent of local variables. In other words,
    they are methods that are only accessible from within the containing method in
    which they have been defined. In other languages, they are sometimes called **nested**
    or **inner functions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local functions can be defined anywhere inside a method: the top, the bottom,
    or even somewhere in the middle!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a local function to implement a factorial calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a `Factorial` function that uses a
    local function inside itself to calculate the result, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the `Factorial` function, and write
    the return value to the console, with exception handling, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the number to `-1` so that we can check the exception handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Splitting classes using partial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on large projects with multiple team members, or when working with
    especially large and complex class implementations, it is useful to be able to
    split the definition of a class across multiple files. You do this using the `partial`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we want to add statements to the `Person` class that are automatically
    generated by a tool, like an object-relational mapper, that reads schema information
    from a database. If the class is defined as `partial`, then we can split the class
    into an autogenerated code file and a manually edited code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code that simulates this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add the `partial` keyword, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `PacktLibraryNet2` project/folder, add a new class file named `PersonAutoGen.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to the new file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `PacktLibraryNet2` project. If you see the `CS0260 Missing partial
    modifier on declaration of type 'Person'; another partial declaration of this
    type exists` error, then make sure you have applied the `partial` keyword to both
    `Person` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the code we write for this chapter will be written in the `PersonAutoGen.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Partial methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partial methods were introduced with C# 3 on .NET Framework in 2007\. They are
    a feature that allows the definition of method signatures in one part of a `partial`
    `class` or `struct`, with the actual implementation provided in another part.
    Partial methods are particularly useful in scenarios where code generation and
    manual code coexist, such as in code generated by tools like Entity Framework
    Core or a source code generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some key characteristics of `partial` methods, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: Partial methods are declared with the `partial` keyword. The declaration provides
    the method signature, while the implementation provides the method body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of a partial method is optional. If a partial method is declared
    but not implemented, the compiler removes the call to the method and no error
    is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial methods are implicitly private and cannot have access modifiers. They
    must also return `void` and cannot have `out` parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial methods cannot be `virtual`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial methods are often used in scenarios involving code generation where
    a base structure is provided, and custom logic can be added without modifying
    the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a class file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine that you have another class file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, `OnSomethingHappened` is a partial method declared
    in `MyClass1.cs` and implemented in `MyClass2.cs`. The method `DoWork` calls the
    partial method, which prints a message if the implementation is provided.
  prefs: []
  type: TYPE_NORMAL
- en: If in the example, `OnSomethingHappened` is declared but not implemented, then
    the C# compiler will remove the call to `OnSomethingHappened` in `DoWork`, and
    no error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Partial methods are often used in auto-generated code where developers can hook
    into the process without modifying the generated code. This would be the case
    if the `MyClass1.cs` file was generated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Partial methods in C# provide a powerful way to extend and customize generated
    code without modifying it directly. They offer a clean mechanism for inserting
    custom behavior, ensuring that code generation and custom logic can coexist. By
    leveraging partial methods, developers can maintain a clear separation between
    generated and custom code, enhancing maintainability and readability. Now that
    you’ve seen lots of examples of fields and methods, we will look at some specialized
    types of methods that can be used to access fields to provide control and improve
    the developer’s experience.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling access with properties and indexers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, you created a method named `GetOrigin` that returned a `string` containing
    the name and origin of the person. Languages such as Java do this a lot. C# has
    a better way, and it is called properties.
  prefs: []
  type: TYPE_NORMAL
- en: A **property** is simply a method (or a pair of methods) that acts and looks
    like a field when you want to get or set a value, but it acts like a method, thereby
    simplifying the syntax and enabling functionality, like validation and calculation,
    when you set and get a value.
  prefs: []
  type: TYPE_NORMAL
- en: A fundamental difference between a field and a property is that a field provides
    a memory address to data. You could pass that memory address to an external component,
    like a Windows API C-style function call, and it could then modify the data. A
    property does not provide a memory address to its data, which provides more control.
    All you can do is ask the property to get or set the data. The property then executes
    statements and can decide how to respond, including refusing the request!
  prefs: []
  type: TYPE_NORMAL
- en: Defining read-only properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `readonly` property only has a `get` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, in the `Person` class, add statements to define three
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first property will perform the same role as the `GetOrigin` method, using
    the property syntax that works with all versions of C#.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second property will return a greeting message, using the lambda expression
    body `=>` syntax from C# 6 and later.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third property will calculate the person’s age.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '**Good practice**: This isn’t the best way to calculate someone’s age, but
    we aren’t learning how to calculate an age from a date and time of birth. If you
    need to do that properly, then read the discussion at the following link: [https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add the statements to get the properties, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output shows `54` because I ran the console app on July 5, 2023, when Sam
    was 54 years old.
  prefs: []
  type: TYPE_NORMAL
- en: Defining settable properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a settable property, you must use the older syntax and provide a
    pair of methods—not just a `get` part, but also a `set` part:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` property that has
    both a `get` and `set` method (also known as a **getter** and **setter**), as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although you have not manually created a field to store the person’s favorite
    ice cream, it is there, automatically created by the compiler for you.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you need more control over what happens when a property is set. In
    this scenario, you must use a more detailed syntax and manually create a `private`
    field to store the value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define a `private` `string` field,
    known as a **backing field**, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Although there is no formal standard to name private fields,
    the most common is to use camel case with an underscore as a prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` property that has
    both `get` and `set` and validation logic in the setter, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Avoid adding too much code to your getters and setters.
    This could indicate a problem with your design. Consider adding private methods
    that you then call in the `set` and `get` methods to simplify your implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to set Sam’s favorite ice cream and color,
    and then write them out, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The print book is limited to about 820 pages. If I added exception handling
    code to all code examples as we have done here, then I would probably have to
    remove at least one chapter from the book to make enough space. In the future,
    I will not explicitly tell you to add exception handling code, but get into the
    habit of adding it yourself when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try to set the color to any value other than red, green, or blue, like black.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Use properties instead of fields when you want to execute
    statements during a read or write to a field without using a method pair, like
    `GetAge` and `SetAge`.'
  prefs: []
  type: TYPE_NORMAL
- en: Partial properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned about partial classes and partial methods.
    With C# 13 on .NET 9, you can define partial properties, and they work in a similar
    way. The main benefit is to support source-generated types. Partial properties
    make it easier for source generator designers to create natural feeling APIs,
    as you will see in *Chapter 8, Working with Common .NET Types*, when we see the
    Regex source generator.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting flags enum values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we defined a field to store a person’s favorite ancient
    wonder. But we then made the `enum` able to store combinations of values. Now,
    let’s limit the favorite to one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, comment out the `FavoriteAncientWonder` field and add a comment
    to note it has moved to the `PersonAutoGen.cs` code file, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `PersonAutoGen.cs`, add a `private` field and `public` property for `FavoriteAncientWonder`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could simplify the validation by only checking if the value is defined in
    the original `enum` because `IsDefined` returns `false` for multiple values and
    undefined values. However, I want to show a different exception for multiple values,
    so I will use the fact that multiple values formatted as a string would include
    a comma in the list of names. This also means we must check for multiple values
    before we check if the value is defined. A comma-separated list is how multiple
    `enum` values are represented as a `string`, but you cannot use commas to set
    multiple `enum` values. You should use `|` (the bitwise `OR`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, in the *Storing a value using an enum type* region, set Bob’s
    favorite wonder to more than one `enum` value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and note the exception, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, set Bob’s favorite wonder to an invalid `enum` value like
    128, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and note the exception, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, set Bob’s favorite wonder back to a valid single `enum` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining indexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Indexers** allow the calling code to use the array syntax to access a property.
    For example, the `string` type defines an indexer so that the calling code can
    access individual characters in the `string`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: You can overload indexers so that different types can be used for their parameters.
    For example, as well as passing an `int` value, you could also pass a `string`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define an indexer to simplify access to the children of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define an indexer to get and set a
    child using the index of the child, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the use of `this[]` to define an indexer. It is not to be confused with
    the use of the `this` keyword to refer to the current instance of an object, or
    the use of `this()` to refer to the current type’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define an indexer to get and set a
    child using the name of the child, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will learn more about collections like `List<T>` in *Chapter 8*, *Working
    with Common .NET Types*, and how to write lambda expressions using `=>` in *Chapter
    11*,*Querying and Manipulating Data Using LINQ*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add two children to `Sam`, and then access
    the first and second children using the longer `Children` field and the shorter
    indexer syntax, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`sam[0].Name` calls the indexer aka `this` on the `Person` class because `[]`
    are the symbols that call an indexer. `sam.Children[0].Name` calls the indexer
    on the collection named `Children`, which is a `List<Person>`. We have implemented
    the indexer on `Person` to do the same thing so we can use a shorter syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s similar with `string` values. If I have `string name = "Mark";` then imagine
    that it has a property named `Characters` that is a `List<char>`. I could use
    `name.Characters[0]` to return the character `M`. But since `string` has an indexer
    defined, I can do the same with `name[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Most types do not define an indexer. It’s just a way to define a property that
    is called using `[]` instead of a name. It can actually do anything you want.
    But it should be used to define an array/collection style getter/setter. If your
    type doesn’t need that, it doesn’t need an indexer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any type you define, just imagine another developer using your type. What
    would they expect the indexer to do? For example, what if you get the first index,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '`thing1` might be the first passenger in the car or the first wheel of the
    car. `thing2` might be the first table in the database or the first user. For
    custom types, it is up to you to decide what makes the most sense for your type.'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to basic pattern matching. In this section, we will explore
    pattern matching in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern-matching flight passengers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will define some classes that represent various types of
    passengers on a flight, and then we will use a switch expression with pattern
    matching to determine the cost of their flight:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryNet2` project/folder, add a new file named `FlightPatterns.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use Visual Studio, in `FlightPatterns.cs`, delete the existing statements,
    including the class named `FlightPatterns`, because we will define multiple classes,
    and none match the name of the code file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `FlightPatterns.cs`, add statements to define three types of passenger with
    different properties, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will learn about overriding the `ToString` method in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to define an object array containing five passengers
    of various types and property values, and then enumerate them, outputting the
    cost of their flight, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While reviewing the preceding code, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Most code editors do not align the lambda symbols => as I have done above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To pattern match the properties of an object, you must name a local variable,
    like `p`, which can then be used in an expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To pattern match on a type only, you can use `_` to discard the local variable;
    for example, `FirstClassPassenger _` means that you match on the type but you
    don’t care what values any of its properties have, so a named variable like `p`
    is not needed. In a moment, you will see how we can improve the code even more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` expression also uses `_` to represent its default branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enhancements to pattern matching in modern C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous examples worked with C# 8\. Now, we will look at some enhancements
    in C# 9 and later. First, you no longer need to use the underscore to discard
    the local variable when doing type matching:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the C# 8 syntax, and add C# 9 and later syntax
    to modify the branches for first-class passengers to use a nested `switch` expression
    and the new support for conditionals, like `>`, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `PeopleApp` project to view the results, and note that they are the
    same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also use the relational pattern in combination with the property
    pattern to avoid the nested `switch` expression, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Working with record types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the new `record` language feature, let us see some other
    related new features of C# 9 and later.
  prefs: []
  type: TYPE_NORMAL
- en: Init-only properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have used object initialization syntax to instantiate objects and set initial
    properties throughout this chapter. Those properties can also be changed after
    instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you want to treat properties like `readonly` fields so that they
    can be set during instantiation but not after. In other words, they are immutable.
    The `init` keyword enables this. It can be used in place of the `set` keyword
    in a property definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a language feature not supported by .NET Standard 2.0, we cannot
    use it in the `PacktLibraryNet2` project. We must use it in the modern project:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project, add a new file named `Records.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Records.cs`, define a person class with two immutable properties, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to instantiate a new immutable person, and
    then try to change one of its properties, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the console app and note the compile error, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the attempt to set the `FirstName` property after instantiation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if you do not set `FirstName` in the object initializer, you still would
    not be able to set it post-initialization. If you need to force a property to
    be set, then apply the `required` keyword that you learned about earlier in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining record types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Init-only properties provide some immutability to C#. You can take the concept
    further by using **record types**. These are defined by using the `record` keyword
    instead of (or as well as) the `class` keyword. That can make the whole object
    immutable, and it acts like a value when compared. We will discuss equality and
    comparisons of classes, records, and value types in more detail in *Chapter 6*,
    *Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutable records should not have any state (properties and fields) that change
    after instantiation. Instead, the idea is that you create new records from existing
    ones. The new record has the changed state. This is called non-destructive mutation.
    To do this, C# 9 introduced the `with` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Records.cs`, add a record named `ImmutableVehicle` after the `ImmutablePerson`
    class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create a `car` and then a mutated copy of
    it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project to view the results, and note the change to the
    car color in the mutated copy, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You could also release the memory for the `car` variable and the `repaintedCar`
    would still fully exist.
  prefs: []
  type: TYPE_NORMAL
- en: Equality of record types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most important behaviors of `record` types is their equality. Two
    records with the same property values are considered equal. This may not sound
    surprising, but if you used a normal class instead of a record, then they would
    *not* be considered equal. Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project, add a new file named `Equality.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Equality.cs`, define a `class` and a `record` type, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create two instances of `AnimalClass` and
    two instances of `AnimalRecord`, and then compare them for equality, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project to view the results, and note that two class instances
    are not equal even if they have the same property values, and two record instances
    are equal if they have the same property values, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Class instances are only equal if they are literally the same object. This is
    true when their memory addresses are equal. You will learn more about the equality
    of types in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Equality of other types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common to compare two variables using the `==` and `!=` operators. The
    behavior of these two operators is different for reference types and value types.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you check the equality of two value type variables, .NET literally compares
    the *values* of those two variables on the stack and returns `true` if they are
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare two integers with equal values and
    then compare them, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you check the equality of two reference type variables, .NET compares the
    memory addresses of those two variables and returns `true` if they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare two `Person` instances with equal
    names, and then compare the variables and their names, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because they are not the same object. If both variables literally pointed
    to the same object on the heap, then they would be equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to declare a third `Person` object and assign `p1` to it, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The one exception to this behavior of reference types is the `string` type.
    It is a reference type, but the equality operators have been overridden to make
    them behave as if they were value types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements to compare the `Name` properties of two `Person` instances,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can do the same as `string` with your classes to override the equality operator
    `==` to return `true`, even if the two variables are not referencing the same
    object (the same memory address on the heap) but, instead, their fields have the
    same values. However, that is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Alternatively, use a `record class` because one of its benefits
    is that it implements this equality behavior for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Positional data members in records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for defining a record can be greatly simplified using positional
    data members. Instead of using object initialization syntax with curly braces,
    sometimes you might prefer to provide a constructor with positional parameters,
    as you saw earlier in this chapter. You can also combine this with a deconstructor
    to split the object into individual parts, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties, constructor, and deconstructor can be generated for you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Records.cs`, add statements to define another record using simplified syntax,
    known as positional records, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to construct and deconstruct immutable animals,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the results, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see records again when we look at C# 10 or later support to create
    `struct` records in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: '**More information**: There are many more ways to use records in your projects.
    I recommend that you review the official documentation at the following link:
    [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a primary constructor for a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced with C# 12, you can define one constructor as part of the class definition.
    This is called the primary constructor. The syntax is the same as for positional
    data members in records, but the behavior is slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, we separate the class definition from any constructors, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'With class primary constructors, you combine both into a more succinct syntax,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project, add a class file named `Headset.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the code file contents to give the class two parameters for manufacturer
    and product name respectively, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to instantiate a headset, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One of the differences between a `record` and a `class` type with a primary
    constructor is that its parameters don’t become public properties automatically,
    so you will see `CS1061` compiler errors. Neither `ProductName` nor `productName`
    are accessible outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Headset.cs`, add statements to define two properties and set them using
    the parameters passed to the primary constructor, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the results, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Headset.cs`, add a default parameterless constructor, as highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the use of `this()` to call the constructor of the base class and pass
    two parameters to it when the default constructor of `Headset` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create an uninitialized instance of a headset and an instance
    for Meta Quest 3, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the results, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More information**: You can learn more about primary constructors for classes
    and structs at the following links: [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/primary-constructors](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/primary-constructors)
    and [https://devblogs.microsoft.com/dotnet/csharp-primary-constructors-refactoring/](https://devblogs.microsoft.com/dotnet/csharp-primary-constructors-refactoring/).
    In particular, it is worth reading the comments at the bottom of the second link
    to understand why many developers do not like primary constructors in classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: Only use a primary constructor in a class if it will only
    initialize non-read-only private fields, and does not need to execute other statements.'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.1 – online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many ways to use pattern matching in your projects. I recommend that
    you review the official documentation at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.2 – practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Practice access modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that you are the compiler. What errors would you show when building
    the following projects? What would need to change to fix it?
  prefs: []
  type: TYPE_NORMAL
- en: 'In a class library project, in `Car.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'In a console app project that references the class library project, in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 5.3 – test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the seven access modifier keywords and combinations of keywords, and
    what do they do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `static`, `const`, and `readonly` keywords
    when applied to a type member?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a constructor do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you apply the `[Flags]` attribute to an `enum` type when you want
    to store combined values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `partial` keyword useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a tuple?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `record` keyword do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does overloading mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the following two statements? (Do not just say
    a > character!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How do you make a method parameter optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can’t a `DateTime` field be a constant?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 5.4 – explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: Making your own types using OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the different categories of members that a type can have, including
    fields to store data and methods to perform actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP concepts, such as aggregation and encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use modern C# features, like relational and property pattern matching
    enhancements, `init`-only properties, and record types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will take these concepts further by defining operators,
    delegates, and events, implementing interfaces, and inheriting from existing classes.
  prefs: []
  type: TYPE_NORMAL
