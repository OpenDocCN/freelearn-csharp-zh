- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Adding Capabilities to Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序添加功能
- en: ASP.NET Core 9 provides different features and tools that enable us to develop
    powerful web-based solutions. However, we often need more specialized features
    in order to provide a better end-to-end experience. In this chapter, we will learn
    good practices related to web applications such as adding caching, using asynchronous
    mechanisms, resilience mechanisms, and logging. We will explore essential best
    practices for developing applications with ASP.NET Core 9, covering the correct
    use of asynchronous mechanisms, HTTP requests, and application instrumentation
    through logs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 提供了不同的特性和工具，使我们能够开发强大的基于网络的解决方案。然而，我们通常需要更多专业化的特性，以便提供更好的端到端体验。在本章中，我们将学习与网络应用程序相关的良好实践，例如添加缓存、使用异步机制、弹性机制和日志记录。我们将探讨使用
    ASP.NET Core 9 开发应用程序的必要最佳实践，包括正确使用异步机制、HTTP 请求以及通过日志进行应用程序仪表化。
- en: 'We will focus on the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下主题：
- en: Working with ASP.NET Core 9 best practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 9 最佳实践进行工作
- en: Improving performance with a cache strategy and making the application resilient
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缓存策略提高性能并使应用程序具有弹性
- en: Understanding and implementing logging and monitoring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现日志记录和监控
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To support the learning of this chapter, the following tools must be present
    in your development environment:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持本章的学习，以下工具必须在您的开发环境中存在：
- en: '**Docker** : Docker Engine must be installed on your operating system and have
    a SQL Server container running. You can find more details about Docker and the
    SQL Server container in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) .'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：必须在您的操作系统上安装 Docker 引擎，并运行 SQL Server 容器。您可以在[*第 5 章*](B21788_05.xhtml#_idTextAnchor078)中找到有关
    Docker 和 SQL Server 容器的更多详细信息。'
- en: '**Postman** : This tool will be used to execute requests to APIs of the developed
    application.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postman**：此工具将用于执行对开发应用程序 API 的请求。'
- en: '**Redis Insight** : This tool is used to connect to a Redis Server database
    ( [https://redis.io/insight/](https://redis.io/insight/) ).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis Insight**：此工具用于连接到 Redis 服务器数据库（[https://redis.io/insight/](https://redis.io/insight/)）。'
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07)
    .'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码示例可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07)。
- en: Working with ASP.NET Core 9 best practices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 9 最佳实践进行工作
- en: So far, we have already learned about several features and benefits of ASP.NET
    Core 9 in creating quality web systems. Of course, just like any other software
    development technology, there is no restriction on the way we will handle our
    code. In this way, we have the freedom to create solutions and new standards with
    the aim of meeting a specific need.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 ASP.NET Core 9 在创建高质量网络系统中的几个特性和好处。当然，就像任何其他软件开发技术一样，我们处理代码的方式没有限制。这样，我们有自由创造解决方案和新标准，以满足特定的需求。
- en: However, relying on good practices can not only expand our capacity to develop
    quality applications but also avoid wasting several hours to achieve a goal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，依赖良好实践不仅可以扩大我们开发高质量应用程序的能力，还可以避免浪费几个小时来实现目标。
- en: In this case, we will address some good practices necessary to bring greater
    quality to our applications, starting with the correct use of **HTTP requests**
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将讨论一些必要的良好实践，以提升我们应用程序的质量，从正确使用**HTTP 请求**开始。
- en: HTTP request best practices
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 请求最佳实践
- en: The HTTP request is a fundamental component when working with web applications.
    Proper handling of HTTP requests can significantly impact the performance and
    reliability of your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求是处理网络应用程序时的一个基本组件。正确处理 HTTP 请求可以显著影响应用程序的性能和可靠性。
- en: We have already learned about the types of HTTP verbs and status codes in [*Chapter
    3*](B21788_03.xhtml#_idTextAnchor044) . However, each HTTP method provided by
    the application must be treated appropriately, to avoid inconsistencies in the
    application and avoid vulnerabilities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第 3 章*](B21788_03.xhtml#_idTextAnchor044)中学习了 HTTP 动词和状态码的类型。然而，应用程序提供的每个
    HTTP 方法都必须得到适当的处理，以避免应用程序中的不一致性和避免漏洞。
- en: Furthermore, the way HTTP requests are made directly impacts the experience
    of users or consumers of your solution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HTTP 请求的方式直接影响到您解决方案的用户或消费者的体验。
- en: Let’s understand some good practices related to HTTP requests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些与 HTTP 请求相关的良好实践。
- en: Validate and sanitize input
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证和清理输入
- en: Always validate and sanitize input to prevent security vulnerabilities such
    as SQL injection and **cross-site** **scripting** ( **XSS** ).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 总是验证和清理输入，以防止诸如 SQL 注入和 **跨站** **脚本**（**XSS**）等安全漏洞。
- en: XSS
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: XSS
- en: XSS is a security vulnerability where the attacker injects scripts into web
    pages. To know more, go to [https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0)
    .
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 是一种安全漏洞，攻击者会将脚本注入到网页中。要了解更多信息，请访问 [https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0)。
- en: 'Consider a scenario where a user submits a form with a username. To prevent
    harmful data from being processed, you should validate the input to ensure it
    meets the expected criteria and sanitize it to remove any malicious content:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，即用户提交一个包含用户名的表单。为了防止有害数据被处理，您应该验证输入以确保它符合预期标准，并清理它以移除任何恶意内容：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code demonstrates a simple validation of the username parameter,
    **if(string.IsNullOrEmpty)** , avoiding using it incorrectly. The **HttpUtility.HtmlEncode(username)**
    method is used to convert characters such as **<** , **>** , **&** , and so on
    into an HTML-encoded format.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了对用户名参数的简单验证，**if(string.IsNullOrEmpty)**，避免错误使用。使用 **HttpUtility.HtmlEncode(username)**
    方法将如 **<**、**>**、**&** 等字符转换为 HTML 编码格式。
- en: Use asynchronous methods
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异步方法
- en: 'During the execution flow of an HTTP request, we must avoid making the processing
    actions synchronous. Otherwise, this could degrade the user experience and cause
    some problems for the application, such as the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求的执行流程中，我们必须避免进行同步处理操作。否则，这可能会降低用户体验，并导致应用程序出现一些问题，例如以下情况：
- en: '**Thread blocking** : Synchronous methods block the thread while waiting for
    I/O operations (such as database queries, file access, or network requests) to
    complete. In an ASP.NET Core application, the thread pool is a limited resource.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程阻塞**：同步方法在等待 I/O 操作（如数据库查询、文件访问或网络请求）完成时会阻塞线程。在 ASP.NET Core 应用程序中，线程池是一种有限资源。'
- en: '**Thread pool exhaustion** : When an application heavily relies on synchronous
    methods, the thread pool can become exhausted, especially under high load, which
    occurs when all available threads are blocked and no new threads are available
    to handle incoming requests.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程池耗尽**：当应用程序大量依赖同步方法时，线程池可能会耗尽，尤其是在高负载下，此时所有可用的线程都被阻塞，没有新的线程来处理传入的请求。'
- en: It is a recommendation and good practice to use asynchronous methods to improve
    performance and scalability. For example, when using the **HttpClient** object
    to make a request in an API, use the **HttpClient.SendAsync** method instead of
    **HttpClient.Send** .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 建议并良好实践是使用异步方法来提高性能和可伸缩性。例如，当使用 **HttpClient** 对象在 API 中进行请求时，使用 **HttpClient.SendAsync**
    方法而不是 **HttpClient.Send**。
- en: Asynchronous programming allows your application to handle multiple tasks simultaneously
    without waiting for each task to complete before starting the next one. This is
    similar to how a chef in a busy kitchen might prepare multiple dishes at once,
    rather than finishing one dish before starting another.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程允许您的应用程序同时处理多个任务，而无需等待每个任务完成后再开始下一个任务。这类似于一个繁忙厨房中的厨师可能一次准备多个菜肴，而不是完成一个菜肴后再开始另一个。
- en: We will cover the use of asynchronous programming in more detail in the *Asynchronous
    requests and I/O optimization* section. Now, let’s understand another good practice
    in relation to HTTP requests, regarding caching and compression.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“异步请求和 I/O 优化”部分更详细地介绍异步编程的使用。现在，让我们了解与 HTTP 请求相关的另一个良好实践，即缓存和压缩。
- en: Caching and compression
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存和压缩
- en: Requests via the HTTP protocol have some attributes, including headers and body.
    During communication between an application and the backend, this information
    is transmitted, and the headers are used both by the client (in this case, the
    browser) and by the backend.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP协议发送的请求有一些属性，包括头和体。在应用程序与后端通信期间，这些信息被传输，并且头由客户端（在这种情况下，是浏览器）和后端使用。
- en: There are several types of HTTP headers, including those associated with caching
    and compression.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头有多种类型，包括与缓存和压缩相关联的头。
- en: By utilizing caching and response compression, we can reduce bandwidth usage
    and improve load times. Browsers also identify these headers, avoiding unnecessary
    requests to the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用缓存和响应压缩，我们可以减少带宽使用并提高加载时间。浏览器也会识别这些头，避免对服务器进行不必要的请求。
- en: Caching and dating compression work similarly to how a library might keep frequently
    borrowed books readily accessible or how a vacuum-sealed package takes up less
    space. These practices reduce the load on your server and speed up responses to
    user requests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存和压缩的工作原理类似于图书馆如何使频繁借阅的书籍易于获取，或者真空包装的包装如何占用更少的空间。这些做法减轻了服务器的负担，并加快了对用户请求的响应。
- en: 'Let’s analyze the following code snippet extracted from a **Program.cs** class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下从**Program.cs**类中提取的代码片段：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s understand the preceding code. When you add **app.UseResponseCaching**
    to the application’s **middleware** pipeline, it performs the following functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解前面的代码。当您将**app.UseResponseCaching**添加到应用程序的**中间件**管道中时，它执行以下功能：
- en: '**Checks for** **Cache-Control headers** :'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查** **Cache-Control头**：'
- en: The middleware checks whether the incoming request can be cached based on the
    presence of Cache-Control headers
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件根据Cache-Control头的存在检查传入的请求是否可以被缓存
- en: If a valid Cache-Control header is found and it allows caching, the middleware
    proceeds to handle the request
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到有效的Cache-Control头并且允许缓存，中间件将继续处理请求
- en: '**Stores responses in** **the cache** :'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将响应存储在** **缓存中**：'
- en: If the response to the request can be cached, the middleware stores the response
    in the cache
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求的响应可以被缓存，中间件将响应存储在缓存中
- en: Subsequent requests that match the cache criteria will be served directly from
    the cache, bypassing the need to generate the response again
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合缓存标准的后续请求将直接从缓存中提供，无需再次生成响应
- en: '**Serves** **cached responses** :'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供** **缓存响应**：'
- en: For requests that match previously cached responses, the middleware serves the
    cached response
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于与之前缓存的响应匹配的请求，中间件提供缓存的响应
- en: This reduces the processing time and load on the server, as the response is
    retrieved directly from the cache
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样可以减少处理时间和服务器负载，因为响应是直接从缓存中检索的
- en: The **app.Use(async (context, next)** method adds the necessary parameters for
    the Cache-Control header to the middleware pipeline, such as the cache duration
    time. This is necessary so that the client can know how the response should be
    cached.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**app.Use(async (context, next)**方法向中间件管道添加了Cache-Control头所需的参数，例如缓存持续时间。这是必要的，以便客户端可以知道如何缓存响应。'
- en: The cache is managed in the application’s memory and, therefore, it is not interesting
    to keep the cache for a large amount of time in memory, which could cause problems.
    However, it is good practice to use it. We will go into more detail about cache
    usage in the next section, *Improving performance with a cache strategy and making
    the* *application resilient* .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存由应用程序的内存管理，因此，长时间在内存中保留缓存可能引起问题，但这是一种良好的做法。我们将在下一节中详细介绍缓存的使用，*通过缓存策略提高性能并使*
    *应用程序具有弹性* 。
- en: To further improve response performance, we can perform compression automatically
    with a few lines of code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高响应性能，我们可以通过几行代码自动执行压缩。
- en: 'For this purpose, we must add the **Microsoft.AspNetCore.ResponseCompression**
    NuGet package to the project. You can do this by typing the following command
    in your application’s project directory:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们必须将**Microsoft.AspNetCore.ResponseCompression** NuGet包添加到项目中。您可以在应用程序的项目目录中键入以下命令：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In any case, it is important that you understand how to use this functionality
    in your applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，了解如何在您的应用程序中使用此功能都很重要。
- en: 'After adding the NuGet package, we must add the compression services to the
    **Program.cs** file. When doing so, we have the following modified file taking
    into account caching and compression:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加NuGet包后，我们必须将压缩服务添加到 **Program.cs** 文件中。这样做时，我们得到以下修改后的文件，考虑到缓存和压缩：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code can be explained as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以这样解释：
- en: '**Add response** **compression middleware** :'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加响应** **压缩中间件** :'
- en: The **builder.Services.AddResponseCompression** method is used to add response
    compression services to the **Dependency Injection** ( **DI** ) container.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **builder.Services.AddResponseCompression** 方法将响应压缩服务添加到 **依赖注入**（**DI**）容器中。
- en: '**options.EnableForHttps** is set to **true** to enable compression for HTTPS
    responses.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options.EnableForHttps** 设置为 **true** 以启用HTTPS响应的压缩。'
- en: '**options.Providers.Add<GzipCompressionProvider>()** and **options.Providers.Add<BrotliCompressionProvider>()**
    are used to add support for **Gzip** and **Brotli** compression providers.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options.Providers.Add<GzipCompressionProvider>()** 和 **options.Providers.Add<BrotliCompressionProvider>()**
    用于添加对 **Gzip** 和 **Brotli** 压缩提供者的支持。'
- en: '**Configure** **compression options** :'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Configure** **compression options** :'
- en: '**builder.Services.Configure<GzipCompressionProvider** **Options>(options =>
    options.Level = System.IO.Compression.CompressionLevel.Fastest)** is used to configure
    the compression level for Gzip. You can adjust the compression level based on
    your needs ( **Optimal** , **Fastest** , or **NoCompression** ).'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Services.Configure<GzipCompressionProvider** **Options>(options =>
    options.Level = System.IO.Compression.CompressionLevel.Fastest)** 用于配置Gzip的压缩级别。你可以根据需要调整压缩级别（**Optimal**，**Fastest**
    或 **NoCompression**）。'
- en: '**Use middleware** :'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用中间件** :'
- en: '**app.UseResponseCompression()** adds the response compression middleware to
    the request pipeline.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**app.UseResponseCompression()** 将响应压缩中间件添加到请求管道中。'
- en: The order of middleware is important
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的处理顺序很重要
- en: When combining response caching and compression, the order of the middleware
    is important. Make sure compression middleware is included before caching middleware.
    This way, responses are compressed before being cached, ensuring that cached responses
    are already compressed and ready to be served efficiently.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合响应缓存和压缩时，中间件的顺序很重要。确保在缓存中间件之前包含压缩中间件。这样，响应在缓存之前被压缩，确保缓存响应已经压缩并准备好高效地提供服务。
- en: With these practices, you can reduce the size of responses, leading to better
    performance and faster loading times for users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些实践，你可以减小响应的大小，从而提高性能和加快用户的加载速度。
- en: The time has come to understand asynchronous requests in more detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是更详细地理解异步请求的时候了。
- en: Asynchronous requests and I/O optimization
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步请求和I/O优化
- en: Asynchronous programming is a fundamental aspect of modern web development,
    enabling non-blocking operations that improve application responsiveness and scalability.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是现代Web开发的基本方面，它使非阻塞操作成为可能，从而提高了应用程序的响应性和可伸缩性。
- en: The great complexity of asynchronous programming is abstracted by the resources
    available in C#, making applications and functionalities even more powerful. But
    to better understand the importance of this asynchronous process, let’s analyze
    the following example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程的复杂性被C#中可用的资源所抽象，使应用程序和功能更加强大。但要更好地理解这个异步过程的重要性，让我们分析以下示例。
- en: Imagine you are waiting in line at a coffee shop. If the barista had to wait
    for each cup of coffee to finish brewing before starting the next one, the line
    would move very slowly. Instead, the barista starts preparing the next drink while
    the previous one is being prepared. Similarly, asynchronous programming allows
    your application to start other tasks while waiting for a previous task to complete.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在咖啡店排队等候。如果咖啡师必须等待每杯咖啡完全煮好才开始下一杯，队伍会移动得非常慢。相反，咖啡师在准备下一杯饮料的同时开始准备前一杯。同样，异步编程允许你的应用程序在等待前一个任务完成时开始其他任务。
- en: Web applications can respond to a large number of requests from users at a given
    time. ASP.NET Core 9 is optimized enough to manage requests and memory efficiently.
    However, if you choose to use a synchronous approach, which is also possible,
    some problems may be caused. Let’s see how we can develop asynchronous methods.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序可以在给定时间内响应用户的大量请求。ASP.NET Core 9已经足够优化，能够高效地管理请求和内存。然而，如果你选择使用同步方法，这也是可能的，可能会引起一些问题。让我们看看我们如何开发异步方法。
- en: Use async and await keywords
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用async和await关键字
- en: In C#, the **async** and **await** keywords let you write asynchronous code
    that is easier to read and maintain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，`async` 和 `await` 关键字让您能够编写更易于阅读和维护的异步代码。
- en: 'For example, in the context of an ASP.NET Core application, using **async**
    and **await** allows your server to handle more requests simultaneously by not
    blocking threads during I/O operations, as demonstrated in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 ASP.NET Core 应用程序的情况下，使用 `async` 和 `await` 允许您的服务器在 I/O 操作期间不阻塞线程，从而同时处理更多请求，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s look at the details highlighted in the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码中突出显示的细节：
- en: '**async** : This is the keyword used to indicate that the method is asynchronous.
    When declaring an asynchronous method, it is mandatory to use at least one **await**
    keyword to perform asynchronous operations in the method body.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async** : 这是用于指示方法为异步的关键字。在声明异步方法时，必须在方法体中使用至少一个 `await` 关键字来执行异步操作。'
- en: '**Task<IActionResult>** : This specifies that the method returns a task that
    will eventually be completed with **IActionResult** . The **Task** type represents
    an asynchronous operation in C#. **IActionResult** is a common return type in
    ASP.NET Core MVC that represents the result of an action method. The return type
    could be any type of class or structure, for example, returning an integer such
    as **Task<int>** .'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Task<IActionResult>** : 这指定了该方法返回一个最终将以 `IActionResult` 完成的任务。`Task` 类型代表
    C# 中的异步操作。`IActionResult` 是 ASP.NET Core MVC 中的常见返回类型，它表示操作方法的返回结果。返回类型可以是任何类型的类或结构，例如，返回一个整数，如
    `Task<int>`。'
- en: '**await** : The **await** keyword is used to asynchronously wait for the **GetDataAsync**
    method to complete. This means that the method will return a task and execution
    will be paused until the task is completed, without blocking the thread.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await** : `await` 关键字用于异步等待 `GetDataAsync` 方法的完成。这意味着该方法将返回一个任务，并且执行将在任务完成之前暂停，而不会阻塞线程。'
- en: '**_dataService.GetDataAsync()** : This line calls an asynchronous **GetDataAsync**
    method on the **_dataService** object. **_dataService** is presumably an instance
    of a service class that handles data retrieval.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**_dataService.GetDataAsync()** : 这行代码在 `_dataService` 对象上调用异步 `GetDataAsync`
    方法。`_dataService` 可能是一个处理数据检索的服务类实例。'
- en: C# has several asynchronous methods and you can identify them by using the **async**
    suffix, added to the name of the methods as a convention.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有几个异步方法，您可以通过在方法名称中添加 `async` 后缀作为约定来识别它们。
- en: Asynchronous programming
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程
- en: 'Asynchronous programming in C# has several other details and ways of application,
    and it is not possible to consider them as part of this book. However, to continue
    your learning, I suggest this great content from Microsoft Learn: [https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/)
    .'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的异步编程有几个其他细节和应用方式，它们不能作为本书的一部分考虑。然而，为了继续您的学习，我建议您阅读 Microsoft Learn 上的这篇优秀内容：[https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/)。
- en: With some simple changes, using the features available in ASP.NET Core 9, we
    have the ability to implement asynchronous requests with some keywords.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 ASP.NET Core 9 中可用的功能，我们可以通过一些关键字实现异步请求。
- en: These resources can be used in conjunction, for example, with Entity Framework
    Core.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源可以结合使用，例如与 Entity Framework Core 一起使用。
- en: We can implement asynchronous data access using Entity Framework Core with methods
    such as **ToListAsync()** and **SaveChangesAsync()** .
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ToListAsync()` 和 `SaveChangesAsync()` 等方法使用 Entity Framework Core 实现异步数据访问。
- en: 'The asynchronous data access lets your application perform other operations
    while waiting for data from the database, as exemplified in the following code,
    where an asynchronous query is made to obtain all records from the **Customers**
    table through Entity Framework:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 异步数据访问允许您的应用程序在等待从数据库获取数据时执行其他操作，如下面的代码所示，其中通过 Entity Framework 对 `Customers`
    表执行异步查询以获取所有记录：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Consider the use of asynchronous programming in the design of your applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在应用程序设计中使用异步编程。
- en: Although the ASP.NET Core 9 platform provides us with several mechanisms to
    create robust applications, it is important to keep in mind that the use of best
    practices for HTTP requests, compression, and information caching, in addition
    to the asynchronous programming model, must be taken into consideration in all
    applications developed. This guarantees the best experience for users and integrated
    systems, in addition to ensuring that applications can be optimized enough to
    support large demands correctly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ASP.NET Core 9平台为我们提供了创建健壮应用程序的多种机制，但我们必须记住，在所有开发的应用程序中，除了异步编程模型外，还必须考虑HTTP请求、压缩和信息缓存的最佳实践。这保证了用户和集成系统的最佳体验，同时确保应用程序能够足够优化以正确支持大量需求。
- en: In the next section, we will see in more detail the use of caching strategies
    and how to make applications resilient.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地了解缓存策略的使用以及如何使应用程序具有弹性。
- en: Improving performance with a cache strategy and making the application resilient
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过缓存策略提高性能并使应用程序具有弹性
- en: In the *HTTP request best practices* subsection of the *Working with ASP.NET
    Core 9 best practices* section, we learned about some mechanisms capable of bringing
    several improvements to our applications. Some approaches were discussed, including
    a brief introduction to the use of caching.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Working with ASP.NET Core 9 best practices* 部分的 *HTTP request best practices*
    子部分中，我们了解了一些能够为我们的应用程序带来多项改进的机制。讨论了一些方法，包括对缓存使用的简要介绍。
- en: To expand our knowledge and add techniques to our robust application development
    model, we will explore the use of caching strategies and how to make our applications
    resilient, a fundamental requirement for modern solutions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们的知识并添加技术到我们健壮的应用程序开发模型中，我们将探讨缓存策略的使用以及如何使我们的应用程序具有弹性，这是现代解决方案的基本要求。
- en: Let’s start with first understanding the different types of caching strategies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从首先了解不同的缓存策略类型开始。
- en: Caching strategies
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存策略
- en: Caching is a powerful technique to improve application performance by storing
    frequently accessed data in a temporary storage location. This reduces the need
    to retrieve data from the original source repeatedly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一种强大的技术，通过在临时存储位置存储频繁访问的数据来提高应用程序性能。这减少了从原始数据源重复检索数据的需求。
- en: In the *Caching and compression* subsection, a code was demonstrated that enabled
    the application to manage a cache, adding functionality to ASP.NET Core 9 middleware,
    used during request processing. For this case, the **in-memory** cache strategy
    was used, which stores data in memory for quick access. This is suitable for small
    to medium-sized datasets that are frequently accessed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Caching and compression* 子部分中，演示了一段代码，使应用程序能够管理缓存，为ASP.NET Core 9中间件添加功能，该中间件在请求处理期间使用。在这种情况下，使用了
    **内存** 缓存策略，将数据存储在内存中以实现快速访问。这对于频繁访问的小到中等数据集是合适的。
- en: However, for more robust applications, another strategy called the **distributed
    cache** is necessary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更健壮的应用程序，另一种称为 **分布式缓存** 的策略是必要的。
- en: A distributed cache uses some type of resource specialized in distributed caching,
    such as Redis.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存使用某种专门用于分布式缓存的资源，例如Redis。
- en: '**Redis** is a powerful technology for large datasets or when running in a
    distributed environment.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis** 是一种用于大数据集或分布式环境运行时的强大技术。'
- en: What is Redis?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Redis？
- en: '**Remote DIctionary Server** ( **Redis** ) is an open source, in-memory data
    structure store. It is known for its high performance, flexibility, and support
    for diverse data structures.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程字典服务器** ( **Redis** ) 是一个开源的内存数据结构存储。它以其高性能、灵活性和对多种数据结构的支持而闻名。'
- en: Redis stores data in memory, which makes it extremely fast compared to disk-based
    databases, and also supports data persistence on disk periodically.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Redis将数据存储在内存中，这使得它与基于磁盘的数据库相比速度极快，并且还支持定期在磁盘上持久化数据。
- en: Redis’ persistence model is key/value, supporting data structures such as strings,
    hashes, lists, sets, sorted sets, bitmaps, HyperLogLogs, and geospatial indexes.
    This flexibility allows for diverse use cases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的持久化模型是键/值，支持字符串、散列、列表、集合、有序集合、位图、HyperLogLogs和地理空间索引等数据结构。这种灵活性允许有各种用例。
- en: 'Redis is a resource widely used by several applications; if you want to know
    more, go to this link: [https://redis.io/](https://redis.io/) .'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是多个应用程序广泛使用的资源；如果您想了解更多信息，请访问此链接：[https://redis.io/](https://redis.io/)。
- en: Several modern applications, hosted mainly in cloud environments, use Redis
    as a solution for distributed caching, in addition to being fully integrated with
    ASP.NET Core 9.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代应用程序，主要托管在云环境中，使用 Redis 作为分布式缓存的解决方案，同时完全集成到 ASP.NET Core 9 中。
- en: So that we can better understand how Redis works when integrated with ASP.NET
    Core 9, let’s implement an application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 Redis 与 ASP.NET Core 9 集成时的工作方式，让我们实现一个应用程序。
- en: It is important to take into account the requirements mentioned in the *Technical
    requirements* section. Let’s learn how to integrate Redis into our application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑 *技术要求* 部分中提到的要求。让我们学习如何将 Redis 集成到我们的应用程序中。
- en: Integrating Redis in our application
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中集成 Redis
- en: 'We will start by creating an application. Therefore, open the terminal in a
    directory of your choice and perform the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个应用程序。因此，在您选择的目录中打开终端，并执行以下步骤：
- en: 'Create a new ASP.NET Core 9 project by running the following commands:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个新的 ASP.NET Core 9 项目：
- en: '[PRE6]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the Redis cache package:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Redis 缓存包：
- en: '[PRE7]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, run the following command to open Visual Studio Code in the application
    directory:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以在应用程序目录中打开 Visual Studio Code：
- en: '[PRE8]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the **appsettings.json** file and change the content to the following
    code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **appsettings.json** 文件，将其内容更改为以下代码：
- en: '[PRE9]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding JSON defines a connection string for the Redis server that we
    will create later.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的 JSON 定义了我们稍后将要创建的 Redis 服务器的连接字符串。
- en: 'Open the **Program.cs** file and change all its contents with the following
    code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Program.cs** 文件，并将其所有内容更改为以下代码：
- en: '[PRE10]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should already be used to most of the code described previously. The **builder.Services.AddStackExchangeRedisCache**
    method adds the default required objects, as part of the added library **Microsoft.Extensions.Caching.StackExchangeRedis**
    , to manage the cache when configuring the DI container.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该已经熟悉了之前描述的大多数代码。**builder.Services.AddStackExchangeRedisCache** 方法添加了默认所需的对象，作为添加的库
    **Microsoft.Extensions.Caching.StackExchangeRedis** 的一部分，用于配置 DI 容器时管理缓存。
- en: 'We have two main configurations:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个主要的配置：
- en: '**options.Configuration** : This is where the connection address to the Redis
    server is provided'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options.Configuration**：这是提供连接 Redis 服务器地址的地方'
- en: '**options.InstanceName** : This is an optional parameter that defines a prefix
    for the cache keys'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options.InstanceName**：这是一个可选参数，用于定义缓存键的前缀'
- en: The foundation of the application has been configured, and now it’s time to
    implement a controller that will interact with Redis.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的基础配置已经完成，现在是时候实现一个将与 Redis 交互的控制器了。
- en: Working with cache in the controller class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器类中处理缓存
- en: 'To do this, still in Visual Studio Code, follow the following steps to create
    the controller:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，仍然在 Visual Studio Code 中，按照以下步骤创建控制器：
- en: If it does not exist, in the root of the project, create a folder named **Controllers**
    .
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不存在，请在项目的根目录下创建一个名为 **Controllers** 的文件夹。
- en: Add a class called **CacheController** in the **Controller** folder
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Controller** 文件夹中添加一个名为 **CacheController** 的类
- en: 'Modify all content of the previously created class with the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前创建的类的所有内容修改为以下代码：
- en: '[PRE11]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code creates an API called **Cache** containing **GET** and **POST**
    methods. Let’s analyze the important points of the code in more detail:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个名为 **Cache** 的 API，包含 **GET** 和 **POST** 方法。让我们更详细地分析代码中的重要点：
- en: '**Microsoft.Extensions.Caching.Distributed** : This is a namespace that references
    the NuGet package containing the dependencies necessary for handling the cache
    in the **CacheController** class.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft.Extensions.Caching.Distributed**：这是一个命名空间，引用了包含处理 **CacheController**
    类中缓存所需依赖项的 NuGet 包。'
- en: '**private readonly IDistributedCache _cache** : This is a private property
    of the class that abstracts a cache handling object.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private readonly IDistributedCache _cache**：这是类的一个私有属性，它抽象了一个缓存处理对象。'
- en: '**public CacheController(IDistributedCache cache)** : As a dependency, the
    class constructor has the **IDistributedCache** interface that will be injected
    by DI and assigns the instance to the class’s **_cache** property.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public CacheController(IDistributedCache cache)**：作为一个依赖项，类的构造函数具有 **IDistributedCache**
    接口，该接口将由 DI 注入，并将实例分配给类的 **_cache** 属性。'
- en: '**var cachedData = await _cache.GetStringAsync(key)** : During the execution
    of the **Get** method, the _ **cache** object, which abstracts a connection to
    the Redis server, will search for a string using the key and return it in the
    request; otherwise, it will return a **NotFound()** status.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**var cachedData = await _cache.GetStringAsync(key)**：在执行 **Get** 方法期间，抽象连接到
    Redis 服务器的 **_cache** 对象将使用键搜索字符串并在请求中返回它；否则，它将返回 **NotFound()** 状态。'
- en: '**Post** method: The **Post** method receives as a parameter an object of the
    **MyData** type, a class created at the end of the file. When obtaining the **MyData**
    object, the **Key** property will be used as the cache key, **var cacheKey = data.Key**
    . Then, the **MyData** object is serialized into JSON, **JsonSerializer.Serialize(data)**
    . Subsequently, an object of the **DistributedCacheEntryOptions** type is created,
    where expiration parameters for information in the cache are specified. Finally,
    the cache persisted in Redis by running **await_cache.SetStringAsync(cacheKey,**
    **serializedData, options)** .'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Post** 方法：**Post** 方法接收一个 **MyData** 类型的对象作为参数，该类在文件末尾创建。在获取 **MyData** 对象时，将使用
    **Key** 属性作为缓存键，**var cacheKey = data.Key**。然后，将 **MyData** 对象序列化为 JSON，**JsonSerializer.Serialize(data)**。随后，创建一个
    **DistributedCacheEntryOptions** 类型的对象，在其中指定缓存中信息的过期参数。最后，通过运行 **await_cache.SetStringAsync(cacheKey,**
    **serializedData, options)** 将缓存持久化到 Redis 中。'
- en: SetSlidingExpiration and SetAbsoluteExpiration
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: SetSlidingExpiration 和 SetAbsoluteExpiration
- en: The **.SetSlidingExpiration(TimeSpan.FromMinutes(5))** and **.SetAbsoluteExpiration(TimeSpan.FromHours(1))**
    methods are used to configure cache entry expiration options in **DistributedCacheEntryOptions**
    . These methods help manage how long the cached data should be kept in the cache.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **DistributedCacheEntryOptions** 中使用 **.SetSlidingExpiration(TimeSpan.FromMinutes(5))**
    和 **.SetAbsoluteExpiration(TimeSpan.FromHours(1))** 方法来配置缓存条目过期选项。这些方法有助于管理缓存数据应在缓存中保留多长时间。
- en: '**SlidingExpiration** specifies the amount of time a cache entry can be inactive
    (not accessed) before it is removed from the cache. The expiration time is reset
    every time the cache entry is accessed.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**SlidingExpiration** 指定了缓存条目在从缓存中移除之前可以不活跃（未访问）的时间量。每次访问缓存条目时，过期时间都会重置。'
- en: '**AbsoluteExpiration** specifies the maximum time a cache entry should be kept
    in the cache, regardless of how often it is accessed. The cache entry will be
    removed from the cache after the specified time has elapsed, no matter how many
    times it has been accessed.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**AbsoluteExpiration** 指定了缓存条目在缓存中应保留的最大时间，无论其访问频率如何。缓存条目将在指定时间过后从缓存中移除，无论其被访问了多少次。'
- en: 'With the application developed, we must create a Redis server, and for this,
    we will use Docker to run it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发完成后，我们必须创建一个 Redis 服务器，为此，我们将使用 Docker 来运行它：
- en: 'In the application directory, open the terminal and run the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序目录中，打开终端并运行以下命令：
- en: '[PRE12]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If this is your first time running Redis on your machine, wait for it to download
    and then the server will start.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这是您第一次在您的机器上运行 Redis，请等待它下载，然后服务器将启动。
- en: 'Still in the application terminal, use the following command to run it:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在应用程序终端中，使用以下命令来运行它：
- en: '[PRE13]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After running the application, open Postman and create a new request by accessing
    the **File** | **New** **Tab** menu.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序运行后，打开 Postman 并通过访问 **File** | **New** **Tab** 菜单创建一个新的请求。
- en: 'Then, define the request type as **GET** , and in the URL field, enter the
    URL made available in the terminal after executing the application with the suffix
    **/api/Cache/DataInCache** . *Figure 7* *.1* demonstrates an example of the request
    configuration:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将请求类型定义为 **GET**，并在 URL 字段中输入执行应用程序后终端提供的带有后缀 **/api/Cache/DataInCache**
    的 URL。*图 7.1* *.1* 展示了请求配置的一个示例：
- en: '![Figure 7.1 – Configuring the API request on Postman](img/B21788_07_1.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 在 Postman 上配置 API 请求](img/B21788_07_1.jpg)'
- en: Figure 7.1 – Configuring the API request on Postman
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 在 Postman 上配置 API 请求
- en: API URL port
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: API URL 端口
- en: The number **5277** added to the URL shown in *Figure 7* *.1* represents the
    API execution port. This value may vary from environment to environment. Make
    sure to enter the execution port available in your terminal after executing the
    **docker** **run** command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7.1* *.1* 中显示的 URL 中添加的数字 **5277** 代表 API 执行端口。此值可能因环境而异。请确保在执行 **docker**
    **run** 命令后输入您终端中可用的执行端口。
- en: 'The **DataInCache** value represents the key we want to get the cached value
    from. However, when clicking on the **Send** button in Postman, we have the following
    return ( *Figure 7* *.2* ):'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DataInCache** 值表示我们想要从缓存中获取值的键。然而，当在 Postman 中点击 **发送** 按钮时，我们会得到以下返回（*图
    7.2*）：'
- en: '![Figure 7.2 – Requesting data in cache](img/B21788_07_2.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 缓存中请求数据](img/B21788_07_2.jpg)'
- en: Figure 7.2 – Requesting data in cache
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 缓存中请求数据
- en: As shown in *Figure 7* *.2* , the HTTP status and JSON return in the response
    body represent the **404** not found state.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 7.2* 所示，响应体中的 HTTP 状态和 JSON 返回表示 **404** 未找到状态。
- en: The API return is correct, as the **GET** method tries to obtain a value from
    the cache, and if not found, an HTTP status of **404** is returned.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: API 返回是正确的，因为 **GET** 方法试图从缓存中获取值，如果没有找到，则返回 HTTP 状态 **404**。
- en: 'Still in Postman, open a new tab ( **File** | **New Tab** ), set the request
    type as **POST** , and define the API URL with the following suffix: **/api/Cache**
    .'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 Postman 中，打开一个新标签页（**文件** | **新建标签页**），将请求类型设置为 **POST**，并使用以下后缀定义 API URL：**/api/Cache**。
- en: 'Then, click **Body** , select the **raw** option, and add the following JSON:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **正文**，选择 **raw** 选项，并添加以下 JSON：
- en: '[PRE14]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The entire configuration of this request is demonstrated in *Figure 7* *.3*
    :'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个请求的配置在 *图 7.3* 中演示：
- en: '![Figure 7.3 – Post request configuration](img/B21788_07_3.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 发起请求的配置](img/B21788_07_3.jpg)'
- en: Figure 7.3 – Post request configuration
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 发起请求的配置
- en: The **POST** request, demonstrated in *Figure 7* *.3* , will make a call to
    the API’s **POST** method, which will add the value defined in the request body
    to the Redis cache.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST** 请求，如 *图 7.3* 所示，将调用 API 的 **POST** 方法，该方法将请求体中定义的值添加到 Redis 缓存中。'
- en: Click the **Send** button to make the request and you should receive the HTTP
    **201** status code in return, indicating that the information was created in
    the cache.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **发送** 按钮发起请求，你应该会收到 HTTP **201** 状态码作为回应，表示信息已在缓存中创建。
- en: If you want to confirm the cached value, in Postman, open the previous tab containing
    the **GET** request and you should receive the HTTP **200** status code in return,
    along with the JSON object that represents the cached data.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想确认缓存的值，在 Postman 中打开包含 **GET** 请求的先前标签页，你应该会收到 HTTP **200** 状态码作为回应，以及表示缓存数据的
    JSON 对象。
- en: Another way to check the values available in the Redis cache is to use a UI
    tool such as Redis Insight, mentioned in the *Technical requirements* section,
    which we’ll configure now.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检查 Redis 缓存中可用值的方法是使用 UI 工具，如 *技术要求* 部分中提到的 Redis Insight，我们现在将进行配置。
- en: Configuring Redis Insight
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Redis Insight
- en: 'Let’s configure Redis Insight to connect to the Redis server running on Docker
    by following these steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置 Redis Insight 以连接到在 Docker 上运行的 Redis 服务器：
- en: 'On the application’s main screen, click on the **Add connection details manually**
    option, as shown in *Figure 7* *.4* :'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的主屏幕上，点击 **手动添加连接详情** 选项，如图 *图 7.4* 所示：
- en: '![Figure 7.4 – Configuring the Redis connection](img/B21788_07_4.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 配置 Redis 连接](img/B21788_07_4.jpg)'
- en: Figure 7.4 – Configuring the Redis connection
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 配置 Redis 连接
- en: 'On the next screen, we must add the connection parameters to the Redis server.
    As this server is running through Docker, the default parameters will be used,
    already available on the screen:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，我们必须将连接参数添加到 Redis 服务器。由于此服务器通过 Docker 运行，默认参数将被使用，已在屏幕上可用：
- en: '**Host** : This defines the Redis server address.'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：这定义了 Redis 服务器的地址。'
- en: '**Port** : This defines the server execution port.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：这定义了服务器执行端口。'
- en: '**Other parameters** : Not important at this time. However, in productive environments,
    the host address, port, user, and password may be different and necessary.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他参数**：目前不重要。然而，在生产环境中，主机地址、端口、用户和密码可能不同且是必要的。'
- en: For our example, just keep the default values and click the **+ Add Redis**
    **database** button.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的示例，只需保留默认值并点击 **+ 添加 Redis 数据库** 按钮。
- en: 'Once the connection is created, the list of servers connected to Redis Insights
    will be displayed, as shown in *Figure 7* *.5* :'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦连接创建成功，连接到 Redis Insights 的服务器列表将显示，如图 *图 7.5* 所示：
- en: '![Figure 7.5 – Connected Redis cache in the Redis Insight tool](img/B21788_07_5.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – Redis Insight 工具中的连接 Redis 缓存](img/B21788_07_5.jpg)'
- en: Figure 7.5 – Connected Redis cache in the Redis Insight tool
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – Redis Insight 工具中的连接 Redis 缓存
- en: 'Click on the created connection displayed in the list of connections. Then,
    click on the magnifying glass icon, as highlighted in *Figure 7* *.6* , to view
    the data available in the cache:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示在连接列表中的创建的连接。然后，点击如图 *7.6* 所示的放大镜图标，查看缓存中的数据：
- en: '![Figure 7.6 – List of data in the cache](img/B21788_07_6.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 缓存中的数据列表](img/B21788_07_6.jpg)'
- en: Figure 7.6 – List of data in the cache
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 缓存中的数据列表
- en: If you cannot view any information when clicking the magnifying glass icon,
    it means that the previously added key has expired. In this case, just make another
    **POST** request to add another key and view it in Redis Insight.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击放大镜图标时无法查看任何信息，这意味着之前添加的键已过期。在这种情况下，只需再次进行 **POST** 请求添加另一个键，并在 Redis Insight
    中查看它。
- en: This is a simple example created so that we can learn how to communicate with
    the cache and add information to memory. In this case, we are using Redis, a powerful
    distributed data management resource, as a server for the information that will
    be kept in memory.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，目的是让我们学习如何与缓存通信并向内存中添加信息。在这种情况下，我们使用 Redis，一个强大的分布式数据管理资源，作为将保存在内存中的信息的服务器。
- en: In real scenarios, this approach can be used in conjunction with a database.
    This way, before executing a request to the database, the existence of information
    in the cache will be checked. If it exists, it will not be necessary to make a
    call to the database, optimizing processes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，这种方法可以与数据库结合使用。这样，在向数据库发送请求之前，会检查缓存中是否存在信息。如果存在，则不需要调用数据库，从而优化过程。
- en: As we learned, caching is a powerful solution for making our applications more
    performant and available.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，缓存是一种强大的解决方案，可以使我们的应用程序性能更优、更可用。
- en: Now that we have learned how to quickly retrieve information from a cache server,
    we will understand how to make our applications more resilient in the next topic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何快速从缓存服务器检索信息，我们将了解如何在下一主题中使我们的应用程序更具弹性。
- en: Resilience mechanisms
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性机制
- en: To build robust applications, it is essential to implement resilience mechanisms
    that deal with transient failures and ensure continuous availability.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建健壮的应用程序，实施处理暂时性故障并确保持续可用性的弹性机制至关重要。
- en: Think of resilience mechanisms as safety nets that catch us if something goes
    wrong. They help your application recover from unexpected crashes and maintain
    a smooth user experience.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将弹性机制视为安全网，如果出现问题，它们会捕捉我们。它们帮助您的应用程序从意外的崩溃中恢复，并保持流畅的用户体验。
- en: 'The most common resilience strategies are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的弹性策略如下：
- en: '**Retry pattern** : Automatically retries a failed operation a specified number
    of times before giving up. This is useful for dealing with transient faults.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试模式**：在放弃之前，自动重试指定次数的失败操作。这对于处理暂时性故障很有用。'
- en: '**Circuit breaker pattern** : Prevents an application from performing an operation
    that is likely to fail. It stops the flow of requests to a service when a failure
    is detected, allowing the system to recover.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器模式**：防止应用程序执行可能失败的操作。当检测到故障时，它停止对服务的请求流，使系统有机会恢复。'
- en: In order to have the ability to implement these patterns in our applications,
    we will use a library called **Polly** .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中实现这些模式，我们将使用一个名为 **Polly** 的库。
- en: Polly
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Polly
- en: Polly is a library that is part of the .NET Foundation used to add various resilience
    features to applications. It is constantly updated by the open source community
    and used in various applications in production environments. To learn more about
    Polly, go to [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)
    .
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Polly 是一个库，它是 .NET 基金会的一部分，用于向应用程序添加各种弹性功能。它由开源社区不断更新，并在生产环境中的各种应用程序中使用。要了解更多关于
    Polly 的信息，请访问 [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)
    。
- en: 'To use Polly in our applications, we just need to add it to the project through
    the following command executed in the application’s project directory:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用 Polly，我们只需通过在应用程序的项目目录中执行以下命令将其添加到项目中：
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s analyze the implementation of the retry strategy in the following code
    example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下代码示例中重试策略的实现：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see in the preceding code, the implementation process is quite simple
    and integrates with the ASP.NET Core 9 development model. In this example, the
    objective is to obtain data from a service in a resilient way. Let’s analyze the
    main points of the implementation:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，实现过程相当简单，并集成了ASP.NET Core 9开发模型。在这个例子中，目标是以弹性的方式从服务中获取数据。让我们分析实现的主要点：
- en: '**var retryPolicy = Policy.Handle<Exception>().RetryAsync(3)** aims to create
    a retry policy. In this case, the policy is related to an exception. During execution,
    if an exception is identified, the request will be made again. Trials were configured
    to run a maximum of three times.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**var retryPolicy = Policy.Handle<Exception>().RetryAsync(3)**旨在创建一个重试策略。在这种情况下，策略与异常相关。在执行过程中，如果检测到异常，请求将再次进行。试验被配置为最多运行三次。'
- en: The **return await retryPolicy.ExecuteAsync** command is a method that executes
    an action using the previously configured retry policy. All code executing the
    **GetDataAsync** method request is defined within the scope of the policy that
    automatically manages the retry mechanism.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**return await retryPolicy.ExecuteAsync**命令是一个使用先前配置的重试策略执行动作的方法。所有执行**GetDataAsync**方法请求的代码都定义在自动管理重试机制的策略范围内。'
- en: It is very common to use the retry strategy when consuming external APIs. There
    may be intermittences or momentary unavailability and, in this case, **retry**
    helps to guarantee greater resilience in cases of momentary unavailability.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用外部API时，使用重试策略是非常常见的。可能会有间歇性或暂时不可用的情况，在这种情况下，**重试**可以帮助在暂时不可用的情况下保证更大的弹性。
- en: 'Let’s look at an example of implementing the circuit breaker strategy:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现断路器策略的一个示例：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s look at the details of the preceding code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面代码的细节：
- en: '**CircuitBreakerAsync** : This method creates an asynchronous circuit breaker
    policy.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CircuitBreakerAsync**：此方法创建一个异步断路器策略。'
- en: The circuit breaker will open (break the circuit) after three consecutive exceptions
    (faults).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器在连续三次异常（故障）后将会打开（断开电路）。
- en: '**TimeSpan.FromMinutes(1)** : Once the circuit is open, it will remain open
    for one minute. During this time, any attempt to perform the action will immediately
    throw **BrokenCircuitException** without performing the action.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TimeSpan.FromMinutes(1)**：一旦电路打开，它将保持打开状态一分钟。在此期间，任何尝试执行动作的行为将立即抛出**BrokenCircuitException**，而不执行动作。'
- en: 'The circuit breaker has the following states:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断路器有以下状态：
- en: '**Closed** : The normal state where all calls are allowed.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：所有调用都被允许的正常状态。'
- en: '**Open** : The state in which calls are blocked after a specified number of
    consecutive failures.'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开**：在指定数量的连续失败后调用被阻止的状态。'
- en: '**Half-open** : After the open period, the circuit breaker allows a limited
    number of test calls to verify that the underlying problem has been resolved.
    If these calls are successful, the circuit returns to the closed state. If they
    fail, the circuit returns to the open state.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开**：在打开期间之后，断路器允许有限数量的测试调用以验证底层问题是否已解决。如果这些调用成功，电路将返回到关闭状态。如果它们失败，电路将返回到打开状态。'
- en: '**circuitBreakerPolicy.ExecuteAsync** : This method executes the given asynchronous
    delegate (the code block inside) under the control of the circuit breaker policy.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**circuitBreakerPolicy.ExecuteAsync**：此方法在断路器策略的控制下执行给定的异步委托（代码块内部）。'
- en: If the **_dataService.GetDataAsync()** call succeeds, the method returns the
    data wrapped in an **OkObjectResult** (HTTP **200** response).
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**_dataService.GetDataAsync()**调用成功，该方法将返回包裹在**OkObjectResult**（HTTP **200**
    响应）中的数据。
- en: 'If the **_dataService.GetDataAsync()** call throws an exception, the circuit
    breaker policy handles it:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**_dataService.GetDataAsync()**调用抛出异常，断路器策略将处理它：
- en: If fewer than three exceptions have occurred consecutively, the circuit breaker
    remains closed, and the exception is propagated.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果连续发生的异常少于三次，断路器保持关闭状态，异常将被传播。
- en: After three consecutive exceptions, the circuit breaker opens for one minute.
    Any further calls within this period will immediately throw **BrokenCircuitException**
    .
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在连续三次异常之后，断路器打开一分钟。在此期间内的任何进一步调用将立即抛出**BrokenCircuitException**。
- en: The circuit breaker policy helps prevent repeated failures from overloading
    the system by interrupting the circuit after three consecutive failures and keeping
    it open for one minute. During this period, any attempt to call the data service
    will result in an immediate exception without attempting to execute the service
    call. This allows the system to recover and prevents cascading failures in dependent
    systems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器策略通过在连续三次失败后中断电路并保持开启一分钟来帮助防止系统过载导致的重复失败。在此期间，任何尝试调用数据服务的操作都将立即抛出异常，而不会尝试执行服务调用。这允许系统恢复，并防止依赖系统的级联失败。
- en: 'The circuit breaker and retry strategies are powerful resilience strategies
    that, despite appearing similar, have different objectives, as shown in *Table
    7.1* :'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器和重试策略是强大的弹性策略，尽管它们看起来相似，但有不同的目标，如*表 7.1* 所示：
- en: '| **Aspect** | **Circuit Breaker** | **Retry** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **方面** | **断路器** | **重试** |'
- en: '| Purpose | Prevent overwhelming a failing service | Handle transient faults
    by retrying |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 防止过载失败的服务 | 通过重试处理瞬态故障 |'
- en: '| Behavior | Stops requests after a certain number of failures and opens the
    circuit for a specified time | Retries the operation a specified number of times
    with a delay between retries |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 行为 | 在一定数量的失败后停止请求并开启电路一段时间 | 在重试之间有延迟的情况下重试指定次数的操作 |'
- en: '| States | Closed, open, half-open | No states, just retries |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 关闭、开启、半开启 | 无状态，仅重试 |'
- en: '| Failure Handling | Fails fast once the circuit is open | Retries multiple
    times before failing |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 失败处理 | 断路器开启后快速失败 | 在失败前多次重试 |'
- en: '| When to Use | When repeated failures need to be avoided to protect a system
    | When temporary faults are expected to be resolved with retries |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 使用场景 | 需要避免重复失败以保护系统 | 预期临时故障可以通过重试解决 |'
- en: '| Complexity | Higher, with state transitions and monitoring | Lower, with
    simple retry logic |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 复杂度 | 较高，具有状态转换和监控 | 较低，具有简单的重试逻辑 |'
- en: '| Feedback to Users | Immediate failure feedback when the circuit is open |
    Delayed feedback after all retries fail |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 用户反馈 | 断路器开启时的即时失败反馈 | 所有重试失败后的延迟反馈 |'
- en: Table 7.1 –The circuit breaker and retry objectives
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 – 断路器和重试目标
- en: In practice, these patterns are often used together to provide a robust fault-handling
    mechanism. For example, you can use a retry policy to handle transient failures,
    and if the attempts consistently fail, the circuit breaker can be used to prevent
    retries and allow the system to recover.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这些模式通常一起使用，以提供强大的故障处理机制。例如，您可以使用重试策略来处理瞬态故障，如果尝试持续失败，则可以使用断路器来防止重试并允许系统恢复。
- en: Polly offers several other resilience mechanisms that can be combined to make
    applications even more powerful.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Polly 提供了其他几种弹性机制，可以组合使用，使应用程序更加强大。
- en: The use of these strategies greatly contributes to the creation of robust solutions
    prepared for large-scale execution models, especially in cloud environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略的使用极大地促进了创建为大规模执行模型准备的强大解决方案，尤其是在云环境中。
- en: In any case, even by adding several mechanisms to avoid failures, they may arise.
    In this case, we must be able to obtain sufficient information to make corrections
    and keep applications free from non-conformities. For this, it is important to
    add logs in applications, and ASP.NET Core 9 provides a powerful mechanism for
    this, which we will learn about in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，即使添加了多个机制来避免失败，它们仍然可能发生。在这种情况下，我们必须能够获取足够的信息来做出纠正，并确保应用程序不受非一致性影响。为此，在应用程序中添加日志非常重要，ASP.NET
    Core 9 提供了强大的机制来实现这一点，我们将在下一节中了解。
- en: Understanding and implementing logging and monitoring
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现记录和监控
- en: Having optimized performance and resilience, we now turn to logging and monitoring,
    essential practices for maintaining and troubleshooting your ASP.NET Core 9 applications.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化性能和弹性之后，我们现在转向记录和监控，这是维护和调试 ASP.NET Core 9 应用程序的基本实践。
- en: Introduction to logging and monitoring
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录和监控简介
- en: Logging and monitoring are crucial to understanding your application’s behavior,
    diagnosing problems, and ensuring it runs smoothly. Logs provide visibility into
    application processes and help detect anomalies early.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 记录和监控对于理解应用程序的行为、诊断问题和确保其平稳运行至关重要。日志提供了对应用程序过程的可见性，并有助于早期检测异常。
- en: Think of logging like keeping a diary and monitoring like installing surveillance
    cameras in your home. The diary helps you remember past events, while the cameras
    let you see what’s happening in real time, maintaining safety and order.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志记录想象成记日记，将监控想象成在家安装监控摄像头。日记帮助您记住过去的事件，而摄像头让您能够实时看到正在发生的事情，保持安全和秩序。
- en: Logging with ILogger
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ILogger 进行日志记录
- en: .NET provides abstractions that allow ASP.NET Core 9 applications to handle
    different logging strategies. The **ILogger** and **ILoggerFactory** interfaces,
    provided by the **Microsoft.Extensions.Logging** namespace, are essential for
    implementing logging in your applications, allowing you to capture and record
    information about the operation of the application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了抽象，允许 ASP.NET Core 9 应用程序处理不同的日志策略。由 **Microsoft.Extensions.Logging**
    命名空间提供的 **ILogger** 和 **ILoggerFactory** 接口对于在您的应用程序中实现日志记录至关重要，它允许您捕获和记录有关应用程序操作的信息。
- en: Logging provides insights into the behavior of your application and is essential
    for debugging and monitoring.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录提供了对应用程序行为的洞察，对于调试和监控至关重要。
- en: 'The **ILogger** interface in ASP.NET Core allows you to log information at
    various levels of details as described in the following points:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的 **ILogger** 接口允许您以以下各点所述的详细程度记录信息：
- en: '**Trace** : Detailed information, typically of interest only when diagnosing
    problems'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trace** : 详细信息，通常仅在诊断问题时才有兴趣。'
- en: '**Debug** : Information useful for debugging the application'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Debug** : 对调试应用程序有用的信息。'
- en: '**Information** : Informational messages that highlight the progress of the
    application'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Information** : 强调应用程序进度的信息性消息。'
- en: '**Warning** : Potentially harmful situations that are not errors'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Warning** : 可能有害但不是错误的情况。'
- en: '**Error** : Errors that prevent the application from performing a function'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Error** : 阻止应用程序执行功能的错误。'
- en: '**Critical** : Critical errors causing complete failure of the application'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Critical** : 导致应用程序完全失败的严重错误。'
- en: 'The **ILogger** interface provides some useful methods:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**ILogger** 接口提供了一些有用的方法：'
- en: '**Log methods** :'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Log methods** :'
- en: '**Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception,
    Func<TState, Exception, string> formatter)** : The core method to log messages.
    It allows you to specify the log level, event ID, state, exception, and a formatter
    function.'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception,
    Func<TState, Exception, string> formatter)** : 记录消息的核心方法。它允许您指定日志级别、事件 ID、状态、异常和一个格式化函数。'
- en: '**Convenience methods** :'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Convenience methods** :'
- en: '**LogTrace(string message, params object[] args)** : Logs a trace message.'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogTrace(string message, params object[] args)** : 记录一个跟踪消息。'
- en: '**LogDebug(string message, params object[] args)** : Logs a debug message.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogDebug(string message, params object[] args)** : 记录一个调试消息。'
- en: '**LogInformation(string message, params object[] args)** : Logs an informational
    message.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogInformation(string message, params object[] args)** : 记录一个信息消息。'
- en: '**LogWarning(string message, params object[] args)** : Logs a warning message.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogWarning(string message, params object[] args)** : 记录一个警告消息。'
- en: '**LogError(string message, params object[] args)** : Logs an error message.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogError(string message, params object[] args)** : 记录一个错误消息。'
- en: '**LogCritical(string message, params object[] args)** : Logs a critical error
    message.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogCritical(string message, params object[] args)** : 记录一个严重错误消息。'
- en: '**Scope Method** :'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scope Method** :'
- en: '**BeginScope<TState>(TState state)** : This method starts a logical operation
    scope. It returns an **IDisposable** interface that ends the scope on disposal.
    Scopes are useful for correlating a set of operations with a common context.'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BeginScope<TState>(TState state)** : 此方法开始一个逻辑操作范围。它返回一个 **IDisposable**
    接口，在处置时结束范围。范围对于将一组操作与一个共同上下文相关联非常有用。'
- en: 'The following is an example of using the **ILogger** interface:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 **ILogger** 接口的示例：
- en: '[PRE18]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The previous code uses several methods provided by the **ILogger** interface:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用了 **ILogger** 接口提供的几个方法：
- en: '**ILogger<MyService> _logger** : This declares a private **readonly** field,
    **_logger** , of the **ILogger<MyService>** type. The **ILogger<T>** interface
    is part of the .NET logging infrastructure, where **T** is the type that is being
    logged. By specifying **MyService** , the logger is associated with this class,
    which helps in identifying where the log messages are coming from.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ILogger<MyService> _logger** : 这声明了一个私有 **readonly** 字段，**_logger**，其类型为
    **ILogger<MyService>**。**ILogger<T>** 接口是 .NET 日志记录基础设施的一部分，其中 **T** 是正在记录的类型。通过指定
    **MyService**，记录器与这个类相关联，这有助于识别日志消息的来源。'
- en: '**MyService(ILogger<MyService> logger)** : The **ILogger<MyService>** instance
    is typically provided via dependency injection. This allows the logging infrastructure
    to be configured and managed centrally.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MyService(ILogger<MyService> logger)**：**ILogger<MyService>** 实例通常通过依赖注入提供。这允许集中配置和管理日志基础设施。'
- en: '**_logger.LogInformation("Starting work.")** : Log the information type with
    the string **Starting work** .'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**_logger.LogInformation("Starting work.")**：记录信息类型，字符串为 **Starting work**。'
- en: '**_logger.LogError(ex, "An error occurred while doing work.")** : Log the information
    type with the string **An error occurred while** **doing work** .'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**_logger.LogError(ex, "An error occurred while doing work.")**：记录信息类型，字符串为
    **An error occurred while** **doing work**。'
- en: The **ILogger** interface offers a powerful abstraction for logging your application’s
    execution data in a technology-agnostic manner, facilitating maintenance and extensibility.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**ILogger** 接口提供了一种强大的抽象方式，以技术无关的方式记录应用程序的执行数据，从而便于维护和扩展。'
- en: Another powerful abstraction mechanism available in .NET is **ILoggerFactory**
    .
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中可用的另一个强大抽象机制是 **ILoggerFactory**。
- en: The **ILoggerFactory** interface is responsible for creating **ILogger** instances.
    It is generally used to create loggers for specific categories or to configure
    logging providers and settings.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**ILoggerFactory** 接口负责创建 **ILogger** 实例。它通常用于为特定类别创建日志记录器或配置日志提供者和设置。'
- en: 'The main methods are as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 主要方法如下：
- en: '**CreateLogger(string categoryname)** : Creates an **ILogger** instance for
    the specified category. The category is usually the name of the class or component
    that the logger is associated with.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CreateLogger(string categoryname)**：为指定的类别创建一个 **ILogger** 实例。类别通常是日志记录器关联的类或组件的名称。'
- en: '**AddProvider (ILoggerProvider provider)** : Adds **ILoggerProvider** to the
    factory. This method is used to configure where and how log messages are sent,
    such as to the console, a file, or a remote log service.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AddProvider (ILoggerProvider provider)**：将 **ILoggerProvider** 添加到工厂中。此方法用于配置日志消息的发送位置和方式，例如发送到控制台、文件或远程日志服务。'
- en: '**To discard()** : Discards the logger factory and all loggers it created.
    Typically used to release any resources held by log providers.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**To discard()**：丢弃日志工厂及其创建的所有日志记录器。通常用于释放日志提供者持有的任何资源。'
- en: 'We can use the **ILoggerFactory** interface as in the following example of
    code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **ILoggerFactory** 接口，如下面的代码示例所示：
- en: '[PRE19]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The big difference between using the **ILoggerFactory** interface and the **ILogger**
    interface is the creation of a new category of logs that will be used to group
    the application’s log messages. The constructor receives an **ILoggerFactory**
    instance via dependency injection and then an **ILogger** instance is created
    for the **MyService** class. In this case, all log messages of this class will
    be grouped by the **MyService** category.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **ILoggerFactory** 接口和 **ILogger** 接口之间的主要区别是创建一个新类别的日志，该日志将用于分组应用程序的日志消息。构造函数通过依赖注入接收一个
    **ILoggerFactory** 实例，然后为 **MyService** 类创建一个 **ILogger** 实例。在这种情况下，此类的所有日志消息都将按
    **MyService** 类别分组。
- en: '**ILoggerFactory** allows for centralized configuration of logging settings.
    This means you can set up logging providers, filters, and other settings in one
    place, typically during application startup, and apply these configurations across
    all loggers created by the factory. You can also dynamically create loggers for
    different categories or components within your application. This is useful for
    associating log messages with specific parts of the application, making it easier
    to filter and analyze logs.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**ILoggerFactory** 允许集中配置日志设置。这意味着您可以在一个地方设置日志提供者、过滤器和其他设置，通常在应用程序启动期间，并将这些配置应用于工厂创建的所有日志记录器。您还可以动态地为应用程序中的不同类别或组件创建日志记录器。这对于将日志消息与特定应用程序部分关联起来非常有用，使得过滤和分析日志更加容易。'
- en: Logs work with providers, which are different sources where the logs will be
    made available. An application may contain different types of providers for each
    purpose.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 日志与提供者一起工作，提供者是日志将可用的不同来源。应用程序可能包含针对每个目的的不同类型的提供者。
- en: Each provider is centrally configured during application startup. This way,
    the **ILogger** and **ILoggerFactory** abstractions will use the configured providers
    for submitting the logs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 每个提供者在应用程序启动期间集中配置。这样，**ILogger** 和 **ILoggerFactory** 抽象将使用配置的提供者提交日志。
- en: There are several types of providers that can be used in ASP.NET Core 9, such
    as providers for writing to the console, adding debug information, and even providers
    for writing logs to external services such as Azure Application Insights and Elasticsearch,
    among others.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 9中可以使用几种类型的提供程序，例如用于写入控制台、添加调试信息的提供程序，甚至用于将日志写入外部服务（如Azure Application
    Insights和Elasticsearch）等提供程序。
- en: 'Let’s look at an example of log settings in the following code from a **Program.cs**
    class:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中关于日志设置的示例，这段代码来自**Program.cs**类：
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see in the preceding code example, different providers were added
    for writing logs. This means that when using a method such as **_logger.LogInformation**
    , **_logger.LogError** , these logs will be distributed to the configured providers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码示例所示，添加了不同的日志提供程序。这意味着当使用类似于**_logger.LogInformation**、**_logger.LogError**的方法时，这些日志将被分发到配置的提供程序。
- en: Logs are a powerful tool, essential in any application, helping to detect failures
    and even optimize systems.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是一种强大的工具，在任何应用程序中都是必不可少的，它有助于检测故障甚至优化系统。
- en: In [*Chapter 8*](B21788_08.xhtml#_idTextAnchor132) , we will explore the use
    of logs in conjunction with middleware.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B21788_08.xhtml#_idTextAnchor132)中，我们将探讨与中间件结合使用日志的方法。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: During this chapter, we learned about implementing best practices in ASP.NET
    Core 9, working correctly with HTTP requests, adding comprehension to responses,
    and understanding the use of caching to bring better performance and resilience
    to applications. We also understood the concepts related to asynchronous requests
    and how we can use this approach in ASP.NET Core applications through the use
    of the **async** and **await** keywords. Finally, we learned about the importance
    of using application monitoring, taking advantage of internal mechanisms that
    abstract writing and logs, such as the use of the **ILogger** and **ILoggerFactory**
    classes, allowing us to have enough inputs to fix inconsistencies in applications
    and optimize them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在ASP.NET Core 9中实施最佳实践，正确处理HTTP请求，增强响应的可理解性，以及理解使用缓存以提高应用程序性能和弹性的方法。我们还了解了与异步请求相关的概念，以及我们如何通过使用**async**和**await**关键字在ASP.NET
    Core应用程序中采用这种方法。最后，我们学习了使用应用程序监控的重要性，利用内部机制抽象编写和日志，例如使用**ILogger**和**ILoggerFactory**类，使我们能够获得足够的输入来修复应用程序中的不一致性并优化它们。
- en: In the next chapter, we will learn how to expand the request pipeline of ASP.NET
    Core 9 applications through the use of middleware.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过使用中间件来扩展ASP.NET Core 9应用程序的请求管道。
