<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-81"><a id="_idTextAnchor083"/>2. Building Quality Object-Oriented Code</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">In this chapter, you will learn how to simplify complex logic using Object-Oriented Programming (OOP). You will start by creating classes and objects, before exploring the four pillars of OOP. You will then learn about some of the best practices in coding, known as the SOLID principles, and see how you can use C# 10 features to write effective code guided by these principles. By the end of this chapter, you will be able to write clean code using object-oriented design with C#.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor084"/>Introduction</h1>
<p>How do people write software that is still maintainable even after many decades? What is the best way to model software around real-world concepts? The answer to both questions is Object Oriented Programming (OOP). OOP is a widely used paradigm in professional programming and is especially useful in enterprise settings.</p>
<p>OOP can be thought of as a bridge that connects real-world concepts and source code. A cat, for example, has certain defining properties, such as age, fur color, eye color, and name. The weather can be described using factors such as temperature and humidity. Both of these are real-world concepts that humans have identified and defined over time. In OOP, classes are what help in defining the logic of a program. When assigning concrete values to the properties of these classes, the result is an object. For example, using OOP, you can define a class for representing a room in a house, and then assign values to its properties (color and area) to create an object of that class.</p>
<p>In <em class="italic">Chapter 1</em>, <em class="italic">Hello C#</em>, you learned how to use C# to write basic programs. In this chapter, you will see how you can design your code by implementing OOP concepts and using C# at its best.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor085"/>Classes and Objects</h1>
<p>A class is like a blueprint that describes a concept. An object, on the other hand, is the result you get after the application of this blueprint. For example, <code>weather</code> can be a class, and <code>25 degrees and</code> <code>cloudless</code> could refer to an object of this class. Similarly, you can have a class named <code>Dog</code>, while a four-year-old <code>Spaniel</code> can represent an object of the <code>Dog</code> class.</p>
<p>Declaring a class in C# is simple. It starts with the <code>class</code> keyword, followed by the class name and a pair of curly braces. To define a class named <code>Dog</code>, you can write the following code:</p>
<pre>class Dog
{
}</pre>
<p>Right now, this class is just an empty skeleton. However, it can still be used to create objects by using the <code>new</code> keyword, as follows:</p>
<pre>Dog dog = new Dog();</pre>
<p>This creates an object named <code>dog</code>. Currently, the object is an empty shell, as it lacks properties. You will see in an upcoming section how to define properties for classes, but first, you will explore constructors.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor086"/>Constructors</h1>
<p>In C#, constructors are functions used to create new objects. You can also use them to set the initial values of an object. Like any function, a constructor has a name, takes arguments, and can be overloaded. A class must have at least one constructor, but if needed, it can have multiple constructors with different arguments. Even if you do not explicitly define a single constructor, a class will still have a default constructor–one that does not take any arguments or perform any actions but simply assigns memory to the newly created object and its fields.</p>
<p>Consider the following snippet, where a constructor for the <code>Dog</code> class is being declared:</p>
<pre>// Within a class named Dog
public class Dog
{
  // Constructor
  public Dog()
  {
    Console.WriteLine("A Dog object has been created");
  }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/H2lUF">https://packt.link/H2lUF</a>. You can find the usage of the code at <a href="https://packt.link/4WoSX">https://packt.link/4WoSX</a>.</p>
<p>If a method has the same name as the class and does not provide a <code>return</code> type, it is a constructor. Here, the snippet of the code is within a class named <code>Dog</code>. So, the constructor is within the specified line of code. Note that by defining this constructor explicitly, you hide the default constructor. If there is one or more such custom constructors, you will no longer be able to use a default constructor. Once the new constructor is called, you should see this message printed in the console: <code>"A Dog object has been created"</code>.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Fields and Class Members</h2>
<p>You already know what a variable is: it has a type, a name, and a value, as you saw in <em class="italic">Chapter 1</em>, <em class="italic">Hello C#</em>. Variables can also exist in the class scope, and such a variable is called a field. Declaring a field is as simple as declaring a local variable. The only difference is the addition of a keyword at the start, which is the access modifier. For example, you can declare a field within the <code>Dog</code> class with the public access modifier, as follows:</p>
<pre>public string Name = "unnamed";</pre>
<p>This line of code states that the <code>Name</code> field, which is a string with the value <code>"unnamed"</code>, can be accessed publicly. Besides <code>public</code>, the other two main access modifiers in C# are <code>private</code> and <code>protected</code>, which you will look at them in detail later.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information regarding access modifiers at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.</a></p>
<p>Everything a class holds is called a class member. Class members can be accessed from outside of a class; however, such access needs to be granted explicitly using the <code>public</code> access modifier. By default, all members have a <code>private</code> access modifier.</p>
<p>You can access class members by writing the object name followed by a dot (<code>.</code>) and the member name. For example, consider the following snippet in which two objects of the <code>Dog</code> class are being created:</p>
<pre>Dog sparky = new Dog();
Dog ricky = new Dog();</pre>
<p>Here, you can declare two independent variables, <code>sparky</code> and <code>ricky</code>. However, you haven't explicitly assigned these names to the objects; note that these are only the variable names. To assign the names to the objects, you can write the following code using dot notation:</p>
<pre>sparky.Name = "Sparky";
ricky.Name = "Ricky";</pre>
<p>You can now have hands-on experience of creating classes and objects through an exercise.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Exercise 2.01: Creating Classes and Objects</h2>
<p>Consider that there are two books, both by an author named <code>New Writer</code>. The first one, called <code>First Book</code>, was published by <code>Publisher 1</code>. There is no description available for this book. Similarly, the second one is named <code>Second Book</code> and was published by <code>Publisher 2</code>. It has a description that simply says, <code>"Interesting read"</code>.</p>
<p>In this exercise, you will model these books in code. The following steps will help you complete this exercise.</p>
<ol>
<li>Create a class called <code>Book</code>. Add fields for <code>Title</code>, <code>Author</code>, <code>Publisher</code>, <code>Description</code>, and the number of pages. You must print this information from outside the class, so make sure every field is <code>public</code>:<pre>    public class Book
    {
        public string Title;
        public string Author;
        public string Publisher;
        public int Pages;
        public string Description;
    }</pre></li>
<li>Create a class named <code>Solution</code>, with the <code>Main</code> method. As you saw in <em class="italic">Chapter 1</em>, <em class="italic">Hello C#</em>, this class with the <code>Main</code> method is the starting point of your application:<pre>    public static class Solution
    {
        public static void Main()
        {
        }
    }</pre></li>
<li>Inside the <code>Main</code> method, create an object for the first book and set the values for the fields, as follows:<pre>Book book1 = new Book();
book1.Author = "New Writer";
book1.Title = "First Book";
book1.Publisher = "Publisher 1";</pre></li>
</ol>
<p>Here, a new object named <code>book1</code> is created. Values are assigned to different fields by writing dot (<code>.</code>) followed by the field name. The first book does not have a description, so you can omit the field <code>book1.Description</code>.</p>
<ol>
<li value="4">Repeat this step for the second book. For this book, you need to set a value for the <code>Description</code> field as well:<pre>Book book2 = new Book();
book2.Author = "New Writer";
book2.Title = "Second Book";
book2.Publisher = "Publisher 2";
book2.Description = "Interesting read";</pre></li>
</ol>
<p>In practice, you will rarely see fields with public access modifiers. Data mutates easily, and you might not want to leave your program open to external changes after initialization.</p>
<ol>
<li value="5">Inside the <code>Solution</code> class, create a method named <code>Print</code>, which takes a <code>Book</code> object as an argument and prints all fields and their values. Use string interpolation to concatenate book information and print it to the console using <code>Console.WriteLine()</code>, as follows:<pre>private static void Print(Book book)
{
    Console.WriteLine($"Author: {book.Author}, " +
                      $"Title: {book.Title}, " +
                      $"Publisher: {book.Publisher}, " +
                      $"Description: {book.Description}.");
}</pre></li>
<li>Inside the <code>Main</code> method, call the <code>Print</code> method for <code>book1</code> and <code>book2</code>:<pre>Print(book1);
Print(book2);</pre></li>
</ol>
<p>Upon running this code, you will see the following output on the console:</p>
<pre>Author: New Writer, Title: First Book, Publisher: Publisher 1, Description: .
Author: New Writer, Title: Second Book, Publisher: Publisher 2, Description: Interesting read.</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/MGT9b">https://packt.link/MGT9b</a>.</p>
<p>In this exercise, you saw how to use fields and class members are used in simple programs. Now proceed to know about reference types.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor089"/>Reference Types</h1>
<p>Suppose you have an object and the object is not created, just declared, as follows:</p>
<pre>Dog speedy;</pre>
<p>What would happen if you tried accessing its <code>Name</code> value? Calling <code>speedy.Name</code> would throw a <code>NullReferenceException</code> exception because <code>speedy</code> is yet to be initialized. Objects are reference types, and their default value is null until initialized. You have already worked with value types, such as <code>int</code>, <code>float</code>, and <code>decimal</code>. Now you need to grasp that there are two major differences between value and reference types.</p>
<p>Firstly, value types allocate memory on the stack, whereas reference types allocate memory on the heap. The stack is a temporary place in memory. As the name implies, in a stack, blocks of memory are stacked on top of each other. When you call a function, all local function variables will end up on a single block of the stack. If you call a nested function, the local variables of that function will be allocated on another block of the stack.</p>
<p>In the following figure, you can see which parts of code will allocate memory in the stack during execution, and which will do so in the heap. Method calls (1, 8, 10) and local variables (2, 4) will be stored in the stack. Objects (3, 5) and their members (6) will be stored on the heap. Stacks use the Push method to allocate data, and Pop to deallocate it. When memory is allocated, it comes on top of the stack. When it is deallocated, it is removed from the top as well. You deallocate memory from the stack as soon as you leave the scope of a method (8, 10, 11). Heap is much more random, and Garbage Collector (GC) automatically (unlike some other languages, where you need to do it yourself), deallocates memory.</p>
<p class="callout-heading">Note</p>
<p class="callout">GC is a massive topic in itself. If you want to find out more, please refer to the official Microsoft documentation at <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals</a>.</p>
<div><div><img alt="Figure 2.1: Stack and heap comparison " height="798" src="img/B16835_02_01.jpg" width="1097"/>
</div>
</div>
<p class="figure-caption">Figure 2.1: Stack and heap comparison</p>
<p class="callout-heading">Note</p>
<p class="callout">If you make too many nested calls, you will run into a <code>StackoverflowException</code> exception because the stack ran out of memory. Freeing up memory on the stack is just a matter of exiting from a function.</p>
<p>The second difference is that, when value types are passed to a method, their value is copied, while for reference types, only the reference is copied. This means that the reference type object's state is modifiable inside a method, unlike a value type, because a reference is simply the address of an object.</p>
<p>Consider the following snippet. Here, a function named <code>SetTo5</code> sets the value of the number to <code>5</code>:</p>
<pre>private static void SetTo5(int number)
{
        number = 5;
}</pre>
<p>Now, consider the following code:</p>
<pre>int a = 2;
// a is 2
Console.WriteLine(a);
SetTo5(a);
// a is still 2
Console.WriteLine(a);</pre>
<p>This should result in the following output:</p>
<pre>2
2 </pre>
<p>If you run this code, you find that the printed value of <code>a</code> is still <code>2</code> and not <code>5</code>. This is because <code>a</code> is a value type that passed the value <code>2</code>, and therefore its value is copied. Inside a function, you never work with the original; a copy is always made.</p>
<p>What about reference types? Suppose you add a field named <code>Owner</code> inside the <code>Dog</code> class:</p>
<pre>public class Dog
{    public string Owner;
}</pre>
<p>Create a function, <code>ResetOwner</code>, that sets the value of the <code>Owner</code> field for an object to <code>None</code>:</p>
<pre>private static void ResetOwner(Dog dog)
{
    dog.Owner = "None";
}</pre>
<p>Now, suppose the following code is executed:</p>
<pre>Dog dog = new Dog("speedy");
Console.WriteLine(dog.Owner);
ResetOwner(dog);
// Owner is "None"- changes remain
Console.WriteLine(dog.Owner);</pre>
<p>This should result in the following output:</p>
<pre>speedy
None </pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/gj164">https://packt.link/gj164</a>.</p>
<p>If you try running this snippet of code yourself, you will first see the name <code>speedy</code> on one line and then <code>None</code> printed on another. This would change the dog's name, and the changes would remain outside the function. This is because Dog is a class, and a class is a reference type. When passed to a function, a copy of a reference is made. However, a copy of a reference points to the whole object, and therefore the changes that are made remain outside as well.</p>
<p>It might be confusing to hear that you pass a copy of a reference. How can you be sure you are working with a copy? To learn this, consider the following function:</p>
<pre>private static void Recreate(Dog dog)
{
    dog = new Dog("Recreated");
}</pre>
<p>Here, creating a new object creates a new reference. If you change the value of a reference type, you are working with a completely different object. It may be one that looks the same but is stored in a completely different place in memory. Creating an object for a passed parameter will not affect anything outside the object. Though this may sound potentially useful, you should generally avoid doing this as it can make code difficult to comprehend.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>Properties</h2>
<p>The <code>Dog</code> class has one flaw. Logically, you wouldn't want the name of a dog to be changed once it is assigned. However, as of now, there is nothing that prevents changing it. Think about the object from the perspective of what you can do with it. You can set the name of a dog (<code>sparky.Name = "Sparky"</code>) or you can get it by calling <code>sparky.Name</code>. However, what you want is a read-only name that can be set just once.</p>
<p>Most languages take care of this through setter and getter methods. If you add the <code>public</code> modifier to a field, this means that it can be both retrieved (read) and modified (written). It isn't possible to allow just one of these actions. However, with setters and getters, you can restrict both read and write access. In OOP, restricting what can be done with an object is key to ensuring data integrity. In C#, instead of setter and getter methods, you can use properties.</p>
<p>In OOP languages (for example Java), to set or get the values of a name, you would write something like this:</p>
<pre>public string GetName()
{
    return Name;
}
public string SetName (string name)
{
    Name = name;
}</pre>
<p>In C#, it is as simple as the following:</p>
<pre>public string Name {get; set;}</pre>
<p>This is a property, which is nothing but a method that reads like a field. There are two types of properties: getters and setters. You can perform both read and write operations with them. From the preceding code, if you remove <code>get</code>, it will become write-only, and if you remove <code>set</code>, it will become read-only.</p>
<p>Internally, the property includes a setter and a getter method with a backing field. A backing field is simply a private field that stores a value, and getter and setter methods work with that value. You can write custom getters and setters as well, as follows:</p>
<pre>private string _owner;
public string Owner
{
    get
    {
        return _owner;
    }
    set
    {
        _owner = value;
    }
}</pre>
<p>In the preceding snippet, the <code>Owner</code> property shows what the default getter and setter methods would look like for the <code>Dog</code> class.</p>
<p>Just like other members, individual parts of a property (either getter or setter) can have their own access modifier, like the following:</p>
<pre>public string Name {get; private set;}</pre>
<p>In this case, the getter is <code>public</code>, and the setter is <code>private</code>. All parts of the property (getter, setter, or both, as defined) take the access modifier from the property (<code>Name</code>, in this case) unless explicitly specified otherwise (as in the case of <code>private</code> set). If you do not need to set a name, you can get rid of the setter. If you need a default value, you can write the code for this as follows:</p>
<pre>public string Name {get;} = "unnamed";</pre>
<p>This piece of code means that the <code>Name</code> field is read-only. You can set the name only through a constructor. Note that this is not the same as a <code>private</code> set because the latter means you can still change the name within the <code>Dog</code> class itself. If no setter is provided (as is the case here), you can set the value in only one place, the constructor.</p>
<p>What happens internally when you create a read-only property? The following code is generated by the compiler:</p>
<pre>private readonly string _name;
public string get_Name()
{
    return _name;
}</pre>
<p>This shows that getter and setter properties are simply methods with a backing field. It is important to note that, if you have a property called <code>Name</code>, the <code>set_Name()</code> and <code>get_Name()</code> methods will be reserved because that's what the compiler generates internally.</p>
<p>You may have noticed a new keyword in the previous snippet, <code>readonly</code>. It signifies that the value of a field can only be initialized once—either during declaration or in a constructor.</p>
<p>Returning a backing field with a property may seem redundant sometimes. For example, consider the next snippet:</p>
<pre>private string _name;
 
public string Name
{
    get
    {
        return "Dog's name is " + _name;
    }
}</pre>
<p>This code snippet is a custom property. When a getter or a setter is more than just a basic return, you can write the property in this way to add custom logic to it. This property, without affecting the original name of a dog, will prepend <code>Dog's name is</code> before returning the name. You can make this more concise using expression-bodied property syntax, as follows:</p>
<pre>public string Name =&gt; "Dog's name is " + _name;</pre>
<p>This code does the same thing as the previous code; the <code>=&gt;</code> operator indicates that it is a read-only property, and you return a value that is specified on the right side of the <code>=&gt;</code> operator.</p>
<p>How do you set the initial value if there is no setter? The answer to that is a constructor. In OOP, a constructor serves one purpose—that is, setting the initial values of fields. Using a constructor is great for preventing the creation of objects in an invalid state.</p>
<p>To add some validation to the <code>Dog</code> class, you can write the following code:</p>
<pre>public Dog(string name)
{
  if(string.IsNullOrWhitespace(name))
  {
    throw new ArgumentNullException("name")
  }
  Name = name;
}</pre>
<p>The code you have just written will prevent an empty name from being passed when creating a <code>Dog</code> instance.</p>
<p>It is worth mentioning that within a class, you have access to the object itself that will be created. It might sound confusing, but it should make sense with this example:</p>
<pre>private readonly string name;
public Dog(string name)
{
  this.name = name;
}</pre>
<p>The <code>this</code> keyword is most often used to clear the distinction between class members and arguments. <code>this</code> refers to the object that has just been created, hence, <code>this.name</code> refers to the name of that object and <code>name</code> refers to the passed parameter.</p>
<p>Creating an object of the <code>Dog</code> class, and setting the initial value of a name, can now be simplified as follows:</p>
<pre>Dog ricky = new Dog("Ricky");
Dog sparky = new Dog("Sparky");</pre>
<p>You still have a private setter, meaning the property that you have is not entirely read-only. You can still change the value of a name within the class itself. However, fixing that is quite easy; you can simply remove the setter and it will become truly read-only.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="http://packt.link/hjHRV">http://packt.link/hjHRV</a>.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Object Initialization</h2>
<p>Often, a class has read and write properties. Usually, instead of setting the property values via a constructor, they are assigned after the creation of an object. However, in C# there is a better way—object initialization. This is where you create a new object and set the mutable (read and write) field values right away. If you had to create a new object of the <code>Dog</code> class and set the value of <code>Owner</code> for this object to <code>Tobias</code>, you could add the following code:</p>
<pre>Dog dog = new Dog("Ricky");
dog.Owner = "Tobias";</pre>
<p>This can be done using object initialization as follows:</p>
<pre>Dog dog = new Dog("Ricky")
{
  Owner = "Tobias"
};</pre>
<p>Setting initial properties like this when they are not a part of a constructor is generally more concise. The same applies to arrays and other collection types. Suppose you had two objects of the <code>Dog</code> class, as follows:</p>
<pre>Dog ricky = new Dog("Ricky");
Dog sparky = new Dog("Sparky");</pre>
<p>In such a case, one way of creating an array would be as follows:</p>
<pre>Dog[] dogs = new Dog[2];
dogs[0] = ricky;
dogs[1] = sparky;</pre>
<p>However, instead of this, you can just add the following code, which is more concise:</p>
<pre>Dog[] dogs = {ricky, sparky};</pre>
<p>In C# 10, you can simplify object initialization without providing the type, if it can be inferred from the declaration, as in the following code:</p>
<pre>Dog dog = new("Dog");</pre>
<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/>Comparing Functions and Methods</h2>
<p>Up until now, you might have seen the terms—function and method—used quite often, almost interchangeably. Now proceed to gain further insight into functions and methods. A function is a block of code that you can call using its name and some input. A method is a function that exists within a class.</p>
<p>However, in C#, you cannot have functions outside of a class. Therefore, in C#, every function is a method. Many languages, especially non-OOP languages, have only some functions that can be called methods (for example, JavaScript).</p>
<p>The behavior of a class is defined using methods. You have already defined some behavior for the <code>Dog</code> class, that is, getting its name. To finish implementing the behaviors for this class, you can implement some real-world parallels, such as sitting and barking. Both methods will be called from the outside:</p>
<pre>public void Sit()
{
    // Implementation of how a dog sits
}
public void Bark()
{
    // Implementation of how a dog barks 
}</pre>
<p>You can call both methods like this:</p>
<pre>Ricky.Sit();
Sparky.Bark();</pre>
<p>In most cases, it is preferable to avoid exposing data publicly, so you should only ever expose functions publicly. Here, you might be wondering, What about properties? Properties are just getter and setter functions; they work with data but aren't data themselves. You should avoid <strong class="bold">exposing</strong> data publicly directly, for the same reason you lock your doors, or carry your phone in a case. If data were public, everyone could access it without any restrictions. </p>
<p>Also, data should not change when the program requires it to be constant. A method is a mechanism that ensures that an object is not used in invalid ways, and if it is, it's well handled.</p>
<p>What if you need to validate the fields consistently throughout the application? Again, properties, that is, getter and setter methods, can help with this. You can limit what you can do with data and add validation logic to it. Properties help you be in full control of how you can get and set data. Properties are handy, but it's important to use them with discretion. If you want to do something complex, something that needs extra computing, it is preferable to use a method.</p>
<p>For example, imagine that you have a class for an inventory made up of items, each having some weight. Here, it might make sense to have a property to return the heaviest item. If you chose to do so through a property (call it <code>MaxWeight</code>), you might get unexpected results; getting the heaviest item would require iterating through a collection of all items and finding the maximum by weight. This process is not as fast as you would expect. In fact, in some cases, it might even throw an error. Properties should have simple logic, otherwise working with them might yield unexpected results. Therefore, when the need for compute-heavy properties arises, consider refactoring them to a method. In this case, you would refactor the <code>MaxWeight</code> property into the <code>GetMaxWeight</code> method.</p>
<p>Properties should be avoided for returning results of complex calculations, as calling a property could be expensive. Getting or setting the value of a field should be straightforward. If it becomes expensive, it should no longer be treated as property.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>An Effective Class</h2>
<p>The <code>Dog</code> class models a <code>dog</code> object; therefore, it can be called a model. Some developers prefer to have a strict separation between data and logic. Others try to put as much logic in a model as possible, so long as it is self-contained. There is no right or wrong way here. It all depends on the context you are working with.</p>
<p class="callout-heading">Note</p>
<p class="callout">This discussion is outside the scope of this chapter, but if you would like to know more, you can refer to the discussion on Domain-Driven Design (DDD) at <a href="https://martinfowler.com/bliki/DomainDrivenDesign.xhtml">https://martinfowler.com/bliki/DomainDrivenDesign.xhtml</a>.</p>
<p>It is hard to pinpoint what an effective class looks like. However, when deciding whether a method fits better in class A or class B, try asking yourself these questions:</p>
<ul>
<li>Would someone, who is not a programmer, know that you are talking about the class? Is it a logical representation of a real-world concept?</li>
<li>How many reasons does the class have to change? Is it just one or are there more reasons?</li>
<li>Is private data tightly related to public behavior?</li>
<li>How often does the class change?</li>
<li>How easy is it to break the code?</li>
<li>Does the class do something by itself?</li>
</ul>
<p>High cohesion is a term used to describe a class that has all its members strongly related, not only semantically, but logically as well. In contrast, a low cohesion class has loosely related methods and fields that probably could have a better place. Such a class is inefficient because it changes for multiple reasons and you cannot expect to look for anything inside it, as it simply has no strong logical meaning.</p>
<p>For example, a part of a <code>Computer</code> class could look like this:</p>
<pre>class Computer
{
    private readonly Key[] keys;
}</pre>
<p>However, <code>Computer</code> and <code>keys</code> are not related at the same level. There could be another class that better suits the <code>Key</code> class, that is <code>Keyboard</code>:</p>
<pre>class Computer
{
    private readonly Keyboard keyboard;
}
class Keyboard
{
    private readonly Key[] keys;
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/FFcDa">https://packt.link/FFcDa</a>.</p>
<p>A keyboard is directly related to keys, just as it is directly related to a computer. Here, both <code>Keyboard</code> and the <code>Computer</code> class have high cohesion because the dependencies have a stable logical place. You can now learn more about it through an exercise.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor094"/>Exercise 2.02: Comparing the Area Occupied by Different Shapes</h2>
<p>You have two sections of a backyard, one with circular tiles and the other with rectangular tiles. You would like to deconstruct one section of the backyard, but you are not sure which one it should be. Obviously, you want as little mess as possible and have decided to pick the section that occupies the least area.</p>
<p>Given two arrays, one for different sized rectangular tiles and the other for different-sized circular tiles, you need to find which section to deconstruct. This exercise aims to output the name of the section occupying less area, that is, <code>rectangular</code> or  <code>circular</code>.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Create a <code>Rectangle</code> class as follows. It should have fields for <code>width</code>, <code>height</code>, and <code>area</code>:<pre>public class Rectangle
{
    private readonly double _width;
    private readonly double _height;
    public double Area
    {
        get
        {
            return _width * _height;
        }
    } 
 
    public Rectangle(double width, double height)
    {
        _width = width;
        _height = height;
    }
}</pre></li>
</ol>
<p>Here, <code>_width</code> and <code>_height</code> have been made immutable, using the <code>readonly</code> keyword. The type chosen is <code>double</code> because you will be performing <code>math</code> operations. The only property that is exposed publicly is <code>Area</code>. It will return a simple calculation: the product of width and height. The <code>Rectangle</code> is immutable, so all it needs is to be passed once through a constructor and it remains constant thereafter.</p>
<ol>
<li value="2">Similarly, create a <code>Circle</code> class as follows:<pre>public class Circle
{
    private readonly double _radius;
 
    public Circle(double radius)
    {
        _radius = radius;
    }
 
    public double Area
    {
        get { return Math.PI * _radius * _radius; }
    }
}</pre></li>
</ol>
<p>The <code>Circle</code> class is similar to <code>Rectangle</code> class, except that instead of width and height, it has <code>radius</code>, and the <code>Area</code> calculation uses a different formula. The constant <code>PI</code> has been used, which can be accessed from the <code>Math</code> namespace.</p>
<ol>
<li value="3">Create a <code>Solution</code> class with a skeleton method named <code>Solve</code>:<pre>public static class Solution
{
    public const string Equal = "equal";
    public const string Rectangular = "rectangular";
    public const string Circular = "circular";
    public static string Solve(Rectangle[] rectangularSection, Circle[] circularSection)
    {
        var totalAreaOfRectangles = CalculateTotalAreaOfRectangles(rectangularSection);
        var totalAreaOfCircles = CalculateTotalAreaOfCircles(circularSection);
        return GetBigger(totalAreaOfRectangles, totalAreaOfCircles);
    }
}</pre></li>
</ol>
<p>Here, the <code>Solution</code> class demonstrates how the code works. For now, there are three constants based on the requirements (which section is bigger? rectangular or circular, or are they equal?). Also, the flow will be to calculate the total area of rectangles, then of circles and finally return the bigger.</p>
<p>Before you can implement the solution, you must first create side methods for calculating the total area of the rectangular section, calculating the total area of the circular section, and comparing the two. You will do this over the next few steps.</p>
<ol>
<li value="4">Inside <code>Solution</code> class, add a method to calculate the total area of the rectangular section:<pre>private static double CalculateTotalAreaOfRectangles(Rectangle[] rectangularSection)
{
    double totalAreaOfRectangles = 0;
    foreach (var rectangle in rectangularSection)
    {
        totalAreaOfRectangles += rectangle.Area;
    }
 
    return totalAreaOfRectangles;
}</pre></li>
</ol>
<p>This method goes through all the rectangles, gets the area of each, and adds it to the total sum.</p>
<ol>
<li value="5">Similarly, add a method to calculate the total area of the circular section:<pre>private static double CalculateTotalAreaOfCircles(Circle[] circularSection)
{
    double totalAreaOfCircles = 0;
    foreach (var circle in circularSection)
    {
        totalAreaOfCircles += circle.Area;
    }
 
    return totalAreaOfCircles;
}</pre></li>
<li>Next, add a method to get the bigger area, as follows:<pre>private static string GetBigger(double totalAreaOfRectangles, double totalAreaOfCircles)
{
    const double margin = 0.01;
    bool areAlmostEqual = Math.Abs(totalAreaOfRectangles - totalAreaOfCircles) &lt;= margin;
    if (areAlmostEqual)
    {
        return Equal;
    }
    else if (totalAreaOfRectangles &gt; totalAreaOfCircles)
    {
        return Rectangular;
    }
    else
    {
        return Circular;
    }
}</pre></li>
</ol>
<p>This snippet contains the most interesting part. In most languages, numbers with a decimal point are not accurate. In fact, in most cases, if a and b are floats or doubles, it is likely that they will never be equal. Therefore, when comparing such numbers, you must consider precision.</p>
<p>In this code, you have defined the margin, to have an acceptable range of accuracy of your comparison for when the numbers are considered equal (for example, 0.001 and 0.0011 will be equal in this case since the margin is 0.01). After this, you can do a regular comparison and return the value for whichever section has the biggest area.</p>
<ol>
<li value="7">Now, create the <code>Main</code> method, as follows:<pre>public static void Main()
{ 
    string compare1 = Solve(new Rectangle[0], new Circle[0]);
    string compare2 = Solve(new[] { new Rectangle(1, 5)}, new Circle[0]);
    string compare3 = Solve(new Rectangle[0], new[] { new Circle(1) });
    string compare4 = Solve(new []
    {
        new Rectangle(5.0, 2.1), 
        new Rectangle(3, 3), 
    }, new[]
    {
        new Circle(1),
        new Circle(10), 
    });
 
    Console.WriteLine($"compare1 is {compare1}, " +
                      $"compare2 is {compare2}, " +
                      $"compare3 is {compare3}, " +
                      $"compare4 is {compare4}.");
}</pre></li>
</ol>
<p>Here, four sets of shapes are created for comparison. <code>compare1</code> has two empty sections, meaning they should be equal. <code>compare2</code> has a rectangle and no circles, so the rectangle is bigger. <code>compare3</code> has a circle and no rectangle, so the circles are bigger. Finally, <code>compare4</code> has both rectangles and circles, but the total area of the circles is bigger. You used string interpolation inside <code>Console.WriteLine</code> to print the results.</p>
<ol>
<li value="8">Run the code. You should see the following being printed to the console:<pre>compare1 is equal, compare2 is rectangular, compare3 is circular, compare4 is circular.</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/tfDCw">https://packt.link/tfDCw</a>.</p></li>
</ol>
<p>What if you did not have objects? What would the section be made of in that case? For a circle, it might be viable to just pass radii, but for rectangles, you would need to pass another collinear array with widths and heights.</p>
<p>Object-oriented code is great for grouping similar data and logic under one shell, that is, a class, and passing those class objects around. In this way, you can simplify complex logic through simple interaction with a class.</p>
<p>You will now know about the four pillars of OOP.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor095"/>The Four Pillars of OOP</h1>
<p>Efficient code should be easy to grasp and maintain, and OOP strives to achieve such simplicity. The entire concept of object-oriented design is based on four main tenets, also known as the four pillars of OOP.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/>Encapsulation</h2>
<p>The first pillar of OOP is encapsulation. It defines the relationship between data and behavior, placed in the same shell, that is, a class. It refers to the need to expose only what is necessary and hide everything else. When you think about encapsulation, think about the importance of security for your code: what if you leak a password, return confidential data, or make an API key public? Being reckless often leads to damage that can be hard to fix.</p>
<p>Security is not just limited to protection from malicious intent, but also extends to preventing manual errors. Humans tend to make mistakes. In fact, the more options there are to choose from, the more mistakes they are likely to make. Encapsulation helps in that regard because you can simply limit the number of options available to the person who will use the code.</p>
<p>You should prevent all access by default, and only grant explicit access when necessary. For example, consider a simplified <code>LoginService</code> class:</p>
<pre>public class LoginService
{
    // Could be a dictionary, but we will use a simplified example.
    private string[] _usernames;
    private string[] _passwords;
 
    public bool Login(string username, string password)
    {
        // Do a password lookup based on username
        bool isLoggedIn = true;
        return isLoggedIn;
    }
}</pre>
<p>This class has two <code>private</code> fields: <code>_usernames</code> and <code>_passwords</code>. The key point to note here is that neither passwords nor usernames are accessible to the public, but you can still achieve the required functionality by exposing just enough logic publicly, through the <code>Login</code> method.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find this code used for this example at <a href="https://packt.link/6SO7a">https://packt.link/6SO7a</a>.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>Inheritance</h2>
<p>A police officer can arrest someone, a mailman delivers mail, and a teacher teaches one or more subjects. Each of them performs widely different duties, but what do they all have in common? In the context of the real world, they are all human. They all have a name, age, height, and weight. If you were to model each, you would need to make three classes. Each of those classes would look the same, other than one unique method for each. How could you express in code that they are all human?</p>
<p>The key to solving this problem is inheritance. It allows you to take all the properties from a parent class and transfer them to its child class. Inheritance also defines an is-a relationship. A police officer, a mailman, and a teacher are all humans, and so you can use inheritance. You will now write this down in code.</p>
<ol>
<li value="1">Create a <code>Human</code> class that has fields for <code>name</code>, <code>age</code>, <code>weight</code>, and <code>height</code>:<pre>public class Human
{
    public string Name { get; }
    public int Age { get; }
    public float Weight { get; }
    public float Height { get; }
 
    public Human(string name, int age, float weight, float height)
    {
        Name = name;
        Age = age;
        Weight = weight;
        Height = height;
    }
}</pre></li>
<li>A mailman is a human. Therefore, the <code>Mailman</code> class should have all that a <code>Human</code> class has, but on top of that, it should have the added functionality of being able to deliver mail. Write the code for this as follows:<pre>public class Mailman : Human
{
    public Mailman(string name, int age, float weight, float height) : base(name, age, weight, height)
    {
    }
 
    public void DeliverMail(Mail mail)
    {
       // Delivering Mail...
    }
}</pre></li>
</ol>
<p>Now, look closely at the <code>Mailman</code> class. Writing <code>class Mailman : Human</code> means that <code>Mailman</code> inherits from <code>Human</code>. This means that <code>Mailman</code> takes all the properties and methods from <code>Human</code>. You can also see a new keyword, <code>base</code>. This keyword is used to tell which parent constructor is going to be used when creating <code>Mailman</code>; in this case, <code>Human</code>.</p>
<ol>
<li value="3">Next, create a class named <code>Mail</code> to represent the mail, containing a field for a message being delivered to an address:<pre>public class Mail
{
   public string Message { get; }
   public string Address { get; }
 
   public Mail(string message, string address)
   {
       Message = message;
       Address = address;
   }
}</pre></li>
</ol>
<p>Creating a <code>Mailman</code> object is no different than creating an object of a class that does not use inheritance.</p>
<ol>
<li value="4">Create <code>mailman</code> and <code>mail</code> variables and tell the <code>mailman</code> to deliver the mail as follows:<pre>var mailman = new Mailman("Thomas", 29, 78.5f, 190.11f);
var mail = new Mail("Hello", "Somewhere far far way");
mailman.DeliverMail(mail);</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this example at <a href="https://packt.link/w1bbf">https://packt.link/w1bbf</a>.</p></li>
</ol>
<p>In the preceding snippet, you created <code>mailman</code> and <code>mail</code> variables. Then, you told the <code>mailman</code> to deliver the <code>mail</code>.</p>
<p>Generally, a base constructor must be provided when defining a child constructor. The only exception to this rule is when the parent has a parameter-less constructor. If a base constructor takes no arguments, then a child constructor using a base constructor would be redundant and therefore can be ignored. For example, consider the following snippet:</p>
<pre>Public class A
{
}
Public class B : A
{
}</pre>
<p><code>A</code> has no custom constructors, so implementing <code>B</code> would not require a custom constructor either.</p>
<p>In C#, only a single class can be inherited; however, you can have a multi-level deep inheritance. For example, you could have a child class for <code>Mailman</code> named <code>RegionalMailman</code>, which would be responsible for a single region. In this way, you could go deeper and have another child class for <code>RegionalMailman</code>, called <code>RegionalBillingMailman</code>, then <code>EuropeanRegionalBillingMailman</code>, and so on.</p>
<p>When using inheritance, it is important to know that even if everything is inherited, not everything is visible. Just like before, <code>public</code> members only will be accessible from a parent class. However, in C#, there is a special modifier, named <code>protected</code>, that works like the <code>private</code> modifier. It allows child classes to access <code>protected</code> members (just like <code>public</code> members) but prevents them from being accessed from the outside of the class (just like <code>private</code>).</p>
<p>Decades ago, inheritance used to be the answer to many problems and the key to code reuse. However, over time, it became apparent that using inheritance comes at a price, which is coupling. When you apply inheritance, you couple a child class with a parent. Deep inheritance stacks class scope all the way from parent to child. The deeper the inheritance, the deeper the scope. Deep inheritance (two or more levels deep) should be avoided for the same reason you avoid global variables—it is hard to know what comes from where and hard to control the state changes. This, in turn, makes the code difficult to maintain.</p>
<p>Nobody wants to write duplicate code, but what is the alternative? The answer to that is composition. Just as a computer is composed of different parts, code should be composed of different parts as well. For example, imagine you are developing a 2D game and it has a <code>Tile</code> object. Some tiles contain a trap, and some tiles move. Using inheritance, you could write the code like this:</p>
<pre>class Tile
{
}
class MovingTile : Tile
{
    public void Move() {}
}
class TrapTile : Tile
{
    public void Damage() {}
}
//class MovingTrapTile : ?</pre>
<p>This approach works fine until you face more complex requirements. What if there are tiles that could both be a trap and move? Should you inherit from a moving tile and rewrite the <code>TrapTile</code> functionality there? Could you inherit both? As you have seen, you cannot inherit more than one class at a time, therefore, if you were to implement this using inheritance, you would be forced to both complicate the situation, and rewrite some code. Instead, you could think about what different tiles contain. <code>TrapTile</code> has a trap. <code>MovingTile</code> has a motor. </p>
<p>Both represent tiles, but the extra functionality they each have should come from different components, and not child classes. If you wanted to make this a composition-based approach, you would need to refactor quite a bit.</p>
<p>To solve this, keep the <code>Tile</code> class as-is:</p>
<pre>class Tile
{
}</pre>
<p>Now, add two components—Motor and Trap classes. Such components serve as logic providers. For now, they do nothing:</p>
<pre>class Motor
{
    public void Move() { }
}
class Trap
{
    public void Damage() { }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/espfn">https://packt.link/espfn</a>.</p>
<p>Next, you define a <code>MovingTile</code> class that has a single component, <code>_motor</code>. In composition, components rarely change dynamically. You should not expose class internals, so apply <code>private readonly</code> modifiers. The component itself can have a child class or change, and so should not be created from the constructor. Instead, it should be passed as an argument (see the highlighted code):</p>
<pre>class MovingTile : Tile
{
    private readonly Motor _motor;
 
    <strong class="bold">public MovingTile(Motor motor)</strong>
    {
        _motor = motor;
    } 
 
    public void Move()
    {
        _motor.Move();
    }
}</pre>
<p>Note that the <code>Move</code> method now calls <code>_motor.Move()</code>. That is the essence of composition; the class that holds composition often does nothing by itself. It just delegates the calls of logic to its components. In fact, even though this is just an example class, a real class for a game would look quite similar to this.</p>
<p>You will do the same for <code>TrapTile</code>, except that instead of <code>Motor</code>, it will contain a <code>Trap</code> component:</p>
<pre>class TrapTile : Tile
{
    private readonly Trap _trap;
 
    public TrapTile(Trap trap)
    {
        _trap = trap;
    }
 
    public void Damage()
    {
        _trap.Damage();
    }
}</pre>
<p>Finally, it's time to create the <code>MovingTrapTile</code> class. It has two components that provide logic to the <code>Move</code> and <code>Damage</code> methods. Again, the two methods are passed as arguments to a constructor:</p>
<pre>class MovingTrapTile : Tile
{
    private readonly Motor _motor;
    private readonly Trap _trap;
 
    public MovingTrapTile(Motor motor, Trap trap)
    {
        _motor = motor;
        _trap = trap;
    }
    public void Move()
    {
        _motor.Move();
    }
    public void Damage()
    {
        _trap.Damage();
    }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/SX4qG">https://packt.link/SX4qG</a>.</p>
<p>It might seem that this class repeats some code from the other class, but the duplication is negligible, and the benefits are well worth it. After all, the biggest chunk of logic comes from the components themselves, and a repeated field or a call is not significant.</p>
<p>You may have noticed that you inherited <code>Tile</code>, despite not extracting it as a component for other classes. This is because <code>Tile</code> is the essence of all the classes that inherit it. No matter what type a tile is, it is still a tile. Inheritance is the second pillar of OOP. It is powerful and useful. However, it can be hard to get inheritance right, because in order to be maintainable, it truly needs to be very clear and logical. When choosing whether you should use inheritance, consider these factors:</p>
<ul>
<li>Not deep (ideally single level).</li>
<li>Logical (is-a relation, as you saw in your tiles example).</li>
<li>Stable and extremely unlikely for the relationship between classes to change in the future; not going to be modified often.</li>
<li>Purely additive (child class should not use parent class members, except for a constructor).</li>
</ul>
<p>If any one of these rules is broken, it is recommended to use composition instead of inheritance.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Polymorphism</h2>
<p>The third pillar of OOP is polymorphism. To grasp this pillar, it is useful to look at the meaning of the word. <code>Thomas</code>. <code>Thomas</code> is both a human and a mailman. <code>Mailman</code> is the specialized form and <code>Human</code> is the generalized form for Thomas. However, you can interact with <code>Thomas</code> through either of the two forms.</p>
<p>If you do not know the jobs for every human, you can use an <code>abstract</code> class.</p>
<p>An <code>abstract</code> class is a synonym for an incomplete class. This means that it cannot be initialized. It also means that some of its methods may not have an implementation if you mark them with the <code>abstract</code> keyword. You can implement this for the <code>Human</code> class as follows:</p>
<pre>public abstract class Human
{
    public string Name { get; }
 
    protected Human(string name)
    {
        Name = name;
    }
 
    public abstract void Work();
}</pre>
<p>You have created an abstract (incomplete) <code>Human</code> class here. The only difference from earlier is that you have applied the <code>abstract</code> keyword to the class and added a new <code>abstract</code> method, <code>public abstract void Work()</code>. You have also changed the constructor to protected so that it is accessible only from a child class. This is because it no longer makes sense to have it <code>public</code> if you cannot create an <code>abstract</code> class; you cannot call a <code>public</code> constructor. Logically, this means that the <code>Human</code> class, by itself, has no meaning, and it only gets meaning after you have implemented the <code>Work</code> method elsewhere (that is, in a child class).</p>
<p>Now, you will update the <code>Mailman</code> class. It does not change much; it just gets an additional method, that is, <code>Work()</code>. To provide an implementation for abstract methods, you must use the <code>override</code> keyword. In general, this keyword is used to change the implementation of an existing method inside a child class. You will explore  this in detail later:</p>
<pre>public override void Work()
{
    Console.WriteLine("A mailman is delivering mails.");
}</pre>
<p>If you were to create a new object for this class and call the <code>Work</code> method, it would print <code>"A mailman is delivering mails."</code> to the console. To get a full picture of polymorphism, you will now create one more class, <code>Teacher</code>:</p>
<pre>public class Teacher : Human
{
    public Teacher(string name, int age, float weight, float height) : base(name, age, weight, height)
    {
    }
 
    public override void Work()
    {
        Console.WriteLine("A teacher is teaching.");
    }
}</pre>
<p>This class is almost identical to <code>Mailman</code>; however, a different implementation for the <code>Work</code> method is provided. Thus, you have two classes that do the same thing in two different ways. The act of calling a method of the same name, but getting different behavior, is called polymorphism.</p>
<p>You already know about method overloading (not to be confused with overriding), which is when you have methods with the same names but different inputs. That is called static polymorphism and it happens during compile time. The following is an example of this:</p>
<pre>public class Person
{
    public void Say()
    {
        Console.WriteLine("Hello");
    }
 
    public void Say(string words)
    {
        Console.WriteLine(words);
    }
}</pre>
<p>The <code>Person</code> class has two methods with the same name, Say. One takes no arguments and the other takes a string as an argument. Depending on the arguments passed, different implementations of the method will be called. If nothing is passed, <code>"Hello"</code> will be printed. Otherwise, the words you pass will be printed.</p>
<p>In the context of OOP, polymorphism is referred to as dynamic polymorphism, which happens during runtime. For the rest of this chapter, polymorphism should be interpreted as dynamic polymorphism.</p>
<h3 id="_idParaDest-97"><a id="_idTextAnchor099"/>What is the Benefit of Polymorphism?</h3>
<p>A teacher is a human, and the way a teacher works is by teaching. This is not the same as a mailman, but a teacher also has a name, age, weight, and height, like a mailman. Polymorphism allows you to interact with both in the same way, regardless of their specialized forms. The best way to illustrate this is to store both in an array of <code>humans</code> values and make them work:</p>
<pre>Mailman mailman = new Mailman("Thomas", 29, 78.5f, 190.11f);
Teacher teacher = new Teacher("Gareth", 35, 100.5f, 186.49f);
// Specialized types can be stored as their generalized forms.
Human[] humans = {mailman, teacher};
// Interacting with different human types
// as if they were the same type- polymorphism.
foreach (var human in humans)
{
    human.Work();
}</pre>
<p>This code results in the following being printed in the console:</p>
<pre>A mailman is delivering mails.
A teacher is teaching.</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ovqru">https://packt.link/ovqru</a>.</p>
<p>This code was polymorphism in action. You treated both <code>Mailman</code> and <code>Teacher</code> as <code>Human</code> and implemented the <code>Work</code> method for both. The result was different behaviors in each case. The important point to note here is that you did not have to care about the exact implementations of <code>Human</code> to implement <code>Work</code>.</p>
<p>How would you implement this without polymorphism? You would need to write <code>if</code> statements based on the exact type of an object to find the behavior it should use:</p>
<pre>foreach (var human in humans)
{
    Type humanType = human.GetType();
    if (humanType == typeof(Mailman))
    {
        Console.WriteLine("Mailman is working...");
    }
    else
    {
        Console.WriteLine("Teaching");
    }
}</pre>
<p>As you see, this is a lot more complicated and harder to grasp. Keep this example in mind when you get into a situation with many <code>if</code> statements. Polymorphism can remove the burden of all that branching code by simply moving the code for each branch into a child class and simplifying the interactions.</p>
<p>What if you wanted to print some information about a person? Consider the following code:</p>
<pre>Human[] humans = {mailman, teacher};
foreach (var human in humans)
{
    Console.WriteLine(human);
}</pre>
<p>Running this code would result in the object type names being printed to the console:</p>
<pre>Chapter02.Examples.Professions.Mailman
Chapter02.Examples.Professions.Teacher</pre>
<p>In C#, everything derives from the <code>System.Object</code> class, so every single type in C# has a method called <code>ToString()</code>. Each type has its own implementation of this method, which is another example of polymorphism, widely used in C#.</p>
<p class="callout-heading">Note</p>
<p class="callout"><code>ToString()</code> is different from <code>Work()</code> in that it provides a default implementation. You can achieve that using the <code>virtual</code> keyword, which will be covered in detail later in the chapter. From the point of view of a child class, working with the <code>virtual</code> or <code>abstract</code> keyword is the same. If you want to change or provide behavior, you will override the method.</p>
<p>In the following snippet, a <code>Human</code> object is given a custom implementation of the <code>ToString()</code> method:</p>
<pre>public override string ToString()
{
    return $"{nameof(Name)}: {Name}," +
           $"{nameof(Age)}: {Age}," +
           $"{nameof(Weight)}: {Weight}," +
           $"{nameof(Height)}: {Height}";
}</pre>
<p>Trying to print information about the humans in the same foreach loop would result in the following output:</p>
<pre>Name: Thomas,Age: 29,Weight: 78.5,Height: 190.11
Name: Gareth,Age: 35,Weight: 100.5,Height: 186.49</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/EGDkC">https://packt.link/EGDkC</a>.</p>
<p>Polymorphism is one of the best ways to use different underlying behaviors when dealing with missing type information.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor100"/>Abstraction</h2>
<p>The last pillar of OOP is abstraction. Some say that there are only three pillars of OOP because abstraction does not really introduce much that is new. Abstraction encourages you to hide implementation details and simplify interactions between objects. Whenever you need the functionality of only a generalized form, you should not depend on its implementation.</p>
<p>Abstraction could be illustrated with an example of how people interact with their computers. What occurs in the internal circuitry when you turn on the computer? Most people would have no clue, and that is fine. You do not need to know about the internal workings if you only need to use some functionality. All you have to know is what you can do, and not how it works. You know you can turn a computer on and off by pressing a button, and all the complex details are hidden away. Abstraction adds little new to the other three pillars because it reflects each of them. <strong class="bold">Abstraction is similar to encapsulation</strong>, as it hides unnecessary details to simplify interaction. It is also similar to polymorphism because it can interact with objects without knowing their exact types. Finally, inheritance is just one of the ways to create abstractions.</p>
<p>You do not need to provide unnecessary details coming through implementation types when creating functions. The following example illustrates this problem. You need to make a progress bar. It should keep track of the current progress and should increment the progress up to a certain point. You could create a basic class with setters and getters, as follows:</p>
<pre>public class ProgressBar
{
    public float Current { get; set; }
    public float Max { get; }
 
    public ProgressBar(float current, float max)
    {
        Max = max;
        Current = current;
    }
}</pre>
<p>The following code demonstrates how to initialize a progress bar that starts at <code>0</code> progress and goes up to <code>100</code>. The rest of the code illustrates what happens when you want to set the new progress to 120. Progress cannot be more than <code>Max</code>, hence, if it is more than <code>bar.Max</code>, it should just remain at <code>bar.Max</code>. Otherwise, you can update the new progress with the value you set. Finally, you need to check whether the progress is complete (at <code>Max</code> value). To do so, you will compare the delta with the allowed margin of error tolerance (<code>0.0001</code>). A progress bar is complete if it is close to tolerance. So, updating progress could look like the following:</p>
<pre>var bar = new ProgressBar(0, 100);
var newProgress = 120;
if (newProgress &gt; bar.Max)
{
    bar.Current = bar.Max;
}
else
{
    bar.Current = newProgress;
}
 
const double tolerance = 0.0001;
var isComplete = Math.Abs(bar.Max - bar.Current) &lt; tolerance;</pre>
<p>This code does what is asked for, but it needs a lot of detail for a function. Imagine if you had to use this in other code; you would need to perform the same checks once again. In other words, it was easy to implement but complex to consume. You have so little within the class itself. A strong indicator of that is that you keep on calling the object, instead of doing something inside the class itself. Publicly, it's possible to break the object state by forgetting to check the <code>Max</code> value of progress and setting it to some high or negative value. The code that you wrote has low cohesion because to change <code>ProgressBar</code>, you would do it not within the class but somewhere outside of it. You need to create a better abstraction.</p>
<p>Consider the following snippet:</p>
<pre>public class ProgressBar
{
    private const float Tolerance = 0.001f;
 
    private float _current;
    public float Current
    {
        get =&gt; _current;
        set
        {
            if (value &gt;= Max)
            {
                _current = Max;
            }
            else if (value &lt; 0)
            {
                _current = 0;
            }
            else
            {
                _current = value;
            }
        }
    }</pre>
<p>With this code, you have hidden the nitty-gritty details. When it comes to updating progress and defining what the tolerance is, that is up to the <code>ProgressBar</code> class to decide. In the refactored code, you have a property, <code>Current</code>, with a backing field, <code>_current</code>, to store the progress. The property setter checks whether progress is more than the maximum and, if it is, it will not allow the value of <code>_current</code> to be set to a higher value,<code> =</code>. It also cannot be negative, as in those cases, the value will be adjusted to <code>0</code>. Lastly, if it is not negative and not more than the maximum, then you can set <code>_current</code> to whatever value you pass.</p>
<p>Clearly, this code makes it much simpler to interact with the <code>ProgressBar</code> class:</p>
<pre>var bar = new ProgressBar(0, 100);
bar.Current = 120;
bool isComplete = bar.IsComplete;</pre>
<p>You cannot break anything; you do not have any extra choices and all you can do is defined through minimalistic methods. When you are asked to implement a feature, it is not recommended to do more than what is asked. Try to be minimalistic and simplistic because that is key to an effective code.</p>
<p>Remember that well-abstracted code is full of empathy toward the reader. Just because today, it is easy to implement a class or a function, you should not forget about tomorrow. The requirements change, the implementation changes, but the structure should remain stable, otherwise, your code can break easily.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example can be found at <a href="https://packt.link/U126i">https://packt.link/U126i</a>. The code given in GitHub is split into two contrasting examples—<code>ProgressBarGood</code> and <code>ProgressBarBad</code>. Both codes are simple <code>ProgressBar</code> but were named distinctly to avoid ambiguity.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>Interfaces</h2>
<p>Earlier, it was mentioned that inheritance is not the proper way of designing code. However, you want to have an efficient abstraction as well as support for polymorphism, and little to no coupling. What if you wanted to have robot or ant workers? They do not have a name. Information such as height and weight are irrelevant. And inheriting from the <code>Human</code> class would make little sense. Using an interface solves this conundrum.</p>
<p>In C#, by convention, interfaces are named starting with the letter <code>I</code>, followed by their actual name. An interface is a contract that states what a class can do. It does not have any implementation. It only defines behavior for every class that implements it. You will now refactor the human example using an interface.</p>
<p>What can an object of the <code>Human</code> class do? It can work. Who or what can do work? A worker. Now, consider the following snippet:</p>
<pre>public interface IWorker
{
    void Work();
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">Interface <code>Work</code> method will have is the same as the interface access modifier, in this case, <code>public</code>.</p>
<p>An ant is not a human, but it can work. With an interface, abstracting an ant as a worker is straightforward:</p>
<pre>public class Ant : IWorker
{
    public void Work()
    {
        Console.WriteLine("Ant is working hard.");
    }
}</pre>
<p>Similarly, a robot is not a human, but it can work as well:</p>
<pre>public class Robot : IWorker
{
    public void Work()
    {
        Console.WriteLine("Beep boop- I am working.");
    }
}</pre>
<p>If you refer to the <code>Human</code> class, you can change its definition to <code>public abstract class Human : IWorker</code>. This can be read as: <code>Human</code> class implements the <code>IWorker</code> interface.</p>
<p>In the next snippet, <code>Mailman</code> inherits the <code>Human</code> class, which implements the <code>IWorker</code> interface:</p>
<pre>public class Mailman : Human
{
    public Mailman(string name, int age, float weight, float height) : base(name, age, weight, height)
    {
    }
 
    public void DeliverMail(Mail mail)
    {
        // Delivering Mail...
    }
 
    public override void Work()
    {
        Console.WriteLine("Mailman is working...");
    }
}</pre>
<p>If a child class inherits a parent class, which implements some interfaces, the child class will also be able to implement the same interfaces by default. However, <code>Human</code> was an abstract class and you had to provide implementation to the <code>abstract void Work</code> method.</p>
<p>If anyone asked what a human, an ant, and a robot have in common, you could say that they can all work. You can simulate this situation as follows:</p>
<pre>IWorker human = new Mailman("Thomas", 29, 78.5f, 190.11f);
IWorker ant = new Ant();
IWorker robot = new Robot();
 
IWorker[] workers = {human, ant, robot};
foreach (var worker in workers)
{
    worker.Work();
}</pre>
<p>This prints the following to the console:</p>
<pre>Mailman is working...
Ant is working hard.
Beep boop- I am working.</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for the example at <a href="https://packt.link/FE2ag">https://packt.link/FE2ag</a>.</p>
<p>C# does not support multiple inheritance. However, it is possible to implement multiple interfaces. Implementing multiple interfaces does not count as multiple inheritance. For example, to implement a <code>Drone</code> class, you could add an <code>IFlyer</code> interface:</p>
<pre>public interface IFlyer
{
    void Fly();
}</pre>
<p><code>Drone</code> is a flying object that can do some work; therefore it can be expressed as follows:</p>
<pre>public class Drone : IFlyer, IWorker
{
    public void Fly()
    {
        Console.WriteLine("Flying");
    }
 
    public void Work()
    {
        Console.WriteLine("Working");
    }
}</pre>
<p>Listing multiple interfaces with separating commas means the class implements each of them. You can combine any number of interfaces, but try not to overdo this. Sometimes, a combination of two interfaces makes up a logical abstraction. If every drone can fly and does some work, then you can write that in code, as follows:</p>
<pre>public interface IDrone : IWorker, IFlyer
{
}</pre>
<p>And the <code>Drone</code> class becomes simplified to <code>public class Drone : IDrone</code>.</p>
<p>It is also possible to mix interfaces with a base class (but no more than one base class). If you want to represent an ant that flies, you can write the following code:</p>
<pre>public class FlyingAnt : Ant, IFlyer
{
    public void Fly()
    {
        Console.WriteLine("Flying");
    }
}</pre>
<p>An interface is undoubtedly the best abstraction because depending on it does not force you to depend on any implementation details. All that is required is the logical concepts that have been defined. Implementation is prone to change, but the logic behind relations between classes is not.</p>
<p>If an interface defines what a class can do, is it also possible to define a contract for common data? Absolutely. An interface holds behavior, hence it can hold properties as well because they define setter and getter behavior. For example, you should be able to track the drone, and for this, it should be identifiable, that is, it needs to have an ID. This can be coded as follows:</p>
<pre>public interface IIdentifiable
{
    long Id { get; }
}
public interface IDrone : IWorker, IFlyer 
{
}</pre>
<p>In modern software development, there are several complex low-level details that programmers use on a daily basis. However, they often do so without knowing. If you want to create a maintainable code base with lots of logic and easy-to-grasp code, you should follow these principles of abstraction:</p>
<ul>
<li>Keep it simple and small.</li>
<li>Do not depend on details.</li>
<li>Hide complexity.</li>
<li>Expose only what is necessary.</li>
</ul>
<p>With this exercise, you will grasp how OOP functions.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Exercise 2.03: Covering Floor in the Backyard</h2>
<p>A builder is building a mosaic with which he needs to cover an area of x square meters. You have some leftover tiles that are either rectangular or circular. In this exercise, you need to find out whether, if you shatter the tiles to perfectly fill the area they take up, can the tiles fill the mosaic completely.</p>
<p>You will write a program that prints <code>true</code>, if the mosaic can be covered with tiles, or <code>false</code>, if it cannot. Perform the following steps to do so:</p>
<ol>
<li value="1">Create an interface named <code>IShape</code>, with an <code>Area</code> property:<pre>public interface IShape
{
    double Area { get; }
}</pre></li>
</ol>
<p>This is a get-only property. Note that a property is a method, so it is okay to have it in an interface.</p>
<ol>
<li value="2">Create a class called <code>Rectangle</code>, with width and height and a method for calculating area, called <code>Area</code>. Implement an <code>IShape</code> interface for this, as shown in the following code:<pre>Rectangle.cs
public class Rectangle : IShape
{
    private readonly double _width;
    private readonly double _height;
 
    public double Area
    {
        get
        {
            return _width * _height;
        }
    } 
 
    public Rectangle(double width, double height)
    {</pre></li>
</ol>
<pre>You can find the complete code here: <a href="https://packt.link/zSquP">https://packt.link/zSquP</a>.</pre>
<p>The only thing required is to calculate the area. Hence, only the <code>Area</code> property is <code>public</code>. Your interface needs to implement a getter <code>Area</code> property, achieved by multiplying <code>width</code> and <code>height</code>.</p>
<ol>
<li value="3">Create a <code>Circle</code> class with a <code>radius</code> and <code>Area</code> calculation, which also implements the <code>IShape</code> interface:<pre>public class Circle : IShape
{
    Private readonly double _radius;
 
    public Circle(double radius)
    {
        _radius = radius;
    }
 
    public double Area
    {
        get { return Math.PI * _radius * _radius; }
    }
}</pre></li>
<li>Create a skeleton <code>Solution</code> class with a method named <code>IsEnough</code>, as follows:<pre>public static class Solution
{
        public static bool IsEnough(double mosaicArea, IShape[] tiles)
        {
   }
}</pre></li>
</ol>
<p>Both the class and the method are just placeholders for the implementation to come. The class is <code>static</code> because it will be used as a demo and it does not need to have a state. The <code>IsEnough</code> method takes the needed <code>mosaicArea</code>, an array of tiles objects, and returns whether the total area occupied by the tiles is enough to cover the mosaic.</p>
<ol>
<li value="5">Inside the <code>IsEnough</code> method, use a <code>for</code> loop to calculate the <code>totalArea</code>. Then, return whether the total area covers the mosaic area:<pre>            double totalArea = 0;
            foreach (var tile in tiles)
            {
                totalArea += tile.Area;
            }
            const double tolerance = 0.0001;
            return totalArea - mosaicArea &gt;= -tolerance;
       }</pre></li>
<li>Inside the <code>Solution</code> class, create a demo. Add several sets of different shapes, as follows:<pre>public static void Main()
{
    var isEnough1 = IsEnough(0, new IShape[0]);
    var isEnough2 = IsEnough(1, new[] { new Rectangle(1, 1) });
    var isEnough3 = IsEnough(100, new IShape[] { new Circle(5) });
    var isEnough4 = IsEnough(5, new IShape[]
    {
        new Rectangle(1, 1), new Circle(1), new Rectangle(1.4,1)
    });
 
    Console.WriteLine($"IsEnough1 = {isEnough1}, " +
                      $"IsEnough2 = {isEnough2}, " +
                      $"IsEnough3 = {isEnough3}, " +
                      $"IsEnough4 = {isEnough4}.");
}</pre></li>
</ol>
<p>Here, you use four examples. When the area to cover is <code>0</code>, then no matter what shapes you pass, it will be enough. When the area to cover is <code>1</code>, a rectangle of area <code>1x1</code> will be just enough. When it's <code>100</code>, a circle of radius <code>5</code> is not enough. Finally, for the fourth example, the area occupied by three shapes is added up, that is, a rectangle of area <code>1x1</code>, a circle of radius <code>1</code>, and the second rectangle of area <code>1.4x1</code>. The total area is <code>5</code>, which is less than the combined area of these three shapes.</p>
<ol>
<li value="7">Run the demo. You should see the following output on your screen:<pre>IsEnough1 = True, IsEnough2 = True, IsEnough3 = False, IsEnough4 = False.</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/EODE6">https://packt.link/EODE6</a>.</p></li>
</ol>
<p>This exercise is very similar to <em class="italic">Exercise 2.02</em>. However, even though the assignment is more complex, there is less code than in the previous assignment. By using the OOP pillars, you were able to create a simple solution for a complex problem. You were able to create functions that depend on abstraction, rather than making overloads for different types. Thus, OOP is a powerful tool, and this only scratches the surface.</p>
<p>Everyone can write code that works but writing code that lives for decades and is easy to grasp is hard. So, it is imperative to know about the set of best practices in OOP.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>SOLID Principles in OOP</h1>
<p>SOLID principles are a set of best practices for OOP. SOLID is an acronym for five principles, namely, single responsibility, open-closed, Liskov substitution, interface segregation, and dependency inversion. You will not explore each of these in detail.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Single Responsibility Principle</h2>
<p>Functions, classes, projects, and entire systems change over time. Every change is potentially a breaking one, so you should limit the risk of too many things changing at a time. In other words, a part of a code block should have only a single reason to change.</p>
<p>For a function, this means that it should do just one thing and have no side effects. In practice, this means that a function should either change, or get something, but never do both. This also means that functions responsible for high-level things should not be mixed with functions that perform low-level things. Low-level is all about implementing interactions with hardware, and working with primitives. High-level is focused on compositions of software building blocks or services. When talking about high- and low-level functions, it is usually referred to as a chain of dependencies. If function A calls function B, A is considered higher-level than B. A function should not implement multiple things; it should instead call other functions that implement doing one thing. The general guideline for this is that if you think you can split your code into different functions, then in most cases, you should do that.</p>
<p>For classes, it means that you should keep them small and isolated from one another. An example of an efficient class is the <code>File</code> class, which can read and write. If it implemented both reading and writing, it would change for two reasons (reading and writing):</p>
<pre>public class File
{
    public string Read(string filePath)
    {
        // implementation how to read file contents
        // complex logic
        return "";
    }
 
    public void Write(string filePath, string content)
    {
        // implementation how to append content to an existing file
        // complex logic
    }
}</pre>
<p>Therefore, to conform to this principle, you can split the reading code into a class called <code>Reader</code> and writing code into a class called <code>Writer</code>, as follows:</p>
<pre>public class Reader
{
    public string Read(string filePath)
    {
        // implementation how to read file contents
        // complex logic
        return "";
    }
}
public class Writer
{
    public void Write(string filePath, string content)
    {
        // implementation how to append content to an existing file
        // complex logic
    }
}</pre>
<p>Now, instead of implementing reading and writing by itself, the <code>File</code> class will simply be composed of a reader and writer:</p>
<pre>public class File
{
    private readonly Reader _reader;
    private readonly Writer _writer;
 
    public File()
    {
        _reader = new Reader();
        _writer = new Writer();
    }  
 
    public string Read(string filePath) =&gt; _reader.Read(filePath);
    public void Write(string filePath, string content) =&gt; _writer.Write(filePath, content);
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/PBppV">https://packt.link/PBppV</a>.</p>
<p>It might be confusing because what the class does essentially remains the same. However, now, it just consumes a component and is not responsible for implementing it. A high-level class (<code>File</code>) simply adds context to how lower-level classes (<code>Reader</code>, <code>Writer</code>) will be consumed.</p>
<p>For a module (library), it means that you should strive to not introduce dependencies, which would be more than what the consumer would want. For example, if you are using a library for logging, it should not come with some third-party logging provider-specific implementation.</p>
<p>For a subsystem, it means that different systems should be as isolated as possible. If two (lower level) systems need to communicate, they could call one another directly. A consideration (not mandatory) would be to have a third system (higher-level) for coordination. Systems should also be separated through a boundary (such as a contract specifying communication parameters), which hides all the details. If a subsystem is a big library collection, it should have an interface to expose what it can do. If a subsystem is a web service, it should be a collection of endpoints. In any case, a contract of a subsystem should provide only the methods that the client may want.</p>
<p>Sometimes, the principle is overdone and classes are split so much that making a change requires changing multiple places. It does keep true to the principle, as a class will have a single reason to change, but in such a case, multiple classes will change for the same reason. For example, suppose you have two classes: <code>Merchandise</code> and <code>TaxCalculator</code>. The <code>Merchandise</code> class has fields for <code>Name</code>, <code>Price</code>, and <code>Vat</code>:</p>
<pre>public class Merchandise
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    // VAT on top in %
    public decimal Vat { get; set; }
}</pre>
<p>Next, you will create the <code>TaxCalculator</code> class. <code>vat</code> is measured as a percentage, so the actual price to pay will be <code>vat</code> added to the original price:</p>
<pre>public static class TaxCalculator
{
    public static decimal CalculateNextPrice(decimal price, decimal vat)
    {
        return price * (1 + vat / 100);
    }
}</pre>
<p>What would change if the functionality of calculating the price moved to the <code>Merchandise</code> class? You would still be able to perform the required operation. There are two key points here:</p>
<ul>
<li>The operation by itself is simple.</li>
<li>Also, everything that the tax calculator needs come from the <code>Merchandise</code> class.</li>
</ul>
<p>If a class can implement the logic by itself, as long as it is self-contained (does not involve extra components), it usually should. Therefore, a proper version of the code would be as follows:</p>
<pre>public class Merchandise
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    // VAT on top in %
    public decimal Vat { get; set; }
    public decimal NetPrice =&gt; Price * (1 + Vat / 100);
}</pre>
<p>This code moves the <code>NetPrice</code> calculation to the <code>Merchandise</code> class and the <code>TaxCalculator</code> class has been removed.</p>
<p class="callout-heading">Note</p>
<p class="callout">Singe Responsibility Principle (SRP) can be summarized in a couple of words: <strong class="bold">split it</strong>. You can find the code used for this example at <a href="https://packt.link/lWxNO">https://packt.link/lWxNO</a>.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>Open-Closed Principle</h2>
<p>As mentioned previously, every change in code is potentially a breaking one. As a way around this, instead of changing existing code, it is often preferable to write new code. Every software entity should have an extension point, through which the changes should be introduced. However, after this change is done, a software entity should not be interfered with. The Open-Closed Principle (OCP) is hard to implement and takes a lot of practice, but the benefits (a minimum number of breaking changes) are well worth it.</p>
<p>If a multiple-step algorithm does not change, but its individual steps can change, you should split it into several functions. A change for an individual step will no longer affect the entire algorithm, but rather just that step. Such minimization of reasons for a single class or a function to change is what OCP is all about.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on OCP at <a href="https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx">https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx</a>.</p>
<p>Another example where you may want to implement this principle is a function working with combinations of specific values in code. This is called hardcoding and is generally deemed an inefficient practice. To make it work with new values, you might be tempted to create a new function, but by simply removing a hardcoded part and exposing it through function parameters, you can make it extensible. However, when you have variables that are known to be fixed and not changing, it is fine to hardcode them, but they should be flagged as constant.</p>
<p>Previously, you created a file class with two dependencies—<code>Reader</code> and <code>Writer</code>. Those dependencies are hardcoded, and leave you with no extension points. Fixing that will involve two things. First, add the virtual modifier for both the <code>Reader</code> and <code>Writer</code> class methods:</p>
<pre>public virtual string Read(string filePath)
public virtual void Write(string filePath, string content)</pre>
<p>Then, change the constructor of the <code>File</code> class so that it accepts instances of <code>Reader</code> and <code>Writer</code>, instead of hardcoding the dependencies:</p>
<pre>public File(Reader reader, Writer writer)
{
    _reader = reader;
    _writer = writer;
}</pre>
<p>This code enables you to override the existing reader and writer behavior and replace it with whatever behavior you want, that is, the <code>File</code> class extension point.</p>
<p>OCP can be summarized in a few words as <strong class="bold">don't change it, extend it</strong>.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>Liskov Substitution</h2>
<p>The Liskov Substitution Principle (LSP) is one of the most straightforward principles out there. It simply means that a child class should support all the public behavior of a parent class. If you have two classes, <code>Car</code> and <code>CarWreck</code>, where one inherits the other, then you have violated the principle:</p>
<pre>class Car
{
    public object Body { get; set; }
    public virtual void Move()
    {
        // Moving
    }
}
class CarWreck : Car
{
    public override void Move()
    {
        throw new NotSupportedException("A broken car cannot start.");
    }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/6nD76">https://packt.link/6nD76</a>.</p>
<p>Both <code>Car</code> and <code>CarWreck</code> have a <code>Body</code> object. <code>Car</code> can move, but what about <code>CarWreck</code>? It can only stay in one place. The <code>Move</code> method is virtual because <code>CarWreck</code> intends to override it to mark it as not supported. If a child can no longer support what a parent can do, then it should no longer inherit that parent. In this case, a car wreck is not a car, it's simply a wreck.</p>
<p>How do you conform to this principle? All you have to do is to remove the inheritance relationship and replicate the necessary behavior and structure. In this case, <code>CarWreck</code> still has a <code>Body</code> object, but the <code>Move</code> method is unnecessary:</p>
<pre>class CarWreck
{
    public object Body { get; set; }
}</pre>
<p>Code changes happen quite often, and you can sometimes inadvertently use the wrong method to achieve your goals. Sometimes, you couple code in such a way that what you thought was flexible code turns out to be a complex mess. Do not use inheritance as a way of doing code reuse. Keep things small and compose them (again) instead of trying to override the existing behavior. Before things can be reusable, they should be usable. Design for simplicity and you will get flexibility for free.</p>
<p>LSP can be summarized in a few words: <strong class="bold">don't fake it</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on LSP at <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2255313">https://www.microsoftpressstore.com/articles/article.aspx?p=2255313</a>.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor107"/>Interface Segregation</h2>
<p>The interface segregation principle is a special case of the OCP but is only applicable to contracts that will be exposed publicly. Remember, every change you make is potentially a breaking change, and this especially matters in making changes to a contract. Breaking changes are inefficient because they will often require effort to adapt to the change from multiple people.</p>
<p>For example, say you have an interface, <code>IMovableDamageable</code>:</p>
<pre>interface IMovableDamageable
{
    void Move(Location location);
    float Hp{get;set;}
}</pre>
<p>A single interface should represent a single concept. However, in this case, it does two things: move and manage <code>Hp</code> (hit points). By itself, an interface with two methods is not problematic. However, in scenarios of the implementation needing only a part of an interface, you are forced to create a workaround.</p>
<p>For example, score text is indestructible, but you would like it to be animated and to move it across a scene:</p>
<pre>class ScoreText : IMovableDamageable
{
    public float Hp 
    { 
        get =&gt; throw new NotSupportedException(); 
        set =&gt; throw new NotSupportedException(); 
    }
 
    public void Move(Location location)
    {
        Console.WriteLine($"Moving to {location}");
    }
}
 
public class Location
{
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">The point here isn't to print the location; just to give an example of where it is used. It's up to location's implementation whether it will be printed or not as such.</p>
<p>Taking another example, you might have a house that does not move but can be destroyed:</p>
<pre>class House : IMovableDamageable
{
    public float Hp { get; set; }
 
    public void Move(Location location)
    {
        throw new NotSupportedException();
    }
}</pre>
<p>In both scenarios, you worked around the issue by throwing <code>NotSupportedException</code>. However, another programmer should not be given an option to call code that never works in the first place. In order to fix the problem of representing too many concepts, you should split the <code>IMoveableDamageable</code> interface into <code>IMoveable</code> and <code>IDamageable</code>:</p>
<pre>interface IMoveable
{
    void Move(Location location);
}
interface IDamageable
{
    float Hp{get;set;}
}</pre>
<p>And the implementations can now get rid of the unnecessary parts:</p>
<pre>class House : IDamageable
{
    public float Hp { get; set; }
}
 
class ScoreText : IMovable
{
    public void Move(Location location)
    {
        Console.WriteLine($"Moving to {location}");
    }
}</pre>
<p>The <code>Console.WriteLine</code>, in the preceding code, would display the namespace name with the class name.</p>
<p class="callout-heading">Note</p>
<p class="callout">Interface segregation can be summarized as <strong class="bold">don't enforce it</strong>. You can find the code used for this example at <a href="https://packt.link/32mwP">https://packt.link/32mwP</a>.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/>Dependency Inversion</h2>
<p>Large software systems can consist of millions of classes. Each class is a small dependency, and if unmanaged, the complexity might stack into something impossible to maintain. If one low-level component breaks, it causes a ripple effect, breaking the whole chain of dependencies. The dependency inversion principle states that you should avoid hard dependence on underlying classes.</p>
<p>Dependency injection is the industry-standard way of implementing dependency inversion. Do not mix the two; one is a principle and the other refers to the implementation of this principle.</p>
<p>Note that you can also implement dependency inversion without dependency injection. For example, when declaring a field, instead of writing something like <code>private readonly List&lt;int&gt; _numbers = new List&lt;int&gt;();</code>, it is preferable to write <code>private readonly IList&lt;int&gt; = _numbers</code>, which shifts dependency to abstraction (<code>IList</code>) and not implementation (<code>List</code>).</p>
<p>What is dependency injection? It is the act of passing an implementation and setting it to an abstraction slot. There are three ways to implement this:</p>
<ul>
<li>Constructor injection is achieved by exposing an abstraction through the constructor argument and passing an implementation when creating an object and then assigning it to a field. Use it when you want to consistently use the same dependency in the same object (but not necessarily the same class).</li>
<li>Method injection is done by exposing an abstraction through a method argument, and then passing an implementation when calling that method. Use it when, for a single method, a dependency might vary, and you do not plan to store the dependency throughout that object's lifetime.</li>
<li>Property injection is implemented by exposing an abstraction through a public property, and then assigning (or not) that property to some exact implementation. Property injection is a rare way of injecting dependencies because it suggests that dependency might even be null or temporary and there are many ways in which it could break.</li>
</ul>
<p>Given two types, <code>interface IBartender { }</code> and <code>class Bar : Bartender { }</code>, you can illustrate the three ways of dependency injection for a class called <code>Bar</code>.</p>
<p>First, prepare the <code>Bar</code> class for constructor injection:</p>
<pre>class Bar
{
    private readonly IBartender _bartender;
 
    public Bar(IBartender bartender)
    {
        _bartender = bartender;
    }
}</pre>
<p>The constructor injection is done as follows:</p>
<pre>var bar = new Bar(new Bartender());</pre>
<p>This kind of dependency injection is a dominating kind of inheritance, as it enforces stability through immutability. For example, some bars have just one bartender.</p>
<p>Method injection would look like this:</p>
<pre>class Bar
{
    public void ServeDrinks(IBartender bartender)
    {
        // serve drinks using bartender
    }
}</pre>
<p>The injection itself is as follows:</p>
<pre>var bar = new Bar();
bar.ServeDrinks(new Bartender());</pre>
<p>Often, this kind of dependency injection is called interface injection because the method often goes under an interface. The interface itself is a great idea, but that does not change the idea behind this kind of dependency injection. Use method injection when you immediately consume a dependency that you set, or when you have a complex way of setting new dependencies dynamically. For example, it makes sense to use different bartenders for serving drinks.</p>
<p>Finally, property injection can be done like this:</p>
<pre>class Bar
{
    public IBartender Bartender { get; set; }
}</pre>
<p>Bartender is now injected like this:</p>
<pre>var bar = new Bar();
bar.Bartender = new Bartender();</pre>
<p>For example, a bar might have bartenders changing shifts, but one bartender at a time.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/JcmAT">https://packt.link/JcmAT</a>.</p>
<p>Property injection in other languages might have a different name: setter injection. In practice, components do not change that often, so this kind of dependency injection is the rarest.</p>
<p>For the <code>File</code> class, this should mean that instead of exposing classes (implementation), you should expose abstractions (interfaces). This means that your <code>Reader</code> and <code>Writer</code> classes should implement some contract:</p>
<pre>public class Reader : IReader
public class Writer: IWriter</pre>
<p>Your file class should expose reader and writer abstractions, instead of implementations, as follows:</p>
<pre>private readonly IReader _reader;
private readonly IWriter _writer;
 
public File(IReader reader, IWriter writer)
{
    _reader = reader;
    _writer = writer;
}</pre>
<p>This allows for a choice of the kind of <code>IReader</code> and <code>IWriter</code> you would like to inject. A different reader may read a different file format, or a different writer may output in a different way. You have a choice.</p>
<p>Dependency injection is a powerful tool that is used often, especially in an enterprise setting. It allows you to simplify complex systems by putting an interface in between and having 1:1 dependencies of implementation-abstraction-implementation.</p>
<p>Writing effective code that does not break can be paradoxical. It is the same as buying a tool from a shop; you can't know for sure how long it will last, or how well it will work. Code, just like those tools, might work now but break in the near future, and you will only know that it does not work if and when it breaks.</p>
<p>Observing and waiting, seeing how the code evolves, is the only way to know for sure if you have written an effective code. In small, personal projects, you might not even notice any changes, unless you expose the project to the public or involve other people. To most people, SOLID principles often sound like old, outdated principles, like over-engineering. But they are actually a set of best practices that have withstood the test of time, formulated by top professionals seasoned in enterprise settings. It is impossible to write perfect, SOLID code right away. In fact, in some cases, it is not even necessary (if a project is small and meant to be short-lived, for example). As someone who wants to produce quality software and work as a professional, you should practice it as early on as possible.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>How C# Helps with Object-Oriented Design</h1>
<p>So far, the principles you have learned are not language-specific. It is time to learn how to use C# for OOP. C# is a great language because it is full of some very useful features. It is not only one of the most productive languages to work with, but it also allows you to write beautiful, hard-to-break code. With a rich selection of keywords and languages features, you can model your classes completely the way you want, making the intentions crystal clear. This section will delve deep into C# features that help with object-oriented design.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Static</h2>
<p>Up till now in this book, you have interacted mostly with <code>static</code> code. This refers to code that does not need new classes and objects, and that can be called right away. In C#, the static modifier can be applied in five different scenarios—methods, fields, classes, constructors, and the <code>using</code> statement.</p>
<p>Static methods and fields are the simplest application of the <code>static</code> keyword:</p>
<pre>public class DogsGenerator
{
    public static int Counter { get; private set; }
    static DogsGenerator()
    {
        // Counter will be 0 anyways if not explicitly provided,
        // this just illustrates the use of a static constructor.
        Counter = 0;
    }
    public static Dog GenerateDog()
    {
        Counter++;
        return new Dog("Dog" + Counter);
    }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/748m3">https://packt.link/748m3</a>.</p>
<p>Here, you created a class called <code>DogsGenerator</code>. A <code>static class</code> cannot be initialized manually (using the <code>new</code> keyword). Internally, it is initialized, but only once. Calling the <code>GenerateDog</code> method returns a new <code>Dog</code> object with a counter next to its name, such as <code>Dog1</code>, <code>Dog2</code>, and <code>Dog3</code>. Writing a counter like this allows you to increment it from everywhere as it is <code>public static</code> and has a setter. This can be done by directly accessing the member from a class: <code>DogsGenerator.Counter++</code> will increment the counter by <code>1</code>.</p>
<p>Once again, note that this does not require a call through an object because a <code>static class</code> instance is the same for the entire application. However, <code>DogsGenerator</code> is not the best example of a <code>static class</code>. That's because you have just created a global state. Many people would say that <code>static</code> is inefficient and should be avoided because it might create unpredictable results due to being modified and accessed uncontrollably. </p>
<p>A public mutable state means that changes can happen from anywhere in the application. Other than being hard to grasp, such code is also prone to breaking in the context of applications with multiple threads (that is, it is not thread-safe).</p>
<p class="callout-heading">Note</p>
<p class="callout">You will learn about threading in detail in <em class="italic">Chapter 5</em>, <em class="italic">Concurrency: Multithreading Parallel and Async Code</em>.</p>
<p>You can reduce the impact of a global state by making it publicly immutable. The benefit of doing so is that now you are in control. Instead of allowing a counter increment to happen from any place inside a program, you will change it within <code>DogsGenerator</code> only. For the <code>counter</code> property, achieving it is as simple as making the setter property <code>private</code>.</p>
<p>There is one valuable use case for the <code>static</code> keyword though, which is with helper functions. Such functions take an input and return the output without modifying any state internally. Moreover, a class that contains such functions is <code>static </code>and has no state. Another good application of the <code>static</code> keyword is creating immutable constants. They are defined with a different keyword (<code>const</code>). The <code>PI</code> and <code>E</code>, static helper methods such as <code>Sqrt</code> and <code>Abs</code>, and so on.</p>
<p>The <code>DogsGenerator</code> class has no members that would be applicable to an object. If all class members are <code>static</code>, then the class should be <code>static</code> as well. Therefore, you should change the class to <code>public static class DateGenerator</code>. Be aware, however, that depending on <code>static</code> is the same as depending on a concrete implementation. Although they are easy to use and straightforward, static dependencies are hard to escape and should only be used for simple code, or code that you are sure will not change and is critical in its implementation details. For that reason, the <code>Math</code> class is a <code>static class</code> as well; it has all the foundations for arithmetic calculations.</p>
<p>The last application of <code>static</code> is <code>using static</code>. Applying the <code>static</code> keyword before a <code>using</code> statement causes all methods and fields to be directly accessible without the need to call a <code>class</code>. For example, consider the following code:</p>
<pre>using static Math;
public static class Demo
{
    public static void Run()
    {
   //No need Math.PI
        Console.WriteLine(PI);
    } 
}</pre>
<p>This is a static import feature in C#. By using <code>static Math</code>, all static members can be accessed directly.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor111"/>Sealed</h2>
<p>Previously, you mentioned that inheritance should be handled with great care because the complexity can quickly grow out of hand. You can carefully consider complexity when you read and write code, but can you prevent complexity by design? C# has a keyword for stopping inheritance called <code>sealed</code>. If it logically makes no sense to inherit a class, then you should mark it with the <code>sealed</code> keyword. Security-related classes should also be sealed because it is critical to keep them simple and non-overridable. Also, if performance is critical, then methods in inherited classes are slower, compared to being directly in a sealed class. This is due to how method lookup works.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Partial</h2>
<p>In .NET, it is quite popular to make desktop applications using <code>WinForms</code>. The way <code>WinForms</code> works is that you can design how your application looks, with the help of a designer. Internally, it generates UI code and all you have to do is double-click a component, which will generate event handler code. That is where the partial class comes in. All the boring, autogenerated code will be in one class and the code that you write will be in another. The key point to note is that both classes will have the same name but be in different files.</p>
<p>You can have as many partial classes as you want. However, the recommended number of partial classes is no more than two. The compiler will treat them as one big class, but to the user, they will seem like two separate ones. Generating code generates new class files, which will overwrite the code you write. Use <code>partial</code> when you are dealing with autogenerated code. The biggest mistake that beginners make is using <code>partial</code> to manage big complex classes. If your class is complex, it's best to split it into smaller classes, not just different files.</p>
<p>There is one more use case for <code>partial</code>. Imagine you have a part of code in a class that is only needed in another assembly but is unnecessary in the assembly it is originally defined in. You can have the same class in different assemblies and mark it as <code>partial</code>. That way, a part of a class that is not needed will only be used where it is needed and be hidden where it should not be seen.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>Virtual</h2>
<p>Abstract methods can be overridden; however, they cannot be implemented. What if you wanted to have a method with a default behavior that could be overridden in the future? You can do this using the <code>virtual</code> keyword, as shown in the following example:</p>
<pre>public class Human
{
    public virtual void SayHi()
    {
        Console.WriteLine("Hello!");
    }
}</pre>
<p>Here, the <code>Human</code> class has the <code>SayHi</code> method. This method is prefixed with the virtual keyword, which means that it can change behavior in a child class, for example:</p>
<pre>public class Frenchman : Human
{
    public override void SayHi()
    {
        Console.WriteLine("Bonjour!");
    }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ZpHhI">https://packt.link/ZpHhI</a>.</p>
<p>The <code>Frenchman</code> class inherits the <code>Human</code> class and overrides the <code>SayHi</code> method. Calling <code>SayHi</code> from a <code>Frenchman</code> object will print <code>Bonjour</code>.</p>
<p>One of the things about C# is that its behavior is hard to override. Upon declaring a method, you need to be explicit by telling the compiler that the method can be overridden. Only <code>virtual</code> methods can be overridden. Interface methods are virtual (because they get behavior later), however, you cannot override interface methods from child classes. You can only implement an interface in a parent class.</p>
<p>An abstract method is the last type of virtual method and is the most similar to <code>virtual</code> in that it can be overridden as many times as you need (in child and grandchild classes).</p>
<p>To avoid having fragile, changing, overridable behavior, the best kind of virtual methods are the ones that come from an interface. The <code>abstract</code> and <code>virtual</code> keywords enable changing class behavior in child classes and overriding it, which can become a big issue if uncontrolled. Overriding behavior often causes both inconsistent and unexpected results, so you should be careful before using the <code>virtual</code> keyword.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Internal</h2>
<p><code>public</code>, <code>private</code>, and <code>protected</code> are the three access modifiers that have been mentioned. Many beginners think that the default class modifier is <code>private</code>. However, <code>private</code> means that it cannot be called from outside a class, and in the context of a namespace, this does not make much sense. The default access modifier for a class is <code>internal</code>. This means that the class will only be visible inside the namespace it is defined in. The <code>internal</code> modifier is great for reusing classes across the same assembly, while at the same time hiding them from the outside.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor115"/>Conditional Operators</h1>
<p>A null reference exception is probably the most common error in programming. For example, refer to the following code:</p>
<pre>int[] numbers = null;
numbers.length;</pre>
<p>This code will throw <code>NullReferenceException</code> because you are interacting with a variable that has a null value. What is the length of a null array? There is no proper answer to this question, so an exception will be thrown here.</p>
<p>The best way to protect against such an error is to avoid working with null values altogether. However, sometimes it is unavoidable. In those cases, there is another technique called defensive programming. Before using a value that might be <code>null</code>, make sure it is not <code>null</code>.</p>
<p>Now recall the example of the <code>Dog</code> class. If you create a new object, the value of <code>Owner</code> could be null. If you were to determine whether the owner's name starts with the letter <code>A</code>, you would need to check first whether the value of <code>Owner</code> is <code>null</code>, as follows:</p>
<pre>if (dog.Owner != null)
{
    bool ownerNameStartsWithA = dog.Owner.StartsWith('A');
}</pre>
<p>However, in C#, using null-conditional, this code becomes as simple as the following:</p>
<pre>dog.Owner?.StartsWith('A');</pre>
<p>Null-conditional (<code>?</code>) is an example of conditional operators in C#. It is an operator that implicitly runs an <code>if</code> statement (a specific <code>if</code> statement is based on the operator) and either returns something or continues work. The <code>Owner?.StartsWith('A')</code> part returns <code>true</code> if the condition is satisfied and <code>false</code> if it is either not satisfied or the object is <code>null</code>.</p>
<p>There are more conditional operators in C# that you will learn about.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor116"/>Ternary Operators</h2>
<p>There is hardly any language that does not have <code>if</code> statements. One of the most common kinds of <code>if</code> statement is <code>if-else</code>. For example, if the value of <code>Owner</code> is <code>null</code> for an instance of the <code>Dog</code> class, you can describe the instance simply as <code>{Name}</code>. Otherwise, you can better describe it as <code>{Name}, dog of {Owner}</code>, as shown in the following snippet:</p>
<pre>if (dog1.Owner == null)
{
    description = dog1.Name;
}
else
{
    description = $"{dog1.Name}, dog of {dog1.Owner}";
}</pre>
<p>C#, like many other languages, simplifies this by using a ternary operator:</p>
<pre>description = dog1.Owner == null
    ? dog1.Name
    : $"{dog1.Name}, dog of {dog1.Owner}";</pre>
<p>On the left side, you have a condition (true or false), followed by a question mark (<code>?</code>), which returns the value on the right if the condition is true, followed by a colon (<code>:</code>), which returns the value to the left if the condition is false. <code>$</code> is a string interpolation literal, which allows you to write <code>$"{dog1.Name}, dog of {dog1.Owner}"</code> over <code>dog1.Name + "dog of" + dog1.Owner</code>. You should use it when concatenating text.</p>
<p>Imagine there are two dogs now. You want the first dog to join the second one (that is, be owned by the owner of the second dog), but this can only happen if the second one has an owner to begin with. Normally, you would use the following code:</p>
<pre>if (dog1.Owner != null)
{
    dog2.Owner = dog1.Owner;
}</pre>
<p>But in C#, you can use the following code:</p>
<pre>dog1.Owner = dog1.Owner ?? dog2.Owner;</pre>
<p>Here, you have applied the null-coalescing operator (<code>??</code>), which returns the value to the right if it is <code>null</code> and the value on the left if it is not <code>null</code>. However, you can simplify this further:</p>
<pre>dog1.Owner ??= dog2.Owner;</pre>
<p>This means that if the value that you are trying to assign (on the left) is <code>null</code>, then the output will be the value on the right.</p>
<p>The last use case for the null-coalescing operator is input validation. Suppose there are two classes, <code>ComponentA</code> and <code>ComponentB</code>, and <code>ComponentB</code> must contain an initialized instance of <code>ComponentA</code>. You could write the following code:</p>
<pre>public ComponentB(ComponentA componentA)
{
    if (componentA == null)
    {
        throw new ArgumentException(nameof(componentA));
    }
    else
    {
        _componentA = componentA;
    }
}</pre>
<p>However, instead of the preceding code, you can simply write the following:</p>
<pre>_componentA = componentA ?? throw new ArgumentNullException(nameof(componentA));</pre>
<p>This can be read as If there is no <code>componentA</code>, then an exception must be thrown.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/yHYbh">https://packt.link/yHYbh</a>.</p>
<p>In most cases, null operators should replace the standard <code>if null-else</code> statements. However, be careful with the way you use the ternary operator and limit it to simple <code>if-else</code> statements because the code can become unreadable very quickly.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor117"/>Overloading Operators</h2>
<p>It is fascinating how much can be abstracted away in C#. Comparing primitive numbers, multiplying, or dividing them is easy, but when it comes to objects, it is not that simple. What is one person plus another person? What is a bag of apples multiplied by another bag of apples? It is hard to say, but it can make total sense in the context of some domains.</p>
<p>Consider a slightly better example. Suppose you are comparing bank accounts. Finding out who has more money in a bank account is a common use case. Normally, to compare two accounts, you would have to access their members, but C# allows you to overload comparison operators so that you can compare objects. For example, imagine you had a <code>BankAccount</code> class like so:</p>
<pre>public class BankAccount
{
    private decimal _balance;
 
    public BankAccount(decimal balance)
    {
        _balance = balance;
    }
}</pre>
<p>Here, the balance amount is <code>private</code>. You do not care about the exact value of <code>balance</code>; all you want is to compare one with another. You could implement a <code>CompareTo</code> method, but instead, you will implement a comparison operator. In the <code>BankAccount</code> class, you will add the following code:</p>
<pre>public static bool operator &gt;(BankAccount account1, BankAccount account2)
    =&gt; account1?._balance &gt; account2?._balance;</pre>
<p>The preceding code is called an operator overload. With a custom operator overload like this, you can return true when a balance is bigger and false otherwise. In C#, operators are <code>public static</code>, followed by a return type. After that, you have the <code>operator</code> keyword followed by the actual operator that is being overloaded. The input depends on the operator being overloaded. In this case, you passed two bank accounts.</p>
<p>If you tried to compile the code as it is, you would get an error that something is missing. It makes sense that the comparison operators have a twin method that does the opposite. Now, add the less operator overload as follows:</p>
<pre>public static bool operator &lt;(BankAccount account1, BankAccount account2)
    =&gt; account1?._balance &lt; account2?._balance;</pre>
<p>The code compiles now. Finally, it would make sense to have an equality comparison. Remember, you will need to add a pair, equal and not equal:</p>
<pre>public static bool operator ==(BankAccount account1, BankAccount account2)
    =&gt; account1?._balance == account2?._balance; 
public static bool operator !=(BankAccount account1, BankAccount account2)
    =&gt; !(account1 == account2);</pre>
<p>Next, you will create bank accounts to compare. Note that all numbers have an <code>m</code> appended, as this suffix makes those numbers <code>decimal</code>. By default, numbers with a fraction are <code>double</code>, so you need to add <code>m</code> at the end to make them <code>decimal</code>:</p>
<pre>var account1 = new BankAccount(-1.01m);
var account2 = new BankAccount(1.01m);
var account3 = new BankAccount(1001.99m);
var account4 = new BankAccount(1001.99m);</pre>
<p>Comparing two bank accounts becomes as simple as this now:</p>
<pre>Console.WriteLine(account1 == account2);
Console.WriteLine(account1 != account2);
Console.WriteLine(account2 &gt; account1);
Console.WriteLine(account1 &lt; account2);
Console.WriteLine(account3 == account4);
Console.WriteLine(account3 != account4);</pre>
<p>Running the code results in the following being printed to the console:</p>
<pre>False
True
True
True
True
False</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/5DioJ">https://packt.link/5DioJ</a>.</p>
<p>Many (but not all) operators can be overloaded, but just because you can do so does not mean you should. Overloading operators can make sense in some cases, but in other cases, it might be counterintuitive. Again, remember to not abuse C# features and use them when it makes <strong class="bold">logical</strong> sense, and when it makes code easier to read, learn, and maintain.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor118"/>Nullable Primitive Types</h2>
<p>Have you ever wondered what to do when a primitive value is unknown? For example, say a collection of products are announced. Their names, descriptions, and some other parameters are known, but the price is revealed only before the launch. What type should you use for storing the price values?</p>
<p>Nullable primitive types are primitive types that might have some value or no value. In C#, to declare such a type, you have to add <code>?</code> after a primitive, as shown in the following code:</p>
<pre>int? a = null;</pre>
<p>Here, you declared a field that may or may not have a value. Specifically, this means that a can be unknown. Do not confuse this with a default value because, by default, the value of <code>int</code> types is <code>0</code>.</p>
<p>You can assign a value to a nullable field quite simply, as follows:</p>
<pre>a = 1;</pre>
<p>And to retrieve its value afterward, you can write the code as follows:</p>
<pre>int b = a.Value;</pre>
<h2 id="_idParaDest-117"><a id="_idTextAnchor119"/>Generics</h2>
<p>Sometimes, you will come across situations where you do the exact same thing with different types, where the only difference is because of the type. For example, if you had to create a method that prints an <code>int</code> value, you could write the following code:</p>
<pre>public static void Print(int element)
{
    Console.WriteLine(element);
}
If you need to print a float, you could add another overload:
public static void Print(float element)
{
    Console.WriteLine(element);
}</pre>
<p>Similarly, if you need to print a string, you could add yet another overload:</p>
<pre>public static void Print(string element)
{
    Console.WriteLine(element);
}</pre>
<p>You did the same thing three times. Surely, there must be a way to reduce code duplication. Remember, in C#, all types derive from an <code>object</code> type, which has the <code>ToString()</code> method, so you can execute the following command:</p>
<pre>public static void Print(object element)
{
    Console.WriteLine(element);
}</pre>
<p>Even though the last implementation contains the least code, it is actually the least efficient. An object is a reference type, whereas a primitive is a value type. When you take a primitive and assign it to an object, you also create a new reference to it. This is called boxing. It does not come for free, because you move objects from <code>stack to heap</code>. Programmers should be conscious of this fact and avoid it wherever possible.</p>
<p>Earlier in the chapter, you encountered polymorphism—a way of doing different things using the same type. You can do the same things with different types as well and generics are what enable you to do that. In the case of the <code>Print</code> example, a generic method is what you need:</p>
<pre>public static void Print&lt;T&gt;(T element)
{
    Console.WriteLine(element);
}</pre>
<p>Using diamond brackets (<code>&lt;&gt;</code>), you can specify a type, <code>T</code>, with which this function works. <code>&lt;T&gt;</code> means that it can work with any type.</p>
<p>Now, suppose you want to print all elements of an array. Simply passing a collection to a <code>WriteLine</code> statement would result in printing a reference, instead of all the elements. Normally, you would create a method that prints all the elements passed. With the power of generics, you can have one method that prints an array of any type:</p>
<pre>public static void Print&lt;T&gt;(T[] elements)
{
    foreach (var element in elements)
    {
        Console.WriteLine(element);
    }
}</pre>
<p>Please note that the generic version is not as efficient as taking an <code>object</code> type, simply because you would still be using a <code>WriteLine</code> overload that takes an object as a parameter. When passing a generic, you cannot tell whether it needs to call an overload with an <code>int</code>, <code>float</code>, or <code>String</code>, or whether there is an exact overload in the first place. If there was no overload that takes an object for <code>WriteLine</code>, you would not be able to call the <code>Print</code> method. For that reason, the most performant code is actually the one with three overloads. It is not terribly important though because that is just one, very specific scenario where boxing happens anyway. There are so many other cases, however, where you can make it not only concise but performant as well.</p>
<p>Sometimes, the answer to choosing a generic or polymorphic function hides in tiny details. If you had to implement a method for comparing two elements and return <code>true</code> if the first one is bigger, you could do that in C# using an <code>IComparable</code> interface:</p>
<pre>public static bool IsFirstBigger1(IComparable first, IComparable second)
{
    return first.CompareTo(second) &gt; 0;
}</pre>
<p>A generic version of this would look like this:</p>
<pre>public static bool IsFirstBigger2&lt;T&gt;(T first, T second)
    where T : IComparable
{
    return first.CompareTo(second) &gt; 0;
}</pre>
<p>The new bit here is <code>where T : IComparable</code>. It is a generic constraint. By default, you can pass any type to a generic class or method. Constraints still allow different types to be passed, but they significantly reduce the possible options. A generic constraint allows only the types that conform to the constraint to be passed as a generic type. In this case, you will allow only the types that implement the <code>IComparable</code> interface. Constraints might seem like a limitation on types; however, they expose the behavior of the constrained types that you can use inside a generic method. Having constraints enables you to use the features of those types, so it is very useful. In this case, you do limit yourself to what types can be used, but at the same time, whatever you pass to the generic method will be comparable.</p>
<p>What if instead of returning whether the first element is bigger, you needed to return the first element itself? You could write a non-generic method as follows:</p>
<pre>public static IComparable Max1(IComparable first, IComparable second)
{
    return first.CompareTo(second) &gt; 0
        ? first
        : second;
}</pre>
<p>And the generic version would look as follows:</p>
<pre>public static T Max2&lt;T&gt;(T first, T second)
    where T : IComparable
{
    return first.CompareTo(second) &gt; 0
        ? first
        : second;
}</pre>
<p>Also, it is worth comparing how you will get a meaningful output using each version. With a non-generic method, this is what the code would look like:</p>
<pre>int max1 = (int)Comparator.Max1(3, -4);</pre>
<p>With a generic version, the code would be like this:</p>
<pre>int max2 = Comparator.Max2(3, -4);</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/sIdOp">https://packt.link/sIdOp</a>.</p>
<p>In this case, the winner is obvious. In the non-generic version, you have to do a cast. Casting in code is frowned upon because if you do get errors, you will get them during runtime and things might change and the cast will fail. Casting is also one extra action, whereas the generic version is far more fluent because it does not have a cast. Use generics when you want to work with types as-is and not through their abstractions. And returning an exact (non-polymorphic) type from a function is one of the best use cases for it.</p>
<p>C# generics will be covered in detail in <em class="italic">Chapter 4</em>, <em class="italic">Data Structures and LINQ</em>.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>Enum</h2>
<p>The <code>enum</code> type represents a set of known values. Since it is a type, you can pass it instead of passing a primitive value to methods. <code>enum</code> holds all the possible values, hence it isn't possible to have a value that it would not contain. The following snippet shows a simple example of this:</p>
<pre>public enum Gender
{
    Male,
    Female,
    Other
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/gP9Li">https://packt.link/gP9Li</a>.</p>
<p>You can now get a possible gender value as if it were in a <code>static class</code> by writing <code>Gender.Other</code>. Enums can easily be converted to an integer using casting—<code>(int)Gender.Male</code> will return <code>0</code>, <code>(int)Gender.Female</code> will return <code>1</code>, and so on. This is because <code>enum</code>, by default, starts numbering at <code>0</code>.</p>
<p>Enums do not have any behavior and they are known as constant containers. You should use them when you want to work with constants and prevent invalid values from being passed by design.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>Extension Methods</h2>
<p>Almost always, you will be working with a part of code that does not belong to you. Sometimes, this might cause inconvenience because you have no access to change it. Is it possible to somehow extend the existing types with the functionality you want? Is it possible to do so without inheriting or creating new component classes?</p>
<p>You can achieve this easily through extension methods. They allow you to add methods on complete types and call them as if those methods were natively there.</p>
<p>What if you wanted to print a <code>string</code> to a console using a <code>Print</code> method, but call it from a <code>string</code> itself? <code>String</code> has no such method, but you can add it using an extension method:</p>
<pre>public static class StringExtensions
{
    public static void Print(this string text)
    {
        Console.WriteLine(text);
    }
}</pre>
<p>And this allows you to write the following code:</p>
<pre>"Hey".Print();</pre>
<p>This will print <code>Hey</code> to the console as follows:</p>
<pre>Hey</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/JC5cj">https://packt.link/JC5cj</a>.</p>
<p>Extension methods are <code>static</code> and must be placed within a <code>static class</code>. If you look at the semantics of the method, you will notice the use of the <code>this</code> keyword. The <code>this</code> keyword should be the first argument in an extension method. After that, the function continues as normal and you can use the argument with the <code>this</code> keyword as if it was just another argument.</p>
<p>Use extension methods to add (extend, but not the same extensions as what happens with inheritance) new behavior to existing types, even if the type would not support having methods otherwise. With extension methods, you can even add methods to <code>enum</code> types, which is not possible otherwise.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor122"/>Struct</h1>
<p>A class is a reference type, but not all objects are reference types (saved on the heap). Some objects can be created on the stack, and such objects are made using structs.</p>
<p>A struct is defined like a class, but it is used for slightly different things. Now, create a <code>struct</code> named <code>Point</code>:</p>
<pre>public struct Point
{
    public readonly int X;
    public readonly int Y;
 
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}</pre>
<p>The only real difference here is the <code>struct</code> keyword, which indicates that this object will be saved on the stack. Also, you might have noticed that there is no use of properties. There are many people who would, instead of <code>Point</code>, type <code>x</code> and <code>y</code>. It is not a big deal, but instead of one variable, you would be working with two. This way of working with primitives is called primitive obsession. You should follow the principles of OOP and work with abstractions, well-encapsulated data, as well as behavior to keep things close so that they have high cohesion. When choosing where to place variables, ask yourself this question: can <code>x</code> change independently of <code>y</code>? Do you ever modify a point? Is a point a complete value on its own? The answer to all of this is <strong class="bold">yes</strong> and therefore putting it in a data structure makes sense. But why choose a struct over a class?</p>
<p>Structs are fast because they do not have any allocations on the heap. They are also fast because they are passed by value (therefore, access is direct, not through a reference). Passing them by value copies the values, so even if you could modify a struct, changes would not remain outside of a method. When something is just a simple, small composite value, you should use a struct. Finally, with structs, you get value equality.</p>
<p>Another effective example of a <code>struct</code> is <code>DateTime</code>. <code>DateTime</code> is just a unit of time, containing some information. It also does not change individually and supports methods such as <code>AddDays</code>, <code>TryParse</code>, and <code>Now</code>. Even though it has several different pieces of data, they can be treated as one unit, as they are date- and time-related.</p>
<p>Most <code>structs</code> should be immutable because they are passed by a copy of a value, so changing something inside a method will not keep those changes. You can add a <code>readonly</code> keyword to a <code>struct</code>, making all its fields <code>readonly</code>:</p>
<pre>public readonly struct Point
{
    public int X { get; }
    public int Y { get; }
 
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}</pre>
<p>A <code>readonly</code> <code>struct</code> can have either a <code>readonly</code> field or getter properties. This is useful for the future maintainers of your code base as it prevents them from doing things that you did not design for (no mutability). Structs are just tiny grouped bits of data, but they can have behavior as well. It makes sense to have a method to calculate the distance between two points:</p>
<pre>public static double DistanceBetween(Point p1, Point p2)
{
    return Math.Sqrt((p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y));
}</pre>
<p>The preceding code has a little bit of math in it—that is, distance between two points is the square root of points x's and y's squared differences added together.</p>
<p>It also makes sense to calculate the distance between this and other points. You do not need to change anything because you can just reuse the existing code, passing correct arguments:</p>
<pre>public double DistanceTo(Point p)
{
    return DistanceBetween(this, p);
}</pre>
<p>If you wanted to measure the distance between two points, you could create them like this:</p>
<pre>var p1 = new Point(3,1);
var p2 = new Point(3,4);</pre>
<p>And use a member function to calculate distance:</p>
<pre>var distance1 = p1.DistanceTo(p2);</pre>
<p>Or a static function:</p>
<pre>var distance2 = Point.DistanceBetween(p1, p2);</pre>
<p>The result for each version will be as follows:</p>
<pre>– 3.</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/PtQzz">https://packt.link/PtQzz</a>.</p>
<p>When you think about a struct, think about it as just a group of primitives. The key point to remember is that all the data members (properties or fields) in a struct must be assigned during object initialization. It needs to be done for the same reason local variables cannot be used without having a value set initially. Structs do not support inheritance; however, they do support implementing an interface.</p>
<p>Structs are actually a great way to have simple business logic. Structs should be kept simple and should not contain other object references within them; they should be primitive-only. However, a class can hold as many struct objects as it needs. Using structs is a great way of escaping the obsessive use of primitives and using simple logic naturally, within a tiny group of data where it belongs—that is, a <code>struct</code>.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Record</h2>
<p>A record is a reference type (unlike a <code>struct</code>, more like a class). However, out of the box, it has methods for comparison by value (both using the <code>equals</code> method and the operator). Also, a record has a different default implementation of <code>ToString()</code>, which no longer prints a type, but instead all the properties. This is exactly what is needed in many cases, so it helps a lot. Finally, there is a lot of syntactic sugar around records, which you are about to witness.</p>
<p>You already know how to create custom types in C#. The only difference between different custom types is the keyword used. For record types, such a keyword is <code>record</code>. For example, you will now create a movie record. It has a <code>Title</code>, <code>Director</code>, <code>Producer</code>, <code>Description</code>, and a <code>ReleaseDate</code>:</p>
<pre>public record MovieRecordV1
{
    public string Title { get; }
    public string Director { get; }
    public string Producer { get; } 
    public string Description { get; set; }
    public DateTime ReleaseDate { get; }
 
    public MovieRecordV1(string title, string director, string producer, DateTime releaseDate)
    {
        Title = title;
        Director = director;
        Producer = producer;
        ReleaseDate = releaseDate;
    }
}</pre>
<p>So far, you should find this very familiar, because the only difference is the keyword. Regardless of such a minor detail, you already reap major benefits.</p>
<p class="callout-heading">Note</p>
<p class="callout">The intention of having <code>MovieRecordV1</code> class in chapter, as against <code>MovieClass</code> in GitHub code, was to have a type, similar to a class and then refactor highlighting how record helps.</p>
<p>Create two identical movies:</p>
<pre>private static void DemoRecord()
{
    var movie1 = new MovieRecordV1(
        "Star Wars: Episode I – The Phantom Menace",
        "George Lucas",
        "Rick McCallum",
        new DateTime(1999, 5, 15));
 
    var movie2 = new MovieRecordV1(
        "Star Wars: Episode I – The Phantom Menace",
        "George Lucas",
        "Rick McCallum",
        new DateTime(1999, 5, 15));
}</pre>
<p>So far, everything is the same. Try to print a movie to the console:</p>
<pre>    Console.WriteLine(movie1);</pre>
<p>The output would be as follows:</p>
<pre>MovieRecordV1 { Title = Star Wars: Episode I - The Phantom Menace, Director = George Lucas, Producer
= Rick McCallum, Description = , ReleaseDate = 5/15/1999 12:00:00 AM }</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/xylkW">https://packt.link/xylkW</a>.</p>
<p>If you tried doing the same to a class or a <code>struct</code> object, you would only get a type printed. However, for a record, a default behavior is to print all of its properties and their values.</p>
<p>That is not the only benefit of a record. Again, a record has value-equality semantics. Comparing two movie records will compare them by their property values:</p>
<pre>    Console.WriteLine(movie1.Equals(movie2));
    Console.WriteLine(movie1 == movie2);</pre>
<p>This will print <code>true true</code>.</p>
<p>With the same amount of code, you have managed to get the most functionality by simply changing a data structure to a record. Out of the box, a record provides <code>Equals()</code>, <code>GetHashCode() overrides</code>, <code>== and != overrides</code>, and even a <code>ToString</code> override, which prints the record itself (all the members and their values). The benefits of records do not end there because, using them, you have a way to reduce a lot of boilerplate code. Take full advantage of records and rewrite your movie record:</p>
<pre>public record MovieRecord(string Title, string Director, string Producer, string Description, DateTime ReleaseDate);</pre>
<p>This is a positional record, meaning all that you pass as parameters will end up in the right read-only data members as if it was a dedicated constructor. If you ran the demo again, you would notice that it no longer compiles. The major difference with this declaration is that, now, changing a description is no longer possible. Making a mutable property is not difficult, you just need to be explicit about it:</p>
<pre>public record MovieRecord(string Title, string Director, string Producer, DateTime ReleaseDate)
{
    public string Description { get; set; }
}</pre>
<p>You started this paragraph with a discussion on immutability, but why is the primary focus on records? The benefits of records are actually immutability-focused. Using a <code>with</code> expression, you can create a copy of a record object with zero or more properties modified. So, suppose you add this to your demo:</p>
<pre>var movie3 = movie2 with { Description = "Records can do that?" };
movie2.Description = "Changing original";
Console.WriteLine(movie3);</pre>
<p>The code would result in this:</p>
<pre>MovieRecord { Title = Star Wars: Episode I - The Phantom Menace, Director = George Lucas, Producer
= Rick McCallum, ReleaseDate = 5/15/1999 12:00:00 AM, Description = Records can do that? }</pre>
<p>As you see, this code copies an object with just one property changed. Before records, you would need a lot of code to ensure all the members are copied, and only then would you set a value. Keep in mind that this creates a shallow copy. A shallow copy is an object with all the references copied. A deep copy is an object with all the reference-type objects recreated. Unfortunately, there is no way of overriding such behavior. Records cannot inherit classes, but they can inherit other records. They can also implement interfaces.</p>
<p>Other than being a reference type, records are more like structs in that they have value equality and syntactic sugar around immutability. They should not be used as a replacement for structs because structs are still preferable for small and simple objects, which have simple logic. Use records when you want immutable objects for data, which could hold other complex objects (if nested objects could have a state that changes, shallow copying might cause unexpected behavior).</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>Init-Only Setters</h2>
<p>With the introduction of records, the previous edition, C# 9, also introduced <code>init</code>-only setter properties. Writing <code>init</code> instead of <code>set</code> can enable object initialization for properties:</p>
<pre>public class House
{
    public string Address { get; init; }
    public string Owner { get; init; }
    public DateTime? Built { get; init; }
}</pre>
<p>This enables you to create a house with unknown properties:</p>
<pre>var house2 = new House();</pre>
<p>Or assign them:</p>
<pre>var house1 = new House
{
    Address = "Kings street 4",
    Owner = "King",
    Built = DateTime.Now
};</pre>
<p>Using <code>init</code>-only setters is especially useful when you want read-only data, which can be known or not, but not in a consistent matter.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/89J99">https://packt.link/89J99</a>.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>ValueTuple and Deconstruction</h2>
<p>You already know that a function can only return one thing. In some cases, you can use the <code>out</code> keyword to return a second thing. For example, converting a string to a number is often done like this:</p>
<pre>var text = "123";
var isNumber = int.TryParse(text, out var number);</pre>
<p><code>TryParse</code> returns both the parsed number and whether the text was a number.</p>
<p>However, C# has a better way of returning multiple values. You can achieve this using a data structure called <code>ValueTuple</code>. It is a generic <code>struct</code> that contains from one to six public mutable fields of any (specified) type. It is just a container for holding unrelated values. For example, if you had a <code>dog</code>, a <code>human</code>, and a <code>Bool</code>, you could store all three in a <code>ValueTuple</code> struct:</p>
<pre>var values1 = new ValueTuple&lt;Dog, Human, bool&gt;(dog, human, isDogKnown);</pre>
<p>You can then access each—that is, <code>dog</code> through <code>values1.Item1</code>, <code>human</code> through <code>values1.Item2</code>, and i<code>sDogKnown</code> through <code>values.Item3</code>. Another way of creating a <code>ValueTuple</code> struct is to use brackets. This does exactly the same thing as before, but using the brackets syntax:</p>
<pre>var values2 = (dog, human, isDogKnown);</pre>
<p>The following syntax proves extremely useful because, with it, you can declare a function that virtually returns multiple things:</p>
<pre>public (Dog, Human, bool) GetDogHumanAndBool()
{
    var dog = new Dog("Sparky");
    var human = new Human("Thomas");
    bool isDogKnown = false;
 
    return (dog, human, isDogKnown);
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/OTFpm">https://packt.link/OTFpm</a>.</p>
<p>You can also do the opposite, using another C# feature called deconstruction. It takes object data members and allows you to split them apart, into separate variables. The problem with a tuple type is that it does not have a strong name. As mentioned before, every field will be called <code>ItemX</code>, where <code>X</code> is the order in which the item was returned. Working with all that, <code>GetDogHumanAndBool</code> would require the results to be assigned to three different variables:</p>
<pre>var dogHumanAndBool = GetDogHumanAndBool();
var dog = dogHumanAndBool.Item1;
var human = dogHumanAndBool.Item2;
var boo = dogHumanAndBool.Item3;</pre>
<p>You can simplify this and instead make use of deconstruction—assigning object properties to different variables right away:</p>
<pre>var (dog, human, boo) = GetDogHumanAndBool(); </pre>
<p>Using deconstruction, you are able to make this a lot more readable and concise. Use <code>ValueTuple</code> when you have multiple unrelated variables and you want to return them all from a function. You do not have to always work around using the <code>out</code> keyword, nor do you have to add overhead by creating a new class. You can solve this problem by simply returning and then deconstructing a <code>ValueTuple</code> struct.</p>
<p>You can now have hands-on experience of using SOLID principles for writing codes incrementally through the following exercise.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Exercise 2.04: Creating a Composable Temperature Unit Converter</h2>
<p>Temperature can be measured in different units: Celsius, Kelvin, and Fahrenheit. In the future, more units might be added. However, units do not have to be added dynamically by the user; the application either supports it or not. You need to make an application that converts temperature from any unit to another unit.</p>
<p>It is important to note that converting to and from that unit will be a completely different thing. Therefore, you will need two methods for every converter. As a standard unit, you will use Celsius. Therefore, every converter should have a conversion method from and to Celsius, which makes it the simplest unit of a program. When you need to convert non-Celsius to Celsius, you will need to involve two converters—one to adapt the input to the standard unit (C), and then another one to convert from C to whatever unit you want. The exercise will aid you in developing an application using the SOLID principles and C# features you have learned in this chapter, such as <code>record</code> and <code>enum</code>.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Create a <code>TemperatureUnit</code> that uses an <code>enum</code> type to define constants—that is, a set of known values. You do not need to add it dynamically:<pre>public enum TemperatureUnit
{
    C,
    F,
    K
}</pre></li>
</ol>
<p>In this example, you will use three temperature units that are <code>C</code>, <code>K</code>, and <code>F</code>.</p>
<ol>
<li value="2">Temperature should be thought of as a simple object made of two properties: <code>Unit</code> and <code>Degrees</code>. You could either use a <code>record</code> or a <code>struct</code> because it is a very simple object with data. The best choice would be picking a <code>struct</code> here (due to the size of the object), but for the sake of practicing, you will use a <code>record</code>:<pre>public record Temperature(double Degrees, TemperatureUnit Unit);</pre></li>
<li>Next, add a contract defining what you want from an individual specific temperature converter:<pre>public interface ITemperatureConverter
{
    public TemperatureUnit Unit { get; }
    public Temperature ToC(Temperature temperature);
    public Temperature FromC(Temperature temperature);
}</pre></li>
</ol>
<p>You defined an interface with three methods—the <code>Unit</code> property to identify which temperature the converter is for, and <code>ToC</code> and <code>FromC</code> to convert from and to standard units.</p>
<ol>
<li value="4">Now that you have a converter, add the composable converter, which has an array of converters:<pre>public class ComposableTemperatureConverter
{
    private readonly ITemperatureConverter[] _converters;</pre></li>
<li>It makes no sense to have duplicate temperature unit converters. So, add an error that will be thrown when a duplicate converter is detected. Also, not having any converters makes no sense. Therefore, there should be some code for validating against <code>null</code> or empty converters:<pre>public class InvalidTemperatureConverterException : Exception
{
    public InvalidTemperatureConverterException(TemperatureUnit unit) : base($"Duplicate converter for {unit}.")
    {
    }
 
    public InvalidTemperatureConverterException(string message) : base(message)
    {
    }
}</pre></li>
</ol>
<p>When creating custom exceptions, you should provide as much information as possible about the context of an error. In this case, pass the <code>unit</code> for which the converter was not found.</p>
<ol>
<li value="6">Add a method that requires non-empty converters:<pre>private static void RequireNotEmpty(ITemperatureConverter[] converters)
{
    if (converters?.Length &gt; 0 == false)
    {
        throw new InvalidTemperatureConverterException("At least one temperature conversion must be supported");
    }
}</pre></li>
</ol>
<p>Passing an array of empty converters throws an <code>InvalidTemperatureConverterException</code> exception.</p>
<ol>
<li value="7">Add a method that requires non-duplicate converters:<pre>private static void RequireNoDuplicate(ITemperatureConverter[] converters)
{
    for (var index1 = 0; index1 &lt; converters.Length - 1; index1++)
    {
        var first = converters[index1];
        for (int index2 = index1 + 1; index2 &lt; converters.Length; index2++)
        {
            var second = converters[index2];
            if (first.Unit == second.Unit)
            {
                throw new InvalidTemperatureConverterException(first.Unit);
            }
        }
    }
}</pre></li>
</ol>
<p>This method goes through every converter and checks that, at other indexes, the same converter is not repeated (by duplicating <code>TemperatureUnit</code>). If it finds a duplicate unit, it will throw an exception. If it does not, it will just terminate successfully.</p>
<ol>
<li value="8">Now combine it all in a constructor:<pre>public ComposableTemperatureConverter(ITemperatureConverter[] converters)
{
    RequireNotEmpty(converters);
    RequireNoDuplicate(converters);
    _converters = converters;
}</pre></li>
</ol>
<p>When creating the converter, validate against converters that are not empty and not duplicates and only then set them.</p>
<ol>
<li value="9">Next, create a <code>private</code> helper method to help you find the requisite converter, <code>FindConverter</code>, inside the composable converter:<pre>private ITemperatureConverter FindConverter(TemperatureUnit unit)
{
    foreach (var converter in _converters)
    {
        if (converter.Unit == unit)
        {
            return converter;
        }
    }
 
    throw new InvalidTemperatureConversionException(unit);
}</pre></li>
</ol>
<p>This method returns the converter of the requisite unit and, if no converter is found, throws an exception.</p>
<ol>
<li value="10">To simplify how you search and convert from any unit to Celsius, add a <code>ToCelsius</code> method for that:<pre>private Temperature ToCelsius(Temperature temperatureFrom)
{
    var converterFrom = FindConverter(temperatureFrom.Unit);
    return converterFrom.ToC(temperatureFrom);
}</pre></li>
</ol>
<p>Here, you find the requisite converter and convert the <code>Temperature</code> to Celsius.</p>
<ol>
<li value="11">Do the same for converting from Celsius to any other unit:<pre>private Temperature CelsiusToOther(Temperature celsius, TemperatureUnit unitTo)
{
    var converterTo = FindConverter(unitTo);
    return converterTo.FromC(celsius);
}</pre></li>
<li>Wrap it all up by implementing this algorithm, standardize the temperature (convert to Celsius), and then convert to any other temperature:<pre>public Temperature Convert(Temperature temperatureFrom, TemperatureUnit unitTo)
{
    var celsius = ToCelsius(temperatureFrom);
    return CelsiusToOther(celsius, unitTo);
}</pre></li>
<li>Add a few converters. Start with the Kelvin converter, <code>KelvinConverter</code>:<pre>public class KelvinConverter : ITemperatureConverter
{
    public const double AbsoluteZero = -273.15;
 
    public TemperatureUnit Unit =&gt; TemperatureUnit.K;
 
    public Temperature ToC(Temperature temperature)
    {
        return new(temperature.Degrees + AbsoluteZero, TemperatureUnit.C);
    }
 
    public Temperature FromC(Temperature temperature)
    {
        return new(temperature.Degrees - AbsoluteZero, Unit);
    }
}</pre></li>
</ol>
<p>The implementation of this and all the other converters is straightforward. All you had to do was implement the formula to convert to the correct unit from or to Celsius. Kelvin has a useful constant, absolute zero, so instead of having a magic number, <code>–273.15</code>, you used a named constant. Also, it is worth remembering that a temperature is not a primitive. It is both a degree value and a unit. So, when converting, you need to pass both. <code>ToC</code> will always take <code>TemperatureUnit.C</code> as a unit and <code>FromC</code> will take whatever unit the converter is identified as, in this case, <code>TemperatureUnit.K</code>.</p>
<ol>
<li value="14">Now add a Fahrenheit converter, <code>FahrenheitConverter</code>:<pre>public class FahrenheitConverter : ITemperatureConverter
{
    public TemperatureUnit Unit =&gt; TemperatureUnit.F;
 
    public Temperature ToC(Temperature temperature)
    {
        return new(5.0/9 * (temperature.Degrees - 32), TemperatureUnit.C);
    }
 
    public Temperature FromC(Temperature temperature)
    {
        return new(9.0 / 5 * temperature.Degrees + 32, Unit);
    }
}</pre></li>
</ol>
<p>Fahrenheit is identical structure-wise; the only differences are the formulas and unit value.</p>
<ol>
<li value="15">Add a <code>CelsiusConverter</code>, which will accept a value for the temperature and return the same value, as follows:<pre>    public class CelsiusConverter : ITemperatureConverter
    {
        public TemperatureUnit Unit =&gt; TemperatureUnit.C;
 
        public Temperature ToC(Temperature temperature)
        {
            return temperature;
        }
 
        public Temperature FromC(Temperature temperature)
        {
            return temperature;
        }
    }</pre></li>
</ol>
<p><code>CelsiusConverter</code> is the simplest one. It does not do anything; it just returns the same temperature. The converters convert to standard temperature—Celsius to Celsius is always Celsius. Why do you need such a class at all? Without it, you would need to change the flow a bit, adding <code>if</code> statements to ignore the temperature if it was in Celsius. But with this implementation, you can incorporate it in the same flow and use it in the same way with the help of the same abstraction, <code>ITemperatureConverter</code>.</p>
<ol>
<li value="16">Finally, create a demo:<pre>Solution.cs
public static class Solution
{
    public static void Main()
    {
        ITemperatureConverter[] converters = {new FahrenheitConverter(), new KelvinConverter(), new CelsiusConverter()};
        var composableConverter = new ComposableTemperatureConverter(converters);
 
        var celsius = new Temperature(20.00001, TemperatureUnit.C);
 
        var celsius1 = composableConverter.Convert(celsius, TemperatureUnit.C);
        var fahrenheit = composableConverter.Convert(celsius1, TemperatureUnit.F);
        var kelvin = composableConverter.Convert(fahrenheit, TemperatureUnit.K);
        var celsiusBack = composableConverter.Convert(kelvin, TemperatureUnit.C);
        Console.WriteLine($"{celsius} = {fahrenheit}");</pre></li>
</ol>
<pre>You can find the complete code here: <a href="https://packt.link/ruBph">https://packt.link/ruBph</a>.</pre>
<p>In this example, you have created all the converters and passed them to the converters container called <code>composableConverter</code>. Then you have created a temperature in Celsius and used it to perform conversions from and to all the other temperatures.</p>
<ol>
<li value="17">Run the code and you will get the following results:<pre>Temperature { Degrees = 20.00001, Unit = C } = Temperature { Degrees = 68.000018, Unit = F }
Temperature { Degrees = 68.000018, Unit = F } = Temperature { Degrees = -253.14998999999997, Unit = K }
Temperature { Degrees = -253.14998999999997, Unit = K } = Temperature { Degrees = 20.000010000000003, Unit = C }</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/dDRU6">https://packt.link/dDRU6</a>.</p></li>
</ol>
<p>A software developer, ideally, should design code in such a way that making a change now or in the future will take the same amount of time. Using SOLID principles, you can write code incrementally and minimize the risk of breaking changes, because you never change existing code; you just add new code. As systems grow, complexity increases, and it might be difficult to learn how things work. Through well-defined contracts, SOLID enables you to have easy-to-read, and maintainable code because each piece is straightforward by itself, and they are isolated from one another.</p>
<p>You will now test your knowledge of creating classes and overriding operators through an activity.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Activity 2.01: Merging Two Circles</h2>
<p>In this activity, you will create classes and override operators to solve the following mathematics problem: A portion of pizza dough can be used to create two circular pizza bites each with a radius of three centimeters. What would be the radius of a single pizza bite made from the same amount of dough? You can assume that all the pizza bites are the same thickness. The following steps will help you complete this activity:</p>
<ol>
<li value="1">Create a <code>Circle</code> struct with a radius. It should be a <code>struct</code> because it is a simple data object, which has a tiny bit of logic, calculating area.</li>
<li>Add a property to get the area of a circle (try to use an expression-bodied member). Remember, the formula of a circle's area is <code>pi*r*r</code>. To use the <code>PI</code> constant, you will need to import the <code>Math</code> package.</li>
<li>Add two circles' areas together. The most natural way would be to use an overload for a plus (<code>+</code>) operator. Implement a <code>+</code> operator overload that takes two circles and returns a new one. The area of the new circle is the sum of the areas of the two old circles. However, do not create a new circle by passing the area. You need a Radius. You can calculate this by dividing the new area by <code>PI</code> and then taking the square root of the result.</li>
<li>Now create a <code>Solution</code> class that takes two circles and returns a result—the radius of the new circle.</li>
<li>Within the <code>main</code> method, create two circles with a radius of <code>3</code> cm and define a new circle, which is equal to the areas of the two other circles added together. Print the results.</li>
<li>Run the <code>main</code> method and the result should be as follows:<pre>Adding circles of radius of 3 and 3 results in a new circle with a radius 4.242640687119285</pre></li>
</ol>
<p>As you can see from this final output, the new circle will have a radius of <code>4.24</code> (rounded to the second decimal place).</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>This activity was designed to test your knowledge of creating classes and overriding operators. Operators are not normally employed to solve this sort of problem, but in this case, it worked well.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor128"/>Summary</h1>
<p>In this chapter, you learned about OOP and how it helps take complex problems and abstract them into simple concepts. C# has several useful features and, roughly every one or two years, a new language version is released. The features mentioned in this chapter are just some of the ways in which C# aids in productivity. You have seen how, by design, it allows for better, clearer code, less prone to error. C# is one of the best languages when it comes to productivity. With C#, you can make effective code, and quickly, because a lot of the boilerplate code is done for you.</p>
<p>Finally, you learned the SOLID principles and used them in an application. SOLID is not something you can just read and learn immediately; it takes practice, discussions with your peers, and a lot of trial and error before you get it right and start applying it consistently. However, the benefits are worth it. In modern software development, producing fast, optimal code is no longer a number one priority. Nowadays, the focus is a balance of productivity (how fast you develop) and performance (how fast your program is). C# is one of the most efficient languages out there, both in terms of performance and productivity.</p>
<p>In the next chapter, you will learn what functional programming is and how to work with lambdas and functional constructs such as delegates.</p>
</div>
<div><div></div>
</div>
</div>
</body></html>