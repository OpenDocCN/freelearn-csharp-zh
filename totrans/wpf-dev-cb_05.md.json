["```cs\n<Style TargetType=\"{x:Type local:SearchControl}\"> \n    <Setter Property=\"Template\"> \n        <Setter.Value> \n            <ControlTemplate TargetType=\"{x:Type local:  \n                              SearchControl}\"> \n                <Border Background=\"{TemplateBinding  \n                              Background}\" \n                        BorderBrush=\"{TemplateBinding  \n                              BorderBrush}\" \n                        BorderThickness=\"{TemplateBinding  \n                              BorderThickness}\">                         \n                </Border> \n            </ControlTemplate> \n        </Setter.Value> \n    </Setter> \n</Style> \n```", "```cs\n<Style TargetType=\"{x:Type local:SearchControl}\"> \n    <Setter Property=\"Height\" Value=\"26\"/> \n    <Setter Property=\"Width\" Value=\"150\"/> \n    <Setter Property=\"Template\"> \n        <Setter.Value> \n            <ControlTemplate TargetType=\"{x:Type \n             local:SearchControl}\"> \n                <Grid> \n                    <Grid.ColumnDefinitions> \n                        <ColumnDefinition Width=\"*\"/> \n                        <ColumnDefinition Width=\"Auto\"/> \n                    </Grid.ColumnDefinitions> \n                    <TextBox x:Name=\"PART_TextBox\" \n                            Grid.Column=\"0\" \n                            Margin=\"2\" \n                            HorizontalAlignment=\"Stretch\" \n                            VerticalAlignment=\"Stretch\"/> \n                    <Button x:Name=\"PART_Button\" \n                            Content=\"Search\" \n                            Grid.Column=\"1\" \n                            Margin=\"2\" Padding=\"8 2\" \n                            HorizontalAlignment=\"Stretch\" \n                            VerticalAlignment=\"Stretch\"/> \n                </Grid> \n            </ControlTemplate> \n        </Setter.Value> \n    </Setter> \n</Style> \n```", "```cs\n\n7.  Now, inside the default `Grid` panel, add the custom control that we just created, and optionally set its `Height` and `Width` properties:\n\n```", "```cs\n\n8.  That's all! Our first custom control has been created and added to the `MainWindow` of the application. Let's build and run the application. You will see the following UI on the screen:\n\n![](img/5e1e0f8c-438e-4501-b59b-e9aad4f1186d.png)\nWe have just added the UI of our custom control here and hence no functionality related to search will work. We will enhance the functionalities in the next recipes.\nHow it works...\nWhen you first create a custom control in a project, Visual Studio creates a folder named `Themes`, and places a file named `Generic.xaml`. This file contains all the styles and templates of the custom controls, by default. When you add more custom controls inside the same project, the `Generic.xaml` file gets updated with the styles of the new controls.\nThe property called `TargetType` defines the type of the control for which we are going to create the style. In the preceding example, `<Style TargetType=\"{x:Type local:SearchControl}\">` defines the style of the custom control called `SearchControl`. To change the UI of the control, we need to update the same style.\nThe `<ControlTemplate TargetType=\"{x:Type local:SearchControl}\">` defines the template of the control, which generally resides inside the `Style`.\nThe `Setter` properties inside the `Style` define the default value of various properties of the said control. In the preceding example, we have defined the default value of the `Height` and `Width` properties. You can add additional property values.\nThere's more...\nBefore going further with the custom controls, you need to learn and understand some other points related to them. Let's discuss them in the following sections.\nXMLNS attribute declaration\nWhen the custom control is present within the same project where you are going to use it, you need to add the XMLNS attribute in the following way:\n\nThis is the same way we added it in the preceding example. The `clr-namespace` defines the namespace where the controls are available. A single namespace can have one or more controls.\nWhen the custom control is present in a different project to the one where you are going to add it, you need to add the XMLNS attribute in the following way:\n\nHere, the `clr-namespace` defines the namespace of the controls, whereas the `assembly` defines the fully qualified name of the assembly where the control is present.\nDefault styling\nWhen you create a custom control, all the default properties of its base class, `Control`, gets assigned to it. You can use `TemplateBinding` to bind the data to a specific control. For example, to change the background color of the input box based on the `Background` property set on the control level, you need to create the template binding in the following way:\n\n```", "```cs\n\nNow, when you change the color of the control, it will change the color of the said input box. Set a color to the `Background` property of our search control inside the `MainWindow.xaml` and observe the change.\nToolbox integration\nWhen you create a custom control within the same project and/or reference a `dll` containing any custom control, you will be able to utilize the Visual Studio Toolbox to drag and drop the control directly to the XAML/designer view.\nAfter creating the control or adding the control library in a project, you need to build it first. Now, open any XAML page and navigate to the Visual Studio Toolbox. You will be able to find the control, as demonstrated here:\n![](img/378e0067-6e71-44b8-af54-8fc726ed60fd.png)\nNow you can drag it to the place where you want to add the said control.\nCustomizing the template of a custom control\nThe development of a custom control always requires its default template to be changed to give it a proper look and make it ready for theming support. That starts with the customization of the template and its default values.\nIn this recipe, we will learn how to change the template and use `TemplateBinding` to create a relation with its property values.\nGetting ready\nTo get started, launch Visual Studio, create a project, and add a new custom control in it. For this demonstration, we will be using the existing project, `CH05.SearchControlDemo`, that we created in the previous recipe. So, let's open the project.\nHow to do it...\nAs we want to customize the template of the custom control to have a proper template binding, perform the following steps:\n\n1.  Open the `Generic.xaml` file, which is present under the `Themes` folder of the project.\n2.  Now, scroll down to the definition of the `ControlTemplate` as we need to customize the look and feel of it.\n3.  Search for the `TextBox` control named `PART_TextBox`, and set its `Background`, `BorderBrush`, `BorderThickness`, and `Foreground` properties to have a binding with the control's default properties.\n4.  Similarly, set the `Background` and `Foreground` property of the button (`PART_Button`) to the same properties of the control, by using template binding. Here's the complete code of the modified control template:\n\n```", "```cs\n\n5.  You can also assign default values to your control templates, by using the `<Setter/>` tag. You will need to add it inside the `<Style/>` definition. To add default values to the `Height`, `Width`, `Background`, `BorderBrush`, `BorderThickness`, and `Foreground` properties, add the following code block inside the `Style` tag:\n\n```", "```cs\n\n6.  Once done, compile your project and run it. You will see the following screen, where the background of the `TextBox` and `Button` controls are painted with `AliceBlue` color. Similarly, the other styles are applied as per the default values specified:\n    ![](img/d9ae63a7-33a9-44a0-9fca-7f8c0e8d4c99.png)\n\n7.  You can override the default style values in your application, where you are using the control. To do this, open the `MainWindow.xaml` file and add a custom `Background` color, `BorderBrush`, `Foreground`, and `BorderThickness` to the control as follows:\n\n```", "```cs\n\n8.  Now, if you build and run the application, you will notice the UI changed as per the custom value that you specified directly to the control:\n    ![](img/bcd1a13a-70bc-4936-89cb-49b22c9d57e1.png)\n\nHow it works...\n`TemplateBinding` is a type of binding used mainly while working with templates. This allows you to replace the visual tree of controls for a completely fresh look and feel, based on the theme or style that you want to use. It also helps you to reference the parent control, read its properties, and apply its values.\nWhen you apply a template binding to a control, present in the `ControlTemplate` of the parent control, it first checks whether the property is present to the parent control. If it is not present, it throws an XAML syntax error.\nIf it finds the property, it checks whether the value is supplied from the place where the custom control has been used. If it finds no reference, it applies the default value to the property.\nExposing properties from the custom control\nMost of the time, while using custom controls, we need to expose additional properties based on the requirement. In this recipe, we will demonstrate exposing dependency properties from the custom control and binding the record to the UI.\nGetting ready\nLet's extend our previous project to perform these steps. To get started, launch Visual Studio and open the project `CH05.SearchControlDemo`.\nHow to do it...\nOnce the project has been opened, perform the following steps to create a dependency property named `SearchTerm` and bind it with the control UI:\n\n1.  Let's open the `SearchControl.cs` to create a dependency property. Inside the class definition, type `propdp` and press the *TAB* key twice to create the property structure. By default, it generates `MyProperty` of type `int`.\n2.  Change the property type from `int` to `string` and press *TAB*.\n3.  Rename `MyProperty` to `SearchTerm` and press *TAB* again.\n4.  Now change `ownerclass` to `SearchControl` and press *TAB*.\n5.  Pass `string.Empty` as the default value to the `PropertyMetaData`.\n6.  Once these preceding steps are done, your property is ready to use. Now open the `Generic.xaml` page to create the binding to the UI control.\n7.  Inside the template of the control, find the `TextBox` named `PART_TextBox`.\n\n8.  Now, add the `Text` property to it, by using `TemplateBinding`. You will see the dependency property (`SearchTerm`) listed in the XAML IntelliSense, as shown here:\n\n![](img/7d448ece-82e5-4e3e-b1d2-ccddce97e64e.png)\n\n9.  Let's complete the template binding as follows:\n\n```", "```cs\n\n10.  Now navigate to the `MainWindow.xaml` page and add the `SearchTerm` property to the control that we have already added:\n    ![](img/e0e6e883-edb0-486e-ac0d-82fb623d56fa.png)\n\n11.  Set some sample strings to it:\n\n```", "```cs\n\n12.  Build the project and run it. You will see that the string that you assigned to the `SearchTerm` property of the control, actually assigned the value to the search `TextBox`:\n    ![](img/289ea954-9831-4d3d-8140-df97707ad334.png)\n\nHow it works...\nTemplate binding works only with the dependency properties. When you assign a value to the dependency property, it automatically updates the child control where you have created the binding. In our example, when you assign a value to the `SearchTerm` property, it sets the value to the textbox (`PART_TextBox`) control's `Text` property and thus you can see the value provided to it.\nExposing events from a custom control\nWhen you build any custom control, you need to expose additional events, based on the child controls and functionality that you want to expose to the user. In this recipe, we will learn how to expose a custom event from a custom control and perform a specific operation using it.\nGetting ready\nLet's start with the existing project that we have already used in the previous recipes. Launch the IDE and open the `CH05.SearchControlDemo` project inside Visual Studio.\nHow to do it...\nIn this recipe, we will create a public event from the `SearchControl`, so that we can subscribe to the `PART_Button` button event and fetch the user-entered text. To do so, follow perform the following steps:\n\n1.  From Solution Explorer, create a new class named `SearchEventArgs`, inside the project.\n2.  Extend the `SearchEventArgs` class from the `EventArgs` and expose a public property (`SearchTerm`) of type `string`. Here's the class implementation:\n\n```", "```cs\n\n3.  Now open the `SearchControl.cs` file. We need to create a delegate and event inside it. Let's add the following inside the class implementation:\n\n```", "```cs\n\n4.  The next task is to associate the button click event with the custom event that we have just created. Pass the `SearchTerm` to the custom event as an argument. To do this, copy the following code inside the `SearchControl` class:\n\n```", "```cs\n\n5.  Open the `Generic.xaml` page and perform a slight change to the `Text` property binding of the search `TextBox`. Instead of template binding, let's perform a normal data binding, passing a relative source to it. As we need to take input from the user, we will set the binding mode to `TwoWay`. Here's the XAML code:\n\n```", "```cs\n\n6.  Once this is done, open the `MainWindow.xaml` and register the `SearchButtonClick` event of the `SearchControl`:\n\n```", "```cs\n\n7.  Open the code behind `MainWindow.xaml.cs` and modify the event implementation to show a message box to the user, with the text that we passed as a search term. You can find it as `e.SearchTerm`, as passed to the event argument. Here's the code for your reference:\n\n```", "```cs\n\n8.  That's all! Let's build the application and run it. As we already have a default value set to the control, click on the Search button. You will see a message box with the default search term. Now, change the value to have a different search term. To do so, click on the `TextBox` control and replace the string. Now, click on the Search button once again, which will show the new search term inside the message box. Here's a screenshot of the same operation:\n\n![](img/1a25bcdf-d48c-48d9-97a1-ee7c2c51c27f.png)\nHow it works...\nWhen the application loads with the control on the UI, the first thing that it does is to load its defined template and call the `OnApplyTemplate()` method. `OnApplyTemplate()` is a virtual method present inside the `System.Windows.FrameworkElement` class, which gets invoked when application code or internal processes call the `System.Windows.FrameworkElement.ApplyTemplate()`.\nAs you can see in the `OnApplyTemplate()` method implementation, it finds out the template child named `PART_Button` using the `GetTemplateChild` method call, and registers its associated `Click` event:\n\n```", "```cs\n\nThe `Click` event then invokes the custom event (`SearchButtonClick`), passing the `SearchTerm` as `SearchEventArgs`. Now, when you click on the button in the application UI, it fires the `OnSearchButtonClicked_Internal` event and bubbles up to the application UI. The `OnSearchButtonClicked` event handler then triggers due to its subscription to the custom event and performs the operation. In our case, it shows a message to the user with the search term passed to the search box.\nExtending the functionality of a control using behavior\n**Behavior** is a concept to extend the functionality of a control using a reusable component. These components can be attached to any control or a specific type of control to provide designers with the flexibility to design complex user interactions without writing any additional code.\nIn this recipe, we will learn how to create a behavior and the way to apply it to a control without writing extra code in the code-behind file.\nGetting ready\nTo get started, we need to open the Visual Studio IDE. Create a new project called `CH05.ControlBehaviorDemo`, based on the WPF application template.\nHow to do it...\nLet's start by creating a component which will add a Size Grow effect to a `TextBlock` control when hovering over with the mouse cursor. To do this, perform the following steps:\n\n1.  To create and/or use behaviors in an application, you will need to set up the project to have a reference to the `System.Windows.Interactivity.dll` assembly file. To do this, right-click on the project and click Add | Reference... from the context menu.\n2.  From the Reference Manager dialog, search for `interactivity` to find the System.Windows.Interactivity assembly in the list of assemblies. Select the latest version, as shown in the following screenshot, and click OK. Make sure you verify the added reference in the project:\n\n![](img/574ed872-afeb-4caf-b34d-075acacafd4a.png)\n\n3.  Now open the `MainWindow.xaml` page and add a `TextBlock` control inside the default `Grid`. Assign a string to its `Text` property:\n\n```", "```cs\n\n4.  If you run the application now, it will have a text in the window. Hovering your mouse on top of that will not have any effect. For that, we need to create the behavior and register it with the `TextBlock` control.\n5.  Let's create a new class, called `GrowTextBehavior`, inside the project.\n6.  Mark the class as `public` and extend it from the `Behavior` class. As we are going to create this component for `TextBlock` control, we will extend the class from `Behavior<TextBlock>`, as shown here:\n\n```", "```cs\n\n7.  You will need to add the `System.Windows.Interactivity` namespace as a `using` statement to resolve the class declaration. Alternatively, you can resolve the namespace by clicking the light bulb and selecting using System.Windows.Interactivity;, as shown in the following screenshot:\n\n![](img/211aab62-d442-40a2-92e0-0073c15351a2.png)\n\n8.  Add a `public` property inside the class to take dynamic input of the size to grow by. Give it a name:\n\n```", "```cs\n\n9.  Now, inside the class, type `override` and enter a space. From the list of overridable methods, select `OnAttached` and hit the *Enter* key. This will override the `OnAttached()` method inside the class.\n\n10.  Similarly, override the method `OnDetaching()` inside the class.\n11.  Inside `OnAttached()`, register the `MouseEnter` and `MouseLeave` events for the associated object, which is a `TextBlock` in our case. Similarly, inside the `OnDetaching()`, unregister the preceding two events. Here's the code that you may like to take as reference:\n\n```", "```cs\n\n12.  Now it's time to write our logic to grow and shrink the size of the associated `TextBlock` control on mouse over and mouse leave events, respectively. To do so, add the following code block inside the class:\n\n```", "```cs\n\n13.  That ends the implementation of the behavior component for our `TextBlock` control. Now it's time to register it with the control in the UI. To do so, open the `MainWindow.xaml` again and add the following XMLNS namespace declaration:\n\n14.  Now modify the `TextBlock` control to register the association with the behavior component that we created. Replace the existing markup with the following:\n\n```", "```cs\n\n15.  Let's build the application and run it. You will see a text message in the application window. Hover over it to see the growing effect on its size:\n\n![](img/66f3007f-9f4b-485c-bd88-12ff030353eb.png)\n\n16.  Take your mouse away from the text to see how it moves back to the original state.\n\nHow it works...\nThe property, `AssociatedObject`, returns the object to which the `System.Windows.Interactivity.Behavior` is attached. In our case, it's the `TextBlock` control passed as `Behavior` of type `T` (`Behavior<TextBlock>`), which is associated in the XAML code block, as mentioned here:\n\n```", "```cs\n\nWhen the association happens between the control and the component, it registers the two events (`MouseEnter` and `MouseLeave`) in our example. Now, when you hover over the mouse on top of the `TextBlock`, it gets the dynamic association of the events and triggers them. This way, it gets notification of the event and performs based on the logic specified.\nYou can now associate this behavior to any number of controls of type `TextBlock`, without writing additional code behind. The XAML designers can easily pick and associate it with the controls that they want to provide a grow effect on mouse hover.\nIf you want to associate the behavior to any control, you need to extend it from `Behavior`, instead of `Behavior<TextBlock>`. Similarly, to change the type to any other specific control (let's say, `Label`), change the `T` to `Label` as shown here—`Behavior<Label>`.\nCreating a User Control interface\nTypically, a User Control is a group of elements and controls joined together to create a reusable component. This is often used to show the same UI in multiple places, either on the same window or in a different window.\nIn this recipe, we will learn how to create a User Control interface with all its typical features.\nGetting ready\nGet started by creating a new project. Open the Visual Studio IDE and create a new project based on the WPF application template. Name it `CH05.UserControlDemo`.\nHow to do it...\nTo demonstrate the complete use of User Control, we will be creating a color mixer control, exposing some properties from it and binding data using converters. Perform the following simple steps:\n\n1.  Once the project has been created, add a new User Control element inside the project. To do this, right-click on the project and select Add | User Control... from the context menu entry.\n2.  From the Add New Item dialog, select User Control (WPF) as the template to create a blank User Control. Name the control `ColorMixer`. Click on the Add button to create a User Control file called `ColorMixer.xaml`:\n\n![](img/2f3450ec-69e5-4d1e-874b-eb23d9ffed82.png)\n\n3.  Once the User Control has been created, open the code-behind file (`ColorMixer.xaml.cs`) and add a property `SelectedColor` of type `Color` inside it. Give it a default color (let's say, `Colors.OrangeRed`):\n\n```", "```cs\n\n4.  Let's open the `ColorMixer.xaml` file to provide a UI to the control. We will be adding four `TextBox` controls to assign the color in RGB mode (Red, Green, Blue, and Alpha) and a `Border` to show the output from the RGB mixer.\n5.  First, give the User Control a name, so that we can easily set its `DataContext` to access its code-behind properties. To do this, add the attribute `x:Name=\"userControl\"` to the `UserControl` tag.\n6.  Set the `DataContext` of the `Grid` to have an element binding. Add the following attribute inside the `Grid` tag:\n\n```", "```cs\n\n7.  Now let's divide the default `Grid` panel into a few rows and columns. Copy the following row and column definitions inside the `Grid` tag to create the structure:\n\n```", "```cs\n\n8.  Now it's time to add the controls inside the `Grid` to create the UI layout of our User Control. Add a `Border` at the first cell of the `Grid` and bind its `Background` property with the `SelectedColor` property of the User Control that we have created:\n\n```", "```cs\n\n9.  Now add a `StackPanel` inside the second cell of the `Grid`, which is `Row=0`, `Column=1`. Add four `TextBox` controls and their associated labels inside the panel. Here's the XAML block, which you can copy and place just after the `Border` control:\n\n```", "```cs\n\n10.  As the basic UI design is ready, let's place the User Control inside the application window. Open `MainWindow.xaml` and add the following XMLNS attribute to the `Window` tag:\n\n11.  Now replace the default `Grid` panel with a `StackPanel`, so that we can place multiple controls in a stack.\n\n12.  Place `<local:ColorMixer />` inside the `StackPanel` and run the application. You will see the following UI on the screen:\n\n![](img/41af04f9-673f-4e92-9180-8acf3c9e0061.png)\n\n13.  The main advantage of a User Control is its ease of use. Creating many instances of it is easy, and there is full design-time support in Visual Studio. Similar to the preceding point, if you place multiple controls of the `ColorMixer` instance inside the `StackPanel`, you will see multiple copies in the UI. Let's not do it, but if you want to try, replace the entire `StackPanel` with the following code block and check out how it places the controls:\n\n```", "```cs\n\n14.  Now let's add the bindings to the `TextBox` controls with the `SelectedColor` property. As the type of the property is `Color`, we will need to create a value converter. So, right-click on the project and add a class by following the context menu path Add | Class...,   name it `ColorToByteConverter`, and hit OK.\n15.  As we need to access the class from the XAML, we will need to mark it as `public`.\n\n16.  Now inherit the class from `IValueConverter`, to make it a value converter. Click on the lightbulb icon, as shown in the following screenshot, and resolve the namespace. Alternatively, you can add the `using` statement to resolve the `System.Windows.Data` namespace:\n\n![](img/17e5bdf8-e0eb-4d92-9db4-24814efc9dd4.png)\n\n17.  Now click on the light bulb again and implement the interface. It will add two methods, called `Convert` and `ConvertBack`, inside the class, as shown in the following screenshot:\n\n![](img/308c1add-f04a-4fec-9f02-70e575bed35a.png)\n\n18.  Replace the `Convert` method with the following code block, which will break the specified color into an RGBA byte value:\n\n```", "```cs\n\n19.  Similarly, replace the `ConvertBack` method to construct the `Color` object from the RGBA values, which you can enter by the `TextBox.Text` property:\n\n```", "```cs\n\n20.  Once this is done, open the `ColorMixer.xaml` file and add the following XMLNS attribute under the `UserControl` tag:\n\n21.  Now create a `<UserControl.Resources>` tag inside the `UserControl` element and register the value converter as a resource. Here's the code that you can copy inside the `UserControl` tag:\n\n```", "```cs\n\n22.  Let's modify the `Text` property of all the four `TextBox` controls to have a `TwoWay` data binding with the `SelectedColor` property, and associate them with the converter that we have added. Pass the proper parameter to the converter, as `ConverterParameter`, as mentioned in the following code. You can copy the following code and replace the existing `StackPanel`:\n\n```", "```cs\n\n23.  At the end, build the project and run the application. You will see the following UI on the screen, where the rectangular `Border` control has an `OrangeRed` background and the associated `TextBox` control has the RGBA byte value of the color:\n    ![](img/89588051-ed78-4bbe-8bc9-199527a6bdd8.png)\n\n24.  Now modify the values of the `TextBox` controls to have a range (`0`–`255`) between `0` to `255` and press *TAB* to reflect the change in the UI. Let's replace the values, Red by `120`, Green by `75`, Blue by `200`, and Alpha by `77`, as shown in the following screenshot, which will result in a light violet background color for the `Border` control:\n    ![](img/043161f3-c872-45c4-97a8-b13f24ee0b50.png)\n\nHow it works...\nA User Control wraps the UI with appropriate properties and events to make it a reusable component. In this User Control, named `ColorMixer`, we created a dependency property called `SelectedColor` of type `Color`.  The user (the developer or the designer) can also set a default value to it, by accessing the property, while adding it to the application UI.\nThe `Text` property of the `TextBox` controls, inside the `ColorMixer.xaml`, is bound with the `SelectedColor` property. As the types of `Text` and `SelectedColor` properties are different, we required the value converter here.\n`ConverterParameter` is used to define whether we need to break the R, G, B, or A value of the color composition. The `Convert` method of the converter class breaks the color according to the parameter and returns, which gets displayed in the appropriate `TextBox` control:\n\n```", "```cs\n\nSimilarly, when you modify the value in the `TextBox`, due to its `TwoWay` binding mode, the `ConvertBack` method of the converter triggers. This constructs the color object based on the values available in all the `TextBox` controls and returns, which gets filled in the `SelectedColor` property and reflects in the `Background` property of the `Border` control.\nExposing events from a User Control\nIn the previous recipe, we learned about User Control, how to create it, and how to expose a dependency property and utilize it. In this recipe, we will learn how to expose events from a User Control, as you will need it in most cases.\nGetting ready\nLet's open the same project, `CH05.UserControlDemo`, inside the Visual Studio to proceed with this recipe.\nHow to do it...\nTo demonstrate the usage of the event, we will add two buttons inside our `ColorMixer` User Control and expose the `OK` and `Cancel` button events from it. To implement the same, perform the following steps:\n\n1.  Open the `ColorMixer.xaml` file and add the following `StackPanel` inside the `Grid`, which will place it at row index `1` and column index `0`. The panel consists of two buttons with labels `OK` and `Cancel:`\n\n```", "```cs\n\n2.  Open the `ColorMixer.xaml.cs` file and register the button click events (`OnOkClicked` and `OnCancelClicked`) inside it.\n3.  Inside the `ColorMixer` class, register the following two delegates and events to handle the OK and Cancel button events from outside the control:\n\n```", "```cs\n\n4.  Now update the `OK` button and the `Cancel` button event handlers to route the event to the place where the control has been used. Here's the code to replace the button click event implementations:\n\n```", "```cs\n\n5.  To register the associated events, in the application window, open the `MainWindow.xaml` file and register the `OkButtonClick` and `CancelButtonClick` events as follows:\n\n```", "```cs\n\n6.  Navigate to the `MainWindow.xaml.cs` file to implement the associated event handlers. As shared in the following code, show a message box to the UI from the event implementation:\n\n```", "```cs\n\n7.  Let's compile the project and run the application. You will see two buttons on the UI. Click on the OK and Cancel buttons to see the output:\n\n![](img/a7ae542f-1d24-4f4c-8590-0cf82e0397c5.png)\nHow it works...\nWhen you hit the OK button in the application window, it triggers the event associated with the button click. In our case, it's the `OnOkClicked` event, inside the `ColorMixer` class. It then routes the event to the custom event `OkButtonClick`, which gets caught in the originating place. It's the `OnOkClicked` event listener in our `MainWindow.xaml`.\nSimilarly, when you click on the Cancel button, it raises the `Click` event inside the `ColorMixer` class and then routes to the `MainWindow`. If the association is present, it gets called. In our case, it's the `OnCancelClicked` handler in `MainWindow` which triggers the message box.\nCustomizing the XMLNS namespace\nXAML namespace is an extension of XML namespace and conventionally written as `xmlns` in XAML pages. It is used in all the XAML-related technologies to refer to the assemblies and/or namespaces within the XAML page.\nTill now, we have seen how to add the XMLNS attribute entry in XAML to refer to custom controls, User Controls, converters, behaviors, and so on, but all that used an assembly/namespace system to define the entry.\nFor local declaration, we use the `clr-namespace:[namespace]` format, as shown in the following code:\n\nFor declarations from a different assembly, we use the `clr-namespace:[namespace];assembly=[assembly]` format, as shown in the following code:\n\nIn this recipe, we will learn how to customize the namespace to give a URL representation.\nGetting ready\nLet's get started by creating a project called `CH05.NamespaceCustomizationDemo`. In this example, you can either choose a WPF application template or a WPF class library template.\nHow to do it...\nPerform the following steps steps to proceed:\n\n1.  Let's create two folders, called `Behaviors` and `Converters`, inside the project.\n2.  Now create one or more behaviors and converters in the respective folders. These will have `CH05.NamespaceCustomizationDemo.Behaviors` and `CH05.NamespaceCustomizationDemo.Converters` as the namespace for all the behaviors and converters in the respective modules.\n3.  To create the URL schema for the namespace representation, open the `AssemblyInfo.cs` file present in the `Properties` folder of each project.\n4.  Now, to create the schema to represent the namespace of the behaviors (`CH05.NamespaceCustomizationDemo.Behaviors`), let's add the following inside the file:\n\n```", "```cs\n\n5.  Similarly, to define the URL schema for the converters (`CH05.NamespaceCustomizationDemo.Behaviors`), add the following inside the same file:\n\n```", "```cs\n\n6.  Navigate to the `MainWindow.xaml` file. To add the XMLNS declaration, you can write ``  instead of `.` ``\n7.  It is a similar case for all the declarations that you have made in the `AssemblyInfo.cs` file to represent the namespace as a URL schema.\n\nHow it works...\nThe `XmlnsPrefix` attribute defines the prefix name that you suggest using in the XAML, while declaring the module namespace. Though it is optional to use the same prefix name,  while using the Visual Studio IntelliSense, it automatically adds it.\nWhen you define the XML namespace as URL format, it has multiple benefits over the traditional representation:\n\n*   If you follow the same structure, it is easy to remember.\n*   When you are using custom libraries, you don't have to write the complete namespace and assembly every time in each file. Thus, uses of ``  can be reduced to `.` ``\n*   You can define the prefix, so that you can follow the same convention in all the files while defining the XMLNS attribute.\n\n```"]