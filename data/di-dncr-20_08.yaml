- en: Patterns - Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 依赖注入
- en: In [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml), *Interception*,
    we completed our journey in exploring the pillars of **Dependency Injection**
    (**DI**). Now, it's time to learn the principles behind Dependency Injection and
    explore how to apply different techniques to implement those principles to acquire
    a loosely coupled architecture. There are different techniques to implement DI,
    but if you are not choosing an appropriate one while you code, you will become
    a troublemaker for the project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml)中，*拦截*，我们完成了探索**依赖注入**（**DI**）支柱的旅程。现在，是时候学习依赖注入背后的原则，并探索如何应用不同的技术来实现这些原则，以获得松散耦合的架构。有各种技术可以实现DI，但如果你在编码时没有选择合适的技术，你将成为项目的麻烦制造者。
- en: In this chapter, we will discuss different techniques, also known as **Patterns of
    Dependency Injection** with proper illustrations. I will shed light on use cases,
    and pros and the cons so that it will be easy for you to visualize the problems
    which you currently see in your application. That will eventually persuade you
    to adapt to these patterns in your app resulting in a better architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论不同的技术，也称为**依赖注入模式**，并附上适当的说明。我将阐明用例、优点和缺点，以便您能够轻松地可视化您当前在应用程序中看到的问题。这将最终说服您在应用程序中采用这些模式，从而实现更好的架构。
- en: Constructor Injection is the most important one among all these patterns. However,
    as developers, we should understand every available pattern. It's always recommended
    to use the best fit pattern for a particular scenario by analyzing the frequency
    and cases of using the dependency.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入是所有这些模式中最重要的一个。然而，作为开发者，我们应该理解每个可用的模式。始终建议通过分析依赖的使用频率和情况来为特定场景选择最佳匹配的模式。
- en: While most of these patterns address some specific context, always remember
    Constructor Injection is the simplest and can be opted without any confusion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些模式中的大多数都针对某些特定上下文，但请始终记住构造函数注入是最简单的，并且可以在没有任何混淆的情况下选择使用。
- en: 'The following topics would be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Dependency Inversion Principle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: Inversion of Control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制反转
- en: DI patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI模式
- en: The proper way to implement patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模式的正确方式
- en: The pros and cons of each pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模式的优缺点
- en: Adoption and examples in .NET Core 2.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 2.0中的采用和示例
- en: Dependency Inversion Principle
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'The SOLID principles have a D in it, which is called the **Dependency Inversion
    Principle** (**DIP**). The following statement is by Robert C. Martin on DIP:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则中有一个D，称为**依赖倒置原则**（**DIP**）。以下是对DIP的描述，由Robert C. Martin提供：
- en: '"High-level modules should not depend on low-level modules. Both should depend
    on abstractions."'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “高级模块不应依赖于低级模块。两者都应依赖于抽象。”
- en: You can consider a High-level Module as a Business Module of one application
    comprising the complex logic of the application, and a Low-level Module as the
    classes that actually perform the basic or primary functions such as writing to
    disks, interaction with the database, and so on, with the commands received from
    the Business Module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将高级模块视为一个应用程序的业务模块，它包含应用程序的复杂逻辑，而低级模块则是实际执行基本或主要功能的类，例如将数据写入磁盘、与数据库交互等，这些操作由业务模块接收的命令执行。
- en: When objects of a High-level Module interact with objects of a Low-level Module,
    they generate a coupling. This happens because you have to refer to the classes
    of Low-level Modules in order to access them for instantiation. However, the DIP
    does not recommend this. The principle encourages us to reduce the coupling so
    that the modules live isolated. It also explains how this can be done through
    abstractions. Both should commit themselves to abstractions instead of directly
    depending on each other. Let's understand this point with an example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当高级模块的对象与低级模块的对象交互时，它们会产生耦合。这是因为你必须引用低级模块的类才能访问它们以进行实例化。然而，DIP并不推荐这样做。该原则鼓励我们减少耦合，使模块能够独立生活。它还解释了如何通过抽象来实现这一点。两者都应该致力于抽象，而不是直接相互依赖。让我们用一个例子来理解这个观点。
- en: 'Consider one class called `FeedbackService` that is saving one `Feedback` details
    in the database:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个名为`FeedbackService`的类，它将一个`Feedback`详情保存到数据库中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The principal method here is `SaveFeedback`, which not only saves the feedback
    but also sends a notification. It takes the `Feedback` object and notifies type
    as parameters. When feedback is saved, usually one notification is sent to the
    customer and admin.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要方法是 `SaveFeedback`，它不仅保存反馈，还发送通知。它接受 `Feedback` 对象和通知类型作为参数。当保存反馈时，通常向客户和管理员发送一条通知。
- en: '`FeedbackService` implements an interface which can be coded like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeedbackService` 实现了一个接口，其代码可以如下编写：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`INotifier` is an interface which is implemented by all the notifier types.
    Have a look at the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifier` 是一个接口，所有通知类型都实现了这个接口。看看下面的代码：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that I have not defined the body of the methods since they are here in
    the book for illustration. You can write logic and implement yours.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有定义方法的主体，因为它们在这里是为了说明。你可以编写逻辑并实现自己的代码。
- en: Problems
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The approach seems correct, but it is not recommended and does not respect
    software design principles which are described as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法看起来是正确的，但不推荐，并且不尊重以下描述的软件设计原则：
- en: Clearly, we are violating the Single Responsibility Principle with this approach. `FeedbackService`
    is taking the responsibility to save a feedback as well as sending notifications
    after success.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们正在违反单一职责原则。`FeedbackService` 不仅负责保存反馈，还在成功后发送通知。
- en: Tight coupling exists with the concrete classes `Feedback` and other `Notifier`
    classes such as `EmailNotifier`, `SmsNotifier`, and `VoiceNotifier`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与具体的类 `Feedback` 以及其他 `Notifier` 类如 `EmailNotifier`、`SmsNotifier` 和 `VoiceNotifier`
    存在紧密耦合。
- en: 'Our most popular, the `new` keyword is used inside the `SendNotification` of
    the `FeedbackService` class to decide which `Notifier` instance to create according
    to the input `notify` of type `enum`, which can be defined as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最常用的 `new` 关键字在 `FeedbackService` 类的 `SendNotification` 方法中使用，根据输入的 `notify`
    类型的 `enum` 来决定创建哪个 `Notifier` 实例，它可以定义如下：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Solution
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution should address all the issues with the preceding approach, so that
    the resulting architecture becomes loosely coupled. Let's get started.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案应该解决前面方法的所有问题，从而使最终的架构变得松耦合。让我们开始吧。
- en: The first thing is to separate the responsibilities from the `FeedbackService`
    class. This can be easily be done by transferring the `SendNotification` responsibility
    to the notifier instead of having it inside the class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是将 `FeedbackService` 类的责任分离出来。这可以通过将 `SendNotification` 责任转移到通知者而不是在类内部完成。
- en: So, we can inject the `INotifier` type dependency inside the constructor. Thus,
    we can do `_notifier.SendNotification()` to send an injected type notification.
    Also, we changed the signature of `SaveFeedback`, which now accepts the `IFeedback`
    type parameter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在构造函数中注入 `INotifier` 类型的依赖。这样，我们就可以通过 `_notifier.SendNotification()`
    发送注入的类型通知。我们还改变了 `SaveFeedback` 的签名，现在它接受 `IFeedback` 类型的参数。
- en: '`FeedbackService` can be rewritten as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeedbackService` 可以重写如下：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now the `Service` does not depend upon the concrete implementations, and we
    eliminated the `if...else...if` clumsy codes from the class to decide which notification
    to send. The decision of notification type is now with the composer of the `Service`
    class instance. That can be done inside the Composition Root, something like the
    following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Service` 不依赖于具体的实现，并且我们从类中消除了决定发送哪种通知的 `if...else...if` 繁琐代码。通知类型的决定现在由
    `Service` 类实例的创建者来决定。这可以在组合根（Composition Root）内部完成，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inversion of Control (IoC)
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制反转（IoC）
- en: '**Inversion of Control** (**IoC**) is a Software Design Pattern which supports
    the **Dependency Inversion Principle** (**DIP**). There is a lot of confusion
    between these two terms, but if you closely observe, the names will clarify the
    doubts themselves.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**（**IoC**）是一种支持 **依赖倒置原则**（**DIP**）的软件设计模式。这两个术语之间有很多混淆，但如果你仔细观察，名称本身就能澄清疑惑。'
- en: The DIP is a principle or set of rules kind of theory. On the other hand, Inversion
    of Control is a pattern of well-defined steps we can follow to make our code DIP
    friendly. You have already experienced the steps of IoC, haven't you?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: DIP 是一种原则或规则集合的理论。另一方面，控制反转是一种定义良好的步骤模式，我们可以遵循它来使我们的代码符合 DIP。你已经体验过 IoC 的步骤，不是吗？
- en: 'Notice the steps we followed to take away the control of object creations from
    the `FeedbackService` class to an external location, which can be considered as
    a Composition Root. We did the following to be precise:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们采取的步骤，将 `FeedbackService` 类的对象创建控制权从外部位置移除，这可以被视为组合根。我们做了以下具体操作：
- en: Introduce interfaces for the concrete dependency: `INotifier` and `IFeedback`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 介绍具体依赖项的接口：`INotifier` 和 `IFeedback`。
- en: Update concrete dependencies to implement from interface: `EmailNotifier`, `SmsNotifier`,
    and `VoiceNotifier`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将具体依赖项更新为从接口实现：`EmailNotifier`、`SmsNotifier` 和 `VoiceNotifier`。
- en: 'Provide dependency to the constructor and store in a `private readonly `member:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将依赖项提供给构造函数并存储在 `private readonly` 成员中：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the private member, we can call the method of the dependency class directly: 
    `_notifier.SendNotification(feedback);`
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过私有成员，我们可以直接调用依赖类的方法：`_notifier.SendNotification(feedback);`
- en: 'Instantiate `Service` with dependency in the Composition Root:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组合根中实例化 `Service` 并包含依赖项：
- en: '`var feedbackService = new FeedbackService(new SmsNotifier());`.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`var feedbackService = new FeedbackService(new SmsNotifier());`。'
- en: So, someone else is now trying to manage the object creation and lifetime. Before
    we executed those steps, the class itself was instantiating all its dependencies
    inside it using the `new` keyword. Therefore, we inverted the controls, and flow
    of management of objects is done in reverse through someone else, isn't it! That's
    it, this is what IoC is trying to express.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在有人正在尝试管理对象创建和生命周期。在我们执行这些步骤之前，该类本身使用 `new` 关键字在其内部实例化所有依赖项。因此，我们反转了控制权，对象的管理流程是通过其他人反向进行的，不是吗！就是这样，这正是
    IoC（控制反转）试图表达的内容。
- en: The last step involves injecting the dependency object into the constructor
    of `Service`, and the pattern is known as the **Constructor Injection Pattern**.
    Let's explore this pattern with other important ones in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将依赖对象注入到 `Service` 的构造函数中，这种模式被称为 **构造函数注入模式**。让我们在下一节中探讨这个模式以及其他重要模式。
- en: 'The following is the diagram representing the DIP and non-DIP implementations.
    Notice the arrows. In non-DIP, dependencies are managed by the class itself so,
    arrows pointing to concrete class objects, whereas, in DIP, an arrow is coming
    into the class, as the dependency objects are sent by someone else:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示了依赖倒置原则（DIP）和非依赖倒置原则（non-DIP）的实现。注意箭头。在非DIP中，依赖项由类本身管理，因此箭头指向具体类对象，而在DIP中，箭头指向类，因为依赖对象是由其他人发送的：
- en: '![](img/c6784d17-712d-41e5-a556-ff8a8142d1a6.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6784d17-712d-41e5-a556-ff8a8142d1a6.png)'
- en: When a class manages all its dependencies itself, it is regarded as a **Control
    Freak**, which is an anti-pattern. We will discuss more about this anti-pattern
    in the next chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类自己管理所有依赖项时，它被视为 **控制狂**，这是一种反模式。我们将在下一章中讨论更多关于这种反模式的内容。
- en: Patterns
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'The following are the four important patterns by which we can implement Dependency
    Injection:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以通过实现依赖注入的四个重要模式：
- en: Constructor Injection Pattern
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入模式
- en: Property Injection Pattern
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性注入模式
- en: Method Injection Pattern
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入模式
- en: Ambient Context
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境上下文
- en: Let's explore one by one with illustrations, the advantages, and disadvantages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一通过插图、优点和缺点来探讨。
- en: Constructor Injection pattern
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入模式
- en: As the name suggests, Injection will take the help of the constructor. In other
    words, the constructor is the target of injection. Injection is performed by supplying
    the dependency to the constructor as an argument. This is the most common technique
    to inject dependencies into classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，注入将借助构造函数。换句话说，构造函数是注入的目标。注入是通过将依赖项作为参数提供给构造函数来执行的。这是将依赖项注入到类中最常见的技巧。
- en: 'The client calls the constructor to create the object and during the instantiation,
    the dependency gets injected, which is depicted as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端调用构造函数来创建对象，在实例化过程中，依赖项被注入，如下所示：
- en: '![](img/923d38e0-dcca-4797-a364-e90566508b8b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/923d38e0-dcca-4797-a364-e90566508b8b.png)'
- en: 'For example, a company, initially, was set up with only one department called
    Engineering. Let''s design the `Employee` class for this company as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一家公司最初只设立了一个名为工程部的部门。让我们为这家公司设计以下 `Employee` 类：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have a constructor which takes `id` and `name` as parameters and initialises
    an `Employee` object. As I told you, the company started only with Engineering
    as a department, so it''s obvious that we assign `EmployeeDept` with a new object
    of the `Engineering` class. `Engineering` and `Department` classes would look
    something as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个构造函数，它接受 `id` 和 `name` 作为参数，并初始化一个 `Employee` 对象。正如我之前所说的，公司最初只有工程部门，所以很明显，我们将
    `EmployeeDept` 赋值为 `Engineering` 类的新对象。`Engineering` 和 `Department` 类可能看起来如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you foresee a complex issue in this design? What if the company grows and
    builds another department like marketing? How would we incorporate this new department
    into the `Employee` class? How to say a particular employee belongs to the marketing
    department?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您能预见这个设计中可能存在的复杂问题吗？如果公司扩大并建立了另一个部门，比如营销部门，我们将如何将这个新部门纳入 `Employee` 类中？如何表示某个员工属于营销部门？
- en: Unfortunately, there is no way to do this here, as the `Employee` class is tightly
    coupled with the `Engineering` class. This not only leads to a bad design, but
    developers also face hurdles for unit testing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在这里没有方法可以做到这一点，因为 `Employee` 类与 `Engineering` 类紧密耦合。这不仅会导致设计不良，而且开发者也会在单元测试中遇到障碍。
- en: The solution
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: So, what is the solution? We just need a `Department` object when we instantiate
    with `Employee`. How about providing the required type of `Department` (engineering/marketing)
    reference directly to the `Employee` class?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，解决方案是什么？当我们用 `Employee` 实例化时，我们只需要一个 `Department` 对象。我们是否可以直接向 `Employee`
    类提供所需的 `Department` 类型（工程/营销）引用呢？
- en: That's super easy. Let's have a look at the modification.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。让我们看看修改后的代码。
- en: 'First, design an interface `IDepartment` which can be implemented by the `Department`
    class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，设计一个接口 `IDepartment`，该接口可以被 `Department` 类实现：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of having a property of `Department` type, now we will have that of
    type `IDepartment`. Basically, we can now allow different types of departments
    with this technique. We will see this in action in a while. Also, see how this
    property is initialized inside the constructor using the param `dept` of type
    `IDepartment`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再拥有 `Department` 类型的属性，现在我们将拥有 `IDepartment` 类型的属性。基本上，我们可以通过这种技术允许不同的部门类型。我们很快就会看到这个技术的实际应用。同时，您也可以看到这个属性是如何在构造函数中使用
    `IDepartment` 类型的 `dept` 参数进行初始化的。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now have a look at the classes for different departments. They inherit from
    `Department`, thereby implementing `IDepartment`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看不同部门的类。它们从 `Department` 继承，从而实现了 `IDepartment`：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating employees with a different department is easy now. If we create such
    objects inside the `main` method, we can do the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建不同部门的员工变得容易了。如果我们将在 `main` 方法内部创建这样的对象，我们可以做以下操作：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see how a particular `Department` object is passed to the `Employee`
    constructor to create different employees who belong to different departments.
    That is the injection we did. We injected objects of type `IDepartment` (`Engineering`
    and `Marketing`) into the `Employee` constructor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到一个特定的 `Department` 对象是如何传递给 `Employee` 构造函数以创建属于不同部门的员工。这就是我们进行的注入。我们将
    `IDepartment` 类型的对象（`Engineering` 和 `Marketing`）注入到 `Employee` 构造函数中。
- en: 'The following is the output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![](img/192956cf-7f83-4a52-95ee-0a24461d5e0d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/192956cf-7f83-4a52-95ee-0a24461d5e0d.png)'
- en: Curveball
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲线球
- en: 'You must be thinking everything in the preceding was perfect. But it is not.
    Let''s analyze it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为前面的内容都是完美的。但事实并非如此。让我们来分析一下：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see I created an object with employee department as `Engineering`. Then
    in the next line, we can easily change the department by assigning a `Marketing`
    object to it. This should be completely avoided.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我创建了一个部门为 `Engineering` 的对象。然后在下一行，我们可以轻松地通过将 `Marketing` 对象赋值给它来更改部门。这应该完全避免。
- en: To do that, the field must be marked as `private` and `readonly`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，该字段必须被标记为 `private` 和 `readonly`。
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's not strictly recommended, but we should definitely follow this so that
    developers can't unnecessary hijack the actual values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是严格推荐的，但我们确实应该遵循这一点，以便开发者不能无端地篡改实际值。
- en: 'Secondly, the constructor does not handle the case where the dependent instance
    is received as `null`. The constructor can be altered as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，构造函数没有处理依赖实例作为 `null` 接收的情况。构造函数可以被修改如下：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now here is the important thing, the constructor not only does the job of pushing
    the dependent instance to a `private` property, but also inserts values to other
    member variables such as `EmployeeId` and `EmployeeName`. This is against the
    Single Responsibility Principle. Therefore, we should have the constructor only
    handling the dependency thing and nothing else:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重要的是，构造函数不仅负责将依赖实例推送到一个 `private` 属性，还向其他成员变量（如 `EmployeeId` 和 `EmployeeName`）插入值。这违反了单一职责原则。因此，我们应该让构造函数只处理依赖项，而无需做其他事情：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Also, writing like this would guarantee that when an object is created, it will
    contain the dependency within it. At the same time, this will be valued only if
    the class is fully dependent on the dependency henceforth.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以这种方式编写可以保证当创建一个对象时，它将包含其中的依赖项。同时，这只有在类从此以后完全依赖于依赖项的情况下才有价值。
- en: 'Let me summarise the points quickly as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我快速总结以下要点：
- en: The class which is dependent must expose a `public` constructor where the dependency
    can be injected
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖的类必须公开一个 `public` 构造函数，以便注入依赖项
- en: If more than one dependency is required, then we can add more arguments to the
    constructor
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要多个依赖项，则可以向构造函数添加更多参数
- en: The dependent class should mark the member variable as `private readonly` where
    dependency instance will be assigned
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖类应将成员变量标记为 `private readonly`，其中将分配依赖实例
- en: The dependent class constructor should only do the job of managing the dependency
    and nothing else
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖类构造函数应仅执行管理依赖项的工作，而无需做其他事情
- en: Injecting with .NET Core 2.0
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET Core 2.0 注入
- en: 'We saw every example previously, where we initialised using the `new` keyword.
    However, we should use the .NET Core 2.0 way of resolving the dependency:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了每个示例，都是使用 `new` 关键字进行初始化。然而，我们应该使用 .NET Core 2.0 的方式来解决依赖项：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `ServiceCollection` object to register the interfaces with the type
    we expect when it is resolved. When we do `serviceProvider.GetService();`, it
    returns an employee object with the department as `Engineering` since we registered
    `IDepartment` as `Engineering` in the collection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ServiceCollection` 对象来注册在解析时我们期望的类型接口。当我们执行 `serviceProvider.GetService();`
    时，它返回一个部门为 `Engineering` 的员工对象，因为我们已在集合中将 `IDepartment` 注册为 `Engineering`。
- en: Implementation inside ASP.NET Core 2.0
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0 内部的实现
- en: Let's have a closer look at ASP.NET Core 2.0 internal codes for `ControllerActivatorProvider.cs`
    inside `Microsoft.AspNetCore.Mvc.Core` `Controllers` to understand how Constructor
    Injection is implemented.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看位于 `Microsoft.AspNetCore.Mvc.Core` `Controllers` 中的 `ControllerActivatorProvider.cs`
    的 ASP.NET Core 2.0 内部代码，以了解构造函数注入是如何实现的。
- en: ControllerActivatorProvider.cs
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ControllerActivatorProvider.cs
- en: 'I will show a screenshot of the class where the constructor is written:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示一个包含构造函数的类的截图：
- en: '![](img/91b877ef-c090-4344-a6c7-592199f1c23f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b877ef-c090-4344-a6c7-592199f1c23f.png)'
- en: '`IControllerActivator` is the dependency which is injected into the constructor
    of this class. Then, it is using the instance to do some operation inside the
    class. We can easily find more of such kind of examples in .NET Core 2.0.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`IControllerActivator` 是注入到这个类构造函数中的依赖项。然后，它使用这个实例在类内部执行一些操作。我们可以在 .NET Core
    2.0 中轻松找到更多这样的例子。'
- en: 'To see how this dependency is resolved, we can check the method `AddMvcCoreServices` of
    the `MvcCoreServiceCollectionExtensions.cs` class inside the `Microsoft.AspNetCore.Mvc.Core`
    `DependencyInjection`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这种依赖是如何解决的，我们可以检查位于 `Microsoft.AspNetCore.Mvc.Core` `DependencyInjection`
    中的 `MvcCoreServiceCollectionExtensions.cs` 类的 `AddMvcCoreServices` 方法：
- en: '![](img/84f0c2b9-30ec-40f1-8bbc-5edd42b9bdd4.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84f0c2b9-30ec-40f1-8bbc-5edd42b9bdd4.png)'
- en: Importance of the Constructor Injection pattern
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入模式的重要性
- en: As the injection is tied to the constructor, this means whenever you try to
    instantiate a particular class, we are 100% sure that the dependency is shipped
    or tied with the object created. The guarantee of having the dependency is ensured
    by the Guard Clause, which verifies the dependency as not `null` before assigning
    that to the `private readonly` data member. Otherwise, the construction of class
    throws an exception.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于注入与构造函数相关联，这意味着每次尝试实例化特定类时，我们都能100%确信依赖项被包含或与创建的对象绑定。通过 Guard Clause 确保依赖项不是
    `null` 并将其分配给 `private readonly` 数据成员，从而确保了拥有依赖项的保证。否则，类的构造函数将抛出异常。
- en: There is no possibility of having one object of such class without injecting
    the dependency. Thus, the state of the object is always valid with no discrepancies.
    Unit testing with mocks becomes easy with this approach. Let's have a look at
    the pros and cons too.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 没有可能不注入依赖就拥有此类的一个对象。因此，对象的状态始终有效，没有差异。使用模拟进行单元测试变得容易。让我们也看看其优缺点。
- en: Advantages of the Constructor Injection pattern
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入模式的优势
- en: This is the most preferable way of respecting the concept of DI. Most DI containers
    target the constructors. It is also the most common and more widely used pattern
    for DI. The injected component can be used anywhere in the class because when
    you create the object, the injected dependency comes into the class automatically
    and stays in some variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是尊重DI概念的最受欢迎的方式。大多数DI容器都针对构造函数。它也是DI最常见和更广泛使用的模式。注入的组件可以在类的任何地方使用，因为当你创建对象时，注入的依赖项会自动进入类并保存在某个变量中。
- en: Developers prefer this technique when classes require some external dependency
    to initiate all other operations. As a constructor is involved, an object becomes
    ready with the dependent object once it is instantiated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当类需要一些外部依赖来启动所有其他操作时，开发者更喜欢这种技术。由于构造函数涉及其中，一旦实例化，对象就准备好了依赖对象。
- en: Disadvantages of the Constructor Injection pattern
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性注入模式的不利之处
- en: This is not so easy to implement when the class contains many constructors.
    Moreover, when the number of dependencies increases for a class, updating the
    constructor each time is not a feasible task.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当类包含许多构造函数时，这并不容易实现。此外，当类的依赖项数量增加时，每次更新构造函数都不是一项可行的任务。
- en: When you have a number of arguments for a constructor by adding the dependency
    ones with the existing ones, the class will look messy.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数有多个参数时，通过添加依赖项与现有参数一起，类看起来会很混乱。
- en: Property Injection pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性注入模式
- en: In this technique, instead of asking the constructor to support the injection,
    we will directly inject to the property of the class. Let's get started.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种技术中，我们不会要求构造函数支持注入，而是直接将依赖注入到类的属性中。让我们开始吧。
- en: 'The following diagram depicts one property `EmployeeDept`, which can be injected
    directly with an `IDepartment` implementation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了一个属性`EmployeeDept`，它可以直接注入`IDepartment`实现：
- en: '![](img/f37e69e5-b4e1-40e3-8395-a2b7c24b106b.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f37e69e5-b4e1-40e3-8395-a2b7c24b106b.png)'
- en: 'The `Employee` class without the constructor argument for `IDepartment` and
    a new setter property will look something like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 没有构造函数参数`IDepartment`和新的设置属性`Employee`类看起来如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We just removed the `IDepartment` argument from the constructor because we
    are going to directly assign an `IDepartment` type object to the property `EmployeeDept`.
    This can be done while creating the `Employee` object as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚从构造函数中移除了`IDepartment`参数，因为我们打算直接将一个`IDepartment`类型的对象分配给属性`EmployeeDept`。这可以在创建`Employee`对象时完成，如下所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thus, by doing `emp.EmployeeDept = new Engineering();`, we are directly pushing
    the `Engineering` object into the property `EmployeeDept`. The same thing is done
    for `emp1` too.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过执行`emp.EmployeeDept = new Engineering();`，我们直接将`Engineering`对象推入属性`EmployeeDept`。对于`emp1`也执行了同样的操作。
- en: 'However, this code won''t compile. We are missing something important here.
    Consider the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码无法编译。我们遗漏了一些重要的东西。考虑以下截图：
- en: '![](img/dbb64f95-24c4-4dc0-bb7b-b52175be846e.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbb64f95-24c4-4dc0-bb7b-b52175be846e.png)'
- en: 'The error is totally self-explanatory. We forgot to include the Getter block
    as we wanted to print the department name. Consider the following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 错误完全自解释。我们忘记包含获取器块，因为我们想打印部门名称。考虑以下代码片段：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we are good. When you run it, you will see the same output as we got in
    the case of Constructor Injection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们做得很好。当你运行它时，你会看到与构造函数注入案例中相同的输出。
- en: Property Injection is preferred when there is an optional dependency required
    for the class. What that means is, if you don't supply the value, the class won't
    mind as it can run without this dependency. If the developer forgets to assign
    the dependency, it should not affect the flow of the app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当类需要可选依赖项时，首选属性注入。这意味着，如果你不提供值，类不会介意，因为它可以在没有此依赖项的情况下运行。如果开发者忘记分配依赖项，它不应影响应用程序的流程。
- en: For instance, in our example, if you don't do anything with the property `EmployeeDept`,
    the class will behave as usual as long as you are not reading the property. In
    the next section, I will tell you how to beautify the code because the code is
    not yet perfect.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的例子中，如果您不对属性`EmployeeDept`做任何操作，只要您不读取该属性，类将像往常一样表现。在下一节中，我将告诉您如何美化代码，因为代码还没有完美。
- en: Curveball
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲球
- en: 'The problems with the approach which we have taken can be any one of the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取的方法存在的问题可以是以下任何一个：
- en: If you don't assign anything to the property (as we developers forget sometimes
    being lazy), the output won't return you anything when you print.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您没有为属性分配任何内容（就像我们开发者有时因为懒惰而忘记做的那样），当您打印时，输出不会返回任何内容。
- en: You can assign null to the property as simply as `emp.EmployeeDept = null;`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以像这样简单地分配`null`给属性：`emp.EmployeeDept = null;`。
- en: Once you assign a dependency to a property, you can easily assign another dependency
    easily, which might be a problem. This might happen accidentally, however, it
    will create side effects for the whole system at some point in time. Imagine a
    situation where you initialized the property with engineering and then changed
    that to marketing, which is wrong.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您将依赖项分配给属性，您就可以轻松地分配另一个依赖项，这可能会成为一个问题。这可能会意外发生，然而，它将在某个时间点对整个系统产生副作用。想象一下这种情况：您用工程初始化了属性，然后将其更改为营销，这是错误的。
- en: 'To handle all these situations, we should introduce more protection to the
    property. Let''s do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理所有这些情况，我们应该为属性引入更多的保护。让我们这样做：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inside the setter, we check for `null` and throw an exception. Then, we again
    investigate whether it is already there and throw an `InvalidOperationException`.
    Likewise, in the Getter, we are assigning a default value as engineering when
    passed `null`. Thus, we guarded our property for all such difficult situations,
    as previously discussed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置器内部，我们检查`null`并抛出异常。然后，我们再次调查它是否已经存在，并抛出`InvalidOperationException`。同样，在获取器中，当传入`null`时，我们将其分配为默认值作为工程。因此，我们保护了我们的属性以应对所有这些困难的情况，如前所述。
- en: Property Injection is not supported by the .NET Core built-in DI or IoC Container
    out of the box. Also, there is no such plan to bring this into the default container
    as of now. You have to use an external container such as Autofac to support this
    feature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 属性注入不是.NET Core内置的DI或IoC容器默认支持的。目前也没有计划将其引入默认容器。您必须使用外部容器，例如Autofac，来支持此功能。
- en: Advantages of the Property Injection Pattern
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性注入模式的优势
- en: 'We can see the following advantages of having a Setter Injection Pattern:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下拥有设置器注入模式的优点：
- en: It does not require adding a new constructor or modifying an existing constructor.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要添加新的构造函数或修改现有的构造函数。
- en: This pattern comes in handy if the class has multiple dependencies of different
    types. Suppose there is a class which will use different types of logging such
    as logging, to text or logging to the database at the same time in different conditions,
    then having two setter properties where we can simply inject the required logger
    to do our task.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类有多个不同类型的依赖项，这个模式就派上用场了。假设有一个类，它将在不同条件下同时使用不同类型的日志记录，例如日志记录到文本或数据库，那么拥有两个设置器属性，我们可以简单地注入所需的记录器来完成我们的任务。
- en: Disadvantages of the Property Injection Pattern
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性注入模式的缺点
- en: Setters are not easy to identify in a particular design to inject some external
    dependency. Still, they are preferred in some situations. However, we should be
    careful while using the property which is injected because that might be `null`.
    There should be an extra check for `null`, everywhere where you want to use it.
    As we already discussed, protection must be provided to the property to avoid
    the inconsistent behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定设计中识别设置器以注入外部依赖项并不容易。尽管如此，在某些情况下它们仍然被优先考虑。然而，在使用注入的属性时我们应该小心，因为那可能为`null`。在您想要使用它的任何地方都应该进行额外的`null`检查。正如我们之前讨论的，必须为属性提供保护以避免不一致的行为。
- en: Property Injection is considered as bad practice in most of the cases because
    it hides the dependencies. When the class is instantiated, there is no guarantee
    that the dependency object will be available for the class to do any operation,
    unlike Constructor Injection, where the dependency makes its way through during
    instantiation itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 属性注入在大多数情况下被认为是不良实践，因为它隐藏了依赖关系。当类被实例化时，没有保证依赖对象将可用于类执行任何操作，这与构造函数注入不同，在实例化过程中依赖项本身就会找到路径。
- en: Method Injection Pattern
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法注入模式
- en: As the name suggests, we will inject the dependency into a method like we did
    in the case of the constructor. This comes in handy when we want different types
    of dependency in different methods of a class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，我们将像在构造函数的情况中那样将依赖项注入到一个方法中。当我们想在类的不同方法中使用不同类型的依赖项时，这会非常有用。
- en: 'Look at the following diagram, which tells us about the `AssignDepartment(IDepartment)`
    method taking `IDepartment` as a dependency inside the `Employee` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下图表，它告诉我们 `Employee` 类中的 `AssignDepartment(IDepartment)` 方法如何作为依赖项使用：
- en: '>![](img/c4d5974f-df2b-4a27-b678-d84fa27f333f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/c4d5974f-df2b-4a27-b678-d84fa27f333f.png)'
- en: The client can create an object of the `Employee` class and then fire `AssignDepartment`
    with the appropriate implementation of `IDepartment`, so that dependency is provided.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以创建 `Employee` 类的一个对象，然后使用适当的 `IDepartment` 实现调用 `AssignDepartment`，从而提供依赖项。
- en: 'Let''s see how the `Employee` class can be coded:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编码 `Employee` 类：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this particular scenario, we have a method `AssignDepartment`, which takes
    one `IDepartment` type argument and then assigns that to the property. An `Employee`
    object can be created accordingly. Consider the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定场景中，有一个 `AssignDepartment` 方法，它接受一个 `IDepartment` 类型的参数，并将其分配给属性。可以相应地创建一个
    `Employee` 对象。考虑以下代码片段：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It also produces the same output as what we have already seen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它也产生了我们之前已经看到的相同输出。
- en: This pattern is useful when we require some dependency, only for some particular
    operation in a method and not for the whole class. Sometimes, the situation demands
    a small change which might be an edge case. To accommodate a small change, the
    simplest way would be to create a method and do whatever you want inside that
    (using dependencies passed in as arguments) instead of touching the constructors
    or properties.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在需要某些依赖项仅用于方法中的某些特定操作，而不是整个类时非常有用。有时，情况需要一个小改动，可能是一个边缘情况。为了适应这个小改动，最简单的方法是创建一个方法，并在其中做任何你想做的事情（使用作为参数传递的依赖项），而不是触摸构造函数或属性。
- en: Curveball
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Curveball
- en: 'In the case of Method Injection, by convention, we should also take care of
    null check to ensure that the dependency is available before using it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法注入的情况下，按照惯例，我们也应该注意空值检查，以确保在使用之前依赖项可用：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Injecting with .NET Core 2.0
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET Core 2.0 注入
- en: 'As we did in previous patterns, we will get the instance using the `GetService`
    method and then call the required method by injecting the dependency:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在之前的模式中所做的那样，我们将使用 `GetService` 方法获取实例，然后通过注入依赖项调用所需的方法：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next thing you will see is the following as the output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来会看到以下输出：
- en: '![](img/055312b3-271d-43f1-8df4-7710be1f7737.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/055312b3-271d-43f1-8df4-7710be1f7737.png)'
- en: This happened because we have a constructor which is taking `integer` and `string`
    params. The provider is not aware of the process to resolve them, therefore, it
    throws an exception. The solution is to provide a default constructor, as the
    service provider is looking for it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们有一个接受 `integer` 和 `string` 参数的构造函数。提供者不知道如何解析它们的过程，因此抛出异常。解决方案是提供一个默认构造函数，因为服务提供者正在寻找它。
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implementation inside .NET Core 2.0
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 2.0 中的实现
- en: We can get many instances of Method Injection Pattern usage inside the .NET
    Core 2.0\. One of them is inside the simplest and frequently used class `MvcServiceCollectionExtensions.cs`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 2.0 中，我们可以找到许多方法注入模式的使用实例。其中之一是在最简单且最常用的类 `MvcServiceCollectionExtensions.cs`
    中。
- en: MvcServiceCollectionExtensions.cs
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MvcServiceCollectionExtensions.cs
- en: 'The `MvcServiceCollectionExtensions.cs` class contains the method `AddMvcCore`,
    which is an example of Method Injection. The following screenshot shows the method
    at a glance:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`MvcServiceCollectionExtensions.cs` 类包含 `AddMvcCore` 方法，这是一个方法注入的例子。以下截图展示了该方法的概览：'
- en: '![](img/9ee3d342-6b6d-4060-8b90-980db41fb1f6.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ee3d342-6b6d-4060-8b90-980db41fb1f6.png)'
- en: '`IServiceCollection` is injected into the `AddMvcCore` method. After it has
    been verified as not `null`, the service collection is processed further. I am
    only showing a screenshot of the relevant codes to understand the concept. You
    can definitely find such examples in other classes.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceCollection` 被注入到 `AddMvcCore` 方法中。在它被验证为非 `null` 之后，服务集合会被进一步处理。我仅展示相关代码的截图以理解该概念。你肯定可以在其他类中找到这样的例子。'
- en: The **Interface Injection Pattern** is something which we have already discussed
    in other patterns, where we injected the implementations such as  `IDepartment`
    which is an interface, into the constructor, property or a method. It's recommended
    to inject the implementation instead of the concrete class to avoid tight coupling.
    Interface injection allows us to achieve loose coupling along with abstraction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口注入模式**是我们已经在其他模式中讨论过的一种模式，其中我们将实现（如 `IDepartment`，它是一个接口）注入到构造函数、属性或方法中。建议注入实现而不是具体类，以避免紧密耦合。接口注入使我们能够实现解耦和抽象。'
- en: Ambient context
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ambient 上下文
- en: Ambient is an adjective meaning completely surrounding or encompassing. This
    means when we say Ambient context, it denotes some context, which would pertain
    its existence and behavior in the background or surrounding.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Ambient 是一个形容词，意为完全围绕或包含。这意味着当我们说 Ambient 上下文时，它表示某种上下文，这将涉及其在背景或周围的存在和行为。
- en: When many classes require the same dependency, we should follow some technique
    to make it available to every such client.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多类需要相同的依赖项时，我们应该遵循一些技术来使其对每个此类客户端可用。
- en: The patterns we discussed are not appropriate for such a scenario. If you try
    to make this possible using Constructor Injection, for example, you would end
    up adding a constructor for every class, having the same dependency injected to
    it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的模式不适用于这种场景。例如，如果你尝试使用构造函数注入来实现这一点，你最终将为每个类添加一个构造函数，并将相同的依赖项注入其中。
- en: Sounds more like a Cross-cutting Concern, doesn't it? To achieve this, we can
    simply add a static accessor for the dependency. This will make sure that the
    dependency is reachable to all the clients demanding it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来更像是一个横切关注点，不是吗？为了实现这一点，我们可以简单地为依赖项添加一个静态访问器。这将确保依赖项对所有要求它的客户端都是可访问的。
- en: 'The concept can be visualized in the following diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以在以下图中可视化：
- en: '![](img/e94dcddc-982d-4c55-8bbb-3f7a0f95a6ff.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e94dcddc-982d-4c55-8bbb-3f7a0f95a6ff.png)'
- en: 'Let''s consider an example to get a better understanding of the implementation.
    An abstract class `DepartmentProvider` can be designed to provide a static accessor
    called `Current`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解实现方式。可以设计一个抽象类 `DepartmentProvider`，以提供名为 `Current` 的静态访问器：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We marked the class as `abstract` and there is a `virtual` property called `Department`,
    which will be accessed by any class requiring that.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类标记为 `abstract`，并且有一个名为 `Department` 的 `virtual` 属性，它将被任何需要它的类访问。
- en: 'Let''s see how we can use the `Current` property. The following code uses the
    class `MarketingProvider` instance which is a derived class of  `DepartmentProvider`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `Current` 属性。以下代码使用了 `MarketingProvider` 类的实例，它是 `DepartmentProvider`
    的派生类：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'See how we can register `MarketingProvider` using the built-in DI container.
    Then we assigned that to the `Current` property by which we are able to get the
    value as marketing when we read `DepartmentProvider.Current.Department`. `MarketingProvider`
    is a child class of `DepartmentProvider`, which returns a `Marketing` object.
    Refer to the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何使用内置的 DI 容器注册 `MarketingProvider`。然后我们将它分配给 `Current` 属性，通过这个属性，我们能够在读取
    `DepartmentProvider.Current.Department` 时获取到营销值。`MarketingProvider` 是 `DepartmentProvider`
    的子类，它返回一个 `Marketing` 对象。请参考以下代码：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, we made a conclusion here. We can use the `static` property wherever we
    need inside the app and the value will be the same, unless you set it differently
    in-between.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出结论。我们可以在应用程序内部需要的地方使用 `static` 属性，除非你在其中设置了不同的值，否则值将是相同的。
- en: Curveball
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲球
- en: 'A following are a few important points to remember while implementing an Ambient
    Context:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 Ambient Context 时，以下是一些重要要点需要记住：
- en: This should be used only if it is really necessary. Constructor Injection or
    Property Injection should be the first choice before deciding to use Ambient Context.
    If you can't decide, just choose other DI patterns.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这应该只在真正必要时使用。在决定使用 Ambient Context 之前，构造函数注入或属性注入应该是首选。如果你无法决定，就选择其他 DI 模式。
- en: The Service Locator anti-pattern is quite similar to this pattern in the way
    it provides the dependency. However, there is a difference and that is Ambient
    Context supplies a single dependency, whereas Service Locator is responsible for
    providing all requested dependencies. We will discuss more on Service Locator
    in [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器反模式在提供依赖的方式上与这个模式非常相似。然而，有一个区别，那就是环境上下文提供单个依赖项，而服务定位器负责提供所有请求的依赖项。我们将在第
    9 章 [Anti-Patterns and Misconceptions on Dependency Injection](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml)
    中进一步讨论服务定位器。
- en: If you don't correctly implement Ambient Context, it will have side effects.
    Suppose you initiate using one context or provider and during the process, you
    change it due to some reason. Now, when you read the value, it will provide you
    with the changed value instead of the first one because of static. That means
    you need to be very careful while implementing this.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有正确实现环境上下文，它将会有副作用。假设你开始使用一个上下文或提供者，在过程中由于某些原因更改了它。现在，当你读取值时，由于静态特性，它将提供更改后的值而不是第一个值。这意味着你在实现时需要非常小心。
- en: With the implementation we discussed, you can easily set `null` to the `Current`
    property `DepartmentProvider.Current = null;`. Therefore, we have to protect it
    by using a guard clause.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过我们讨论的实现，你可以轻松地将 `null` 设置到 `Current` 属性 `DepartmentProvider.Current = null;`。因此，我们必须通过使用守卫子句来保护它。
- en: 'The following code represents a simple guard clause inside getter and setter
    blocks:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示在获取器和设置器块中的简单守卫子句：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We did a null check both in getter and setter and used a backup provider called
    `DefaultDepartmentProvider` to overcome the situation of mishandling the context.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在获取器和设置器中都进行了空检查，并使用了一个名为 `DefaultDepartmentProvider` 的备用提供者来克服处理上下文不当的情况。
- en: Implementation inside .NET Core 2.0
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 .NET Core 2.0 中的实现
- en: The `corefx` library has a  `CurrentPrincipal` `static` property inside the
    partial class `Thread` under  `System.Threading` namespace.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`corefx` 库在 `System.Threading` 命名空间下的部分类 `Thread` 中有一个 `CurrentPrincipal` `static`
    属性。'
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The usage can be seen in a method `Demand()` of the class `PrincipalPermission`
    under the namespace `System.Security.Permissions`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例可以在命名空间 `System.Security.Permissions` 下的类 `PrincipalPermission` 的方法 `Demand()`
    中看到：
- en: '![](img/18fdc3f9-c8d6-4b42-81ca-435b2c7dc3ff.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18fdc3f9-c8d6-4b42-81ca-435b2c7dc3ff.png)'
- en: The advantages of the Ambient Context
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境上下文的优点
- en: Ambient Context is definitely a savior when an app demands the same dependency
    multiple times during the app execution. It's very hard to realise the fact that
    while we write codes for injecting dependencies, there are many such instances
    of asking the same dependency repeatedly within the app. This is the time where
    we should take the help of the Ambient Context Pattern, and with just a simple
    `static` accessor, we will be able to get the dependency. This not only reduces
    code but also imposes the DRY principle.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在执行期间多次请求相同的依赖项时，环境上下文绝对是一个救星。在编写注入依赖项的代码时，很难意识到在应用程序内部有如此多的重复请求相同依赖项的实例。这就是我们应该利用环境上下文模式的时候，通过一个简单的
    `static` 访问器，我们就能获取到依赖项。这不仅减少了代码，还遵循了 DRY 原则。
- en: The disadvantages of the Ambient Context
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境上下文的缺点
- en: Ambient Context is not easy to implement and needs careful attention while using
    it. By just looking at a class, we can't tell whether it implements the Ambient
    Context Pattern or not. If the context changes in between execution, the outcome
    will be different, resulting in side effects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 环境上下文不易实现，在使用时需要仔细注意。仅通过查看一个类，我们无法判断它是否实现了环境上下文模式。如果在执行过程中上下文发生变化，结果将不同，从而导致副作用。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While implementing DI, we should definitely learn the techniques associated
    with it. These techniques, otherwise called DI patterns, play a vital role in
    the application architecture. So, deciding which pattern to use when is the most
    important factor in the case of injecting dependencies.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现依赖注入时，我们绝对应该学习与之相关的技术。这些技术，也称为依赖注入模式，在应用程序架构中起着至关重要的作用。因此，决定何时使用哪种模式是注入依赖项时最重要的因素。
- en: Constructor Injection is the most widely used, is easy, and should always be
    your first choice. However, there are scenarios where you might opt for another
    pattern.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入是最广泛使用的，简单易用，并且应该始终是你的首选。然而，在某些情况下，你可能需要选择另一种模式。
- en: When you see there are multiple dependencies required for different operations
    of a class, choose the Method Injection Pattern as it allows you the flexibility
    to inject dependency as you require.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到某个类的不同操作需要多个依赖项时，选择方法注入模式，因为它允许你根据需要灵活地注入依赖项。
- en: Another beautiful design case reveals itself while you land on a situation where
    you need certain dependency at many places in your app. It looks like a Cross-Cutting
    Concern, however, you expect a certain return type, which is the dependency. For
    that, you need to use Ambient Context and can't rely on interceptors. This is
    because you need the returned dependency to do some operation in your class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到需要在应用程序的多个地方使用特定依赖项的情况时，另一个漂亮的设计案例就会显现出来。这看起来像是一个横切关注点，然而，你期望得到一个特定的返回类型，即依赖项。为此，你需要使用环境上下文，而不能依赖于拦截器。这是因为你需要返回的依赖项在类中执行某些操作。
- en: Property Injection is something which allows you to inject optional dependency.
    This means it relies upon a Local Default for sure, otherwise, we might end up
    in an exception while requesting it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 属性注入是一种允许你注入可选依赖项的技术。这意味着它肯定依赖于本地默认值，否则在请求它时我们可能会遇到异常。
- en: In [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*, we will explore bad practices while implementing
    DI, which are denoted as anti-patterns.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml)《依赖注入中的反模式和误解》中，我们将探讨在实现依赖注入时的一些不良做法，这些做法被称为反模式。
