<html><head></head><body>
        

                            
                    Debugging and Threading
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Enabling the UI debugging tool for XAML</li>
<li>Navigating through XAML elements using Live Visual Tree</li>
<li>Inspecting XAML properties using Live Property Explorer</li>
<li>Updating the UI from a non-UI thread</li>
<li>Adding cancelation support to long running threads</li>
<li>Using the background worker component</li>
<li>Using a timer to periodically update the UI</li>
</ul>
<h1 id="uuid-aadfe863-17fa-4a85-b70e-75462df8d170" class="">Introduction</h1>
<p>When it comes to application development, debugging plays a vital role. It is a process that helps you to quickly look at the current state of your program by walking through the code line by line. While writing the code, developers start debugging their applications. Sometimes, developers start debugging even before writing the first line of code to know the existing logic.</p>
<p>Visual Studio provides us with details about running programs as much as possible and helps you to change some values while the application is running. As a developer, you must already know this. As the focus of this book is on <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>), we will be discussing XAML UI debugging using <strong>Live Visual Tree</strong> and <strong>Live Property Explorer</strong>.</p>
<p>Later in this chapter, we will discuss <strong>threading</strong> and learn how to update a UI thread from a non-UI thread, a background worker process, and a timer that is used to periodically update the UI.</p>
<h1 id="uuid-ba1e8d77-ab76-4c2f-a838-2e92e549dbfc">Enabling the UI debugging tool for XAML</h1>
<p>To begin debugging your XAML application UI, you will first need to enable a few settings in Visual Studio. If the settings are disabled, you won't be able to view the <strong>Live Visual Tree</strong> and the <strong>Live Properties</strong> window, which we will be discussing in the next few recipes.</p>
<p>These settings are by default enabled in Visual Studio 2017, but in case are disabled; this recipe will help you to get started with that.</p>
<h2 id="uuid-d1b0fe5a-41ae-447f-9627-eab51550795a">Getting ready</h2>
<p>Make sure that you have Visual Studio 2017. Open it to get started with the settings changes.</p>
<h2 id="uuid-00a1342b-f18a-477f-bc08-d5a528952a08">How to do it...</h2>
<p>Follow the steps mentioned here to verify and enable the UI Debugging Tools for XAML in Visual Studio 2017:</p>
<ol>
<li>Inside the Visual Studio IDE, navigate to the Tools | Options... menu, as shown in the following screenshot:</li>
</ol>
<div><img src="img/48a669c8-31c8-490c-8c7f-05b27b019075.png"/></div>
<ol start="2">
<li>This will open the Visual Studio Options window. From this page, navigate to the Debugging | General section.</li>
</ol>
<p> </p>
<ol start="3">
<li>Select the checkbox labeled Enable UI Debugging Tools for XAML, and switch it ON if it is not already:</li>
</ol>
<div><img src="img/31212628-0a71-4961-a105-1c99e420412a.png"/></div>
<ol start="4">
<li>Once you switch ON the functionality to debug the XAML application UI, you will enable a few more settings to use the <strong>Live Visual Tree</strong> and modifications of XAML properties when the debugger is already attached.</li>
<li>From the same page, select the other checkboxes labeled Preview selected elements in Live Visual Tree and Show runtime tools in application.</li>
<li>To be able to change the XAML elements and their properties when the application is already running in debug mode, check Enable XAML Edit and Continue, as shown in the preceding screenshot.</li>
<li>Click OK to save the changes and restart the debugging process for the changes to take effect. You will now be able to debug your XAML UI.</li>
</ol>
<h1 id="uuid-016dd1d9-77f0-4c8f-8072-8dc914dc93e6">Navigating through XAML elements using Live Visual Tree</h1>
<p><strong>Live Visual Tree</strong> is a debugger tool that helps you to perform XAML debugging more easily. Using this, you can inspect the XAML at runtime and visualize the layout to show alignments and space for UI elements.</p>
<p>Basically, Live Visual Tree provides you a tree view of the UI elements of your running XAML application, and provides information about the number of XAML elements inside each container. If the interface changes from one state to another, Live Visual Tree also changes in runtime.</p>
<p>In this recipe, we will learn more about Live Visual Tree and how to use it to visualize the actual control rendering on the UI.</p>
<h2 id="uuid-916b7f34-c80f-4d44-b88d-ccc622b3867c">Getting ready</h2>
<p>To get started, open Visual Studio 2017 IDE and create a new WPF project named <kbd>CH10.XamlDebuggingDemo</kbd>.</p>
<h2 id="uuid-bf2e54db-5621-40ee-8c1e-9e8ff03234f4">How to do it...</h2>
<p>Follow the steps mentioned here to create our sample demo application and then learn how to use <strong>Live Visual Tree</strong> to navigate through the XAML elements while debugging the application:</p>
<ol>
<li>Let's first design our application UI. Open the <kbd>MainWindow.xaml</kbd> file from Solution Explorer.</li>
<li>Divide the default <kbd>Grid</kbd> panel to have five rows in the following manner:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
    &lt;RowDefinition Height="*"/&gt; 
&lt;/Grid.RowDefinitions&gt;</pre>
<ol start="3">
<li>Inside the <kbd>Grid</kbd>, add the following XAML code block to create a login screen with a few textblocks, textboxes, and button controls. Place them in appropriate rows as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBlock Text="Username:" 
           Grid.Row="0" 
           Margin="0 4 0 0"/&gt; 
&lt;TextBlock Text="Password:" 
           Grid.Row="2" 
           Margin="0 4 0 0"/&gt; 
 
&lt;TextBox x:Name="username" 
         Grid.Row="1"/&gt; 
&lt;TextBox x:Name="password" 
         Grid.Row="3"/&gt; 
 
&lt;StackPanel Orientation="Horizontal" 
            HorizontalAlignment="Center" 
            VerticalAlignment="Center" 
            Grid.Row="4"&gt; 
    &lt;Button Content="Login"/&gt; 
    &lt;Button Content="Cancel"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="4">
<li>Now, inside the <kbd>&lt;Window&gt;</kbd> tag, add <kbd>&lt;Window.Resources&gt;</kbd> and add the following styles for the <kbd>TextBox</kbd> and <kbd>Button</kbd> controls to give them a proper look:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;Style TargetType="TextBox"&gt; 
        &lt;Setter Property="Height" 
                Value="24"/&gt; 
    &lt;/Style&gt; 
         
    &lt;Style TargetType="Button"&gt; 
        &lt;Setter Property="Margin" 
                Value="4"/&gt; 
        &lt;Setter Property="Width" 
                Value="60"/&gt; 
        &lt;Setter Property="Height" 
                Value="30"/&gt; 
    &lt;/Style&gt; 
&lt;/Window.Resources&gt;</pre>
<ol start="5">
<li>Once the UI is ready, let's run the application. You will see the following output on the screen:</li>
</ol>
<div><img src="img/506b3fa6-288b-46a3-a28c-b9ac7cb2c22f.png"/></div>
<ol start="6">
<li>Now, close the application and run it in debug mode. To do this, either click on the Start button (<img src="img/56df5ce0-a8b4-4745-8b84-26d258ecfc9c.png"/>) on the <strong>Visual Studio Toolbar</strong> or navigate to the Visual Studio Debug menu and click Start Debugging.</li>
<li>Alternatively, you can press the keyboard shortcut <em>F5</em> to run the application in debug mode.</li>
<li>Once the application launches, you will see the following output with a toolbar on the screen:</li>
</ol>
<div><img src="img/7dff8c22-8b81-4214-af63-436438d3ff62.png"/></div>
<ol start="9">
<li>In case the toolbar is not present in the UI, navigate to Visual Studio's Debugging options and enable Show runtime tools in application, as shown in the following screenshot. Also make sure that the other checkboxes (marked here) are already checked:</li>
</ol>
<div><img src="img/3a277773-7867-425b-a4e2-5480e54599eb.png"/></div>
<ol start="10">
<li>When the application is running in debug mode, click on the second button on the runtime toolbar to enable the control selection:</li>
</ol>
<div><img src="img/86f44a73-7714-42fd-9148-0c83e2e33c03.png"/></div>
<ol start="11">
<li>Now, hover over on any control on the application UI, and you will see a red dotted border on the hovered control (just like the <strong>IE Developer Tools</strong>), as shown in the following screenshot:</li>
</ol>
<div><img src="img/d163a9cd-69ad-41bb-b44e-265f61620ebb.png"/></div>
<ol start="12">
<li>Click on any control to open Live Visual Tree inside the Visual Studio editor. In case it is not visible, navigate back to the application UI, and as shown in the following screenshot, click the first button on the runtime toolbar to launch the Live Visual Tree dialog panel:</li>
</ol>
<div><img src="img/abcdcdcf-6f33-4ccb-9a19-0877d78ff662.png"/></div>
<ol start="13">
<li>Alternatively, you can navigate to the Visual Studio 2017 menu Debug | Windows | Live Visual Tree to launch this dialog window.</li>
</ol>
<p> </p>
<ol start="14">
<li>Click on the input box, labeled Password. Live Visual Tree will show you the currently selected visual element within the visual tree. Check out the following screenshot:</li>
</ol>
<div><img src="img/3b7450a6-0aac-4d90-b645-c941565aeba6.png"/></div>
<ol start="15">
<li>Let's click on the button control (labeled Login) and, as shown in the following screenshot, the appropriate Button control will be automatically selected in the Visual Tree:</li>
</ol>
<div><img src="img/d01fa2b3-4c5f-441a-affd-5fb208e69ea8.png"/></div>
<ol start="16">
<li>Now, click on the Login label inside the button. You will see that the <kbd>Button</kbd> control contains a <kbd>TextBlock</kbd> element, which is present inside a <kbd>ContentPresenter</kbd>, wrapped inside a <kbd>Border</kbd> control:</li>
</ol>
<div><img src="img/696637c5-9aa8-4e54-a362-ea1b14cb02bf.png"/></div>
<h2 id="uuid-f1ffe2a8-08f5-4882-b2ed-0f4b9c2a46c4">How it works...</h2>
<p>When you launch a WPF application in debug mode, the floating toolbar also gets loaded on the screen, which allows you to easily select the element in the running instance of the application and inspect its <strong>Visual Element</strong> in <strong>Live Visual Tree</strong>.</p>
<p>The floating toolbar contains four buttons—Go to Live Visual Tree, Enable Selection, Display layout adorners, and Track focused element, as shown in the following screenshot:</p>
<div><img src="img/757ffdbe-5586-46ef-b8f5-9979650a9cd9.png" style=""/></div>
<p>In <kbd>MainWindow.xaml</kbd>, we have added just the <kbd>Button</kbd> control inside <kbd>StackPanel</kbd>, but when you see it on <strong>Live Visual Tree</strong>, you will notice that the <kbd>Button</kbd> control consists of other UI elements to represent the control. It contains a <kbd>Border</kbd>, a <kbd>ContentPresenter</kbd>, and a <kbd>TextBlock</kbd> to visualize the <kbd>Button</kbd> content:</p>
<div><img src="img/c19150fb-9b41-470b-ba1f-b7dc94dd5e83.png"/></div>
<p>Like this, each UI control consists of one or more UI elements that are only visible in a Visual Tree and can be inspected via Live Visual Tree when the debugger is attached to the application.</p>
<p>Please note that this is how the XAML controls actually render in the UI. The more levels of elements you have in a <strong>Visual Tree</strong>, the more performance issues it may hit. Detecting and eliminating unnecessary elements in the Visual Tree is one of the major advantages of a <strong>Live Visual Tree</strong> debugger window.</p>
<p>Visual Studio 2017 also supports modification of the selected element in the Live Visual Tree window, which we will be demonstrating in the next recipe.</p>
<h2 id="uuid-2ccca940-485f-4d40-9fa0-1dba7e043013">There's more...</h2>
<p>You can also ask the XAML debugger to display the layout adorners. While the runtime debugger tool is visible on the application window, click on the third button (as shown in the following screenshot), titled Display layout adorners. It will cause the application window to show horizontal and vertical lines along the bounds of the selected object, so you can see what it aligns to. It also displays rectangles showing the margins:</p>
<div><img src="img/561a81b9-1d04-4ea4-b88c-8bc4b5a946aa.png"/></div>
<p>When enabled, hover over or click any UI element on the application window. You will see the layout adorner for that control, as shown in the following screenshot:</p>
<div><img src="img/9f4dc5f3-ce5b-4a75-9cca-b28b3a6b7271.png"/></div>
<h1 id="uuid-afe80c84-60ec-4281-80e4-9725527fb7cb">Inspecting XAML properties using Live Property Explorer</h1>
<p>In the previous recipe, we learnt about <strong>Live Visual Tree</strong>, which is used to get a real-time view of your running XAML code by inspecting the visual elements. Visual Studio 2015 and above also provide a <strong>Live Property Explorer</strong> window, which allows you to temporarily modify the XAML properties at runtime to see the visual effect.</p>
<p>In this recipe, we will learn about Live Property Explorer. We will use Visual Studio 2017 to demonstrate it.</p>
<h2 id="uuid-1609533a-8543-4bfa-81f5-8021b0ef1950">Getting ready</h2>
<p>Let's begin with a demo project creation. Open your Visual Studio 2017 instance and create a new project named <kbd>CH10.LivePropertyExplorerDemo</kbd>. Make sure to select the WPF application template during project creation.</p>
<h2 id="uuid-4aed50ac-ed8e-4260-9cf2-0c0ccd03dd9f">How to do it...</h2>
<p>Follow these steps to design our application UI with a simple button and then utilize <strong>Live Property Explorer</strong> to view and modify the XAML properties at runtime:</p>
<ol>
<li>From Solution Explorer, open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Replace the content of the XAML with the following code to have a basic <kbd>Button</kbd> with default style:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH10.LivePropertyExplorerDemo.MainWindow" 
         
         
        Title="Live Property Explorer Demo" Height="150" Width="400"&gt; 
    &lt;Grid&gt; 
        &lt;Button x:Name="myButton" 
                Content="Click here"/&gt; 
    &lt;/Grid&gt; 
&lt;/Window&gt; </pre>
<ol start="3">
<li>Let's run the application. You will see that the button automatically arranges itself to cover the entire application. This is because we have placed the button inside a <kbd>Grid</kbd> and haven't specified its dimensions and margins, as shown in the following screenshot:</li>
</ol>
<div><img src="img/1fa1a4a0-fd85-4ba4-8143-6c19f5c3ace5.png" style=""/></div>
<ol start="4">
<li>Now, close the application and run it in debug mode.</li>
<li>Once the application launches in debug mode, navigate to the Visual Studio menu—Debug | Windows | Live Property Explorer to open said explorer window.</li>
<li>The Live Property Explorer window will look as follows:</li>
</ol>
<div><img src="img/9961fcd4-f963-4cd8-b227-cbb48a327975.png" style=""/></div>
<ol start="7">
<li>As you can see in the preceding screenshot, Live Property Explorer is showing the properties of the selected <kbd>Button</kbd> control, named <kbd>myButton</kbd>. You will find that most of the properties are disabled. This is because they are either inherited from implicit/explicit styles or have default values.</li>
<li>To experiment with the UI element properties, you should modify the properties inside the Local panel.</li>
<li>To override an existing property value of the selected element (in our case, it is <kbd>myButton</kbd>) from Live Visual Tree, click on the New button, as shown in the following screenshot:</li>
</ol>
<div><img src="img/fa9bb085-0f10-482f-8c7b-bea94c9638d0.png"/></div>
<ol start="10">
<li>This will add a drop-down list in the panel, where you will be able to select the property that you would like to modify. Let's select Width from the property list:</li>
</ol>
<div><img src="img/b20e3581-8413-4bb1-b086-dd6401cb91a1.png" style=""/></div>
<ol start="11">
<li>When you select the property, the panel will get populated with the appropriate property boxes to fill it. Enter <kbd>120</kbd> as the value against the Width property.</li>
<li>Notice the running application window. The <kbd>Button</kbd> control in the window will be automatically resized to a width of 120 pixels.</li>
</ol>
<p> </p>
<ol start="13">
<li>Observe the actual element in the XAML designer window. The change was not performed in the XAML code:</li>
</ol>
<div><img src="img/7a71d29e-bcd4-4a27-8f85-0627aabd7a6c.png"/></div>
<ol start="14">
<li>Let's modify a few more properties of the <kbd>Button</kbd> control. Click on the New button and select <kbd>Height</kbd> from the property list. Set its value to <kbd>30</kbd>.</li>
<li>Click on the New button once again and select <kbd>Background</kbd> from the property list. Now enter <kbd>Red</kbd> as its value. You can alternatively enter <kbd>#FFFF0000</kbd> to apply a red color as the button background.</li>
<li>Once you perform these changes, look at the running application window. The new height and the background color have already been applied to the button:</li>
</ol>
<div><img src="img/31e040d8-a933-4e68-a14e-c70ccdbca665.png" style=""/></div>
<ol start="17">
<li>Let's change a few more properties. Add the <kbd>FontSize</kbd> and <kbd>Foreground</kbd> properties in your local property list. Set their values to <kbd>16</kbd> and <kbd>White</kbd>, respectively.</li>
<li>Check the application window for the changes. It will now look as follows:</li>
</ol>
<div><img src="img/65878958-94b4-47d9-a8a0-bd8ba688afa3.png" style=""/></div>
<h2 id="uuid-33f98308-fc5b-457d-89ea-3fc11cdd2009">How it works...</h2>
<p><strong>Live Property Explorer</strong> only gives you a preview of what you want to modify in runtime. Based on that, you can change the original UI in the XAML view or designer view for permanent changes.</p>
<p>If you end the debugging session, the changes that you performed in the Live Property Explorer window won't be saved and you will lose those changes. When you restart the application, you will see fresh values as per the default.</p>
<p>This is often useful when you want to see the changes live at runtime for any element inside the Visual Tree.</p>
<h2 id="uuid-bb70a506-f964-47bf-8678-dfae884d6df1">There's more...</h2>
<p>To permanently set the properties of any UI element while the application is running in debug mode, use either the XAML code view or the XAML designer view. The running application will automatically get the update of the style changes.</p>
<p>To modify the XAML code while the application is running in debug mode, make sure that the Enable UI Debugging Tools for XAML and the Enable XAML Edit and Continue settings are enabled (checked) in the Visual Studio Options window, under the Debugging | General section.</p>
<p>Let's run the application once again in debug mode and start modifying the control properties directly in the XAML view. Once you have made some changes, check the running application and you will see that it already has been updated with the modified data:</p>
<div><img src="img/47153405-e910-4b93-921c-3a2e2e324dd5.png"/></div>
<p>Here's the modified XAML code of the button, which we used in the preceding screenshot. When applied, it will result in the addition of a nice linear gradient color to the button background:</p>
<pre style="padding-left: 60px">&lt;Button x:Name="myButton" 
        Content="Click here" 
        Height="30" 
        Width="200" 
        FontSize="18" 
        FontWeight="Bold" 
        Foreground="Red"&gt; 
    &lt;Button.Background&gt; 
        &lt;LinearGradientBrush&gt; 
            &lt;GradientStop Color="#FFFF5454"  
                          Offset="0"/&gt; 
            &lt;GradientStop Color="#FFFFF754"  
                          Offset="0.3"/&gt; 
            &lt;GradientStop Color="#FFFFF754"  
                          Offset="0.8"/&gt; 
            &lt;GradientStop Color="#FFFF5454"  
                          Offset="1"/&gt; 
        &lt;/LinearGradientBrush&gt; 
    &lt;/Button.Background&gt; 
&lt;/Button&gt; </pre>
<h1 id="uuid-0a8d7801-d477-4c31-89df-8a0e1e79b6c7">Updating the UI from a non-UI thread</h1>
<p>In WPF, the UI is managed by a single thread, called a <strong>UI thread</strong>, which that creates an instance of a window and processes the UI messages for that window. This is known as <strong>message pumping</strong>.</p>
<p>When the UI thread is performing a lot of operations, it enters in to a wait state and stops processing further UI messages. This causes the application to enter <em>Not Responding</em> mode, which is commonly known as <strong>UI freezing</strong>.</p>
<p>To resolve this issue, you need to offload that long running operation into another thread. This keeps the UI thread free and allows it to perform the UI updates and stay responsive.</p>
<p>In this recipe, we will learn how to offload a long running process into a separate thread in a thread pool and perform the UI updates once it completes the execution.</p>
<h2 id="uuid-cbf5d5ff-4c5e-457e-90d5-0c29764b2e50">Getting ready</h2>
<p>Let's begin by creating a WPF project. Name it <kbd>CH10.ThreadingDemo1</kbd>. Make sure to select the right WPF App template during project creation.</p>
<h2 id="uuid-76967625-9c87-4625-9ab4-86bb3e7cb600">How to do it...</h2>
<p>We will create a simple application that will count odd and even numbers in a numeric range. This will be done on a non-UI thread and once the result is available we will update the UI. Follow these steps:</p>
<ol>
<li>From Solution Explorer, open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Replace the existing <kbd>Grid</kbd> with the following simple user interface to provide the numeric range, and a button to calculate and display the result:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid Margin="10"&gt; 
    &lt;Grid.RowDefinitions&gt; 
        &lt;RowDefinition Height="Auto"/&gt; 
        &lt;RowDefinition Height="Auto"/&gt; 
        &lt;RowDefinition Height="Auto"/&gt; 
    &lt;/Grid.RowDefinitions&gt; 
    &lt;StackPanel Orientation="Horizontal" 
                Grid.Row="0" 
                Margin="4"&gt; 
        &lt;TextBlock Text="From:" 
                   Margin="4"/&gt; 
        &lt;TextBox x:Name="fromValue" 
                 Text="100" 
                 Width="100" 
                 MaxLength="10" 
                 Margin="4"/&gt; 
         
        &lt;TextBlock Text="To:" 
                   Margin="4"/&gt; 
        &lt;TextBox x:Name="toValue" 
                 Text="1000000000" 
                 Width="100" 
                 MaxLength="10" 
                 Margin="4"/&gt; 
 
        &lt;Button x:Name="calculateButton" 
                Content="Calculate" 
                Margin="4" 
                Padding="8 2" 
                Click="OnCalculateClicked"/&gt; 
    &lt;/StackPanel&gt; 
 
    &lt;TextBlock x:Name="oddResultBlock" 
               Grid.Row="1" 
               Text="Total odd numbers: 0" 
               Margin="4"/&gt; 
 
    &lt;TextBlock x:Name="evenResultBlock" 
               Grid.Row="2" 
               Text="Total even numbers: 0" 
               Margin="4"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="3">
<li>Navigate to the <kbd>MainWindow.xaml.cs</kbd> file and add the following two member-variables to store the total count of odd and even numbers:</li>
</ol>
<pre style="padding-left: 90px">private int totalOdd = 0; 
private int totalEven = 0;</pre>
<ol start="4">
<li>We will now create a method to calculate the odd and even numbers. Inside the <kbd>MainWindow</kbd> class, create a method named <kbd>CalculateOddEven</kbd>, and implement the code block as shown in this following code snippet:</li>
</ol>
<pre style="padding-left: 90px">private void CalculateOddEven(int from, int to) 
{ 
    for (int i = from; i &lt;= to; i++) 
    { 
        if (i % 2 == 0) { totalEven++; } 
        else { totalOdd++; } 
    } 
} </pre>
<ol start="5">
<li>Now, we need to invoke the call. Let's implement the button click event <kbd>OnCalculateClicked</kbd> to call the <kbd>CalculateOddEven</kbd> method and display the result:</li>
</ol>
<pre style="padding-left: 90px">private void OnCalculateClicked(object sender,  
                        RoutedEventArgs e) 
{ 
    totalOdd = 0; 
    totalEven = 0; 
 
    if (int.TryParse(fromValue.Text, out int from) &amp;&amp; 
        int.TryParse(toValue.Text, out int to)) 
    { 
        calculateButton.IsEnabled = false; 
 
        CalculateOddEven(from, to); 
 
        oddResultBlock.Text = "Total odd numbers: " +  
                               totalOdd; 
        evenResultBlock.Text = "Total even numbers: " +  
                                totalEven; 
        calculateButton.IsEnabled = true; 
    } 
}</pre>
<ol start="6">
<li>Run the application and click on the Calculate button. The UI will freeze for some time while the long running operation is in-progress, as it finds out the odd and even numbers between the <kbd>100 - 1000000000</kbd> range. Once the calculation completes, it will unfreeze the UI and display the result:</li>
</ol>
<div><img src="img/c0636500-0d8d-47e8-acb0-b7bb41ad2afd.png"/></div>
<ol start="7">
<li>To resolve this issue, we should move the long running process to a different thread so that the UI thread keeps responding. We will be using a thread pool to move the process to a different thread. You can also perform this by creating a new <kbd>Thread</kbd> instance or by using <kbd>Task</kbd>.</li>
<li>In this example, we will be using thread pool. This can be done by calling <kbd>ThreadPool.QueueUserWorkItem</kbd>, as shown in the following code snippet:</li>
</ol>
<pre style="padding-left: 90px">ThreadPool.QueueUserWorkItem(_ =&gt; 
{ 
    CalculateOddEven(from, to); 
}); </pre>
<ol start="9">
<li>Now, we need to update the UI once the operation gets completed. This can't be done outside the <kbd>ThreadPool.QueueUserWorkItem</kbd> block, as the operation will run in a different thread. The same can't be done directly inside the <kbd>ThreadPool.QueueUserWorkItem</kbd> block too, as the update should be performed in the UI thread. For this to work, the <kbd>Dispatcher.BeginInvoke</kbd> block can be used within the <kbd>ThreadPool.QueueUserWorkItem</kbd> block, as shown in the following code snippet:</li>
</ol>
<pre style="padding-left: 90px">ThreadPool.QueueUserWorkItem(_ =&gt; 
{ 
    CalculateOddEven(from, to); 
 
    Dispatcher.BeginInvoke(new Action(() =&gt; 
    { 
        oddResultBlock.Text = "Total odd numbers: " +  
                               totalOdd; 
        evenResultBlock.Text = "Total even numbers: " +  
                                totalEven; 
        calculateButton.IsEnabled = true; 
    })); 
}); </pre>
<ol start="10">
<li>Let's run the application once again. Click on the Calculate button. You will observe that the UI is responsive while the long running operation is in progress.</li>
</ol>
<h2 id="uuid-f325a4eb-3b12-4d3b-9745-694f3e92e3b9">How it works...</h2>
<p>Each and every element in WPF inherits from <kbd>DispatcherObject</kbd>, and thus, the UI thread is always associated with <kbd>System.Windows.Threading.Dispatcher</kbd>. This is the reason why the <kbd>Dispatcher</kbd> object can be accessed any time by using the <kbd>DispatcherObject.Dispatcher</kbd> property.</p>
<p><kbd>ThreadPool.QueueUserWorkItem</kbd> causes a delegate to execute on the CLRs thread pool. Thus, the operation performed within that delegate never executes on the UI thread.</p>
<p>Once the operation completes, and you need to update the UI, you must update this from the UI thread. The call to <kbd>Dispatcher.BeginInvoke</kbd> causes the delegate to run on the UI thread and make the necessary changes to the UI.</p>
<p>A point to note is that the dispatcher is also accessible from the UI thread, using the static property <kbd>Dispatcher.CurrentDispatcher</kbd>.</p>
<h2 id="uuid-613e6b6c-dfab-483d-8a57-818c5a3d8961">There's more...</h2>
<p>There are two kinds of invocations by <kbd>Dispatcher</kbd>—<kbd>BeginInvoke</kbd> and <kbd>Invoke</kbd>. We have already seen the uses of <kbd>BeginInvoke</kbd>, which basically invokes <kbd>delegate</kbd> and returns to perform other operations while <kbd>delegate</kbd> is still running on the UI thread.</p>
<p>On the other side, the <kbd>Invoke</kbd> operation does not return until <kbd>delegate</kbd> completes its execution on the UI thread.</p>
<div><kbd>BeginInvoke</kbd> is always preferable unless there is a specific reason to wait for the UI operation to complete.</div>
<p><kbd>Dispatcher</kbd> maintains a queue of requests that need to be processed on the UI thread. This is basically handled by setting <kbd>DispatcherPriority</kbd>. The default priority is <kbd>DispatcherPriority.Normal</kbd>, but you can set a lower or a higher priority based on the importance of the operation.</p>
<h1 id="uuid-9a43fd5c-dc81-487f-9aa6-f7b69eff8661">Adding cancelation support to long running threads</h1>
<p>When you execute a long running process on a different thread, to keep the UI responsive during the operation, you may want to provide a functionality to cancel the operation. This can be done on an on-demand basis.</p>
<p>In this recipe, we will learn how to add cancellation support to the existing long running operation that we have built in the previous recipe.</p>
<h2 id="uuid-d4a7cc42-56c4-4577-aed8-e77f1e72a2d7">Getting ready</h2>
<p>We will be using the same example that we used in the previous recipe. You can copy the entire <kbd>CH10.ThreadingDemo1</kbd> project folder and give it a new name, <kbd>CH10.ThreadingDemo2</kbd>. Launch Visual Studio and open the new (<kbd>CH10.ThreadingDemo2</kbd>) project inside it.</p>
<h2 id="uuid-a1a4ace6-ee04-412e-b66c-89f0a5677c96">How to do it...</h2>
<p>Follow these steps to update the existing project and to have cancellation support during the long running process:</p>
<ol>
<li>Navigate to the <kbd>MainWindow.xaml</kbd> file and modify the UI to have a <kbd>Cancel</kbd> button in it. Add the following button control inside <kbd>StackPanel</kbd>, and label it as <kbd>Cancel</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button x:Name="cancelButton" 
        Content="Cancel" 
        IsEnabled="False" 
        Margin="4" 
        Padding="8 2" 
        Click="OnCancelClicked"/&gt; </pre>
<ol start="2">
<li>Make sure to set its <kbd>IsEnabled</kbd> property to <kbd>False</kbd>.</li>
<li>Now, navigate to the <kbd>MainWindow.xaml.cs</kbd> file and add the following member variable inside the class:</li>
</ol>
<pre style="padding-left: 90px">private CancellationTokenSource tokenSource = null; </pre>
<ol start="4">
<li>On the <kbd>Cancel</kbd> button click, we need to cancel the running operation. Let's modify the <kbd>OnCancelClicked</kbd> event to perform the same as the following code snippet:</li>
</ol>
<pre style="padding-left: 90px">private void OnCancelClicked(object sender,  
                             RoutedEventArgs e) 
{ 
    if (tokenSource != null) 
    { 
        tokenSource.Cancel(); 
        tokenSource = null; 
    } 
} </pre>
<ol start="5">
<li>Let's navigate to the <kbd>CalculateOddEven</kbd> method and modify it to accept a third parameter of type <kbd>CancellationToken</kbd>:</li>
</ol>
<pre style="padding-left: 90px">private void CalculateOddEven(int from,  
                              int to,  
                              CancellationToken token)</pre>
<ol start="6">
<li>Inside the <kbd>for</kbd> loop of the <kbd>CalculateOddEven</kbd> method, check whether the <kbd>CancellationToken.IsCancellationRequested</kbd> is <kbd>true</kbd>, and if so, return immediately after setting the <kbd>totalOdd</kbd> and <kbd>totalEven</kbd> values to <kbd>-1</kbd>:</li>
</ol>
<pre style="padding-left: 90px">for (int i = from; i &lt;= to; i++) 
{ 
    if (token.IsCancellationRequested) 
    { 
        totalOdd = -1; 
        totalEven = -1; 
        return; 
    } </pre>
<ol start="7">
<li>For reference, here's the modified code of the <kbd>CalculateOddEven</kbd> method implementation:</li>
</ol>
<pre style="padding-left: 90px">private void CalculateOddEven(int from,  
                              int to,  
                              CancellationToken token) 
{ 
    for (int i = from; i &lt;= to; i++) 
    { 
        if (token.IsCancellationRequested) 
        { 
            totalOdd = -1; 
            totalEven = -1; 
            return; 
        } 
 
        if (i % 2 == 0) { totalEven++; } 
        else { totalOdd++; } 
    } 
} </pre>
<ol start="8">
<li>On <kbd>OnCalculateClicked</kbd> event implementation, we need to perform some changes. First create the instance of <kbd>CancellationTokenSource</kbd> and assign it to the <kbd>tokenSource</kbd> variable.</li>
<li>Then, pass the instance to the <kbd>CalculateOddEven</kbd> method as the third parameter value.</li>
</ol>
<p> </p>
<ol start="10">
<li>Then, inside the <kbd>Dispatcher.BeginInvoke</kbd> call, modify the code to display Operation canceled! based on the value of <kbd>totalOdd</kbd> and <kbd>totalEven</kbd> variables. Display the message only if either of them is <kbd>-1</kbd>. Here's the complete implementation:</li>
</ol>
<pre style="padding-left: 90px">tokenSource = new CancellationTokenSource(); 
ThreadPool.QueueUserWorkItem(_ =&gt; 
{ 
    CalculateOddEven(from, to, tokenSource.Token); 
 
    Dispatcher.BeginInvoke(new Action(() =&gt; 
    { 
        if (totalOdd &lt; 0 || totalEven &lt; 0) 
        { 
            oddResultBlock.Text = "Operation canceled!"; 
            evenResultBlock.Text = string.Empty; 
        } 
        else 
        { 
            oddResultBlock.Text = "Total odd numbers: " +  
                                   totalOdd; 
            evenResultBlock.Text = "Total even numbers: " +  
                                    totalEven; 
        } 
 
        calculateButton.IsEnabled = true; 
        cancelButton.IsEnabled = false; 
    })); 
}); </pre>
<ol start="11">
<li>Once done, let's run the application. Click the Calculate button to start the process in a separate thread in the thread pool:</li>
</ol>
<div><img src="img/c47ebde2-9a39-4ce8-85bb-0d27be0ae523.png"/></div>
<ol start="12">
<li>While the operation is in progress, click the Cancel button. You will see that the process immediately stops and the Operation canceled! message gets displayed in the UI:</li>
</ol>
<div><img src="img/05979e0a-608b-4706-a2dc-ddf3ff9ce364.png"/></div>
<ol start="13">
<li>Let's click on the <kbd>Calculate</kbd> button once again and wait until the process ends. What can you see now? It displays the total count of odd and even numbers on the UI.</li>
</ol>
<h2 id="uuid-80284b56-563c-48b5-a24c-21513c929102">How it works...</h2>
<p><kbd>CancellationTokenSource</kbd> represents a logical operation that can be canceled. The <kbd>Token</kbd> property of <kbd>CancellationTokenSource</kbd> provides the token object that provides the part of the logical operation.</p>
<p>Whenever the <kbd>Cancel()</kbd> method gets called on the <kbd>CancellationTokenSource</kbd> object, all distributed tokens from that source get their <kbd>IsCancellationRequested</kbd> property set as <kbd>true</kbd>.</p>
<p>In our example, the <kbd>for</kbd> loop inside our <kbd>CalculateOddEven</kbd> method polls the <kbd>IsCancellationRequested</kbd> property and fills the <kbd>totalOdd</kbd> and <kbd>totalEven</kbd> member variables with <kbd>-1</kbd>, which can be used to understand that a cancellation call was performed. Based on that value, the Operation canceled! message gets displayed on the screen.</p>
<h1 id="uuid-9258f714-98ca-4b95-a2d4-33c1ffd0a94a">Using the background worker component</h1>
<p>In the previous recipes, we used thread pool to perform long running operations in a different thread. From there, we had to update the UI by marshalling the code to the UI thread, which required additional work.</p>
<p>To overcome this explicit thread pooling and the marshalling of the UI updation on the UI thread, we can use the <kbd>System.ComponentModel.BackgroundWorker</kbd> class. It provides automatic management of long running operations on a background thread.</p>
<p>In this recipe, we will use that <kbd>BackgroundWorker</kbd> to do the asynchronous operations without blocking the UI thread.</p>
<h2 id="uuid-c28c655e-fb65-43e8-b010-65f4890b5ee3">Getting ready</h2>
<p>We will be using the same example that we have used in previous recipes. You can copy the entire <kbd>CH10.ThreadingDemo1</kbd> project folder and create a new one with the name <kbd>CH10.ThreadingDemo3</kbd>. Launch Visual Studio and open the new project.</p>
<h2 id="uuid-ee25bd69-fb5d-4d9c-a7d5-883fef504bc4">How to do it...</h2>
<p>Follow these steps to use a background worker, to perform the long running process, and to count the odd and even numbers within a range:</p>
<ol>
<li>From Solution Explorer, navigate to the <kbd>MainWindow.xaml.cs</kbd> file.</li>
<li>Add the following <kbd>using</kbd> namespace—<kbd>System.ComponentModel</kbd>, so that we can use the <kbd>BackgroundWorker</kbd> class.</li>
<li>Inside the <kbd>OnCalculateClicked</kbd> event, instead of calling <kbd>ThreadPool</kbd> to execute the operation, create an instance of the <kbd>BackgroundWorker</kbd> class.</li>
<li>Register the worker events <kbd>DoWork</kbd> and <kbd>RunWorkerCompleted</kbd>.</li>
<li>Call the <kbd>RunWorkerAsync</kbd> method of the background worker by passing the numeric range as an argument. The argument accepts objects, hence, we will use <kbd>Tuple&lt;int, int&gt;</kbd> as the data type for simplicity. The complete code looks as follows:</li>
</ol>
<pre style="padding-left: 90px">private void OnCalculateClicked(object sender,  
  RoutedEventArgs e) 
{ 
    totalOdd = 0; 
    totalEven = 0; 
 
    if (int.TryParse(fromValue.Text, out int from) &amp;&amp; 
        int.TryParse(toValue.Text, out int to)) 
    { 
        calculateButton.IsEnabled = false; 
 
        var worker = new BackgroundWorker(); 
        worker.DoWork += OnWorker_DoWork; 
        worker.RunWorkerCompleted +=  
                        OnWorker_WorkCompleted; 
        worker.RunWorkerAsync(new Tuple&lt;int, int&gt;(from, to)); 
    } 
} </pre>
<ol start="6">
<li>Let's modify the <kbd>OnWorker_DoWork</kbd> event implementation to extract the argument first. Then, call the long running method (<kbd>CalculateOddEven</kbd>) by passing the values extracted from the argument:</li>
</ol>
<pre style="padding-left: 90px">private void OnWorker_DoWork(object sender,  
   DoWorkEventArgs e) 
{ 
    var argument = (Tuple&lt;int, int&gt;)e.Argument; 
    CalculateOddEven(argument.Item1, argument.Item2); 
} </pre>
<ol start="7">
<li>In the <kbd>OnWorker_WorkCompleted</kbd> event implementation, release the <kbd>BackgroundWorker</kbd> instance and then update the UI based on the values. Here's the code for your reference:</li>
</ol>
<pre style="padding-left: 90px">private void OnWorker_WorkCompleted(object sender,  
 RunWorkerCompletedEventArgs e) 
{ 
    if (sender is BackgroundWorker worker) 
    { 
        worker.RunWorkerCompleted -=  
         OnWorker_WorkCompleted; 
        worker.DoWork -= OnWorker_DoWork; 
        worker = null; 
    } 
 
    oddResultBlock.Text = "Total odd numbers: " +  
      totalOdd; 
    evenResultBlock.Text = "Total even numbers: " +  
      totalEven; 
 
    calculateButton.IsEnabled = true; 
}</pre>
<ol start="8">
<li>Once this is done, let's run the application. You will see the same application UI as we saw in the first example:</li>
</ol>
<div><img src="img/6141192f-8e70-4c3a-8849-212faeb6e121.png"/></div>
<ol start="9">
<li>Click on the <kbd>Calculate</kbd> button. You will observe that the application is responding while the execution is happening in the background worker process.</li>
<li>Once the execution completes, it displays the result in the UI.</li>
</ol>
<h2 id="uuid-c5f5f2fe-0291-4e57-8071-df3155a5fff9">How it works...</h2>
<p><kbd>BackgroundWorker</kbd> exposes events to coordinate the work. When you call the <kbd>RunWorkerAsync</kbd> method, the <kbd>DoWork</kbd> event is raised on the thread pool thread. You can pass an optional <kbd>Argument</kbd> to the <kbd>RunWorkerAsync</kbd> method, which can be retrieved from the <kbd>DoWorkEventArgs.Argument</kbd> property inside the <kbd>DoWork</kbd> event handler.</p>
<p>As the <kbd>DoWork</kbd> event handler executes on a thread pool thread, accessing UI controls inside the <kbd>DoWork</kbd> handler will throw <kbd>Exception</kbd>. For this reason, pass the value from the UI as an argument to the <kbd>RunWorkerAsync</kbd> method.</p>
<p>When the <kbd>DoWork</kbd> event handler completes its execution, <kbd>BackgroundWorker</kbd> raises the <kbd>RunWorkerCompleted</kbd> event. This runs on the UI thread, and thus, you can perform UI operations from this event handler. If you have passed any value from the <kbd>DoWork</kbd> handler, you can retrieve it here from the <kbd>RunWorkerCompletedEventArgs.Result</kbd> property.</p>
<h2 id="uuid-994e4b62-aa27-4b9a-8b3a-a00f9edcc617">There's more...</h2>
<p>To show the current progress indication of the long running background operation, you can raise the <kbd>ProgressChanged</kbd> event on the worker process and update the UI directly from here. The <kbd>ProgressChanged</kbd> handler runs in the UI thread and occurs when <kbd>BackgroundWorker.ReportProgress(System.Int32)</kbd> is called from the <kbd>DoWork</kbd> handler. For this to work, make sure that you have set the <kbd>WorkerReportsProgress</kbd> property of the worker to <kbd>true</kbd>.</p>
<p>You can also check whether <kbd>BackgroundWorker</kbd> is running an asynchronous operation. The <kbd>IsBusy</kbd> property will return <kbd>true</kbd> if it is running the background operation.</p>
<p>In case you want to cancel a running background worker, you can call the <kbd>CancelAsync()</kbd> method of the worker to request cancellation of a pending background operation. If <kbd>BackgroundWorker.WorkerSupportsCancellation</kbd> is set as <kbd>false</kbd>, it will throw <kbd>InvalidOperationException</kbd>.</p>
<h1 id="uuid-0da22ae5-2e14-4317-9097-014ab05afbb1">Using a timer to periodically update the UI</h1>
<p>It is often require to update a portion of the user interface periodically. In that case, a timer object is beneficial to keep the UI refreshed. For example, in your application, you may want to show the current time at some part of the UI. For this, you can use a timer to periodically update the UI without the need to create a different thread.</p>
<p>The <kbd>System.Windows.Threading.DispatcherTimer</kbd> class can be used to integrate into the <kbd>Dispatcher</kbd> queue, and can process at a specified interval of time and at a specified priority.</p>
<p>In this recipe, we will use the <kbd>DispatcherTimer</kbd> class to implement a timer, which will execute its subscribed <kbd>Tick</kbd> event each time the specified <kbd>Interval</kbd> is met.</p>
<h2 id="uuid-bf411a4f-9e8b-46cc-851c-73fa5b4d7167">Getting ready</h2>
<p>Open Visual Studio and create a new WPF application project. Name it <kbd>CH10.DispatcherTimerDemo</kbd>.</p>
<h2 id="uuid-adcec360-442c-40d2-89d6-8ed4609b49a4">How to do it...</h2>
<p>Follow these steps to create a digital clock experience with a timer:</p>
<ol>
<li>From Solution Explorer, navigate to the <kbd>MainWindow.xaml</kbd> page.</li>
<li>Divide the default <kbd>Grid</kbd> into three rows, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="*"/&gt; 
    &lt;RowDefinition Height="20"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
&lt;/Grid.RowDefinitions&gt; </pre>
<ol start="3">
<li>Add a <kbd>TextBlock</kbd> control at the <kbd>Grid.Row="0"</kbd> position and align it to the center:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBlock x:Name="clock" 
           Grid.Row="0" 
           Text="00:00:00" 
           FontSize="80" 
           HorizontalAlignment="Center" 
           VerticalAlignment="Center"/&gt; </pre>
<ol start="4">
<li>Add a <kbd>StackPanel</kbd> at <kbd>Grid.Row="2"</kbd> and insert two buttons inside it. Name the buttons <kbd>startButton</kbd> and <kbd>stopButton</kbd>. Also, register the <kbd>Click</kbd> events for both the buttons as <kbd>OnStartTimer</kbd> and <kbd>OnStopTimer</kbd>, respectively:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Grid.Row="2" 
            Margin="10" 
            Orientation="Horizontal" 
            HorizontalAlignment="Center" 
            VerticalAlignment="Center"&gt; 
    &lt;Button x:Name="startButton" 
            Content="Start" 
            Margin="4" 
            Height="26" 
            Width="100" 
            Click="OnStartTimer"/&gt; 
    &lt;Button x:Name="stopButton" 
            Content="Stop" 
            Margin="4" 
            Height="26" 
            Width="100" 
            IsEnabled="False" 
            Click="OnStopTimer"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="5">
<li>Now, navigate to <kbd>MainWindow.xaml.cs</kbd> to add the code behind the logic.</li>
<li>First, add the following namespaces in the class file:</li>
</ol>
<pre style="padding-left: 90px">using System; 
using System.Windows; 
using System.Windows.Threading; </pre>
<ol start="7">
<li>Inside the class, declare a private member variable (<kbd>dispatcherTimer</kbd>) of type <kbd>DispatcherTimer</kbd>:</li>
</ol>
<pre style="padding-left: 90px">private DispatcherTimer dispatcherTimer = null; </pre>
<ol start="8">
<li>Inside the constructor of the class, let's create the instance of <kbd>DispatcherTimer</kbd> and raise its <kbd>Tick</kbd> event to trigger after every <kbd>1</kbd> second of interval. Here's the code:</li>
</ol>
<pre style="padding-left: 90px">public MainWindow() 
{ 
    InitializeComponent(); 
 
    dispatcherTimer = new DispatcherTimer(); 
    dispatcherTimer.Interval = TimeSpan.FromSeconds(1.0); 
    dispatcherTimer.Tick += OnTimerTick; 
} </pre>
<ol start="9">
<li>Now, inside the <kbd>Tick</kbd> event implementation, set the <kbd>Text</kbd> property of the <kbd>TextBlock</kbd> control (<kbd>clock</kbd>) to the current time in <kbd>hh:mm:ss</kbd> format:</li>
</ol>
<pre style="padding-left: 90px">private void OnTimerTick(object sender,  
 EventArgs e) 
{ 
    clock.Text = DateTime.Now.ToString("hh:mm:ss"); 
} </pre>
<ol start="10">
<li>When a user clicks on the Start button, the <kbd>OnStartTimer</kbd> event handler will fire. Inside it, let's start the timer by calling the <kbd>Start()</kbd> method on the <kbd>dispatcherTimer</kbd> instance. Alternatively, you can also set the <kbd>dispatcherTimer.IsEnabled</kbd> property to <kbd>true</kbd> to start the timer:</li>
</ol>
<pre style="padding-left: 90px">private void OnStartTimer(object sender,  
 RoutedEventArgs e) 
{ 
    if (dispatcherTimer != null) 
    { 
        dispatcherTimer.Start(); 
 
        startButton.IsEnabled = false; 
        stopButton.IsEnabled = true; 
    } 
} </pre>
<ol start="11">
<li>When the handler <kbd>OnStopTimer</kbd> raises, on a click of the Stop button we will call the <kbd>Stop()</kbd> method of the <kbd>dispatcherTimer</kbd> instance. Here, also, you can set the <kbd>dispatcherTimer.IsEnabled</kbd> property as an alternate method to stop the timer, but in this case, you will have to set it as <kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 90px">private void OnStopTimer(object sender,  
 RoutedEventArgs e) 
{ 
    if (dispatcherTimer != null) 
    { 
        dispatcherTimer.Stop(); 
 
        startButton.IsEnabled = true; 
        stopButton.IsEnabled = false; 
    } 
} </pre>
<ol start="12">
<li>Now run the application. You will see the following output on the screen:</li>
</ol>
<div><img src="img/d7bd357d-0de7-4267-9242-6315d91c6609.png"/></div>
<ol start="13">
<li>Observe the text in the UI, where it is being displayed as <kbd>00:00:00</kbd>. Now click on the Start button. This will now change the text to the current time of your system, and it will refresh after every second:</li>
</ol>
<div><img src="img/b1363bc2-a4ec-4d61-a0d7-5af1c06c449b.png"/></div>
<ol start="14">
<li>As the time is ticking on the UI, after every second of interval, click on the Stop button. This will cause the running timer on the screen to stop.</li>
<li>Clicking on the Start button again will start the timer and show the current time on the screen. The time displayed on the UI will refresh after every second.</li>
</ol>
<h2 id="uuid-fadf4154-8340-4fa8-a3ef-62084bc75d91">How it works...</h2>
<p>When you use a <kbd>DispatcherTimer</kbd> object, it represents a timer that is bound to the UI thread. The <kbd>Interval</kbd> property of the <kbd>DispatcherTimer</kbd> class indicates the period of the timer for the <kbd>Tick</kbd> event to raise, and continues ticking until explicitly stopped.</p>
<p>To start the timer, you can call its <kbd>Start()</kbd> method, or set the <kbd>IsEnabled</kbd> property to <kbd>true</kbd>. Similarly, to stop a timer, you can call the <kbd>Stop()</kbd> method, or set the <kbd>IsEnabled</kbd> property to <kbd>false</kbd>.</p>
<p>Never perform any lengthy operations in the <kbd>Tick</kbd> event, as it runs on the UI thread. Long running operations may block the UI from responding.</p>


            

            
        
    </body></html>