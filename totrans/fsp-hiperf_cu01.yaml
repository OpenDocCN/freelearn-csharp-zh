- en: Chapter 1. Performing Common Optimizations in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s quite well-known today that F# has been a first class citizen, a built-in
    part of programming language support in Visual Studio, starting from Visual Studio
    2010\. F# is a programming language that has its own unique trait: it is a functional
    programming language and at the same time it has object-oriented programming (OOP)
    support. F# from the start has run on .NET, although we can also run F# on cross-platform,
    such as Android (using Mono).'
  prefs: []
  type: TYPE_NORMAL
- en: Although F# mostly runs faster than C# or VB when doing computations, its own
    performance characteristics and some not so obvious bad practices and subtleties
    may have led to performance bottlenecks. The bottlenecks may or may not be faster
    than the C#/VB counterparts, although some of the bottlenecks may share the same
    performance characteristics, such as the use of .NET APIs. The main goal of this
    book is to identify performance problems in F#, measuring and also optimizing
    F# code to run more efficiently, while also maintaining the functional programming
    style as appropriately as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A basic knowledge of F# (including the functional programming concept and basic
    OOP) is required as a prerequisite to start understanding the performance problems
    and the optimization of F#.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to define F# performance characteristics and at the same
    time to measure them, but understanding the mechanics of running F# code, especially
    on top of .NET, is crucial and is also a part of the performance characteristics
    itself. This includes other aspects of approaches to identify concurrency problems
    and language constructs. This chapter describes the optimization of F# code and
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the nature of F# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of common bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly misunderstood concurrency problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of tooling in .NET including Visual Studio to help understanding the
    running code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediate testing of F# code in F# interactive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to debugging in F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the nature of F# code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the nature of F# code is very crucial and is a definitive prerequisite
    before we begin to measure how long it runs and its effectiveness. We can measure
    a running F# code by running time, but to fully understand why it may run slow
    or fast, there are some basic concepts we have to consider first.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive more into this, we must meet the basic requirements and setup.
  prefs: []
  type: TYPE_NORMAL
- en: After the requirements have been set, we need to put in place the environment
    setting of Visual Studio 2015\. We have to set this because we need to maintain
    the consistency of the default setting of Visual Studio. The setting should be
    set to **General**.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Tools** menu from Visual Studio's main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Import and Export Settings...** and the **Import and Export Settings
    Wizard** screen is displayed:![Understanding the nature of F# code](img/image00237.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Reset all Settings** and then **Next** to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **No, just reset my settings overwriting my current setting** and then
    **Next** to proceed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select  **General** and then click on **Finish**:![Understanding the nature
    of F# code](img/image00238.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting it up, we will have a consistent layout to be used throughout
    this book, including the menu locations and the look and feel of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to scratch the surface of F# runtime with an introductory
    overview of common F# runtime, which will give us some insights into F# performance.
  prefs: []
  type: TYPE_NORMAL
- en: F# runtime characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The release of Visual Studio 2015 occurred at the same time as the release of
    .NET 4.6 and the rest of the tools, including the F# compiler. The compiler version
    of F# in Visual Studio 2015 is F# 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: F# 4.0 has no large differences or notable new features compared to the previous
    version, F# 3.0 in Visual Studio 2013.
  prefs: []
  type: TYPE_NORMAL
- en: Its runtime characteristic is essentially the same as F# 4.0, although there
    are some subtle performance improvements and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on what''s new in F# 4.0 (described as release notes)
    visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md](https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, the online and offline MSDN Library of F#
    in Visual Studio does not have F# 4.0 release notes documentation, but you can
    always go to the GitHub repository of F# to check the latest update.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the common characteristics of F# as part of managed programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: F# must conform to .NET CLR. This includes the compatibilities, the IL emitted
    after compilation, and support for .NET BCL (the basic class library). Therefore,
    F# functions and libraries can be used by other CLR-compliant languages such as
    C#, VB, and managed C++.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debug symbols (PDB) have the same format and semantics as the other CLR-compliant
    languages. This is important because F# code must be able to be debugged from
    other CLR-compliant languages as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the managed languages perspective, measuring the performance of F# is
    similar when measured by tools such as the CLR profiler. But from an F# unique
    perspective, the following are the unique characteristics of F#:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, all types in F# are immutable. Therefore, it's safe to assume it
    is intrinsically thread safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# has a distinctive collection library, and it is immutable by default. It
    is also safe to assume it is intrinsically thread safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# has a strong type inference model, and when a generic type is inferred without
    any concrete type, it automatically performs generalizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default functions in F# are implemented internally by creating an internal class
    derived from F#'s `FSharpFunc`. This `FSharpFunc` is essentially a delegate that
    is used by F# to apply functional language constructs such as currying and partial
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With **tail call recursive optimization** in the IL, the F# compiler may emit
    `.tail` IL, and then the CLR will recognize this and perform optimization at runtime.
    More on this in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# has inline functions as options. More on this in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1
    "Chapter 7. Language Features and Constructs Optimization"), *Language Features
    and Constructs Optimization.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# has a computation workflow that is used to compose functions. This will be
    described in more detail in [Chapter 8](fsp-hiperf_cu08.html#aid-1JFUC2 "Chapter 8. Optimizing
    Computation Expressions"), *Optimizing Computation Expressions.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# async computation doesn't need `Task<T>` to implement it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although F# async doesn't need the `Task<T>` object, it can operate well with
    the async-await model in C# and VB. The async-await model in C# and VB is inspired
    by F# async, but behaves semantically differently based on more things than just
    the usage of `Task<T>`. More on this in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: All of those characteristics are not only unique, but they can also have performance
    implications when used to interoperate with C# and VB.
  prefs: []
  type: TYPE_NORMAL
- en: Relation between F# code and its generated assembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The F# assembly (commonly known as DLL or executable EXE in .NET running on
    Windows) is the same as the C#/VB assembly upon compilation. The end product of
    the compiler is a .NET assembly.
  prefs: []
  type: TYPE_NORMAL
- en: An assembly may contain multiple namespaces, and each namespace may contain
    multiple files of modules, classes, or a mix of both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the F# relation of code and compiled code (assembly):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **F# code** | **Description** | **Compiled code** |'
  prefs: []
  type: TYPE_TB
- en: '| Project | An organization of an F# project. It may contain F# script (FSX)
    and F# source files (FS).In the conceptual layout, a project may contain multiple
    namespaces that spawn across multiple files of FSX and F# script. | An assembly
    of either executable EXE or DLL class library |'
  prefs: []
  type: TYPE_TB
- en: '| Namespace | A logical organization of modules and classes to help organizing
    within an organization, company, or functionality.For example: the `System.Web`
    namespace that contains many classes related to enable browser/server communication,
    including HTTP and HTTPS. | A namespace may spawn across different assemblies
    instead of a namespace for only one assembly |'
  prefs: []
  type: TYPE_TB
- en: '| Module | A module in F# is equal to a C# static class or module in VB. An
    F# FS file may contain multiple modules, although it is not recommended to have
    this practice. | Part of a generated assembly |'
  prefs: []
  type: TYPE_TB
- en: '| Classes and interfaces | A file can contain multiple classes and interfaces
    under different namespaces. It is recommended to have not more than one namespace
    for each file as this also minimizes compilation time when it tries to resolve
    references. | Part of a generated assembly |'
  prefs: []
  type: TYPE_TB
- en: Immutability versus mutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# implementation of types and collection types are immutable. Immutable in
    this sense means it is read-only, and we can only initialize the object with an
    initial value and we can't change it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability means once we initialize an object, it can be changed afterwards.
    This is why it is sometimes called a *mutating object value* instead of a changing
    object value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, `anynumber` is immutable and the value of it will always be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark a variable as mutable, F# has the `mutable` keyword and we can use
    `mutable` in the `let` declaration, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, changing the value requires the use of the `<-` symbol in F#, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the nature of F# is functional, a symbol can be both a data and a function.
    The content of the symbol is read-only, so does a function in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutability also has another advantage: it scales well across multiple threads
    or even in parallel, no matter whether it''s a value or a function. The immutability
    guarantee means that it is free of side effects. It is then safe to spawn multiple
    symbols in parallel because the result of an execution will be guaranteed to have
    the same result. This is also simply called **thread safe**.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that F# has a mixed support for functional and OOP at the same time
    (including having support for the inherent mutable state of OOP) may lead to bottlenecks
    as described next.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of common bottlenecks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# has common bottlenecks although they might be subtle as well.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to quickly understand the bottleneck factors in F#, we will
    categorize the shared general bottlenecks of .NET as managed bottlenecks (also
    in C#/VB), and F#-only bottlenecks (this includes when using F# with other languages).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are managed .NET bottlenecks (from obvious to less obvious):'
  prefs: []
  type: TYPE_NORMAL
- en: String concatenations, such as using string `String.Concat` instead of `StringBuilder`.
    This is often overlooked because of a lack of awareness of the string's immutability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of non-generic collections such as `ArrayList`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrectly handling side effects, such as exceptions and I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable objects usage, including casting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complex objects that will be serialized and deserialized, for example: sending
    `DataSet` that has `DataTables` over HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignoring performance profiling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Side effects mean all of the elements outside the formal computation (it is
    often called the *outside world*) that we interact with, and this includes the
    changing global state. The outside world can be all of the things that we cannot
    fully determine as the end result. Examples of the outside world include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I/O: This is included as being part of the outside world because you cannot
    determine or guarantee any kind of work you pass to I/O to be successfully completed.
    For example, when sending a command to a printer to print a document, we cannot
    guarantee 100% success of the printing operation. We cannot even guarantee that
    the process of sending the data to the printer will be successful or not before
    the printer receives the data and begins to print the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global static mutable variables: A quick example of this is when we define
    a `public static` variable in the scope of ASP.NET. Every value change will always
    change the condition of any user of the ASP.NET application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions or properties that always have different results when they are invoked,
    such as `DateTime.Now`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DateTime.Now` will always return different results and this is as expected
    because the result *must* change every time it is called or instantiated. It is
    not free of side effects, but it is still expected to always return a different
    result.'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects are not just for functional programming developers, as many of
    us are now becoming quite aware. There are no absolute side effect-free computations
    because we should learn and be able to correctly handle them. For example, even
    printing a screen to a console is also a side effect because it involves I/O,
    and it changes the state of the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are F#''s unique bottlenecks:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect use of data structures and collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect use of auto generalization and other language constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrectly implemented concurrency problems, such as mixing synchronous and
    asynchronous although the original intention is asynchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slow performance when having to interoperate with other languages' class libraries
    such as C#/VB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling `MailboxProcessor` in F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying when **tail call optimization** should occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slow response when resolving type in type provider implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slow performance when implementing computation workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common samples of misunderstood concurrent problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of us, when dealing with concurrent problems, sometimes try to use a hammer
    for every nail. There is no silver bullet for all of the problems of implementing
    concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: It is also recommended to understand concurrency, as concurrency is now becoming
    more relevant because of the many core models in the releases of modern microprocessors
    (or simply processors) in the last 7 years. This fact is also becoming a trend
    as the clock speed of the latest processors has been usually limited to 3.2 GHz
    for the last 3 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft''s Visual C++ architect, Herb Sutter, has written a very thorough
    article in the form of a whitepaper famously known as *The Free Lunch Is Over*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.gotw.ca/publications/concurrency-ddj.htm](http://www.gotw.ca/publications/concurrency-ddj.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand first what concurrency is and the F# supports.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to concurrency in F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive deeper into concurrency in F#, we should understand the definition
    of concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is one of the main disciplines of computer science and it is still
    one of the main problems of computations.
  prefs: []
  type: TYPE_NORMAL
- en: Simply defined, concurrency is the composition of the order of independent process
    units or partially-ordered process units that can be executed in parallel or not
    in parallel, but not in sequential order. The term *order* in this context means
    ordered as sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the concept of sequential (not concurrent)
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to concurrency in F#](img/image00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Process 1** to **Process 4** as shown in the preceding diagram is executed
    sequentially step by step. **Process 2** must wait for **Process 1** to be completed
    first, as do **Process 3** and **Process 4**.'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence is also called a synchronous process or is simply referred to
    as being synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure is a sample illustration of a parallel concurrency combination
    of parallel and synchronous processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to concurrency in F#](img/image00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Processes ** **1A**, **2A**, and **3A** run in parallel, although each parallel
    lane has its own sequence of processes that are run sequentially.'
  prefs: []
  type: TYPE_NORMAL
- en: The term parallel means that it is not just executing simultaneously in parallel,
    but parallel also means that it may run on many processors or on many cores, as
    is common in modern processors that have multiple cores.
  prefs: []
  type: TYPE_NORMAL
- en: Defining asynchronous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple definition of asynchronous means *not synchronous*. This means that
    if we have an asynchronous flow, the process is not run synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the implications of an asynchronous flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Processes run not sequentially. For example, if the first process is running
    asynchronously, the next process doesn't have to wait for the first process to
    be completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There has to be a way of scheduling and telling the scheduler to inform that
    the asynchronous process is completed. Typically, the asynchronous process is
    usually related to blocking I/O or some long computations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At first, the processes may look sequential, but the next process run may not
    be sequential at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a sample case of asynchronous: a customer is going to have dinner in
    a restaurant. The flows are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Customer A* orders some food or drinks, and the order is noted by *waiter
    X*. Usually, most restaurants have more than one waiter, but for this illustration,
    the waiter available currently to serve *customer A* is *waiter X*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Waiter X* then gives the list of the customer''s order to *chef Y*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Chef Y* accepts the order, and checks if he is currently occupied or not.
    If he is occupied, the order is registered as part of his cooking queue. Otherwise,
    he will start to cook the order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The waiter does not have to wait for the chef to complete his cooking. He can
    then serve other customers who have just arrived or there might be customers that
    want to add more food or drinks as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Chef Y* finishes his cooking for *customer A*, and then gives a notification
    to *waiter X* to inform that his cooking for *customer A* is finished. Or he can
    inform all waiters to tell that the cooking for *customer A* is finished. This
    concept of informing to tell a process is finished is commonly called a callback.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Waiter X* (or any other waiter) delivers the finished food to *customer A*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The asynchronous model that uses a notification to inform that a process is
    completed is called **asynchronous callback**.
  prefs: []
  type: TYPE_NORMAL
- en: The result returned at the end of the execution later (or in the future) is
    called a **Future**. It is also the future, in a sense, when many processes are
    executed in parallel, having results later.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the official documentation of Future in MSDN Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/ff963556.aspx](https://msdn.microsoft.com/en-us/library/ff963556.aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: For I/O operations, such as printing a document, we cannot determine whether
    the printing is successful or not, so the notification of the end process is not
    available. We can implement an asynchronous operation on I/O, and the fact that
    there is no observable notification of this is why this asynchronous model is
    called the asynchronous *fire and forget* model.
  prefs: []
  type: TYPE_NORMAL
- en: Misunderstood concurrency problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many developers, even seasoned or experienced developers, still think that concurrency
    and parallel programming are different. Actually, parallel programming is just
    one member within the concurrency discipline, together with the differentiation
    of asynchronous and synchronous processing models.
  prefs: []
  type: TYPE_NORMAL
- en: This is also one of the most misunderstood concurrency concepts or problems,
    and there are many more regarding how we approach concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some common organized sample cases of misunderstood concurrency problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming all concurrent problems can be solved using parallel programming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fact: Not all concurrent problems are easily solved with parallelism.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assuming all implementation of asynchronous is asynchronous.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fact: This depends on how we implement async; sometimes the execution of an
    async construct is executed synchronously.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ignoring blocking threads such as I/O.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fact: Blocking I/O threads should be handled asynchronously; otherwise, the
    current thread is always waiting indefinitely until the I/O thread is finished.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The synchronized lock is blocking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fact: The lock is not a blocking thread.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Relying on the CPU speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fact: The CPU speed increase is becoming less of an issue. The research and
    development of modern CPUs is focusing on multiple core CPUs.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A few sample cases of concurrent problems are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The case samples of the first case are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordering or sorting a collection**: Ordering is by default a sequential process,
    and it requires iterating all the elements of the collection. Therefore, it''s
    useless to use parallelism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouping data**: Grouping data is implicitly one of the sequential processes;
    it is also quite useless to use parallelism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Printing reports**: Printing is part of I/O and I/O is intrinsically without
    support for parallelism. Unless the I/O is part of I/O parallelism, it is useless
    to use parallelism in this context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sample cases of the second case are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mixing `Parallel.For` that has F# async in it. The implications of having `Parallel.For`
    is by default taking a multiple core or a CPU to run it is not the same as running
    asynchronously, as it is not guaranteed to run as a combined async in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Thread.Sleep` instead of `Async.Sleep` to signify a *wait* operation.
    The call to `Thread.Sleep` will instead make the flow synchronous, as the `Sleep`
    method simply puts on hold the current thread as a *delay* synchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RAID array in the storage I/O is one of the best samples of parallelism in I/O.
    It stores data in parallel across multiple disks. It is faster than common I/O
    because data is stored in parts (not whole data to a disk) to several disks in
    parallel.
  prefs: []
  type: TYPE_NORMAL
- en: The third case is related to all of the I/O operations including sending data
    to a printer and saving large data into a disk. These operations are always blocking
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: For the case of `lock`, Microsoft has issued official statements that `lock`
    in .NET used by C# and VB is executed without any interruption, and it only locks
    an object until it has finished executing the block in the synchronized lock.
    It's still allowing other threads to run without waiting for the thread that has
    the lock to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the official thread synchronization of C# and VB in MSDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/ms173179.aspx](https://msdn.microsoft.com/en-us/library/ms173179.aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to always check online the MSDN Library of the .NET class
    library, as this is always updated.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to concurrency support in .NET and F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrency support in F# is based on the existing work of concurrency support
    features in .NET BCL (the Base Class Library). It's also by design, since F# runs
    on top of .NET CLR and can use .NET BCL. F# also has its unique ways that bring
    more features other than just language features (for example, asynchronous computations).
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET BCL part of concurrency has basic support for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beginning with .NET 4.0, we have the **Task Parallel Library** (**TPL**). This
    library makes concurrent support easier. TPL consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data parallelism (for example: `Parallel.For` and `ForEach`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous task (this is also the base foundation of C#/VB's async-await)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel LINQ (often abbreviated as PLINQ)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more complete reference of concurrency support in .NET, please visit [https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET has no support yet for fiber API in Win32 API. Microsoft currently has
    no definite plan for fiber support.
  prefs: []
  type: TYPE_NORMAL
- en: 'F# has its own unique features of concurrency supports. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous workflow or computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MailboxProcessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel async
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel async combined with I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More on concurrency support in F# is available in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#* and [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced Concurrency
    Support in F#"), *Advanced Concurrency Support in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to dive more into some codes. To start writing F# code, we can
    use F# and Visual Studio combined. This includes IDE supports for F#.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of F# tooling in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# has been supported in Visual Studio since Visual Studio 2010, and in Visual
    Studio 2015 the support has improved with better syntax colorizations than Visual
    Studio 2010, not just IDE. This F# IDE support is officially called *Visual F#.*
  prefs: []
  type: TYPE_NORMAL
- en: This tooling is available as open source from Microsoft and it is available
    to be downloaded from GitHub at [https://github.com/Microsoft/visualfsharp/](https://github.com/Microsoft/visualfsharp/).
  prefs: []
  type: TYPE_NORMAL
- en: And the F# compiler itself is open source and it is also available from GitHub
    (including the design proposal discussions) at [https://github.com/fsharp](https://github.com/fsharp).
  prefs: []
  type: TYPE_NORMAL
- en: The tooling is under the governance of Microsoft, but it is welcoming community
    contributions as it is available on GitHub. All of the community participations
    of tooling, compilers and the language specifications are under the governance
    of the F# Software Foundation (FSSF).
  prefs: []
  type: TYPE_NORMAL
- en: We can also support FSSF directly. For more information about FSSF, please visit
    [http://fsharp.org/](http://fsharp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The F# community projects are also managed by FSSF, and it is welcoming contributions
    as well. FSSF is an independent entity and it is not tied to Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual F# in Visual Studio 2015 has mainly the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Project template support, including the NuGet package addition and references
    to other projects in the same solution file. The other projects can be VB or C#
    projects, not just F#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssemblyInfo` support in a separate file. This feature has been available
    since Visual Studio 2015\. Previously it was only available in C# and VB projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The F# compiler, FSC, is used to compile F# into .NET executable and libraries
    in the form of DLL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of the F# compiler, MSBuild infrastructure, and also Intellisense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# libraries, a foundation to the functional programming constructs of F# and
    F# unique concurrency features such as asynchronous workflow and `MailboxProcessor`.
    It also contains many useful functions to further interoperate with C#/VB, including
    interoperating with .NET delegates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive support for the F# interactive (FSI) prompt in the IDE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information about F# tooling, this is the official MSDN Library link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp](https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp)'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to always consult the Visual F# documentation on GitHub first,
    then combine it with the online MSDN Library section of F#.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has planned to rebuild all of the online MSDN Library to use the GitHub
    participation model, so developers can submit a pull request to modify or to amend
    any documentation page. Visual F# is now being reworked on as well, but there
    are some pages still left behind inside Visual F# GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: To always check the latest development of F# documentation on GitHub, visit
    [https://github.com/Microsoft/visualfsharpdocs](https://github.com/Microsoft/visualfsharpdocs).
  prefs: []
  type: TYPE_NORMAL
- en: Interactive support for F# interactive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# interactive is a tool to interpret your F# code and run it immediately. It
    will also process and show the results, the types, and the syntax errors. The
    code can be run in the interactive prompt or taken from the source code and then
    run into F# interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of having interpreted code, executing it, and seeing the results
    is called REPL. **REPL** is abbreviated from **Read-Eval-Print-Loop**, and it
    was first available as the system's command-line prompt. There is nothing new
    about this REPL concept, as other programming languages such as Python already
    have had REPL before F#.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to C# and VB, F# interactive is the first to have interactive REPL
    support since Visual Studio 2010\. Unfortunately, there is no Visual Studio's
    Intellisense support for F# interactive yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to use F# interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Command Prompt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common usage of F# interactive is within Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We have to set up the **F# Interactive** window to be displayed in order to
    use F# interactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps to display the **F# Interactive** window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **View** menu from the Visual Studio main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Other Windows..** and then choose **F# Interactive**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A window that hosts the **F# Interactive** within Visual Studio will appear
    and it will be ready to interpret our F# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive support for F# interactive](img/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a starter, type `#help` followed by `;;` to mark as closing statements to
    be evaluated. We now see some further options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive support for F# interactive](img/image00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: F# interactive can be used to not only interpret and run F# code but also as
    a way to see immediate results of a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Type `5 * 25;;` and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now see the result of that calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive support for F# interactive](img/image00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can also execute codes in the Visual Studio editor when we are opening F#
    source code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, create a new project using the F# tutorial project template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive support for F# interactive](img/image00244.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You may find that your display of Visual Studio is different from the previous
    screenshot. Actually, the aforementioned display depends on what Visual Studio
    edition we have. For Visual Studio Enterprise, more templates are available for
    us to use, such as the **Modeling Projects** to create UML.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of F#, the project templates of the F# projects are the same
    for the Community Edition and above.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the project, an F# project contains `Tutorial.fsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we use F# interactive, we should turn on the option for displaying line
    numbers. It is also recommended to have this option always turned on, as it will
    provide easier navigation to the code we write:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Tools** menu and choose **Options**. It is available in F# options
    in the **Options** dialog:![Interactive support for F# interactive](img/image00245.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now double-click `Tutorial.fsx`, and highlight lines **44** to **61**:![Interactive
    support for F# interactive](img/image00246.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then press *Alt* + *Enter*. F# interprets the code. We can see the result of
    the interpretation in **F# Interactive**:![Interactive support for F# interactive](img/image00247.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have tried F# interactive from within the Visual Studio IDE. Let's use F#
    interactive from Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use *Ctrl* + *Alt* + *F* to activate or open **F# Interactive**.
  prefs: []
  type: TYPE_NORMAL
- en: To use F# interactive from Command Prompt, we call the executable FSI directly
    from Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to run FSI is from Visual Studio's developer Command Prompt. This
    developer Command Prompt is available under the `Visual Studio 2015` folder on
    the start menu of the Windows desktop menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select it, and now we have the **Developer Command Prompt for VS2015**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive support for F# interactive](img/image00248.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Type `FSI` and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to write some code to evaluate, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Enter*. The immediate result will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive support for F# interactive](img/image00249.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To quit the FSI, type `#quit;;` and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Using F# interactive from Command Prompt is faster but it is also not quite
    so user-friendly because we cannot evaluate multiple lines of code easily. It
    is easier to evaluate this in Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For simplicity and ease of use, the rest of this book will always use FSI within
    the Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about F# FSI, consult the FSI reference from the MSDN Library
    at  [https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference](https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference).
  prefs: []
  type: TYPE_NORMAL
- en: FSI is also configurable. We can configure FSI further by leveraging the FSI
    class library in the `Microsoft.FSharp.Compiler.Interactive` namespace. More information
    on this library is also available at the F# FSI URL mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to debugging in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one aspect of understanding running F# code that is crucial: debugging
    F# code. We have to be able to debug F# code, especially when we have very large
    projects that have hundreds of F# code files, not to mention when each of the
    code files may have too many lines of code. For example, having to check a running
    F# code that has more than 2,000 lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages of the debug features:'
  prefs: []
  type: TYPE_NORMAL
- en: Isolating the error and focusing on it by inserting a breakpoint can ease the
    fixing of an error or bug. Developers are gaining more productivity because they
    can fix errors/bugs faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging can also provide insightful information about the correctness of any
    value returning from a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging can also be used to trace bugs further by examining the results from
    other referenced libraries as well. It is possible that we may use the referenced
    library incorrectly or the referenced library may also have bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual F# in Visual Studio 2015 also has debugging capabilities. It was not
    as powerful when it was introduced in Visual Studio 2008 as additional add-on,
    but now the debugging experience is much better. It has been integrated with the
    Visual Studio extensibility model nicely, providing, for example, faster execution
    while running in the debug mode and having conditional breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: It is different from the C#/VB debugger because F#, although being a strongly
    and strictly typed language, currently has no support for evaluating expressions
    in the debugger's immediate windows in Visual Studio 2015.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some experienced F# developers may argue that this additional debug feature
    is not a big concern at all as F# has a tendency to enforce type restriction and
    correctness at the fabric of F# as a programming language. But for most other
    developers, especially those who jump from C#/VB to F#, the overall debugging
    experience is still lacking some features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently these are the differences between the F# and C#/VB debugger in Visual
    Studio 2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **F#** | **C#/VB** |'
  prefs: []
  type: TYPE_TB
- en: '| Breakpoint insertion | Yes. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Condition in breakpoint | Yes. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Intellisense in editing condition in breakpoint | Not supported because Intellisense
    is not yet linked to the whole infrastructure of the Visual Studio 2015 IDE extensibility
    and the F# compiler. There is a plan to have this feature for the next Visual
    Studio release after Visual Studio 2015. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Lightbulb assistant | Not available. There is a plan to have this feature
    for the next Visual Studio release after Visual Studio 2015, but the exact planned
    release is not quite clear. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Expression evaluation in immediate window | Not available. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Locals value | Yes. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Auto watch value | Yes. | Yes |'
  prefs: []
  type: TYPE_TB
- en: Other than the features in the previous table, basic debugging with breakpoints
    in Visual F# is essentially the same as debugging in C#/VB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take some code to debug. To quickly have some code, we can use the F#
    3.0 sample from CodePlex at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://fsharp3sample.codeplex.com/](http://fsharp3sample.codeplex.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the ZIP file of the code samples, unzip it to a folder and
    open the `SampleProject.sln` solution file in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may read `Readme.txt` first before using the whole sample code. This readme
    guide is available in the `Solution Item` folder when opened in **Solution Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your screen should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in F#](img/image00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Some of the samples in F# 3.0 are not valid anymore. You have to register for
    Azure DataMarket to access the F# Type Provider of Azure DataMarket.
  prefs: []
  type: TYPE_NORMAL
- en: There are some compiler errors if we try to rebuild the solution without changing
    the code at all, and one of the sample type providers, ESRI DataMarket, is not
    working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on those invalid type provider conditions, to build this sample solution
    successfully, you have to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Register with Azure DataMarket. You need to have your own Azure account key
    to access Azure DataMarket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ESRI sample has not been working since 2014\. Please comment the lines from
    line 135 to line 157 in the `Samples.TypeProviders.AzureMarketPlace.fs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebuild the solution. This will compile the whole solution and also resolve
    the type provider in the background for us to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the `Samples.Beginners.fs` file. Put the debugger breakpoints at lines
    19 and 20 by clicking the line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add breakpoints, you can simply toggle the highlighted column on the left
    before the line number like this:![Introduction to debugging in F#](img/image00251.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And we can also add breakpoints by right clicking and choosing **Breakpoints..**
    and then **Insert Breakpoint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the code by initiating the **Build Solution**. Then press *F5* to run.
    The window of **F# Micro Sample Explore** is displayed:![Introduction to debugging
    in F#](img/image00252.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This sample is actually a showcase of many F# features, from basic language
    constructs, units of measure, type providers, and LINQ, to concurrency such as
    async and parallelism.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now expand the **Basic** node on the left and choose **Basic Data Types**, and
    then choose the last node of **Integer Arithmetic**, as illustrated here:![Introduction
    to debugging in F#](img/image00253.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Going back to the source code of `Samples.Beginner.fs`, we can see that the
    node name is also the same as the name of the attributes in the code to categorize:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the **Run Sample!** button and Visual Studio will stop the execution at
    the breakpoint:![Introduction to debugging in F#](img/image00254.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can debug our code easily. We can also look at the value of the variables
    or symbols that are currently in scope by checking the value at the **Locals**
    window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *F10* to step over, and now we see the evaluated value of `x` and `y`:![Introduction
    to debugging in F#](img/image00255.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any local variables in **Locals** and watch expressions displayed in the **Watch1**
    window always have the name, value, and type of the variables. The type displayed
    is using the F# keyword, not the full type name.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `int` is displayed instead of `System.Int32` as shown in **Locals**.
  prefs: []
  type: TYPE_NORMAL
- en: We can always check other values as well if we have another `global` or `static
    global` variable in the **Watch1** window. The values can contain immediate values
    from an expression, for example `DateTime.Now`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, we have to write using the full namespace of `System.DateTime`,
    so we have to write the expression as `System.DateTime.Now`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in F#](img/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This requirement to have the full namespace proves that debugger support in
    Visual F# still requires improvements compared to its C#/VB counterparts. Typing
    the full object name may be error prone, as F# watch does not support Intellisense
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: After we have finished debugging and bug fixing, it is recommended to change
    the compilation to the **Release** mode. The **Release** mode will have a smaller
    compiled F# code and it executes faster because it does not contain debug symbols
    and any other debug information attached to the compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change back and forth between **Debug** and **Release** is quite easy. We
    can simply change the mode at the drop-down menu in the Visual Studio toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in F#](img/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is no apparent distinction on the compiled DLL or EXE filename, other
    than the smaller size of the release mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the following are the differences of the **Debug** mode and the
    **Release** mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Elements** | **Debug** | **Release** |'
  prefs: []
  type: TYPE_TB
- en: '| Debug symbol (PDB) | Included | Not included. |'
  prefs: []
  type: TYPE_TB
- en: '| Size of compiled code | Bigger than the release mode, excluding the PDB file
    | Smaller than the debug mode. |'
  prefs: []
  type: TYPE_TB
- en: '| Code optimization | Not optimized, as it is focused for debugging and it
    is also synchronized | Yes, but the code will not be able to be debugged easily,
    as the code is optimized for executions.In .NET 4.6 and Windows 10, it is optimized
    further by compiling into native code using the Ahead Of Time (AOT) model instead
    of Just In Time (JIT). |'
  prefs: []
  type: TYPE_TB
- en: '| Compilation symbol availability | `DEBUG` | Not applicable. |'
  prefs: []
  type: TYPE_TB
- en: '| Execution | Slower than Release, as there is no optimization | Fast, since
    it is optimized for runtime, and there is no debug symbol overhead. |'
  prefs: []
  type: TYPE_TB
- en: For more information about AOT and JIT, consult the MSDN Library at [https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the introduction to performing common performance optimizations,
    from the performance characteristics of F# and .NET to the most commonly used
    optimization concepts such as concurrency. We also have a basic knowledge to start
    troubleshooting performance problems by debugging using Visual Studio. But debugging
    running F# code is still a small part of performance optimization because debugging
    only provides an insight of the values and the states of objects in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The debug support of F# tooling itself is not enough to fully understand the
    details of performance problems because most of the detailed performance optimization
    requires us to measure the benchmark of our code. The measurement of performance
    in order to objectively measure optimization will be described in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement") , *Performance Measurement*.
  prefs: []
  type: TYPE_NORMAL
