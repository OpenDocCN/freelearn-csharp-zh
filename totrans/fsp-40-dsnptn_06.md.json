["```cs\naverage : seq<^T> -> ^T (requires member (+) and member    DivideByInt and member get_Zero)averageBy : ('T -> ^U) -> seq<'T> -> ^U (requires ^U with static    member (+) and ^U with static member DivideByInt and ^U with    static member Zero) \nfold : ('State -> 'T -> 'State) -> 'State -> seq<'T> -> 'State \nlength : seq<'T> -> int \nsum : seq<^T> -> ^T (requires member (+) and member get_Zero) \nsumBy : ('T -> ^U) -> seq<'T> -> ^U (requires ^U with static  member (+) and ^U with static member Zero) \nmax : seq<'T> -> 'T (requires comparison) \nmaxBy : ('T -> 'U) -> seq<'T> -> 'T (requires comparison) \nmin : seq<'T> -> 'T (requires comparison) \nminBy : ('T -> 'U) -> seq<'T> -> 'T (requires comparison) \nisEmpty : seq<'T> -> bool \nreduce : ('T -> 'T -> 'T) -> seq<'T> -> 'T \nexactlyOne : seq<'T> -> 'T \ncompareWith : ('T -> 'T -> int) -> seq<'T> -> seq<'T> -> int \n\n```", "```cs\nempty : seq<'T>\ninit : int -> (int -> 'T) -> seq<'T>\ninitInfinite : (int -> 'T) -> seq<'T>\nsingleton : 'T -> seq<'T>\nunfold : ('State -> 'T * 'State option) -> 'State -> seq<'T>\n```", "```cs\ncast : IEnumerable -> seq<'T>\ncache : seq<'T> -> seq<'T>\ndelay : (unit -> seq<'T>) -> seq<'T>\nreadonly : seq<'T> -> seq<'T>\ntoArray : seq<'T> -> 'T []\ntoList : seq<'T> -> 'T\nlist ofArray : 'T array -> seq<'T>\nofList : 'T list -> seq<'T>\n```", "```cs\niter : ('T -> unit) -> seq<'T> -> unit\niter2 : ('T1 -> 'T2 -> unit) -> seq<'T1> -> seq<'T2> -> unit\niteri : (int -> 'T -> unit) -> seq<'T> -> unit\n```", "```cs\nappend : seq<'T> -> seq<'T> -> seq<'T>\ncollect : ('T -> 'Collection) -> seq<'T> -> seq<'U>\nconcat : seq<'Collection> -> seq<'T>\nhead : seq<'T> -> 'T\nlast : seq<'T> -> 'T\nnth : int -> seq<'T> -> 'T\nskip : int -> seq<'T> -> seq<'T>\ntake : int -> seq<'T> -> seq<'T>\nsort : seq<'T> -> seq<'T>\nsortBy : ('T -> 'Key) -> seq<'T> -> seq<'T>\ntruncate : int -> seq<'T> -> seq<'T>\ndistinct : seq<'T> -> seq<'T>\ndistinctBy : ('T -> 'Key) -> seq<'T> -> seq<'T>\n```", "```cs\nchoose : ('T -> 'U option) -> seq<'T> -> seq<'U>\nexists : ('T -> bool) -> seq<'T> -> bool\nexists2 : ('T1 -> 'T2 -> bool) -> seq<'T1> -> seq<'T2> -> bool\nfilter : ('T -> bool) -> seq<'T> -> seq<'T>\nfind : ('T -> bool) -> seq<'T> -> 'T\nfindIndex : ('T -> bool) -> seq<'T> -> int\nforall : ('T -> bool) -> seq<'T> -> bool\nforall2 : ('T1 -> 'T2 -> bool) -> seq<'T1> -> seq<'T2> -> bool\npick : ('T -> 'U option) -> seq<'T> -> 'U\nskipWhile : ('T -> bool) -> seq<'T> -> seq<'T>\ntakeWhile : ('T -> bool) -> seq<'T> -> seq<'T>\ntryFind : ('T -> bool) -> seq<'T> -> 'T option\ntryFindIndex : ('T -> bool) -> seq<'T> -> int\noption tryPick : ('T -> 'U option) -> seq<'T> -> 'U option\nwhere : ('T -> bool) -> seq<'T> -> seq<'T>\n```", "```cs\ncountBy : ('T -> 'Key) -> seq<'T> -> seq<'Key * int>\ngroupBy : ('T -> 'Key) -> seq<'T> -> seq<'Key * seq<'T>>\npairwise : seq<'T> -> seq<'T * 'T>\nmap : ('T -> 'U) -> seq<'T> -> seq<'U>\nmap2 : ('T1 -> 'T2 -> 'U) -> seq<'T1> -> seq<'T2> -> seq<'U>\nmapi : (int -> 'T -> 'U) -> seq<'T> -> seq<'U>\nscan : ('State -> 'T -> 'State) -> 'State -> seq<'T> -> seq<'State> windowed : int -> seq<'T> -> seq<'T []>\nzip : seq<'T1> -> seq<'T2> -> seq<'T1 * 'T2>\nzip3 : seq<'T1> -> seq<'T2> -> seq<'T3> -> seq<'T1 * 'T2 * 'T3>\n```", "```cs\ntype seq<'T> = System.Collections.Generic.IEnumerable<'T> \n\n```", "```cs\ntype private DummyEnumerate<'T>() = \n  interface System.Collections.Generic.IEnumerator<'T> with \n    member x.Current = Unchecked.defaultof<'T> \n\n  interface System.Collections.IEnumerator with  \n    member x.Current = box Unchecked.defaultof<'T> \n    member x.MoveNext() = false \n    member x.Reset() = () \n\n  interface System.IDisposable with  \n    member x.Dispose() = () \n\n```", "```cs\nlet makeDummyEnumerator<'T>() = \n  fun() -> (new DummyEnumerate<'T>() \n    :> System.Collections.Generic.IEnumerator<'T>) \n\n```", "```cs\nlet makeSeq enumerator = \n{ \n  new System.Collections.Generic.IEnumerable<_> with \n    member x.GetEnumerator() = enumerator() \n  interface System.Collections.IEnumerable with \n    member x.GetEnumerator() = \n    (enumerator() :> System.Collections.IEnumerator) \n} \n\n```", "```cs\nlet ss = makeSeq (makeDummyEnumerator<int>()) \n\n```", "```cs\nSystem.Int32.MaxValue = 2147483647 \nSystem.Int64.MaxValue = 9223372036854775807L \n\n```", "```cs\ntype private Repeater<'T>(repeated) = \n  let _repeated = repeated \n    interface System.Collections.Generic.IEnumerator<'T> with \n    member x.Current = _repeated \n\n  interface System.Collections.IEnumerator with  \n    member x.Current = box _repeated \n    member x.MoveNext() = true \n    member x.Reset() = () \n\n  interface System.IDisposable with \n    member x.Dispose() = () \n\n```", "```cs\nlet repeat<'T>(e) = \n  (new Repeater<'T>(e) \n  :> System.Collections.Generic.IEnumerator<'T>) \n\n```", "```cs\nlet makeSeq enumerator = \n{ \n  new System.Collections.Generic.IEnumerable<'U> with \n    member x.GetEnumerator() = enumerator \n  interface System.Collections.IEnumerable with \n    member x.GetEnumerator() = \n    (enumerator :> System.Collections.IEnumerator) \n} \n\n```", "```cs\nlet inline traverse n s = \n  let counter = \n    (Seq.zip \n    (seq { LanguagePrimitives.GenericOne..n }) s) \n    .GetEnumerator() \n  let i = ref LanguagePrimitives.GenericOne \n  let mutable last = Unchecked.defaultof<_> \n  while counter.MoveNext() do \n    if !i = n then last <- counter.Current \n      i := !i + LanguagePrimitives.GenericOne \n  last \n\n```", "```cs\n// odd int64 between 1 and 1000 \nseq { 1L .. 2L .. 1000L } \n// val it : seq<int64> = seq [1L; 3L; 5L; 7L; ...] \n\n// range not necessarily must be numeric! \nseq { 'A' .. 'Z' } \n// val it : seq<char> = seq ['A'; 'B'; 'C'; 'D'; ...] \n\n```", "```cs\n// even int from 2 to 1000 \nseq { for i in 1..2..999 -> ((+) 1 i) } \n// val it : seq<int> = seq [2; 4; 6; 8; ...] \n\n// nested enumerations \nseq { for i in 1..10 do for j in 1..10 -> if i = j then 1 else 0} \n// val it : seq<int> = seq [1; 0; 0; 0; ...] \n\n// cartesian product tuple projection \nseq { for i in 1..10 do for j in 1..10 -> (i,j) } \n// val it : seq<int * int> = seq [(1, 1); (1, 2); (1, 3); ...] \n\n// cartesian product nested enumerations \nseq { for i in seq {'a'..'b'} do for j in 1..2 -> (i,j) } \nval it : seq<char * int> = seq [('a', 1); ('a', 2); ('b', 1); ('b', 2)] \n\n```", "```cs\nlet rec descend top =  \n  seq { \n    match top with \n      | _ when top < 0 -> () \n      | _ -> \n      yield top \n      yield! descend (top - 1) \n  } \n\n// descend 3;; \n// val it : seq<int> = seq [3; 2; 1; 0] \n// descend -3;; \n// val it : seq<int> = seq [] \n\n```", "```cs\nlet rec fizzbuzz = seq {  \n  yield \"Fizz\" \n  yield \"Buzz\" \n  yield! fizzbuzz \n} \nin fizzbuzz \n\n// val it : seq<string> = seq [\"Fizz\"; \"Buzz\"; \"Fizz\"; \"Buzz\";  ...]\n```", "```cs\nlet rec circular ss = \n  seq { yield! ss; yield! circular ss } \n\ncircular (seq { yield '+'; yield '-' }) \n// val it : seq<char> = seq ['+'; '-'; '+'; '-'; ...] \n\n```", "```cs\nSeq.init 10 (sprintf \"%s%d\"\"I'm element #\") \n//val it : seq<string> = \n//  seq \n//    [\"I'm element #0\"; \"I'm element #1\"; \"I'm element #2\"; \n//    \"I'm element #3\"; ...] \n\n```", "```cs\nSeq.initInfinite (sprintf \"%s%d\"\"I'm element #\") \n//val it : seq<string> = \n//  seq \n//    [\"I'm element #0\"; \"I'm element #1\"; \"I'm element #2\"; \n//    \"I'm element #3\"; ...] \n\n```", "```cs\nSeq.initInfinite (fun _ -> ()) \n|> Seq.skip (System.Int32.MaxValue) \n//> \n//val it : seq<unit> = \n//  Error: Enumeration based on System.Int32 exceeded System.Int32.MaxValue. \n\n```", "```cs\n// Oh NO! Not Fibonacci again! \nlet fibnums = Seq.unfold (fun (current, next) -> \n  Some(current, (next, current+next)))(1,1) \n\nfibnums |> Seq.take 10 |> Seq.toList \n// val it : int list = [1; 1; 2; 3; 5; 8; 13; 21; 34; 55] \n\n```", "```cs\nlet makeSeq f = \n{ \n  new System.Collections.Generic.IEnumerable<'U> with \n    member x.GetEnumerator() = printfn \"Fresh enumerator given\"; f() \n  interface System.Collections.IEnumerable with \n    member x.GetEnumerator() = \n    (f() :> System.Collections.IEnumerator) \n} \n\n```", "```cs\n//caching \nlet nums = (seq {1..100}).GetEnumerator |> makeSeq \n// non-cached - double enumeration \n((nums |> Seq.sum),(nums |> Seq.length)) \n//Fresh enumerator given \n//Fresh enumerator given \n//val it : int * int = (5050, 100) \n\nlet cache = nums |> Seq.cache \n// cached - single enumeration \n((cache |> Seq.sum),(cache |> Seq.length)) \n//Fresh enumerator given \n//val it : int * int = (5050, 100) \n// just another time - no enumerations at all \n((cache |> Seq.sum),(cache |> Seq.length)) \n//val it : int * int = (5050, 100) \n\n```", "```cs\nlet series = (seq {1..100}).GetEnumerator |> makeSeq \nlet average dd = (Seq.sum dd) / (Seq.length dd) \naverage series \n//Fresh enumerator given \n//Fresh enumerator given \n//val it : int = 50 \n\n```", "```cs\nlet averageFused dd = \n  dd \n  |> Seq.fold (fun acc x -> (fst acc + x, snd acc + 1)) (0,0) \n  |> fun x -> fst x / snd x \naverageFused series \n//Fresh enumerator given \n//val it : int = 50 \n\n```"]