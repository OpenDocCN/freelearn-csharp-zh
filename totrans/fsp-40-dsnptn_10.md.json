["```cs\nlet reverse ls = \n    let rec rev acc = function \n    | h::t -> rev (h::acc) t \n    | []   -> acc \n    rev [] ls \n\n```", "```cs\nreverse [1;2;3] \n// val it : int list = [3; 2; 1] \nreverse [\"1\";\"2\";\"3\"] \n// val it : string list = [\"3\"; \"2\"; \"1\"] \n\n```", "```cs\nreverse [box 1.0; box 2.0M; box 3I] \n//val it : obj list = [3 {IsEven = false; \n//                        IsOne = false; \n//                        IsPowerOfTwo = false; \n//                        IsZero = false; \n//                        Sign = 1;}; 2.0M; 1.0] \n\n```", "```cs\nlet twice x  = x <<< 1 \n\n```", "```cs\nlet twice x = x <<< 1 \ntwice 10L \n//val twice : x:int64 -> int64 \n//val it : int64 = 20L \n\n```", "```cs\nlet inline twice' x = x <<< 1 \n// val inline twice' : \n//     x: ^a ->  ^a when \n//        ^a : (static member ( <<< ) :  ^a * int32 ->  ^a) \n\n```", "```cs\ntwice' 5    // int32 argument \ntwice' 5u   // uint32 argument \ntwice' 5L   // int64 argument \ntwice' 5UL  // uint64 argument \ntwice' 5y   // sbyte argument \ntwice' 5uy  // byte argument \ntwice' 5s   // int16 argument \ntwice' 5us  // uint16 argument \ntwice' 5I   // biginteger argument \ntwice' 5n   // nativeint argument \n\n```", "```cs\ntwice' 5m //The type 'decimal' does not support the operator '<<<' \ntwice' 5.0 // The type 'float' does not support the operator '<<<' \ntwice' \"5\"// The type 'string' does not support the operator '<<<' \ntwice' '5' // The type 'char' does not support the operator '<<<' \n\n```", "```cs\nlet inline constrained (param: ^a \n    when ^a: equality and ^a: comparison) = () \n\ntype Good = Good \n\n[<NoEquality; NoComparison>]type Bad = Bad \n\nGood |> constrained \n// Compiles just fine \nBad |> constrained \n// Error: type Bad does not support comparison constraint \n\n```", "```cs\n[<AutoOpen>] \nmodule Restrict = \n    let inline private impl restricted = \n        printfn \"%s type is OK\" (restricted.GetType().FullName) \n\n    type Restricting = Restrict with \n        static member ($) (Restrict, value: byte) = impl value \n        static member ($) (Restrict, value: sbyte) = impl value \n        static member ($) (Restrict, value: int) = impl value \n        static member ($) (Restrict, value: uint32) = impl value \n        static member ($) (Restrict, value: bigint) = impl value \n\n    let inline doit restricted = Restrict $ restricted \n\n```", "```cs\ndoit 1uy \ndoit 1y \ndoit 1 \ndoit 1u \ndoit 1I \ndoit 1L // does not compile \ndoit 1.0 // does not compile \ndoit 1.0m // does not compile \ndoit '1' // does not compile \n\n```", "```cs\ntype Bar() = \n  static member doIt() = 42 \n\ntype Foo< ^T when ^T: (static member doIt: unit -> int)>(data: ^T []) = \n  member inline this.Invoke () = (^T : (static member doIt : unit -> int) ()) \n\nlet result = (Foo([|Bar()|]).Invoke()) \n// val result : int = 42 \n\n```", "```cs\nopen System \n#time \"on\" \nlet x, y = DateTime.MinValue, DateTime.MaxValue \nfor i = 0 to 10000000 do x = y |> ignore \n//Real: 00:00:00.421, CPU: 00:00:00.406, GC gen0: 115, gen1: 2, gen2: 1 \n\n```", "```cs\nopen System \n#time \"on\" \nlet inline eq<'a when 'a :> IEquatable<'a>> (x:'a) (y:'a) = x.Equals y \nlet inline (==) x y = eq x y \nfor i = 0 to 10000000 do x == y |> ignore \n//Real: 00:00:00.022, CPU: 00:00:00.015, GC gen0: 0, gen1: 0, gen2: 0 \n\n```", "```cs\nlet inline nextHigher number = \n    let g0 = LanguagePrimitives.GenericZero<'a> \n    let g1 = LanguagePrimitives.GenericOne<'a> \n    let g10 = (g1 <<< 3) + (g1 <<< 1) \n\n    let toDigits n = \n        let rec toDigitList digits n = \n            if n = g0 then digits \n            else toDigitList ((n % g10) :: digits) (n / g10) \n        toDigitList [] n \n\n    let fromDigits digits = \n        let rec fromDigitList n = function \n            | [] -> n \n            | h::t -> fromDigitList (n * g10 + h) t \n        fromDigitList g0 digits \n\n    let make p ll  = \n        ll |> List.rev |> List.partition ((<) p) \n        |> fun (x,y) -> (x.Head::y) @ (p::(x.Tail)) \n\n    let rec scan (changing: 'a list) source = \n        match source with \n        | [] -> changing \n        | h::t -> if h >= changing.Head then \n                    scan (h::changing) t \n                  else \n                    (List.rev t) @ (make h changing) \n\n    number |> toDigits \n           |> List.rev |> fun x -> scan [(x.Head)] (x.Tail) \n           |> fromDigits \n\n```", "```cs\ntype Outcome = \n| Success \n| Failure \nwith \n    member x.IsFailure = \n        match x with \n        | Failure -> true \n        | _ -> false \n    member x.IsSuccess = not x.IsFailure \n\n```", "```cs\ntype Sale = \n    | DirectSale of decimal \n    | ManualSale of decimal \n\ntype Refund = \n    | Refund of decimal \n\n```", "```cs\nlet ll: obj list = [box (DirectSale 10.00M); box (Refund -3.99M)] \n\n```", "```cs\nlet ll': obj list = [box (Refund -3.99M); box 1; box \"Anything\"] \n\n```", "```cs\ntype Transaction = \n  | Sale of Sale \n  | Refund of Refund \n\nlet ll: Transaction list = [Sale (DirectSale 5.00M); Sale (ManualSale 5.00M); Refund (Refund.Refund -1.00M)] \n\n```", "```cs\ntype ITransaction = interface end \n\n```", "```cs\ntype Sale = \n    | DirectSale of decimal \n    | ManualSale of decimal \n    interface ITransaction \n\ntype Refund = \n    | Refund of decimal \n    interface ITransaction \n\n```", "```cs\nlet mixer (x: ITransaction) = x \n\n```", "```cs\nlet ll: list<_> = [mixer(DirectSale 10.00M); mixer(Refund -3.99M)] \n\n```", "```cs\n#nowarn \"25\" \n\nlet disassemble (x: ITransaction) = \n    match x with \n    | :? Sale as sale -> (function DirectSale amount -> (sprintf \n\"%s%.2f\" \"Direct sale: \" amount, amount) \n    | ManualSale amount -> (sprintf \"%s%.2f\" \"Manual sale: \" amount,\namount)) sale \n    | :? Refund as refund -> (function Refund amount -> (sprintf\n\"%s%.2f\" \"Refund: \" amount, amount)) refund \n\n```", "```cs\n[mixer(DirectSale 4.12M);mixer(Refund -0.10M);mixer(ManualSale 3.62M)] \n|> List.fold (fun (details, total) transaction -> \n    let message, amount = disassemble transaction in \n    (message::details, total + amount)) \n    ([],0.00M) \n|> fun (details,total) -> \n    (sprintf \"%s%.2f\" \"Total: \" total) :: details \n|> List.iter (printfn \"%s\") \n\n```"]