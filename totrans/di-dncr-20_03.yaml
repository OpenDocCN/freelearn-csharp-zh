- en: Introducing Dependency Injection in .NET Core 2.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 2.0中的依赖注入介绍
- en: This chapter is a first approach in the implementation of .NET Core Dependency
    Injection technologies in the most recent version of .NET Core (2.0). Its main
    features, functionalities, and the namespaces holding the set of classes support
    these features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是.NET Core依赖注入技术在.NET Core最新版本（2.0）中的首次尝试实现。它的主要功能、功能以及包含支持这些功能的类集的命名空间。
- en: 'We will talk about the following in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: In all, we'll talk about how .NET Core includes support for several of the SOLID
    principles in general and those related to Dependency Injection in particular
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总的来说，我们将讨论.NET Core如何包括对SOLID原则的支持，特别是与依赖注入相关的原则
- en: We'll start with the main characteristics of .NET Core and its installation
    and usage from Visual Studio, especially focusing on the latest version, Visual
    Studio 2017, together with the distinct types of deployment that this version
    allows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从.NET Core的主要特性及其在Visual Studio中的安装和使用开始，特别是关注最新版本Visual Studio 2017，以及这个版本允许的不同类型的部署
- en: Then, we'll get into the Dependency Injection in .NET Core, the `ActivatorUtilities`
    class, and the `Microsoft.Extensions.DependencyInjection` container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将深入了解.NET Core中的依赖注入，`ActivatorUtilities`类，以及`Microsoft.Extensions.DependencyInjection`容器
- en: Later on, we'll see some demos related to the implementation of an object's
    lifetime and how to map interfaces to instance classes, as well as a brief reminder
    of some more aspects of the Scope when applied to services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将看到一些与对象生命周期实现相关的演示，以及如何将接口映射到实例类，以及当应用于服务时对作用域的一些更多方面的简要回顾
- en: Finally, we'll see how this DI functionality is also implemented inside some
    .NET Core services, especially those related to logging with plenty of demos showing
    how to use it in pure .NET Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将看到这种依赖注入功能是如何在.NET Core服务中实现的，特别是与日志记录相关的服务，以及大量演示如何在使用纯.NET Core时使用它。
- en: The main characteristics of .NET Core
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core的主要特性
- en: We've explained the basics of the architecture proposal of .NET Core in [Chapter
    1](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml), *The SOLID Principles of Software
    Design* and how it pretends to be a game-changer, since it offers the possibility
    of creating code in the same language (C# or VB.NET), capable of executing on
    any device or platform.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml)《软件设计的SOLID原则》中解释了.NET
    Core架构提案的基础，以及它如何试图成为一个变革者，因为它提供了在相同语言（C#或VB.NET）中创建代码的可能性，能够在任何设备或平台上执行。
- en: Please note that VB.NET support of new features always goes behind the advances
    you'll see in the C# language, so, in case you try some new feature using this
    language, you should make sure that it has been implemented for the version we're
    using in this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，VB.NET对新特性的支持总是落后于C#语言中的新进展，因此，如果你尝试使用此语言使用某些新特性，请确保它已经实现了我们在这本书中使用的版本。
- en: This capability also extends to mobile applications, thanks to the incorporation
    of the Xamarin environment (and IDE) to the set of tools related to .NET Core
    development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力也扩展到了移动应用程序，这得益于将Xamarin环境（和IDE）纳入到与.NET Core开发相关的工具集。
- en: The main advantages of .NET Core
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core的主要优势
- en: 'If we look at this framework from a more developer-like point of view, we could
    say that what makes .NET Core different from other choices can be summarized in
    the following points:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从更开发者的角度来审视这个框架，我们可以说，使.NET Core与其他选择不同的因素可以总结如下：
- en: '**Cross-platform:** This means execution on Windows, macOS and Linux, and also
    its portability to other operating systems. You can check the list of supported
    operating systems on various sites, such as [https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md),
    and you should bear in mind that CPUs and application scenarios will keep growing,
    whether they are provided by Microsoft or other companies.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台：** 这意味着在Windows、macOS和Linux上执行，以及将其移植到其他操作系统。您可以在各种网站上查看支持的操作系统列表，例如[https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md)，并且您应该记住，无论是微软还是其他公司提供的，CPU和应用场景都将持续增长。'
- en: '**Compatibility:** .NET Core is not only compatible with the .NET Framework,
    but also with Xamarin and Mono, thanks to the .NET Standard Library. As the official
    documentation states, the .NET Standard Library is,'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：.NET Core不仅与.NET Framework兼容，还与Xamarin和Mono兼容，这得益于.NET Standard库。正如官方文档所述，.NET
    Standard库是，'
- en: '"a formal specification of .NET APIs that are intended to be available on all
    .NET runtimes. The motivation behind the Standard Library is establishing greater
    uniformity in the .NET ecosystem. ECMA 335 continues to establish uniformity for
    .NET runtime behavior, but there is no similar spec for the .NET Base Class Libraries
    (BCL) for .NET library implementations."'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “.NET API的正式规范，旨在在所有.NET运行时中可用。标准库背后的动机是在.NET生态系统中建立更大的统一性。ECMA 335继续为.NET运行时行为建立统一性，但对于.NET库实现没有类似的规范。”
- en: '**Deployment:** Perhaps the most interesting feature about runtime is that
    it can be deployed inside an application or installed in a side-by-side user-or
    machine-wide basis'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：关于运行时最有趣的特点可能是它可以在应用程序内部部署或以并排方式安装，适用于用户或机器范围'
- en: '**Distinct command-line options:** All distinct scenarios can be used at the
    command-line tools (and that''s extensible to the rest of the platforms)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独特的命令行选项**：所有独特的场景都可以在命令行工具中使用（并且这可以扩展到其他平台）'
- en: '**Open source:** The .NET Core platform is open source, since its inception.
    It uses MIT and Apache 2 licenses, and the documentation is licensed under Creative
    Commons 4.0 (CC-BY, see [https://creativecommons.org/licenses/by/4.0/](https://creativecommons.org/licenses/by/4.0/)).
    Besides that, .NET Core is a .NET Foundation ([http://www.dotnetfoundation.org/](http://www.dotnetfoundation.org/))
    project'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：.NET Core平台自诞生以来就是开源的。它使用MIT和Apache 2许可证，文档在Creative Commons 4.0（CC-BY）许可下发布（见[https://creativecommons.org/licenses/by/4.0/](https://creativecommons.org/licenses/by/4.0/)）。除此之外，.NET
    Core是.NET Foundation（[http://www.dotnetfoundation.org/](http://www.dotnetfoundation.org/)）的项目'
- en: '**Microsoft''s support:** .NET Core is completely supported by Microsoft, and
    you''ll find plenty of documentation, videos, forums, and so on in promotion sites
    that the company usually encourages as it is indicated in .NET Core Support ([https://www.microsoft.com/net/core/support/](https://www.microsoft.com/net/core/support/))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft的支持**：.NET Core完全由Microsoft支持，您将在公司的推广网站上找到大量文档、视频、论坛等内容，这些内容通常在.NET
    Core支持（[https://www.microsoft.com/net/core/support/](https://www.microsoft.com/net/core/support/)）中提及'
- en: Installation of .NET Core in the IDE
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IDE中安装.NET Core
- en: In [Chapter 1](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml), *The SOLID Principles
    of Software Design*, we mentioned that you could use .NET Core (and ASP.NET Core)
    with any IDE of your choice. However, in this book, I'm using Visual Studio 2017
    due to its integration tools and facilities, and its degree of optimization for
    .NET Core projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml)《软件设计的SOLID原则》中，我们提到您可以使用.NET
    Core（和ASP.NET Core）与您选择的任何IDE一起使用。然而，在这本书中，我使用Visual Studio 2017，因为它集成了工具和设施，并且对.NET
    Core项目的优化程度很高。
- en: Nevertheless, and due to its youth, there's no common installation path for
    all versions of Visual Studio and, depending on the one you use, you'll find two
    different approaches.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，由于其年轻，Visual Studio的所有版本都没有一个共同的安装路径，并且根据您使用的版本，您会发现两种不同的方法。
- en: Installation path for .NET Core in Visual Studio 2015
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio 2015中.NET Core的安装路径
- en: 'If you want to use Visual Studio 2015, you should have Update 3.3 installed.
    It''s available from this link: [https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs](https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs).
    In this site, you''ll see how the update is related to NET Core 1.0.0 and .NET
    Core 1.0.0 SDK Preview 2.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Visual Studio 2015，您应该安装更新3.3。它可以从以下链接获取：[https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs](https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs)。在这个网站上，您将看到更新如何与.NET
    Core 1.0.0和.NET Core 1.0.0 SDK Preview 2相关。
- en: If you're not sure about this version, just check the About Microsoft Visual
    Studio in the Help menu and make sure the version number is 14.0.25424.00 or higher,
    and includes Update 3.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对此版本不确定，请转到帮助菜单中的“关于 Microsoft Visual Studio”，并确保版本号是14.0.25424.00或更高版本，并且包含更新3。
- en: 'You''ll also need:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要：
- en: The **NuGet Manager** extension for Visual Studio (you know, NuGet is the official
    package manager for Microsoft development, and we can be sure that it includes
    .NET Core in all its versions). You need NuGet 3.5.0-beta or higher to build .NET
    Core apps.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 的 **NuGet 管理器** 扩展（你知道，NuGet 是微软开发的官方包管理器，我们可以确信它包含所有版本的 .NET
    Core）。你需要 NuGet 3.5.0-beta 或更高版本来构建 .NET Core 应用程序。
- en: .**NET Core Tooling Preview 2+**, which takes care of project templates and
    other tools for Visual Studio 2015, and you can find it at [https://go.microsoft.com/fwlink/?LinkID=827546](https://go.microsoft.com/fwlink/?LinkID=827546).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .**NET Core 工具预览版 2+**，负责 Visual Studio 2015 的项目模板和其他工具，你可以在 [https://go.microsoft.com/fwlink/?LinkID=827546](https://go.microsoft.com/fwlink/?LinkID=827546)
    找到它。
- en: .NET Core in Visual Studio 2017
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio 2017 中的 .NET Core
- en: The case for Visual Studio 2017 is quite different, since it takes care of the
    installation of prerequisites, as long as you have selected the .NET Core and
    Docker workload during the initial installation process (remember that, in V.
    Studio 2017, installation is made in a modular fashion, so, by default, it only
    installs a minimum set of features).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Visual Studio 2017 来说，情况相当不同，因为它负责安装先决条件，只要你在初始安装过程中选择了 .NET Core 和 Docker
    工作负载（记住，在 Visual Studio 2017 中，安装是模块化的，所以默认情况下，它只安装最小功能集）。
- en: As it happens in the previous case, if you want to make sure about the installed
    version, just check in the Help/About Visual Studio menu, and see if you have
    version 15.0.26020.0 or higher.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的例子中发生的那样，如果你想确认已安装的版本，只需在“帮助/关于 Visual Studio”菜单中进行检查，看看你是否拥有版本 15.0.26020.0
    或更高版本。
- en: Types of deployment
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署类型
- en: We've mentioned how .NET Core allows using two distinct kinds of deployment
    for your apps--**Framework Dependent Deployment** (**FDD**), and **Self-Contained
    Deployment (SCD).** Which one to choose? That will depend on the target system
    and the amount of knowledge and management control that we might have about it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了 .NET Core 允许为你的应用程序使用两种不同的部署方式--**框架依赖部署（FDD**）和**自包含部署（SCD**）。选择哪一个取决于目标系统和我们对它的知识和管理控制程度。
- en: 'Let''s briefly remind ourselves about the main differences between these two
    types of deployment and its implications facing the management and structure of
    the assemblies resulted from any .NET Core compilation process:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下这两种部署类型之间的主要区别及其对任何 .NET Core 编译过程产生的程序集管理和结构的影响：
- en: Framework Dependent relies on a shared version of .NET Core that should be installed
    on the target system. If this is the case, the application is portable between
    installations of .NET Core.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架依赖部署依赖于目标系统上安装的共享 .NET Core 版本。如果这种情况成立，则应用程序可以在 .NET Core 的不同安装之间移植。
- en: Notice that, in this case, the app contains only its own code and any third-party
    dependencies that are outside of the .NET Core libraries. This is because FDDs
    contain `.dll` files that can be launched by means of the `dotnet` utility from
    the command line. Remember that if you launch, for example, the command `dotnet``application1.dll`,
    that's enough to run an application named `application1.dll`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，该应用程序仅包含其自身的代码以及任何位于 .NET Core 库之外的第三方依赖项。这是因为 FDD 包含可以通过命令行中的 `dotnet`
    工具启动的 `.dll` 文件。记住，如果你启动，例如，命令 `dotnet application1.dll`，这就足够运行名为 `application1.dll`
    的应用程序了。
- en: On the other side, SCD apps don't rely on any external code installed on the
    destination system. That is, all components, (and that includes both .NET Core
    libraries and the .NET Core runtime), are included in the final, installable package,
    and are isolated from other .NET Core applications.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一方面，SCD 应用程序不依赖于目标系统上安装的任何外部代码。也就是说，所有组件（包括 .NET Core 库和 .NET Core 运行时）都包含在最终的、可安装的包中，并且与其他
    .NET Core 应用程序隔离。
- en: Consequently, SCDs include an executable (something like `app1.exe` on Windows
    platforms for an app of that name). This is a renamed version of the platform-specific
    .NET Core host, and a DLL file (such as `app.dll`), which is the actual application.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，SCD 包含一个可执行文件（例如，在 Windows 平台上名为 `app1.exe` 的应用程序）。这是特定平台 .NET Core 主机的重命名版本，以及一个
    DLL 文件（例如 `app.dll`），这是实际的应用程序。
- en: So, you're deploying a concrete version of .NET Core as the executable together
    with your application, that will always adopt the form of a DLL, and it will run
    inside the context created by the executable.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，你正在将 .NET Core 的具体版本作为可执行文件与你的应用程序一起部署，它将始终以 DLL 的形式存在，并在由可执行文件创建的上下文中运行。
- en: As you can see, it is a very different approach, and perhaps, the first time
    that we can generate totally independent executable applications with .NET.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常不同的方法，也许是我们第一次能够使用.NET生成完全独立的可执行应用程序。
- en: Checking other dependencies in .NET Core
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在.NET Core中检查其他依赖项
- en: Before we keep on walking through the .NET Core features, it is wise to keep
    in mind that dependency is not only a matter of classes' relations but also about
    the components used to build applications, and the IDE might help us when defining
    and visually analyzing those dependencies even when the application is already
    compiled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续了解.NET Core功能之前，明智的做法是记住，依赖项不仅涉及类之间的关系，还涉及构建应用程序所使用的组件，IDE在定义和可视化分析这些依赖项时可能会帮助我们，即使应用程序已经编译完成。
- en: This is especially important in a framework where these components, are always
    downloaded from NuGet (or any other valid repository) and updated in our projects
    within Visual Studio 2017 in a dynamic manner.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一个框架中，这些组件总是从NuGet（或任何其他有效存储库）下载，并在Visual Studio 2017项目中以动态方式更新，这一点尤为重要。
- en: 'Not taking care of these aspects, might lead to several problems. Among them,
    I''d like to highlight the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不注意这些方面可能会导致许多问题。其中，我想强调以下问题：
- en: Maintainability issues
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性问题
- en: Security flaws
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全漏洞
- en: License misuse
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证滥用
- en: Unwanted dependencies
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要的依赖项
- en: In order to help developers to prevent dependency's issues, from version 2010
    of Visual Studio, the IDE offers the ability to create layer diagrams, which have
    evolved continuously since that version.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发者防止依赖项问题，从Visual Studio 2010版本开始，IDE提供了创建层图的能力，自那个版本以来，这些图一直在持续发展。
- en: With these diagrams, you can express dependencies between layers, and these
    dependencies are not just shown through the diagrams hints but, starting in the
    latest version (2017), in the code itself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些图，您可以表达层之间的依赖关系，这些依赖关系不仅通过图例显示，从最新版本（2017）开始，还在代码本身中显示。
- en: 'When you design one of these diagrams, you can express dependencies using symbols
    provided by the designer that include single and bi-directional dependency, layers,
    and simple shapes, as you can see in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设计这些图之一时，可以使用设计器提供的符号来表达依赖关系，包括单向和双向依赖、层以及简单的形状，正如您可以在以下屏幕截图中所见：
- en: '![](img/2a19ce2c-cefb-4ede-b3ed-6e210595a7a9.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a19ce2c-cefb-4ede-b3ed-6e210595a7a9.png)'
- en: 'This diagram is created using the new menu option related to the Architecture
    menu in the IDE, which also presents some features related to code analysis, such
    as Code Map generation, the possibility to create graphs of those external files
    (graph of `Include Files`), and other features. In all, that option presents the
    following options:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是通过IDE中与架构菜单相关的新菜单选项创建的，它还展示了与代码分析相关的某些功能，例如代码图生成、创建外部文件（包括文件）的图，以及其他功能。总的来说，该选项提供了以下选项：
- en: '![](img/331d0368-7f23-41b6-918c-c77efcda6d18.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/331d0368-7f23-41b6-918c-c77efcda6d18.png)'
- en: Remember that this Architecture menu is only available in V.Studio 2017 Enterprise.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此架构菜单仅在V.Studio 2017 Enterprise中可用。
- en: One of this menu's options is the new Dependency Validation diagram, which launches
    a new editing window, where we can drag and drop elements from the solution, including
    folders, files (C# and VB.NET) and even assemblies. We could consider these features
    as other implementations that the IDE offers to study any applications' dependencies.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这份菜单中的一个新选项是依赖项验证图，它将打开一个新的编辑窗口，在这里我们可以从解决方案中拖放元素，包括文件夹、文件（C# 和 VB.NET）甚至程序集。我们可以将这些功能视为IDE提供的其他实现，用于研究任何应用程序的依赖项。
- en: This technique, has been rebuilt from scratch using Roslyn (refer my book *Mastering
    C# and .NET Framework* also by Pack, for more details and demos about this feature),
    and it allows the coder to configure the editor's behavior in a totally customized
    manner, programming how the IDE should respond when encountering any of these
    features in code (or even in other assemblies, since the tool accepts drag and
    drop already-compiled pieces too).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是从头开始使用Roslyn重建的（参考Pack的《精通C#和.NET Framework》一书，了解更多关于此功能的信息和演示），它允许编码者以完全定制的方式配置编辑器的行为，编程IDE在遇到代码（甚至在其他程序集，因为该工具接受拖放已编译的组件）中的任何这些功能时应如何响应。
- en: Once you establish relations and dependencies in the diagram, this new Intellisense
    will be able to validate the existing code, advising the programmer about the
    conflicting areas inside different application domains.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在图中建立了关系和依赖，这个新的Intellisense将能够验证现有代码，向程序员建议不同应用域内的冲突区域。
- en: Actually, you can activate these features in the configuration in a such a way,
    that, as soon as a problem is detected, you will see a squiggle highlighting your
    offending code, together with an indication of the root of the problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以在配置中激活这些功能，这样一旦发现问题，你将看到一个波浪线突出显示你的违规代码，同时还有一个问题根源的指示。
- en: 'For instance, we can establish which classes are allowed to live in every application''s
    namespace. If a single class is moved to a namespace forbidden by the dependency
    diagram, a hint will be presented in the code editor itself and, also, in the
    Error List window (see the following screenshot):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以确定哪些类可以存在于每个应用程序的命名空间中。如果一个类被移动到依赖关系图中禁止的命名空间，代码编辑器本身将显示提示，同样，在错误列表窗口中也会显示（见以下截图）：
- en: '![](img/84aa0679-a0fb-4a0d-8f76-410e81044608.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84aa0679-a0fb-4a0d-8f76-410e81044608.png)'
- en: Of course, this behavior is also configurable, and these features are independent
    from other options we find in the Analyze menu in relation with Code Metrics,
    Performance Profilers, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种行为也是可配置的，这些功能与其他选项无关，我们在分析菜单中找到的选项，如代码度量、性能分析器等。
- en: Dependency Injection in .NET Core
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的依赖注入
- en: When dealing with the proper features related to Dependency Injection in .NET
    Core, there are a bunch of previous approaches to consider. One of those is the
    mantra `new` is glue, which we often hear as an advice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理与.NET Core相关的依赖注入的正确功能时，有许多先前的方法需要考虑。其中之一是“new”是粘合剂的格言，这是我们经常作为建议听到的。
- en: This means that whenever you create a new instance of a class (you use the `new`
    keyword), there's some code cohesion behind the scenes. You're establishing that
    the class that defines that instance is going to have a dependency on the instantiated
    class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次你创建一个类的新的实例（你使用`new`关键字），在幕后都有一些代码的凝聚力。你是在建立这样一个事实，即定义该实例的类将依赖于实例化的类。
- en: We've seen how to get rid of that problem via factories, or using third-party
    libraries focused on the DI problem and how they can be used, but, in this chapter,
    we're going to rely on those features provided by the framework itself to achieve
    the same results.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过工厂或使用专注于DI问题的第三方库来解决这个问题，但在这个章节中，我们将依靠框架本身提供的这些功能来实现相同的结果。
- en: Ideally, that's something that we could define and, once the definition is registered,
    every time we need an instance of any of the predefined classes, something else
    should take care of providing that instance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这是我们能够定义的，一旦定义注册，每次我们需要任何预定义类的实例时，其他东西应该负责提供这个实例。
- en: In other words, the behavior we've seen related to other DI containers should
    (more or less) be present here as well, and cover the most important features
    that those veteran containers offer, including an object's lifetime, registration,
    and definition of generic classes and interfaces, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们看到的与其他DI容器相关的行为（或多或少）也应该在这里存在，并涵盖那些资深容器提供的重要功能，包括对象的生命周期、注册和泛型类和接口的定义等。
- en: DI Architecture and Object's Lifetime
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI架构和对象的生命周期
- en: 'Considering the preceding points, and even knowing that we''re dealing with
    an initial version of the frameworks, the .NET Core team designed Dependency Injection
    features based on two ideas:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面提到的点，即使我们知道我们正在处理框架的初始版本，.NET Core团队设计了基于两个想法的依赖注入功能：
- en: On one side, there was already existing functionality, that could be perfectly
    extended to work inside .NET Core
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一方面，已经存在的一些功能，可以完美地扩展到.NET Core内部工作
- en: On the other side, they thought that it would be wise to include the most used
    features present in other initiatives, (either Microsoft's or external) like those
    present in Prism Patterns & Practices or third party DI Containers (remember the
    four containers we saw in previous chapters)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一方面，他们认为将其他倡议中最常用的功能包含在内是明智的，无论是微软的还是外部的，比如那些在Prism Patterns & Practices或第三方DI容器中存在的功能（记得我们在前几章中看到的四个容器）
- en: Consequently (following these ideas), when dealing with an object's lifetime,
    .NET Core presents three types, depending on the way instances will be configured
    and used--Singleton, Scoped, and Transient.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此（遵循这些想法），在处理对象的生存周期时，.NET Core提供了三种类型，这取决于实例的配置和使用方式--单例（Singleton）、作用域（Scoped）和瞬态（Transient）。
- en: These options do not only have influence in the way we define them, but also
    in the way we can use them, and in some cases, thread safe precautions, and other
    aspects should be considered.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些选项不仅影响我们定义它们的方式，还影响我们使用它们的方式，在某些情况下，还需要考虑线程安全预防措施和其他方面。
- en: In the Singleton option, a unique instance of the object is used (meaning that
    we only manage a reference to the object). Any further request uses the same instance,
    according to the singleton pattern.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单例选项中，使用对象的唯一实例（这意味着我们只管理对象的引用）。任何进一步的请求都使用相同的实例，根据单例模式。
- en: The Scoped version is local to the context in which it is used and doesn't extend
    beyond that context.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域版本仅限于其使用的上下文，不会超出该上下文。
- en: Finally, the Transient option creates a new instance of the class every time
    is requested.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，每次请求时，瞬态选项都会创建该类的新实例。
- en: 'Although included in the ASP.NET Core documentation, Microsoft provides the
    following diagram in relation to these options:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然包含在ASP.NET Core文档中，但Microsoft提供了以下图表，与这些选项相关：
- en: '![](img/f55299db-672f-4987-ac1d-d401ea3d01b2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f55299db-672f-4987-ac1d-d401ea3d01b2.png)'
- en: Since, in the real world, this functionality is mainly linked to ASP.NET Core
    apps, services and middleware show up with functionality that helps in the task
    (that's why those references are to the *request*). But it actually works equally
    well in pure .NET Core applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在现实世界中，此功能主要与ASP.NET Core应用程序、服务和中间件相关联，因此它们会显示有助于任务的函数（这就是为什么那些引用是针对*请求*的）。但实际上，它同样适用于纯.NET
    Core应用程序。
- en: As we mentioned at the beginning, a big part of this functionality is related
    to the `Microsoft.Extensions.DependencyInjection` namespace, included in a DLL
    of the same name, which can work in conjunction with another helper DLLs such
    as `Microsoft.Extensions.DependencyInjection.Abstractions` and others.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们最初提到的，这部分功能与`Microsoft.Extensions.DependencyInjection`命名空间相关，该命名空间包含同名的DLL，它可以与另一个辅助DLL（如`Microsoft.Extensions.DependencyInjection.Abstractions`）和其他DLL一起工作。
- en: Concretely, the `IServiceCollection` interface is the base of a set of classes
    that provide methods to instantiate objects (usually called services in this context)
    via DI using these three options. We'll see this in action in the next sections,
    but also in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency
    Injection in ASP.NET Core,* dedicated to ASP.NET Core.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，`IServiceCollection`接口是一组提供方法的类的基类，这些方法可以通过DI使用这三种选项来实例化对象（在这个上下文中通常称为服务）。我们将在下一节中看到这一点，但也会在[第4章](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml)，*ASP.NET
    Core中的依赖注入*中看到，该章节专门介绍ASP.NET Core。
- en: The class ActivatorUtilities and other helpers
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ActivatorUtilities`类和其他辅助类'
- en: Before we get into the demos, keep in mind that the number of classes included
    in this namespace is pretty large, since it pretends to offer a wide coverage
    while still being multi-platform.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入演示之前，请记住，这个命名空间中包含的类数量相当大，因为它试图提供广泛的覆盖范围，同时仍然是多平台的。
- en: One of these cases is the class `ActivatorUtilities` class, also included in
    the `Microsoft.Extensions.DependencyInjection` library, which contains static
    methods to help in the configuration and implementation of services, instances,
    and factories that ease DI management and control.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是`ActivatorUtilities`类，它也包含在`Microsoft.Extensions.DependencyInjection`库中，该库包含静态方法，有助于配置和实现服务、实例和工厂，从而简化DI管理和控制。
- en: Thus, in case you find yourself missing some feature or functionality, take
    a look at the documentation at [http://docs.microsoft.com](http://docs.microsoft.com),
    but, keep in mind that you'll find that it is related to ASP.NET Core.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你发现自己缺少某些功能或功能，请查看[http://docs.microsoft.com](http://docs.microsoft.com)上的文档，但请注意，你会发现它与ASP.NET
    Core相关。
- en: This means that most of the implementations that you will see (on the internet
    and other sources) are not going to be linked to .NET Core apps, but to ASP.NET
    Core apps, in which, much of this functionality is implemented by default for
    different scenarios.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你将在互联网和其他来源看到的大多数实现都不会链接到.NET Core应用程序，而是链接到ASP.NET Core应用程序，在这些应用程序中，许多此类功能默认为不同场景实现。
- en: Obviously, there's much more inside those classes that we cannot cover in a
    single chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些类中还有更多内容，我们无法在一个章节中全部涵盖。
- en: 'To give you an idea of the possibilities linked to this class, I''m including
    a summary of its functionality presented in the official documentation, reminding
    you of each method and its main purpose:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解与这个类相关的可能性，我包括了一个官方文档中呈现的功能摘要，提醒你每个方法和其主要用途：
- en: '| **Methods summary** | **Description** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **方法摘要** | **描述** |'
- en: '| [CreateFactory(Type, Type[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateFactory_System_Type_System_Type___)
    | Create a delegate that will instantiate a type with constructor arguments provided
    directly and/or from a `System.IServiceProvider`. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| [CreateFactory(Type, Type[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateFactory_System_Type_System_Type___)
    | 创建一个委托，该委托将使用直接提供的构造函数参数和/或从 `System.IServiceProvider` 提供的参数实例化一个类型。|'
- en: '| [CreateInstance(IServiceProvider, Type, Object[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance_System_IServiceProvider_System_Type_System_Object___)
    | Instantiate a type with constructor arguments provided directly and/or from
    a `System.IServiceProvider`. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| [CreateInstance(IServiceProvider, Type, Object[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance_System_IServiceProvider_System_Type_System_Object___)
    | 使用直接提供的构造函数参数和/或从 `System.IServiceProvider` 提供的参数实例化一个类型。|'
- en: '| <p>[CreateInstance<T>(IServiceProvider, Object[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance__1_System_IServiceProvider_System_Object___)
    | Instantiate a type with constructor arguments provided directly and/or from
    a `System.IServiceProvider`. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <p>[CreateInstance<T>(IServiceProvider, Object[])](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance__1_System_IServiceProvider_System_Object___)
    | 使用直接提供的构造函数参数和/或从 `System.IServiceProvider` 提供的参数实例化一个类型。|'
- en: '| [GetServiceOrCreateInstance(IServiceProvider, Type)](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance_System_IServiceProvider_System_Type_)
    | Retrieve an instance of the given type from the service provider. If one is
    not found, then instantiate it directly. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| [GetServiceOrCreateInstance(IServiceProvider, Type)](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance_System_IServiceProvider_System_Type_)
    | 从服务提供程序中检索给定类型的实例。如果没有找到，则直接实例化。|'
- en: '| [GetServiceOrCreateInstance<T>(IServiceProvider)](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance__1_System_IServiceProvider_)
    | Retrieve an instance of the given type from the service provider. If one is
    not found, then instantiate it directly. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| [GetServiceOrCreateInstance<T>(IServiceProvider)](https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance__1_System_IServiceProvider_)
    | 从服务提供程序中检索给定类型的实例。如果没有找到，则直接实例化。|'
- en: It's now time to start working with the main classes related to DI inside the
    `**Microsoft.Extensions.DependencyInjection**` and `**Microsoft.Extensions.DependencyInjection.Abstractions**`
    libraries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始使用 `**Microsoft.Extensions.DependencyInjection**` 和 `**Microsoft.Extensions.DependencyInjection.Abstractions**`
    库中与依赖注入相关的主要类了。
- en: The Microsoft.Extensions.DependencyInjection container
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft.Extensions.DependencyInjection 容器
- en: Most of the samples that you'll see on the internet about Dependency Injection
    and .NET Core will reference to ASP.NET Core applications since it comes by default
    when you use the predefined template inside Visual Studio.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你在网上看到的关于依赖注入和 .NET Core 的大多数示例都将引用 ASP.NET Core 应用程序，因为当你使用 Visual Studio 内置的预定义模板时，它默认包含。
- en: However, the use of ASP.NET Core applications is not mandatory if you want to
    see how DI works from scratch. That being said, we will have to configure the
    registering of our services manually. This implies certain extra aspects such
    as severity levels, an object's lifetime, and disposable features if we want this
    architecture to work seamlessly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想从头开始了解依赖注入的工作原理，使用 ASP.NET Core 应用程序并不是强制性的。也就是说，我们必须手动配置服务的注册。这意味着某些额外的方面，例如严重级别、对象的生存期以及可处置功能，如果想让这种架构无缝工作。
- en: Since .NET Core offers its own container linked to the external library `Microsoft.Extensions.DependencyInjection`
    (now, in version 2.0), we'll have to reference it via NuGet packages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .NET Core 提供了自己的容器，与外部库 `Microsoft.Extensions.DependencyInjection` 链接（现在在
    2.0 版本中），我们必须通过 NuGet 包引用它。
- en: 'For a first demo, we can create a simple .NET Core Console application, reference
    the library using the NuGet package plug-in, and look for its name online. You''ll
    observe that when you filter for that name, the NuGet Package Manager, presents
    several versions of the library (see the following screenshot):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次演示，我们可以创建一个简单的 .NET Core 控制台应用程序，使用 NuGet 包插件引用库，并在网上查找其名称。你会发现，当你过滤该名称时，NuGet
    包管理器会显示该库的几个版本（见以下截图）：
- en: '![](img/b65efcfb-babb-4daf-81f2-c70983dd38e3.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b65efcfb-babb-4daf-81f2-c70983dd38e3.png)'
- en: As you see, other libraries are also declared as complementary (`Microsoft.Extensions.DependencyInjection.Abstractions`,
    and `Microsoft.Extensions.DependencyInjection.Specification.Tests`). The first
    one (the `Abstractions`) should also appear as referenced inside our project once
    the installation is completed. But for now, let's focus on the main library.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，其他库也被声明为补充的（`Microsoft.Extensions.DependencyInjection.Abstractions` 和 `Microsoft.Extensions.DependencyInjection.Specification.Tests`）。第一个（`Abstractions`）在安装完成后也应该出现在我们的项目中作为引用。但就目前而言，让我们专注于主要库。
- en: At this moment, don't be scared of the following dialog box. It will tell you
    that a whole bunch of libraries is going to be updated, and another set of libraries
    will be installed anew. The reason for this might be double--on one side, the
    use of the latest versions of this library implies updating other previously referenced
    libraries according to an internal library dependency manager that Visual Studio
    2017 uses.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，不要害怕下面的对话框。它会告诉你将更新一大堆库，并且还将安装另一组新的库。原因可能是双重的——一方面，使用该库的最新版本意味着根据 Visual
    Studio 2017 使用的内部库依赖管理器更新先前引用的其他库。
- en: On the other side, installation of some new libraries, like this one, might
    imply other dependencies, so we end up with two distinct areas of updates (go
    to the Dependencies section in the Solution Explorer after installation).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，安装一些新的库，如这个库，可能意味着其他依赖项，因此我们最终有两个不同的更新区域（安装后转到解决方案资源管理器中的依赖项部分）。
- en: 'Visual Studio 2017 will offer a list of every library being updated and if
    you scroll down a bit, also the list of all the dependent libraries:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017 将列出所有正在更新的库，如果你向下滚动一点，还会显示所有依赖库的列表：
- en: '![](img/b5e0f7ef-5266-4279-b903-81b9dde13c74.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5e0f7ef-5266-4279-b903-81b9dde13c74.png)'
- en: After this dialog box, you'll be presented another one with the License Acceptance
    of each one of the libraries. Once completed, another entry in your Dependencies
    section of the Solution Explorer will show up, pointing to NuGet. That's where
    you'll find all that new stuff.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对话框之后，你将看到一个包含每个库许可接受的新对话框。完成后，解决方案资源管理器依赖项部分将出现另一个条目，指向 NuGet。那里你可以找到所有新东西。
- en: A further look at those new entries will reveal all the main and dependent libraries
    linked to that DependencyInjection reference, which might be a few.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步查看这些新条目将揭示与那个 DependencyInjection 引用链接的所有主要和依赖库，可能有一些。
- en: Since, initially, we just want to make a test of how this namespace works, we'll
    start testing it in a very simple manner (Legit is to say that I was inspired
    by Jurgen Gustch's blog's entry Using Dependency Injection in .NET Core Console
    Apps, because, for this initial approach, I found it especially suitable and explanatory).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最初只想测试这个命名空间的工作方式，我们将以非常简单的方式进行测试（可以说，我受到了 Jurgen Gustch 的博客文章《在 .NET Core
    控制台应用程序中使用依赖注入》的启发，因为对于这种初始方法，我发现它特别适合且具有解释性）。
- en: So, I've modified those ideas to create a couple of classes, in which the first
    one happens to have dependencies on the other (that is, the first class references
    the second).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我修改了这些想法来创建几个类，其中一个类恰好依赖于另一个（即，第一个类引用第二个类）。
- en: Just for the matter of completeness, I included an extra method to check the
    right moment in which it was invoked, and also implemented the `IDisposable` interface
    to be able to convey information about disposal by the Garbage Collector (more
    about that later).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了完整性，我增加了一个额外的方法来检查调用正确的时间，并且实现了 `IDisposable` 接口，以便能够通过垃圾回收器传达有关销毁的信息（关于这一点稍后讨论）。
- en: 'So, I ended with this code (outside of the class `Program` class that the template
    creates by default):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我最终得到了以下代码（在默认由模板创建的 `Program` 类之外）：
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice also that `DependencyClass1` takes care of disposing `DependencyClass2`,
    once it's done with it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`DependencyClass1` 会负责在完成使用后销毁 `DependencyClass2`。
- en: 'Now it comes when the `DependencyInjection` classes are needed. First, we make
    a reference to the corresponding namespace on top of our code (only two namespaces
    are required for this simple demo):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是当需要 `DependencyInjection` 类的时候。首先，我们在代码顶部引用相应的命名空间（对于这个简单的演示只需要两个命名空间）：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, inside the `Program` class, we need to register and use these classes.
    The first step is performed using a new instance of the `ServiceCollection` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Program` 类中，我们需要注册和使用这些类。第一步是使用 `ServiceCollection` 类的新实例来执行。
- en: 'Inside that class, we find methods to register all required services in a way
    that at the same time, configures the object''s lifetime mentioned previously,
    as you can see in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们可以找到注册所有所需服务的方法，同时配置了之前提到的对象的生命周期，如下面的截图所示：
- en: '![](img/73ac9339-cc80-4532-b126-17912c57a125.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73ac9339-cc80-4532-b126-17912c57a125.png)'
- en: As we will see further on, we're provided with two versions of every method--generic
    and a non-generic. This gives us more flexibility to integrate different classes
    and services into our DI architecture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们稍后将会看到的，我们提供了每个方法的两个版本--通用和非通用。这为我们提供了更多的灵活性，可以将不同的类和服务集成到我们的依赖注入架构中。
- en: For this initial version, we're using the `AddTransient` generic version of
    the methods, which will return new instances of every class, every time we make
    a reference in the code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个初始版本，我们使用方法的 `AddTransient` 通用版本，每次我们在代码中创建引用时，它将返回每个类的新的实例。
- en: Once our classes are registered, a provider has to be built with that definition.
    That's something we perform with a call to `BuildServiceProvider()` on the `ServicesCollection`
    class just created (we'll go back to service providers later on). But, for now,
    suffice to say that an instance of the `IServiceProvider` interface will be created
    and configured to manage any request for one of the classes previously registered
    using the `Add*` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的类注册完毕，就需要根据这个定义构建一个提供者。这是通过在刚刚创建的 `ServicesCollection` 类上调用 `BuildServiceProvider()`
    来完成的（我们稍后会回到服务提供者）。但就现在而言，只需说一个 `IServiceProvider` 接口的实例将被创建并配置为管理使用 `Add*` 方法注册的任何先前注册的类的请求即可。
- en: Another thing to point out is that the way objects are instantiated follows
    the lazy creation pattern that you, reader, which you might already know from
    other contexts, such as LINQ. That means until the first instance of a DI Object
    is requested, nothing gets created.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要指出的是，对象的实例化遵循了您可能已经从其他上下文（如 LINQ）中了解的懒加载模式。这意味着直到请求第一个 DI 对象的实例之前，不会创建任何内容。
- en: So, even if we don't do anything (useful) with these classes, once the `DependencyClass1`
    is requested, the entire dependency injection mechanism is started.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们不做任何（有用）的事情，一旦请求 `DependencyClass1`，整个依赖注入机制就会启动。
- en: 'The following code is modified in the class `Program` class to configure this
    architecture:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在 `Program` 类中被修改以配置此架构：
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see in the following output, everything works as expected:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下输出中看到的，一切按预期工作：
- en: '![](img/b31ea530-6e2e-4210-bb84-25a5dc0278c6.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b31ea530-6e2e-4210-bb84-25a5dc0278c6.png)'
- en: The code shows how whenever we need an instance of a class, we issue a call
    to the generic `GetService()` method and we can start using it in the next sentence.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码展示了每当我们需要一个类的实例时，我们都会调用通用的 `GetService()` 方法，并且我们可以在下一句中开始使用它。
- en: Another aspect to notice is that the reference to `DependencyClass2` goes first,
    and so it does its disposal. Remember that the constructor of `DependencyClass1`
    receives an instance of `DependencyClass2`, so, it doesn't finish until the latter
    is totally created.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的方面是，对 `DependencyClass2` 的引用先出现，因此它先进行清理。请记住，`DependencyClass1` 的构造函数接收
    `DependencyClass2` 的一个实例，所以它不会完成，直到后者完全创建。
- en: Also, before disposing of the first class, we call on `Dispose` of the second,
    that's why the order is inverted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在处置第一个类之前，我们调用第二个类的 `Dispose`，这就是为什么顺序是相反的。
- en: Checking the object's lifetime
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查对象的生命周期
- en: Another important aspect of this architecture that we should consider carefully,
    is the way our instances are obtained from the point of view of its lifetime.
    Let's see the differences in this very demo, adding references and changing the
    way they are registered into the `IServiceProvider` class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该仔细考虑的此架构的另一个重要方面，是从其生命周期的角度来看我们如何获取实例。让我们看看在这个演示中的差异，添加引用并更改它们在 `IServiceProvider`
    类中的注册方式。
- en: 'What happens if we create another instance of the first class? As expected,
    when we change the `using` block of code to include another instance of `DependencyClass1`,
    such as in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为第一个类创建另一个实例会发生什么？正如预期的那样，当我们将代码中的 `using` 块改为包含 `DependencyClass1` 的另一个实例时，例如以下代码：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output changes noticeably since we''re forcing the engine to create a new
    instance, instead of reusing the previous one:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出发生了明显的变化，因为我们迫使引擎创建一个新的实例，而不是重用之前的实例：
- en: '![](img/71199e7d-4332-42c9-8a8b-bdf7818bd845.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71199e7d-4332-42c9-8a8b-bdf7818bd845.png)'
- en: As seen in the preceding screenshot, we're making the DI engine call the constructor
    twice, because we're using the `AddTransient()` version of the `services` configuration
    object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们让 DI 引擎调用构造函数两次，因为我们使用了 `services` 配置对象的 `AddTransient()` 版本。
- en: However, in this scenario, if we change the registration method for `AddScoped`
    of `AddSingleton`, we would be reusing the same instance of the objects, and therefore,
    saving memory and resources.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，如果我们更改 `AddSingleton` 的 `AddScoped` 注册方法，我们将重用相同的对象实例，因此可以节省内存和资源。
- en: 'For instance, by just changing those two lines of code in this manner:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，只需以这种方式更改这两行代码：
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can check the different creation behavior with a simple look at the corresponding
    output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地查看相应的输出来检查不同的创建行为：
- en: '![](img/375fd621-ba77-41e2-93b5-ac9f6ca12f07.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/375fd621-ba77-41e2-93b5-ac9f6ca12f07.png)'
- en: As you can see, the `CurrentTime` function is still called twice, but the number
    of instances in use is only one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`CurrentTime` 函数仍然被调用了两次，但正在使用的实例数量只有一个。
- en: And, in this case, we would get exactly the same output using the `AddSingleton<>()`
    methods, since, in this scenario, there is a coincidence and no more than one
    instance is going to be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用 `AddSingleton<>()` 方法得到完全相同的输出，因为在这种情况下，存在一个巧合，并且不会使用超过一个实例。
- en: Another interesting aspect of the functionality provided by this service is
    that being a generic collection itself, it is possible to add/remove/clear instances
    of services at runtime, so we can always have total control of what it is inside
    the collection and the order in which is defined and instantiated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务提供的功能的另一个有趣方面是，作为一个泛型集合本身，我们可以在运行时添加/删除/清除服务实例，因此我们可以始终完全控制集合中的内容以及定义和实例化的顺序。
- en: To that purpose, we find methods such as `Clear()`, `Contains()`, `IndexOf()`,
    `Insert()`, `InsertAt()`, `Remove` and `RemoveAt()`, just like we would find in
    any other generic collection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们找到了像 `Clear()`、`Contains()`、`IndexOf()`、`Insert()`、`InsertAt()`、`Remove`
    和 `RemoveAt()` 这样的方法，就像我们在任何其他泛型集合中找到的方法一样。
- en: Mapping interfaces to instance classes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将接口映射到实例类
- en: The previous demo is simple enough to understand the basics of DI inside the
    `Microsoft.Extensions.DependencyInjection` library, but, most likely, in a real
    application, you will have some interfaces defined and a series of classes that
    implement those interfaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的演示足够简单，可以理解 `Microsoft.Extensions.DependencyInjection` 库内部的依赖注入（DI）的基本原理，但在实际应用中，你可能会定义一些接口和一系列实现这些接口的类。
- en: In such a case, it is more convenient to be able to map interfaces to classes
    that implement them, so you just have to ask for an implementation of the corresponding
    interface, thinking on the functionality the interface provides (the business
    problem to be solved), rather than in the concrete class that implements it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，能够将接口映射到实现它们的类会更方便，因此你只需请求相应接口的实现，思考接口提供的功能（要解决的问题的业务问题），而不是实现它的具体类。
- en: Another advantage is that we're able to change the definitions at runtime (remember,
    it's a collection where we can add/remove items), so it is perfectly possible
    to redefine any previous mapping to a new one, according to our applications'
    needs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是我们能够在运行时更改定义（记住，这是一个我们可以添加/删除项的集合），因此根据我们应用程序的需求，重新定义任何之前的映射到新的映射是完全可能的。
- en: 'As in the preceding demo, we''re using a very simple approach to see this in
    action. I''ve created two interfaces, and two classes that implement them, with
    a single method that writes a basic message to the `Console`. This is the initial
    code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的演示一样，我们使用一个非常简单的方法来展示这一点。我创建了两个接口和两个实现它们的类，每个类都有一个将基本消息写入`Console`的方法。这是初始代码：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is a correspondence between classes and interfaces, so we can now refer
    to the interface and let the DI engine decide which class instance is returned
    to us. This is quite similar to the demos we saw in the previous chapter when
    using third-party DI containers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类和接口之间存在对应关系，因此我们现在可以引用接口，让DI引擎决定返回给我们哪个类实例。这与我们在上一章使用第三方DI容器时看到的演示非常相似。
- en: With that purpose, the `ServiceCollection` class supports an alternative way
    of defining references in which you can pass (generic signature) an interface
    name and the class that maps such interface when a `GetService<Interface>()` is
    called.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，`ServiceCollection`类支持一种定义引用的替代方式，在调用`GetService<Interface>()`时，你可以传递（泛型签名）一个接口名称和映射该接口的类。
- en: At the time of requesting one of these implementations, we will ask for an instance
    of the predefined interface, rather than a concrete class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求这些实现之一时，我们将请求预定义接口的实例，而不是具体类。
- en: Note that we also have an alternative way to ask for a service by means of the
    `GetRequiredService<Interface>()` method, that throws an exception if the service
    type isn't registered.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还有通过`GetRequiredService<Interface>()`方法请求服务的另一种方式，如果服务类型未注册，它会抛出异常。
- en: 'Assuming this change, the implementation of the demo is quite simple:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个变更，演示的实现相当简单：
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unlike the previous case, we don't ask for a given class, but the class implements
    the required interface.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一种情况不同，我们不请求一个特定的类，而是请求实现所需接口的类。
- en: 'The output is, again, as expected (see the following screenshot):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出再次符合预期（见以下截图）：
- en: '![](img/8eb2f516-7118-402d-a140-fc036cdb5850.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8eb2f516-7118-402d-a140-fc036cdb5850.png)'
- en: Notice that the registration works in a similar way to what we already saw in
    other DI containers. That is, if we use this syntax, that latest registered mapping
    is the one returned, although that can be changed dynamically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，注册的方式与我们之前在其他DI容器中看到的方式类似。也就是说，如果我们使用这种语法，最新注册的映射就是返回的映射，尽管这可以动态地改变。
- en: Another very useful feature is the `GetServices<Interface>` method, since it
    allows us to recover all registered services and invoke them at will.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是`GetServices<Interface>`方法，因为它允许我们恢复所有已注册的服务并随意调用它们。
- en: 'We can prove this by adding a couple of new classes that implement the same
    interfaces and register them together with the previous ones:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加几个实现相同接口的新类并将它们与之前的类一起注册来证明这一点：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After these definitions, we register both classes under the same Interface
    contracts, so they can be accessed altogether:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些定义之后，我们在相同的接口合约下注册这两个类，因此它们可以一起访问：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since we're using the defined interface functionality, we know all of them will
    implement the `WriteXML()` function, even if they do it differently.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是定义的接口功能，我们知道它们都将实现`WriteXML()`函数，即使它们实现的方式不同。
- en: 'You can appreciate the different calls in the corresponding output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在相应的输出中看到不同的调用：
- en: '![](img/bf46316e-d5cd-4b7f-ba67-9aa2e14c886d.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf46316e-d5cd-4b7f-ba67-9aa2e14c886d.png)'
- en: Another alternative way to get the whole list of services is, of course, from
    the `services` collection itself. To perform this, we need another helper class
    also provided by the `Microsoft.Extensions.DependencyInjection` library.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 获取整个服务列表的另一种替代方法，当然是从 `services` 集合本身。为此，我们需要另一个由 `Microsoft.Extensions.DependencyInjection`
    库提供的辅助类。
- en: 'In this case, the procedure is to create a `ServiceDescriptor` collection that
    holds the information of all services in our `ServiceCollection` class. We use
    an enumerator and the `CopyTo()` method (which expects a `ServiceCollection` as
    the first argument) to create such a collection:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，过程是创建一个包含我们 `ServiceCollection` 类中所有服务信息的 `ServiceDescriptor` 集合。我们使用枚举器和
    `CopyTo()` 方法（它期望 `ServiceCollection` 作为第一个参数）来创建这样一个集合：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the collection is copied to the `ServiceDescriptor` collection, we can
    see at least five interesting properties that might, later on, be used to determine
    the service we need in a given scenario:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合被复制到 `ServiceDescriptor` 集合时，我们可以看到至少五个可能后来用于确定在特定场景中所需服务的有趣属性：
- en: '![](img/f6b2b26e-c182-48c3-8ab1-81c0b127b75e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6b2b26e-c182-48c3-8ab1-81c0b127b75e.png)'
- en: 'Notice that here we''re asking for the `ImplementationType` property to obtain
    all defined types:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们请求 `ImplementationType` 属性以获取所有定义的类型：
- en: '![](img/99b1f3a4-c3c8-418d-81de-acb1b0149376.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99b1f3a4-c3c8-418d-81de-acb1b0149376.png)'
- en: This gives us a clue on how to select a single service independently of its
    position in the collection. Another helper method linked to this functionality
    is the simple `Contains()` that asks for a `ServiceDescriptor` object as its unique
    argument.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了如何独立于服务在集合中的位置来选择单个服务的线索。与这一功能相关联的另一个辅助方法是简单的 `Contains()` 方法，它要求一个唯一的
    `ServiceDescriptor` 对象作为其参数。
- en: 'Another easy way to get information about the currently registered components
    in our services container is by iterating through it directly, using a simple
    `foreach` loop:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取我们服务容器中当前注册的组件的信息，另一个简单的方法是直接遍历它，使用一个简单的 `foreach` 循环：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that depending on the way the services are registered and other programming
    features, not all the properties will have a value (in this case, it only makes
    sense asking for the interfaces (`ServiceType`), the implementations (`Types`)
    and their lifetimes).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据服务注册的方式和其他编程功能，并非所有属性都将有值（在这种情况下，只请求接口（`ServiceType`）、实现（`Types`）及其生命周期是有意义的）。
- en: 'This is also useful when we have more than a class that implements the same
    interface, because we can decide which one we need based on these values:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们有多个实现相同接口的类时也很有用，因为我们可以根据这些值来决定我们需要哪一个：
- en: '![](img/76036b1f-e60a-49f7-b72d-93e854a66e4c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76036b1f-e60a-49f7-b72d-93e854a66e4c.png)'
- en: Additionally, it's possible to use some helper classes linked to the namespaces
    here implied, to perform registrations `a posteriori`. For instance, the `ServiceProviderServiceExtensions`
    class contains a static method capable of obtaining a given `ServiceType` linked
    to a certain provider.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用一些与这里暗示的命名空间相关联的辅助类来执行 `a posteriori` 注册。例如，`ServiceProviderServiceExtensions`
    类包含一个静态方法，能够获取与特定提供者相关联的给定 `ServiceType`。
- en: In other words, you can get an instance of a registered service without using
    the `ServiceCollection` that registered it, as long as you can pass the corresponding
    provider as an argument.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，只要你能传递相应的提供者作为参数，你就可以获取一个已注册服务的实例，而无需使用注册它的 `ServiceCollection`。
- en: I've created a variant of the previous demo, this time including a read-only
    property in each of the `*writer` classes to hold a unique identifier (a `GUID`),
    so it is easy to determine if we're using the same or another instance of the
    service.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了一个之前演示的变体，这次在每个 `*writer` 类中包含一个只读属性来保存一个唯一的标识符（一个 `GUID`），这样就可以很容易地确定我们是否正在使用相同的或另一个服务实例。
- en: 'Consider the following code (a variant of the previous demo):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码（前一个演示的变体）：
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we''re using two distinct approaches to get the same instance
    (identified by its `GUID`). We can test it by comparing both outputs (see the
    following screenshot):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用两种不同的方法来获取相同的实例（通过其 `GUID` 标识）。我们可以通过比较两个输出（见以下截图）来测试它：
- en: '![](img/76e66637-4315-42cd-b072-4ebfcd7403b3.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76e66637-4315-42cd-b072-4ebfcd7403b3.png)'
- en: This could be especially useful in situations in which, for whatever reason,
    a call to services is not suitable or convenient.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种情况下可能特别有用，在这种情况下，出于某种原因，调用服务可能不适合或不方便。
- en: Providers can also be obtained via helper classes, besides the `BuildServiceProvider`
    method of `ServiceCollection`. To do so, we can use the `CreateDefaultServiceProvider`
    class, which also has instance methods to create, either a provider or a `Builder`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ServiceCollection`的`BuildServiceProvider`方法之外，还可以通过辅助类获取提供者。为此，我们可以使用`CreateDefaultServiceProvider`类，它也有实例方法来创建提供者或`Builder`。
- en: 'For the time being, those two are the only possibilities available to that
    class, but it can also be quite useful in certain scenarios where we prefer the
    service collection not to be used:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这两个是该类唯一可用的可能性，但在某些场景中，它也可以非常有用，在这些场景中我们更愿意不使用服务集合：
- en: '![](img/be316783-9b1c-4f05-af4f-579fb1b2ed8e.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be316783-9b1c-4f05-af4f-579fb1b2ed8e.png)'
- en: 'The following code has the provider created via the `DefaultServiceProvider`
    class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是通过`DefaultServiceProvider`类创建的提供者：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I omit the output here, since it's exactly the same as in the previous demos,
    and you can check it yourself within the code accompanying this chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里省略了输出，因为它与之前的演示完全相同，你可以在本章伴随的代码中自行检查。
- en: This is not the only way in which we can obtain a service provider. Yes, there's
    another one, linked to the static method `BuildServiceProvider` of the `ServiceCollectionContainerBuilderExtensions`
    class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们获取服务提供者的唯一方式。是的，还有另一种方式，与`ServiceCollectionContainerBuilderExtensions`类的静态方法`BuildServiceProvider`相关联。
- en: 'In this case, programming it is even easier, since we don''t need any instance
    of the class, and the code gets reduced to the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编程甚至更简单，因为我们不需要类的任何实例，代码简化为以下代码：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just to get exactly the same results as we did before (again, I omit the output).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了得到与我们之前相同的结果（再次，我省略了输出）。
- en: The concept of Scope Applied to services
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将作用域概念应用于服务
- en: When dealing with services and other DI-related functionality, an important
    point to define is its scope. DI documentation defines the scope of a service
    closely related to its lifetime, and therefore, with the moment in which that
    service should be disposed of by the Garbage Collector.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理服务和与DI相关的其他功能时，一个重要的问题是定义其范围。DI文档将服务的范围与其生命周期紧密相关联，因此，与垃圾收集器应该销毁该服务的时刻相关联。
- en: We have talked about the Transient and Singleton lifetimes previously, but the
    Scope lifetime is, indeed, a bit more confusing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过Transitory和Singleton的生命周期，但Scope生命周期确实有点令人困惑。
- en: Concretely, the `IServiceDispose` interface, which implements the `IDispose`
    interface, holds the method `Disposed of()`, method which, when called, ends the
    scope lifetime. It is included inside the `Microsoft.Extensions.DependencyInjection.Abstractions.dll`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，实现了`IDisposable`接口的`IServiceDispose`接口包含了一个`Disposed of()`方法，该方法在调用时结束作用域生命周期。它包含在`Microsoft.Extensions.DependencyInjection.Abstractions.dll`中。
- en: 'In more detail, the documentation states: "*Once this is disposed of, any scoped
    services that have been resolved from the* *M**icrosoft.Extensions.DependencyInjection.IServiceScope.ServiceProvider
    will also be disposed of"*.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，文档中声明：“*一旦此对象被销毁，从* *M**icrosoft.Extensions.DependencyInjection.IServiceScope.ServiceProvider解析出的任何作用域服务也将被销毁*”。
- en: 'Its declaration is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它的声明如下：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you remember in the first demos of this chapter, our `DependencyClass1` and
    `DependencyClass2` classes implemented the `IDisposable` interface, so we could
    call those methods after the classes' main operations were finished.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得本章的第一个演示，我们的`DependencyClass1`和`DependencyClass2`类实现了`IDisposable`接口，因此我们可以在类的主要操作完成后调用这些方法。
- en: As we'll see in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency
    Injection in ASP.NET Core,* this concept adapts especially well to some internet
    applications' scenarios in which it makes a lot of sense to have a specific control
    for the lifetime of some services, and always have access to the execution context
    in the form of an instance class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml)，“ASP.NET Core中的依赖注入”中将会看到的，这个概念特别适合某些互联网应用的场景，在这些场景中，对某些服务的生命周期进行特定控制非常有意义，并且始终可以通过实例类访问执行上下文。
- en: In [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency Injection
    in ASP.NET Core*, you'll see that this feature can be important to face performance
    issues, resources of the server, scalability issues, and so on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml)，“ASP.NET Core中的依赖注入”中，你会看到这个特性在面对性能问题、服务器资源、可伸缩性问题等时可能非常重要。
- en: Other extensions with DI functionality
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他具有DI功能的扩展
- en: Linked to the `Microsoft.Extensions` global namespace, we find related namespaces
    that are becoming popular among developers, because they help in different areas
    of the application's lifecycle.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Microsoft.Extensions` 全局命名空间相关联，我们发现了一些在开发者中越来越受欢迎的相关命名空间，因为它们有助于应用程序生命周期的不同领域。
- en: Two of the most used are `Microsoft.Extensions.Logging` and `Microsoft.Extensions.Logging.Console`,
    which you can use to configure and code logging services using the techniques
    of Dependency Injection that we've seen in this chapter. They offer functionality
    similar to other popular frameworks, such as Serilog, Log4Net or NLog.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其中两个最常用的库是 `Microsoft.Extensions.Logging` 和 `Microsoft.Extensions.Logging.Console`，您可以使用我们在本章中看到的依赖注入技术来配置和编写日志服务。它们提供了类似于其他流行框架（如
    Serilog、Log4Net 或 NLog）的功能。
- en: I'm talking about `ILoggerFactory` and `ILogger<T>`, mainly used (especially
    in ASP.NET Core apps) to emit information at runtime, with the ability to redirect
    that information to different targets (console, output window, and so on).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我在谈论 `ILoggerFactory` 和 `ILogger<T>`，它们主要用于（尤其是在 ASP.NET Core 应用中）在运行时发出信息，并具有将信息重定向到不同目标（控制台、输出窗口等）的能力。
- en: But they can also be used to monitor and debug applications in .NET Core, and,
    even not offering the whole set of resources we find in those, more specialized,
    frameworks, they can be, many times, enough to cover our needs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们也可以用于监控和调试 .NET Core 应用程序，尽管它们不提供我们在那些更专业的框架中找到的全部资源，但很多时候它们足以满足我们的需求。
- en: A reflection on the structure of .NET Core
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 .NET Core 结构的反思
- en: It's quite interesting to see how .NET Core creators have designed this technology
    based on the Dependency Injection principles. That's why, besides its value as
    a tool for the developer, we can see the extra value of seeing DI really implemented
    by default in .NET Core libraries.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 看到 .NET Core 的创造者如何基于依赖注入原则设计这项技术，非常有趣。这就是为什么，除了它作为开发者工具的价值之外，我们还可以看到在 .NET
    Core 库中默认实现依赖注入（DI）的额外价值。
- en: Both classes are available inside the `Microsoft.Extensions.Logging` namespace,
    but other complementary namespaces, such as `Microsoft.Extensions.Logging.Console`
    and `Microsoft.Extensions.Logging.Debug`, also permit extended logging functionality
    that we'll use in the next demo. They can be easily referenced via NuGet packages,
    as we did before.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类都位于 `Microsoft.Extensions.Logging` 命名空间内，但其他互补的命名空间，如 `Microsoft.Extensions.Logging.Console`
    和 `Microsoft.Extensions.Logging.Debug`，也允许我们使用在下一个演示中将要使用的扩展日志功能。它们可以通过 NuGet
    包轻松引用，就像我们之前做的那样。
- en: To keep on demoing things with the simplest possible code, I'll use a simplified
    version of the previous demo, only this time using a single external class `XMLWriter`
    and its corresponding interface, with slight changes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用尽可能简单的代码来演示事物，我将使用之前演示的简化版本，这次只使用一个外部类 `XMLWriter` 及其相应接口，并进行了一些细微的改动。
- en: 'Just like with the `DependencyInjection` namespace, `Microsoft.Extensions.Logging`
    appears next to `Configuration` and `Dependency` libraries when filtering for
    this criterion in the Search box (notice that we''ll need a total of four extra
    libraries, including `Logging.Console` and `Logging.Debug`):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 `DependencyInjection` 命名空间中一样，当在搜索框中按此标准筛选时，`Microsoft.Extensions.Logging`
    会出现在 `Configuration` 和 `Dependency` 库旁边（请注意，我们总共需要四个额外的库，包括 `Logging.Console`
    和 `Logging.Debug`）：
- en: '![](img/1db817ef-3a61-47fd-a814-8191e9bc8896.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1db817ef-3a61-47fd-a814-8191e9bc8896.png)'
- en: After installing those libraries, if you're curious about these API's possibilities,
    you can also inspect the references that will show up in the `Solution Explorer`,
    next to the NuGet references' entry.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这些库之后，如果您对这些 API 的可能性感到好奇，您还可以检查在 `Solution Explorer` 中出现的引用，它位于 NuGet 引用条目旁边。
- en: 'The functionality provided by these logging services include the ability to
    write to the `Console`, using distinct types of messages (depending on the nature
    of the output: debug, information, warning, or error) and using several colors
    and formats to express these categories.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志服务提供的功能包括将信息写入 `Console`，使用不同类型的消息（根据输出的性质：调试、信息、警告或错误）以及使用多种颜色和格式来表示这些类别。
- en: Mark Michaelis clearly explains in his MSDN article *Essential .NET - Dependency
    Injection with .NET Core* some of the advantages of these DI implementations that
    we find linked to .NET Core.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Mark Michaelis 在他的 MSDN 文章 *Essential .NET - Dependency Injection with .NET
    Core* 中清楚地解释了我们发现与 .NET Core 链接的一些 DI 实现的优势。
- en: He points out that, when you want to switch between different implementations
    of some service and avoid hard-coding a reference to any service implementation,
    it is much more extensible and maintainable to ask for a factory of such instance,
    just like we did in other demos. The `ILoggerFactory` implements that functionality.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 他指出，当你想要在某个服务的不同实现之间切换，并避免硬编码对任何服务实现的引用时，请求此类实例的工厂会更加可扩展和易于维护，就像我们在其他演示中所做的那样。`ILoggerFactory`
    实现了该功能。
- en: 'He goes even further, highlighting that: "*you ask for an interface (such as
    ILoggerFactory**) with the expectation that the service provider (in this case,
    NLog, Log4Net or Serilog) will implement the interface"*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 他更进一步，强调说：“*你请求一个接口（例如 ILoggerFactory**）的期望是服务提供者（在这种情况下，NLog、Log4Net 或 Serilog）将实现该接口*”。
- en: 'Thus, `ILoggerFactory` is extensible even with third-party libraries! He also
    remarks that: "*the result is that while the client will directly reference the
    abstract assembly (Logging.Abstractions), defining the service interface, no references
    to the direct implementation will be needed"*.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ILoggerFactory` 即使与第三方库一起也是可扩展的！他还评论说：“*结果是，虽然客户端将直接引用定义服务接口的抽象程序集（Logging.Abstractions），但不需要引用直接实现*”。
- en: Actually, you may have noticed that the `ServiceCollection` itself owns a method
    called `AddLogging()`, which is a convenient method to activate logging functionality
    for the collection. This call is really translated to an internal registry of
    the `ILoggerFactory` service as part of the services collection we are configuring.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能已经注意到 `ServiceCollection` 本身有一个名为 `AddLogging()` 的方法，这是一个方便的方法，用于激活集合的日志功能。这个调用实际上是将
    `ILoggerFactory` 服务作为我们正在配置的服务集合的一部分的内部注册。
- en: 'Considering that we can also concatenate calls to configure our service collections,
    let''s see the first part of our new `Main()` method, including that call:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们也可以连接调用来配置我们的服务集合，让我们看看我们的新 `Main()` 方法的第一部分，包括那个调用：
- en: '[PRE15]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Consequently, we enable logging inside the `ServiceCollection` via `AddLogging()`.
    So, what happened? Let''s check the new members that our collection now has, by
    iterating through the resulting services object, like in a previous demo:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过 `AddLogging()` 在 `ServiceCollection` 中启用日志记录。那么，发生了什么？让我们通过迭代结果服务对象来检查我们的集合现在具有的新成员，就像在之前的演示中那样：
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ll obtain a collection containing three services (see the following output),
    because the `AddLogging()` method has, indeed, registered a `LoggingFactory` class
    with the `ILoggingFactory` interface, and another generic one, `ILogger<>`. That
    `ILogger<>` class will later be configured to provide any other class with the
    ability to send logging messages to the console:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得一个包含三个服务的集合（见下面的输出），因为 `AddLogging()` 方法确实已将 `LoggingFactory` 类注册为 `ILoggingFactory`
    接口，以及另一个泛型类，`ILogger<>`。该 `ILogger<>` 类将被配置为提供将日志消息发送到控制台的能力，为任何其他类：
- en: '![](img/66c9e26a-bf30-486b-a816-6289e9dbd476.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66c9e26a-bf30-486b-a816-6289e9dbd476.png)'
- en: 'Therefore, the next step is to obtain an `ILoggerFactory` object and link that
    object to the `Console`, which we perform with a call to `AddConsole()` in this
    fashion:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一步是获取一个 `ILoggerFactory` 对象，并将其与 `Console` 相关联，我们通过以这种方式调用 `AddConsole()`
    来执行此操作：
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you see, `AddConsole` expects some additional configuration in the form of
    an `enum` value of type `LogLevel`, which determines the minimum level of severity
    the runtime will filter when sending messages to the console--whenever the logging
    system receives an entry, it will ignore it if it is below that level.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`AddConsole` 预期一些额外的配置，形式为 `LogLevel` 类型的 `enum` 值，它决定了运行时在向控制台发送消息时将过滤的最小严重程度级别——每当日志系统接收到条目时，如果它低于该级别，它将忽略它。
- en: LogLevels Severity
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志级别严重性
- en: The `LogLevel` enumeration also establishes the priority of messages (pretty
    useful in case we want to distinguish low-level from high-level messages, and
    even redirect them to different output windows).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogLevel` 枚举还建立了消息的优先级（如果我们想区分低级消息和高级消息，甚至将它们重定向到不同的输出窗口，这非常有用）。'
- en: 'According to the official documentation these levels are organized as follows
    (it goes from least to highest severity):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档，这些级别按以下顺序组织（从最低严重性到最高严重性）：
- en: '**Trace = 0**: For information that is valuable only to a developer debugging
    an issue. These messages may contain sensitive application data and so should
    not be enabled in a production environment. Disabled by default. For example,
    credentials: `{"User":"someuser", "Password":"P@ssword"}`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪 = 0**：对于只有开发人员在调试问题时才有价值的信息。这些消息可能包含敏感的应用程序数据，因此不应在生产环境中启用。默认情况下禁用。例如，凭证：`{"User":"someuser",
    "Password":"P@ssword"}`'
- en: '**Debug = 1**: For information that has short-term usefulness during development
    and debugging. For example, entering the `Configure` method with fl the g set
    to true.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试 = 1**：对于在开发和调试期间具有短期有用性的信息。例如，使用fl the g设置为true进入`Configure`方法。'
- en: '**Information = 2**: For tracking the general flow of the application. These
    logs typically have some long-term value. For example, the request received for
    path `/``api/todo`.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息 = 2**：用于跟踪应用程序的一般流程。这些日志通常具有一些长期价值。例如，接收到的路径`/api/todo`的请求。'
- en: '**Warning = 3**: For abnormal or unexpected events in the application flow.
    These may include errors or other conditions that do not cause the application
    to stop, but which may need to be investigated. Handled exceptions are a common
    place to use the warning log level. For example, `FileNotFoundException` for file
    `quotes.txt`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告 = 3**：对于应用程序流程中的异常或意外事件。这些可能包括不会导致应用程序停止的错误或其他条件，但可能需要调查。处理异常是使用警告日志级别的常见地方。例如，对于文件`quotes.txt`的`FileNotFoundException`。'
- en: '**Error = 4**: For errors and exceptions that cannot be handled. These messages
    indicate a failure in the current activity or operation (such as the current HTTP
    request), not an application-wide failure. For example, log message: `Cannot insert
    record due to duplicate key violation`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误 = 4**：对于无法处理的错误和异常。这些消息表明当前活动或操作（如当前HTTP请求）失败，而不是应用程序级别的失败。例如，日志消息：`由于重复键违反无法插入记录`。'
- en: '**Critical = 5**: For failures that require immediate attention. For example,
    data loss scenarios, out of disk space.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键 = 5**：对于需要立即注意的失败。例如，数据丢失场景，磁盘空间不足。'
- en: 'The IDE also shows those levels through the IntelliSense services, together
    with an explanation of each purpose and functionality:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: IDE还通过IntelliSense服务显示这些级别，以及每个目的和功能的说明：
- en: '![](img/3f7d1638-39ba-41ce-9149-55c0adae1e7f.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f7d1638-39ba-41ce-9149-55c0adae1e7f.png)'
- en: In this way, the returned `ILoggerFactory` service we get when asking for a
    reference will redirect any output to the console using the debug level configuration,
    if not instructed otherwise.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们请求引用时返回的`ILoggerFactory`服务将根据调试级别配置将任何输出重定向到控制台，除非有其他指示。
- en: The `ILogger` and `ILoggerFactory` interfaces are located in `Microsoft.Extensions.Logging.Abstractions`,
    and default implementations of them are in `Microsoft.Extensions.Logging`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILogger`和`ILoggerFactory`接口位于`Microsoft.Extensions.Logging.Abstractions`中，它们的默认实现位于`Microsoft.Extensions.Logging`。'
- en: 'Now, if we want both classes (`XMLWriter` and `Program`) to use these logging
    services, we need an `ILogger` instance for each one. We''ll start creating one
    for `Program` and presenting a first set of messages in the console:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想让这两个类（`XMLWriter`和`Program`）都使用这些日志服务，我们需要为每个类提供一个`ILogger`实例。我们将开始为`Program`创建一个实例，并在控制台中展示一组初始消息：
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice that the creation of the logger class implies calling the `CreateLogger<Program>()`
    generic method. Once instantiated, the logger has methods to declare different
    scopes, (marking the beginning and the end of each scope) and to send six different
    types of messages to the console, each one representing a different severity level:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到创建日志类意味着调用`CreateLogger<Program>()`泛型方法。一旦实例化，日志器就有方法来声明不同的作用域（标记每个作用域的开始和结束）以及向控制台发送六种不同类型的消息，每种消息代表不同的严重级别：
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we take a look at the output, we can appreciate the differences between
    those messages'' formats:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看输出，我们可以欣赏到这些消息格式之间的差异：
- en: '![](img/606837b0-ae76-44ad-804d-dc8669814a7a.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/606837b0-ae76-44ad-804d-dc8669814a7a.png)'
- en: As you can see, the different messages' severity levels generate different formats
    in the output using distinct colors and prefixes to denote its `LogLevel` category.
    But, wait a minute! There's one missing (the `Trace` message).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，不同的消息严重级别在输出中生成不同的格式，使用不同的颜色和前缀来表示其`LogLevel`类别。但是，等等！有一个缺失的（`Trace`消息）。
- en: Well, not quite. What happens is that the `Trace` `LogLevel` doesn't output
    to the console, and it is prepared to be used mainly in web applications in which
    the trace switch is enabled (we will see more on that in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml),
    *Dependency Injection in ASP.NET Core*).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，还不完全是。发生的事情是，`Trace` `LogLevel`不会输出到控制台，它主要准备用于启用跟踪开关的Web应用程序（我们将在[第4章](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml)，*ASP.NET
    Core中的依赖注入*）中。
- en: So, all that said, how can we use this architecture and logging services from
    our `XMLWriter` class? Let's change the implementation, so we use one of the DI
    patterns that we saw in the previous chapter--the constructor dependency model.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，所有这些都说完了，我们如何使用这个架构和从我们的`XMLWriter`类中使用的日志服务呢？让我们改变实现方式，以便我们使用我们在上一章中看到的一个DI模式——构造函数依赖模型。
- en: 'To use that model, we have to change our `XMLWriter` class a little to include
    a read-only property that holds the `ILogger<>` instance and assign its value
    in the class'' constructor. So, the final format of our, this time, unique `XMLWriter`
    classes will be (the interface definition is not affected yet, so it''s just the
    same as in previous demos):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该模型，我们必须稍微改变我们的`XMLWriter`类，以包括一个只读属性，它持有`ILogger<>`实例，并在类的构造函数中分配其值。因此，这次我们独特的`XMLWriter`类的最终格式将是（接口定义尚未受到影响，所以它和之前的演示相同）：
- en: '[PRE20]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only thing remaining is to use the `logger` instead of the previous calls
    to `Console` and call one of the `Log*` methods to generate the intended output.
    And that's it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是使用`logger`代替之前的`Console`调用，并调用一个`Log*`方法来生成预期的输出。就是这样。
- en: We have totally replaced the functionality provided by the `Console` class with
    the logging services delivered by the `ILogginFactory` and `ILogger` objects,
    and we can also configure the severity level to generate distinct output formats.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完全用`ILogginFactory`和`ILogger`对象提供的日志服务替换了`Console`类提供的功能，我们还可以配置严重级别以生成不同的输出格式。
- en: 'So, with all that in mind, we end up with a final version of our `Main` method
    with this implementation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，考虑到所有这些，我们最终得到了这个实现版本的`Main`方法：
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see in the final output (see the following screenshot), all messages
    are presented in the console in the same sequence they''re invoked, using the
    predefined formats that .NET Core configures, and including our `XMLWriter` message:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在最终输出中可以看到的（请参阅以下截图），所有消息都按照它们被调用的顺序在控制台中呈现，使用.NET Core配置的预定义格式，包括我们的`XMLWriter`消息：
- en: '![](img/1d65f85e-fa1c-4fc9-8e55-3a85320b9fdf.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d65f85e-fa1c-4fc9-8e55-3a85320b9fdf.png)'
- en: This is not all. We still have other options available that allow us to separate
    and filter the output message destination. This possibility is correlated to the
    `Microsoft.Extensions.Logging.Debug` library, which should also be referenced
    just like the others we're using here.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。我们还有其他一些选项可供选择，允许我们分离和过滤输出消息的目的地。这种可能性与`Microsoft.Extensions.Logging.Debug`库相关联，它也应该像我们在这里使用的其他库一样被引用。
- en: One of the features included in this library is the `AddDebug()` method of `ILoggerFactory`.
    Once activated, it permits us to send messages to the Debug window, enabling a
    separation of messages conditional to its severity level, for instance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包含的一个功能是`ILoggerFactory`的`AddDebug()`方法。一旦激活，它允许我们将消息发送到调试窗口，并能够根据消息的严重级别进行条件分离，例如。
- en: 'To test this functionality, we''ll make a few changes in our definitions of
    the `IXMLWriter` interface and update the implementation accordingly. Our new
    interface will have another method that also sends messages to the predefined
    output (which, in this case, will show up in several places at runtime):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我们将在`IXMLWriter`接口的定义中做一些更改，并相应地更新实现。我们的新接口将有一个额外的方法，该方法也会将消息发送到预定义的输出（在这种情况下，将在运行时出现在几个地方）：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, the updated code of XMLWriter will be:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，XMLWriter的更新代码将是：
- en: '[PRE23]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, now we have two distinct methods to write messages. To test this functionality,
    we can configure the `ILoggerService` object in the `Main()` method (which, remember,
    is of type `ILoggerFactory`). Once the new namespace is loaded and available,
    we can write:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有两种不同的方法来写入消息。为了测试这个功能，我们可以在`Main()`方法中配置`ILoggerService`对象（记住，它是`ILoggerFactory`类型）。一旦新的命名空间被加载并可用，我们可以写入：
- en: '[PRE24]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this manner, we allow sending messages to the `Debug` or `Output` windows,
    either for console or web applications.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们允许将消息发送到`Debug`或`Output`窗口，无论是控制台还是Web应用程序。
- en: 'It''s easy to test different options, changing the types of severity levels
    used in the calls to this method, and the already existing ones. For example,
    we can make a call to `WriteXMLWithSeverityLevel()` and observe the two outputs
    (now we have two), that are generated during execution:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不同的选项很容易，只需更改调用此方法时使用的严重性级别类型，以及现有的那些。例如，我们可以调用`WriteXMLWithSeverityLevel()`并观察在执行过程中生成的两个输出（现在我们有两个）：
- en: '[PRE25]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On one side, the output now presents the new message (nothing unexpected):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，输出现在显示了新的消息（没有意外）：
- en: '![](img/324caea3-87c7-41a9-9eb7-285ad3cf41e7.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/324caea3-87c7-41a9-9eb7-285ad3cf41e7.png)'
- en: 'But, now, we have more messages. If we take a look at the `Output` window,
    we''ll see the new entries depending on the `LogLevel` we configure--some of them
    will be presented, and others, ignored (as you can see, in this version, only
    the first four messages are replicated in the Output window, and all XMLWriter
    messages are ignored):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在我们有了更多的消息。如果我们查看`输出`窗口，我们会看到根据我们配置的`LogLevel`出现的新条目——其中一些将被展示，而其他一些则会被忽略（正如你所见，在这个版本中，只有前四条消息被复制到输出窗口中，所有XMLWriter消息都被忽略）：
- en: '![](img/d33a0f69-0e87-4e06-ae02-edc6de0e2883.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d33a0f69-0e87-4e06-ae02-edc6de0e2883.png)'
- en: This is only a first approach to some of the services that adopt the DI architecture
    and that are available inside .NET Core. We will see much more on these implementations
    when dealing with ASP.NET Core coding, in [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml),
    *Dependency Injection in ASP.NET Core*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对采用DI架构的一些服务以及.NET Core内部可用的服务的初步了解。当我们处理ASP.NET Core编码时，在[第4章](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml)，“ASP.NET
    Core中的依赖注入”中，我们将看到更多关于这些实现的细节。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have made a first approach to how Dependency Injection technologies
    are supported and implemented in the current version of the .NET Core (2.0) and
    how we can use them, even outside of ASP.NET projects.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们初步探讨了如何在当前版本的.NET Core（2.0）中支持和使用依赖注入技术，以及我们如何在ASP.NET项目之外使用它们。
- en: To summarize, we've seen the main characteristics of NET Core and its installation
    and usage from Visual Studio, especially focused on the latest version, Visual
    Studio 2017, together with the distinct types of deployment linked to this version
    of the framework, along with the main features and functionality included in the
    namespaces related to DI and, especially, inside the `Microsoft.Extensions.DependencyInjection`
    and `Microsoft.Extensions.Logging` containers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经看到了.NET Core的主要特性和从Visual Studio安装和使用的步骤，特别是关注最新版本，Visual Studio 2017，以及与这个框架版本相关的不同类型的部署，以及包含在DI和相关命名空间中的主要功能和功能。
- en: We've also analyzed the classes and interfaces related to this architecture,
    together with its implementation through a bunch of samples, ending with some
    real implementations, that are already part of .NET Core 2.0, such as the logging
    services, and how to use them, from any class.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分析了与此架构相关的类和接口，以及通过一系列示例实现它的方法，最后是一些真实实现，它们已经是.NET Core 2.0的一部分，例如日志服务，以及如何从任何类中使用它们。
- en: In [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency Injection
    in ASP.NET Core*, our approach will be more real, since it deals with web applications
    and how the new architecture and configuration of websites manage these new concepts,
    such as middleware and services configuration, in which DI plays an important
    role since the very beginning.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml)，“ASP.NET Core中的依赖注入”，我们的方法将更加真实，因为它涉及到Web应用程序以及网站的新架构和配置如何管理这些新概念，例如中间件和服务配置，其中DI从一开始就扮演着重要角色。
