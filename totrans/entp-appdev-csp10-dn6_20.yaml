- en: '*Chapter 15*: Testing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success of any application depends on how easy it is for users to use it.
    The longevity of any software product depends directly on the quality of the product.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is an important aspect of the **Software Development Life Cycle** (**SDLC**)
    and ensures that a product meets the customer's requirements and the quality requirements.
    Testing is also important, as the cost of fixing bugs increases as we move toward
    the later stages of the SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the different types of testing and the
    tools that Visual Studio provides for testing, as well as looking at third-party
    tools that we can use to ensure the quality of the products we build in .NET 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the importance of load testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know everything you need to know about
    ensuring the quality of a product.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need Visual Studio 2022 Community Edition. (Certain sections require
    Enterprise Edition.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with Visual Studio, you will need JMeter, which can be downloaded from
    here: [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    You will also need a basic understanding of Microsoft .NET.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software testing is a way to check whether an application is performing according
    to expectations. These expectations could be to do with functionality, responsiveness,
    or the resources that the software consumes while running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software testing can be broadly categorized into the following two categories
    based on the way it is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual testing**: In manual testing, testers execute test cases manually
    by using the application under test and validating the expected outcome. Manual
    testing requires more effort than the alternative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated testing**: Automated testing is performed by special automated
    testing software. This automated software runs on the application under test in
    a specialized environment and validates the expected output. Automated testing
    saves a lot of time and manpower. In some cases, it might take a lot of effort
    to have 100% automation and maintain the automation with considerably less **Return
    on Investment** (**ROI**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of the information known about the internals of the application under
    test (such as the code flow and dependent modules integration), software testing
    can also be broadly categorized in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Black-box testing**: In black-box testing, the individual responsible for
    testing does not have information about the internals of the system. The focus
    here is on the behavior of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**White-box testing**: In white-box testing, the tester has information about
    the internal structure, design, and implementation of the system. The focus of
    white-box testing is testing the alternate paths that exist in the implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In software testing, we validate different aspects of an application. Software
    testing also has the following variants, based on the aspect of an application
    that it validates and the tools or frameworks it uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Unit testing focuses on the smallest unit of an application.
    Here, we validate individual classes or functions. This is mostly done during
    the development phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional testing**: This is often termed **integration testing**. The main
    objective of this is to ensure that an application is performing as per the requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing**: A regression test ensures that any recent changes have
    not adversely affected application performance and that the existing functionality
    is not affected by any changes. In regression testing, all or some of the functional
    test cases are executed, depending upon the change introduced in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoke test**: A smoke test is done after every deployment to ensure that
    the application is stable and ready for rollout. This is also known as a **Build
    Verification Test** (**BVT**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load test**: A load test is used to determine the overall effectiveness of
    the system. During a load test, we simulate the projected load on an integrated
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress testing**: In stress tests, we push the system beyond the intended
    capacity or load. This helps us identify the bottlenecks in the system and identify
    the points of failure. Performance testing is the umbrella term used for both
    stress and load testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security testing**: Security testing is performed to ensure the flawless
    execution of the application. In security testing, we focus on evaluating various
    elements of security aspects such as integrity, confidentiality, and authenticity,
    among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility testing**: Accessibility testing is designed to determine whether
    differently-abled individuals will be able to use an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have seen the different types of testing, in the sections ahead,
    we will be covering unit testing, functional testing, and load testing in detail,
    as they are critical to ensuring the stability of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore more on security, try security testing with static code analysis
    tools: [https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview](https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview).
    More on accessibility can be found here: [https://accessibilityinsights.io/](https://accessibilityinsights.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: Performance tests, accessibility tests, and security tests are the tests that
    we perform to assess the non-functional aspects of the application, such as performance,
    usability, reliability, security, and accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to perform unit testing for our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a way to test the smallest isolated unit of an application.
    It is an important step in software development that helps isolate a problem early.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing has a direct impact on the quality of the software we build. It
    is always recommended to write a unit test as soon as you write any method. If
    we follow the methodology of **test-driven development** (**TDD**), we write the
    test case first and then proceed to implement the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about creating unit tests and running them
    from Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We chose to use Visual Studio as it has powerful tooling to create and manage
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: With Visual Studio, we can create, debug, and run unit test cases. We can also
    check the code coverage of the tests that are executed. Additionally, it has a
    **Live Unit** test feature, which runs unit test cases while we modify the code
    and shows the results in real time.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore all these features in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and running unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's go ahead and create a unit test project to perform unit testing on the
    `Packt.ECommerce.Order` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create unit test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new project of the `Tests` folder, and name the project `Packt.ECommerce.Order.UnitTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Visual Studio xUnit test project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – Visual Studio xUnit test project
  prefs: []
  type: TYPE_NORMAL
- en: Add a project reference of `Packt.ECommerce.Order` to the newly created test
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class to the test project and name it `OrdersControllerTest`. We are
    going to add all the test cases related to `OrdersController` in this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s add a simple test to test the constructor of the `OrdersController`
    controller. The test we will be performing is to assert the successful creation
    of the `OrderController` controller. Let''s now add the test, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Create_Object_OfType_OrderController` test method is attributed with `Fact`;
    this is required for the `xUnit` framework to discover the test method. Here,
    we are asserting by checking the `null` condition of the object created.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio provides **Test Explorer** to manage and run tests. Let's open
    it by going to **Test** | **Test Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the solution to see the tests in **Test Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `OrderController_Constructor` test we created by right-clicking on it and
    selecting **Run** from the context menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Test Run context menu from the Test Explorer window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – Test Run context menu from the Test Explorer window
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the test is executed, we can see the test result in the right pane. From
    the result, we can see that the test was executed and run successfully, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Test results from Test Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – Test results from Test Explorer
  prefs: []
  type: TYPE_NORMAL
- en: We have created and executed a simple test in Visual Studio. In the next section,
    we will learn how to mock the dependencies of `OrdersController` to validate the
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies with Moq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, a method under test calls other external methods or services, which we
    call dependencies. To ensure the functionality of the method under test, we isolate
    the behavior of dependencies by creating mock objects for the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In an application, classes may be dependent on other classes; for instance,
    our `OrdersController` class is dependent on `OrderService`. While testing `OrdersController`,
    we should be isolating the behavior of `OrderService`.
  prefs: []
  type: TYPE_NORMAL
- en: To understand mocking, let's create the unit test for the `GetOrdersAsync` action
    method of `OrdersController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `GetOrderById` method for which we are writing the
    unit test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this method, the call is made to `GetOrderByIdAsync` of `orderService` in
    order to fetch the orders based on the `id` instance passed in. The controller
    action will return the order `id` retrieved from `OrderService`; otherwise, the
    `NotFound` action is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, there are two paths for the code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: One path is for when the order is present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other is for when the order is not present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a unit test, we should be able to cover both paths. So, now, the question
    that arises is, how do we simulate these two cases?
  prefs: []
  type: TYPE_NORMAL
- en: What we want here is to mock the response of `OrderService`. To mock the response
    of `OrderService`, we can leverage the `Moq` library. To leverage Moq, we need
    to add a NuGet reference to the `Moq` package to the `Packt.ECommerce.Order.UnitTest`
    test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the test method in the `OrdersControllerTest` class, as shown in
    the following code, to test `GetOrderById` of `OrdersController` to validate the
    case where the order object is returned by `OrderService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From the code, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Since `IOrderService` is injected to `OrderController` via controller injection,
    we can inject a mocked `OrderService` to `OrderController`, which will help us
    to test all the code paths of `OrderController` by altering the mock object behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We leverage the `Mock` class to create a stub (also known as a mock) for `IOrderService`
    and overwrite the `GetOrderByIdAsync` behavior, as shown in the preceding code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an instance of the `Mock` object for the `IOrderService` interface
    and set up the behavior for `GetOrderByIdAsync` by calling the `Setup` method
    on the `Mock` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetOrderByIdAsync` method is mocked such that for any parameter value that
    it receives, the `mock` object will return the object of `OrderDetailsViewModel`
    with `Id` as `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we injected the mocked object into `OrderService` via constructor injection,
    whenever there is a call to any method in `IOrderService`, the call will go to
    the mocked implementation of `IOrderService`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we assert the test result by validating the type of result that is
    returned from `OrderController` to `OkObjectResult`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s add a test case to validate the behavior, where we receive the
    `NotFound` result if the order is not present, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this test case, we simulated the behavior of the order not being present
    by returning a `null` value from the `OrderService` stub. This will make the `GetOrderById`
    action method of `OrdersController` return `NotFoundResult`, and this is validated
    in the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `OrderService` class depends on `IHttpClientFactory`, `IOptions`, `Mapper`,
    and `DistributedCacheService`. So, to add a unit test for this, we should be mocking
    them all. You can take a look at the `When_GetOrderByIdAsync_with_ExistingOrder_receive_Order`
    test method in the `OrderServiceTest` test class of the GitHub code samples for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we have seen how to leverage the `xUnit` framework to create
    unit tests. There are several other test frameworks available to create unit tests
    in .NET. Two such frameworks worth mentioning here are MSTest and NUnit. Though
    there are a few differences in the way the tests are executed between these frameworks,
    all these frameworks are brilliant and provide features such as mocking and parallel
    execution. Because of its simplicity and extensibility, xUnit has a little advantage
    over competing frameworks. We can also write data-driven tests using `Theory`
    in xUnit, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the test method is executed with the test data
    passed through the `InlineData` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In unit testing, our aim is to test a specific class by mocking the behavior
    of dependent classes. If we test these classes along with other dependent classes,
    we call that **integration testing**. We write integration tests at various levels:
    at the level of a specific module or assembly, at the microservice level, or the
    entire application level.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added unit test cases to our e-commerce solution, in the next
    section, we will check the code coverage for these tests.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code coverage is a measure to describe how much of the code is covered by our
    test cases. Visual Studio provides a tool to find the code coverage of unit tests.
    We can run **Test** | **Analyze Code Coverage** for all tests, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The Analyze Code Coverage context option in Text Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.4_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – The Analyze Code Coverage context option in Text Explorer
  prefs: []
  type: TYPE_NORMAL
- en: This can also be done from the **Context** menu in **Test Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **Analyze Code Coverage** feature is only available in the Enterprise Edition
    of Visual Studio. If you are using the Community Edition, you can use the Visual
    Studio free extension, [https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage](https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage),
    to view the code coverage results.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will run all the test cases and identify any code blocks that are not
    tested. We can see the code coverage results in the following **Code Coverage
    Results** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Visual Studio Code Coverage Results window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.5_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – Visual Studio Code Coverage Results window
  prefs: []
  type: TYPE_NORMAL
- en: '`GetOrderByIdAsync`, the code coverage for that method is `GetOrdersAsync`
    is **0.00%**, as we did not have any test cases to test it. The code coverage
    gives us a good indication of how effective our unit testing is.'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to create unit test cases for all the classes in a solution.
    By adding unit tests to validate all the classes and functionality, a higher percentage
    of code will be covered by unit test cases. With higher code coverage, we will
    be able to catch more errors early in the development while making changes to
    a solution. We should ensure that all the test cases pass before we commit changes.
    In the next chapter, [*Chapter 16*](B18507_16_Epub.xhtml#_idTextAnchor1932), *Deploying
    the Application in Azure*, we will learn how to integrate running test cases with
    Azure DevOps pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have tested individual modules or classes by mocking dependencies
    and writing unit test cases. It is also important to test functionality after
    integrating and deploying an entire solution. In the next section, we will learn
    about how to perform functional testing for our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio''s code metrics and code analysis tools are useful to ensure
    the maintainability and readability of the code that we write. You can find details
    on code metrics here: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For code analysis, go here: [https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview).'
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional testing, we validate the application we have built against the
    functional requirements. Functional testing is performed by providing some input
    and asserting the response or output of the application. While performing functional
    testing, we consider the application as a whole; we are not validating individual
    internal components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional testing can be split into three tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the functionalities of the system to be tested
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determining the input with the expected output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing these tests to assess whether the system is responding according to
    expectations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution of functional tests can be done manually by performing the test
    steps on the application, or we can automate them using tools. The time to market
    for an application can be drastically reduced by automating functional tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about automating functional test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Automating functional test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Executing functional test cases manually is still relevant in application testing.
    However, given the fact of shorter deployment cycles and customers expecting new
    features quickly, manual testing can be prohibitively time-consuming and inefficient
    in terms of identifying bugs early. Using automation, we can gain new efficiencies,
    accelerate the testing process, and improve software quality. There are multiple
    tools and frameworks available to automate functional test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the most popular automation framework,
    **Selenium**. Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, let's create an `MSTest` project and name it `Packt.ECommerce.FunctionalTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To this project, add the `Selenium.WebDriver`, `Selenium.WebDriver.ChromeDriver`,
    and `WebDriverManager` NuGet packages. These packages are required for us to run
    Selenium tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with a simple test that validates the title of our e-commerce
    application. To do this, create a `HomePageTest` test class and a `When_Application_Launched_Title_Should_be_ECommerce_Packt`
    test method, as we did in the *Unit testing* section, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To execute our functional tests, we should launch a browser and use that browser
    to navigate to the e-commerce application. The `MSTest` framework provides a special
    function to perform the initialization and cleanup operations required for our
    tests. We will be creating a Chrome web driver to perform a functional test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add the initialize and cleanup methods, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `InitializeDriver` method is attributed with `TestInitialize`
    to notify the framework that this is the test initialization method. In test initialization,
    we are creating `ChromeDriver` and initializing the class variable. After the
    completion of the test case, we should close the browser instance; we do this
    in the `WebDriverCleanup` method by calling the `Quit` method. To notify the test
    framework that it is the cleanup method, it should be attributed as `TestCleanup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go and add the test case to navigate to the e-commerce application
    and validate the title, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Call `GoToUrl` on our Chrome web driver to navigate to the e-commerce application.
    Once navigated, we can validate the title of the page by asserting the `Title`
    property of the web driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the test case from `When_Application_Launched_Title_Should_be_ECommerce_Pact`
    test case and selecting **Run**. This will open the Chrome browser and navigate
    to the specified e-commerce URL, and then it will assert the title of the page.
    After the execution of the test case, the browser will be closed. We see the results
    in **Test Explorer**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Solution structure after the creation of the test project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.6_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – Solution structure after the creation of the test project
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will extend the functional test to validate the search functionality.
    To test this functionality, we should enter text in the search box and click on
    the **Search** button. Then, check the results to see whether the returned test
    results are only for the searched product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s automate the test case by adding the `When_Searched_For_Item` test method,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test case, after navigating to the home page, enter the search text
    in the `search` string.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium makes it so easy to write functional tests. We should try to automate
    all functional test cases, such as user management, adding products to the cart,
    and placing an order. With all the functional test cases automated, we will be
    in a better position to test and validate the functionality of new releases and
    maintain the quality of our application. There are other functional testing tools
    available, such as QTP and Visual Studio Coded UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at functional testing, which validates the functionality of an
    application. It is equally important to assess the responsiveness of an application
    to see how it responds to a particular load. In the next section, we will learn
    how we can perform performance testing on our e-commerce application. We can leverage
    automated functional test cases to perform BVT or regression testing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the documentation to explore more about Selenium testing: [https://www.selenium.dev/documentation/en/](https://www.selenium.dev/documentation/en/).'
  prefs: []
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users expect an application to respond quickly to their actions. Any sluggishness
    in response will lead to user frustration, and ultimately, we will lose them.
    Even if an application works fine under a normal load, we should know how our
    application behaves when there is a sudden peak in demand and be prepared for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of load testing is not to find bugs but to eradicate the performance
    bottlenecks of the application. A load test is done to provide stakeholders with
    information about the speed, scalability, and stability of their application.
    In the next section, we will learn how to perform a load test using JMeter.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing with JMeter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JMeter** is an open source testing tool built by the Apache Software Foundation.
    It is one of the most popular tools available to perform load testing. JMeter
    can simulate a heavy load on an application by creating virtual concurrent users
    of a web server.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and create a JMeter load test for our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to use JMeter to do a load test, we will be creating a test with
    two home pages and product search pages. Try the following steps to create the
    load test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Apache JMeter from the download location. We will see the window as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Apache JMeter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.7_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – Apache JMeter
  prefs: []
  type: TYPE_NORMAL
- en: Add a thread group by right-clicking on **Test Plan** in the left pane and selecting
    **Add** | **Threads (Users)** | **Thread Group**. The thread group defines the
    pool of users that will execute the test case against our application. With it,
    we can configure the number of users simulated, the time to start all the users,
    and the number of times to perform the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s name the thread group `Load and Query Products` and set the number of
    users to `30`. Set `5` seconds, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Adding a thread group in Apache JMeter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image87474.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – Adding a thread group in Apache JMeter
  prefs: []
  type: TYPE_NORMAL
- en: This will simulate a user load of `30` within `5` seconds. Using **Thread Group**,
    we can also control the number of times the test should run.
  prefs: []
  type: TYPE_NORMAL
- en: To add the test request, right-click on **Thread Group** and select **Add**
    | **Sampler** | **HTTP Request**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s set `https`, `localhost`, and `44365` (the port number of the locally
    running e-commerce portal). Name this test `Home Page`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Adding the Home Page HTTP request in JMeter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image87486.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.9 – Adding the Home Page HTTP request in JMeter
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add one more HTTP request sampler to get the details of a specific
    product. For this request, set the `productId` query parameter as `Cloth.3` and
    `productName` as `Orange%20Shirt`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Adding the Product Details page HTTP request in JMeter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.10_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.10 – Adding the Product Details page HTTP request in JMeter
  prefs: []
  type: TYPE_NORMAL
- en: Save this test plan by clicking on the `ECommerce`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To view the results, we should add a listener to this test. Right-click on the
    test group and select **Add** | **Listener** | **View Results in Table**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the listener is added, go ahead and run the test by selecting **Run** |
    **Start**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the test run is complete, you will see the results as shown in the following
    screenshot. This will give us the response time for each request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Test results table in JMeter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.11_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.11 – Test results table in JMeter
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple listeners available in JMeter to view the results, such as
    **Summary report** and **Graph results**, which will give another representation
    of the test results. We can configure different kinds of samplers easily with
    JMeter, as well as configuring requests with different HTTP methods and dynamic
    tests, where requests are dependent on another API's response. Once a test plan
    is in JMeter, we can leverage the JMeter command-line utility to run it from multiple
    data centers to simulate a load across geographies and collate the results.
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility that JMeter provides, along with its extensive documentation,
    makes it the most-used performance testing tool. JMeter can also be leveraged
    to perform functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Azure Load Testing service to generate high-scale load using
    the JMeter test that we created in this section. The infrastructure required to
    execute your JMeter script and load test your application is abstracted by Azure
    Load Testing. Azure Load Testing gathers precise resource data for Azure-based
    applications to assist you in identifying performance bottlenecks across your
    Azure application components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Azure Load Testing is in preview. More details
    about load testing can be found in the Azure documentation at [https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing](https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing).
    It is recommended to run a load test with one and a half to two times the anticipated
    load. After running the performance test, it is recommended to use **Application
    Insights** to analyze the server response time of requests, how dependent APIs
    are responding during the load conditions, and more importantly, any failures
    that occur while the test is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to run automated tests using Azure DevOps pipelines. Use
    the documentation to see how to integrate tests with an Azure DevOps pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selenium: [https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops)'
  prefs: []
  type: TYPE_NORMAL
- en: 'JMeter tests: [https://github.com/Azure-Samples/jmeter-aci-terraform](https://github.com/Azure-Samples/jmeter-aci-terraform)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored a very important aspect of software development:
    testing. We have learned about the different kinds of testing and the stages at
    which we should be using them in the SDLC.'
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the concepts of unit testing and how to focus our testing on
    specific calls by mocking dependencies using the `Moq` framework. We were also
    introduced to the creation of automated functional tests using Selenium to test
    the functionality of our e-commerce application before releasing it to production.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end, we learned about JMeter, which is the most-used tool for performing
    load testing. The next chapter will focus on deploying applications in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: True or false? We should only start to think about testing an application after
    the completion of its development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is a kind of software testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Security testing
  prefs: []
  type: TYPE_NORMAL
- en: b. Functional testing
  prefs: []
  type: TYPE_NORMAL
- en: c. Accessibility testing
  prefs: []
  type: TYPE_NORMAL
- en: d. All of the above
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: d**'
  prefs: []
  type: TYPE_NORMAL
- en: True or false? A higher code coverage percentage for unit tests is desirable
    to achieve a shorter time to market.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
