- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Working with Minimal APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最小 API 进行工作
- en: In this chapter, we will try to apply some advanced development techniques available
    in earlier versions of .NET. We will touch on four common topics that are disjointed
    from each other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试应用在 .NET 早期版本中可用的某些高级开发技术。我们将涉及四个相互独立的话题。
- en: We’ll cover productivity topics and best practices for frontend interfacing
    and configuration management.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖前端接口和配置管理的前沿主题和最佳实践。
- en: Every developer, sooner or later, will encounter the issues that we describe
    in this chapter. A programmer will have to write documentation for APIs, will
    have to make the API talk to a JavaScript frontend, will have to handle errors
    and try to fix them, and will have to configure the application according to parameters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者，迟早都会遇到本章中描述的问题。程序员将不得不为 API 编写文档，将不得不使 API 与 JavaScript 前端通信，将不得不处理错误并尝试修复它们，以及根据参数配置应用程序。
- en: 'The themes we will touch on in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涉及的主题如下：
- en: Exploring Swagger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Swagger
- en: Supporting CORS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持CORS
- en: Working with global API settings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局 API 设置
- en: Error handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As reported in the previous chapters, it will be necessary to have the .NET
    6 development framework available; you will also need to use .NET tools to run
    an in-memory web server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，需要具备 .NET 6 开发框架；您还需要使用 .NET 工具来运行内存中的 Web 服务器。
- en: To validate the functionality of **cross-origin resource sharing** (**CORS**),
    we should exploit a frontend application residing on a different HTTP address
    from the one where we will host the API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证**跨源资源共享**（**CORS**）的功能，我们应该利用一个位于不同 HTTP 地址的前端应用程序，该地址与我们将托管 API 的地址不同。
- en: To test the CORS example that we will propose within the chapter, we will take
    advantage of a web server in memory, which will allow us to host a simple static
    HTML page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试本章中我们将提出的 CORS 示例，我们将利用内存中的 Web 服务器，这将使我们能够托管一个简单的静态 HTML 页面。
- en: 'To host the web page (HTML and JavaScript), we will therefore use **LiveReloadServer**,
    which you can install as a .NET tool with the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了托管网页（HTML 和 JavaScript），我们将使用 **LiveReloadServer**，您可以使用以下命令将其作为 .NET 工具安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03)。
- en: Exploring Swagger
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Swagger
- en: Swagger has entered the life of .NET developers in a big way; it’s been present
    on the project shelves for several versions of Visual Studio.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 以一种重大的方式进入了 .NET 开发者的生活；它已经在 Visual Studio 的多个版本中出现在项目架子上。
- en: 'Swagger is a tool based on the OpenAPI specification and allows you to document
    APIs with a web application. According to the official documentation available
    at [https://oai.github.io/Documentation/introduction.xhtml](https://oai.github.io/Documentation/introduction.xhtml):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 是一个基于 OpenAPI 规范的工具，允许您使用 Web 应用程序来记录 API。根据官方文档（[https://oai.github.io/Documentation/introduction.xhtml](https://oai.github.io/Documentation/introduction.xhtml)）：
- en: “The OpenAPI Specification allows the description of a remote API accessible
    through HTTP or HTTP-like protocols.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “OpenAPI 规范允许通过 HTTP 或类似 HTTP 协议描述可远程访问的 API。
- en: An *API*defines the allowed interactions between two pieces of software, just
    like a user interface defines the ways in which a user can interact with a program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *API* 定义了两个软件组件之间允许的交互方式，就像用户界面定义了用户与程序交互的方式一样。
- en: An API is composed of the list of possible methods to call (requests to make),
    their parameters, return values and any data format they require (among other
    things). This is equivalent to how a user’s interactions with a mobile phone app
    are limited to the buttons, sliders and text boxes in the app’s user interface.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 API 由可以调用的可能方法列表（要发出的请求）、它们的参数、返回值以及它们所需的数据格式（以及其他事项）组成。这相当于用户与手机应用程序的交互仅限于应用程序用户界面中的按钮、滑块和文本框。”
- en: Swagger in the Visual Studio scaffold
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 模板中的 Swagger
- en: 'We understand then that **Swagger**, as we know it in the .NET world, is nothing
    but a set of specifications defined for all applications that expose web-based
    APIs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们理解，**Swagger**，正如我们在 .NET 世界中所知，只不过是为所有公开基于 Web 的 API 的应用程序定义的一组规范：
- en: '![Figure 3.1 – Visual Studio scaffold](img/Figure_3.1_B17902.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Visual Studio 模板](img/Figure_3.1_B17902.jpg)'
- en: Figure 3.1 – Visual Studio scaffold
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Visual Studio 模板
- en: By selecting `Swashbuckle.AspNetCore` and automatically configures it in the
    `Program.cs` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择 `Swashbuckle.AspNetCore` 并在 `Program.cs` 文件中自动配置它。
- en: 'We show the few lines that are added with a new project. With these few pieces
    of information, a web application is enabled only for the development environment,
    which allows the developer to test the API without generating a client or using
    tools external to the application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了在新项目中添加的几行代码。凭借这些少量的信息，Web 应用程序仅启用开发环境，这允许开发者测试 API 而无需生成客户端或使用应用程序外部的工具：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The graphical part generated by Swagger greatly increases productivity and allows
    the developer to share information with those who will interface with the application,
    be it a frontend application or a machine application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 生成的图形部分大大提高了生产力，并允许开发者与那些将与应用程序接口的人共享信息，无论是前端应用程序还是机器应用程序。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We remind you that enabling Swagger in a production environment is *strongly
    discouraged* because sensitive information could be publicly exposed on the web
    or on the network where the application resides.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提醒您，在生产环境中启用 Swagger 是 **强烈不建议** 的，因为敏感信息可能会在网络上或应用程序所在的网络中被公开暴露。
- en: We have seen how to introduce Swagger into our API applications; this functionality
    allows us to document our API, as well as allow users to generate a client to
    call our application. Let’s see the options we have to quickly interface an application
    with APIs described with OpenAPI.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将 Swagger 引入我们的 API 应用程序；此功能使我们能够记录我们的 API，并允许用户生成一个客户端来调用我们的应用程序。让我们看看我们可以快速将应用程序与使用
    OpenAPI 描述的 API 接口的方法。
- en: OpenAPI Generator
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenAPI 生成器
- en: With Swagger, and especially with the OpenAPI standard, you can automatically
    generate clients to connect to the web application. Clients can be generated for
    many languages but also for development tools. We know how tedious and repetitive
    it is to write clients to access the Web API. **Open API Generator** helps us
    automate code generation, inspect the API documentation made by Swagger and OpenAPI,
    and automatically generate code to interface with the API. Simple, easy, and above
    all, fast.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swagger，尤其是使用 OpenAPI 标准，您可以自动生成连接到 Web 应用程序的客户端。可以为许多语言生成客户端，也可以为开发工具生成。我们知道编写客户端以访问
    Web API 是多么繁琐和重复。**Open API Generator** 帮助我们自动化代码生成，检查 Swagger 和 OpenAPI 制作的 API
    文档，并自动生成与 API 接口的代码。简单、容易，最重要的是，快速。
- en: The `@openapitools/openapi-generator-cli` npm package is a very well-known package
    wrapper for OpenAPI Generator, which you can find at [https://openapi-generator.tech/](https://openapi-generator.tech/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`@openapitools/openapi-generator-cli` npm 包是 OpenAPI 生成器的一个非常著名的包包装器，您可以在 [https://openapi-generator.tech/](https://openapi-generator.tech/)
    找到它。'
- en: With this tool, you can generate clients for programming languages as well as
    load testing tools such as **JMeter** and **K6**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此工具，您可以生成编程语言的客户端以及负载测试工具，如 **JMeter** 和 **K6**。
- en: 'It is not necessary to install the tool on your machine, but if the URL of
    the application is accessible from the machine, you can use a Docker image, as
    described by the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要在您的机器上安装此工具，但如果应用程序的 URL 可从机器访问，您可以使用以下命令描述的 Docker 镜像：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The command allows you to generate a `petstore.yaml` file that is mounted on
    the Docker volume.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令允许您生成一个挂载在 Docker 卷上的 `petstore.yaml` 文件。
- en: Now, let’s go into detail to understand how you can leverage Swagger in .NET
    6 projects and with minimal APIs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解如何在 .NET 6 项目和最小 API 中利用 Swagger。
- en: Swagger in minimal APIs
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swagger 在最小 API 中
- en: In ASP.NET Web API, as in the following code excerpt, we see a method documented
    with C# language annotations with the triple slash (`///`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Web API 中，正如以下代码片段所示，我们看到一个使用 C# 语言注释（`///`）进行文档化的方法。
- en: 'The documentation section is leveraged to add more information to the API description.
    In addition, the `ProducesResponseType` annotations help Swagger identify the
    possible codes that the client must handle as a result of the method call:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文档部分被用来为API描述添加更多信息。此外，`ProducesResponseType`注解帮助Swagger识别客户端必须处理的方法调用结果的可能代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Swagger, in addition to the annotations on single methods, is also instructed
    by the documentation of the language to give further information to those who
    will then have to use the API application. A description of the methods of the
    parameters is always welcome by those who will have to interface; unfortunately,
    it is not possible to exploit this functionality in the minimal API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger除了对单个方法的注解外，还受到语言文档的指导，为将使用API应用程序的人提供更多信息。参数方法的描述总是受到那些必须进行接口的人的欢迎；不幸的是，在最小API中无法利用此功能。
- en: 'Let’s go in order and see how to start using Swagger on a single method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序来看，看看如何在一个单独的方法上开始使用Swagger：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this first example, we have configured Swagger and general Swagger information.
    We have included additional information that enriches Swagger’s UI. The only mandatory
    information is the title, while the version, contact, description, license, and
    terms of service are optional.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个第一个例子，我们已经配置了Swagger和一般的Swagger信息。我们包括了丰富Swagger UI的附加信息。唯一必需的信息是标题，而版本、联系信息、描述、许可和服务条款是可选的。
- en: The `UseSwaggerUI()` method automatically configures where to put the UI and
    the JSON file describing the API with the OpenAPI format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseSwaggerUI()`方法自动配置了UI的放置位置以及用OpenAPI格式描述API的JSON文件。'
- en: 'Here is the result at the graphical level:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是图形层面的结果：
- en: '![Figure 3.2 – The Swagger UI](img/Figure_3.2_B17902.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Swagger UI](img/Figure_3.2_B17902.jpg)'
- en: Figure 3.2 – The Swagger UI
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Swagger UI
- en: We can immediately see that the OpenAPI contract information has been placed
    in the `/swagger/v1/swagger.json` path.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到OpenAPI合同信息已经被放置在`/swagger/v1/swagger.json`路径上。
- en: The contact information is populated, but no operations are reported as we haven’t
    entered any yet. Should the API have versioning? In the top-right section, we
    can select the available operations for each version.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 联系信息已填充，但由于我们尚未输入任何操作，因此没有报告任何操作。API应该有版本控制吗？在右上角，我们可以选择每个版本的可用操作。
- en: 'We can customize the Swagger URL and insert the documentation on a new path;
    the important thing is to redefine `SwaggerEndpoint`, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自定义Swagger的URL并在新的路径上插入文档；重要的是要重新定义`SwaggerEndpoint`，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s now go on to add the endpoints that describe the business logic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续添加描述业务逻辑的端点。
- en: It is very important to define `RouteHandlerBuilder` because it allows us to
    describe all the properties of the endpoint that we have written in code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`RouteHandlerBuilder`非常重要，因为它允许我们描述我们在代码中编写的端点的所有属性。
- en: The UI of Swagger must be enriched as much as possible; we must describe at
    best what the minimal APIs allow us to specify. Unfortunately, not all the functionalities
    are available, as in ASP.NET Web API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger的UI必须尽可能丰富；我们必须尽可能详细地描述最小API允许我们指定的内容。不幸的是，并非所有功能都可用，就像在ASP.NET Web API中一样。
- en: Versioning in minimal APIs
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小API中的版本控制
- en: '**Versioning** in minimal APIs is not handled in the framework functionality;
    as a result, even Swagger cannot handle UI-side API versioning. So, we observe
    that when we go to the **Select a definition** section shown in *Figure 3.2*,
    only one entry for the current version of the API is visible.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小API中，**版本控制**不是由框架功能处理的；因此，甚至Swagger也无法处理UI端的API版本控制。所以，我们观察到当我们进入*图3.2*中显示的**选择定义**部分时，只能看到API当前版本的条目。
- en: Swagger features
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swagger功能
- en: We just realized that not all features are available in Swagger; let’s now explore
    what is available instead. To describe the possible output values of an endpoint,
    we can call functions that can be called after the handler, such as the `Produces`
    or `WithTags` functions, which we are now going to explore.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚意识到Swagger中并非所有功能都可用；现在让我们探索一下可用的功能。为了描述端点的可能输出值，我们可以调用在处理程序之后可以调用的函数，例如`Produces`或`WithTags`函数，我们现在将要探讨这些函数。
- en: The `Produces` function decorates the endpoint with all the possible responses
    that the client should be able to manage. We can add the name of the operation
    ID; this information will not appear in the Swagger screen, but it will be the
    name with which the client will create the method to call the endpoint. `OperationId`
    is the unique name of the operation made available by the handler.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Produces` 函数用客户端应该能够管理的所有可能响应装饰端点。我们可以添加操作 ID 的名称；此信息不会出现在 Swagger 屏幕上，但它将是客户端创建调用端点的方法的名称。`OperationId`
    是处理程序提供的操作的唯一名称。'
- en: To exclude an endpoint from the API description, you need to call `ExcludeFromDescription()`.
    This function is rarely used, but it is very useful in cases where you don’t want
    to expose endpoints to programmers who are developing the frontend because that
    particular endpoint is used by a machine application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要将端点从 API 描述中排除，需要调用 `ExcludeFromDescription()`。此函数很少使用，但在您不想向开发前端程序员的程序员暴露特定端点时，它非常有用。
- en: 'Finally, we can add and tag the various endpoints and segment them for better
    client management:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加和标记各种端点，并将它们分段以更好地进行客户端管理：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the graphical result of Swagger; as I anticipated earlier, the tags
    and operation IDs are not shown by the web client:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Swagger 的图形结果；正如我之前所预料的，标签和操作 ID 不会被 Web 客户端显示：
- en: '![Figure 3.3 – Swagger UI methods  ](img/Figure_3.3_B17902.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Swagger UI 方法](img/Figure_3.3_B17902.jpg)'
- en: Figure 3.3 – Swagger UI methods
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Swagger UI 方法
- en: 'The endpoint description, on the other hand, is very useful to include. It’s
    very easy to implement: just insert C# comments in the method (just insert three
    slashes, `///`, in the method). Minimal APIs don’t have methods like we are used
    to in web-based controllers, so they are not natively supported.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，端点描述非常有用，可以包含在内。它非常容易实现：只需在方法中插入 C# 注释（只需在方法中插入三个斜杠，`///`）。Minimal APIs
    没有我们习惯于在基于 Web 的控制器中的方法，因此它们不是原生支持的。
- en: Swagger isn’t just the GUI we’re used to seeing. Above all, Swagger is the JSON
    file that supports the OpenAPI specification, of which the latest version is 3.1.0.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 不仅仅是我们所习惯看到的 GUI。首先，Swagger 是支持 OpenAPI 规范的 JSON 文件，其中最新版本是 3.1.0。
- en: 'In the following snippet, we show the section containing the description of
    the first endpoint that we inserted in the API. We can infer both the tag and
    the operation ID; this information will be used by those who will interface with
    the API:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们展示了包含我们插入 API 的第一个端点描述的章节。我们可以推断出标签和操作 ID；这些信息将由与 API 接口的人使用：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we have seen how to configure Swagger and what is currently
    not yet supported.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何配置 Swagger 以及目前尚未支持的内容。
- en: In the following chapters, we will also see how to configure OpenAPI, both for
    the OpenID Connect standard and authentication via the API key.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何配置 OpenAPI，包括 OpenID Connect 标准和通过 API 密钥进行认证。
- en: In the preceding code snippet of the Swagger UI, Swagger makes the schematics
    of the objects involved available, both inbound to the various endpoints and outbound
    from them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Swagger UI 代码片段中，Swagger 使涉及的对象的规范图可用，无论是输入到各个端点还是从它们输出。
- en: '![Figure 3.4 – Input and output data schema ](img/Figure_3.4_B17902.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 输入和输出数据规范](img/Figure_3.4_B17902.jpg)'
- en: Figure 3.4 – Input and output data schema
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 输入和输出数据规范
- en: We will learn how to deal with these objects and how to validate and define
    them in [*Chapter 6*](B17902_06.xhtml#_idTextAnchor082), *Exploring Validation
    and Mapping*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何处理这些对象，以及如何在 [*第 6 章*](B17902_06.xhtml#_idTextAnchor082) *探索验证和映射* 中验证和定义它们。
- en: Swagger OperationFilter
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swagger OperationFilter
- en: The operation filter allows you to add behavior to all operations shown by Swagger.
    In the following example, we’ll show you how to add an HTTP header to a particular
    call, filtering it by `OperationId`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 操作过滤器允许您向 Swagger 显示的所有操作添加行为。在下面的示例中，我们将向您展示如何通过 `OperationId` 过滤器向特定调用添加 HTTP
    头。
- en: 'When you go to define an operation filter, you can also set filters based on
    routes, tags, and operation IDs:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义操作过滤器时，您还可以根据路由、标签和操作 ID 设置过滤器：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To define an operation filter, the `IOperationFilter` interface must be implemented.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个操作过滤器，必须实现 `IOperationFilter` 接口。
- en: In the constructor, you can define all interfaces or objects that have been
    previously registered in the dependency inject engine.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，您可以定义所有之前已在依赖注入引擎中注册的接口或对象。
- en: 'The filter then consists of a single method, called `Apply`, which provides
    two objects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，过滤器由一个名为`Apply`的单个方法组成，它提供了两个对象：
- en: '`OpenApiOperation`: An operation where we can add parameters or check the operation
    ID of the current call'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenApiOperation`：一个可以添加参数或检查当前调用操作ID的操作'
- en: '`OperationFilterContext`: The filter context that allows you to read `ApiDescription`,
    where you can find the URL of the current endpoint'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OperationFilterContext`：允许你读取`ApiDescription`的过滤器上下文，在那里你可以找到当前端点的URL'
- en: Finally, to enable the operation filter in Swagger, we will need to register
    it inside the `SwaggerGen` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在Swagger中启用操作过滤器，我们需要在`SwaggerGen`方法内部注册它。
- en: 'In this method, we should then add the filter, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们应该添加过滤器，如下所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the result at the UI level; in the endpoint and only for a particular
    operation ID, we would have a new mandatory header with a default parameter that,
    in development, will not have to be inserted:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是UI级别的结果；在端点和特定操作ID的情况下，我们会有一个新的强制头，默认参数在开发中不需要插入：
- en: '![Figure 3.5 – API key section ](img/Figure_3.5_B17902.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – API密钥部分](img/Figure_3.5_B17902.jpg)'
- en: Figure 3.5 – API key section
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – API密钥部分
- en: This case study helps us a lot when we have an API key that we need to set up
    and we don’t want to insert it on every single call.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要设置API密钥但又不想在每次调用中都插入它时，这个案例研究对我们帮助很大。
- en: Operation filter in production
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境中的操作过滤器
- en: Since Swagger should not be enabled in the production environment, the filter
    and its default value will not create application security problems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Swagger不应该在生产环境中启用，因此过滤器及其默认值不会创建应用程序安全问题。
- en: We recommend that you disable Swagger in the production environment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你在生产环境中禁用Swagger。
- en: In this section, we figured out how to enable a UI tool that describes the API
    and allows us to test it. In the next section, we will see how to enable the call
    between **single-page applications** (**SPAs**) and the backend via CORS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了如何启用一个描述API并允许我们测试它的UI工具。在下一节中，我们将看到如何通过CORS启用**单页应用程序**（**SPAs**）和后端之间的调用。
- en: Enabling CORS
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用CORS
- en: CORS is a security mechanism whereby an HTTP/S request is blocked if it arrives
    from a different domain than the one where the application is hosted. More information
    can be found in the Microsoft documentation or on the Mozilla site for developers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: CORS是一种安全机制，如果HTTP/S请求来自与应用程序托管域不同的域，则会阻止请求。更多信息可以在Microsoft文档或Mozilla开发者网站上找到。
- en: A browser prevents a web page from making requests to a domain other than the
    domain that serves that web page. A web page, SPA, or server-side web page can
    make HTTP requests to several backend APIs that are hosted in different origins.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器阻止网页向除提供该网页的域以外的域发送请求。一个网页、SPA或服务器端网页可以向托管在不同源的不同后端API发送HTTP请求。
- en: This restriction is called the **same-origin policy**. The same-origin policy
    prevents a malicious site from reading data from another site. Browsers don’t
    block HTTP requests but do block response data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制被称为**同源策略**。同源策略阻止恶意网站从另一个网站读取数据。浏览器不会阻止HTTP请求，但会阻止响应数据。
- en: We, therefore, understand that the CORS qualification, as it relates to safety,
    must be evaluated with caution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们理解，与安全相关的CORS资格必须谨慎评估。
- en: 'The most common scenario is that of SPAs that are released on web servers with
    different web addresses than the web server hosting the minimal API:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的场景是，在发布于与托管最小API的Web服务器不同地址的Web服务器上发布的SPAs：
- en: '![Figure 3.6 – SPA and minimal API ](img/Figure_3.6_B17902.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – SPA和最小API](img/Figure_3.6_B17902.jpg)'
- en: Figure 3.6 – SPA and minimal API
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – SPA和最小API
- en: A similar scenario is that of microservices, which need to talk to each other.
    Each microservice will reside at a particular web address that will be different
    from the others.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的场景是微服务，它们需要相互通信。每个微服务将驻留在特定的Web地址上，这个地址将与其他的不同。
- en: '![Figure 3.7 – Microservices and minimal APIs ](img/Figure_3.7_B17902.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 微服务和最小API](img/Figure_3.7_B17902.jpg)'
- en: Figure 3.7 – Microservices and minimal APIs
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 微服务和最小API
- en: In all these cases, therefore, a CORS problem is encountered.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这些所有情况下，都会遇到CORS问题。
- en: We now understand the cases in which a CORS request can occur. Now let’s see
    what the correct HTTP request flow is and how the browser handles the request.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了CORS请求可能发生的情况。现在让我们看看正确的HTTP请求流程以及浏览器如何处理请求。
- en: CORS flow from an HTTP request
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从HTTP请求到CORS流程
- en: What happens when a call leaves the browser for a different address other than
    the one where the frontend is hosted?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用离开浏览器，前往除前端托管地址之外的其他地址时会发生什么？
- en: The HTTP call is executed and it goes all the way to the backend code, which
    executes correctly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP调用被执行，并且一直传递到后端代码，后端代码执行正确。
- en: The response, with the correct data inside, is blocked by the browser. That’s
    why when we execute a call with Postman, Fiddler, or any HTTP client, the response
    reaches us correctly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 带有正确数据的响应被浏览器阻止。这就是为什么当我们使用Postman、Fiddler或任何HTTP客户端执行调用时，响应能够正确地到达我们。
- en: '![Figure 3.8 – CORS flow ](img/Figure_3.8_B17902.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – CORS流程](img/Figure_3.8_B17902.jpg)'
- en: Figure 3.8 – CORS flow
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – CORS流程
- en: 'In the following figure, we can see that the browser makes the first call with
    the `OPTIONS` method, to which the backend responds correctly with a `204` status
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到浏览器使用`OPTIONS`方法发出第一次调用，后端正确地以`204`状态码响应：
- en: '![Figure 3.9 – First request for the CORS call (204 No Content result) ](img/Figure_3.9_B17902.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – CORS调用的第一次请求（204无内容结果）](img/Figure_3.9_B17902.jpg)'
- en: Figure 3.9 – First request for the CORS call (204 No Content result)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – CORS调用的第一次请求（204无内容结果）
- en: 'In the second call that the browser makes, an error occurs; the `strict-origin-when-cross-origin`
    value is shown in **Referrer Policy**, which indicates the refusal by the browser
    to accept data from the backend:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器发出的第二次调用中，发生了一个错误；在**Referrer Policy**中显示了`strict-origin-when-cross-origin`的值，这表明浏览器拒绝接受来自后端的数据：
- en: '![Figure 3.10 – Second request for the CORS call (blocked by the browser) ](img/Figure_3.10_B17902.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – CORS调用的第二次请求（被浏览器阻止）](img/Figure_3.10_B17902.jpg)'
- en: Figure 3.10 – Second request for the CORS call (blocked by the browser)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – CORS调用的第二次请求（被浏览器阻止）
- en: 'When CORS is enabled, in the response to the `OPTIONS` method call, three headers
    are inserted with the characteristics that the backend is willing to respect:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当CORS启用时，在`OPTIONS`方法调用的响应中，插入三个具有后端愿意遵守的特征的头：
- en: '![Figure 3.11 – Request for CORS call (with CORS enabled) ](img/Figure_3.11_B17902.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – CORS调用的请求（已启用CORS）](img/Figure_3.11_B17902.jpg)'
- en: Figure 3.11 – Request for CORS call (with CORS enabled)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – CORS调用的请求（已启用CORS）
- en: In this case, we can see that three headers are added that define `Access-Control-Allow-Headers`,
    `Access-Control-Allow-Methods`, and `Access-Control-Allow-Origin`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到添加了三个头，定义了`Access-Control-Allow-Headers`、`Access-Control-Allow-Methods`和`Access-Control-Allow-Origin`。
- en: The browser with this information can accept or block the response to this API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些信息的浏览器可以接受或阻止对这一API的响应。
- en: Setting CORS with a policy
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用策略设置CORS
- en: Many configurations are possible within a .NET 6 application for activating
    CORS. We can define authorization policies in which the four available settings
    can be configured. CORS can also be activated by adding extension methods or annotations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6应用程序中，有许多配置可以激活CORS。我们可以定义授权策略，其中可以配置四个可用的设置。CORS也可以通过添加扩展方法或注解来激活。
- en: But let us proceed in order.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们按顺序进行。
- en: The `CorsPolicyBuilder` class allows us to define what is allowed or not allowed
    within the CORS acceptance policy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`CorsPolicyBuilder`类允许我们定义在CORS接受策略中允许或不允许的内容。'
- en: 'We have, therefore, the possibility to set different methods, for example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有设置不同方法的可能性，例如：
- en: '`AllowAnyHeader`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowAnyHeader`'
- en: '`AllowAnyMethod`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowAnyMethod`'
- en: '`AllowAnyOrigin`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowAnyOrigin`'
- en: '`AllowCredentials`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowCredentials`'
- en: While the first three methods are descriptive and allow us to enable any settings
    relating to the header, method, and origin of the HTTP call, respectively, `AllowCredentials`
    allows us to include the cookie with the authentication credentials.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前三种方法都是描述性的，允许我们分别启用与HTTP调用头、方法和源相关的任何设置，但`AllowCredentials`允许我们包含带有认证凭据的cookie。
- en: CORS policy recommendations
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: CORS策略建议
- en: 'We recommend that you don’t use the `AllowAny` methods but instead filter out
    the necessary information to allow for greater security. As a best practice, when
    enabling CORS, we recommend the use of these methods:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您不要使用`AllowAny`方法，而是过滤出必要的信息以提供更高的安全性。作为最佳实践，在启用CORS时，我们建议使用这些方法：
- en: '`WithExposedHeaders`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithExposedHeaders`'
- en: '`WithHeaders`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithHeaders`'
- en: '`WithOrigins`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithOrigins`'
- en: To simulate a scenario for CORS, we created a simple frontend application with
    three different buttons. Each button allows you to test one of the possible configurations
    of CORS within the minimal API. We will explain these configurations in a few
    lines.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟 CORS 的场景，我们创建了一个简单的前端应用程序，有三个不同的按钮。每个按钮允许你测试最小 API 中 CORS 的可能配置之一。我们将在几行中解释这些配置。
- en: To enable the CORS scenario, we have created a single-page application that
    can be launched on a web server in memory. We have used `LiveReloadServer`, a
    tool that can be installed with the .NET CLI. We talked about it at the start
    of the chapter and now it’s time to use it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 CORS 场景，我们创建了一个单页应用程序，它可以在内存中的 Web 服务器上启动。我们使用了 `LiveReloadServer` 工具，这是一个可以使用
    .NET CLI 安装的工具。我们在本章开头提到了它，现在是我们使用它的时候了。
- en: 'After installing it, you need to launch the SPA with the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，你需要使用以下命令启动 SPA：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `BasePath` is the folder where you are going to download the examples
    available on GitHub.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BasePath` 是你将要下载 GitHub 上可用的示例的文件夹。
- en: 'Then you must start the application backend, either through Visual Studio or
    Visual Studio Code or through the .NET CLI with the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你必须启动应用程序的后端，无论是通过 Visual Studio 还是 Visual Studio Code，或者通过以下命令使用 .NET CLI：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve figured out how to start an example that highlights the CORS problem;
    now we need to configure the server to accept the request and inform the browser
    that it is aware that the request is coming from a different source.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了如何启动一个突出 CORS 问题的示例；现在我们需要配置服务器以接受请求并通知浏览器它知道请求来自不同的源。
- en: Next, we will talk about policy configuration. We will understand the characteristics
    of the default policy as well as how to create a custom one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论策略配置。我们将了解默认策略的特点以及如何创建一个自定义策略。
- en: Configuring a default policy
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置默认策略
- en: To configure a single CORS enabling policy, you need to define the behavior
    in the `Program.cs` file and add the desired configurations. Let’s implement a
    policy and define it as `Default`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置单个启用 CORS 的策略，需要在 `Program.cs` 文件中定义行为并添加所需的配置。让我们实现一个策略并将其定义为 `Default`。
- en: 'Then, to enable the policy for the whole application, simply add `app.UseCors();`
    before defining the handlers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使整个应用程序启用该策略，只需在定义处理程序之前添加 `app.UseCors();`：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Configuring custom policies
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置自定义策略
- en: We can create several policies within an application; each policy may have its
    own configuration and each policy may be associated with one or more endpoints.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序中创建多个策略；每个策略可能有它自己的配置，每个策略可能关联一个或多个端点。
- en: In the case of microservices, having several policies helps to precisely segment
    access from a different source.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的情况下，拥有几个策略有助于精确地分割来自不同源的对访问。
- en: In order to configure a new policy, it is necessary to add it and give it a
    name; this name will give access to the policy and allow it to be associated with
    the endpoint.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置一个新的策略，必须添加它并给它一个名称；这个名称将赋予策略访问权限，并允许它与端点关联。
- en: 'The customized policy, as in the previous example, is assigned to the entire
    application:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，自定义策略被分配给整个应用程序：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We next look at how to apply a single policy to a specific endpoint; to this
    end, two methods are available. The first is via an extension method to the `IEndpointConventionBuilder`
    interface. The second method is to add the `EnableCors` annotation followed by
    the name of the policy to be enabled for that method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何将单个策略应用于特定的端点；为此，有两种方法。第一种是通过 `IEndpointConventionBuilder` 接口的扩展方法。第二种方法是在方法中添加
    `EnableCors` 注解，后跟要启用的策略名称。
- en: Setting CORS with extensions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展设置 CORS
- en: It is necessary to use the `RequireCors` method followed by the name of the
    policy.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用 `RequireCors` 方法后跟策略的名称。
- en: 'With this method, it is then possible to enable one or more policies for an
    endpoint:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，然后可以为一个端点启用一个或多个策略：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting CORS with an annotation
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注解设置 CORS
- en: 'The second method is to add the `EnableCors` annotation followed by the name
    of the policy to be enabled for that method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是添加 `EnableCors` 注解，后跟要为该方法启用的策略名称：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Regarding controller programming, it soon becomes apparent that it is not possible
    to apply a policy to all methods of a particular controller. It is also not possible
    to group controllers and enable the policy. It is therefore necessary to apply
    the individual policy to the method or the entire application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于控制器编程，很快就会很明显，无法将策略应用于特定控制器的所有方法。也无法将控制器分组并启用策略。因此，有必要将单个策略应用于方法或整个应用程序。
- en: In this section, we found out how to configure browser protection for applications
    hosted on different domains.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到如何为托管在不同域上的应用程序配置浏览器保护。
- en: In the next section, we will start configuring our applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始配置我们的应用程序。
- en: Working with global API settings
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与全局API设置一起工作
- en: We have just defined how you can load data with the `options` pattern within
    an ASP.NET application. In this section, we want to describe how you can configure
    an application and take advantage of everything we saw in the previous section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了如何在ASP.NET应用程序中使用`options`模式加载数据。在本节中，我们想要描述如何配置应用程序并利用上一节中看到的一切。
- en: With the birth of `Web.config` file to the `appsettings.json` file. The configurations
    can also be read from other sources, such as other file formats like the old `.ini`
    file or a positional file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着从`Web.config`文件到`appsettings.json`文件的诞生。配置也可以从其他来源读取，例如其他文件格式，如旧的`.ini`文件或位置文件。
- en: In minimal APIs, the `options` pattern feature remains unchanged, but in the
    next few paragraphs, we will see how to reuse the interfaces or the `appsettings.json`
    file structure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小API中，`options`模式功能保持不变，但在接下来的几段中，我们将看到如何重用接口或`appsettings.json`文件结构。
- en: Configuration in .NET 6
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 6中的配置
- en: The object provided from .NET is `IConfiguration`, which allows us to read some
    specific configurations inside the `appsettings` file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供的对象是`IConfiguration`，它允许我们读取`appsettings`文件中的某些特定配置。
- en: But, as described earlier, this interface does much more than just access a
    file for reading.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如前所述，此接口的功能远不止访问文件进行读取。
- en: 'The following extract from the official documentation helps us understand how
    the interface is the generic access point that allows us to access the data inserted
    in various services:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从官方文档中摘录的内容，有助于我们了解接口是如何成为通用的访问点，使我们能够访问各种服务中插入的数据：
- en: Configuration in ASP.NET Core is performed using one or more configuration providers.
    Configuration providers read configuration data from key-value pairs using a variety
    of configuration sources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core中的配置是通过一个或多个配置提供程序来执行的。配置提供程序使用各种配置来源从键值对中读取配置数据。
- en: 'The following is a list of configuration sources:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个配置来源列表：
- en: Settings files, such as `appsettings.json`
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置文件，如`appsettings.json`
- en: Environment variables
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Azure Key Vault
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Key Vault
- en: Azure App Configuration
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure App Configuration
- en: Command-line arguments
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: Custom providers, installed or created
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义提供程序，已安装或创建
- en: Directory files
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录文件
- en: In-memory .NET objects
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中的.NET对象
- en: ([https://docs.microsoft.com/aspnet/core/fundamentals/configuration/](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/))
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://docs.microsoft.com/aspnet/core/fundamentals/configuration/](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/))
- en: The `IConfiguration` and `IOptions` interfaces, which we will see in the next
    chapter, are designed to read data from the various providers. These interfaces
    are not suitable for reading and editing the configuration file while the program
    is running.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到的`IConfiguration`和`IOptions`接口旨在从各种提供程序中读取数据。这些接口不适合在程序运行时读取和编辑配置文件。
- en: The `IConfiguration` interface is available through the `builder` object, `builder.Configuration`,
    which provides all the methods needed to read a value, an object, or a connection
    string.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`IConfiguration`接口通过`builder`对象，`builder.Configuration`提供，它提供了读取值、对象或连接字符串所需的所有方法。'
- en: 'After looking at one of the most important interfaces that we will use to configure
    the application, we want to define good development practices and use a fundamental
    building block for any developer: namely, classes. Copying the configuration into
    a class will allow us to better enjoy the content anywhere in the code.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们将用于配置应用程序的最重要接口之一后，我们希望定义良好的开发实践，并使用任何开发者都应具备的基本构建块：即类。将配置复制到类中将使我们能够在代码的任何地方更好地享受内容。
- en: 'We define classes containing a property and classes corresponding `appsettings`
    file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义包含属性的类和对应于`appsettings`文件的类：
- en: Configuration classes
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 配置类
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here, we bring back the corresponding JSON of the C# class that we just
    saw:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重新引入我们刚才看到的C#类的相应JSON：
- en: appsettings.json definition
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: appsettings.json定义
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we will be performing several operations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行几个操作。
- en: 'The first operation we perform creates an instance of the `startupConfig` object
    that will be of the `MyCustomStartupObject` type. To populate the instance of
    this object, through `IConfiguration`, we are going to read the data from the
    section called `MyCustomStartupObject`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的第一个操作是创建一个`startupConfig`对象的实例，该实例将是`MyCustomStartupObject`类型。为了填充此对象的实例，通过`IConfiguration`，我们将从名为`MyCustomStartupObject`的部分读取数据：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The newly created object can then be used in the various handlers of the minimal
    APIs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的对象可以用于最小API的各种处理器中。
- en: 'Instead, in this second operation, we use the dependency injection engine to
    request the instance of the `IConfiguration` object:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在这个第二个操作中，我们使用依赖注入引擎来请求`IConfiguration`对象的实例：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the `IConfiguration` object, we will retrieve the data similarly to the
    operation just described. We select the `GetSection(nameof(MyCustomObject))` section
    and type the object with the `Get<T>()` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IConfiguration`对象，我们将以类似上述操作的方式检索数据。我们选择`GetSection(nameof(MyCustomObject))`部分，并使用`Get<T>()`方法输入对象。
- en: 'Finally, in these last two examples, we read a single key, present at the root
    level of the `appsettings` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这最后两个例子中，我们读取一个位于`appsettings`文件根级别的单个键：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `configuration.GetValue<T>(“JsonRootKey”)` method extracts the value of
    a key and converts it into an object; this method is used to read strings or numbers
    from a root-level property.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`configuration.GetValue<T>("JsonRootKey")`方法提取键的值并将其转换为对象；此方法用于从根级属性读取字符串或数字。'
- en: In the next line, we can see how you can leverage an `IConfiguration` method
    to read `ConnectionString`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们可以看到如何利用`IConfiguration`方法读取`ConnectionString`。
- en: In the `appsettings` file, *connection strings* are placed in a specific section,
    `ConnectionStrings`, that allows you to name the string and read it. Multiple
    connection strings can be placed in this section to exploit it in different objects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`appsettings`文件中，*连接字符串*放置在特定的`ConnectionStrings`部分中，允许你命名字符串并读取它。可以在该部分放置多个连接字符串，以便在不同的对象中利用它。
- en: 'In the configuration provider for Azure App Service, connection strings should
    be entered with a prefix that also indicates the SQL provider you are trying to
    use, as described in the following link: [https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings](https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure App Service的配置提供程序中，连接字符串应以一个前缀输入，该前缀也指示你试图使用的SQL提供程序，如以下链接中所述：[https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings](https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings)。
- en: 'At runtime, connection strings are available as environment variables, prefixed
    with the following connection types:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，连接字符串作为以下连接类型的前缀的环境变量可用：
- en: SQLServer: `SQLCONNSTR_`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SQLServer: `SQLCONNSTR_`'
- en: MySQL: `MYSQLCONNSTR_`
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MySQL: `MYSQLCONNSTR_`'
- en: SQLAzure: `SQLAZURECONNSTR_`
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SQLAzure: `SQLAZURECONNSTR_`'
- en: Custom: `CUSTOMCONNSTR_`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Custom: `CUSTOMCONNSTR_`'
- en: PostgreSQL: `POSTGRESQLCONNSTR_`
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PostgreSQL: `POSTGRESQLCONNSTR_`'
- en: 'For completeness, we will bring back the entire code just described in order
    to have a better general picture of how to exploit the `IConfiguration` object
    inside the code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们将重新引入上述描述的整个代码，以便更好地了解如何在代码中利用`IConfiguration`对象：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ve seen how to take advantage of the `appsettings` file with connection strings,
    but very often, we have many different files for each environment. Let’s see how
    to take advantage of one file for each environment.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何利用包含连接字符串的`appsettings`文件，但很多时候，我们为每个环境有许多不同的文件。让我们看看如何为每个环境利用一个文件。
- en: Priority in appsettings files
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: appsettings文件中的优先级
- en: The `appsettings` file can be managed according to the environments in which
    the application is located. In this case, the practice is to place key information
    for that environment in the `appsettings.{ENVIRONMENT}.json` file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`appsettings`文件可以根据应用程序所在的环境进行管理。在这种情况下，实践是将该环境的密钥信息放置在`appsettings.{ENVIRONMENT}.json`文件中。'
- en: The root file (that is, `appsettings.json`) should be used for the production
    environment only.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件（即`appsettings.json`）应仅用于生产环境。
- en: For example, if we created these examples in the two files for the `“Priority”`
    key, what would we get?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在这两个文件中为`“Priority”`键创建了这些示例，我们会得到什么？
- en: appsettings.json
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: appsettings.json
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: appsettings.Development.json
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: appsettings.Development.json
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If it is a *Development* environment, the value of the key would result in `Dev`,
    while in a *Production* environment, the value would result in `Root`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是*开发*环境，键的值将导致`Dev`，而在*生产*环境中，值将导致`Root`。
- en: What would happen if the environment was anything other than *Production* or
    *Development*? For example, if it were called *Stage*? In this case, having not
    specified any `appsettings.Stage.json` file, the read value would be that of one
    of the `appsettings.json` files and therefore, `Root`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境不是*生产*或*开发*，会发生什么？例如，如果它被称作*阶段*？在这种情况下，由于没有指定任何`appsettings.Stage.json`文件，读取的值将是`appsettings.json`文件中的一个，因此，`Root`。
- en: However, if we specified the `appsettings.Stage.json` file, the value would
    be read from the that file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们指定了`appsettings.Stage.json`文件，值将从该文件中读取。
- en: Next, let’s visit the `Options` pattern. There are objects that the framework
    provides to load configuration information upon startup or when changes are made
    by the systems department. Let’s go over how.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`选项`模式。框架提供了一些对象，用于在启动时或系统部门进行更改时加载配置信息。让我们来看看如何操作。
- en: Options pattern
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项模式
- en: The `options` pattern uses classes to provide strongly typed access to groups
    of related settings, that is, when configuration settings are isolated by scenario
    into separate classes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`选项`模式使用类来提供对相关设置组的强类型访问，即当配置设置通过场景隔离到不同的类中时。'
- en: The `options` pattern will be implemented with different interfaces and different
    functionalities. Each interface (see the following subsection) has its own features
    that help us achieve certain goals.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`选项`模式将以不同的接口和不同的功能来实现。每个接口（见以下小节）都有其自身的功能，帮助我们实现某些目标。'
- en: 'But let’s start in order. We define an object for each type of interface (we
    will do it to better represent the examples), but the same class can be used to
    register more options inside the configuration file. It is important to keep the
    structure of the file identical:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们按顺序开始。我们为每种类型的接口定义一个对象（我们将这样做以更好地表示示例），但同一个类可以用于在配置文件中注册更多选项。保持文件结构相同是很重要的：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each option is registered in the dependency injection engine via the `Configure`
    method, which also requires the registration of the `T` type present in the method
    signature. As you can see, in the registration phase, we declared the types and
    the section of the file where to retrieve the information, and nothing more:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都通过`Configure`方法在依赖注入引擎中注册，该方法还要求注册方法签名中存在的`T`类型。如您所见，在注册阶段，我们声明了类型和文件中的部分，以及更多：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have not yet defined how the object should be read, how often, and with what
    type of interface.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未定义如何读取对象，多久读取一次，以及使用哪种类型的接口。
- en: The only thing that changes is the parameter, as seen in the last two examples
    of the preceding code snippet. This parameter allows you to add a name to the
    option type. The name is required to match the type used in the method signature.
    This feature is called **named options**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一改变的是参数，如前代码片段的最后两个示例所示。此参数允许您为选项类型添加一个名称。该名称必须与方法签名中使用的类型匹配。此功能称为**命名选项**。
- en: Different option interfaces
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同的选项接口
- en: 'Different interfaces can take advantage of the recordings you just defined.
    Some support named options and some do not:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的接口可以利用您刚刚定义的录制。一些支持命名选项，而另一些则不支持：
- en: '`IOptions<TOptions>`:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptions<TOptions>`:'
- en: 'Does not support the following:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持以下：
- en: Reading of configuration data after the app has started
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序启动后读取配置数据
- en: Named options
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名选项
- en: Is registered as a singleton and can be injected into any service lifetime
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册为单例，可以注入到任何服务生命周期中
- en: '`IOptionsSnapshot<TOptions>`:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptionsSnapshot<TOptions>`:'
- en: Is useful in scenarios where options should be recomputed on every request
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要为每个请求重新计算选项的场景中很有用
- en: Is registered as **scoped** and therefore cannot be injected into a singleton
    service
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册为**作用域**，因此不能注入到单例服务中
- en: Supports named options
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持命名选项
- en: '`IOptionsMonitor<TOptions>`:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptionsMonitor<TOptions>`:'
- en: Is used to retrieve options and manage options notifications for `TOptions` instances
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检索`TOptions`实例的选项和管理选项通知
- en: Is registered as a singleton and can be injected into any service lifetime
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为单例注册，并且可以被注入到任何服务生命周期中
- en: 'Supports the following:'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持以下内容：
- en: Change notifications
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更通知
- en: Named options
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名选项
- en: Reloadable configuration
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重载的配置
- en: Selective options invalidation (`IOptionsMonitorCache<TOptions>`)
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择性选项无效化（`IOptionsMonitorCache<TOptions>`）
- en: We want to point you to the use of `IOptionsFactory<TOptions>`, which is responsible
    for creating new instances of options. It has a single `Create` method. The default
    implementation takes all registered `IConfigureOptions<TOptions>` and `IPostConfigureOptions<TOptions>`
    and performs all configurations first, followed by post-configuration ([https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要指出`IOptionsFactory<TOptions>`的使用，它负责创建选项的新实例。它有一个单一的`Create`方法。默认实现首先执行所有注册的`IConfigureOptions<TOptions>`和`IPostConfigureOptions<TOptions>`配置，然后是后配置（[https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces)）。
- en: 'The `Configure` method can also be followed by another method in the configuration
    pipeline. This method is called `PostConfigure` and is intended to modify the
    configuration each time it is configured or reread. Here is an example of how
    to record this behavior:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure`方法后面还可以跟配置管道中的另一个方法。这个方法被称为`PostConfigure`，它的目的是在每次配置或重新读取配置时修改配置。以下是如何记录此行为的示例：'
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Putting it all together
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Having defined the theory of these numerous interfaces, it remains for us to
    see `IOptions` at work with a concrete example.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这些众多接口的理论之后，我们还需要通过一个具体的例子来看看`IOptions`是如何工作的。
- en: 'Let’s see the use of the three interfaces just described and the use of `IOptionsFactory`,
    which, along with the `Create` method and with the named options function, retrieves
    the correct instance of the object:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面描述的三个接口的使用，以及`IOptionsFactory`的使用，它通过`Create`方法和命名选项功能检索对象的正确实例：
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous code snippet, we want to bring attention to the use of the different
    interfaces available.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们想要引起大家对可用不同接口使用的注意。
- en: Each individual interface used in the previous snippet has a particular life
    cycle that characterizes its behavior. Finally, each interface has slight differences
    in the methods, as we have already described in the previous paragraphs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中使用的每个单独的接口都有其特定的生命周期，这决定了其行为。最后，每个接口在方法上都有细微的差异，正如我们在前面的段落中已经描述的那样。
- en: IOptions and validation
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOptions 和验证
- en: Last but not least is the validation functionality of the data present in the
    configuration. This is very useful when the team that has to release the application
    still performs manual or delicate operations that need to be at least verified
    by the code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是配置中存在的验证功能。当必须发布应用程序的团队仍然执行需要至少通过代码验证的手动或精细操作时，这非常有用。
- en: Before the advent of .NET Core, very often, the application would not start
    because of an incorrect configuration. Now, with this feature, we can validate
    the data in the configuration and throw errors.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core出现之前，应用程序经常因为配置错误而无法启动。现在，有了这个功能，我们可以验证配置中的数据并抛出错误。
- en: 'Here is an example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: Register option with validation
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注册具有验证的选项
- en: '[PRE28]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the configuration file where an error is explicitly reported:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是报告错误的配置文件：
- en: Appsettings section for configuration validation
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 配置验证的应用设置部分
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And here is the class containing the validation logic:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个包含验证逻辑的类的示例：
- en: '[PRE30]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The application then encounters errors while using the particular configuration
    and not at startup. This is also because, as we have seen before, `IOptions` could
    reload information following a change in `appsettings`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在使用特定配置时遇到错误，而不是在启动时。这也是因为我们之前看到，`IOptions`可以在`appsettings`更改后重新加载信息：
- en: Error validate option
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 错误验证选项
- en: '[PRE31]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Best practice for using validation in IOptions
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IOptions 中使用验证的最佳实践
- en: This setting is not suitable for all application scenarios. Only some options
    can have formal validations; if we think of a connection string, it is not necessarily
    formally incorrect, but the connection may not be working.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置并不适合所有应用程序场景。只有一些选项可以进行正式验证；如果我们考虑连接字符串，它可能并不一定是形式上不正确的，但连接可能无法工作。
- en: Be cautious about applying this feature, especially since it reports errors
    at runtime and not during startup and gives an Internal Server Error, which is
    not a best practice in scenarios that should be handled.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用此功能时要谨慎，特别是因为它在运行时而不是在启动时报告错误，并给出内部服务器错误，这在应该处理的场景中不是最佳实践。
- en: Everything we’ve seen up to this point is about configuring the `appsettings.json`
    file, but what if we wanted to use other sources for configuration management?
    We’ll look at that in the next section.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的一切都是关于配置`appsettings.json`文件，但如果我们想使用其他源进行配置管理怎么办？我们将在下一节中探讨这个问题。
- en: Configuration sources
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置源
- en: As we mentioned at the beginning of the section, the `IConfiguration` interface
    and all variants of `IOptions` work not only with the `appsettings` file but also
    on different sources.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，`IConfiguration`接口和所有`IOptions`变体不仅与`appsettings`文件一起工作，而且与不同的源一起工作。
- en: Each source has its own characteristics, and the syntax for accessing objects
    is very similar between providers. The main problem is when we must define a complex
    object or an array of objects; in this case, we will see how to behave and be
    able to replicate the dynamic structure of a JSON file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个源都有其自身的特性，并且在不同提供者之间访问对象的语法非常相似。主要问题在于我们必须定义一个复杂对象或对象数组时；在这种情况下，我们将看到如何表现并能够复制JSON文件的动态结构。
- en: Let’s look at two very common use cases.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个非常常见的用例。
- en: Configuring an application in Azure App Service
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Azure App Service中配置应用程序
- en: Let’s start with Azure, and in particular, the Azure Web Apps service.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Azure开始，特别是Azure Web Apps服务。
- en: 'On the **Configuration** page, there are two sections: **Application settings**
    and **Connection strings**.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在**配置**页面，有两个部分：**应用程序设置**和**连接字符串**。
- en: In the first section, we need to insert the keys and values or JSON objects
    that we saw in the previous examples.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们需要插入之前示例中看到的键和值或JSON对象。
- en: In the `appsettings.json` file. In this section, in addition to the textual
    string, it is necessary to set the connection type, as we saw in the *Configuration
    in .NET 6* section.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`appsettings.json`文件中。在本节中，除了文本字符串外，还需要设置连接类型，正如我们在*配置.NET 6*部分中看到的。
- en: '![Figure 3.12 – Azure App Service Application settings ](img/Figure_3.12_B17902.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – Azure App Service应用程序设置](img/Figure_3.12_B17902.jpg)'
- en: Figure 3.12 – Azure App Service Application settings
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – Azure App Service应用程序设置
- en: Inserting an object
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入对象
- en: To insert an object, we must specify the parent for each key.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入一个对象，我们必须为每个键指定父对象。
- en: 'The format is as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 格式如下：
- en: '`parent__key`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent__key`'
- en: Note that there are *two* underscores.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有*两个*下划线。
- en: 'The object in the JSON file would be defined as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: JSON文件中的对象定义如下：
- en: '[PRE32]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, we should write `MyCustomObject__CustomProperty`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该编写`MyCustomObject__CustomProperty`。
- en: Inserting an array
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入数组
- en: Inserting an array is much more verbose.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 插入数组要冗长得多。
- en: 'The format is as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 格式如下：
- en: '`parent__child__ArrayIndexNumber_key`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent__child__ArrayIndexNumber_key`'
- en: 'The array in the JSON file would be defined as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: JSON文件中的数组定义如下：
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So, to access the `ValueOne` value, we should write the following: `MyCustomArray__CustomPropertyArray__0__CustomKey`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要访问`ValueOne`值，我们应该编写以下内容：`MyCustomArray__CustomPropertyArray__0__CustomKey`。
- en: Configuring an application in Docker
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Docker中配置应用程序
- en: If we are developing for containers and therefore for Docker, `appsettings`
    files are usually replaced in the `docker-compose` file, and very often in the
    `override` file, because it behaves analogously to the settings files divided
    by the environment.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在为容器和Docker开发，`appsettings`文件通常在`docker-compose`文件中替换，并且在`override`文件中非常常见，因为它与环境分隔的设置文件行为类似。
- en: 'We want to provide a brief overview of the features that are usually leveraged
    to configure an application hosted in Docker. Let’s see in detail how to define
    root keys and objects, and how to set the connection string. Here is an example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供一个关于通常用于配置托管在Docker中的应用程序的功能的简要概述。让我们详细了解如何定义根键和对象，以及如何设置连接字符串。以下是一个示例：
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Minimal APIs that use configuration
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置的最小API
- en: 'The `docker-compose.override.yaml` file is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.override.yaml`文件如下：'
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There is only one application container for this example, and the service that
    instantiates it is called `dockerenvironment`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中只有一个应用程序容器，实例化它的服务称为`dockerenvironment`。
- en: In the configuration section, we can see three particularities that we are going
    to analyze line by line.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置部分，我们可以看到三个我们将逐行分析的特定之处。
- en: 'The snippet we want to show you has several very interesting components: a
    property in the configuration root, an object composed of a single property, and
    a connection string to a database.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示的代码片段有几个非常有趣的部分：配置根中的一个属性、由单个属性组成的对象以及数据库的连接字符串。
- en: 'In this first configuration, you are going to set a property that is the root
    of the configurations. In this case, it is a simple string:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个配置中，你需要设置一个作为配置根的属性。在这种情况下，它是一个简单的字符串：
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this second configuration, we are going to set up an object:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个配置中，我们将设置一个对象：
- en: '[PRE37]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The object is called `RootSettings`, while the only property it contains is
    called `SampleVariable`. This object can be read in different ways. We recommend
    using the `Ioptions` object that we have seen extensively before. In the preceding
    example, we show how to access a single property present in an object via code.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象被命名为 `RootSettings`，而它所包含的唯一属性被命名为 `SampleVariable`。这个对象可以通过不同的方式读取。我们建议使用我们之前广泛使用过的
    `Ioptions` 对象。在先前的示例中，我们展示了如何通过代码访问对象中存在的单个属性。
- en: 'In this case, via code, you need to use the following notation to access the
    value: `RootSettings:SampleVariable`. This approach is useful if you need to read
    a single property, but we recommend using the `Ioptions` interfaces to access
    the object.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过代码，你需要使用以下记法来访问值：`RootSettings:SampleVariable`。这种方法在需要读取单个属性时很有用，但我们建议使用
    `Ioptions` 接口来访问对象。
- en: 'In this last example, we show you how to set the connection string called `SqlConnection`.
    This way, it will be easy to retrieve the information from the base methods available
    on `Iconfiguration`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的示例中，我们向您展示如何设置名为 `SqlConnection` 的连接字符串。这样，将很容易从 `Iconfiguration` 上可用的基方法中检索信息：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To read the information, it is necessary to exploit this method: `GetConnectionString(“SqlConnection”)`.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取信息，必须利用此方法：`GetConnectionString("SqlConnection")`。
- en: There are a lot of scenarios for configuring our applications; in the next section,
    we will also see how to handle errors.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 配置我们的应用程序有很多场景；在下一节中，我们还将看到如何处理错误。
- en: Error handling
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling is one of the features that every application must provide. The
    representation of an error allows the client to understand the error and possibly
    handle the request accordingly. Very often, we have our own customized methods
    of handling errors.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是每个应用程序必须提供的功能之一。错误的表示允许客户端理解错误，并可能相应地处理请求。非常常见的是，我们有自己的自定义错误处理方法。
- en: Since what we’re describing is a key functionality of the application, we think
    it’s fair to see what the framework provides and what is more correct to use.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们描述的是应用程序的关键功能，我们认为查看框架提供的内容以及更正确的使用方式是公平的。
- en: Traditional approach
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统方法
- en: '.NET provides the same tool for minimal APIs that we can implement in traditional
    development: a **Developer Exception Page**. This is nothing but middleware that
    reports the error in plain text format. This middleware can’t be removed from
    the ASP.NET pipeline and works exclusively in the development environment ([https://docs.microsoft.com/aspnet/core/fundamentals/error-handling](https://docs.microsoft.com/aspnet/core/fundamentals/error-handling)).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 为最小 API 提供了与我们在传统开发中可以实现的相同工具：**开发者异常页面**。这只是一个以纯文本格式报告错误的中间件。这个中间件不能从
    ASP.NET 管道中移除，并且仅在开发环境中工作 ([https://docs.microsoft.com/aspnet/core/fundamentals/error-handling](https://docs.microsoft.com/aspnet/core/fundamentals/error-handling))。
- en: '![Figure 3.13 – Minimal APIs pipeline, ExceptionHandler ](img/Figure_3.13_B17902.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 最小 API 管道，ExceptionHandler](img/Figure_3.13_B17902.jpg)'
- en: Figure 3.13 – Minimal APIs pipeline, ExceptionHandler
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 最小 API 管道，ExceptionHandler
- en: If exceptions are raised within our code, the only way to catch them in the
    application layer is through middleware that is activated before sending the response
    to the client.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码中抛出了异常，在应用层中捕获它们的唯一方法是通过在向客户端发送响应之前激活的中间件。
- en: 'Error handling middleware is standard and can be implemented as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理中间件是标准的，可以按照以下方式实现：
- en: '[PRE39]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have shown here a possible implementation of the middleware. In order to
    be implemented, the `UseExceptionHandler` method must be exploited, allowing the
    writing of management code for the whole application.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示了中间件的可能实现。为了实现它，必须利用 `UseExceptionHandler` 方法，允许编写整个应用程序的管理代码。
- en: 'Through the `var` functionality called `exceptionHandlerPathFeature = context.Features.Get<IExceptionHandlerPathFeature>()!;`,
    we can access the error stack and return the information of interest for the caller
    in the output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名为 `exceptionHandlerPathFeature = context.Features.Get<IExceptionHandlerPathFeature>()!;`
    的 `var` 功能，我们可以访问错误堆栈，并在输出中返回对调用者有用的信息：
- en: '[PRE40]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When an exception occurs in the code, as in the preceding example, the middleware
    steps in and handles the return message to the client.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码中发生异常时，就像前面的例子一样，中间件介入并处理返回给客户端的消息。
- en: If the exception were to occur in internal application stacks, the middleware
    would still intervene to provide the client with the correct error and appropriate
    indication.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常发生在内部应用程序堆栈中，中间件仍然会介入，向客户端提供正确的错误和适当的指示。
- en: Problem Details and the IETF standard
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题详情与IETF标准
- en: '*Problem Details for HTTP APIs* is an IETF standard that was approved in 2016\.
    This standard allows a set of information to be returned to the caller with standard
    fields and JSON notations that help identify the error.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP API的问题详情* 是一个于2016年获得批准的IETF标准。此标准允许通过标准字段和JSON注释返回一组信息，这些注释有助于识别错误。'
- en: HTTP status codes are sometimes not enough to convey enough information about
    an error to be useful. While the humans behind web browsers can be informed about
    the nature of the problem with an HTML response body, non-human consumers, such
    as machine, PC, and server, of so-called *HTTP APIs* usually cannot.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态代码有时不足以传达足够的信息来描述错误，使其有用。虽然浏览器背后的人类可以通过HTML响应体了解问题的性质，但非人类消费者，如机器、PC和服务器，通常无法从所谓的
    *HTTP API* 中获得这些信息。
- en: This specification defines simple JSON and XML document formats to suit this
    purpose. They are designed to be reused by HTTP APIs, which can identify distinct
    *problem types* specific to their needs.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本规范定义了简单的JSON和XML文档格式，以满足此目的。它们被设计成可以被HTTP API重用，以识别特定于其需求的独特 *问题类型*。
- en: Thus, API clients can be informed of both the high-level error class and the
    finer-grained details of the problem ([https://datatracker.ietf.org/doc/html/rfc7807](https://datatracker.ietf.org/doc/html/rfc7807)).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，API客户端可以了解高级错误类和问题的更详细细节（[https://datatracker.ietf.org/doc/html/rfc7807](https://datatracker.ietf.org/doc/html/rfc7807)）。
- en: In .NET, there is a package with all the functionality that meets the IETF standard.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，有一个符合IETF标准的所有功能的包。
- en: 'The package is called `Hellang.Middleware.ProblemDetails`, and you can download
    it at the following address: [https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/](https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 该包名为 `Hellang.Middleware.ProblemDetails`，您可以从以下地址下载它：[https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/](https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/)。
- en: 'Let’s see now how to insert the package into the project and configure it:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将包插入项目并配置它：
- en: '[PRE41]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, there are only two instructions to make this package work:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只需两条指令即可使此包工作：
- en: '`builder.Services.AddProblemDetails`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builder.Services.AddProblemDetails`'
- en: '`app.UseProblemDetails();`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.UseProblemDetails();`'
- en: Since, in the minimal APIs, the `IActionResultExecutor` interface is not present
    in the ASP.NET pipeline, it is necessary to add a custom class to handle the response
    in case of an error.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在最小API中，`IActionResultExecutor` 接口不在ASP.NET管道中，因此有必要添加一个自定义类来处理错误情况下的响应。
- en: 'To do this, you need to add a class (the following) and register it in the
    dependency injection engine: `builder.Services.TryAddSingleton<IActionResultExecutor<ObjectResult>,
    ProblemDetailsResultExecutor>();`.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您需要添加一个类（如下所示）并在依赖注入引擎中注册它：`builder.Services.TryAddSingleton<IActionResultExecutor<ObjectResult>,
    ProblemDetailsResultExecutor>();`。
- en: 'Here is the class to support the package, also under minimal APIs:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是支持该包的类，也位于最小API之下：
- en: '[PRE42]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As mentioned earlier, the standard for handling error messages has been present
    in the IETF standard for several years, but for the C# language, it is necessary
    to add the package just mentioned.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，处理错误消息的标准已经在IETF标准中存在了几年，但对于C#语言来说，有必要添加前面提到的包。
- en: 'Now, let’s see how this package goes about handling errors on some endpoints
    that we report here:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个包是如何处理我们在这里报告的一些端点错误的：
- en: '[PRE43]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We throw an application-level exception with this endpoint. In this case, the
    `ProblemDetails` middleware goes and returns a JSON error consistent with the
    error. We then have the handling of an unhandled exception for free:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此端点抛出一个应用程序级别的异常。在这种情况下，`ProblemDetails`中间件会返回一个与错误一致的JSON错误。然后我们免费处理未处理的异常：
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By inserting additional configurations in the `Program` file, you can map some
    specific exceptions to HTTP errors. Here is an example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Program`文件中插入额外的配置，你可以将一些特定的异常映射到HTTP错误。以下是一个示例：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The code with the `NotImplementedException` exception is mapped to HTTP error
    code `501`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`NotImplementedException`异常的代码被映射到HTTP错误代码`501`：
- en: '[PRE46]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, it is possible to create extensions to the `ProblemDetails` class of
    the framework with additional fields or to call the `base` method by adding custom
    text.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过添加额外的字段或通过添加自定义文本调用`base`方法来扩展框架中`ProblemDetails`类的功能。
- en: 'Here are the last two examples of `MapGet` endpoint handlers:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`MapGet`端点处理程序的最后两个示例：
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen several advanced aspects regarding the implementation
    of minimal APIs. We explored Swagger, which is used to document APIs and provide
    the developer with a convenient, working debugging environment. We saw how CORS
    handles the issue of applications hosted on different addresses other than the
    current API. Finally, we saw how to load configuration information and handle
    unexpected errors in the application.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了关于最小API实现的一些高级方面。我们探讨了Swagger，它用于记录API并为开发者提供一个方便、实用的调试环境。我们看到了如何处理除当前API之外托管在不同地址上的应用程序的问题。最后，我们看到了如何加载配置信息和处理应用程序中的意外错误。
- en: We explored the nuts and bolts that will allow us to be productive in a short
    amount of time.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了在短时间内提高生产力的关键要素。
- en: In the next chapter, we will add a fundamental building block for SOLID pattern-oriented
    programming, namely the dependency injection engine, which will help us to better
    manage the application code scattered in the various layers.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加一个用于SOLID面向模式编程的基本构建块，即依赖注入引擎，这将帮助我们更好地管理散布在各种层中的应用代码。
- en: 'Part 2: What’s New in .NET 6?'
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：.NET 6的新特性是什么？
- en: In the second part of the book, we want to show you the features of the .NET
    6 framework and how they can also be used in minimal APIs.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，我们希望向您展示.NET 6框架的特性以及它们如何在最小API中使用。
- en: 'We will cover the following chapters in this section:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下章节：
- en: '[*Chapter 4*](B17902_04.xhtml#_idTextAnchor061), *Dependency Injection in a
    Minimal API Project*'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B17902_04.xhtml#_idTextAnchor061)，*最小API项目中的依赖注入*'
- en: '[*Chapter 5*](B17902_05.xhtml#_idTextAnchor068), *Using Logging to Identify
    Errors*'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B17902_05.xhtml#_idTextAnchor068)，*使用日志识别错误*'
- en: '[*Chapter 6*](B17902_06.xhtml#_idTextAnchor082), *Exploring Validation and
    Mapping*'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B17902_06.xhtml#_idTextAnchor082)，*探索验证和映射*'
- en: '[*Chapter 7*](B17902_07.xhtml#_idTextAnchor094), *Integration with the Data
    Access Layer*'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B17902_07.xhtml#_idTextAnchor094)，*与数据访问层的集成*'
