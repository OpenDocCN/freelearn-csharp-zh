<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor086"/>4</h1>
<h1 id="_idParaDest-85"><a id="_idTextAnchor087"/>Applying Security from the Start</h1>
<p>Next to performance, security<a id="_idIndexMarker157"/> should always be a top priority when building web applications. The ability to create secure web applications continues to be a problem with the evolving landscape of internet <a id="_idIndexMarker158"/>threats such as <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) and injection techniques. While the best developer can safeguard an application against even the worst threat, most attacks succeed through human interaction and environmental issues. The best approach for developers to protect their applications is to start from the ground up and create as many roadblocks as possible to deter even the most vigilant attackers from gaining access to their systems.</p>
<p>First, we’ll learn how to identify highly sensitive data and how to secure access. We’ll then move on to common security practices and provide various ASP.NET Core features that you can apply to your applications. Finally, we’ll review the top three security threats according to the <strong class="bold">Open Worldwide Application Security Project</strong> (<strong class="bold">OWASP</strong>) and how to safeguard <a id="_idIndexMarker159"/>your application.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Developing Security</li>
<li>Common Security Practices</li>
<li>Safeguarding Against the Top 3 Security Threats</li>
</ul>
<p>By the end of this chapter, you’ll understand what is considered sensitive data, a variety of common security practices in the industry, and how to safeguard yourself against the top three threats according to the OWASP Foundation.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor088"/>Technical requirements</h1>
<p>While we will talk about security in this chapter, most of the discussion will contain small snippets of code that you can include in your projects. Access to a code editor isn’t necessary for this chapter to understand the essentials of security at a developer level.</p>
<p>The code files for this chapter can be found here: https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor089"/>Developing Security</h1>
<p>In<a id="_idIndexMarker160"/> this section, we’ll examine terms and concepts regarding how to identify the data you need to secure and explain three extremely important ways to secure your website.</p>
<p>Too often, when developers start to build an ASP.NET web project, security is usually applied at the end of a project as opposed to being proactive and aware of security measures. One approach for implementing security is to examine your applications and look for these types of highly sensitive data throughout:</p>
<ul>
<li>Name and location</li>
<li>Usernames and passwords</li>
<li>Contact information (phone number, email address, and so on)</li>
<li>Social security number</li>
<li>Financials (customer plans, credit cards, and so on)</li>
<li>Database connections</li>
<li>Custom settings</li>
</ul>
<p>Depending on the intent of the web application, other types might be involved, such as specific access to a section where permissions are implied. Other types of data could be considered sensitive based on industry or even government regulations.</p>
<p>Security in your application should be examined based on the criteria discussed in the following sections.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>Do I have any sensitive data to protect?</h2>
<p>Based <a id="_idIndexMarker161"/>on your application and the list in the previous section, ask yourself, “If any of the data is leaked and made public, would there be a problem?”</p>
<p>Exposing any data from the aforementioned sources would be a disaster. Keep sensitive information contained using encryption, access controls, and secure coding practices, and use it only when necessary.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Am I exposing anything through the application?</h2>
<p>When moving from one web page to another, am I passing something sensitive when maneuvering through the site? Is the application using primary keys in the URL? How is data passed to the next page?</p>
<p>Be mindful of visible clues to the users that contain information such as primary keys or sensitive information. We’ll discuss this later in this chapter.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/>Am I sanitizing user input?</h2>
<p>When requesting input from a user, it’s always a good practice to sanitize the data. Sanitization, or scrubbing, is the process of taking user input and confirming it’s not malicious content that could compromise the system. One philosophy is to never trust submitted data.</p>
<p>It’s extremely important to use light validation with JavaScript/HTML on the client side, along with heavy validation and sanitization of data on the server.</p>
<p>Light validation would include ensuring the required fields are populated and contain the minimum and maximum length of data, and that certain fields meet a particular format (such as phone numbers, credit cards, and so on).</p>
<p>Heavier validation would reaffirm the light validation but also confirm various scenarios, such as that a user has access to something, referenced entities exist, or data disguised to<a id="_idIndexMarker162"/> cause malicious activity.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>Securing Access</h2>
<p>When building a website, it’s <a id="_idIndexMarker163"/>best to think about whether a user is required to log in to your site or not. If you’re creating a blog, there wouldn’t be a need to have users log in to view a post. They would just view it anonymously.</p>
<p>However, if you require a user to log in to your website, there is a minimum of three mandatory requirements you must understand to <em class="italic">begin</em> to secure your application. We’ll look at them in the following sections.</p>
<h3>Authentication</h3>
<p>When authenticating a <a id="_idIndexMarker164"/>user, you are <em class="italic">identifying and validating who they are</em> when they log in to your system.</p>
<p>This is the primary concept of Microsoft’s Identity framework. It offers various methods to authenticate a user using either username/password, the ability to use third-party social networks (such as Facebook, Google, or Twitter), use <strong class="bold">two-factor authentication</strong> (<strong class="bold">2FA</strong>), or even <a id="_idIndexMarker165"/>use third-party authenticators.</p>
<p>You may have already experienced this on a website where you have to enter your username and password. That is step one in authenticating a user. Once verified, you are then asked to enter the code that’s been sent to your email or the authenticator app on your phone. That is step two.</p>
<p>Many websites use a username and password to log in. While this is the bare minimum to secure a website, it may help to implement additional security measures when authenticating a user.</p>
<p>Again, it’s a better approach to create as many additional roadblocks to protect your application from attackers as possible. The more obstacles, the less likely your site will be compromised.</p>
<h3>Authorization</h3>
<p>Once the user has authenticated, what can they do in the system? This is where authorization enters the picture.</p>
<p>Authorization<a id="_idIndexMarker166"/> is the <em class="italic">process of granting permission to do something in a system or on a website</em>. For example, authors of a blog are permitted to update their articles when they log in, but they are not allowed to edit other articles unless they are authorized to do so by an administrator. An authorization system would need to be in place for this to work.</p>
<p>As mentioned in the <em class="italic">Authentication</em> section, Microsoft’s Identity framework contains various techniques for implementing role-based and user-based claims throughout the system. In our previous example, we mentioned that authors are only allowed to update their own articles. In a role-based system, the authors could be grouped into an “Authors” role, allowing them to create and update their own articles. In a user-based system, special privileges could be assigned at the user level, such as editing other authors’ articles.</p>
<p>While Microsoft Identity is flexible enough to incorporate any kind of authorization mechanism, developers should think about how to structure application-level authorizations from the very beginning before writing one line of code.</p>
<p>Authorizations <a id="_idIndexMarker167"/>are extremely important when you’re identifying what a logged-in user can (and can’t) do on your website.</p>
<h3>Secure Sockets Layer (SSL)</h3>
<p>If you’re <a id="_idIndexMarker168"/>building a website, SSL is <em class="italic">absolutely required</em>.</p>
<p>The necessity to have an SSL-enabled website protects you for the following reasons:</p>
<ul>
<li>You want your visitors to know they are on a secure website.</li>
<li>It prevents others on the same network viewing your login credentials.</li>
<li>HTTPS helps prevent<a id="_idIndexMarker169"/> a <strong class="bold">Man-in-the-Middle</strong> (<strong class="bold">MITM</strong>) attack, where an attacker inserts themselves into a conversation between two users, possibly altering the exchange of data.</li>
<li><strong class="bold">Search Engine Optimization</strong> (<strong class="bold">SEO</strong>). Google <a id="_idIndexMarker170"/>and other search engines use HTTPS as a ranking signal (reference: https://developers.google.com/search/blog/2014/08/https-as-ranking-signal). If you wanted to increase your chances of reaching number one in the search results, you should make your site SSL-enabled.</li>
</ul>
<p>Most hosting companies <em class="italic">include</em> an SSL certificate free of charge for your sites. That’s how important SSL is to a website.</p>
<p>In this section, we identified what is considered sensitive data and learned about how to secure access using three critical concepts when building an ASP.NET Core application.</p>
<p>In the next section, we’ll look over some common security practices you can immediately start using in your applications.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor094"/>Common Security Practices</h1>
<p>As a developer, security<a id="_idIndexMarker171"/> seems to be a black box sometimes. You always hear about incidents where websites have been hacked, but you might think to yourself, “That couldn’t happen to me,” until it happens to you. When you witness a website you built being attacked first-hand, it’s a humbling experience.</p>
<p>While the techniques we’re about to cover only scratch the surface for ASP.NET websites, they encourage developers to become more <em class="italic">proactive</em> in their coding as opposed to finding out they were hacked and immediately becoming <em class="italic">reactive</em>.</p>
<p>In this section, we’ll review common security practices in the industry you can use to protect yourself so that you know what your system is doing and are not exposing too much to the world. We’ll learn about the different types of logs, how to update libraries and frameworks, and how to remove header information. We’ll finish this chapter by learning how to encrypt Entity Framework Core database columns.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/>Logging</h2>
<p>Once you’ve created your website, some extra features are required before you can roll out the red carpet for everyone to <a id="_idIndexMarker172"/>enjoy it.</p>
<p>How do you know what’s going on with your website? How will you know when someone deletes a post? How about a transaction? How long does it take for your Web API to make a full trip to present data? These questions should be answered by creating audit trails and enabling general logging for your application.</p>
<p>Audit trails<a id="_idIndexMarker173"/> are a type of logging where you keep track of every action a user has executed in your system. Microsoft Id<a id="_idIndexMarker174"/>entity should already be in place with logging code to sprinkle throughout the application.</p>
<p>IIS Logs<a id="_idIndexMarker175"/> are a type of audit trail. Every user accessing your system, including anonymous users, is logged through IIS. A simple log entry is shown here:</p>
<pre class="source-code">
192.168.15.11, -, 01/01/22, 7:55:20, W3SVC2, -, 182.15.22.90, 4502, 163, 3223, 200, 0, GET, /Index, -,</pre> <p>Standard data used in an audit trail would contain the following:</p>
<ul>
<li>Date/time</li>
<li>IP address/port</li>
<li>URL</li>
<li>Action taken</li>
<li>The user who executed the action</li>
<li>An entity state before and after the action was executed (<em class="italic">optional</em>)</li>
</ul>
<p>General logging<a id="_idIndexMarker176"/> is carried out more at an <a id="_idIndexMarker177"/>application level as opposed to a system level. Most general logging includes data such as this:</p>
<ul>
<li>Date/time</li>
<li>URL</li>
<li>Log type (informational, warning, or error)</li>
<li>A comment about the action</li>
<li>Method/action/section name performing the action</li>
<li>The duration of the process (<em class="italic">optional</em>)</li>
</ul>
<p>These types of <a id="_idIndexMarker178"/>logs are essential in the API world. These logs are created by the developer and stored on a disk or in a database. Once you create a Web API, there will be moments when you’ll wonder what it’s doing and why it’s taking so long to complete a request. Logs are <a id="_idIndexMarker179"/>windows to the system. What exactly is happening there?</p>
<p>When it comes to security, your logs are gold. If someone impersonates another user, you can immediately examine the logs, identify the user and IP, and take the necessary actions to prevent it from happening again. This could be done by resetting a password, disconnecting or disabling a user from logging in, or even removing the user from the system overall.</p>
<p>Without <a id="_idIndexMarker180"/>logging, you’ll <a id="_idIndexMarker181"/>be unaware of events occurring in your system.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/>Keep your Framework and Libraries Current</h2>
<p>Every <a id="_idIndexMarker182"/>developer has their favorite libraries and frameworks. With .NET, there are times when the framework requires an update to prevent possible security threats.</p>
<p>Once you are aware of these security updates, it’s your responsibility to update the framework and/or libraries or notify someone who <em class="italic">can</em> perform the update (in case developers are not allowed to update servers) to protect against any type of threat based on the update’s vulnerabilities.</p>
<p>Twice in my career, a .NET version had a security issue and a security update was released to be applied to the framework. The patch wasn’t applied immediately. Two weeks later, there was a breach and it was concluded the breach could’ve been prevented if the patch was applied two weeks earlier.</p>
<p>It was a bad day for the company.</p>
<p>To see whether there is a security patch for .NET, refer to the <a id="_idIndexMarker183"/>Microsoft Update Catalog at https://www.catalog.update.microsoft.com/home.aspx.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>Always Force SSL</h2>
<p>If a visitor <a id="_idIndexMarker184"/>arrives through an HTTP URL and not HTTPS, it’s best to redirect them over to the secure portion of your site.</p>
<p><strong class="bold">HTTP Strict Transport Security Protocol</strong> (<strong class="bold">HSTS</strong>) is a security enhancement specified by the web application through a <a id="_idIndexMarker185"/>response header. When the browser receives an HSTS header, it prevents the user from using untrusted or invalid certificates.</p>
<p>However, there are limitations to using this:</p>
<ul>
<li>Modern clients must support HSTS</li>
<li>HSTS must establish one HTTPS connection to establish an HSTS policy</li>
<li>The web application must examine every HTTP request and redirect or reject the HTTP request</li>
</ul>
<p>To implement <a id="_idIndexMarker186"/>this in your code, you must revisit the middleware and add the HSTS extension to a production environment. If you’ve just created a new web app, this is automatically added by default. Here is an example:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
var app = builder.Build();
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
<strong class="bold">    app.UseHsts();</strong>
}
<strong class="bold">app.UseHttpsRedirection();</strong>
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.MapRazorPages();
app.Run();</pre> <p>The <code>app.UseHttpsRedirection()</code> method must appear after the <code>app.UseHsts()</code> extension method for the redirect to occur. This ensures your users will be visiting an <a id="_idIndexMarker187"/>SSL-enabled website.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Never Trust the Client</h2>
<p>I’ve<a id="_idIndexMarker188"/> always likened this approach with the old saying, “Wearing suspenders with a belt.” At least you wouldn’t be caught with your pants down (as I use this as a security metaphor).</p>
<p>As mentioned near the beginning of this chapter, the intent here is to validate and sanitize data that’s been submitted by the client as best you can with JavaScript and HTML and then follow up with additional validation using C# when a form is submitted.</p>
<p>For example, HTML 5 is now available in almost every browser, with the ability to apply a certain type to a text input, such as <code>type="number"</code> or <code>type="date"</code>. A welcome addition to this collection of input types is the ability to add a regex pattern to make validation even easier on the client side:</p>
<pre class="source-code">
&lt;input type="text"
       placeholder="Enter a Columbus Phone Number"
       title="Enter either a 740 or 614 area code using this format: (740) 999-9999"
       pattern="^\(?(740|614)\)?(\s+)?[0-9]{3}-?[0-9]{4}$"
       required /&gt;</pre> <p>This pattern allows for either 740 or 614 area codes to be in a phone number. If the pattern doesn’t match, you will receive a tooltip message stating why it’s not valid:</p>
<div><div><img alt="Figure 4.1 – The effect of a failed validation on an input" src="img/Figure_4.01_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The effect of a failed validation on an input</p>
<p>However, this <a id="_idIndexMarker189"/>does not justify neglecting validation on the server. For every field where a user inputs data, this same effort regarding validation should be applied when the server receives the data.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Always Encode User Input</h2>
<p>One of the <a id="_idIndexMarker190"/>easiest methods of sanitizing user input on the <a id="_idIndexMarker191"/>server is <strong class="bold">encoding</strong>.</p>
<p>If a user enters data and the data will be displayed on a page at any time, it’s best to encode the data to prevent XSS. The easiest way to encode user input is to dependency inject <code>HtmlEncoder</code> into a method to perform the encoding, as shown in the following code snippet:</p>
<pre class="source-code">
    public async Task&lt;IActionResult&gt; OnGet(
        [FromServices] HtmlEncoder htmlEncoder,
        string q = "")
    {
        PageResults = await PerformTheSearch(htmlEncoder.Encode(q));
        return Page();
    }</pre> <p>.NET has various injectable services already defined. <code>HtmlEncoder</code> is one such service and is injected automatically by adding a <code>[FromServices]</code> attribute. Once we have our encoder, we can encode the string that’s been passed in and safely perform the action that’s been requested.</p>
<p>In this section, you learned how to encode user input from the client, making your site safe from malicious data.</p>
<p>In the next section, you’ll learn how to hide what your servers are telling the world and how to make a reusable middleware component.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor100"/>Securing Your Headers</h2>
<p>By default, several headers<a id="_idIndexMarker192"/> are added to HTTP requests to identify a server, the version used, what technology stack you’re using, and what powers your website. While these default headers are helpful, some of them aren’t required, while others can make your site more secure.</p>
<p>In this section, we’ll focus on securing the recommended header changes through ASP.NET’s Middleware.</p>
<h3>Removing Server Headers</h3>
<p>It’s generally not a good idea to announce to the world what server you’re running and its version to an anonymous user. This exposes the type of web server you’re running and allows attackers to find IIS-specific techniques to gain access to your web server.</p>
<p>In ASP.NET, you can disable the server header for Kestrel (which is the open source server used in ASP.NET) in <code>Program.cs</code>:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.WebHost.UseKestrel(options =&gt; options.AddServerHeader = false);</pre> <p>When we set <code>AddServerHeader</code> to <code>false</code>, the header doesn’t display the type and version of the server.</p>
<p>In addition to the server header, we also need to remove the <code>X-Powered-By</code> header to avoid exposing too much information. This can be achieved through middleware, as shown here:</p>
<pre class="source-code">
app.<a id="_idTextAnchor101"/>Use(async (context, next) =&gt;
{
    context.<a id="_idTextAnchor102"/>Response.Headers.Remove("Server");
    context.Response.Headers.Remove("X-Powered-By");
    await next();
});</pre> <p>However, you’ll also have to add it to <code>web.config</code>, which should exist in the root of your project. Here are the only reasons <code>web.config</code> should exist in your project:</p>
<ul>
<li>Compression configuration</li>
<li>Removing specific IIS headers</li>
<li>Custom MIME mappings</li>
</ul>
<p>If it doesn’t exist, add<a id="_idIndexMarker193"/> it to your project and add the following path to remove the <code>X-Powered-By</code> header:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;
  &lt;system.webServer&gt;
    &lt;httpProtocol&gt;
      &lt;customHeaders&gt;
        &lt;remove name="X-Powered-By" /&gt;</pre> <p>Other header values to remove include <code>X-Aspnet-Version</code> and <code>X-AspnetMvc-Version</code>. The reason you should remove these headers is that they provide detailed information about what technology you’re running on your server. If there is a security flaw specifically for ASP.NET or ASP.NET Core MVC, these headers would make your site easier for attackers to narrow down their attacks and cause an inevitable security event.</p>
<p>To remove these two headers, add the following two lines to the <a id="_idTextAnchor103"/>middleware in your <code>Program.cs</code> file:</p>
<pre class="source-code">
context.Response.Headers.Remove("X-Aspnet-version");
context.Response.Headers.Remove("X-AspnetMvc-version");</pre> <h3>No Sniffing Allowed</h3>
<p>When you include <code>X-Content-Type-Options</code> in a header, this tells the browser to adhere to the MIME types registered in the <code>Content-Type</code> headers. Thes<a id="_idTextAnchor104"/>e shouldn’t be changed or followed:</p>
<pre class="source-code">
context.Response.Headers.Add("X-Content-Type-Options", new
   StringValues("nosniff"));</pre> <p>This marker tells the browser that these MIME types were intentionally configured to avoid MIME-type sniffing. This helps prevent attacks based on MIME-type confusion, where non-MIME types could be considered valid MIME types.</p>
<h3>No Framing Either</h3>
<p>When the browser sees an <code>X-Frame-Options</code> header response, it indicates whether or not the browser should render the web page in <code>&lt;fram<a id="_idTextAnchor105"/>e&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;embed&gt;</code>, or <code>&lt;object&gt;</code>:</p>
<pre class="source-code">
context.Response.Headers.Add("X-Frame-Options", new
    StringValues("DENY"));</pre> <p>The <code>X-Frame-Options</code> header prevents clickjacking attacks, where someone could embed your content into other sites using frames, embeds, or objects. Setting this to <code>DENY</code> protects<a id="_idIndexMarker194"/> you from such attacks.</p>
<h3>Creating a security middleware component</h3>
<p>To finalize this section, we’ll create a simple middleware component we can reuse in our .NET Core web applications.</p>
<p>Since we created our middleware skeleton in <a href="B19493_03.xhtml#_idTextAnchor070"><em class="italic">Chapter 3</em></a>, we can reuse the code for our <code>RemoveInsecureHeadersMiddleware</code> component, as shown here:</p>
<pre class="source-code">
public class RemoveInsecureHeadersMiddleware
{
    private readonly RequestDelegate _next;
    public RemoveInsecureHeadersMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task Invoke(HttpContext httpContext)
    {
        httpContext.Response.OnStarting((state) =&gt;
        {
            httpContext.Response.Headers.Remove("Server");
            httpContext.Response.Headers.Remove("X-Powered-By");
            httpContext.Response.Headers.Remove("X-Aspnet-version");
            httpContext.Response.Headers.Remove("X-AspnetMvc-                version");
            httpContext.Response.Headers.Add("X-Content-Type-Options",
                new StringValues("nosniff"));
            httpContext.Response.Headers.Add("X-Frame-Options",
                new StringValues("DENY"));
            return Task.CompletedTask;
        }, null!);
        await _next(httpContext);
    }
}</pre> <p>Don’t forget<a id="_idIndexMarker195"/> our extension method:</p>
<pre class="source-code">
public static class RemoveInsecureHeadersMiddlewareExtensions
{
    public static IApplicationBuilder RemoveInsecureHeaders(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;RemoveInsecureHeadersMiddleware&gt;();
    }
}</pre> <p>We can use newly created security extension in our <code>Program.cs</code> file:</p>
<pre class="source-code">
app.RemoveInsecureHeaders();</pre> <p>While we’ve added the most obvious headers, the good news is that you can update this component by adding additional headers to increase the security of your site even further.</p>
<p>In this section, you learned how to secure your headers and create a reusable middleware component for all of your web applications. In the next section, you’ll learn how to secure Entity Framework by encrypting your data, using stored procedures, and using parameterized queries.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor106"/>Securing Entity Framework Core</h2>
<p>Entity Framework Core<a id="_idIndexMarker196"/> is one of<a id="_idIndexMarker197"/> those technologies that continues to amaze me. Every version of Entity Framework Core that’s released provides some new performance enhancement, a better approach to a technique, or some other method to make our lives a little bit easier.</p>
<p>In this section, we’ll learn about how we can encrypt our data at the database level.</p>
<h3>Encrypting Your Data</h3>
<p>One of the most<a id="_idIndexMarker198"/> valuable things to a company is data. To prevent an attack, one of the security measures you can take is to encrypt the data in the table.</p>
<p>At the beginning of this chapter, we explained the types of data that require special attention, such as phone numbers, email addresses, and credit card data.</p>
<p>The best approach is to apply security at the database level by using the database’s encryption technology, whether it’s SQL Server or a similar database.</p>
<p>SQL Server encrypts specific <a id="_idIndexMarker199"/>columns by using the <strong class="bold">Encrypt Columns…</strong> option in <strong class="bold">SQL Server Management Studio</strong> (<strong class="bold">SSMS</strong>), as shown in <em class="italic">Figure 4</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 4.2 – The Encrypt Columns… option in SQL Server Management Studio" src="img/Figure_4.02_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The Encrypt Columns… option in SQL Server Management Studio</p>
<p>If you are using Entity Framework, generating a DbContext will take the secure columns into account. Again, when creating encryption at the database level, it would be another roadblock to dissuade attackers from accessing sensitive data.</p>
<p>In this section, we examined the best approach to protecting your data – that is, by encrypting your data using SQL Server’s <strong class="bold">Encrypt Columns…</strong> feature. In the next section, we’ll look at how to protect your pages from a <strong class="bold">cross-site request forgery</strong> (<strong class="bold">XSRF</strong>) attack.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor107"/>Use Microsoft Entra for Securing Applications</h2>
<p>As mentioned previously, when logging into a website, it’s best to protect the database from intruders by encrypting the database. This means using existing methods as opposed to writing custom encryption algorithms. Creating a custom encryption algorithm should be avoided since most algorithms are easily broken through hacker tools. It’s best to use an existing framework like Microsoft Identity (now called Entra).</p>
<p>With Blazor and SPAs (Single-Page Applications) all the rage, it can be hard to secure an application using APIs. Previously, using Microsoft Identity through an API required a lot of effort making it harder to implement secure applications.</p>
<p>With the latest .NET 8, Microsoft Entra introduces API-based calls for every aspect of security for web applications for <strong class="bold">Single-Page Applications</strong> (<strong class="bold">SPAs</strong>). When creating a new application, the following code adds an Entra-enabled REST-based API to an application:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
 
// Add services to the container.
builder.Services
    .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApi(builder.Configuration.GetSection(“AzureAd”));
builder.Services.AddAuthorization(); </pre> <p>The preceding code creates our web application and defines a JwtBearerDefault authentication scheme and adds a Web API specifically for Microsoft Identity.</p>
<p>If JWT Tokens are not an option, .NET 8 also introduces Bearer Tokens as shown here:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
 
// Add services to the container.
builder.Services
    .AddAuthentication()
    .AddBearerToken();
builder.Services.AddAuthorization();</pre> <p>The ability to write fast APIs along with simple authentication and authorization gives web developers more options when writing web applications using Blazor and SPAs. We’ll cover Microsoft Entra more in <a href="B19493_09.xhtml#_idTextAnchor207"><em class="italic">Chapter 9</em></a> when looking at creating better web APIs.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor108"/>Protecting Your Pages with Anti-Forgery</h2>
<p>Cross-site request forgery, or<a id="_idIndexMarker200"/> XSRF, is where an attack occurs, tricking a user to <a id="_idIndexMarker201"/>execute unwanted actions in a web application in which they’re currently authenticated. For example, a user could be tricked into using their credit card on a different site without them even knowing it.</p>
<p>To prevent an XSRF attack through your web forms, the recommended approach is to use anti-forgery tokens.</p>
<p>To add some to our Middleware, we will add them to our pipeline, as shown in the following code snippet:</p>
<pre class="source-code">
services.AddAntiforgery();</pre> <p>When an HTML form is created, anti-forgery tokens are automatically generated when a <code>&lt;form&gt;</code> tag contains <code>method="post"</code> and one of the following conditions is true:</p>
<ul>
<li>The action attribute is empty (<code>action=""</code>)</li>
<li>The action attribute isn’t supplied (<code>&lt;</code><code>form method="post"&gt;</code>)</li>
</ul>
<p>If you have other attributes attached to the form tag, you can explicitly add an <code>HtmlHelper</code> called <code>AntiForgeryToken()</code> inside the form tag:</p>
<pre class="source-code">
@Html.AntiForgeryToken();</pre> <p>This will generate a hidden input with an arbitrary value. If the value that comes back from the client is not the same as when the server originally sent it, the request will be denied.</p>
<p>In this section, you learned about audit trails and general logging, how to keep your frameworks and libraries current, how to always force SSL to make your connections secure, and to never trust the client’s input. You also learned that every user input should be encoded when received by the server, how to secure your headers, how to secure your database by using Entity Framework Core, and, finally, how to protect your forms from cross-site request<a id="_idIndexMarker202"/> forgery attacks by using the <code>.AddAntiForgery()</code> Middleware service.</p>
<p>In the next section, we’ll look at some real-world issues and how to solve the top three threats according to OWASP.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor109"/>Safeguarding Against the Top 3 Security Threats</h1>
<p>The <a id="_idIndexMarker203"/>Open Worldwide Application Security Project, or OWASP, is a non-profit foundation dedicated to improving the security of software. Since new threats are emerging all the time, they keep a list called the OWASP Top 10, which is meant to keep software developers up to date regarding the latest security threats and how to prevent them. The Top 10 list includes the <a id="_idIndexMarker204"/>following security threats:</p>
<ol>
<li>Broken Access Control</li>
<li>Cryptographic Failures</li>
<li>Injection</li>
<li>Insecure Design</li>
<li>Security Misconfiguration</li>
<li>Vulnerable and Outdated Components</li>
<li>Identification and Authentication Failures</li>
<li>Software and Data Integrity Failures</li>
<li>Security Logging and Monitoring Failures</li>
<li><strong class="bold">Server-Side Request </strong><strong class="bold">Forgery</strong> (<strong class="bold">SSRF</strong>)</li>
</ol>
<p>In this section, we’ll cover the top three threats and how to safeguard your ASP.NET Core application from these threats – that is, Broken Access Control, Cryptographic Failures, and Injection.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor110"/>Broken Access Control</h2>
<p>Broken access control<a id="_idIndexMarker205"/> is when a user can perform a particular act in the system outside of their intended permissions. Permission checks could be missing in the software, or the correct permissions might not have been checked in the software.</p>
<p>The key word to focus on here<a id="_idIndexMarker206"/> is <strong class="bold">authorization</strong>. Authorizing users into your system is a big responsibility.</p>
<p>Let’s look at how to get better at access control.</p>
<h3>Denying Access by Default</h3>
<p>When someone visits a site, consider <a id="_idIndexMarker207"/>them anonymous and restricted from the administrative area. When an administrator adds someone to the system, they are now authenticated and should be able to log in to the system.</p>
<p>Your authorization system should be thoroughly tested. Even though a user is allowed to log in, they shouldn’t be able to do anything unless an administrator authorizes them.</p>
<p>“Deny by default” means that when a user uses the system, they should be denied access until permissions are granted.</p>
<p>For Razor Pages, you can use the <code>.AddRazorPages()</code> Middleware component configuration to authorize certain pages and folders, as shown in the following code snippet:</p>
<pre class="source-code">
services.AddRazorPages(options =&gt;
{
    options.Conventions.AuthorizeAreaFolder("Admin", "/Areas/Admin");
    options.Conventions.AllowAnonymousToFolder("/");
});</pre> <p>In the <code>AddRazorPages</code> method, we are only allowing authenticated users into the <code>Admin</code> area; anonymous users can only go to the root of the website.</p>
<p>For controller-based pages such as ASP.NET MVC, you can use the <code>[Authorize]</code> attribute to allow authenticated users to view the page, as shown here:</p>
<pre class="source-code">
[Authorize]
public class MySecretController : Controller
{
    public ActionResult Index()
    {
    }
}</pre> <p>In the preceding code, the <code>Index</code> page isn’t available to the authenticated user because the <code>[Authorize]</code> attribute is on <code>MySecretController</code>.</p>
<p>If you only <a id="_idIndexMarker208"/>want the <code>Index</code> page to be available to authenticated users, put the <code>[Authorize]</code> attribute on the <code>Index()</code> method, as shown here:</p>
<pre class="source-code">
[Authorize]
public ActionResult Index()
{
}</pre> <p>These techniques deny anonymous users by default, which should be the proper approach.</p>
<h3>Avoid Exposing Keys</h3>
<p>When you’re <a id="_idIndexMarker209"/>building a blog, it’s best to have a URL without a post ID as an integer. When I’ve written blog posts, I’ve seen hits on my page before the page was public. It was great to see people were interested in looking at my latest post, but how were they getting to it? They would go to my blog, pull up the latest post, and add <code>1</code> to the post ID. There it was – an unfinished post in all its unfinished glory.</p>
<p>Imagine this type of scenario on a bank website. A user logs in to their account and they see the following URL: https://www.bobsbank.com/view/accountid=511324.</p>
<p>A curious user could add <code>1</code> to the account ID and view another person’s account.</p>
<p>Avoid <a id="_idIndexMarker210"/>exposing accounts or primary keys to users and, if a user does guess an account number, confirm the authenticated user is the owner of their account before viewing it.</p>
<h3>Final Notes on Broken Access Controls</h3>
<p>Here are some <a id="_idIndexMarker211"/>other things you should consider:</p>
<ul>
<li>Audit trails and logs are gold. They will help you identify risks and patterns with users.</li>
<li>Confirm your authorization system works by running unit tests and integration tests. We’ll cover unit and integration tests in a later chapter.</li>
</ul>
<p>In this section, we learned how to protect ourselves from broken access controls by denying users by default, hiding primary keys, and protecting certain pages by confirming users are allowed to view that page, as well as how to implement audit trails and logs and battle-test our authorization system.</p>
<p>In this next section, we’ll look at how to protect against cryptographic failures.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor111"/>Cryptographic Failures</h2>
<p>OWASP <a id="_idIndexMarker212"/>considers cryptographic failures as sensitive data that is unencrypted, failed security measures that use invalid access control, and even stale server environments, such as servers that don’t contain the latest security patches. This includes using industry-proven encryption algorithms which are already included in Microsoft Entra.</p>
<p>The following sections detail more common incidents in the industry.</p>
<h3>Transmitting Clear Text</h3>
<p>If you are transmitting <a id="_idIndexMarker213"/>sensitive data across the wire, it should be encrypted by using an SSL connection.</p>
<p>A general rule of thumb is that the client should be the one sending sensitive data to the server, not the other way around.</p>
<p>If you need to send sensitive data back to the client for approval, it’s best to mask the data somehow for display purposes (for example, using XXXX-XXXX-XXXX-9999 for credit cards) and, when updated, confirm this by having the authenticated user re-enter their password or <a id="_idIndexMarker214"/>providing some way to authenticate them again.</p>
<h3>Invalid/Expired SSL Certificates</h3>
<p>Once your code gets to a <a id="_idIndexMarker215"/>server, its primary job is to deliver the data as fast and as securely as possible.</p>
<p>Certificates are required for SSL to create secure connections that have an expiration date. There should be some reminder or notification letting administrators know when a certificate expires. It’s not recommended to continue using an expired certificate on your site.</p>
<h3>Unencrypted Database</h3>
<p>Again, if your database contains<a id="_idIndexMarker216"/> sensitive information, it’s best to be proactive and encrypt the database using the database’s recommended encryption method.</p>
<h3>Final Notes on Cryptographic Failures</h3>
<p>Let’s look at some <a id="_idIndexMarker217"/>final notes:</p>
<ul>
<li>Avoid weak algorithms such as MD5, SHA1, or PKCS number 1 v1.5, which are easy algorithms to break.</li>
<li>Avoid sending sensitive data to the client. If this is necessary, mask the data.</li>
<li>Use proper access key management, storing keys in safe locations such as Microsoft’s Key Vault, Google’s Cloud Key Management, or Amazon’s Key Management Service.</li>
</ul>
<p>In this section, we learned how to avoid cryptographic failures by avoiding sending clear text, updating stale or invalid SSL certificates, and always encrypting the database if it contains sensitive data.</p>
<p>In the final section, we’ll look at how injection can impact your application.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor112"/>Injection</h2>
<p>In 2017, OWASP reported <a id="_idIndexMarker218"/>SQL injection was the top threat when writing code for the web. Now, their Top 10 includes simply “injection,” which is an umbrella term covering SQL injection and XSS as well.</p>
<h3>SQL Injection</h3>
<p>We already mentioned that <a id="_idIndexMarker219"/>you should never trust the <a id="_idIndexMarker220"/>client and always sanitize and encode user input, but it bears repeating since it is still considered a threat, even if it did move down two spots to number three.</p>
<p>The great news is that Entity Framework Core supports parameterized queries to help you avoid SQL injection. However, this feature doesn’t mean you don’t have to sanitize input from users.</p>
<h3>Script Injection</h3>
<p>Script injection is when someone<a id="_idIndexMarker221"/> enters a script tag in a text box and the value is<a id="_idIndexMarker222"/> accepted and saved in the database. When the data is displayed on the page, the script is triggered and performs a particular action.</p>
<p>Here is a simple extension method that searches for and destroys malicious tags from HTML using regex:</p>
<pre class="source-code">
public static class StringExtensions
{
    public static string Sanitize(this string content)
    {
        // Replace the malicious tags with nothing.
        var maliciousTagsPattern =
            @"&lt;(applet|embed|frameset|head|noframes|noscript|object|            form|select|option|script|style|title)(.*?)&gt;"+
            "((.|\n)*?)"+
            "&lt;/(applet|embed|frameset|head|noframes|noscript|object|            select|form|option|script|style|title)&gt;";
        var options = RegexOptions.IgnoreCase | RegexOptions.            Multiline;
        var regex = new Regex(maliciousTagsPattern, options);
        content = regex.Replace(content, @"");
        // Remove the Javascript function on the tags (i.e.            OnChange="Javascript:&lt;blah blah blah&gt;")
        var inlinePattern = @"&lt;[^&gt;]*=""javascript:[^""]*""[^&gt;]*&gt;";
        options = RegexOptions.IgnoreCase;
        var regex2 = new Regex(inlinePattern, options);
        return regex2.Replace(content, @"");
    }
}</pre> <p>While this <code>.Sanitize()</code> extension method removes any malicious tags from a string, if you are passing in HTML-formatted text, it also removes any tag using any JavaScript events on<a id="_idIndexMarker223"/> tags (such as <code>onclick='alert("gotcha");'</code>). It then returns the sanitized string <a id="_idIndexMarker224"/>for use.</p>
<p>Use this extension method like any other extension method with a string:</p>
<pre class="source-code">
var sanitizedString = inputFromUser.Sanitize();</pre> <p>You could even extend the method further so that it includes other safeguards, such as encoding the string before returning it.</p>
<p>Always validate, filter, and sanitize input from the user. No matter what.</p>
<h3>Final Notes on Injection</h3>
<p>Here are some final <a id="_idIndexMarker225"/>things you should consider:</p>
<ul>
<li>The further you can keep users (and users with malicious intent) away from the database, the better</li>
<li>Confirm you have a <code>maxlength</code> attribute on single-line inputs to minimize how many characters are acceptable and limit the ability to allow scripts in HTML input<a id="_idIndexMarker226"/> fields</li>
</ul>
<p>Injection continues to be a credible threat and has always been listed on OWASP’s Top 10 list.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor113"/>Summary</h1>
<p>In this chapter, we learned how to safeguard our code by understanding what sensitive data is and how to secure it using authentication, authorization, and SSL-enabled connections.</p>
<p>In the second part of this chapter, we reviewed some common standards in the industry, such as logging, keeping our frameworks and libraries up-to-date, and always redirecting to SSL-enabled sites. After that, we learned to never trust client data and that we should validate, filter, and sanitize it and always encode it, and not announce to the world what server and version we’re running by adding or removing security headers. We even created a reusable security middleware component.</p>
<p>We also touched on encrypting database columns with SQL Server and how it’s important to protect fields by being proactive, and why creating a custom encryption algorithm should be avoided.. We also learned how to avoid cross-site request forgery by using anti-forgery tokens.</p>
<p>Finally, we examined the top three threats as determined by the OWASP Foundation and how to properly protect ourselves from Broken Access Control, Cryptographic Failures, and Injection of all types.</p>
<p>In the next chapter, we’ll pick up the discussion of Entity Framework Core once more and learn how to optimize data access using Entity Framework Core by using some intuitive techniques.</p>
</div>
</body></html>