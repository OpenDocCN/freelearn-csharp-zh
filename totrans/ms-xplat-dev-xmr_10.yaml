- en: Chapter 10. ALM – Developers and QA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter provides an introduction to **Application Lifecycle Management**
    (**ALM**) and continuous integration methodologies on Xamarin cross-platform applications.
    As the part of the ALM process that is most relevant for developers, unit test
    strategies will be discussed and demonstrated, as well as automated UI testing.
    This chapter is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Development pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development pipeline can be described as the virtual production line that
    steers a project from a mere bundle of business requirements to the consumers.
    Stakeholders that are part of this pipeline include, but are not limited to, business
    proxies, developers, the QA team, the release and configuration team, and finally
    the consumers themselves. Each stakeholder in this production line assumes different
    responsibilities, and they should all function in harmony. Hence, having an efficient,
    healthy, and preferably automated pipeline that is going to provide the communication
    and transfer of deliverables between units is vital for the success of a project.
  prefs: []
  type: TYPE_NORMAL
- en: In the Agile project management framework, the development pipeline is cyclical
    rather than a linear delivery queue. In the application life cycle, requirements
    are inserted continuously into a backlog. The backlog leads to a planning and
    development phase, which is followed by testing and QA. Once the production-ready
    application is released, consumers can be made part of this cycle using live application
    telemetry instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Development pipeline](img/B04693_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Application life cycle management'
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin cross-platform application projects, development teams are blessed
    with various tools and frameworks that can ease the execution of ALM strategies.
    From sketching and mock-up tools available for early prototyping and design to
    source control and project management tools that make up the backbone of ALM,
    Xamarin projects can utilize various tools to automate and systematically analyze
    project timeline.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections of this chapter concentrate mainly on the lines of defense
    that protect the health and stability of a Xamarin cross-platform project in the
    timeline between the assignment of tasks to developers to the point at which the
    task or bug is completed/resolved and checked into a source control repository.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting and diagnostics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SDKs associated with Xamarin target platforms and development IDEs are equipped
    with comprehensive analytic tools. Utilizing these tools, developers can identify
    issues causing app freezes, crashes, slow response time, and other resource-related
    problems (for example, excessive battery usage).
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.iOS applications are analyzed using the XCode Instruments toolset. In
    this toolset, there are a number of profiling templates, each used to analyze
    a certain perspective of application execution (such as the allocations template
    that was used in [Chapter 2](ch02.html "Chapter 2. Memory Management"), *Memory
    Management*, for memory profiling). Instrument templates can be executed on an
    application running on the iOS simulator or on an actual device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Troubleshooting and diagnostics](img/B04693_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: XCode Instruments'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, Android applications can be analyzed using the device monitor provided
    by the Android SDK. Using Android Monitor, memory profile, CPU/GPU utilization,
    and network usage can also be analyzed, and application-provided diagnostic information
    can be gathered. **Android Debug Bridge** (**ADB**) is a command-line tool that
    allows various manual or automated device-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows Phone applications, Visual Studio provides a number of analysis
    tools for profiling CPU usage, energy consumption, memory usage, and XAML UI responsiveness.
    XAML diagnostic sessions in particular can provide valuable information on problematic
    sections of view implementation and pinpoint possible visual and performance issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Troubleshooting and diagnostics](img/B04693_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Visual Studio XAML analyses'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Xamarin Profiler, as a maturing application (currently in preview release),
    can help analyze memory allocations and execution time. Xamarin Profiler can be
    used with iOS and Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **test-driven development** (**TDD**) pattern dictates that the business
    requirements and the granular use-cases defined by these requirements should be
    initially reflected on unit test fixtures. This allows a mobile application to
    grow/evolve within the defined borders of these assertive unit test models. Whether
    following a TDD strategy or implementing tests to ensure the stability of the
    development pipeline, unit tests are fundamental components of a development project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Unit testing](img/B04693_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Unit test project templates'
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin Studio and Visual Studio both provide a number of test project templates
    targeting different areas of a cross-platform project. In Xamarin cross-platform
    projects, unit tests can be categorized into two groups: platform-agnostic and
    platform-specific testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Platform-agnostic unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Platform-agnostic components, such as portable class libraries containing shared
    logic for Xamarin applications, can be tested using the common unit test projects
    targeting the .NET framework. Visual Studio Test Tools or the NUnit test framework
    can be used according to the development environment of choice. It is also important
    to note that shared projects used to create shared logic containers for Xamarin
    projects cannot be tested with .NET unit test fixtures. For shared projects and
    the referencing platform-specific projects, platform-specific unit test fixtures
    should be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: When following an MVVM pattern, view models are the focus of unit test fixtures
    since, as previously explained, view models can be perceived as a finite state
    machine where the bindable properties are used to create a certain state on which
    the commands are executed, simulating a specific use-case to be tested. This approach
    is the most convenient way to test the UI behavior of a Xamarin application without
    having to implement and configure automated UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: While implementing unit tests for such projects, a mocking framework is generally
    used to replace the platform-dependent sections of the business logic. Loosely
    coupling these dependent components (see [Chapter 8](ch08.html "Chapter 8. Xamarin.Forms"),
    *Xamarin.Forms*) makes it easier for developers to inject mocked interface implementations
    and increases the testability of these modules. The most popular mocking frameworks
    for unit testing are Moq and RhinoMocks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both Moq and RhinoMocks utilize reflection and, more specifically, the Reflection.Emit
    namespace, which is used to generate types, methods, events, and other artifacts
    in the runtime. Aforementioned iOS restrictions on code generation make these
    libraries inapplicable for platform-specific testing, but they can still be included
    in unit test fixtures targeting the .NET framework. For platform-specific implementation,
    the True Fakes library provides compile time code generation and mocking features.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the implementation specifics (such as namespaces used, network
    communication, multithreading, and so on), in some scenarios it is imperative
    to test the common logic implementation on specific platforms as well. For instance,
    some multithreading and parallel task implementations give different results on
    Windows Runtime, Xamarin.Android, and Xamarin.iOS. These variations generally
    occur because of the underlying platform's mechanism or slight differences between
    the .NET and Mono implementation logic. In order to ensure the integrity of these
    components, common unit test fixtures can be added as linked/referenced files
    to platform-specific test projects and executed on the test harness.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Xamarin project, platform-dependent features cannot be unit tested using
    the conventional unit test runners available in Visual Studio Test Suite and NUnit
    frameworks. Platform-dependent tests are executed on empty platform-specific projects
    that serve as a harness for unit tests for that specific platform.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Runtime application projects can be tested using the Visual Studio Test
    Suite. However, for Android and iOS, the NUnit testing framework should be used,
    since Visual Studio Test Tools are not available for the Xamarin.Android and Xamarin.iOS
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform-specific unit tests](img/B04693_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Test harnesses'
  prefs: []
  type: TYPE_NORMAL
- en: The unit test runner for Windows Phone (Silverlight) and Windows Phone 8.1 applications
    uses a test harness integrated with the Visual Studio test explorer. The unit
    tests can be executed and debugged from within Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Android and Xamarin.iOS test project templates use NUnitLite implementation
    for the respective platforms. In order to run these tests, the test application
    should be deployed on the simulator (or the testing device) and the application
    has to be manually executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to automate the unit tests on Android and iOS platforms through
    instrumentation; however, these methods will be discussed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each Xamarin target platform, the initial application lifetime event is
    used to add the necessary unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Xamarin.Android implementation, the `MainActivity` class derives from
    the `TestSuiteActivity`, which implements the necessary infrastructure to run
    the unit tests and the UI elements to visualize the test results. On the Xamarin.iOS
    platform, the test application uses the default `UIApplicationDelegate`, and generally,
    the `FinishedLaunching` event delegate is used to create the `ViewController`
    for the unit test run fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The main shortcoming of executing unit tests this way is the fact that it is
    not easy to generate a code coverage report and archive the test results.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of these testing methods provide the ability to test the UI layer. They
    are simply used to test platform-dependent implementations. In order to test the
    interactive layer, platform-specific or cross-platform (Xamarin.Forms) coded UI
    tests need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: UI testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general terms, the code coverage of the unit tests directly correlates with
    the amount of shared code which amounts to, at the very least, 70-80 percent of
    the code base in a mundane Xamarin project. As explained in the previous chapters,
    one of the main driving factors of architectural patterns was to decrease the
    amount of logic and code in the view layer so that the testability of the project
    utilizing conventional unit tests reaches a satisfactory level. Coded UI (or automated
    UI acceptance) tests are used to test the uppermost layer of the cross-platform
    solution: the views.'
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.UITests and Xamarin Test Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main UI testing framework used for Xamarin projects is the Xamarin.UITests
    testing framework. This testing component can be used on various platform-specific
    projects, varying from native mobile applications to Xamarin.Forms implementations,
    except for the Windows Phone platform and applications. Xamarin.UITests is an
    implementation based on the Calabash framework, which is an automated UI acceptance
    testing framework targeting mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.UITests is introduced to the Xamarin.iOS or Xamarin.Android applications
    using the publicly available NuGet packages. The included framework components
    are used to provide an entry point to the native applications. The entry point
    is the Xamarin Test Cloud Agent, which is embedded into the native application
    during the compilation. The cloud agent is similar to a local server that allows
    either the Xamarin Test Cloud or the test runner to communicate with the app infrastructure
    and simulate user interaction with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xamarin Test Cloud is a subscription-based service allowing Xamarin applications
    to be tested on real mobile devices using UI tests implemented via Xamarin.UITests.
    Xamarin Test Cloud not only provides a powerful testing infrastructure for Xamarin.iOS
    and Xamarin.Android applications with an abundant amount of mobile devices but
    can also be integrated into Continuous Integration workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the appropriate NuGet package, the UI tests can be initialized
    for a specific application on a specific device. In order to initialize the interaction
    adapter for the application, the app package and the device should be configured.
    On Android, the APK package path and the device serial can be used for the initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For an iOS application, the procedure is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the `App` handle has been created, each test written using NUnit should
    first create the pre-conditions for the tests, simulate the interaction, and finally
    test the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: The `IApp` interface provides a set of methods to select elements on the visual
    tree and simulate certain interactions, such as text entry and tapping. On top
    of the main testing functionality, screenshots can be taken to document test steps
    and possible bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Both Visual Studio and Xamarin Studio provide project templates for Xamarin.UITests.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin Test Recorder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin Test Recorder is an application that can ease the creation of automated
    UI tests. It is currently in its preview version and is only available for the
    Mac OS platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin Test Recorder](img/B04693_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Xamarin Test Recorder'
  prefs: []
  type: TYPE_NORMAL
- en: Using this application, developers can select the application in need of testing
    and the device/simulator that is going to run the application. Once the recording
    session starts, each interaction on the screen is recorded as execution steps
    on a separate screen, and these steps can be used to generate the preparation
    or testing steps for the Xamarin.UITests implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Coded UI tests (Windows Phone)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coded UI tests are used for automated UI testing on the Windows Phone platform.
    Coded UI Tests for Windows Phone and Windows Store applications are not any different
    than their counterparts for other .NET platforms such as Windows Forms, WPF, or
    ASP.Net. It is also important to note that only XAML applications support Coded
    UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coded UI tests are generated on a simulator and written on an Automation ID
    premise. The Automation ID property is an automatically generated or manually
    configured identifier for Windows Phone applications (only in XAML) and the UI
    controls used in the application. Coded UI tests depend on the UIMap created for
    each control on a specific screen using the Automation IDs. While creating the
    UIMap, a crosshair tool can be used to select the application and the controls
    on the simulator screen to define the interactive elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coded UI tests (Windows Phone)](img/B04693_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7:- Generating coded UI accessors and tests
  prefs: []
  type: TYPE_NORMAL
- en: Once the UIMap has been created and the designer files have been generated,
    gestures and the generated XAML accessors can be used to create testing pre-conditions
    and assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Coded UI tests, multiple scenario-specific input values can be used and
    tested on a single assertion. Using the `DataRow` attribute, unit tests can be
    expanded to test multiple data-driven scenarios. The code snippet below uses multiple
    input values to test different incorrect input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Automated tests can run on available simulators and/or a real device. They can
    also be included in CI build workflows and made part of the automated development
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Calabash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calabash is an automated UI acceptance testing framework used to execute Cucumber
    tests. Cucumber tests provide an assertion strategy similar to coded UI tests,
    only broader and behavior oriented. The Cucumber test framework supports tests
    written in the Gherkin language (a human-readable programming grammar description
    for behavior definitions). Calabash makes up the necessary infrastructure to execute
    these tests on various platforms and application runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple declaration of the feature and the scenario that is previously tested
    on Coded UI using the data-driven model would look similar to the excerpt below.
    Only two of the possible test scenarios are declared in this feature for demonstration;
    the feature can be extended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Calabash test execution is possible on Xamarin target platforms since the Ruby
    API exposed by the Calabash framework has a bidirectional communication line with
    the Xamarin Test Cloud Agent embedded in Xamarin applications with NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: Calabash/Cucumber tests can be executed on Xamarin Test Cloud on real devices
    since the communication between the application runtime and Calabash framework
    is maintained by Xamarin Test Cloud Agent, the same as Xamarin.UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin projects can benefit from a properly established development pipeline
    and the use of ALM principles. This type of approach makes it easier for teams
    to share responsibilities and work out business requirements in an iterative manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the ALM timeline, the development phase is the main domain in which most
    of the concrete implementation takes place. In order for the development team
    to provide quality code that can survive the ALM cycle, it is highly advised to
    analyze and test native applications using the available tooling in Xamarin development
    IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: While the common codebase for a target platform in a Xamarin project can be
    treated and tested as a .NET implementation using the conventional unit tests,
    platform-specific implementations require more particular handling. Platform-specific
    parts of the application need to be tested on empty shell applications, called
    test harnesses, on the respective platform simulators or devices.
  prefs: []
  type: TYPE_NORMAL
- en: To test views, available frameworks such as Coded UI tests (for Windows Phone)
    and Xamarin.UITests (for Xamarin.Android and Xamarin.iOS) can be utilized to increase
    the test code coverage and create a stable foundation for the delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Most tests and analysis tools discussed in this chapter can be integrated into
    automated continuous integration processes. The infrastructure used for source
    control and continuous integration build and testing processes will be the topic
    of the next chapter.
  prefs: []
  type: TYPE_NORMAL
