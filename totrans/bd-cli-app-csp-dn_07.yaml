- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interactive CLI Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the interaction with our CLI application (*Bookmarkr*) has mostly been
    text-based, meaning that the application responds to a text input with a text
    output. In a sense, it was mostly a request-response kind of application.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, weâ€™ve also added some colors to the text output so that the user can easily
    and instantly know whether the request was processed successfully or it ended
    with errors or warnings.
  prefs: []
  type: TYPE_NORMAL
- en: However, even though CLI applications donâ€™t provide a **graphical user interface**
    (**GUI**), that doesnâ€™t mean they canâ€™t be fun to use! ðŸ˜‰
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, weâ€™ll learn how to enhance the output of our CLI application
    to make it more user-friendly. Weâ€™ll learn how to add the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Progress bars and checkmarks to let the user know of the progress of their request.
    This is especially useful for time-consuming, long-running operations (such as
    downloading or encoding a file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists of items to make it easier to pick a selection from a list of predefined
    items. Note that this list doesnâ€™t have to be static; it can dynamically adapt
    to the current context of the user (for example, their permissions) and the request
    (for example, the requested command and the values of its options).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By relying on such enhancements, not only are we making our CLI application
    more fun to use, but weâ€™re also making it more **interactive** as it can have
    a conversation with the user, keeping them updated on the progress of their operations
    or presenting them with a list of options to choose from that are tailored to
    their specific context.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter07](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Building interactive command-line applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed â€“ and Iâ€™m sure that you did ðŸ˜‰ â€“ weâ€™ve already created
    some helper methods to display text in different colors for different scenarios:
    green for success messages, yellow for warnings, and red for errors. The code
    for these helper methods can be found in the `Helper.cs` file.'
  prefs: []
  type: TYPE_NORMAL
- en: We could certainly add more methods to this file to support other features,
    such as progress bars and drop-down lists. However, as I mentioned earlier, I
    trust that youâ€™re smart, so you wonâ€™t want to reinvent the wheel and rather rely
    on an existing library that fits the job ðŸ˜Š.
  prefs: []
  type: TYPE_NORMAL
- en: Although multiple libraries may exist to fit this purpose, the one weâ€™ll be
    using in this chapter is `Spectre.Console`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Spectre.Console` library is designed to enhance the creation of visually
    appealing console applications by going way beyond colored text. It also allows
    you to render trees, drop-down lists, tables, progress bars, and many other graphical
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: This wide range of features allows us to create rich user interfaces within
    the console environment of our CLI applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about `Spectre.Console`, you can visit its GitHub page at
    [https://github.com/spectreconsole/spectre.console](https://github.com/spectreconsole/spectre.console).
    In particular, I recommend checking out the two following repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spectre.console`: The official repository of the project, which means it contains
    the code of the library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Examples`: This repository contains various examples of using the library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, letâ€™s start by adding the `Spectre.Console` library to our application.
    This can be achieved with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s start by adding a new command that weâ€™ll call `interactive`. This command
    will be a child of the `root` command. Letâ€™s also add a handler for the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s add the handler method for this new command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are using the `Spectre.Console` library, letâ€™s reference it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding a FIGlet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A FIGlet is a way to generate large text banners using ordinary screen characters,
    in the form of ASCII art. Originally released in 1991, it became popular for creating
    eye-catching text in terminal sessions. So, itâ€™s perfect for making our CLI applications
    more user-friendly!
  prefs: []
  type: TYPE_NORMAL
- en: So, letâ€™s add a FIGlet to *Bookmarkr*!
  prefs: []
  type: TYPE_NORMAL
- en: We donâ€™t need to create the ASCII art ourselves since `Spectre.Console` alreadyprovides
    this capability. So, letâ€™s take advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s update our command handler method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates some FIGlet text, centers it, and displays it in
    a shade of blue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, letâ€™s run the application and see what weâ€™ve got so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be presented with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 â€“ A FIGlet for Bookmarkr](img/B22400_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 â€“ A FIGlet for Bookmarkr
  prefs: []
  type: TYPE_NORMAL
- en: Wow! This is awesome. This is a great start for our interactive CLI application,
    isnâ€™t it? ðŸ˜Š
  prefs: []
  type: TYPE_NORMAL
- en: AnsiConsole versus Console
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, we arenâ€™t using the `Console.Write` method provided
    by .NET but the one provided by the `AnsiConsole` class, which is part of the
    `Spectre.Console` library. This is due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. `AnsiConsole` class provides a much richer set of features compared to the
    `Console` class, such as advanced text formatting, colors, styles, and interactive
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. `AnsiConsole` class is designed to work consistently across different operating
    systems and terminal emulators. It automatically detects the capabilities of the
    current terminal and adjusts its output accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. `AnsiConsole` class offers support for 24-bit colors, text styling (such
    as bold and italic), and various widgets, such as tables, trees, and even ASCII
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. `AnsiConsole` class enables the creation of interactive prompts, selection
    menus, and other user input mechanisms that are more sophisticated than whatâ€™s
    possible with the standard `Console` class.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. `AnsiConsole` class supports live-rendering capabilities, allowing you to
    dynamically update content such as progress bars and status indicators.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. `AnsiConsole` class provides a rich markup language that makes it easy to
    apply colors and styles to text without complex code.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. `IAnsiConsole` interface instead of the static `AnsiConsole` class, it becomes
    possible to unit test command handlers and other console-related code.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, weâ€™ve laid the foundations for an interactive version of our
    CLI application. In the next section, weâ€™ll add more features to make *Bookmarkr*
    even more user-friendly!
  prefs: []
  type: TYPE_NORMAL
- en: Designing user-friendly CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although tons of features are provided by `Spectre.Console` (and I encourage
    you to check them out by visiting the documentation at [https://spectreconsole.net](https://spectreconsole.net)),
    weâ€™ll be focusing on a subset of these capabilities to add more interactivity
    to our *Bookmarkr* application.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing text display using markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Letâ€™s improve our `Helper.cs` class by leveraging the markup capabilities provided
    by `Spectre.Console`. These capabilities allow us to style and format text and
    even render emojis! However, note that some terminal environments (especially
    older systems or restricted environments, such as CI/CD systems) might not support
    emoji rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, letâ€™s review our three methods: `ShowErrorMessage`, `ShowWarningMessage`,
    and `ShowSuccessMessage`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods differ in the color in which they display the text thatâ€™s received
    as a parameter, but theyâ€™re similar in the way that they all follow the same process:'
  prefs: []
  type: TYPE_NORMAL
- en: First, they save the current foreground color to a temporary variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, they change the foreground color to the intended color (red, yellow, or
    green).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, they display the received text using that color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, they restore the foreground color to the saved color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is made easier by the `Spectre.Console` library. We donâ€™t have to save
    and restore the current foreground color (the library does this for us). It also
    opens some new possibilities. Letâ€™s explore some while redefining these methods!
  prefs: []
  type: TYPE_NORMAL
- en: The ShowErrorMessage method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We still want the error message to be displayed in red, but we also want to
    use emojis to make it more eye-catching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many things worth mentioning in this code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we set the encoding to UTF-8\. This ensures that emojis are rendered
    properly. Otherwise, theyâ€™ll be replaced by question marks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Speaking about emojis, notice that we can display them in two ways: we can
    either use the `Known` enumeration under the `Emoji` class or use markup code
    (here, we used`:cross_mark:`). The full list of supported emojis, along with their
    markup codes and enumeration constants, can be found at [https://spectreconsole.net/appendix/emojis](https://spectreconsole.net/appendix/emojis).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `AnsiConsole.MarkupLine(â€¦)` to display the word *ERROR* in bold and red
    surrounded by cross marks. The syntax is based on `BBCode` ([https://en.wikipedia.org/wiki/BBCode](https://en.wikipedia.org/wiki/BBCode)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the `ShowErrorMessage` method receives an array of strings, we display
    each string in red. However, this time, we rely on the `MarkupLineInterpolated`
    method of the `AnsiConsole` class because weâ€™re performing string interpolation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Letâ€™s see what happens if we call the `ShowErrorMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 â€“ The updated ShowErrorMessage method in action](img/B22400_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 â€“ The updated ShowErrorMessage method in action
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the *Hello!* message isnâ€™t displayed in red but rather in the previous
    foreground color of the terminal, without us having to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: Now, letâ€™s update the `ShowWarningMessage` and `ShowSuccessMessage` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The ShowWarningMessage method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We still want to display the warning message in yellow, but letâ€™s also align
    it so that itâ€™s in the center of the screen (and, yes, weâ€™ll use emojis too ðŸ˜Š).
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very similar to the code for `ShowErrorMessage`. However, thereâ€™s
    a slight difference: instead of calling the `MarkupLine` method to display the
    *Warning* text surrounded by emojis, we instantiate an object of the `Markup`
    type, then call its `Centered()` method before passing it as a parameter to the
    `Write` method. This is required so that we can center that text on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that just after that, we call the `WriteLine` method without any
    parameter. This ensures that a line break is performed before the warning information
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s see what happens if we call the `ShowWarningMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 â€“ The updated ShowWarningMessage method in action](img/B22400_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 â€“ The updated ShowWarningMessage method in action
  prefs: []
  type: TYPE_NORMAL
- en: Once again, notice that the *Hello!* message isnâ€™t displayed in red but rather
    in the previous foreground color of the terminal, without us having to handle
    this.
  prefs: []
  type: TYPE_NORMAL
- en: The ShowSuccessMessage method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We still want to display the success message in green.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Thereâ€™s absolutely nothing worth mentioning here, except maybe that we decided
    to use heart emojis to celebrate the success of the operation! ðŸ˜Š Congratulations
    â€“ youâ€™re starting to master the skills of styling and formatting text using `Spectre.Console`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s see what happens if we call the `ShowSuccessMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 â€“ The updated ShowSuccessMessage method in action](img/B22400_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 â€“ The updated ShowSuccessMessage method in action
  prefs: []
  type: TYPE_NORMAL
- en: Once again, notice that the *Hello!* message isnâ€™t displayed in red but rather
    in the previous foreground color of the terminal, without us having to handle
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can make our text more eye-catching, letâ€™s improve our interactive
    command by adding more features.
  prefs: []
  type: TYPE_NORMAL
- en: Offering choices to the user using selection prompts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Showing text in a visually pleasant manner is important, but interacting with
    the user and getting their input is equally important. Fortunately, `Spectre.Console`
    provides many ways to interact with the user. Letâ€™s explore one of these.
  prefs: []
  type: TYPE_NORMAL
- en: For now, our interactive command only shows a FIGlet. Itâ€™s certainly great,
    but letâ€™s make it more valuable to the user. One thing we can add is a list of
    all operations a user can perform. To do so, we will use a **selection prompt**.
    This will allow the user to navigate the list using the up and down arrows on
    their keyboard and confirm the operation to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s what it looks like in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 â€“ The selection prompt in action](img/B22400_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 â€“ The selection prompt in action
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s the updated code of the `OnInteractiveCommand` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s take a closer look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: We want the user to be able to keep picking up operations until they decide
    to exit the program (by selecting the *Exit Program* option from the selection
    prompt). Thatâ€™s why we placed our code inside a `while` loop that relies on the
    value of a Boolean variable thatâ€™s initially set to `true`. When the user selects
    *Exit Program*, the Boolean variable is set to `false` and the program is exited.
    Otherwise, the selection prompt is displayed to the user after each completed
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We instantiate the `SelectionPrompt` class (provided by `Spectre.Console`),
    specifying a title and a list of available options that will be displayed to the
    user. The user can then navigate this list using the up and down arrows and confirm
    their selection by hitting the *Enter* key. When they do, the `selectedOperation`
    variable is set to the selected value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use a `switch` statement to call a specific method, depending on
    the value of the `selectedOperation` variable. That method will process the requested
    operation. Note that these methods havenâ€™t been implemented yet â€“ weâ€™ll focus
    on them in the upcoming sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-selection
  prefs: []
  type: TYPE_NORMAL
- en: The `Spectre.Console` library also provides multi-selection prompts, which allow
    the user to select more than one item from a list of possible choices. You can
    find an illustrative example, along with a code sample, at [https://spectreconsole.net/prompts/multiselection](https://spectreconsole.net/prompts/multiselection).
  prefs: []
  type: TYPE_NORMAL
- en: Showing live progress of the export command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous iteration of our export command was a little bitâ€¦ dry! It certainly
    exported the bookmarks to the specified output file as expected, but it didnâ€™t
    give us information on the progress of the operation. We couldnâ€™t know whether
    it was halfway done or whether it was still at the very first few items out of
    a thousand. Thanks to the capabilities of `Spectre.Console`, we can display live
    progress along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Thereâ€™s both a synchronous and an asynchronous method for showing live progress.
    Since our export code is asynchronous, weâ€™ll use the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, letâ€™s implement the `ExportBookmarks` method we saw in the previous section.
    Hereâ€™s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s take a closer look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we ask the user for the filename. We achieved this by using `AnsiConsole.Prompt`
    and passing an instance of `TextPrompt`. This class also allows us to specify
    a default value if no value has been provided by the user or if theyâ€™re fine with
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we display the progress bar by calling `AnsiConsole.Progress`. The processing
    of the export operation is implemented as a delegate within the `Start` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by retrieving the list of bookmarks to be exported.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create an instance of the `Task` class, which will be responsible for
    tracking the processing of the export operation and incrementing the progress
    barâ€™s percentage. We also set the maximum value for that task to the number of
    bookmarks to be exported.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we open a stream writer to the export file. While the task hasnâ€™t been
    completed (indicated by the `ctx.IsFinished` Boolean value), we serialize each
    bookmark as JSON and write it to the file, increment the task (which, in turn,
    will update the progress bar), and wait 1.5s (this is optional, but since the
    export operation isnâ€™t that time-consuming, adding a delay allows us to see the
    animation of the progress bar ðŸ˜Š).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may have noticed some lines of code before the `Start` method is called.
    These are here to configure the look and behavior of the progress bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AutoRefresh(true)`: We enable auto-refresh of the progress bar. Otherwise,
    even if we increment the value of the task, the progress bar wonâ€™t be animated
    to reflect the updated value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutoClear(false)`: This prevents the task from being removed once completed.
    This is especially useful if we display the progress of multiple, concurrent operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HideCompleted(false)`: This prevents the task from being hidden once completed.
    This is especially useful if we display the progress of multiple, concurrent operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Columns`: This collection controls the look of the progress bar. In this case,
    we decided to display the description of the task, the progress bar, the current
    percentage of the operation, the remaining time to complete the operation, and
    a spinner indicating that the operation is ongoing (this proves helpful in situations
    where dealing with time-consuming operations for which the progress bar may be
    updated at longer intervals but since the spinner keeps, wellâ€¦ spinning, the user
    has that sentiment that the operation is still ongoing).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the code has been implemented, letâ€™s run the program and see what
    we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 â€“ Showing live progress while exporting bookmarks](img/B22400_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 â€“ Showing live progress while exporting bookmarks
  prefs: []
  type: TYPE_NORMAL
- en: Now, our export operation is more user-friendly (and, letâ€™s face it, more fun
    to use ðŸ˜Š). The user is informed of the progress of the export operation as it
    continues to run.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the terminal isnâ€™t considered interactive (for example, when running in a
    continuous integration system), any progress will be displayed in a simpler way
    (such as the current percentage value being displayed on a new line).
  prefs: []
  type: TYPE_NORMAL
- en: With that, weâ€™ve exported our bookmarks to a file and we can view them from
    there. Awesome! But what if we wanted to view them right from within the CLI application?
    Letâ€™s see how we can have a visually pleasant representation of these bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying bookmarks in a tree view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Spectre.Console` library provides various options to display a list of
    elements. We can use tables, trees, layouts, panels, grids, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to display the list of our bookmarks based on the categories to
    which they belong, weâ€™ll use a tree representation. So, letâ€™s implement the `ViewBookmarks`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s the code for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s explain this code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create the root element of the tree, and we label it *Bookmarks*.
    This label will be displayed to indicate what elements this tree is presenting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add four nodes (one for each category). These labels are children of
    the root node, and their labels are displayed in yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we call the `GetBookmarksByCategory` method of `BookmarkService` to retrieve
    the list of bookmarks associated with the specified category (in this case, *Tech
    Books*). After, we iterate over this list and add each bookmark as a child node
    to the `techBooksCategory` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do the same thing for the other categories. The preceding code sample has
    been simplified and only shows the code for the *Tech Books* category for clarity.
    However, the complete code can be found in this bookâ€™s GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we display the label in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pretty straightforward, isnâ€™t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, letâ€™s run the program and see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 â€“ Showing bookmarks as a tree view, grouped by categories](img/B22400_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 â€“ Showing bookmarks as a tree view, grouped by categories
  prefs: []
  type: TYPE_NORMAL
- en: Wow. What an improvement! The interactive version of our CLI application looks
    great and is more user-friendly and engaging, donâ€™t you think? ðŸ˜‰
  prefs: []
  type: TYPE_NORMAL
- en: To be or not to be interactive?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing an interactive version of a CLI application certainly enhances the
    user experience. So, shouldnâ€™t we always provide it? Shouldnâ€™t it be the default
    version? These are great questions. Thanks for asking! ðŸ˜Š
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s start with the first one: **shouldnâ€™t we always provide it?** We certainly
    should as it (as mentioned previously) improves the user experience and engagement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shouldnâ€™t it be the default version?** It could! It depends on your target
    audience:'
  prefs: []
  type: TYPE_NORMAL
- en: If your CLI application is primarily intended to be run by humans, then yes!
    You should make the interactive version the default one. In this case, your commands
    could provide a `--non-interactive` option to disable this interactive behavior
    when that command is executed by a program (in a CI/CD pipeline, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your CLI application is primarily intended to be run by programs (such as
    one for processing a large batch of files or a CI/CD pipeline), your commands
    could provide a `--interactive` option to enable interactive behavior when theyâ€™re
    executed by humans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, interactivity is fantastic, but use it wisely!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made *Bookmarkr* more user-friendly and graphically appealing
    by introducing progress bars, checkmarks, and lists of items for easier user selection
    and ensuring that only valid values are selected.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that these additions, in combination with text coloring, help make
    our CLI applications more compelling and fun to use and showed that CLI applications
    have nothing to be ashamed of in front of GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: But thatâ€™s not all! We also learned that these additions help make our CLI applications
    more conversational (that is, interactive) with the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, weâ€™ll learn how to make our CLI application have a more
    modular design so that itâ€™s easier to extend.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding various features.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 â€“ present a bookmark in a user-friendly way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Youâ€™ve been asked to add a `show` command that takes the name of a bookmark
    and displays it in a three-column grid â€“ one for the name, one for the URL, and
    one for the category.
  prefs: []
  type: TYPE_NORMAL
- en: The grid should contain a row for the headers (name, URL, and category).
  prefs: []
  type: TYPE_NORMAL
- en: The name should be displayed in yellow and bold; the URL should be presented
    as a link; and the category should be presented in italics and green.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the command should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 â€“ change the category of a bookmark interactively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Youâ€™ve been asked to implement a new command called `category change` that changes
    the category of an existing URL.
  prefs: []
  type: TYPE_NORMAL
- en: The command must display the list of existing categories as a selection menu;
    the user will have to select which one will be set as the new category for that
    bookmark based on its URL. This update will then be saved to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the command should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
