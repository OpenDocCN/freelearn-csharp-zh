<html><head></head><body>
        

                            
                    <h1 class="header-title">Understanding Object-Oriented Programming</h1>
                
            
            
                
<p>When we are writing any program, apart from making sure that it serves the required purpose, we must make sure that we also take the following aspects into consideration:</p>
<ul>
<li><strong>Code reuse</strong>: We must try to implement the program flow in such a way that common functionalities can be used across multiple modules. </li>
<li><strong>Code maintenance</strong>: We must accept that any program code that's written is bound to have a few bugs. However, we must ensure that the code that's written is clear and structured enough that it's understandable and easy to maintain.</li>
<li><strong>Design patterns</strong>: Design patterns allow us to write programs in such a manner that there is a common template/structure/functionality that can be used across multiple modules. This ensures that the performance of the application is not compromised, which is a key aspect of any program application.</li>
</ul>
<p>All of these aspects are difficult to achieve in a procedural language. However, using object-oriented programming, which is the main essence of any high-level programming language, we can achieve the aforementioned objectives.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding object-oriented programming</li>
<li>Understanding encapsulation</li>
<li>Understanding abstraction</li>
<li>Understanding inheritance</li>
<li>Understanding polymorphism</li>
</ul>
<p>We will also go through code examples to understand how these features are implemented in a C# application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>Like in the previous chapters in this book, the programs that we will cover will be developed in Visual Studio 2017.</p>
<p>The sample code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples">https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding object-oriented programming</h1>
                
            
            
                
<p class="mce-root">Object-oriented programming is a programming concept that is based on objects. An object is a collection of related data such as fields and procedures, that is, methods. For example, an object could be anything right from a very simple object such as a pencil to a very complex type such as a car. Each object will have its own set of attributes, that is, properties and functions or the methods that are implemented in that object. For example, for a car object, the possible attributes could be color, registration number, model, and so on. The possible functions could be start, stop, and accelerate.</p>
<p>Before object-oriented programming came into the picture, we did our programming under the principles of procedural programming. In a procedural language, an application was divided into a set of functions. The data that was used in the program was stored in a bunch of local variables that were used by the functions. It formed the basis of legacy programming languages such as COBOL and BASIC. </p>
<p>The main disadvantages of this programming concept were as follows:</p>
<ul>
<li><strong>No code reuse</strong>: As the entire application was divided into a set of sequential functions, there was no code reuse in this programming concept. </li>
<li><strong>Maintenance and scalability</strong>: The following diagram is just an indicative flow of how a typical program written in a procedural language will run. In the program, the blocks indicate the different code functions, which are interlinked and interacting with each other to complete a task:</li>
</ul>
<div><img src="img/1b84d311-0fdd-43df-b4df-6905b35c7bfd.png" style=""/></div>
<p>Here, as in any typical program written on procedural language, there would be a bunch of functions, passing around parameters and executing them in a conceptual manner. So, any change or upgrade that's made to any one of these functions will have a good chance of causing issues in the execution of another function. Therefore, from both the standpoint of maintenance and scalability, an application that's written in a procedural language will have its challenges. </p>
<p>In object-oriented programming, each application can be divided into a bunch of objects that have their own properties and procedures. For example, let's consider the same car scenario we explored in the previous chapter. A car can have the following properties and methods:</p>
<div><img src="img/221913d4-2396-466f-94d7-4e171a6659fc.png" style=""/></div>
<p>Now, what we can do in an object-oriented programming language is directly declare a <kbd>car</kbd> object, set the values related to the properties, and call the corresponding properties, such as start. </p>
<p>Since the object is grouped with the corresponding properties, we don't need to pass any data for the respective properties. Instead, while executing the respective functions such as <kbd>start</kbd>, <kbd>stop</kbd>, or <kbd>accelerate</kbd>, we can then pass data against these properties as a function parameter list.</p>
<p>Thus, in this case, if, in the future, we change the <kbd>start()</kbd> function of the <kbd>car</kbd> class, we won't need to bother all the other places that it's getting called from. </p>
<p>This is a major upgrade in terms of the maintainability and scalability of the application compared to the standard way of doing things in a procedural language.</p>
<p>Now, let's deep dive into each of the four pillars of an object-oriented language and understand how we can use them in our C# applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding encapsulation</h1>
                
            
            
                
<p>Encapsulation basically involves grouping all the related properties and methods that access them in an object. Whenever an application is being designed, we need to decide how many objects should be defined in it, along with the associated attributes and methods available in it. </p>
<p class="mce-root">For instance, in the car example, we have the following associated attributes and methods:</p>
<ul>
<li><kbd>car</kbd> is an object.</li>
<li>The <kbd>make</kbd>, <kbd>model</kbd>, and <kbd>color</kbd> are the different attributes that are present in the object.</li>
<li><kbd>start</kbd>, <kbd>stop</kbd>, and <kbd>accelerate</kbd> are the different methods that are present in the object.</li>
</ul>
<p>Encapsulation allows us to achieve the following functionality in any application:</p>
<ul>
<li><strong>Security</strong>: Using encapsulation, we can define our attributes in such a way that not all of the attributes of an object are exposed to the entire application. In <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a>, <em>Understanding Classes, Structures, and Interfaces,</em> we used access modifiers to control the security access of any property/method in the class/in the namespace/in the assembly, as well as in the entire application. </li>
<li><strong>Code maintenance</strong>: From a maintenance perspective of a function, it's always desirable that the function has as few attributes as possible. </li>
</ul>
<p>Using encapsulation, we can organize the required parameters of a function as an attribute of the class and thus we are not passing them explicitly in every call. </p>
<p>In the following code example, we will go through a code sample in C# and understand how this can be achieved.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>Let's consider an example of a banking application. In this banking application, we need to implement a scenario related to opening an account.</p>
<p>From a class implementation perspective, the following are the possible attributes that should be in the <kbd>Account</kbd> class. Please also note that there will be an additional class, <kbd>Customer</kbd>, to signify the person who is opening the account:</p>
<ul>
<li><kbd>openingDate</kbd></li>
<li><kbd>customer</kbd></li>
<li><kbd>float currentBalance</kbd></li>
</ul>
<p>The following are some of the methods that could be present in the <kbd>Account</kbd> class:</p>
<ul>
<li><kbd>bool OpenAccount();</kbd></li>
<li><kbd>bool depositMoney(float deposit);</kbd></li>
<li><kbd>bool withdrawMoney(float withdrawalAmt);</kbd></li>
</ul>
<p>In regard to the <kbd>Customer</kbd> class, we will just go simple now and define the following attributes:</p>
<ul>
<li><kbd>string name</kbd></li>
<li><kbd>string customerId</kbd></li>
</ul>
<p>Please refer to the following code for the declaration of the <kbd>Customer</kbd> class in a C# program. Here, we have created a <kbd>Customer</kbd> class and defined two attributes in it, that is, the name of the customer and a field of <kbd>CustomerID</kbd>, which will be a unique field for that customer.</p>
<div><p>In the following code, we will declare two variables and use them to showcase examples for the operators we mentioned previously:</p>
</div>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Text;<br/>using System.Threading.Tasks;<br/><br/>namespace ConsoleApp1<br/>{<br/>    public class Customer<br/>    {<br/>        public string name;<br/>        public string customerId;<br/>    } <br/>}</pre>
<p>Please refer to the following code for the declaration of the <kbd>Account</kbd> class in a C# program:</p>
<pre>public class Account<br/>{<br/>  public DateTime openingDate;<br/>  public Customer customer;<br/>  private float currentBalance;<br/>  public bool OpenAccount(Customer customer)<br/>  {<br/>     this.openingDate = DateTime.Now.Date;<br/>     this.currentBalance = 0.0f;<br/>     this.customer = customer;<br/>     return true;      <br/>  }  <br/>  public bool DepositMoney(float deposit)<br/>  {<br/>     if(deposit &gt; 0.0f)<br/>     {<br/>         this.currentBalance = this.currentBalance + deposit;<br/>         return true;<br/>     }<br/>     else<br/>     {<br/>         return false;<br/>     }<br/>  }<br/>  public bool WithdrawMoney(float withdraw)<br/>  {<br/>     if(this.currentBalance &gt;= withdraw)<br/>     {<br/>         this.currentBalance = this.currentBalance - withdraw;<br/>         return true;<br/>     }<br/>     else<br/>     {<br/>         return false;<br/>     } <br/>  }<br/>}<br/>}</pre>
<p>The following are some of the key items in the implementation:</p>
<ul>
<li>In the <kbd>Account</kbd> class, note that <kbd>currentBalance</kbd> is marked as private, as a customer may not want their balance to be exposed to the entire application. </li>
<li>In the <kbd>Account</kbd> class, in the methods of <kbd>OpenAccount</kbd>, <kbd>DepositMoney</kbd>, and <kbd>WithdrawMoney</kbd>, we are not passing all of the attributes related to the customer, current balance, or opening date. This is because the required attributes are already grouped together in the <kbd>Account</kbd> class.</li>
</ul>
<p>Now, let's look at how we will invoke these classes:</p>
<pre>Customer customer = new Customer();<br/>customer.name = "Sample Customer";<br/>customer.customerId = "12345";<br/><br/>Account newAccount = new Account();<br/>newAccount.OpenAccount(customer);<br/>newAccount.DepositMoney(1000);<br/>newAccount.WithdrawMoney(400);</pre>
<p>If you look at the function calling part, you will understand that because the properties are linked to the <kbd>Account</kbd> class, we are not passing them explicitly to the functions. Therefore, if the implementation of the functions is changed, from a maintenance perspective, there will be minimal impact. </p>
<p>Therefore, it's always beneficial to use the principles of encapsulation and divide the application into chunks of classes with the related information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding abstraction</h1>
                
            
            
                
<p>Abstraction is also a concept in object-oriented programming and implies that, when we write code, we should hide the complexity and details of the implementation from the outside world.</p>
<p>In other words, when we write a program that, on receiving an input, does a bunch of complex operations and returns an output, we should hide the inner complexity of the operations that are done inside the program so that the outer applications can just focus on the input they are sending to the application and the output that they are getting from it. </p>
<p>For example, let's consider the same example of <kbd>Account</kbd> that we worked on in the previous example. If we consider the example of the <kbd>OpenAccount</kbd> function, you will understand that opening an account for the customer will not be that simple. There will be several subtasks that need to be executed before we can finally open the account for the customer. For example, some of the steps could be as follows:</p>
<ul>
<li>Verifying the identification documents of the customer</li>
<li>Linking and opening different bank accounts, which could be <kbd>Salary</kbd>, <kbd>Current</kbd>, and <kbd>Savings</kbd></li>
<li>Fetching, that is, counting the initial amount deposit of the customer</li>
</ul>
<p>Basically, in real life, the function that we have written above will look more similar to the following code snippet. In <kbd>OpenAccount</kbd>, we are passing a <kbd>Customer</kbd> object. Before creating the bank account of the customer, we are doing three distinct tasks:</p>
<ol>
<li><kbd>VerifyCustomerIdentity()</kbd>: In this function, the idea is to verify the identity of the customer, which is a common practice before an account is opened.</li>
<li><kbd>OpenAndLinkRelatedAccounts()</kbd>: In this function, the idea is to open different accounts for the same customer, that is, <kbd>Savings</kbd>, <kbd>Current</kbd>, and <kbd>Salaried</kbd>.</li>
<li><kbd>RetrieveAndCountDeposit()</kbd>: In this function, the idea is to retrieve the money the customer intends to save, count it, and finally deposit it in the customer's account:</li>
</ol>
<pre style="padding-left: 60px">public bool OpenAccount(Customer customer)<br/>{<br/>    this.openingDate = DateTime.Now.Date;<br/>    this.currentBalance = 0.0f;<br/>    this.customer = customer;<br/>    if(VerifiyCustomerIdentity() &amp;&amp; OpenAndLinkRelatedAccounts() &amp;&amp; RetrieveAndCountDeposit())<br/>      {<br/>        return true;<br/>      }<br/>    else<br/>    {<br/>        return false;<br/>    } <br/>}<br/>private bool VerifiyCustomerIdentity()<br/>{<br/>    //This function will verify the customer documents.<br/>    return true;<br/>}<br/>private bool OpenAndLinkRelatedAccounts()<br/>{    <br/>    //This function will open the related accounts of savings , current and salary and link them together.<br/>    return true;<br/>}<br/>private bool RetrieveAndCountDeposit()<br/>{<br/>    //This function will fetch the deposit, count and verify the amount.<br/>    return true;<br/>}<br/>public bool DepositMoney(float deposit)<br/>{<br/>     this.currentBalance = this.currentBalance + deposit;<br/>     return true;<br/>} </pre>
<p>Please note the following:</p>
<ul>
<li>The three functions, that is, <kbd>VerifyCustomerIdentity()</kbd>, <kbd>OpenAndLinkRelatedAccounts()</kbd>, and <kbd>RetrieveAndCountDeposit()</kbd>, all of which have <kbd>Private</kbd> as the access modifier. This will ensure that the complexities in these three functions are not exposed to the outside. </li>
<li>These three functions are being internally called in the <kbd>OpenAccount</kbd> function, so the calling application doesn't need to worry about calling these functions explicitly. </li>
<li>Let's say we discover some issues in the internal private function. In this case, we can easily make changes in these internal functions without needing to worry about the external implementation.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding inheritance</h1>
                
            
            
                
<p>If you went through <a href="7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml">Chapter 2</a>, <em>Understanding Classes, Structures, and Interfaces</em>, you will already know how inheritance helps us in code reuse and reduced maintenance, and that it gives us more control of the entire application. </p>
<p>We also looked at a few code examples and saw how inheritance works and how it's implemented in C#. Now, we will look at some advanced features in inheritance, their use, and how they are implemented in C#.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Method overriding</h1>
                
            
            
                
<p>Method overriding is a technique in C# that we can use to invoke the methods that are defined in the base class from the classes that are deriving from that base class. In method overriding, a derived class implements a function that's declared in the base class with the same signature:</p>
<ul>
<li>The same name as the function that's declared in the base class</li>
<li>The same number and type of parameters in the function</li>
<li>The same return type as the function declared in the base class</li>
</ul>
<p> In C#, method overriding is implemented using the following two methods:</p>
<ul>
<li><strong>Virtual methods</strong>: A virtual method is a method in the base class that can also be defined or overridden in the derived class as well. Please note that, when a method is declared as virtual, it's optional to define the implementation of the method in the base class. In case it's defined, it becomes even more optional for the derived class to override it further. A method is declared as virtual using the <em>virtual</em> keyword.</li>
<li><strong>Override</strong>: Once a method has been declared as <kbd>virtual</kbd> or <kbd>abstract</kbd> in the base class, then by using the <em>override</em> keyword, the derived class can redefine the implementation of the method for its own use. In this section, we will be looking at <em>virtual methods</em>. In the next section, <em>Abstract and sealed classes</em>, we will do a deep dive into <kbd>abstract</kbd> methods.</li>
</ul>
<p>Let's look at a code example to understand how method overriding is implemented in C#. Let's assume that we have a base class, <kbd>Car</kbd>, and two classes, <kbd>Ferrari</kbd> and <kbd>Suzuki</kbd>, that are inheriting from the <kbd>Car</kbd> class. For the sake of explanation, we will keep things simple by just specifying a default constructor and a common <kbd>Accelerate</kbd> method across the three classes. The following would be the code implementation for the same:</p>
<pre>public class Car<br/>{<br/>     public Car()<br/>     {<br/>         Console.WriteLine("Inside Car");<br/>     }<br/>     public void Accelerate()<br/>     {<br/>         Console.WriteLine("Inside Acceleration of Car");<br/>     }     <br/>}<br/>public class Ferrari : Car<br/>{<br/>     public Ferrari()<br/>     {<br/>         Console.WriteLine("Inside Ferrari");<br/>     }<br/>     public void Accelerate()<br/>     {<br/>         Console.WriteLine("Inside Acceleration of Ferrari");<br/>     }     <br/>}<br/>public class Suzuki : Car<br/>{<br/>     public Suzuki()<br/>     {<br/>         Console.WriteLine("Inside Suzuki");<br/>     }<br/>     public void Accelerate()<br/>     {<br/>         Console.WriteLine("Inside Acceleration of Suzuki");<br/>     }     <br/> }</pre>
<p> Now, let's create some objects for these classes by using the following code:</p>
<pre>Car ferrari = new Ferrari();<br/>ferrari.Accelerate();<br/>Console.WriteLine("End of Ferrari Implementation");<br/>Car suzuki = new Suzuki();<br/>suzuki.Accelerate();<br/>Console.WriteLine("End of Suzuki Implementation"); </pre>
<p>Note that in the preceding code, we have created a new object of the <kbd>Ferrari</kbd> class and have assigned it to a variable, <kbd>ferrari</kbd>, which is of the <kbd>Car</kbd> type. Similarly, we have also created a new object of the <kbd>Suzuki</kbd> class and have assigned it to a variable, <kbd>suzuki</kbd>, which is also of the <kbd>Car</kbd> type.</p>
<p>When we execute the code, we get the following output:</p>
<div><img src="img/f4182fda-7d40-4c9a-ba21-32094fa5784e.png" style=""/></div>
<p>Note that, even though we have the <kbd>Accelerate</kbd> method in both the parent <kbd>Car</kbd> class and the derived <kbd>Ferrari</kbd> and <kbd>Suzuki</kbd> classes, when we are calling the <kbd>Accelerate</kbd> method from the <kbd>ferrari</kbd> object, it's calling the <kbd>Accelerate</kbd> method that's present in the parent <kbd>Car</kbd> class. This is due to the fact that the type of the variable is <kbd>Car</kbd> and that, even though it's instantiated with the objects of the <kbd>Ferrari</kbd> and <kbd>Suzuki</kbd> child classes, the method in the base class has not been overridden. </p>
<p>Now let's make a slight change to the implementation and declare the method in the base class as <kbd>virtual</kbd> and the methods in the classes deriving from this class as <kbd>override</kbd>:</p>
<pre>public class Car<br/>{<br/>     public Car()<br/>     {<br/>         Console.WriteLine("Inside Car");<br/>     }<br/>     public virtual void Accelerate()<br/>     {<br/>         Console.WriteLine("Inside Acceleration of Car");<br/>     }     <br/>}<br/>public class Ferrari : Car<br/>{<br/>     public Ferrari()<br/>     {<br/>         Console.WriteLine("Inside Ferrari");<br/>     }<br/>     public override void Accelerate()<br/>     {<br/>         Console.WriteLine("Inside Acceleration of Ferrari");<br/>     }     <br/>}<br/>public class Suzuki : Car<br/>{<br/>     public Suzuki()<br/>     {<br/>         Console.WriteLine("Inside Suzuki");<br/>     }<br/>     public override void Accelerate()<br/>     {<br/>         Console.WriteLine("Inside Acceleration of Suzuki");<br/>     }     <br/> }</pre>
<p>Now, execute the same code again and review that we receive the following output:</p>
<div><img src="img/614daa81-9315-476d-9b50-fbbca7659856.png" style=""/></div>
<p>Note that now, the <kbd>Accelerate</kbd> method executes the code mentioned in the derived classes of <kbd>Ferrari</kbd> and <kbd>Suzuki</kbd> and not the code specified in the parent class of <kbd>Car</kbd>.</p>
<p>Later in this chapter, we will also do a deep dive into polymorphism. There are two types of polymorphism: runtime polymorphism and compile-time polymorphism. Runtime polymorphism is implemented using method overriding. </p>
<p>In the next section, we will look at <kbd>abstract</kbd> classes and also explore the use of <kbd>virtual</kbd> methods in <kbd>abstract</kbd> classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Abstract classes</h1>
                
            
            
                
<p>An <kbd>abstract</kbd> class in C# is a class that cannot be instantiated, that is, the program execution cannot create an object of this class. Instead, these classes can only act as base classes from which other classes can inherit. </p>
<p>We use the <kbd>abstract</kbd> class in scenarios where we specifically want all the deriving classes to implement the specific implementation of a particular function that's declared in the base class. The following are some of the properties of an <kbd>abstract</kbd> class:</p>
<ul>
<li>Just like all the other classes, an <kbd>abstract</kbd> class can have both functions and properties.</li>
<li>An <kbd>abstract</kbd> class can have both abstract and non-abstract functions.</li>
</ul>
<p>Let's take a look at a program to analyze how <kbd>abstract</kbd> classes work. We will define an <kbd>Animal</kbd> class using the <kbd>abstract</kbd> keyword. Now, let's assume that each animal type, such as dog, speaks differently, so they must implement the function in their own way. To implement this, we will declare our base <kbd>Animal</kbd> class as <kbd>abstract</kbd> and have an <kbd>abstract</kbd> method <kbd>Speak</kbd> in it. Review that if we try to implement the <kbd>Speak</kbd> method, the compiler throws an error:</p>
<div><img src="img/d648af81-c47b-4e58-8504-52ba481fb632.png"/></div>
<p>To remove this error, we can simply remove the declaration of the <kbd>abstract</kbd> method:</p>
<pre>public abstract class Animal<br/>{<br/>     public abstract void Speak();<br/>     public void Walk()<br/>     {<br/>         Console.WriteLine("Base Animal Walk Functionality");<br/>     }<br/>}</pre>
<p>Now, let's create a <kbd>Dog</kbd> class that inherits from this base class of <kbd>Animal</kbd>. Note that the compiler will throw an error if the <kbd>Speak</kbd> method is not implemented:</p>
<div><img src="img/33b389c9-5891-4cf7-86af-a23c5d1e2519.png"/></div>
<p>We can get over this error by creating an implementation of the <kbd>Speak</kbd> function:</p>
<pre>public class Dog : Animal<br/>{<br/>     public override void Speak()<br/>     {<br/>         Console.WriteLine("A dog will bark");<br/>     }<br/>}</pre>
<p>Please note that we use the <kbd>override</kbd> keyword to let the compiler know that we are overriding the implementation of the <kbd>abstract</kbd> function called <kbd>Speak</kbd> in the derived class.</p>
<p>In the next section, we will look at the same example and understand how <kbd>abstract</kbd> methods differ from <kbd>virtual</kbd> methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Abstract versus virtual methods</h1>
                
            
            
                
<p>In the preceding example, we declared the <kbd>Speak</kbd> method as <kbd>abstract</kbd>. This forced our <kbd>Dog</kbd> class to provide an implementation of the method because, otherwise, we would get a compile-time error. Now, what if we don't want to have that particular restriction in our code?</p>
<p>We can do this by replacing the <kbd>abstract</kbd> method with the <kbd>virtual</kbd> method. The following is the changed implementation of the preceding code:</p>
<pre>public abstract class Animal<br/>{<br/>     public virtual void Speak()<br/>     { <br/>     }<br/>}</pre>
<p>Note that when you compile the code, there are no errors. Also, just for the sake of experimenting, comment out the <kbd>Speak</kbd> method in the <kbd>Dog</kbd> class.</p>
<p>Now, compile the program. Note that, unlike the previous case, when we use <kbd>abstract</kbd> methods, no compile-time errors occur:</p>
<div><img src="img/0f314e04-d673-4fd9-8045-82f76c321da4.png" style=""/></div>
<p>In the next section, we will look at <kbd>sealed</kbd> classes and how they are implemented in C# applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sealed classes</h1>
                
            
            
                
<p>A <kbd>sealed</kbd> class in C# is a class that we do not want to be inherited by any derived class. Once we insert the keyword <kbd>sealed</kbd>, a compiler will give a compile-time error if a derived class tries to inherit from the <kbd>sealed</kbd> class. The following is the screenshot of the same. For explanation purposes, we will use the same two classes we used in the preceding example:</p>
<div><img src="img/dc089c73-eadd-46f1-b15f-ba19c1353c83.png" style=""/></div>
<p>Note that <kbd>abstract</kbd> and <kbd>sealed</kbd> do not go hand in hand. <kbd>abstract</kbd> means that the class must never be instantiated, whereas the <kbd>sealed</kbd> class indicates that the class must never be inherited. Therefore, in hindsight, if we declare a <kbd>sealed</kbd> class as <kbd>abstract</kbd>, this will not make any sense. Thus, if we do try to declare an <kbd>abstract</kbd> class as <kbd>sealed</kbd>, we will get a compile-time error, as follows:</p>
<div><img src="img/e6492e94-c777-4aa6-8993-c146065b80be.png" style=""/></div>
<p>In the next section, we will look at another pillar of OOP programming, that is, <em>polymorphism</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding polymorphism</h1>
                
            
            
                
<p>Polymorphism is a Greek word whose literal translation to English is <em>many-shaped</em>. In programming terms, it's referred to as one interface with multiple functions. Let's try to understand polymorphism by looking at the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/539317c7-f54a-4233-9dec-c8b89f7cd982.png" style="width:22.08em;height:12.17em;"/> </p>
<p>In the preceding diagram, we have some program code that runs on <strong>Input 1</strong> and gives <strong>Output 1</strong>. Now, let's say we make a mistake and send an incorrect input of <strong>Input 2</strong> instead. In this case, unfortunately, the program code may error out and send an error message. In such a scenario, we can use polymorphism. With polymorphism, the same example will be represented as follows:</p>
<div><img src="img/1f794080-5921-49d2-8dbe-d6a8ee4d55b9.png" style=""/></div>
<p>As we can see, by using polymorphism, we will maintain three copies of the code in memory and depending on the type of input received, the appropriate copy of the program code will be loaded and executed. </p>
<p>There are two types of polymorphism possible in C#:</p>
<ul>
<li>Static/compile-time polymorphism, that is, method overloading or function overloading</li>
<li>Execution time polymorphism, that is, method overriding or virtual functions</li>
</ul>
<p>Let's go through each of these types and use code examples to understand how they work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Static/compile-time polymorphism</h1>
                
            
            
                
<p>Static polymorphism, also known as function overloading, involves creating functions with the same name but with different numbers or types of parameters. </p>
<p>The compiler loads the appropriate function based on the input that's passed. Let's go through the following code example to see how it works. Here, we will create two copies of a function called <kbd>ADD</kbd> that will differ in terms of the number of parameters accepted by the function:</p>
<pre>static int AddNumber (int a, int b)<br/>{<br/>     Console.WriteLine("Accepting two inputs");<br/>     return a + b;<br/>}<br/>static int AddNumber(int a, int b, int c)<br/>{<br/>     Console.WriteLine("Accepting three inputs");<br/>     return a + b + c;<br/>} </pre>
<p>Now, when the call is made to the function, based on the number of parameters passed, the respective function will be loaded:</p>
<pre>int result = AddNumber(1, 2);<br/>Console.WriteLine(result);<br/>int result2 = AddNumber(1, 2, 3);<br/>Console.WriteLine(result2);<br/>Console.ReadLine();</pre>
<p>After the program is executed, we will get the following output:</p>
<div><img src="img/8f624dda-0863-4caf-acd1-4fb2fddcef50.png" style=""/></div>
<p>Now, let's consider another example. In the preceding example, we implemented polymorphism based on the number of parameters. In this example, we will implement polymorphism based on the type of parameter:</p>
<ol>
<li>Create two classes, one each for <kbd>Dog</kbd> and <kbd>Cat</kbd>: </li>
</ol>
<pre style="padding-left: 60px">public class Dog <br/>{<br/>}<br/>public class Cat <br/>{<br/>}</pre>
<ol start="2">
<li>Create two functions with the same name but one accepting the input of a <kbd>Dog</kbd> object and another accepting the input of a <kbd>Cat</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">static void AnimalImplementation(Dog dog)<br/>{<br/>    Console.WriteLine("The implementation is for a dog."); <br/>}<br/>static void AnimalImplementation(Cat cat)<br/>{<br/>    Console.WriteLine("The implementation is for a cat.");<br/>}</pre>
<p>Now, when a call is made to the function, based on the type of parameter, the appropriate function will be loaded:</p>
<pre>Cat cat = new Cat();<br/>Dog dog = new Dog();<br/>AnimalImplementation(cat);<br/>AnimalImplementation(dog);<br/>Console.ReadLine();</pre>
<p>When the program is executed, it will show the following output:</p>
<div><img src="img/c5be0bc9-f734-4255-bb9e-5a05a4fe6bb9.png" style=""/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Runtime polymorphism</h1>
                
            
            
                
<p>Runtime polymorphism in C# is executed via virtual methods. In this type of polymorphism, the compiler executes the code by identifying its form at runtime. </p>
<p>In the <em>Method overriding</em> section, we learned about virtual methods and saw how they allow the derived class to override the implementation of a function in the base class. In runtime polymorphism, the object of the base class holds the reference to objects of the base and derived classes. Now, based on the object that the base object is pointing to, the appropriate function will be loaded.</p>
<p>To recap our understanding of this, let's go through another code example. In this example, we will create a base class called <kbd>Animal</kbd> that will be inherited by two classes, <kbd>Man</kbd> and <kbd>Dog</kbd>. </p>
<p>The following is the implementation in the <kbd>Animal</kbd> class:</p>
<pre>public class Animal<br/>{<br/>     public int numOfHands;<br/>     public int numOfLegs;<br/>     public virtual void Speak()<br/>     {<br/>         Console.WriteLine("This is a base implementation in the base animal class");<br/>     }<br/>}</pre>
<p>In the <kbd>Animal</kbd> class, we have declared two attributes to represent <kbd>numOfHands</kbd> and <kbd>numOfLegs</kbd> of the <kbd>Animal</kbd>. We have also declared a function called <kbd>Speak</kbd> and have marked it as <kbd>Virtual</kbd> so that any class that inherits from this class can give its own implementation of the <kbd>Speak</kbd> functionality.</p>
<p>We have declared the <kbd>Speak</kbd> function as virtual, which means that this function can be overridden in the derived class.</p>
<p>The following is the implementation in the <kbd>Dog</kbd> class: </p>
<pre>public class Dog : Animal<br/>{<br/>    public string breed;<br/>    public Dog(string breed, int hands, int legs)<br/>    {<br/>        this.breed = breed;<br/>        base.numOfHands = hands;<br/>        base.numOfLegs = legs;<br/>    }<br/><br/>    public override void Speak()<br/>    {<br/>        Console.WriteLine("A dog will bark , its breed is " + this.breed + " and number of legs and hands         are " + this.numOfLegs + " " + this.numOfHands);<br/>    }<br/>}</pre>
<p>In this implementation, we have created a <kbd>Dog</kbd> class that is inheriting from the <kbd>Animal</kbd> class. The <kbd>Dog</kbd> class has an attribute called <kbd>Breed</kbd> and a constructor that takes three parameters of <kbd>breed</kbd>, <kbd>hands</kbd>, and <kbd>legs</kbd>, respectively. We also have a <kbd>Speak</kbd> function to provide an impression of how a dog object will implement the <kbd>Speak</kbd> functionality.</p>
<p>The following code is for another class, <kbd>Human</kbd>, which will also inherit from the base class of <kbd>Animal</kbd>:</p>
<pre>public class Human : Animal<br/>{<br/>    public string countryOfCitizenship;<br/>    public Human(string citizenship, int hands, int legs)<br/>    {<br/>         this.countryOfCitizenship = citizenship;<br/>         base.numOfHands = hands;<br/>         base.numOfLegs = legs;<br/>    }<br/>    public override void Speak()<br/>    {<br/>         Console.WriteLine("A man can speak multiple languages, its citizenship is " +                              this.countryOfCitizenship + " and number of legs and hands are " + this.numOfLegs + " " +                  this.numOfHands);<br/>    }<br/>}</pre>
<p>In the preceding code, we are doing the following:</p>
<ul>
<li>We are inheriting the <kbd>Dog</kbd> class from the base class of <kbd>Animal</kbd>.</li>
<li>We are overriding the <kbd>Speak</kbd> function in the derived class.</li>
<li>We are also using the attributes that were declared in the base class.</li>
</ul>
<p>Now, let's see how runtime polymorphism works. In the following code, we are declaring an object of the base <kbd>Animal</kbd> class and pointing it to an object of the derived class:</p>
<pre>Animal animal = new Animal();<br/>animal.numOfHands = 2;<br/>animal.numOfLegs = 4;<br/>animal.Speak();<br/><br/>animal = new Dog("Labrador", 0, 4);<br/>animal.Speak();<br/><br/>animal = new Human("India", 2, 2);<br/>animal.Speak();<br/>Console.ReadLine();</pre>
<p>Once we execute this code, we will notice that, based on the class object reference that the base object <kbd>animal</kbd> is pointing to, the appropriate implementation of the <kbd>Speak</kbd> method will be loaded. This loading is decided at runtime, which is why this is called <strong>runtime polymorphism</strong>:</p>
<div><img src="img/cabfb529-154a-4e4d-9014-790e2f078430.png" style=""/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary </h1>
                
            
            
                
<p>In this chapter, we learned about object-oriented programming, which is the main essence of any high-level programming language, including C#. We learned about the four pillars of OOP, that is, encapsulation, abstraction, polymorphism, and inheritance, and understood how they help us write applications that are easy to maintain, are scalable, and have a good amount of reuse. </p>
<p>We learned how encapsulation helps us in keeping our code structured by grouping together all the related properties and methods in one class. Then, we learned how abstraction helps us reduce the complexity of a module that is exposed to the entire application. Using abstraction, we can make sure that all the complexities of a class are not exposed to outside classes, which also helps us maintain the application better. We also learned how we can use both runtime and static polymorphism to implement similar functionalities that can be reused across different inputs, thus helping us reuse our code throughout the application. Finally, we learned how inheritance helps us have more control over the application's implementation. Using inheritance, we can make sure that similar classes implement a set of properties and methods that are common across them.</p>
<p>While writing any program in C#, it's highly important that we keep these principles in mind. The biggest mistake that some C# programmers make these days is they don't utilize these core principles of OOP programming and, instead, the program that's written resembles more of a procedural language program. From a maintenance perspective, it helps us a lot as, to some extent, it ensures that the bug fixes in one module do not impact the complete application. </p>
<p>In the next chapter, we will look at the different operators that are used across C# programming. We will look at how we can manage program flow using operators and different conditional selection statements. We will also look at different iteration statements such as for and while loop, which help us control the program's flow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>
<p>Which of the following best describes a program in which we have multiple functions with the same name but they differ in terms of the number of parameters and types of parameters accepted by them?</p>
<ol type="a">
<li>
<p>Method overloading</p>
</li>
<li>
<p>Method overriding</p>
</li>
<li>
<p>Encapsulation</p>
</li>
<li>
<p>Abstraction</p>
</li>
</ol>
</li>
<li>
<p>Which keyword must be used when a derived class is defining the implementation of a function that's present in the base class?</p>
<ol type="a">
<li>
<p>New</p>
</li>
<li>
<p>Abstract</p>
</li>
<li>
<p>Virtual</p>
</li>
<li>
<p>Override</p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li>Which keyword can we use to prevent the inheritance of a particular class?
<ol type="a">
<li>
<p>Abstract</p>
</li>
<li>
<p>Private</p>
</li>
<li>
<p>Sealed</p>
</li>
<li>
<p>Protected</p>
</li>
</ol>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Answers</h1>
                
            
            
                
<ol>
<li>Method overloading or function overloading is the concept in which different implementations of a function with same name is made. Depending upon the number of arguments or type of argument, appropriate implementation of the function is loaded.</li>
<li>The override keyword allows a derived class to implement the abstract method declared in the base class.</li>
<li>Sealed. If a class is declared as sealed, it will prevent the inheritance of the base class throughout the application.</li>
</ol>


            

            
        
    </body></html>