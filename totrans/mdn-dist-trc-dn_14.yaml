- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Creating Your Own Conventions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的约定
- en: Correlation is one of the most important parts of observability. Distributed
    tracing bring correlation by propagating trace context, allowing us to follow
    individual operations, and consistent attributes enable correlation across traces
    and other telemetry signals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性是可观察性最重要的部分之一。分布式跟踪通过传播跟踪上下文带来相关性，使我们能够跟踪单个操作，而一致的属性使跟踪和其他遥测信号之间的相关性成为可能。
- en: In [*Chapter 9*](B19423_09.xhtml#_idTextAnchor148), *Best Practices*, we talked
    about the importance of reusing standard attributes and following OpenTelemetry
    semantic conventions. Sometimes we need to go further and define our own conventions.
    Here, we’re going to explore how to define custom attributes and conventions and
    use them across the system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第9章*](B19423_09.xhtml#_idTextAnchor148) 的 *最佳实践* 中，我们讨论了重用标准属性和遵循 OpenTelemetry
    语义约定的重要性。有时我们需要更进一步，定义我们自己的约定。在这里，我们将探讨如何定义自定义属性和约定，并在整个系统中使用它们。
- en: First, we’ll list properties that should be standardized across the system,
    and then we’ll explore how to populate them with shared code. Finally, we’ll look
    at OpenTelemetry’s semantic convention schema and see how it can simplify documenting
    and validating custom conventions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将列出应在整个系统中标准化的属性，然后我们将探讨如何使用共享代码来填充它们。最后，我们将查看 OpenTelemetry 的语义约定模式，并了解它如何简化自定义约定的文档和验证。
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Identify and document common attributes and conventions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和记录常见的属性和约定
- en: Share instrumentation and custom conventions across the system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个系统中共享仪器和自定义约定
- en: Use OpenTelemetry tooling to create conventions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 工具创建约定
- en: With this, you should be able to create easy-to-use processes and tools to keep
    custom telemetry and attributes consistent and stable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你应该能够创建易于使用的流程和工具，以保持自定义遥测和属性的一致性和稳定性。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available in the book’s repository on GitHub at
    [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上的书籍存储库中找到：[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14)。
- en: 'To run the examples and perform analysis, we’ll need the following tools:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例并执行分析，我们需要以下工具：
- en: .NET SDK 7.0 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK 7.0 或更高版本
- en: Docker and `docker-compose`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 和 `docker-compose`
- en: Defining custom conventions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义约定
- en: There are multiple ways to express even the most basic things. If we take our
    meme application example from [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083),
    *Configuration and Control Plane*, we enriched all spans with the meme name attribute
    so that we can find when the meme was uploaded or how frequently it’s accessed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表达最基本的事情也有多种方式。如果我们以 [*第5章*](B19423_05.xhtml#_idTextAnchor083) 的 meme 应用程序示例，*配置和控制平面*
    为例，我们为所有跨度添加了 meme 名称属性，以便我们可以在 meme 上传时找到它或了解它被访问的频率。
- en: We chose that approach, but we could instead write a log with the meme name
    once, and then use slightly more complicated queries to find all traces related
    to that meme. We could come up with something else, but what’s important is to
    keep the approach consistent across the system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了那种方法，但我们可以先记录一次 meme 名称的日志，然后使用稍微复杂一些的查询来找到与该 meme 相关的所有跟踪。我们可以想出其他方法，但重要的是在整个系统中保持方法的一致性。
- en: 'Even with a custom attribute added to each span, there are still plenty of
    things to consider when recording such an attribute:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使为每个跨度添加了自定义属性，在记录这样的属性时仍有许多事情需要考虑：
- en: '`meme_name`, `meme.name`, and `memeName` are different attributes. Unless we
    document the exact name and define it as a constant somewhere, someone will eventually
    use the wrong variation of it.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meme_name`、`meme.name` 和 `memeName` 是不同的属性。除非我们记录确切的名称并将其定义为某个地方的一个常量，否则最终有人会使用错误的变体。'
- en: '**Type**: The meme name is just a string. What if we wanted to capture the
    size or the image format? We need to document the type and maybe provide helper
    methods to record attributes so that it’s easier to set them correctly.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：主题名称只是一个字符串。如果我们想捕获大小或图像格式呢？我们需要记录类型，并可能提供辅助方法来记录属性，以便更容易地正确设置它们。'
- en: '`image/png` or as an enumeration?'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image/png` 或作为一个枚举？'
- en: When recording a meme name, we extract it from the uploaded filename, and we
    need to document what should be recorded on the attribute value (absolute or relative
    path, filename, with or without extension). If, when writing business logic, we
    sanitize or escape the meme name, or generate a unique one, we probably want to
    capture the one used by the business logic. We may also record the original name
    just once for debugging purposes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录meme名称时，我们从上传的文件名中提取它，并需要记录在属性值上应该记录什么（绝对路径或相对路径、文件名、带或不带扩展名）。如果在编写业务逻辑时，我们对meme名称进行清理或转义，或生成一个唯一的名称，我们可能想要捕获业务逻辑使用的那个。我们也可能只记录一次原始名称，用于调试目的。
- en: '**When to populate the attribute**: Document on which metrics, spans, and logs
    the attribute should be recorded. For example, meme names have high cardinality
    and do not belong on metrics. The meme name attribute can be recorded on spans
    and logs, but which ones? In our example in [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083),
    *Configuration and Control Plane*, we recorded the meme name on all spans and
    a couple of specific log records.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时填充属性**：记录在哪些指标、跨度和对数上应该记录属性。例如，meme名称具有高基数，不属于指标。meme名称属性可以记录在跨度和对数上，但哪些可以？在我们的例子中，在[*第五章*](B19423_05.xhtml#_idTextAnchor083)的*配置和控制平面*中，我们在所有跨度上记录了meme名称，并在几个特定的日志记录上记录了它。'
- en: 'There are other aspects you might want to document: relationships between spans,
    event names, whether to record exceptions on spans, attribute cardinality, stability,
    and so on.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想记录其他方面：跨度之间的关系、事件名称、是否在跨度上记录异常、属性基数、稳定性等等。
- en: We’ll see how to formally define attributes in the *Using OpenTelemetry schemas
    and tools* section of this chapter. Now, let’s focus on naming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的*使用OpenTelemetry模式和工具*部分中看到如何正式定义属性。现在，让我们专注于命名。
- en: Naming attributes
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名属性
- en: Naming is known to be one of the hardest problems in computer science.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命名被认为是计算机科学中最难的问题之一。
- en: If we named the meme name attribute `document.id`, it might precisely match
    a property in the database schema. However, it would be very generic and have
    a high chance of collision with another similar concept in the system. People
    who are not familiar with the internals but analyze business data might have a
    hard time understanding what `document.id` represents.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将meme名称属性命名为`document.id`，它可能与数据库模式中的一个属性精确匹配。然而，它将非常通用，并且与系统中另一个类似概念发生冲突的概率很高。不熟悉内部结构但分析业务数据的人可能很难理解`document.id`代表什么。
- en: '`meme_name` seems to be intuitive, short, and descriptive, and the chances
    of a collision with something else are low. It seems fine, but we’ll probably
    have other attributes and should put them into an application-specific or company-specific
    namespace.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`meme_name`看起来直观、简短且描述性强，与其他事物的冲突概率很低。这似乎是可行的，但我们可能还有其他属性，应该将它们放入特定于应用程序或公司的命名空间中。'
- en: Namespaces
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces allow us to set unique, specific, descriptive, and consistent names.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间允许我们设置唯一、具体、描述性和一致的名称。
- en: Since we have called our system `memes`, let’s use it as the root namespace.
    This will help us understand that all attributes in this space come from our customizations
    and are not set by some auto-instrumentation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们称我们的系统为`memes`，让我们将其用作根命名空间。这将帮助我们理解这个空间中的所有属性都来自我们的自定义，而不是由某些自动工具设置。
- en: This helps us navigate between telemetry and makes it possible to do filtering,
    redaction, and other post-processing in telemetry pipelines. For example, if we
    want to remove unknown attributes from logs, we can consider everything in the
    `memes` namespace (http, `db`, and so on) to be known.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们在遥测之间导航，并使得在遥测管道中进行过滤、编辑和其他后处理成为可能。例如，如果我们想从日志中删除未知属性，我们可以考虑`memes`命名空间（http、`db`等）中的所有内容都是已知的。
- en: 'We can have nested namespaces. Since we’d like to record other meme properties,
    such as size and type, we can end up with the following set of attributes: `memes.meme.name`,
    `memes.meme.size`, and `memes.meme.type`. We can easily add other properties as
    we see fit, such as `memes.meme.author` or `memes.meme.description`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有嵌套的命名空间。由于我们希望记录其他meme属性，例如大小和类型，我们最终可能会得到以下一组属性：`memes.meme.name`、`memes.meme.size`和`memes.meme.type`。我们可以根据需要轻松添加其他属性，例如`memes.meme.author`或`memes.meme.description`。
- en: While `memes.meme` might look repetitive, it’ll start to make more sense once
    we add something such as `memes.user.name` or `memes.tag.description`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`memes.meme`可能看起来重复，但一旦我们添加了诸如`memes.user.name`或`memes.tag.description`之类的元素，它就会开始更有意义。
- en: The OpenTelemetry naming convention (available at [https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md))
    uses a dot (`.`) as a separator between namespaces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 命名约定（可在[https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md)找到）使用点（`.`）作为命名空间之间的分隔符。
- en: 'For multi-word namespaces or attributes, OpenTelemetry recommends `snake_case`:
    for example, we could introduce `memes.meme.creation_date`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多词命名空间或属性，OpenTelemetry建议使用`snake_case`：例如，我们可以引入`memes.meme.creation_date`。
- en: Following this convention for our custom attributes allows us to stay consistent
    across all attributes. It will also reduce the chance of mistakes while writing
    queries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此约定为我们自定义属性，使我们能够在所有属性中保持一致性。它还将减少在编写查询时的错误机会。
- en: Having a schema defined and documented in some form is an essential step. But
    how can we keep it in sync with the code and ensure all services follow it? One
    way to do so is by capturing it in code and reusing it across the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种形式下定义和记录模式是一个基本步骤。但如何使其与代码保持同步并确保所有服务都遵循它？做到这一点的一种方法是将它捕获在代码中并在整个系统中重用它。
- en: Sharing common schema and code
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享公共模式和代码
- en: Consistent telemetry reporting applies to telemetry collection configuration.
    First, we need to enable a basic layer of instrumentation on all services, which
    should include resource utilization metrics, traces, and metrics for HTTP, gRPC,
    or any other RPC protocol used in your system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一致的遥测报告适用于遥测收集配置。首先，我们需要在所有服务上启用基本层级的仪器，这应该包括资源利用率指标、跟踪和HTTP、gRPC或系统使用的任何其他RPC协议的指标。
- en: We should also configure sampling and resource attributes, add enrichment processors,
    and set up context propagators.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该配置采样和资源属性，添加丰富处理程序，并设置上下文传播器。
- en: 'Individual services should be able to customize configuration to some extent:
    add more instrumentations, enable custom activity sources and meters, or control
    log verbosity.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单个服务应该能够在一定程度上自定义配置：添加更多仪器、启用自定义活动源和仪表、或控制日志详细程度。
- en: The easiest way to unify configuration is to ship corresponding code as a common
    library (or a set of them) shared across all the services in your system. Such
    libraries would define configuration options, provide helper methods to enable
    telemetry collection, implement common enrichment processors, declare cross-service
    events, and so on. Let’s go ahead and implement such a configuration helper.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 统一配置的最简单方法是将相应的代码作为公共库（或一组库）分发，这些库在系统中的所有服务之间共享。这样的库将定义配置选项，提供辅助方法以启用遥测收集，实现常见的丰富处理程序，声明跨服务事件等。让我们继续实现这样的配置助手。
- en: Sharing setup code
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享设置代码
- en: In [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083), *Configuration and Control
    Plane*, and other chapters where we used meme application, we applied OpenTelemetry
    configuration individually in each service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B19423_05.xhtml#_idTextAnchor083)“配置和控制平面”以及其他章节中，我们使用了meme应用程序，我们在每个服务中单独应用了OpenTelemetry配置。
- en: We’d never do this in production code – it’s hard to keep our configurations,
    instrumentation options, OpenTelemetry package versions, and anything else in
    sync.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不会在生产代码中这样做——很难保持我们的配置、仪器选项、OpenTelemetry包版本和其他一切同步。
- en: To fix this, we can start extracting common pieces of instrumentation code into
    a shared library. Since the configuration can slightly vary from service to service,
    we’ll need to define some configuration options.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以开始将常见的仪器代码片段提取到一个共享库中。由于配置可能从服务到服务略有不同，我们需要定义一些配置选项。
- en: We need are options that would help us to set the service name, specify the
    sampling rate or strategy, enable additional instrumentations, and more. You can
    find an example of such options in the `MemesTelemetryConfiguration` class in
    the book’s repository.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些选项来帮助我们设置服务名称，指定采样率或策略，启用额外的仪器，等等。你可以在书籍仓库中的`MemesTelemetryConfiguration`类中找到一个这样的选项示例。
- en: 'Then we can declare a helper method that takes care of the OpenTelemetry configuration.
    Here’s an example of this method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以声明一个处理OpenTelemetry配置的辅助方法。以下是这个方法的示例：
- en: OpenTelemetryExtensions.cs
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetryExtensions.cs
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs)'
- en: All services that use this method will have the same basic level of instrumentation
    applied and enriched consistently.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '使用此方法的所有服务都将应用和丰富相同的基本级别的仪表。 '
- en: 'Here’s an example of using this method in the **storage** service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在**存储**服务中使用此方法的示例：
- en: storage/Program.cs
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: storage/Program.cs
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs)'
- en: Here, we read the telemetry options from the `Telemetry` section of the ASP.NET
    Core configuration, which you can populate in any way that works for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从 ASP.NET Core 配置的 `Telemetry` 部分读取遥测选项，您可以根据自己的需要以任何方式填充它。
- en: Then, we add the Entity Framework instrumentation. Only the **storage** service
    needs it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了 Entity Framework 仪表。只有**存储**服务需要它。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Having a central library that enables collection helps to reduce version hell.
    By having a dependency on it, individual service packages get a transitive dependency
    on OpenTelemetry packages and should never add them as direct dependencies. Services
    that need an uncommon instrumentation library would still need to install the
    corresponding NuGet package.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个中央库，它能够实现收集功能，有助于减少版本混乱。通过依赖它，各个服务包会获得对 OpenTelemetry 包的传递依赖，并且不应将其作为直接依赖添加。需要不常见仪表库的服务仍然需要安装相应的
    NuGet 包。
- en: Now that we have a common setup, let’s see what we can do to help services follow
    our custom semantic conventions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了共同的设置，让我们看看我们可以做些什么来帮助服务遵循我们的自定义语义约定。
- en: Codifying conventions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定法典化
- en: In the previous example, we started recording the meme name attribute – we enabled
    `MemeNameEnrichingProcessor`, which sets the `memes.meme.name` attribute on each
    span. Individual services don’t need to do anything to enable it and cannot set
    the wrong attribute name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们开始记录 meme 名称属性——我们启用了 `MemeNameEnrichingProcessor`，它将 `memes.meme.name`
    属性设置在每个跨度上。各个服务不需要做任何事情来启用它，也不能设置错误的属性名称。
- en: 'Still, we might need to use the attribute directly in some other parts (for
    example, on logs), so it’s important to declare the attribute name as a constant
    and never use a string literal in the code. Here’s an example demonstrating how
    attribute names can be declared:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可能还需要在其他某些部分（例如日志）中直接使用属性，因此声明属性名称为常量并永远不在代码中使用字符串字面量是很重要的。以下是一个演示如何声明属性名称的示例：
- en: SemanticConventions.cs
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SemanticConventions.cs
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs)'
- en: OpenTelemetry also provides the `OpenTelemetry.SemanticConventions` NuGet package,
    which declares common attributes defined in the specification. It might make sense
    to add a dependency to it when reusing common attributes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 还提供了 `OpenTelemetry.SemanticConventions` NuGet 包，它声明了规范中定义的常见属性。在重用常见属性时添加对其的依赖可能是有意义的。
- en: So, we have now defined constants for the attribute names, and we have a processor
    that populates the meme name. Can we do more?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经为属性名称定义了常量，并且有一个填充 meme 名称的处理器。我们能做更多吗？
- en: 'We can provide helpers to report common events in a performant and consistent
    manner. Let’s look at how we can use the high-performance logging we explored
    in [*Chapter 8*](B19423_08.xhtml#_idTextAnchor131), *Writing Structured and Correlated
    Logs*, to populate our attributes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供助手以高效且一致地报告常见事件。让我们看看我们如何使用我们在[*第 8 章*](B19423_08.xhtml#_idTextAnchor131)中探索的高性能日志记录，*编写结构和关联日志*，来填充我们的属性：
- en: EventService.cs
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: EventService.cs
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs)'
- en: Here, we have some difficult-to-read code. It defines a log record representing
    the meme download event by following the OpenTelemetry conventions and our own
    conventions. We would not want to write this code every time we needed to log
    something.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一些难以阅读的代码。它通过遵循OpenTelemetry约定和我们的约定，定义了一个表示表情包下载事件的日志记录。我们并不希望每次需要记录某些内容时都编写此代码。
- en: Implementing this event once in the common library and making it easy to reuse
    is the best way to record the event consistently and with a low performance overhead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共库中实现此事件一次，并使其易于重用，是记录事件一致性和低性能开销的最佳方式。
- en: 'Now, anyone can use the `DownloadMemeEvent` method, as shown in the following
    example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何人都可以使用`DownloadMemeEvent`方法，如下面的示例所示：
- en: StorageService.cs
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: StorageService.cs
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs)'
- en: This is easy to use and performant, and there is no need to worry about attributes,
    their types, or any conventions at all. If attributes are renamed, there is no
    need to update the service code – it’s all hidden in the shared library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易使用且性能良好，无需担心属性、它们的类型或任何约定。如果属性被重命名，无需更新服务代码——所有这些都隐藏在共享库中。
- en: If we follow this approach, we can define other events and add helper methods
    to populate attribute groups on metrics and traces.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循这种方法，我们可以定义其他事件并为指标和跟踪添加辅助方法来填充属性组。
- en: If we need any custom instrumentations, like we had for gRPC or messaging, we
    should put them into shared libraries and apply all the attributes there instead
    of in the service code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要任何自定义的仪器，就像我们为gRPC或消息传递所做的那样，我们应该将它们放入共享库中，并在那里应用所有属性，而不是在服务代码中。
- en: Separating telemetry-related code from business logic makes them both easier
    to read and maintain. It also makes telemetry-related code testable and helps
    us to keep it in sync with documentation. It also becomes easy to enforce conventions
    with tests and notice during code review when shared code changes something controlled
    by semantic conventions and breaks them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将与遥测相关的代码从业务逻辑中分离出来，使它们都更容易阅读和维护。这也使得与遥测相关的代码可测试，并帮助我们保持它与文档的一致性。这也使得通过测试强制执行约定变得容易，并在代码审查期间，当共享代码更改由语义约定控制的某些内容时，可以注意到这些更改。
- en: Defining semantic conventions in code is sufficient for some applications. Others,
    which may use different languages or have some other constraints, cannot rely
    on shared code alone. Either way, telemetry can be used by everyone in the company
    for business reporting and for any non-technical needs. So, it’s important to
    document it separately from code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中定义语义约定对于某些应用来说是足够的。其他可能使用不同语言或有一些其他约束的应用，不能仅仅依赖共享代码。无论如何，公司中的每个人都可以使用遥测数据来进行业务报告和满足任何非技术需求。因此，将它们与代码分开单独记录是很重要的。
- en: Let’s see how we can do this using OpenTelemetry tooling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用OpenTelemetry工具来实现这一点。
- en: Using OpenTelemetry schemas and tools
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenTelemetry模式和工具
- en: It does not really matter how we document custom semantic conventions. The goal
    is to have a consistent and specific convention that’s easy to read and follow.
    Let’s see how the OpenTelemetry semantic conventions schema may help with this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并不关心如何记录自定义语义约定。目标是有一个一致且具体的约定，易于阅读和遵循。让我们看看OpenTelemetry语义约定模式如何帮助解决这个问题。
- en: Semantic conventions schema
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义约定模式
- en: So far, when we have talked about semantic conventions, we have referred to
    Markdown files such as [https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md).
    These files are the source of truth, but here, we’re going to take a look at the
    implementation details behind them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们谈论语义约定时，我们提到了如 [https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md)
    这样的 Markdown 文件。这些文件是真相的来源，但在这里，我们将看看其背后的实现细节。
- en: The tables describing the attributes in these files are usually auto-generated.
    Attributes are defined in YAML files that follow OpenTelemetry’s semantic convention
    schema.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中描述属性的表格通常是自动生成的。属性定义在遵循 OpenTelemetry 语义约定架构的 YAML 文件中。
- en: YAML files could be shared across different semantic conventions and signals
    and then consistently written to all Markdown files with a script.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件可以在不同的语义约定和信号之间共享，然后使用脚本一致地写入所有 Markdown 文件。
- en: 'Let’s see how our meme attributes can be defined in a YAML file to get an impression
    of the schema:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 YAML 文件中定义我们的 meme 属性，以了解其架构：
- en: memes-common.yaml
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: memes-common.yaml
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
- en: Here, we defined the `name` attribute with a `string` type inside the `memes.meme`
    namespace (defined by the `prefix` property). It’s a required attribute since,
    in [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083), *Configuration and Control
    Plane*, we decided to record the meme name attribute on all the spans.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `memes.meme` 命名空间（由 `prefix` 属性定义）内定义了 `name` 属性，其类型为 `string`。这是一个必需属性，因为在
    [*第 5 章*](B19423_05.xhtml#_idTextAnchor083)，*配置和控制平面* 中，我们决定在所有跨度上记录 meme 名称属性。
- en: 'OpenTelemetry supports several requirement levels:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 支持多个需求级别：
- en: '`required`: Any telemetry item that follows this convention must set the attribute.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`：遵循此约定的任何遥测项都必须设置该属性。'
- en: '`conditionally_required`: The attribute must be populated when a condition
    is met. For example, http.route is only populated when routing is enabled and
    a route is available.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conditionally_required`：当满足条件时，必须填充该属性。例如，http.route 仅在启用路由且存在路由时填充。'
- en: '`recommended`: The attribute should be populated, but may be removed or disabled.
    Observability backends and tools should not rely on it being available. This is
    the default level.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommended`：应填充该属性，但可能被删除或禁用。可观察性后端和工具不应依赖于其可用性。这是默认级别。'
- en: '`opt_in`: The attribute is not populated by default, but is known and documented,
    and it can be added when it’s explicitly enabled.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opt_in`：默认情况下不填充该属性，但已知并已记录，并且可以在明确启用时添加。'
- en: 'Let’s see how we can define the `size` attribute:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义 `size` 属性：
- en: memes-common.yaml
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: memes-common.yaml
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
- en: The `size` attribute has the `int` type (and maps to `int64` or `long`) and
    an `opt-in` level as we don’t want to record it on all telemetry by default.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 属性具有 `int` 类型（并映射到 `int64` 或 `long`），并且具有 `opt-in` 级别，因为我们不希望在默认情况下记录所有遥测数据。'
- en: 'Finally, we can define the `type` attribute:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以定义 `type` 属性：
- en: memes-common.yaml
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: memes-common.yaml
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
- en: Here, we define `type` as an enumeration. Instrumentation must use one of the
    values defined here or set `type` to `unknown`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `type` 定义为一个枚举。仪器必须使用这里定义的值之一或将 `type` 设置为 `unknown`。
- en: I hope your team won’t spend too much time deciding between JPEG and JPG – either
    is fine. What’s important is to pick and document one option.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你的团队不会在 JPEG 和 JPG 之间花费太多时间决定——两者都可以。重要的是要选择并记录一个选项。
- en: You can find the full schema definition in the OpenTelemetry build tools repository
    on GitHub (https://github.com/open-telemetry/build-tools/blob/main/semantic-conventions/syntax.md).
    It also contains the schema definition that your IDE may use to autocomplete and
    validate schema files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上 OpenTelemetry 构建工具仓库中找到完整的模式定义（https://github.com/open-telemetry/build-tools/blob/main/semantic-conventions/syntax.md）。它还包含你的
    IDE 可能用于自动完成和验证模式文件的模式定义。
- en: Now that we have defined a few attributes, let’s use another OpenTelemetry tool
    to validate the schema file and generate content in a Markdown file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一些属性，让我们使用另一个 OpenTelemetry 工具来验证模式文件，并在 Markdown 文件中生成内容。
- en: 'If you look at the raw `memes.md` file in the book repository, it contains
    documentation with the following annotations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看书籍仓库中的原始 `memes.md` 文件，它包含以下注释的文档：
- en: memes.md
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: memes.md
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md)'
- en: 'Content in between these lines is auto-generated from the YAML group that has
    the `memes.meme` identifier. We can regenerate this content with the following
    command (make sure to specify the path):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行之间的内容是从具有 `memes.meme` 标识符的 YAML 组自动生成的。我们可以使用以下命令重新生成此内容（确保指定路径）：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we use the Markdown generator from the `otel/semconvgen` image. We mount
    the `source` and `destination` volumes. The generator recursively parses all YAML
    files found in the `source` folder and then generates attribute tables in Markdown
    files available in the `destination` folder based on the `semconv` annotations
    we saw earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `otel/semconvgen` 图像中的 Markdown 生成器。我们挂载了 `source` 和 `destination`
    卷。生成器递归地解析 `source` 文件夹中找到的所有 YAML 文件，然后根据我们之前看到的 `semconv` 注释，在 `destination`
    文件夹中生成 Markdown 文件中的属性表。
- en: The generation is the cherry on top of the cake, and you might not need it initially.
    Still, if you decide to use OpenTelemetry semantic convention schemas, make sure
    to use the `otel/semconvgen` tool to *validate* YAML files, which you can do as
    a part of your CI run; just add the `–md-check` flag to the previous command.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 生成是蛋糕上的樱桃，你可能一开始不需要它。不过，如果你决定使用 OpenTelemetry 语义约定模式，请确保使用 `otel/semconvgen`
    工具来 *验证* YAML 文件，你可以在 CI 运行过程中这样做；只需将 `–md-check` 标志添加到之前的命令中。
- en: The tooling also supports generating attribute definitions in code using Jinja
    templates (https://jinja.palletsprojects.com). All we need is to create a Jinja
    template for the `SemanticConventions.cs` file and run the `otel/semconvgen` generator.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 工具还支持使用 Jinja 模板（https://jinja.palletsprojects.com）在代码中生成属性定义。我们只需要为 `SemanticConventions.cs`
    文件创建一个 Jinja 模板，然后运行 `otel/semconvgen` 生成器。
- en: We can also define tracing, metrics, or event-specific conventions. Let’s do
    it for events.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义跟踪、指标或特定事件的约定。让我们为事件做这件事。
- en: Defining event conventions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义事件约定
- en: Meme upload and download events are important for business reporting. We can’t
    really expose them as metrics – meme names have high cardinality and we’re interested
    in finding the most popular ones or measuring other per-meme things.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 段子上传和下载事件对于业务报告非常重要。我们实际上不能将它们作为指标暴露——段子名称具有高基数，我们感兴趣的是找到最受欢迎的或者测量每个段子的其他事物。
- en: 'To avoid breaking business reporting, we need to make sure events are defined
    precisely enough and are well documented. To achieve this, we can declare an event
    in the following way:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免破坏业务报告，我们需要确保事件定义得足够精确，并且有良好的文档记录。为了实现这一点，我们可以以下述方式声明一个事件：
- en: memes-events.yaml
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: memes-events.yaml
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml)'
- en: Here, we declare a group with the `event` type (previously, we used `attribute_group`,
    which is signal agnostic). We provided a prefix (`download_name`) that documents
    the event name. We added references to attributes defined previously, but now
    require the presence of the `size` and `type` attributes on these events only.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个具有 `event` 类型的组（之前，我们使用 `attribute_group`，它是信号无关的）。我们提供了一个前缀（`download_name`），用于记录事件名称。我们添加了对先前定义的属性的引用，但现在仅在这些事件上需要
    `size` 和 `type` 属性的存在。
- en: You might have noticed that the event name does not contain a namespace – here,
    we follow the `event` semantic convention. If you look at the corresponding code
    snippet for the `EventService` class, we also record the `event.domain` attribute,
    which serves as a namespace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到事件名称不包含命名空间——在这里，我们遵循 `event` 语义约定。如果您查看 `EventService` 类的相应代码片段，我们也会记录
    `event.domain` 属性，该属性作为命名空间。
- en: With this approach, we can define spans or metric conventions that reuse the
    same common attributes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们可以定义跨度的或度量约定，这些约定重用了相同的公共属性。
- en: These schemas or corresponding Markdown files would define and document the
    contract between telemetry producers and consumers regardless of the language
    they use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式或相应的 Markdown 文件将定义和记录遥测生产者和消费者之间的合同，无论他们使用什么语言。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about different ways to keep custom telemetry and
    attributes consistent across your system. We identified attribute properties to
    be documented and learned about attribute naming conventions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在不同系统内保持自定义遥测和属性一致性的不同方法。我们确定了需要记录的属性属性，并了解了属性命名约定。
- en: Keeping telemetry consistent is a challenge. We explored how to make it easier
    by sharing common instrumentation code, including OpenTelemetry setup and utility
    methods that report attributes with the right names and types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 保持遥测的一致性是一个挑战。我们探讨了如何通过共享公共仪表化代码来使其更容易，包括 OpenTelemetry 设置和实用方法，这些方法报告具有正确名称和类型的属性。
- en: Finally, we learned about the OpenTelemetry semantic conventions schema and
    tooling, which may help you define, validate, and automate the documentation process
    for custom conventions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了 OpenTelemetry 语义约定模式和工具，这可能有助于您定义、验证和自动化自定义约定的文档过程。
- en: Defining a common schema for telemetry during the early stages of a project
    is going to save your organization a lot of time down the road, and now you have
    the knowledge and tools to do it. In the next chapter, we’ll talk about brownfield
    systems, where new solutions coexist with legacy ones, and we’ll see how difficult
    it can be to align different standards and conventions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的早期阶段为遥测定义一个公共模式将为您组织节省大量时间，现在您拥有了知识和工具来实现这一点。在下一章中，我们将讨论棕色地带系统，其中新解决方案与旧解决方案共存，我们将看到对齐不同标准和约定有多么困难。
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: It’s likely that alerts, dashboards, and usage reporting depend on custom telemetry
    and rely on conventions. How would you approach evolving conventions to prevent
    breaking something critical?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报、仪表板和用法报告很可能依赖于自定义遥测并依赖于约定。你将如何处理演变约定以防止破坏关键部分？
- en: Is it possible to validate that telemetry coming from some service follows defined
    semantic conventions?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以验证来自某些服务的遥测是否符合定义的语义约定？
