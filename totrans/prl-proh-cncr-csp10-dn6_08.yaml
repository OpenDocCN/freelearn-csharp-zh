- en: '*Chapter 6*: Parallel Programming Concepts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：并行编程概念'
- en: The `Task` objects. This chapter will delve deeper into the `System.Threading.Tasks.Parallel`
    members in the TPL and some additional tasking concepts for handling related tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 对象。本章将进一步探讨 TPL 中的 `System.Threading.Tasks.Parallel` 成员以及一些额外的任务概念，用于处理相关任务。'
- en: The lines between parallel programming, concurrency, and asynchronous programming
    are not always clear-cut, and you will discover where the three concepts intersect
    as we read ahead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程、并发编程和异步编程之间的界限并不总是清晰的，随着我们继续阅读，您将发现这三个概念相交的地方。
- en: 'In this chapter, you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Getting started with the TPL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 TPL
- en: Parallel loops in .NET
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 中的并行循环
- en: Relationships between parallel tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行任务之间的关系
- en: Common pitfalls with parallelism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行编程的常见陷阱
- en: By the end of this chapter, you will understand how to use parallel programming
    in your own projects, why you would choose a parallel loop over a standard loop,
    and when to use `async` and `await` instead of a parallel loop.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何在自己的项目中使用并行编程，为什么您会选择并行循环而不是标准循环，以及何时使用 `async` 和 `await` 而不是并行循环。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，建议 Windows 开发者使用以下软件：
- en: Visual Studio 2022 version 17.0 or later
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 版本 17.0 或更高版本
- en: .NET 6
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐使用的，但如果您已安装 .NET 6，您可以使用您喜欢的编辑器。例如，macOS 10.13 或更高版本的 Visual Studio 2022
    for Mac、JetBrains Rider 或 Visual Studio Code 都可以正常工作。
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06)。
- en: Let’s get started by discussing the TPL and where it fits within the world of
    parallel programming in .NET.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论 TPL 以及它在 .NET 并行编程世界中的位置开始。
- en: Getting started with the TPL
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 TPL
- en: The `System.Threading` and `System.Threading.Tasks` namespaces in *.NET Framework
    4.0*. The TPL provides features that make parallelism and concurrency simpler
    for .NET developers. There is no need to manage the `ThreadPool` tasks in your
    code. The TPL handles thread management and automatically scales the number of
    active threads based on processor capability and availability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *.NET Framework 4.0* 中的 `System.Threading` 和 `System.Threading.Tasks` 命名空间。TPL
    提供了使并行性和并发性对 .NET 开发者来说更简单的功能。您不需要在代码中管理 `ThreadPool` 任务。TPL 处理线程管理，并自动根据处理器能力和可用性调整活动线程的数量。
- en: Developers should use the TPL when they need to introduce parallelism or concurrency
    to their code for improved performance. However, the TPL is not the right choice
    for every scenario. How do you know when to choose the TPL and which TPL constructs
    are the best choice for each scenario?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应在需要将并行性或并发性引入代码以提高性能时使用 TPL。然而，TPL 并不是每个场景的正确选择。您如何知道何时选择 TPL 以及每个场景的最佳
    TPL 构造？
- en: Let’s explore a few common scenarios.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些常见的场景。
- en: I/O-bound operations
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 密集型操作
- en: When dealing with I/O-bound operations such as file operations, database calls,
    or web service calls, asynchronous programming with `Task` objects and C# `async`/`await`
    operations are your best choice. If your service requires that you loop through
    a large collection, making a service call for each object in the loop, you should
    consider refactoring the service to return the data as a single service call.
    This will minimize the overhead associated with each network operation. It will
    also allow your client code to make a single `async` call to the service while
    keeping the main thread free to do other work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 I/O 密集型操作，如文件操作、数据库调用或 Web 服务调用时，使用 `Task` 对象和 C# 的 `async`/`await` 操作进行异步编程是您的最佳选择。如果您的服务需要您循环遍历一个大型集合，并为循环中的每个对象进行服务调用，您应考虑重构服务以返回单个服务调用中的数据。这将最小化与每个网络操作相关的开销。它还将允许您的客户端代码对服务进行单个
    `async` 调用，同时保持主线程可以执行其他工作。
- en: I/O-bound operations are usually not suited to parallel operations, but there
    are exceptions to every rule. If you need to iterate through a set of folders
    and subfolders in the filesystem, a parallel loop can be well-suited for this.
    However, it is important that none of the iterations of your loop attempt to access
    the same file in order to avoid locking issues.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: I/O密集型操作通常不适合并行操作，但每条规则都有例外。如果你需要遍历文件系统中的一组文件夹和子文件夹，并行循环可能非常适合这个任务。然而，重要的是，你的循环的任何迭代都不要尝试访问相同的文件，以避免锁定问题。
- en: Now, let’s explore some CPU-bound scenarios.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一些CPU密集型场景。
- en: CPU-bound operations
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU密集型操作
- en: CPU-bound operations are not reliant on outside resources such as the filesystem,
    network, or the internet. They involve processing data in memory within your application’s
    process. There are many types of data transformation that fall into this category.
    Your application may be serializing or deserializing data, converting between
    file types, or processing images or other binary data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CPU密集型操作不依赖于外部资源，如文件系统、网络或互联网。它们涉及在应用程序进程内处理内存中的数据。有许多类型的数据转换属于这一类别。你的应用程序可能正在序列化或反序列化数据，在文件类型之间转换，或处理图像或其他二进制数据。
- en: These types of operations make sense for data parallelism and parallel loops
    in particular, with a couple of exceptions. First, if each iteration is not very
    CPU intensive, using the TPL is not worth the overhead it introduces. If the process
    is very intensive, but there are very few objects to iterate over, consider using
    `Parallel.Invoke` instead of one of the parallel loops, `Parallel.For` or `Parallel.ForEach`.
    Using parallel constructs for less CPU-intense operations can often slow your
    code due to the overhead of using the TPL. In [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158)
    we will learn how to use Visual Studio to determine the performance of parallel
    and concurrent code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这类操作对于数据并行性和特定的并行循环来说是有意义的，但有几点例外。首先，如果每个迭代不是非常CPU密集型，使用TPL带来的开销不值得。如果过程非常密集，但迭代对象很少，考虑使用`Parallel.Invoke`而不是`Parallel.For`或`Parallel.ForEach`中的一个并行循环。对于CPU密集度较低的操作使用并行结构可能会因为使用TPL的开销而减慢你的代码。在第[*第10章*](B18552_10_ePub.xhtml#_idTextAnchor158)中，我们将学习如何使用Visual
    Studio来确定并行和并发代码的性能。
- en: Now that you have some understanding of when to use parallelism in your applications,
    let’s explore some practical examples of using `Parallel.For` and `Parallel.ForEach`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解在应用程序中何时使用并行性，让我们探索一些使用`Parallel.For`和`Parallel.ForEach`的实际示例。
- en: Parallel loops in .NET
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的并行循环
- en: In this section, we will explore some examples of leveraging data parallelism
    in .NET projects. The parallel versions of the C# `for` and `foreach` loops, `Parallel.For`
    and `Parallel.ForEach`, are part of the `System.Threading.Tasks.Parallel` namespace.
    Using these parallel loops is similar to using their standard counterparts in
    C#.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些在.NET项目中利用数据并行性的示例。C#的`for`和`foreach`循环的并行版本，`Parallel.For`和`Parallel.ForEach`，是`System.Threading.Tasks.Parallel`命名空间的一部分。使用这些并行循环的方式与使用它们的C#标准对应物相似。
- en: One key difference is that the body of the parallel loops is declared as a `continue`
    to stop the current iteration of the loop without breaking the entire loop, you
    would use a `return` statement. The equivalent of using `break` to break out of
    a parallel loop is to use the `Stop()` or `Break()` statements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的区别是，并行循环的主体被声明为`continue`以停止循环的当前迭代，而不中断整个循环，你会使用`return`语句。使用`break`跳出并行循环的等效操作是使用`Stop()`或`Break()`语句。
- en: Let’s look at an example of using a `Parallel.For` loop in a .NET WinForms application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在.NET WinForms应用程序中使用`Parallel.For`循环的一个示例。
- en: Basic Parallel.For loops
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本并行`Parallel.For`循环
- en: 'We are going to create a new `FileProcessor` class will iterate the files to
    aggregate the file size and find the most recently written file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`FileProcessor`类，它将遍历文件以聚合文件大小并找到最近写入的文件：
- en: Start by creating a new .NET 6 WinForms project in Visual Studio
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在Visual Studio中创建一个新的.NET 6 WinForms项目
- en: 'Add a new class named `FileData`. This class will contain the data from `FileProcessor`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`FileData`的新类。这个类将包含`FileProcessor`中的数据：
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will be returning a list of the `FileInfo` objects for the files in the selected
    folder, the total size of all files, the name of the last written file, and the
    date and time that the file was written.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将返回一个包含所选文件夹中文件的`FileInfo`对象列表，所有文件的总大小，最后写入的文件名以及文件被写入的日期和时间。
- en: Next, create a new class named `FileProcessor`
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `FileProcessor` 的新类
- en: 'Add a static method named `GetInfoForFiles` to `FileProcessor`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `FileProcessor` 添加一个名为 `GetInfoForFiles` 的静态方法：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Parallel.For` loop and the **lambda expression** of its body are highlighted
    in the preceding code. There are a few things to note about the code inside the
    loop:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Parallel.For` 循环及其体中的 **lambda 表达式** 被突出显示。关于循环内的代码有一些需要注意的事项：
- en: First, `index` is provided as a parameter to the lambda expression so the expression
    body can use it to access the current member of the `files` array.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`index` 作为参数提供给 lambda 表达式，以便表达式体可以使用它来访问 `files` 数组的当前成员。
- en: The `totalFileSize` gets updated inside a call to `Interlocked.Add`. This is
    the most efficient way to safely add values in parallel code.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`totalFileSize` 在调用 `Interlocked.Add` 时更新。这是在并行代码中安全地添加值的最高效方式。'
- en: There isn’t a simple way to leverage `Interlocked` to update the `lastWriteTime`
    DateTime value. So, instead, we are using a `lock` block with a `dateLock` object
    to safely read and set the `lastWriteTime` method-level variable.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有一种简单的方法可以利用 `Interlocked` 来更新 `lastWriteTime` DateTime 值。因此，我们使用一个带有 `dateLock`
    对象的 `lock` 块来安全地读取和设置方法级别的 `lastWriteTime` 变量。
- en: 'Next, open the designer for `Form1.cs` and add the following controls to the
    form:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `Form1.cs` 的设计器，并将以下控件添加到窗体中：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: View the `Form1.designer.cs` file on this chapter’s GitHub repository ([https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp))
    to review and set all of the properties for these controls.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章 GitHub 仓库中查看 `Form1.designer.cs` 文件 ([https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp))
    以审查和设置这些控件的所有属性。
- en: 'When you are finished, the form’s designer should look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，窗体的设计器应该看起来像这样：
- en: '![Figure 6.1 – The completed Form1.cs designer view in Visual Studio ](img/Figure_6.1_B18552.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – Visual Studio 中完成的 Form1.cs 设计视图](img/Figure_6.1_B18552.jpg)'
- en: Figure 6.1 – The completed Form1.cs designer view in Visual Studio
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Visual Studio 中完成的 Form1.cs 设计视图
- en: 'Next, double-click the `Form1` designer, and a `FolderBrowserButton_Click`
    event handler will be generated in the code-behind file. Add the following code
    to use the `folderToProcessDialog` object to show a folder picker dialog to the
    user:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，双击 `Form1` 设计器，代码背后将生成一个 `FolderBrowserButton_Click` 事件处理程序。将以下代码添加到使用 `folderToProcessDialog`
    对象向用户显示文件夹选择对话框的代码中：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The selected folder path will be set in `FolderToProcessTextBox` for use in
    the next step. The user can alternatively manually type or paste a folder path
    in the field. If you would like to prevent manual entry, you can set `FolderToProcessTextBox.ReadOnly`
    to `true`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的文件夹路径将设置在 `FolderToProcessTextBox` 中，用于下一步。用户可以手动输入或粘贴文件夹路径到字段中。如果您想防止手动输入，可以将
    `FolderToProcessTextBox.ReadOnly` 设置为 `true`。
- en: 'Next, double-click the `FolderProcessButton_Click` event handler will be generated
    in the code behind. Add the following code to call `FileProcessor` and display
    the results in `FolderResultsTextBox`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，双击代码背后的 `FolderProcessButton_Click` 事件处理程序将生成。将以下代码添加到调用 `FileProcessor`
    并在 `FolderResultsTextBox` 中显示结果的代码中：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code here is straightforward enough. The static `GetInfoForFiles` method
    returns a `FileData` instance with the file information. We’re using `StringBuilder`
    to create the output to be set in `FolderResultsTextBox`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码足够简单。静态 `GetInfoForFiles` 方法返回一个包含文件信息的 `FileData` 实例。我们使用 `StringBuilder`
    创建要设置在 `FolderResultsTextBox` 中的输出。
- en: 'We’re ready to run the application. Start debugging the project in Visual Studio
    and give it a try. Your results should look something like this:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好运行应用程序。在 Visual Studio 中开始调试项目并尝试一下。你的结果应该看起来像这样：
- en: '![Figure 6.2 – Running the Parallel Loops application ](img/Figure_6.2_B18552.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 运行并行循环应用程序](img/Figure_6.2_B18552.jpg)'
- en: Figure 6.2 – Running the Parallel Loops application
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 运行并行循环应用程序
- en: That’s all there is to it. If you want to try something more advanced, you can
    try modifying the project to also process files in all subfolders of the selected
    folder. Let’s make a different change to the project so we can reduce the locking
    calls to `Interlocked.Add`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。如果你想尝试更高级的功能，你可以尝试修改项目以处理所选文件夹的所有子文件夹中的文件。让我们对项目进行不同的修改，以便减少对 `Interlocked.Add`
    的锁定调用。
- en: Parallel loops with thread-local variables
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有线程局部变量的并行循环
- en: 'The `Parallel.For` construct has an overload that will allow our code to keep
    a running subtotal of the total file size for each thread participating in the
    loop. What that means is that we will only need to use `Interlocked.Add` when
    aggregating the subtotal from each thread to `totalFileSize`. This is accomplished
    by providing a `Interlocked.Add` will only be called 5 times instead of 200 times
    without losing any thread safety:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.For` 构造函数有一个重载版本，将允许我们的代码为每个参与循环的线程保持总文件大小的运行小计。这意味着我们只有在从每个线程聚合小计到
    `totalFileSize` 时才需要使用 `Interlocked.Add`。这是通过提供 `Interlocked.Add` 只会调用 5 次而不是
    200 次来实现的，而不会丢失任何线程安全性：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To summarize the preceding changes, you will notice we are using the `Parallel.For<long>`
    generic method to indicate that the `subtotal` thread-local variable should be
    `long` instead of `int` (the default type). The size is added to `subtotal` in
    the first lambda expression without any locking expression. We now have to return
    `subtotal`, so the other iterations have access to the data. Finally, we have
    added a final parameter to `For` with a lambda expression that adds each thread’s
    `runningTotal` to `totalFileSize` using `Interlocked.Add`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的更改，你会注意到我们正在使用 `Parallel.For<long>` 泛型方法来指示 `subtotal` 线程局部变量应该是 `long`
    而不是默认的 `int` 类型。大小在第一个 lambda 表达式中添加到 `subtotal`，而不需要任何锁定表达式。我们现在必须返回 `subtotal`，以便其他迭代可以访问数据。最后，我们向
    `For` 添加了一个最终参数，该参数包含一个 lambda 表达式，该表达式使用 `Interlocked.Add` 将每个线程的 `runningTotal`
    添加到 `totalFileSize`。
- en: If you update `FolderProcessButton_Click` to call `GetInfoForFilesThreadLocal`,
    the output will be the same, but the performance will be improved, perhaps not
    noticeably. The performance improvement depends on the number of files in your
    selected folder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `FolderProcessButton_Click` 更改为调用 `GetInfoForFilesThreadLocal`，输出将相同，但性能将得到提升，可能不是很明显。性能提升取决于你选择的文件夹中的文件数量。
- en: Now that we have tried a couple of exercises with the `Parallel.For` loop, let’s
    create a sample using the `Parallel.ForEach` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试了几个 `Parallel.For` 循环的练习，让我们创建一个使用 `Parallel.ForEach` 方法的示例。
- en: Simple Parallel.ForEach loops
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的 Parallel.ForEach 循环
- en: 'The `Parallel.ForEach` methods, such as `Parallel.For`, are similar in use
    to their non-parallel counterpart. You would use `Parallel.ForEach` over `Parallel.For`
    when you have an `IEnumerable` collection to process. In this sample, we will
    create a new method that accepts a `List<string>` of image files to iterate and
    convert to `Bitmap` objects:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach` 方法，如 `Parallel.For`，在用法上与它们的非并行对应方法类似。当你有一个要处理的 `IEnumerable`
    集合时，你会使用 `Parallel.ForEach` 而不是 `Parallel.For`。在这个示例中，我们将创建一个新的方法，该方法接受一个包含图像文件的
    `List<string>` 列表以迭代并转换为 `Bitmap` 对象：'
- en: 'Start by creating a new private static method named `ConvertJpgToBitmap` in
    the `FileProcessor` class. This method will open each JPG file and return a new
    `Bitmap` containing the image data:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `FileProcessor` 类中创建一个新的私有静态方法，命名为 `ConvertJpgToBitmap`。此方法将打开每个 JPG 文件并返回一个包含图像数据的新
    `Bitmap`：
- en: '[PRE40]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, create a public static method in the same class named `ConvertFilesToBitmaps`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在同一个类中创建一个公共静态方法，命名为 `ConvertFilesToBitmaps`：
- en: '[PRE41]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method accepts `List<string>` containing the files in the selected folder.
    Inside the `Parallel.ForEach` loop, it checks whether the file has a `.jpg` or
    `.jpeg` file extension. If it does, it is converted to a bitmap and added to the
    `result` collection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受包含所选文件夹中文件的 `List<string>`。在 `Parallel.ForEach` 循环内部，它检查文件是否有 `.jpg` 或
    `.jpeg` 文件扩展名。如果有，它将转换为位图并添加到 `result` 集合中。
- en: Add a new button to `Form1.cs`. Set the `Name` property as `ProcessJpgsButton`
    and the `Text` property as `Process JPGs`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Form1.cs` 中添加一个新按钮。将 `Name` 属性设置为 `ProcessJpgsButton`，将 `Text` 属性设置为 `Process
    JPGs`。
- en: 'Double-click the new button to create an event handler in the code-behind file.
    Add the following code to the new event handler:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新按钮以在代码隐藏文件中创建事件处理器。将以下代码添加到新的事件处理器中：
- en: '[PRE42]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, run the project, select a folder containing some JPG files, and click the
    new **Process JPGs** button. You should see the height of each converted JPG listed
    in the output.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目，选择包含一些 JPG 文件的文件夹，并点击新的 **处理 JPGs** 按钮。你应该会在输出中看到每个转换后的 JPG 的高度。
- en: That’s all you need for a simple `Parallel.ForEach` loop. What can you do if
    you need to cancel a long-running parallel loop? Let’s update our example to do
    just that with `Parallel.ForEachAsync`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是简单的 `Parallel.ForEach` 循环所需的所有内容。如果你需要取消一个长时间运行的并行循环，你能做什么？让我们更新我们的示例，使用
    `Parallel.ForEachAsync` 来实现这一点。
- en: Cancel a Parallel.ForEachAsync loop
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消 Parallel.ForEachAsync 循环
- en: '`Parallel.ForEachAsync` is new in .NET 6\. It is an awaitable version of `Parallel.ForEach`
    with an `async` lambda expression as its body. Let’s update the previous example
    to use this new parallel method and add the ability to cancel the operation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEachAsync` 是 .NET 6 中的新特性。它是 `Parallel.ForEach` 的可等待版本，其主体是一个
    `async` lambda 表达式。让我们更新之前的示例，使用这个新的并行方法，并添加取消操作的能力：'
- en: 'We are going to start by making an `async` copy of `ConvertFilesToBitmaps`
    named `ConvertFilesToBitmapsAsync`. The differences are highlighted in the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个 `async` 版本的 `ConvertFilesToBitmaps`，命名为 `ConvertFilesToBitmapsAsync`。以下是其差异：
- en: '[PRE43]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The new method is `async`, returns `Task<List<Bitmap>>`, accepts `CancellationTokenSource`,
    and uses that when creating `ParallelOptions` to pass to the `Parallel.ForEachAsync`
    method. `Parallel.ForEachAsync` is awaited and its lambda expression is declared
    as `async` so we can await the new `Task.Delay` that has been added to give us
    enough time to click the **Cancel** button before the loop completes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法是 `async`，返回 `Task<List<Bitmap>>`，接受 `CancellationTokenSource`，并在创建 `ParallelOptions`
    时使用它传递给 `Parallel.ForEachAsync` 方法。`Parallel.ForEachAsync` 被等待，其 lambda 表达式被声明为
    `async`，这样我们就可以等待新添加的 `Task.Delay`，给我们足够的时间在循环完成前点击 **取消** 按钮。
- en: Enclosing `Parallel.ForEachAsync` in a `try`/`catch` block that handles `OperationCanceledException`
    enables the method to catch the cancellation. We’ll show a message to the user
    after the cancellation is handled.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Parallel.ForEachAsync` 包裹在处理 `OperationCanceledException` 的 `try`/`catch`
    块中，使得方法能够捕获取消操作。在取消操作被处理后，我们将向用户显示一条消息。
- en: The code is also setting the `ProcessorCount` option. If there is only one CPU
    core available, we will set the value to `1`; otherwise, we want to use no more
    than the number of available cores minus one. The .NET runtime typically manages
    this value very well, so you should only change this option if you find it improves
    your application’s performance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还设置了 `ProcessorCount` 选项。如果只有一个 CPU 核心可用，我们将设置该值为 `1`；否则，我们希望使用的核心数不超过可用核心数减一。.NET
    运行时通常管理这个值非常好，所以你应该只有在发现它提高了应用程序的性能时才更改此选项。
- en: 'In the `Form1.cs` file, add a new `CancellationTokenSource` private variable:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Form1.cs` 文件中，添加一个新的 `CancellationTokenSource` 私有变量：
- en: '[PRE44]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Update the event handler to be `async`, set `_cts` to be a new instance of `CancellationTokenSource`,
    and pass it to `ConvertFilesToBitmapsAsync`. Add `await` to that call as well.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新事件处理程序为 `async`，将 `_cts` 设置为 `CancellationTokenSource` 的新实例，并将其传递给 `ConvertFilesToBitmapsAsync`。同样，在该调用中添加
    `await`。
- en: 'All of the necessary changes are highlighted in the following snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的所有更改都在以下代码片段中突出显示：
- en: '[PRE45]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Add a new button to the form named `CancelButton` with a caption of `Cancel`
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单中添加一个名为 `CancelButton` 的新按钮，其标题为 `取消`
- en: 'Double-click the **Cancel** button and add the following event handler code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 **取消** 按钮并添加以下事件处理程序代码：
- en: '[PRE46]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run the application, browse to and select a folder containing JPG files, click
    the **Process JPGs** button, and immediately click the **Cancel** button. You
    should receive a message indicating that processing has been canceled. No further
    records are processed.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，浏览并选择包含 JPG 文件的文件夹，点击 **处理 JPGs** 按钮，然后立即点击 **取消** 按钮。你应该会收到一条消息，表明处理已被取消。不会进一步处理记录。
- en: We will learn more about canceling asynchronous and parallel work in [*Chapter
    11*](B18552_11_ePub.xhtml#_idTextAnchor173). Now, let’s discuss the `Parallel.Invoke`
    construct and relationships between tasks in the TPL.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第11章*](B18552_11_ePub.xhtml#_idTextAnchor173) 中了解更多关于取消异步和并行工作的内容。现在，让我们讨论
    `Parallel.Invoke` 构造以及 TPL 中任务之间的关系。
- en: Relationships between parallel tasks
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行任务之间的关系
- en: In the previous chapter, [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082),
    we learned how to use `async` and `await` to perform work in parallel and manage
    the flow of tasks by using `ContinueWith`. In this section, we will examine some
    of the TPL features that can be leveraged to manage relationships between tasks
    running in parallel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，[*第 5 章*](B18552_05_ePub.xhtml#_idTextAnchor082)，我们学习了如何使用 `async` 和 `await`
    来并行执行工作，并通过使用 `ContinueWith` 来管理任务的流程。在本节中，我们将检查一些可以用来管理并行运行的任务之间关系的 TPL 功能。
- en: Let’s start by looking deeper into the `Parallel.Invoke` method provided by
    the TPL.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先深入探讨 TPL 提供的 `Parallel.Invoke` 方法。
- en: Under the covers of Parallel.Invoke
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `Parallel.Invoke` 的底层
- en: 'In [*Chapter 2*](B18552_02_ePub.xhtml#_idTextAnchor034), we learned how to
    use the `Parallel.Invoke` method to execute multiple tasks in parallel. We are
    going to revisit `Parallel.Invoke` now and discover what is happening under the
    covers. Consider using it to invoke two methods:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18552_02_ePub.xhtml#_idTextAnchor034)，我们学习了如何使用 `Parallel.Invoke`
    方法并行执行多个任务。现在我们将重新审视 `Parallel.Invoke`，并发现其底层发生了什么。考虑使用它来调用两个方法：
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is what is happening behind the scenes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是幕后发生的事情：
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Two tasks will be created and queued on the thread pool. Assuming the system
    has available resources, the two tasks should be picked up and run in parallel.
    The calling method will block the current thread, waiting for the parallel tasks
    to complete. The action will block the calling thread for the duration of the
    longest-running task.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建两个任务并将它们排队在线程池中。假设系统有可用资源，这两个任务应该被选中并并行运行。调用方法将阻塞当前线程，等待并行任务完成。动作将阻塞调用线程，直到最长运行的任务完成。
- en: 'If this is acceptable for your application, using `Parallel.Invoke` makes the
    code cleaner and easy to understand. However, if you don’t want to block the calling
    thread, there are a couple of options. First, let’s make a change to the second
    example to use `await`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对您的应用程序来说是可接受的，使用 `Parallel.Invoke` 可以使代码更简洁、更容易理解。然而，如果您不想阻塞调用线程，有几个选项。首先，让我们对第二个示例进行修改，使用
    `await`：
- en: '[PRE52]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'By awaiting `Task.WhenAll` instead of using `Task.WaitAll`, we’re allowing
    the current thread to do other work while waiting for the two child tasks to finish
    processing in parallel. To achieve the same result with `Parallel.Invoke`, we
    can wrap it in `Task`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过等待 `Task.WhenAll` 而不是使用 `Task.WaitAll`，我们允许当前线程在等待两个子任务并行完成处理的同时执行其他工作。要使用
    `Parallel.Invoke` 实现相同的结果，我们可以将其包装在 `Task` 中：
- en: '[PRE56]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The same technique can be used with `Parallel.For` to avoid blocking the calling
    thread while waiting for the loop to complete. This is not necessary for `Parallel.ForEach`.
    Instead of wrapping `Parallel.ForEach` in `Task`, we can replace it with `Parallel.ForEachAsync`.
    We learned earlier in this chapter that .NET 6 added `Parallel.ForEachAsync`,
    which returns `Task` and can be awaited.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术可以用 `Parallel.For` 来使用，以避免在等待循环完成时阻塞调用线程。对于 `Parallel.ForEach` 来说，这并不是必需的。我们不需要将
    `Parallel.ForEach` 包装在 `Task` 中，而是可以用 `Parallel.ForEachAsync` 来替换它。我们在本章前面了解到，.NET
    6 添加了 `Parallel.ForEachAsync`，它返回 `Task` 并可以等待。
- en: Next, let’s discuss how the relationship between parent tasks and their children
    can be managed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何管理父任务与其子任务之间的关系。
- en: Understanding parallel child tasks
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解并行子任务
- en: 'When executing nested tasks, by default, the parent task will not wait for
    its child tasks unless we use the `Wait()` method or `await` statements. However,
    this default behavior can be controlled with some options when using `Task.Factory.StartNew()`.
    To illustrate the available options, we are going to create a new sample project:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行嵌套任务时，默认情况下，父任务不会等待其子任务，除非我们使用 `Wait()` 方法或 `await` 语句。然而，在使用 `Task.Factory.StartNew()`
    时，我们可以通过一些选项来控制这种默认行为。为了说明可用的选项，我们将创建一个新的示例项目：
- en: First, create a new C# console application named `ParallelTaskRelationshipsSample`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 C# 控制台应用程序，命名为 `ParallelTaskRelationshipsSample`。
- en: Add a class to the project named `ParallelWork`. This is where we will create
    the parent methods and their children.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `ParallelWork` 的类。这是我们创建父方法和它们的子方法的地方。
- en: 'Add the three following methods to the `ParallelWork` class. These will be
    our child methods. Each one writes some console output when starting and completing.
    Delays are injected with `Thread.SpinWait`. If you are unfamiliar with `Thread.SpinWait`,
    it puts the current thread into a loop for the number of iterations specified,
    injecting a wait without removing the thread from consideration with the scheduler:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下三个方法添加到 `ParallelWork` 类中。这些将是我们的子方法。每个方法在启动和完成时都会写入一些控制台输出。使用 `Thread.SpinWait`
    注入延迟。如果你不熟悉 `Thread.SpinWait`，它将当前线程放入一个循环中，循环次数由指定的迭代数决定，注入等待而不将线程从调度程序中移除：
- en: '[PRE58]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, add a method named `DoAllWork`. This method will create a parent task
    that calls the preceding three methods with child tasks. There is no code added
    to wait for the child tasks:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `DoAllWork` 的方法。此方法将创建一个父任务，该任务调用前面的三个方法并带有子任务。没有添加代码来等待子任务：
- en: '[PRE59]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, add some code to run `DoAllWork` from `Program.cs`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Program.cs` 中添加一些代码来运行 `DoAllWork`：
- en: '[PRE60]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the program and examine the output. As you might expect, the parent task
    completes before its children:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并检查输出。正如你所预期的，父任务在它的子任务之前完成：
- en: '![Figure 6.3 – The console application runs DoAllWork ](img/Figure_6.3_B18552.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 控制台应用程序运行 DoAllWork](img/Figure_6.3_B18552.jpg)'
- en: Figure 6.3 – The console application runs DoAllWork
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 控制台应用程序运行 DoAllWork
- en: 'Next, let’s create a method named `DoAllWorkAttached`. This method will run
    the same three child tasks, but the child task will include the `TaskCreationOptions.AttachedToParent`
    option:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 `DoAllWorkAttached` 的方法。此方法将运行相同的三个子任务，但子任务将包含 `TaskCreationOptions.AttachedToParent`
    选项：
- en: '[PRE61]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Update `Program.cs` to call `DoAllWorkAttached` instead of `DoAllWork` and
    run the application again:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 更新为调用 `DoAllWorkAttached` 而不是 `DoAllWork` 并重新运行应用程序：
- en: '![Figure 6.4 – Running our application and calling DoAllWorkAttached ](img/Figure_6.4_B18552.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 运行我们的应用程序并调用 DoAllWorkAttached](img/Figure_6.4_B18552.jpg)'
- en: Figure 6.4 – Running our application and calling DoAllWorkAttached
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 运行我们的应用程序并调用 DoAllWorkAttached
- en: You can see that even though we are not explicitly waiting for the child tasks,
    the parent task does not complete until its children do.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，即使我们没有明确等待子任务，父任务也不会在它的子任务完成之前完成。
- en: 'Now, suppose you have another parent that should not wait for its child tasks,
    regardless of whether they are started with the `TaskCreationOptions.AttachedToParent`
    option. Let’s create a new method that can handle this scenario:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你还有一个父任务，它不应该等待其子任务，无论是否使用 `TaskCreationOptions.AttachedToParent` 选项启动。让我们创建一个新的方法来处理这种情况：
- en: 'Create a method named `DoAllWorkDenyAttach` with the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DoAllWorkDenyAttach` 的方法，以下是其代码：
- en: '[PRE62]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The child tasks are still being created with the `AttachedToParent` option,
    but the parent task now has a `DenyChildAttach` option set. This will supersede
    the child requests to attach to the parent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 子任务仍然使用 `AttachedToParent` 选项创建，但父任务现在设置了 `DenyChildAttach` 选项。这将覆盖子任务附加到父任务的要求。
- en: 'Update `Program.cs` to call `DoAllWorkDenyAttach` and run the application once
    more:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 更新为调用 `DoAllWorkDenyAttach` 并再次运行应用程序：
- en: '![Figure 6.5 – The console application calls DoAllWorkDenyAttach ](img/Figure_6.5_B18552.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 控制台应用程序调用 DoAllWorkDenyAttach](img/Figure_6.5_B18552.jpg)'
- en: Figure 6.5 – The console application calls DoAllWorkDenyAttach
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 控制台应用程序调用 DoAllWorkDenyAttach
- en: You can see that `DenyChildAttach` did override the `AttachToParent` option
    set on each child task. The parent completed without waiting for the children,
    as it did when calling `DoAllWork`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`DenyChildAttach` 确实覆盖了每个子任务上设置的 `AttachToParent` 选项。父任务在没有等待子任务的情况下完成，就像调用
    `DoAllWork` 时那样。
- en: One final note about this example. You may have noticed that we used `Task.Factory.StartNew`
    instead of `Task.Run`, even when we didn’t need to set `TaskCreationOption`. That
    is because `Task.Run` will prohibit any child tasks from attaching to a parent.
    If you used `Task.Run` for the parent task in the `DoAllWorkAttached` method,
    the parent would have completed first, as it did in the other methods.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个示例的最后一点。你可能已经注意到，我们使用了 `Task.Factory.StartNew` 而不是 `Task.Run`，即使我们不需要设置
    `TaskCreationOption`。这是因为 `Task.Run` 将禁止任何子任务附加到父任务。如果你在 `DoAllWorkAttached` 方法中使用
    `Task.Run` 作为父任务，父任务将首先完成，就像在其他方法中那样。
- en: Let’s finish up this chapter by covering some potential pitfalls when working
    with parallel programming in .NET.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过介绍一些在使用 .NET 进行并行编程时可能遇到的潜在陷阱来结束本章。
- en: Common pitfalls with parallelism
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行编程的常见陷阱
- en: When working with the TPL, there are some practices to avoid in order to ensure
    the best outcomes in your applications. In some cases, parallelism used incorrectly
    can result in performance degradation. In other cases, it can cause errors or
    data corruption.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 TPL 时，有一些做法要避免，以确保在您的应用程序中获得最佳结果。在某些情况下，错误使用并行性可能会导致性能下降。在其他情况下，它可能导致错误或数据损坏。
- en: Parallelism is not guaranteed
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行性不能保证
- en: When using one of the parallel loops or `Parallel.Invoke`, the iterations can
    run in parallel, but they are not guaranteed to do so. The code in these parallel
    delegates should be able to run successfully in either scenario.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用并行循环之一或 `Parallel.Invoke` 时，迭代可以并行运行，但并不保证一定会这样做。这些并行委托中的代码应该能够在任何场景下成功运行。
- en: Parallel loops are not always faster
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行循环并不总是更快
- en: We discussed this earlier in this chapter, but it is important to remember that
    parallel versions of `for` and `foreach` loops are not always faster. If each
    loop iteration runs quickly, the overhead of adding parallelism can slow down
    your application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章 earlier 讨论过这一点，但重要的是要记住，`for` 和 `foreach` 循环的并行版本并不总是更快。如果每个循环迭代运行得很快，添加并行的开销可能会减慢您的应用程序。
- en: This is important to remember when introducing any threading to applications.
    Always test your code before and after introducing concurrency or parallelism
    to ensure that the performance gains are worth the overhead of threading.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在向应用程序引入任何线程时，这一点非常重要。在引入并发或并行之前和之后始终测试您的代码，以确保性能提升值得线程开销。
- en: Beware of blocking the UI thread
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨防阻塞 UI 线程
- en: Remember that `Parallel.For` and `Parallel.ForEach` are *blocking calls*. If
    you use them on the UI thread, they will block the UI for the duration of the
    call. This blocking duration will be, at a minimum, the duration of the longest-running
    loop iteration.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Parallel.For` 和 `Parallel.ForEach` 是 *阻塞调用*。如果您在 UI 线程上使用它们，它们将阻塞 UI 直到调用结束。这个阻塞时间至少是运行时间最长的循环迭代的时间。
- en: As we discussed in the previous section, you can wrap the parallel code in a
    call to `Task.Run` to move the execution from the UI thread to a background thread
    on the thread pool.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的，您可以通过调用 `Task.Run` 来包装并行代码，将执行从 UI 线程移动到线程池上的后台线程。
- en: Thread safety
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: 'Do not make calls to .NET methods that are not thread-safe within parallel
    loops. The thread safety of each .NET type is documented on Microsoft Docs. Use
    the .NET API browser to quickly find information about specific .NET APIs: [https://docs.microsoft.com/dotnet/api/](https://docs.microsoft.com/dotnet/api/).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在并行循环中调用非线程安全的 .NET 方法。每个 .NET 类型的线程安全性在 Microsoft Docs 上有记录。使用 .NET API 浏览器快速查找有关特定
    .NET API 的信息：[https://docs.microsoft.com/dotnet/api/](https://docs.microsoft.com/dotnet/api/)。
- en: Limit the use of static .NET methods in parallel loops, even if they are marked
    as thread-safe. They will not cause errors or problems with data consistency,
    but they can negatively impact the loop performance. Even calls to `Console.WriteLine`
    should only be used for testing or demonstration purposes. Do not use these in
    production code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 限制在并行循环中使用静态 .NET 方法，即使它们被标记为线程安全。它们不会引起错误或数据一致性问题，但可能会对循环性能产生负面影响。即使是调用 `Console.WriteLine`
    也应仅用于测试或演示目的。不要在生产代码中使用这些方法。
- en: UI controls
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI 控件
- en: In Windows client applications, do not try to access UI controls within parallel
    loops. WinForms and WPF controls can only be accessed from the thread on which
    they were created. You can use `Dispatcher.Invoke` to invoke actions on other
    threads, but this will have performance implications. It is best to update the
    UI after your parallel loops have been completed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 客户端应用程序中，不要尝试在并行循环中访问 UI 控件。WinForms 和 WPF 控件只能从创建它们的线程访问。您可以使用 `Dispatcher.Invoke`
    在其他线程上调用操作，但这将产生性能影响。最好在并行循环完成后更新 UI。
- en: ThreadLocal data
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadLocal 数据
- en: Remember to take advantage of `ThreadLocal` variables in your parallel loops.
    We illustrated how to do this in the *Parallel loops with thread-local variables*
    section earlier in this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要在您的并行循环中利用 `ThreadLocal` 变量。我们在本章 earlier 的 *带有线程局部变量的并行循环* 部分展示了如何做到这一点。
- en: That covers your introduction to parallel programming with C# and .NET. Let’s
    wrap up by reviewing everything we have learned in the chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了您对 C# 和 .NET 并行编程的介绍。让我们通过回顾本章学到的所有内容来结束。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to leverage parallel programming concepts in
    our .NET applications. We got hands-on with `Parallel.For`, `Parallel.ForEach`,
    and `Parallel.ForEachAsync` loops. In those sections, we learned how to safely
    aggregate data while maintaining thread safety. Next, we learned how to manage
    relationships between parent tasks and their parallel children. This will help
    to ensure your applications maintain an expected order of operations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在.NET应用程序中利用并行编程概念。我们亲自动手使用了`Parallel.For`、`Parallel.ForEach`和`Parallel.ForEachAsync`循环。在这些部分，我们学习了如何在保持线程安全的同时安全地聚合数据。接下来，我们学习了如何管理父任务与其并行子任务之间的关系。这将有助于确保你的应用程序保持预期的操作顺序。
- en: Finally, we covered some important pitfalls to avoid when implementing parallelism
    in our applications. Developers will want to pay close attention to avoid any
    of these pitfalls in their own applications.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了在实现应用程序中的并行性时需要避免的一些重要陷阱。开发者应该注意避免在自己的应用程序中遇到这些陷阱。
- en: 'To read more about data parallelism in .NET, the *Data Parallelism* documentation
    on Microsoft Docs is a great place to start: [https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library](https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于.NET中数据并行的信息，Microsoft Docs上的*数据并行*文档是一个很好的起点：[https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library](https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library).
- en: In the next chapter, we will continue our exploration of the TPL by learning
    how to leverage the various building blocks included in the TPL Dataflow Library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索TPL，通过学习如何利用TPL数据流库中包含的各种构建块。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which parallel loop executes a delegate in parallel for a given number of iterations?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个并行循环在给定次数的迭代中并行执行一个委托？
- en: Which parallel loop is the awaitable version of `Parallel.ForEach`?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个并行循环是`Parallel.ForEach`的可等待版本？
- en: Which parallel method can execute two or more provided actions in parallel?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个并行方法可以并行执行两个或更多提供的行为？
- en: Which `Task.Factory.StartNew` option can attach a child task’s completion to
    its parent?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个`Task.Factory.StartNew`选项可以将子任务的完成附加到其父任务上？
- en: Which `Task.Factory.StartNew` option can be provided to a parent task to prevent
    any child tasks from attaching?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个`Task.Factory.StartNew`选项可以提供给父任务以防止任何子任务附加？
- en: Why should you never use `Task.Run` when using `TaskCreationOptions` to establish
    parent/child relationships?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在使用`TaskCreationOptions`建立父子关系时永远不应该使用`Task.Run`？
- en: Are parallel loops always faster than their traditional counterparts?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行循环是否总是比它们的传统对应物更快？
