- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Dynamic UIs with Razor Pages, MVC, and Blazor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has a complete UI framework to suit different types of approaches
    and applications that allow the use of page rendering strategies on both the client
    side and server side. In this chapter, we will learn about the options available
    in the ASP.NET Core UI framework, in addition to understanding how to define the
    best option for each scenario.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we will understand some important concepts and then continue with
    a practical approach so that we are able to exercise the concepts learned.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, we will initially understand what the ASP.NET Core UI framework
    is, learning about the different approaches to rendering applications both on
    the server, using Razor Pages and ASP.NET MVC, and rendering on the client, using
    JavaScript frameworks. Finally, we will understand the power of merging different
    technologies into a hybrid solution that uses the best of both the client and
    the server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the ASP.NET Core UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a UI server render model with Razor Pages and ASP.NET MVC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring UI client rendering with Blazor and JavaScript frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with hybrid solutions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all code examples and other materials used in this chapter in
    the following repository: [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the ASP.NET Core UI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic web-based applications have a flow that basically involves two distinct
    “worlds” the frontend and the backend. In general, the frontend deals with the
    mechanisms that are visualized and allow interaction between users and the various
    functionalities proposed by the solution. Therefore, a frontend is made up of
    buttons, texts, lists, menus, images, and other aspects that together form the
    UI. The backend is the representation of the mechanisms used to allow dynamism
    to the frontend, according to user interaction. We will discuss more about backend-related
    aspects in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044) .
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Each of the terms expressed in the previous paragraph works in different contexts.
    The *frontend* usually runs on the client, which translates into the user’s browser.
    *Client* is a generic term that can express other types of user interaction. But
    in this case, we will talk about the client as the browser of your choice. The
    *backend* runs on the server, whether in a data center or even a cloud provider
    such as Azure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Through user interactions in the UI, the user must communicate with the backend
    and subsequently be able to adapt to the server’s responses to deliver some type
    of response and interaction, again , to the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser basically uses three technologies: HTML, CSS, and JavaScript. HTML
    is static; that is, it is interpreted by the browser and then rendered in the
    form of a UI. CSS is responsible for making visual elements more attractive, defining
    colors, shadows, and formatting, among other design aspects. JavaScript is used
    to make static elements dynamic, and this includes, for example, making a call
    to a server, and depending on the result, modifying the user’s UI to adapt to
    the response of the processing carried out. JavaScript is responsible for increasing
    the ability of web-based applications to become dynamic and interactive. However,
    it can be complex to create and manipulate elements through JavaScript code and,
    in addition, to manage calls on the server. There are several excellent JavaScript
    frameworks available, such as Angular or React that allow you to develop richly
    dynamic UI solutions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to have knowledge of UI technologies; however, in addition,
    we can benefit from an integrated development model that allows us to work on
    both the UI and the backend in a rich way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has a complete UI framework to meet any UI requirement for web
    applications and is fully integrated with the .NET platform, using best practices
    for separation of responsibilities, management, and maintenance, among other important
    aspects. Despite this, ASP.NET Core is not restricted to the use of the UI renderers
    proposed by the platform; it also integrates well with JavaScript frameworks and
    even allows you to use the best of the available options by adopting a hybrid
    approach.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: However, before we move on to a more specific understanding of the options available
    in ASP.NET Core 9, let’s learn about important aspects related to web systems
    architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the UI
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different approaches to developing web-based solutions when it comes
    to the UI layer, even before talking about technologies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: There are basically two models, client-side and server-side, with their respective
    pros and cons. There is also a third possibility, which would be to use a hybrid
    approach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In the client-side model, processing is done locally in the browser. In this
    way, all the HTML, CSS, JavaScript, and other assets are processed by the browser,
    responding to user stimuli. Interactions with users are handled locally through
    scripts containing UI-related logic without the need to request the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach depends on server resources, such as access to data,
    among other things, and so it is necessary to make frequent calls to the server
    in order to obtain information based on the user’s needs, which is then processed
    and presented in the UI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side approach, all the processing is delegated to the server,
    which returns a customized HTML page ready to be rendered in the browser. The
    server processes all the necessary information, allows access to data, manages
    business logic, has the ability to abstract sensitive information using secrets,
    and delegates minimal processing to the client. However, if the server is not
    available, it will not be possible to use the system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In the hybrid approach, there is a combination of the best of “ both worlds.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: There are many JavaScript frameworks prepared to make web-based systems dynamic,
    providing a great user experience by processing resources on the client and, likewise,
    having the ability to interact with the server, delegating the processing of only
    relevant information to the UI rather than the entire processing of a page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, ASP.NET Core 9 is prepared for the development of web-based solutions
    in the different approaches mentioned. We’ll start to understand the first UI
    development model, using Razor Pages, in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a UI server render model with Razor Pages and ASP.NET MVC
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core 9 offers two powerful server-render models: Razor Pages and MVC.
    They are similar models, but MVC is more elaborate and implements the Model-View-Controller
    architectural design pattern—we’ll talk more about this in the *ASP.NET Core MVC*
    section. For now, let’s start learning about Razor Pages.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Razor Pages
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Razor Pages is a server-rendered framework that implements a page-based model.
    The page-based model basically contextualizes the implementation of a specific
    page, taking into account the UI and business logic, but correctly segregating
    responsibilities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Razor is a markup language that acts similarly to a template engine and combines
    its use with HTML and C# code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Razor’s origins
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Razor’s development began in June 2010, but it was only released in January
    2011 with MVC 3, as part of Microsoft Visual Studio 2010. Razor is a simple-syntax
    visualization engine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: This page-based development model brings great advantages, such as ease of creating
    and updating the UI; it’s testable, keeps UI and business logic separate, and
    although it has similarities to ASP.NET Core MVC, it’s simpler. Taking all these
    advantages into consideration, let’s create our first project using Razor Pages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first project with Razor Pages
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a Razor Pages project, you can use Visual Studio or the **dotnet**
    CLI tool.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Creation using Visual Studio is very simple; just open the IDE, select **Create
    a new project** , and then select the **ASP.NET Core Web App** template, as shown
    in *Figure 2* *.1* :'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Selecting a project template](img/B21788_02_1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Selecting a project template
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Both Visual Studio and the CLI tool work with the concept of templates. With
    the .NET platform, it is possible to develop different types of projects, whether
    for web, Windows, or mobile. Each template creates a basic project structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of the book, we will use the CLI tool to create projects,
    as well as other needs that we will discuss later. From now on, we will use the
    .NET CLI tool to create a Razor Pages project, as this tool offers us several
    benefits that we will discuss in the rest of the book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: When you install the .NET 9 SDK, a number of tools are available. The main tool
    we will use in this book is **dotnet** .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The **dotnet** CLI tool also has a concept of templates. To test this functionality,
    open your operating system’s Command Prompt and run the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After running the preceding command, the current version of the tool will be
    displayed. This time, still at the prompt, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After running the preceding command, you will see the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – dotnet CLI tool templates](img/B21788_02_2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – dotnet CLI tool templates
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in *Figure 2* *.2* , some templates and examples of use were
    listed. Each model has a set of parameters that are used to customize project
    creation. If you want to know more about the parameters of each template, just
    type the following command; for example, for the **webapp** template, you’d type
    this command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **-h** (help) parameter will provide a list of parameters and documentation
    for the desired template.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the installation on your machine, there may be other templates.
    Run the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see a list containing many types of project templates; we will focus
    on the projects highlighted in *Figure 2* *.3* :'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – All available project templates](img/B21788_02_3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – All available project templates
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve understood templates, let’s finally create a new Razor Pages
    project via the command line. To do this, open Command Prompt, create a new folder
    called **NewRazorPages** , and run the following command on this folder:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous command is composed of the **new** command, to create a new project,
    then **razor** , representing the short name of the desired template, and finally
    the **-n** parameter, which defines the name of the project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: After executing the command, a new folder containing the project will be created.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Command details
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Each of the commands available in the CLI tool can have a set of parameters.
    To find out more about these parameters, simply add the **-h** option after a
    command; for example, **dotnet** **new -h** .
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also consult the tool’s documentation at the following link: [https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the book, we will consider creating projects via the command
    line. Now, let’s go into more detail about the Razor Pages project we’ve created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Razor Pages project
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Razor Pages project has a very simple directory structure and configurations
    compared to ASP.NET Core MVC. However, many of the concepts used in this project
    serve as a basis for the MVC project, so we’ll take advantage of all the content.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2* *.4* shows the structure of the project created in the previous
    section and has been expanded to express each important item that we will discuss
    in more detail:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Razor Pages project structure](img/B21788_02_4.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Razor Pages project structure
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Razor Pages has a simple structure that can basically be divided into four
    important items:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '**wwwroot folder** : This folder contains the application’s static files, such
    as JavaScript, CSS, libraries, and images. By default, three subdirectories are
    configured, such as **css** , **js** , and **lib** , used to contain JavaScript
    files from external libraries, such as jQuery, among others. You can also create
    other directories to contain files such as images, fonts, and so on.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pages folder** : This folder contains the application’s pages, subdivided
    into a pair of files with the **cshtml** extension that contain the HTML code
    and C# code using Razor syntax, and **cshtml.cs** , which contains the C# code
    responsible for handling page events.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**appsettings.json** : This is a file in **JSON** format that is used to maintain
    application settings centrally, as well as database connection strings, API keys,
    and other parameters. We’ll talk more about settings in [*Chapter 9*](B21788_09.xhtml#_idTextAnchor146)
    .'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program.cs** : This is the most important file in the Razor Pages project,
    written in C# and containing all the execution settings for the entire application
    flow.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other details and configurations related to the project will be seen in
    the other chapters of the book as we add more features and concepts to the learning
    process. For now, it’s very important to understand some of the project’s premises.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the **Program.cs** file to understand some details:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following points explain the preceding code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the file creates an instance of an ASP.NET Core web application,
    using some standard configurations, such as adding middleware, between *lines
    9* and *13* , that acts on the application flow and convention configurations
    for generating routes, among other aspects provided by the framework itself.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the execution of the **builder.services.AddRazorPages** line,
    which is responsible for configuring the web application with the characteristics
    of the Razor Pages project. This project has dependencies on certain classes that
    are used by the platform when running the application.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between *lines 4* and *8* , there is a check related to the environment in which
    the application is running. This block ensures that if there are any errors not
    dealt with by the application, the user will be redirected to a generic error
    page, preventing details of the application from being exposed. The **app.UseHsts()**
    code aims to force communication via the **HTTP Strict Transport Security** (
    **HSTS** ) protocol to add security and the use of HTTPS.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 9* , we guarantee the use of the HTTPS protocol.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 10* is necessary for the Razor Pages application to take into account
    static files, localization, and the use of HTTPS.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to consider, at this point, that the code described in the **Program.cs**
    file will affect how the application will behave at runtime. We must also consider
    the order of each of the methods located in the file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Further details and configuration variations will be discussed later in the
    book. We are already familiar with the Razor Pages project structure, so let’s
    learn more about the syntax used in HTML pages and how to interact with C# code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Working with pages
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Razor acts as a powerful templating engine, allowing you to create pages using
    HTML, CSS, JavaScript, and C# code in the same file. This approach brings great
    flexibility in generating dynamic pages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of the **Index.html** page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first lines of code refer to page-related settings, and then we have the
    pure HTML code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the main components described in the file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The **@page** directive must be the first directive in a Razor page view. It
    indicates that the page will function as an action handler.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **@model** directive indicates which type of model will be passed to the
    page. Razor Pages has a set of two files that make up a page, **.cshtml** and
    **.cshtml.cs** .
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **ViewData["Title"]** code is a dictionary, which represents another way
    of passing data to pages. In general, **ViewData** is used to pass small amounts
    of data. In the case of the preceding code, **ViewData** is being used to pass
    information from the page title to the HTML template.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The first concerns HTML; as with the previous example, **.cshtml.cs** refers
    to the C# code of the page handler, which contains the model or information that
    will be used on the page. Thus, the **Index.cshtml** file has an association with
    the **index.cshtml.cs** file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have the **IndexModel** class that represents the
    model that will be used on the page:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we noted in the example, the **Index.cshtml** page does not have the entire
    structure of an HTML page. This is because Razor Pages allows the concept of Layout.
    That is, pages can often share a similar structure. This way, we can reuse the
    code to both generate common Layouts and create shared View blocks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project structure, Layouts are kept within the **Pages/Shared** folder.
    By convention, shared views start with an underscore. The **_Layout.cshtml** file
    has a common HTML structure and, in addition, a special directive, **@RenderBody()**
    :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The **RenderBody()** method specifies the location where views will be rendered
    after server processing. In the case of the **index.cshtml** page, all HTML will
    be rendered between the main tags, in the **_Layout.cshtml** file. Also, note
    the use of **ViewData["Title"]** , which will display the value set on a page,
    as done in the **index.cshtml** file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other special files that, by convention, should be located in
    the **Pages** folder:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**_ViewStart.cshtml** : This is a file that allows us to define code that must
    be executed before displaying each Views. In this case, this file has a code where
    it defines which Layout file will be used for Views.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**_ViewImports.cshtml** : This file is used to define the namespace and import
    features into the page, in a common way. This way, there is no need to declare
    namespaces and other features on each page.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the entire project structure and how Razor pages are
    managed in the project, let’s add some customizations to the **Index** page and
    the **IndexModel** model and learn how to use Razor syntax and interact with C#
    code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Razor syntax and C# model
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained previously, Razor pages have two files, one responsible for rendering
    the UI and the other responsible for containing the page’s business logic. Furthermore,
    there is the possibility of using C# code together with HTML, meaning that the
    page can be generated during processing time on the server, according to user
    interactions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make some changes to the **index.cshtml** file, adding some controls
    as shown in *Figure 2* *.5* :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Customizing the index.cshtml file using Razor syntax](img/B21788_02_5.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Customizing the index.cshtml file using Razor syntax
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **index.cshtml** file in Visual Studio or Visual Studio Code to make
    the changes and follow these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Between the **@{}** instance, add the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, change all the content between the **div** tags, which contain the page
    content, to the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code creates formatting for the **Price** property so that it
    is displayed in currency format. This formatting will take into account your browser’s
    regional settings. In the case of the example run in this book, the formatting
    will display the price in **en-US** culture format.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To ensure that the property is displayed in a specific format, a new property
    can be created:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This way, we can update the existing code for price display to the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, we can define the application culture globally, avoiding the need
    to create a new property. To make this change, add the following code to the **Program.cs**
    file below the **var app =** **builder.Build()** line:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about managing cultures in ASP.NET Core 9, see the following
    link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Some elements that use inline C# code have been added, in addition to some calls
    to the server code. At the moment, it is important to understand how Razor syntax
    can be used together with HTML. Let’s understand all the elements added to the
    UI and how they interact with C#.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The first snippet added on *line 5* , **string subtitle = "It's funny"** , is
    C# code, declaring a variable of type **string** .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Note that all the code is enclosed between **@{ and }** symbols, as per the
    example between *lines 3* and *6* of the **index.cshtml** file. This syntax allows
    the addition of a block of code capable of containing C# and HTML instructions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Combining C# and HTML code and a block
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a C# code block, it is also possible to add HTML tags. Using this strategy
    brings great advantages, such as determining what type of HTML tag will be rendered,
    according to an **if** statement, as in the following example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**@{**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**if (total >** **0)**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**<h1>The available amount** **is: @total</h1>**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**<h2>There is no** **amount available</h2>**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the code block, the use of the **@** symbol allows the addition
    of C# code in one line, as in the example of the preceding code, which will display
    the value of the **Message** property of the **Model** object and display the
    value of the **subtitle** variable, previously defined:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Razor Pages provides directives, which are features added to HTML tags. The
    following code adds two anchors to the page:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that there are two attributes, **asp-page-handler** and **asp-route-id**
    . These are directive Razor pages, which determine, respectively, the name of
    the event handler when the link is clicked and the value that will be sent as
    a parameter to the handler.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the **div** style has the **@Model.Color** code, inserted as
    the value of the **background-color** property. The color of the **div** tag will
    be set dynamically, according to the link.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the controls created on the page, we have a purely HTML form
    and a table that lists randomly generated products. The form does not have the
    **action** attribute, used to determine the page or script that will process the
    posting of data. This attribute was omitted because Razor Pages follows a convention,
    which in this case is to infer the action to the form page itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates the rows and columns of the product table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is a mix of HTML and C# code. After executing the **foreach**
    statement, the columns and rows of the product table are defined. Products are
    generated in the **Products** property of the **Model** object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Remember to separate responsibilities
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it is possible to add any C# code to an HTML page using Razor
    Pages. However, use this approach to manipulate UI elements, but it is important
    to separate responsibilities correctly, avoiding multiple implementations of business
    rules together with UI manipulation rules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: All the elements we need at this point have been added, and we now know how
    to add C# code to manipulate our UI. Let’s finalize the **Index** page, adding
    the necessary code for its operation in the **index.cshtml.cs** file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Working with the page model
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the previously created UI to work correctly, we must add some properties
    and methods to the page model. Open the **index.cshtml.cs** file so that we can
    add the necessary functionality.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The **Index** page model is, in fact, a C# class that has an inheritance from
    the **PageModel** class, which is an abstraction of several properties and methods
    used by models in Razor Pages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make changes to the **IndexModel** class and understand each piece of
    code added:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a **Message** property to the **Index.cshtml.cs** file. It will be used
    to define a message that will be displayed in the UI:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the project root, create a folder named **Models** and then add a class
    called **Product.cs** . This class must have the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Go back to the **Index.cshtml.cs** file and add a **Products** property that
    will contain a list of objects that will be listed in the table created in the
    UI previously:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, add a **Color** property:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The basic properties have been created. Now, let’s create a method that randomly
    generates a list of products. Add the **GenerateProduct** method as per the following
    code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will change the class constructor and add default values for the **Products**
    and **Message** properties. This way, as soon as the page is displayed, we will
    have a randomly generated list of products and an **I’m using the Razor** **Syntax**
    message:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The method that generates the products is being used in the constructor to
    generate an initial listing. However, we want to interact through the UI and generate
    a list based on a value that will be entered in the form. To do this, we will
    create an **OnPost** method. This method generates a new list, based on the quantity
    entered in the UI form:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, let’s define a last method that will be responsible for setting the
    value of the **Color** property:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our model is ready to interact with the UI. But before running the application,
    let’s understand a simple concept of Razor Pages convention.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The **OnPost** method has this name, following a convention, and is related
    to the **GET** , **POST** , **DELETE** , and **PUT** HTTP verbs. This way, by
    defining methods such as **OnGet** , **OnPost** , **OnDelete** , and **OnPut**
    , they will be able to handle page events, according to the HTTP verb. The **Index**
    page UI has a form with the **POST** method. Therefore, when clicking on the **Load
    Products** button, Razor Pages will automatically call the **OnPost** method on
    the **IndexModel** model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The **OnGetDefineColor** method has this name to follow the convention, but
    there is no obligation to use the **OnGet** prefix in the method name. In HTML,
    we do not define the link handler as **OnGetDefineColor** ; this is because, by
    convention, Razor Pages will infer the prefix from the method name, and also because
    a **GET** request is performed. But if you wish to provide your full name, there
    will be no problem. The **OnGetDefineColor** method has another important characteristic:
    its **id** parameter. The **id** parameter receives the value defined in the directive
    added in the HTML link, as shown in the following code example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This action is called binding, which means that when passing the **id** parameter,
    Razor Pages sets the values of the method arguments according to the name of each
    parameter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Directive tip
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters in the previously defined HTML link is done using the **asp-route**
    directive together with the name of the parameter expected in the method—in this
    case, **id** . This way, the complete directive is defined by **asp-route-id**
    . If there were another argument called **name** , for example, the directive
    would be **asp-route-name** .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the entire implementation of the **Index** page, run the application
    and interact with the controls created previously.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to use Razor Pages to create dynamic pages using
    the server-side approach. With each interaction with the controls created on the
    **Index** page, a call will be made to the server, which will manipulate the information,
    interpret the Razor page code implemented in the UI, and later return an HTML
    output with the result.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: This approach is quite similar to ASP.NET Core MVC, which we will learn about
    in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core MVC
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core MVC is also a very powerful server-side framework that implements
    the MVC design pattern. Let’s understand how the MVC design pattern works and
    then learn how to benefit from this approach by creating a new project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: MVC pattern
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MVC is an architectural design pattern that works on the separation of responsibilities
    or context:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – MVC pattern](img/B21788_02_6.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – MVC pattern
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 2* *.6* , the **Controller** acts as an orchestrator,
    responding to user interactions through the **View** , and delegating actions
    to the **Model** , which represents the application state and business rules.
    Subsequently, the Controller returns the result, defining which View will be responsible
    for displaying the UI to the end user.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The View and the Controller have a dependency on the Model, but the Model is
    agnostic, allowing the separation of responsibilities and the use of good code
    practices, such as the use of unit tests, as there is independence from the visual
    presentation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core MVC is based on the MVC pattern, adapting the project model and
    conventions. Let’s understand how this pattern is implemented in this type of
    project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.NET Core MVC project structure
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating the ASP.NET Core MVC project is very simple, and we use the CLI tool,
    in addition to Visual Studio Code as an editor.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the next instructions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Open your operating system’s Command Prompt and access a directory of your choice
    where the project will be created.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command to create the project:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding command uses the **dotnet** CLI tool, where we specify the action
    of creating a new project through the **new** command. Then, we define which type
    of project will be created. In this case, we inform that the template will be
    **mvc** , and a **--name** parameter has been added, whereby we inform the name
    of the project.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A folder will be created with the name of the application. Access this folder
    and then open Visual Studio Code by running the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding command will open up the following:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.7 – ASP.NET MVC project structure](img/B21788_02_7.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – ASP.NET MVC project structure
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the structure of the MVC project created, we will notice a similarity
    with Razor Pages.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main project folders:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Views** : It has the same characteristics as the **Pages** folder in Razor
    Pages; that is, it is the application’s UI. It has **.cshtml** files, and these
    are organized into subfolders that represent a page and contain all the UIs that
    can be used as responses to actions. However, there are no **.** **cshtml.cs**
    files.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller** : The controller has a similar role to the class defined in
    the Razor Pages **.cshtml.cs** file. As mentioned, it is an orchestrator that
    has methods to manipulate events executed in Views. In MVC, each controller method
    is called **actions** and can return Views, redirections, or even data.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Models** : This folder is used to manage the business classes and models
    that will be used to exchange information between Views and HTML.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure follows a convention, which, in a way, facilitates development
    in this approach. However, the platform allows us to make customizations if necessary.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The MVC project also presents a small difference in the settings defined in
    the **program.cs** file in relation to Razor Pages. Before executing the **app.Run()**
    line, there is a call to the **app.MapControllerRoute** method. This method is
    responsible for configuring all of the application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Routes define what will be accessed and how it should be accessed through application
    requests.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, a default route is configured, called **default**
    , which has the **controller** / **action** / **parameter** pattern. Furthermore,
    the controller and action have a default value, **Home** and **Index** , respectively,
    while the parameter is optional:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a standard MVC convention and can be easily changed. In this model,
    if access to the application does not have a definition of the controller and
    which action should be executed, then the default controller, **Home** , and the
    **Index** action will be defined as the response to the request.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that we are referring to Controllers and not pages.
    This is because the MVC pattern allows the Controller to orchestrate the request,
    according to the desired action, and then return a result or a View.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through the chapters of the book, we will have other examples
    of using routes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Understanding patterns and conventions
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MVC project follows a convention that benefits the file structure presented
    previously.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: As we learned, the Controller acts as an orchestrator between the Model and
    the View. This way, instead of using a concept of pages, there is the idea of
    actions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the user’s intention or interaction, it triggers an action. This action
    is captured by a Controller, which then performs the processing and returns either
    a value or a View, as shown in *Figure 2* *.8* :'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – MVC request flow](img/B21788_02_8.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – MVC request flow
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The **Controller** class is a C# class, which has attributes and methods. The
    **Controller** class’s public methods are called actions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a registry of people. We would then have the following class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The **PersonController** class follows the name convention, adopting the **Controller**
    suffix at the end of the class name. Furthermore, this class has an inheritance
    from the **Controller** class, which is a base class that already has some utility
    methods responsible for processing and returning data and information through
    the controller.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a method called **Index** , which just returns a View, executing
    the **return** **View()** command.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Which View is returned?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The **View()** method takes into account the Asp.NET Core MVC convention. So,
    when executed, the view that is instantiated considers the following path: **/Views/<ControllerName>/Action.cshtml**
    . This means that in the case of the **PersonController** class, calling the **Index**
    method will return a View: **Views/Person/Index.cshtml** .'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The **View()** method has other overloads, making it possible to pass an object
    that will be used as a Model into the View or even define a Controller View that
    should be displayed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The **GetPeople()** method just returns a list of people in JSON format, as
    shown in *Figure 2* *.9* :'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – JSON with a list of people](img/B21788_02_9.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – JSON with a list of people
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Register()** method processes the form request and returns an object
    to the **Result** View. However, in this case, it is making the call to an action
    from the **PersonController** controller, executing the **RedirectToAction** method,
    called **Result** , which expects a string as a parameter. *Figure 2* *.10* demonstrates
    the display of the action result after registering a person:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Register Person view](img/B21788_02_10.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Register Person view
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Base Controller class
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The abstract **Controller** class has some utility methods that allow you to
    work on the communication flow between the Controller and the View.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The **Json()** , **View()** , and **RedirectToAction()** methods are some of
    the resources that are commonly used in a controller class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The MVC model and Razor Pages have similarities, but a big difference is the
    use of actions instead of pages. In this way, the controller has the ability to
    decide what type of View or information should be returned, in relation to some
    user interaction, orchestrating the processing flow.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The Controller responds to user events, and the View is an important aspect
    of this type of project. Based on the **PersonController** example, we will understand
    how the View was created and learn how the interaction with the Controller’s actions
    works in the next section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Working with Views on ASP.NET MVC
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The concept of Views in ASP.NET MVC is the same as that used in Razor Pages,
    using the Razor syntax. As we can see in the following code, there is a form tag,
    using Razor directives, defining which Controller and action will process the
    registration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding file was created in the **Views/Person/Index.cshtml** directory
    structure. Following the convention, for the **PersonController** controller,
    there must be a **Person** folder, a subfolder of Views, which will contain all
    the Views that will be displayed through the **PersonController** controller.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The view index is a good practice
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to have an **Index.cshtml** file and an **Index()** action
    in each controller. Following the route pattern, defined in the **Program.cs**
    file, by default, when an action is not specified, an **Index()** action will
    be executed. In this case, having a View and Action Index will avoid usability
    problems in your application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: To create the labels and inputs used in the form, **tag helpers** were used.
    Tag helpers are Razor Pages methods that basically render HTML. The difference,
    in the preceding code presented, is that there is a connection with the Model.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the **Index.csthml** page, a Model was defined, using the
    **@model MyFirstMVCApp.Models.PersonModel** code. This makes the Model strongly
    typed. By using a tag helper, together with a Lambda expression, we are implementing
    good practice in relation to the MVC binding model.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the HTML generated by tag helpers for the form will have the correct
    names in relation to the model properties, following the flow outlined next:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The data is the name and date of birth informed in the inputs.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user clicks the **Register** button.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework makes a request to the **Result** action.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework identifies that the **Result** action has a **PersonModel**
    object as a parameter and then creates an instance.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework binds the data posted by the form and sets the values
    in the corresponding properties of the instantiated object.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework executes the **Result** action.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the bind is done through property names, if any name is typed incorrectly,
    some properties will not have a value.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The use of the tag helpers approach also helps in other aspects such as attributes
    added to the **Model** class that allow validations, among other aspects. We will
    discuss more about attributes and bind during *Chapters 3* and *5* .
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern provides us with several benefits, especially in more complex
    projects where there is a need to control different business flows and return
    dynamic Views according to the need.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: There are other approaches to working with UIs in ASP.NET Core 9. Let’s learn
    a little more about other options, such as using Blazor and integrations with
    JavaScript frameworks, in the next section.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Exploring UI client rendering with Blazor and JavaScript frameworks
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has several frameworks that provide the creation of UIs with
    high quality and good user experience, using client-side and server-side approaches.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the newest technology that uses the **WebAssembly** standard,
    called Blazor, which is a powerful and flexible UI framework. However, if you
    are used to JavaScript frameworks, you can also benefit from the . NET platform.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Rich UIs with Blazor
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as with Razor Pages and MVC, Blazor offers a **single-page application**
    ( **SPA** ) framework on the .NET platform, running both client-side and server-side,
    using all the power of C#.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The client-server version of Blazor runs on the WebAssembly platform, which
    is a compact bytecode with an optimized format, fast to download, and provides
    great performance when running on the client side, creating rich UI experiences.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 2* *.11* , Blazor is an abstraction of ASP.NET Core
    for WebAssembly. This way, the Blazor code will generate application assemblies,
    which require the .NET runtime for execution, also allowing interaction between
    WebAssembly and the HTML document.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly is a web standard, and you can learn more about it at the official
    website: [https://webassembly.org/](https://webassembly.org/)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – WebAssembly and Blazor](img/B21788_02_11.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – WebAssembly and Blazor
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly platform uses an interoperability model, which allows it to
    interact with all browser APIs, running in a sandbox, providing security against
    malicious actions, and also allowing the execution of . NET code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: All page code developed is compiled into .NET assemblies. Thus, when accessing
    the page through the browser, both the assemblies and the .NET runtime are downloaded.
    Then, with the support of WebAssembly, the application runs and uses JavaScript
    interop to handle **DOM** ( **Document Object Model** ) manipulation and browser
    API calls.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is a flexible framework that also allows you to create projects with
    the benefits of server-side processing, offering an excellent client-side experience.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blazor also allows for a server-side UI rendering approach. However, unlike
    what happens with Razor Pages and MVC, instead of rendering the entire HTML for
    each client request and returning a complete document as a response, Blazor creates
    a graph, which represents the page components, considering properties and state.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Then, with each interaction, Blazor performs an evaluation of the graph and
    produces a binary representation, which is sent back to the client.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Blazor’s server-side approach uses **SignalR** technology, which allows you
    to update the UI through a direct connection to the server, bringing better usability
    and a rich user experience. We will cover SignalR in [*Chapter 4*](B21788_04.xhtml#_idTextAnchor061)
    .
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server brings great benefits in the development of web-based solutions,
    with C# as a common language, bringing security, reliability, and performance.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the development approach using Blazor.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Blazor components and structure
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as with some JavaScript frameworks, such as Angular, Blazor works with
    a component structure.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: A component is one or more UI elements developed with a specific objective,
    according to the needs of the application. This component can be reused throughout
    the application, enabling separation of responsibilities, reusability, and flexibility.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: All Blazor components have the **.razor** extension and use both the Razor syntax
    and all the benefits of C#.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Blazor project, simply use the **dotnet** CLI, with the following
    command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Interactivity Render Mode
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 introduces the render interactive mode on Blazor Apps. The interactive
    render mode feature enhances the way Blazor apps handle rendering, introducing
    a mode where the server-rendered static HTML is progressively enhanced into a
    fully interactive client-side application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of this feature are:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Progressive Enhancement: When a Blazor app is initially loaded, the server
    pre-renders the HTML, providing a fully functional page for users to interact
    with immediately. This allows the app to seamlessly transition from this static
    HTML to a fully interactive Blazor app once the Blazor framework is loaded on
    the client side.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Seamless Transition: ensures the app appears interactive even while the client-side
    Blazor runtime is being initialized and users can start interacting with the app
    before the complete Blazor runtime is ready, making the user experience smoother.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Improved Performance: optimizes the time-to-interactivity by reducing the noticeable
    delay that users might experience in traditional Blazor Server or Blazor WebAssembly
    apps.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhanced User Experience: minimizes interruptions or loading indicators during
    transitions, giving users a better perception of speed.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a Blazor app using the command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet new blazor --** **name MyFirstBlazorApp**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The default interactive mode is Server. In case you want to leverage the new
    feature, use the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet new blazor --name MyFirstBlazorApp --** **interactivity Auto**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about this new feature, access the following URL: [https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the project, just open the **Pages** folder, and you will then
    find some components as shown in *Figure 2* *.12* :'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – The Blazor project structure](img/B21788_02_12.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – The Blazor project structure
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: There are components that are defined as pages and therefore have the **@pages**
    directive, where a route to access the page is defined. There are also components
    that are added to pages.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Counter.razor** file is a page component and has the following content:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that there is use of Razor and HTML syntax, as we learned in the Razor
    Pages and MVC approaches. There is also C# code between the **@code {}** tags.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The C# code defined in the preceding file has the functionality to increment
    a counter when the user clicks on the **Click** **me** button.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The HTML button tag has the **@onclick** attribute, which is defined with the
    name defined in the C# code block.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: For simple components, the approach of using HTML and C# code in the same file
    may be valid. However, it is good practice to separate business rules from the
    UI. Therefore, Blazor allows a file to be created containing the component’s C#
    code.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code example, there would be two files: **Counter.razor**
    and **Counter.razor.cs** . All C# code could be moved to the new file generating
    the following class:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Blazor is very flexible and offers a huge range of possibilities for developing
    rich web-based applications, integrated with HTML, CSS, and JavaScript and using
    the most modern technologies. It would take an exclusive book to talk about Blazor,
    however; this book will focus on approaches based on Razor Pages and MVC.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 is very flexible when it comes to developing UIs, featuring different
    frameworks. But if you are familiar with Angular, React, or Vue.js, you can benefit
    from the power of the . NET platform.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 and JavaScript frameworks
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned during the other topics in this chapter, ASP.NET Core 9 offers
    several approaches to building a UI, interacting with C# code. There are several
    related benefits, including the use of a common development model, using the Razor
    syntax, and all the benefits of the . NET platform.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you are used to using a framework for building SPAs, such as Angular,
    Vue.js, and React, the .NET platform has some templates available for this purpose:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template](img/B21788_02_13.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The **React and ASP.NET Core** template creates two projects, one for the frontend
    and the other for the application’s backend.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: SPAs use the approach where the UI is developed independently of the backend,
    which is generally an external service or application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the model offered by ASP.NET Core, there is also a clear separation
    between the UI and the backend. The project is already configured for integration
    with the web API developed in .NET. One of the great benefits of this is the convenience
    of publishing the UI and backend project in a single simple unit, facilitating
    publication:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – ASP.NET Core React standalone project structure](img/B21788_02_14.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – ASP.NET Core React standalone project structure
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Using project templates for frameworks such as Angular, Vue.js, or React is
    completely optional. Even if the UI project is created independently, we can benefit
    from ASP.NET Core by developing web APIs to serve the UI. We’ll talk about creating
    web APIs in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044) .
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the platform offers several approaches for developing high-quality
    web-based systems. Each ASP.NET Core UI framework has several benefits that can
    be combined to generate even more powerful solutions, and we will look at these
    solutions in the next section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Working with hybrid solutions
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great benefits of working on a powerful platform such as ASP.NET
    Core is having the ability to integrate between technologies. Therefore, we can
    combine all the power of Razor Pages, MVC, and Blazor in the same project.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In the case of integration with Blazor, there is the benefit of using **.razor**
    components, providing reusability.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor integration into Razor Pages or MVC projects must be configured according
    to the following steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project root, add a file named **_Imports.razor** . This file will be
    responsible for importing the namespaces necessary for the project:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that at the end of the file, there is a **{CHANGE_FOR_THE_NAMESPACE_OF_YOUR_PROJECT}**
    tag. Change this value to your project namespace.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it will be necessary to change the **_Layout.cshtml** file, located in
    **Pages/Shared** directory in the case of the Razor Pages project or in the **Views/Shared**
    directory for MVC projects. Add the following code in the head element:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The purpose of defining **<base href="~/"/>** is to define the base path of
    the application, while the **component** tag is used to render the contents of
    the Razor components in the HTML head element.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following script before the **@await RenderSection(...)** render section:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Don’t worry about the script path, much less creating it. This will be done
    automatically by the framework.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open the **Program.cs** file to make some modifications. First, we must
    register the Blazor services so that they are available while the application
    is running. Add the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You also need to add the Blazor route mapping control. Add the following line
    below the **MapRazorPages** call (in the case of a Razor Pages project) or the
    **MapControllerRoute** call (in the case of an MVC project):'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that the project is integrated with Blazor, let’s create a component with
    the following steps:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called **technology.razor** in the **Pages/Shared** (Razor Pages)
    or **Views/Shared** (MVC) folder and add the following code:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code creates a **Load** button with a click event that will load
    a list of technologies. This list of technologies was created in the **@code{}**
    session, using an array of strings. When running the application, the screen will
    be similar to *Figure 2* *.15* :'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Page/View using the Blazor component](img/B21788_02_15.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Page/View using the Blazor component
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this component, add the following code to any MVC Razor page or View:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When running the application, simply use the component to obtain the expected
    result, as shown in *Figure 2* *.16* . This component is reusable and can be added
    to any page or view, bringing greater flexibility and power to UI development:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Using a Blazor component with Razor Pages and MVC](img/B21788_02_16.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Using a Blazor component with Razor Pages and MVC
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Combining ASP.NET Core UI frameworks can bring benefits during the web-based
    application development process, using the best of each approach.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ve delved into the rich world of the ASP.NET Core UI, gaining
    valuable insights into the available tools for crafting dynamic and engaging UIs.
    You’ve not only understood the key concepts and tools required for implementing
    a server-side UI, but you’ve also discovered the remarkable benefits of WebAssembly
    through Blazor, enabling you to create powerful SPAs in conjunction with ASP.NET
    Core. As you wrap up this chapter, you’ve learned how to seamlessly combine ASP.NET
    Core UI solutions. Now, with a solid foundation in place, I invite you to embark
    on the next exciting journey in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044)
    , where we’ll explore the world of web APIs and their pivotal role in delivering
    outstanding services. Get ready to take your skills to the next level!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经深入探索了ASP.NET Core UI的丰富世界，获得了关于构建动态和吸引人的UI可用工具的宝贵见解。你不仅理解了实现服务器端UI所需的关键概念和工具，而且还发现了通过Blazor使用WebAssembly带来的显著好处，使你能够与ASP.NET
    Core结合创建强大的单页应用（SPAs）。随着本章的结束，你已经学会了如何无缝结合ASP.NET Core UI解决方案。现在，在打下坚实基础之后，我邀请你开始下一章的激动人心的旅程[*第3章*](B21788_03.xhtml#_idTextAnchor044)，我们将探讨Web
    API的世界及其在提供卓越服务中的关键作用。准备好将你的技能提升到下一个层次！
