<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor061"/>4</h1>
<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/>Dependency Injection in a Minimal API Project</h1>
<p>In this chapter of the book, we will discuss some basic topics of minimal APIs in .NET 6.0. We will learn how they differ from the controller-based Web APIs that we were used to using in the previous version of .NET. We will also try to underline the pros and the cons of this new approach of writing APIs.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>What is dependency injection?</li>
<li>Implementing dependency injection in a minimal API project</li>
</ul>
<h1 id="_idParaDest-62"><a id="_idTextAnchor063"/>Technical requirements</h1>
<p>To follow the explanations in this chapter, you will need to create an ASP.NET Core 6.0 Web API application. You can refer the Technical requirements section of <a href="B17902_02.xhtml#_idTextAnchor023"><em class="italic">Chapter 2</em></a><em class="italic">, Exploring Minimal APIs and Their Advantages</em> to know how to do it.</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter04">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/>What is dependency injection?</h1>
<p>For a while, .NET has <a id="_idIndexMarker202"/>natively supported the <strong class="bold">dependency injection</strong> (often referred to as <strong class="bold">DI</strong>) software design pattern.</p>
<p>Dependency injection is a way to implement in .NET the <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) pattern between service classes and their dependencies. By the way, in .NET, many fundamental services are built with dependency injection, such as logging, configuration, and other services.</p>
<p>Let’s look at a practical example to get a good understanding of how it works.</p>
<p>Generally speaking, a dependency is an object that depends on another object. In the following example, we have a <code>LogWriter</code> class with only one method inside, called <code>Log</code>:</p>
<pre class="source-code">
public class LogWriter
{
    public void Log(string message)
    {
        Console.WriteLine($"LogWriter.Write
          (message: \"{message}\")");
    }
}</pre>
<p>Other classes in the project, or in another project, can create an instance of the <code>LogWriter</code> class and use the <code>Log</code> method.</p>
<p>Take a look at the following example:</p>
<pre class="source-code">
public class Worker
{
    private readonly LogWriter _logWriter = new LogWriter();
    protected async Task ExecuteAsync(CancellationToken 
                                      stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logWriter.Log($"Worker running at: 
             {DateTimeOffset.Now}");
             await Task.Delay(1000, stoppingToken);
        }
    }
}</pre>
<p>This class depends<a id="_idIndexMarker203"/> directly on the <code>LogWriter</code> class, and it’s hardcoded in each class of your projects.</p>
<p>This means that you will have some issues if you want to change the <code>Log</code> method; for instance, you will have to replace the implementation in each class of your solution.</p>
<p>The preceding implementation has some issues if you want to implement unit tests in your solution. It’s not easy to create a mock of the <code>LogWriter</code> class.</p>
<p>Dependency injection can solve these problems with some changes in our code:</p>
<ol>
<li>Use an interface to abstract the dependency.</li>
<li>Register the dependency injection in the built-in service connecte to .NET.</li>
<li>Inject the service into the constructor of the class.</li>
</ol>
<p>The preceding things might seem like they require big change in your code, but they are very easy to implement.</p>
<p>Let’s see how we can achieve this goal with our previous example:</p>
<ol>
<li value="1">First, we will create an <code>ILogWriter</code> interface with the abstraction of our logger:<pre>public interface ILogWriter
{
    void Log(string message);
}</pre></li>
<li>Next, implement this <code>ILogWriter</code> interface in a real class called <code>ConsoleLogWriter</code>:<pre>public class ConsoleLogWriter : ILogWriter
{
    public void Log(string message)
    {
        Console.WriteLine($"ConsoleLogWriter.
        Write(message: \"{message}\")");
    }
}</pre></li>
<li>Now, change<a id="_idIndexMarker204"/> the <code>Worker</code> class and replace the explicit <code>LogWriter</code> class with the new <code>ILogWriter</code> interface:<pre>public class Worker
{
    private readonly ILogWriter _logWriter;
    public Worker(ILogWriter logWriter)
    {
        _logWriter = logWriter;
    }
    protected async Task ExecuteAsync
      (CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logWriter.Log($"Worker running at: 
                             {DateTimeOffset.Now}");
             await Task.Delay(1000, stoppingToken);
        }
    }
}</pre></li>
</ol>
<p>As you can<a id="_idIndexMarker205"/> see, it’s very easy to work in this new way, and the advantages are substantial. Here are a few advantages of dependency injection:</p>
<ul>
<li>Maintainability</li>
<li>Testability</li>
<li>Reusability</li>
</ul>
<p>Now we need to perform the last step, that is, register the dependency when the application starts up.</p>
<ol>
<li value="4">At the top of the <code>Program.cs</code> file, add this line of code:<pre>builder.Services.AddScoped&lt;ILogWriter, ConsoleLogWriter&gt;();</pre></li>
</ol>
<p>In the next section, we will discuss the difference between dependency injection lifetimes, another concept that you need to understand before using dependency injection in your minimal API project.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Understanding dependency injection lifetimes</h2>
<p>In the previous<a id="_idIndexMarker206"/> section, we learned the benefits of using dependency injection in our project and how to transform our code to use it.</p>
<p>In one of the last paragraphs, we added our class as a service to <code>ServiceCollection</code> of .NET.</p>
<p>In this section, we will try to understand the difference between each dependency injection’s lifetime.</p>
<p>The service lifetime defines how long an object will be alive after it has been created by the container.</p>
<p>When they are registered, dependencies require a lifetime definition. This defines the conditions when a new service instance is created.</p>
<p>In the following list, you can find the lifetimes defined in .NET:</p>
<ul>
<li><strong class="bold">Transient</strong>: A new instance of the class is created every time it is requested.</li>
<li><strong class="bold">Scoped</strong>: A new instance of the class is created once per scope, for instance, for the same HTTP request.</li>
<li><strong class="bold">Singleton</strong>: A new instance of the class is created only on the first request. The next request will use the same instance of the same class.</li>
</ul>
<p>Very often, in web applications, you only find the first two lifetimes, that is, transient and scoped.</p>
<p>If you have a particular use case that requires a singleton, it’s not prohibited, but for best practice, it is recommended to avoid them in web applications.</p>
<p>In the first two cases, transient and scoped, the services are disposed of at the end of the request.</p>
<p>In the next section, we will see how to implement all the concepts that we have mentioned in the last two sections (the definition of dependency injection and its lifetime) in a short demo that you can use as a starting point for your next project.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/>Implementing dependency injection in a minimal API project</h1>
<p>After<a id="_idIndexMarker207"/> understanding<a id="_idIndexMarker208"/> how to use dependency injection in an ASP.NET Core project, let’s try to understand how to use dependency injection in our minimal API project, starting with the default project using the <code>WeatherForecast</code> endpoint.</p>
<p>This is the actual code of the <code>WeatherForecast</code> GET endpoint:</p>
<pre class="source-code">
app.MapGet("/weatherforecast", () =&gt;
{
    var forecast = Enumerable.Range(1, 5).Select(index =&gt;
    new WeatherForecast
    (
        DateTime.Now.AddDays(index),
        Random.Shared.Next(-20, 55),
        summaries[Random.Shared.
        Next(summaries.Length)]
    ))
    .ToArray();
    return forecast;
});</pre>
<p>As we mentioned before, this code works but it’s not easy to test it, especially the creation of the new values of the weather.</p>
<p>The best choice is to use a service to create fake values and use it with dependency injection.</p>
<p>Let’s see how we can better implement our code:</p>
<ol>
<li value="1">First of all, in the <code>Program.cs</code> file, add a new interface called <code>IWeatherForecastService</code> and define a method that returns an array of the <code>WeatherForecast</code> entity:<pre>public interface IWeatherForecastService
{
           WeatherForecast[] GetForecast();
}</pre></li>
<li>The next step<a id="_idIndexMarker209"/> is to create<a id="_idIndexMarker210"/> the real implementation of the class inherited from the interface.</li>
</ol>
<p>The code should look like this:</p>
<pre>public class WeatherForecastService : IWeatherForecastService
{
}</pre>
<ol>
<li value="3">Now cut and paste the code from the project template inside our new implementation of the service. The final code looks like this:<pre>public class WeatherForecastService : IWeatherForecastService
{
    public WeatherForecast[] GetForecast()
    {
        var summaries = new[]
        {
            "Freezing", "Bracing", "Chilly", "Cool", 
            "Mild", "Warm", "Balmy", "Hot", "Sweltering", 
            "Scorching"
        };
        var forecast = Enumerable.Range(1, 5).
        Select(index =&gt;
        new WeatherForecast
        (
            DateTime.Now.AddDays(index),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next
            (summaries.Length)]
        ))
        .ToArray();
        return forecast;
    }
}</pre></li>
<li>We<a id="_idIndexMarker211"/> are<a id="_idIndexMarker212"/> now ready to add our implementation of <code>WeatherForecastService</code> as a dependency injection in our project. To do that, insert the following line below the first line of code in the <code>Program.cs</code> file:<pre>builder.Services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre></li>
</ol>
<p>When the application starts, insert our service into the services collection. Our work is not finished yet.</p>
<p>We need to use our service in the default <code>MapGet</code> implementation of the <code>WeatherForecast</code> endpoint.</p>
<p>The minimal API has his own parameter binding implementation and it’s very easy to use.</p>
<p>First of all, to implement our service with dependency injection, we need to remove all the old code from the endpoint.</p>
<p>The code of the endpoint, after removing the code, looks like this:</p>
<pre class="source-code">
app.MapGet("/weatherforecast", () =&gt;
{
});</pre>
<p>We can improve our code and use the dependency injection very easily by simply replacing the old code with the new code:</p>
<pre class="source-code">
app.MapGet("/weatherforecast", (IWeatherForecastService weatherForecastService) =&gt;
{
    return weatherForecastService.GetForecast();
});</pre>
<p>In the <a id="_idIndexMarker213"/>minimal <a id="_idIndexMarker214"/>API project, the real implementations of the services in the service collection are passed as parameters to the functions and you can use them directly.</p>
<p>From time to time, you may have to use a service from the dependency injection directly in the main function during the startup phase. In this case, you must retrieve the instance of the implementation directly from the services collection, as shown in the following code snippet:</p>
<pre class="source-code">
using (var scope = app.Services.CreateScope())
{
    var service = scope.ServiceProvider.GetRequiredService
                  &lt;IWeatherForecastService&gt;();
    service.GetForecast();
}</pre>
<p>In this section, we have implemented dependency injection in a minimal API project, starting from the default template.</p>
<p>We reused the <a id="_idIndexMarker215"/>existing code<a id="_idIndexMarker216"/> but implemented it with logic that’s more geared toward an architecture that’s better suited to being maintained and tested in the future.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/>Summary</h1>
<p>Dependency injection is a very important approach to implement in modern applications. In this chapter, we learned what dependency injection is and discussed its fundamentals. Then, we saw how to use dependency injection in a minimal API project.</p>
<p>In the next chapter, we will focus on another important layer of modern applications and discuss how to implement a logging strategy in a minimal API project.</p>
</div>
</div></body></html>