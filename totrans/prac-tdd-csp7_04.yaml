- en: What to Know Before Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You're off to a pretty good start. By now, you should be starting to feel comfortable
    with the basic concepts behind Test-Driven Development. You know the basic premise
    behind TDD and how to write a unit test in C# and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover more of the practices behind TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific advice will be given on how to avoid pitfalls along the way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll explain the importance of defining and testing boundaries, abstracting
    away third-party code (including the .NET Framework)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll begin to introduce more advanced concepts, such as spies, mocks, and fakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's cover some issues you may run into while trying to test an existing
    application. Hopefully, this will help you avoid problems in your next green-field
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Untestable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of telltale signs that an application, class, or method
    will be difficult, or even impossible, to test. Sure, there are ways around some
    of the following examples but it's usually best to just avoid workarounds and
    programmatic acrobatics. Simple is usually best, and your future self and/or future
    maintainers will thank you for keeping things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're creating instances of external resources within your constructors
    or inside methods instead of having them passed in, it will be very difficult
    to write tests to cover these classes and methods. Generally, in today's modern
    applications, Dependency Injection frameworks are used to create and provide the
    external dependencies to a class. Many choose to define an *interface* as the
    contract for the dependency, providing a more flexible method for testing and
    the coupling to external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Static
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have a need to access static third-party classes or methods. Instead
    of accessing static resources directly, it would be better to access these through
    an *interface*. In the example of `DateTime` in C#, `Now` is a static property,
    which prevents you from being able to control the `DateTime` value used by the
    class or method being tested. This makes it more difficult to verify your test
    cases and ensure your program's logic is behaving correctly, based on specific
    dates or times.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Singletons* are the essence of the shared state. In order to ensure your tests
    run in an isolated environment, it would be best to avoid them. If a *singleton*
    is required (for example, `Logging`, `Data Context`, and so on), most Dependency
    Injection frameworks allow for the substitution of a non-singleton class as a
    single instance, which gives the functionality and flexibility of effectively
    having a singleton. For production code, this allows you to control the scope
    of the singleton instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Global state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has long been understood that global state within an application will wreak
    havoc on a system and cause unexpected behavior that is difficult to trace. Changing
    the code in one place will possibly have far-reaching side-effects on the rest
    of your system. For testability, this often means much more effort in setup and
    slower test execution.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting third-party software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your application grows, you'll likely introduce external dependencies. Assuredly,
    the developers of these systems, applications, and libraries have thoroughly tested
    their offerings. You should focus your attention on testing your application,
    not on testing third-party code. Your application should be robust enough to handle
    edge cases, and you'll want to account for expected and unexpected behavior. You'll
    want to abstract away the details of the third-party code and test for expected
    (and unexpected) results.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is *third-party code*? Anything you didn't write. That includes the
    .NET Framework itself. One way to achieve the abstraction of third-party code
    is with the use of test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Test doubles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test doubles are functions and classes that aid in the testing process by allowing
    you to either verify functionality or bypass a dependency that would otherwise
    be difficult to test. Test doubles are used at all levels to isolate the code
    being tested. Many times, the need for a test double drives the architecture of
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: The `DateTime` object in C# is an example of when this is the case. `System.DateTime`
    is part of the .NET Framework, and normally you wouldn’t think that you would
    abstract this in your code. The instinct of most developers is to simply reference
    it in a *using statement* and then access `DateTime.Now` directly within their
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A test that can't be repeated is a bad test.
  prefs: []
  type: TYPE_NORMAL
- en: This is usually difficult to test. If we were to try to test a method using
    `DateTime.Now`, we would be unable to prevent `DateTime.Now` default functionality.
    `DateTime.Now` returns the current date and time stored in a `DateTime` object.
    Not having the ability to manipulate the return of this object causes our tests
    to be unpredictable and unrepeatable. A test that can't be repeated is a bad test.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers already understand the need for predictability. You may have
    heard the phrase, *If it can't be reproduced, it's not a bug* or a similar sentiment.
    This is because, in order to verify that we have fixed a bug, we must be able
    to predictably repeat the error. This way, once the steps to reproduce it no longer
    produce the bug, we can confidently say that the bug is fixed. At least we can
    for that series of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is no different from bug fixing; it follows all the same steps. We just
    know exactly what caused the bug; the code hasn't been written yet, or the refactoring
    we just attempted failed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating test doubles can get a little involved at times. For this reason, frameworks
    to support the creation of these test doubles have been created for nearly every
    language that has a testing framework. The frameworks are generally referred to
    as mocking frameworks or libraries. In C#, the predominant framework currently
    in use is *Moq*, pronounced *mock*. Similarly, in JavaScript, the most referenced
    mocking library seems to be *Sinon*, pronounced *sign on*.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking frameworks are a great utility to alleviate some of the pressure of
    testing in a large project. They are especially useful when trying to wrap tests
    around a legacy system. A legacy system, in this case, is defined as an application
    that does not already have tests around it. This definition is from Michael Feather's
    book, *Working Effectively with Legacy Code*.
  prefs: []
  type: TYPE_NORMAL
- en: Use caution while learning Test-Driven Development and using mocking frameworks.
    Mocking frameworks provide a very attractive alternative to carefully considering
    your code. It is possible to write a complete set of tests that, in the end, only
    really test the mocking framework.
  prefs: []
  type: TYPE_NORMAL
- en: Many mocking frameworks are overpowered in this respect. In C#, a classification
    of mocking frameworks exists that allows you to replace external code. This external
    code includes `DateTime.Now` and any other class that you don’t control. In JavaScript,
    this is called monkey patching, and every framework allows you to do it.
  prefs: []
  type: TYPE_NORMAL
- en: What's the harm, you ask? One of the benefits of TDD is that it encourages smart
    architectural choices. When you have the power to override the functionality of
    the third-party code, you no longer have the need to abstract in order to test.
  prefs: []
  type: TYPE_NORMAL
- en: Why is that a problem? Abstraction of the third-party is necessary if we want
    to keep the code flexible and if we want to follow the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SOLID principles are a collection of concepts originally put together by
    Robert C. Martin, aka "Uncle Bob." Usually advertised as *Object-Oriented Principles*,
    you should think of them as just plain good architectural choices. The SOLID principles
    consist of five principles: the Single Responsibility Principle, the Open/Closed
    principle, the Liskov Substitution principle, the Interface Segregation Principle,
    and the Dependency Inversion Principle.'
  prefs: []
  type: TYPE_NORMAL
- en: The original articles on the SOLID principles are available at [http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Uncle Bob's article, the **Single Responsibility Principle** (**SRP**) is
    defined as, "A class should have only one reason to change."
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean? That is the tough part; there are many approaches to understanding
    the meaning. One way to look at it is that the class should only support one business
    user. Another is that, within the application, the class should only be used with
    a limited or specific scope. Another is that the class should have a limited range
    of functionality. These are all correct, and yet insufficient. One way to ensure
    you are following it is to use what we will refer to as the "Rule of Three to
    Five."
  prefs: []
  type: TYPE_NORMAL
- en: If we're discussing requirements, for example, when a requirement has between
    three to five acceptance criteria, then it is most likely appropriately sized
    for its level of detail. Similarly, if we are discussing a method or function,
    then three to five lines of code is probably appropriately sized.
  prefs: []
  type: TYPE_NORMAL
- en: The Rule of Three to Five is a generic way to know that you are honoring the
    SRP. The rule states, "Less than three is good. Between three and five is fine.
    Above five is strongly consider refactoring." It's not quite as elegant as many
    other laws, principles, and rules, but the rule of three to five is easy to follow.
    This rule is just a guideline and should not be used as an ultimatum. You should
    try to apply this rule to just about everything in software development. You have
    already seen it in action in this book. This rule was used to determine the scope
    of the requirements in [Chapter 1](part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195),
    *Why TDD is Important*, and in all the code samples that have been included so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the Rule of Three to Five, it nearly guarantees that you are following
    SRP, and it keeps your code, file structure, and requirements small and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: The Open/Closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Open/Closed principle states, "Software entities (classes, modules, functions,
    and so on) should be open for extension, but closed for modification." The second
    of the SOLID principles doesn't sound like it is saying much, but it has a large
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to honor this principle. You or your development team could
    put into place a rule that only allows for new development. That is, any existing
    functionality cannot be updated or changed, only replaced by new methods or classes.
    When we get to creating dividing lines in the code, you could use those dividing
    lines to create a place for this functionality swap to take place.
  prefs: []
  type: TYPE_NORMAL
- en: The Open/Closed principle also enables continuous integration and deployment.
    This is because, if your application never breaks a contract it has with the user,
    itself, or a third party, then it can always be deployed without fear of causing
    a production issue.
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov Substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Liskov Substitution principle may be difficult to understand at first due
    to its somewhat complex and mathematical definition. From Barbara Liskov''s *Data
    Abstraction and Hierarchy* [[https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf](https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf)],
    the principle is stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is wanted here is something like the following substitution property.
    If for each object o1 of type S there is an object o2 of type T, such that for
    all programs P defined in terms of T, the behavior of P is unchanged when o1 is
    substituted for o2, then S is a subtype of T.*'
  prefs: []
  type: TYPE_NORMAL
- en: Uncle Bob has simplified this definition to be, *Functions that use pointers
    or references to base classes must be able to use objects of derived classes without
    knowing it.* Looking at this principle, it seems like it would just be inheritance.
    Except, it's not just inheritance. This principle implies that not only does the
    object replacing the other have to implement the same interface or contract as
    the original, it must also adhere to the same expectations as the original.
  prefs: []
  type: TYPE_NORMAL
- en: The classic example of a violation of this principle is the use of a square
    class in the place of a rectangle class. A typical rectangle class would need
    to have both length and width properties. In mathematics, a square is just a special
    type of rectangle. So, many would assume that creating a square class with length
    and width would be an acceptable swap for the rectangle class.
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that a square requires that both length and width have the
    same value. So, when you change either one on the square class, the class will
    update the other to have the same value. This is a problem because the application
    using the object doesn't expect this behavior. Therefore, the application must
    be aware of the possibility of the length or width changing without notice.
  prefs: []
  type: TYPE_NORMAL
- en: A failure to meet the expectations of the application is known as a refused
    bequest. A refused bequest can cause inconsistent behavior in an application and,
    at the very least, requires more code to compensate for the mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: The Interface Segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Interface Segregation principle is about keeping to the contract of interaction
    presented by your class small. More than small, the contract presented by your
    class should have a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, having a class with a small single responsibility contract is difficult
    or not desired. In those instances, the class should implement multiple contracts
    instead of creating a combined contract. We want multiple contracts to reduce
    the number of far-reaching dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a base class or interface is modified, the child classes must also
    be modified. At the very least, the child classes must now be recompiled. By limiting
    the scope of a contract, we can reduce the impact of changing that contract and
    improve the overall system architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inversion of dependencies is important for several reasons, among which are
    that inverted dependencies increase flexibility, decrease fragility, and help
    the code to be potentially reused.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of dependencies allows for a plugin type architecture. By defining
    a contract of interaction, a module can determine how it wants to interact with
    dependencies. Then the dependencies depend on that contract.
  prefs: []
  type: TYPE_NORMAL
- en: Because the top-level module has no outgoing dependencies, it can be deployed
    independently. Deploying a piece of an application independently almost never
    happens, but having an independently deployable library has the tremendous benefit
    of not needing to be recompiled when a dependency changes.
  prefs: []
  type: TYPE_NORMAL
- en: In normal development, the dependencies fluctuate a lot more than the higher-level
    modules. This fluctuation causes the need to recompile. When your application
    dependencies flow downward, a dependency recompile also triggers a recompile of
    the dependent library. So, in effect, changing a utility helper class in a tiny,
    but common, library will trigger a recompile of your entire application.
  prefs: []
  type: TYPE_NORMAL
- en: If you are inverting your dependencies, however, a change like this will only
    trigger a recompile of the utility helper library and the application library.
    It will not trigger a recompile of every library between.
  prefs: []
  type: TYPE_NORMAL
- en: That does it for the SOLID principles. Please keep them in mind if you choose
    to use a mocking framework. Make sure you don't allow the mocking framework to
    trick you into building a rigid, fragile, immobile system.
  prefs: []
  type: TYPE_NORMAL
- en: Timely greeting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expanding on the classic *Hello World* example, what if you wanted to change
    your greeting based on the time of day? An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You might think to yourself, This is simple; I can just write a quick method
    to return the proper message. Of course, you would be right. This is a pretty
    easy task. You might come up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember, back in [Chapter 1](part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195),
    *Why TDD is Important*, we discussed the Three laws of TDD. The all-important
    first law states that you aren't allowed to write a single line of production
    code without a failing test.
  prefs: []
  type: TYPE_NORMAL
- en: Fragile tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"But, this is such a simple method," you might say. What if you encountered
    a bug? What if you wanted to write some tests for this method after the fact?
    Would you have to run your test suite at a specific time of day to ensure a passing
    test? Would you have to alter your tests based on the time of day that you ran
    them?'
  prefs: []
  type: TYPE_NORMAL
- en: False positives and false failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we left the code in our *Message* example as-is and wrote a test to cover
    the method, it might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the problem with this test? There's nothing inherently wrong with
    the test, per se. The problem is that the production code will return a different
    message, based on the time of day. This means that if you ran the test in the
    afternoon, it would pass. If you ran the test in the morning, it would fail.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract DateTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DateTime` is part of the .NET Framework, and therefore, it should be abstracted
    away from our system. Typically, we want our system to depend on interfaces, allowing
    us to substitute implementations at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of `ITimeManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For testing purposes, you might end up with an implementation of `ITimeManager`
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to set the value for `Now` so that we can supply a known value
    to our test methods. Now, let''s revisit our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our production code would end up looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Test double types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test doubles come in many varieties. Those varieties can generally be grouped
    as dummies, stubs, spies, mocks, and fakes. Coming up, we will discuss the different
    types and provide examples in C# and in JavaScript for each.
  prefs: []
  type: TYPE_NORMAL
- en: Dummies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dummies are the simplest form of test double. A dummy has no appreciable functionality.
    We don't actually expect the `dummy` class or method to be used in the result
    of the class or method we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: Dummies are most often used when the class you are testing has a dependency
    that the method or function you are testing does not use.
  prefs: []
  type: TYPE_NORMAL
- en: You create a dummy by creating a new copy or instance of a class or method and
    then doing absolutely nothing in the body of the code. Void methods will be empty
    and methods or functions expecting a return value will either throw when called
    or return the simplest form of that return value.
  prefs: []
  type: TYPE_NORMAL
- en: Dummy logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *Logging* service is a perfect example of something that can be replaced with
    a dummy. While you are testing specific methods it is unlikely (and not recommended)
    to also test logging functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Example in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `DummyLogger` in C#. You'll note that when `Log`
    is called nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `DummyLogger` in JavaScript. You'll note that
    when `info`, `warn`, `error`, and `success` are called nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stubs are the next level up from dummies. A Stub test double will provide the
    same response regardless of the parameters passed into it.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs are used when you want to test different paths of execution in your code.
    One instance is an error that must be thrown under a particular condition.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs are created by creating a copy or override of the class or method that
    needs to return the stub value and then setting it to return the needed value.
    Remember, stubs don't evaluate parameters, so you need to just return the desired
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Example in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `StubSpeakerContactServiceError` in C#. You'll
    note that, when `MessageSpeaker` is called then a new `UnableToContactSpeakerException`
    error is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `stubSpeakerReducer` in JavaScript. You'll
    note that regardless of the action passed in, a new `*UNABLE_TO_RETRIEVE_SPEAKERS*`
    error is pushed to the error array in the state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spies are the next evolution in test doubles. A spy returns a value similar
    to a stub but has an extremely important and helpful difference. Spies can report
    back on the information related to the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Spies are most often used when you want to verify that a function was called
    with specific parameters. This is most useful at third-party boundaries in your
    application. For instance, it is important to know whether your application is
    correctly configuring a database connection using the credentials supplied by
    some configuration service. Also, in some cases, it is difficult to measure the
    side-effects of the method or function being tested. In those cases, you can use
    a spy to just make sure you are calling the method or function in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Spies are created by starting with a stub and adding the functionality to determine
    whether a function has been called, how many times a function is called, or reporting
    what values were passed into that function.
  prefs: []
  type: TYPE_NORMAL
- en: Example in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `SpySpeakerContactService` in C#. The `SpySpeakerContactService` allows
    you to determine if the service has been called and how many times it might have
    been called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Example in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `spySpeakerReducer` in JavaScript. The `spySpeakerReducer`
    allows you to determine how many times it might have been called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocks are essentially programmable spies. Mocks are useful when you want to
    use the same test double in multiple tests. Mocks have the ability to return whatever
    values you set them to return. It is important to note that mocks are still not
    doing any logic. They return the value that is specified and do not check the
    parameters passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks are used in all the situations where dummies, stubs, and spies are used.
    Mocks are a heavier implementation of a test double, which is why you may not
    want to use them all the time. Mocks get less reuse than the previous test doubles
    because a mock's data must be set for each test, whereas a dummy, stub, or spy
    has a set return value that does not need to be configured. Setting up the test
    data that gets returned is often more difficult than simply creating a whole stub
    or spy class.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks are created by making a copy of a class or method and creating a property
    that can be set as the return value for a method; then, in the method being mocked,
    the property value is returned. Once created, before each test, the mock's return
    value must be set.
  prefs: []
  type: TYPE_NORMAL
- en: Example in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `MockDateTimeService` in C#. The `MockDateTimeService`
    allows you to set the `DateTime` to be returned by the service in order to reliably
    test how other parts of the system might behave based on specific `DateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Example in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `MockDateTimeService` in JavaScript. Much like
    the `MockDateTimeService` in C#, this allows you to set the `DateTime` to be returned
    by the service in order to reliably test how other parts of the system might behave
    based on specific `DateTimes`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Fakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fakes are the last and most powerful type of test double. A fake is a class
    that attempts to behave as if it weren't a test double. While a fake will not
    connect with a database, it will attempt to behave just like it is connecting
    to a database. A fake will not use the system clock, but it will attempt to have
    an internal clock that behaves as close to the system clock as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Fakes either add extra testing functionality or prevent external interference
    from third-party libraries and systems. Most applications are connected to some
    data source. A fake repository can be created that uses its own in-memory data
    source but otherwise behaves just like a normal data connection.
  prefs: []
  type: TYPE_NORMAL
- en: Fakes are created by generating a whole new class or method and then writing
    enough functionality to be indistinguishable from the production class or method.
    The only important distinction for a fake versus a production class or method
    is that the fake does not make external connections and likely has the ability
    for the tester to control the underlying data set.
  prefs: []
  type: TYPE_NORMAL
- en: Example in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `FakeRepository` and associated *interfaces*.
    The `FakeRepository` is a fake implementation of a generic repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Example in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of a `FakeDataContext` in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: N-Tiered example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, turn your attention back to the API controller in [Chapter 2](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195),
    *Setting Up the .NET Test Environment*. Hard-coded data being returned directly
    from the controller does not make for a solid foundation on which to build an
    application. Most modern .NET applications of any size are written in some sort
    of N-tiered architecture. You'll want to separate your business logic from your
    presentation, in this instance, the presentation in the API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We'll introduce an *interface* for a speaker service in preparation for using
    Dependency Injection to provide the concrete implementation to the controller,
    then verify that the proper method in the new service is being called. You'll
    need to rearrange some tests in order to remove the business logic from the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, add a new test to verify that the controller accepts an *interface*
    of `ISpeakerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make your test pass by creating a constructor in the `SpeakerController`
    to accept the `ISpeakerService` interface, introducing a field variable and a
    constructor in your `speaker controller` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Your test project should now fail to compile. This is because in our previous
    example from [Chapter 2](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195),
    *Setting up the .NET Test Environment*, we''re defining the controller instance
    in the constructor of the test class. Modify the constructor to create an instance
    of `TestSpeakerService`, which implements the `ISpeakerService` interface, and
    pass this to the `SpeakerController`. Feel free to create the `TestSpeakerService`
    in your test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, you'll want to verify that the `Search` method of the `SpeakerService`
    is called from the controller. But, how do you do that? One way is to use a mocking
    framework called *Moq*.
  prefs: []
  type: TYPE_NORMAL
- en: Moq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add *Moq* to your unit test project, right-click on your test project and
    choose Manage NuGet Packages. Browse for *Moq,* and choose to install the latest
    stable version. We won't delve too deeply into *Moq*, but we will show how mocking
    frameworks help facilitate testing the boundaries of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a test to verify that the `Search` method of the `SpeakerService` is called
    once from the `Search` action result of the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make the test pass, you will also be required to do a little more
    setup in the constructor of the `test` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to modify the *interface* so that the application will compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make your test pass by ensuring the `Search` method of the `SpeakerService`
    is called from the `Search` action result of the controller. If you haven''t done
    so already, create a `field` variable for `_speakerService` that is assigned in
    the constructor by the `speakerService` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a test to validate that the `searchString` supplied to the `Search`
    action result of the controller is the `searchString` being passed to the `Search`
    method of the `SpeakerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And make the test pass by supplying `searchString` to the `Search` method on
    the `_speakerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, ensure that the results of the `Search` method from the `SpeakerService`
    are what is being returned by the action result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, the results returned by the `Search` method of the `SpeakerService`
    are being defined by the `Mock`. You''ll need to extract a `field` in order to
    test that the results being returned by the *action result* are the same as those
    being defined for our `Mock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There's still the problem of the hard-coded data. Don't forget to remove unnecessary
    and unneeded code while you're making your test pass. Remember *red, green, refactor*.
    This applies to your production code as well as your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may encounter some failing tests once you remove the hard-coded data. For
    now, skip these tests, as we''ll be moving this logic to another part of the application.
    Now it''s time to create a `SpeakerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Business layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might want to start thinking about how to organize your tests effectively.
    As your application grows, and the number of test files increases, you may find
    it more and more cumbersome to navigate your solution. One answer  might be to
    create individual folders per class under test and a single file per public method
    within the class folder. This might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You don't necessarily need to tackle this now, but it wouldn't hurt to have
    a plan for the future. Applications tend to grow quite quickly, and before you
    know it you will have thirteen projects within your solution. You may choose to
    go ahead and create a `Services` project with a `ServicesTest` project at this
    time, to separate your business layer and associated tests from your presentation
    layer and its tests. That will be left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new test class for the `SpeakerService`. Here is where you''ll
    be creating all of your test methods for `Search` in the `SpeakerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you make this test pass, create a few new tests to confirm the `Search`
    method exists and that it returns a collection of speakers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, test that the `SpeakerService` implements the `ISpeakerService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `SpeakerService` should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remember, take slow and methodical steps. You are not allowed to write a line
    of production code without writing a failing test, and you're not to write more
    production code than is sufficient to make the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, begin to move the s*kipped* tests from the `controller test` file to the
    `Speaker Service Search Test` file. Start with `GivenExactMatchThenOneSpeakerInCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Make this test pass, then move on to `GivenCaseInsensitveMatchThenSpeakerInCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, `GivenNoMatchThenEmptyCollection` and `Given3MatchThenCollectionWith3Speakers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you get more comfortable with the practice and gain more experience with
    TDD, you may find it helpful to list the tests which you want to implement. This
    could be simply jotting them down on a piece of paper, or stubbing out some skipped
    or ignored tests in your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'If done correctly, your code should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now moved the hard-coded data out of our controller and into our business
    layer in the `SpeakerService`. You may think that a lot of effort was expended
    simply to move the problem into a new file! While this is true to an extent, this
    actually puts us in a better place for future development. The "logic", such as
    it is, has been moved into a class that can be reused by other parts of the application,
    and by potential new interfaces (think native and/or mobile applications) that
    would not have access to our original controller.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue with this example in future chapters. We will *finally* rid ourselves
    of hard-coded data and implement a data access layer using the Entity framework.
    All of this can be accomplished with Test-Driven Development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some pitfalls that will hinder TDD, such as dependence
    on third-party libraries, direct instantiation of classes, and fragile tests.
    We also discussed ways to avoid or work around those issues. We introduced and
    discussed each of the SOLID principles. We also discussed the different types
    of test double and when each type is appropriate. Lastly, we gave a short example
    of an N-tiered application and how it could be tested.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195), *Tabula
    Rasa – Approaching an Application with TDD in Mind*, we'll explore how to approach
    and application with a TDD in mind, turning theory into practice, and how better
    to grow an application through tests.
  prefs: []
  type: TYPE_NORMAL
