- en: '21'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Massive Worlds: Introduction to DOTS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Unity is a powerful and performant engine (when used properly), there’s
    a limit on how many GameObjects you can have without reaching performance limits.
    While the **Object-Oriented Programming** (**OOP**) paradigm provides a convenient
    way to code a game, due to its internal works, it won’t always take advantage
    of all the modern CPU features, like caching, **Single Instruction Multiple Data**
    (**SIMD**) operations, and multi-threading. While it isn’t impossible to use such
    features in OOP, doing so is not a trivial task and can lead to difficult-to-track
    bugs. Unity’s response to that issue was releasing the first production-ready
    version of the DOTS packages, which will help us with these problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following build concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what DOTS is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first DOTS game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating gameplay in DOTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by getting an idea of what DOTS is and why we should use it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what DOTS is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Unity Data-Oriented Technology Stack (DOTS) is a set of Unity packages
    that allows us to write data-oriented code easily. While there are plenty of packages
    in the DOTS stack, let’s focus on the three key ones that serve as pillars for
    the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities:** Unity takes on the ECS pattern. It replaces GameObjects and MonoBehaviours
    with Entities, Components, and Systems (ECS, a paradigm in Unity that separates
    data (components) from logic (systems), enhancing performance and scalability),
    a cache-friendly way to store and update our scene objects. It provides considerable
    performance boosts, especially in games with lots of objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jobs:** The Unity way to create multi-threaded code. It groups data and code
    that processes jobs. They are executed in parallel thanks to the job scheduler,
    which guarantees that explicit dependencies between jobs are respected. This avoids
    classic multi-threading issues like deadlocks and race conditions. Unity uses
    Jobs to boost the performance of its different systems, like rendering or physics.
    It cannot be applied to regular MonoBehaviour methods like Update without significant
    modifications, but entities are highly compatible with jobs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Burst**: A code compiler capable of converting C# scripts to highly optimized
    native code. It uses LLVM, which applies advanced optimizations when compiling.
    The code to convert needs to use a subset of C#, called **High Performant C#**
    (**HPC**#), so it cannot be applied to any script without (sometimes) considerable
    modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these packages can be used separately (especially the Jobs and Burst packages),
    the idea is to mix them to parallelize our game logic written in ECS using Jobs,
    while Burst makes it run as fast as possible. The other DOTS packages provide
    different features like rendering (Entities Graphics), physics (Unity Physics
    and Havok), and networking (Netcode for Entities).
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this sounds great and exciting, but there are some caveats when using
    this technology. Here’s a list of the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a fundamental change from the GameObject approach. This means that you
    must relearn how to do the same things you are already comfortable doing with
    GameObjects and MonoBehaviours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The learning curve can be steep, depending on your programming experience. This
    is caused by the limited C# features available due to HPC#, custom APIs to learn,
    and the multi-threaded nature of its code. Even if the Jobs package is easy to
    use, it adds challenges that aren’t present in single-thread code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s in its early stages. It’s likely that its API will change considerably
    in the short term (for the better!). Luckily, the data-oriented principles won’t
    change, meaning that we won’t need to relearn them again, just the APIs involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some GameObjects features aren’t available in DOTS yet, like UI, audio, terrain,
    or animations. For now, you need to implement such features in GameObjects and
    synchronize them with their respective entities. It is a hard endeavor that requires
    several custom solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regardless, these obstacles didn’t stop ambitious games from being made with
    DOTS, like V-Rising and Cities Skylines 2\. The idea of discussing DOTS’ caveats
    is not to intimidate but to understand when it is justified to use it. The games
    I just mentioned are great examples of where DOTS shines, given that those games
    simulate huge worlds with lots of objects. Here’s a non-comprehensive list of
    games that could benefit from using DOTS:'
  prefs: []
  type: TYPE_NORMAL
- en: Big worlds with several objects that require complex simulation logic to run
    in a performant way. Some examples of this are massively multiplayer online games
    (MMOs), city-builder games, or big RPGs that simulate vast worlds like Cyberpunk
    2077 or Assassin’s Creed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex simulations require real-life behavior, like wind-tunnel simulations,
    architecture visualization, or even galaxy star simulations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific features of a GameObjects-based game can use DOTS, like a crowd in
    a football stadium or complex particle systems. DOTS and GameObjects can coexist
    in the same game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, simple games that run properly with GameObjects don’t need
    the difficulties and current limitations of DOTS. For example, fighting games
    that require two main objects (the fighters) and a minimal environment are not
    good candidates. Other examples are casual open-world exploration games like Firewatch,
    which, even if they feature big landscapes to explore, have a simple enough logic
    to get away with some clever tricks using GameObjects. In the end, Firewatch was
    made without DOTS.
  prefs: []
  type: TYPE_NORMAL
- en: These limitations will be sorted in the future, making all types of games using
    DOTS viable, but for now, let’s avoid starting a project in a way that might risk
    its development. I’m not saying that DOTS is risky, but I want to be clear that
    not every game is worth the effort and pitfalls of relearning a new tech from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: If, after careful consideration and research, you think your future project
    might benefit from using DOTS, then stick with us; in the next section, we are
    going to learn how DOTS works by doing a simple introductory project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first DOTS game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is plenty to learn in order to create performant games with DOTS, so let’s
    start by creating a simple project featuring cubes moving forward. Emphasis on
    cubes – we are going to have thousands of them! I know it is not the most exciting
    project, but bear with me, as in the *Creating Gameplay in the DOTS* section in
    this chapter, we will convert it into an actual (but simple) game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine the following DOTS concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DOTS project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating entities with subscenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating components and bakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating systems using Jobs and Burst
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging systems jobs and queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing how to set up a project to be compatible with DOTS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DOTS project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step for creating a DOTS project is the one you should already know
    by this point in the book: creating a brand-new URP project. If you are not sure
    how to do it, please refer to *Chapter 1*, *Embark on Your Unity Journey*. Make
    sure you are using the **3D (URP)** template, as DOTS is only compatible with
    URP and HDRP, and we didn’t cover HDRP in this book. You can also add DOTS to
    an existing project if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to install the needed DOTS packages. We mentioned that there
    are three key packages: Entities, Jobs, and Burst, and we also mentioned that
    the rest of the packages are built on top of them. Aside from those packages,
    we need **Entities Graphics** to render our entities. Given that this package
    has dependencies on the core DOTS packages, just installing it will bring the
    holy three packages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t remember how to install packages, please refer to the *Installing
    ProBuilder* section from *Chapter 3*,*From Blueprint to Reality: Building with
    Terrain and ProBuilder*. Those instructions install the **ProBuilder** package,
    but the steps can be extrapolated to install this one. At the time of writing
    this chapter, **Entities Graphics** is in version 1.0.16.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.1: Installing Entities Graphics and also the Entities package as
    a dependency'
  prefs: []
  type: TYPE_NORMAL
- en: You might receive a message about the **Burst** package being updated, which
    might cause Unity to be unstable. As usual, restart Unity when installing a new
    package to fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is to change the URP settings to use Forward+, a new URP
    rendering path that is utilized by DOTS for rendering. Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the currently used SRP asset as explained in the *Configuring performant
    shadows* section of *Chapter 12*, *Enlightening Worlds: Illuminating Scenes with
    the Universal Render Pipeline*. In my case, the asset is called **URP-HighFidelity**,
    so you can also search for it by name in the **Project** panel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.2: Seeing the current SRP asset in use.'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Renderer List** of the SRP asset, double-click its first element to
    select the renderer asset. In my case, it is called **URP-HighFidelity-Renderer**,
    so again, you can just search it in the **Project** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.3: Selecting the Renderer asset used by the SRP asset'
  prefs: []
  type: TYPE_NORMAL
- en: In the renderer asset, set the **Rendering Path** option to **Forward+**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.4: Activating Forward+ as the current rendering path'
  prefs: []
  type: TYPE_NORMAL
- en: Press the **Play** button in the editor to make sure everything works fine.
    If you see a warning message in the console like the one in *Figure 21.5*, make
    sure you are modifying the proper asset. The console message will tell you the
    name of the asset to change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.5: Warning message when playing a DOTS project and not using Forward+'
  prefs: []
  type: TYPE_NORMAL
- en: Consider that the other URP renderer assets might be used if the game allows
    changing the quality settings if the game features an options menu. In such a
    case, change all renderer assets to use Forward+.
  prefs: []
  type: TYPE_NORMAL
- en: 'A discussion about Forward+ is beyond the scope of this chapter. For more info,
    check the following link: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html)'
  prefs: []
  type: TYPE_NORMAL
- en: There is an extra step that is not necessary for DOTS to work, but that will
    make the editor experience faster. Just go to **Edit | Project Settings | Editor**
    and check the **Enter Play Mode Options** checkbox. This will avoid the costly
    domain reload process that happens whenever we play a game in the editor. While
    this might be necessary in GameObject-based projects, pure DOTS projects can avoid
    it. Enable this option when doing a hybrid DOTS game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are ways to use the Play Mode Options in GameObject projects. Check the
    following documentation link for more info: [https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html](https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our project properly set up, let’s create our first entity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating entities with subscenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While entities work differently from GameObjects, you are still going to use
    GameObjects to create entities in the editor. The idea is to use the familiar
    Unity tools you are used to working with, like the **Scene**, **Hierarchy**, and
    **Inspector** panels, and even Prefabs. This works by converting specific GameObjects
    and their components into their entity equivalents. We will also instantiate entities
    via scripting later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To convert GameObjects to entities in the editor, we are going to use the baking
    system. It uses bakers – scripts responsible for converting specific components
    to their entities’ equivalents. Some DOTS packages come with bakers to convert
    specific Unity components; for example, Entities Graphics has bakers to convert
    the `MeshFilter` and the `MeshRenderer` components to their entities’ versions.
    The converted versions might differ considerably from the original ones, and usually,
    one component can be converted to several ECS components. If you don’t install
    the Entities Graphics package, `MeshFilter` and `MeshRenderer` will be discarded
    when converting them, as there’s no baker in the project for them, making your
    entity not be rendered. Later in this chapter, we will create our own bakers.
  prefs: []
  type: TYPE_NORMAL
- en: The way to tell Unity which GameObjects should be converted is via a subscene,
    which is another scene that will contain just the GameObjects to convert. The
    idea is for a main scene to load the entities subscene by using the SubScene component,
    which is responsible for converting and loading the entities in the subscene.
    Note that the conversion happens in the editor, meaning that no conversion happens
    when playing the game from a build. This allows loading subscenes extremely fast,
    thanks to the way scenes are serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a subscene, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In an existing scene, right-click in any empty space of the Hierarchy and select
    the **New Sub Scene | Empty Scene** option. If you see the option grayed out,
    make sure to save the main scene first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.6: Creating a subscene'
  prefs: []
  type: TYPE_NORMAL
- en: In the save-file prompt, save the subscene like you save a regular scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a GameObject with the **SubScene** component in the main scene.
    It will have the Scene Asset property set to reference the subscene file we created.
    If the **New Sub Scene** option is not available, create the subscene asset and
    GameObject manually until it looks like *Figure 21.7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.7: A subscene component that loads the subscene asset we just created'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the checkbox of the subscene GameObject in the Hierarchy is checked,
    as it allows you to edit the subscene and add objects to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cube using **GameObject | 3D Object | Cube** and drag it inside the
    subscene in the Hierarchy. Make sure you create it inside the subscene by noting
    the indentation seen in *Figure 21.8*. If it is created outside the subscene,
    the cube will look right, but because it is still a regular GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.8: Indentation that shows that the Cube is inside the subscene'
  prefs: []
  type: TYPE_NORMAL
- en: To confirm the cube was converted, select it and check if the **Entity Baking
    Preview** is at the bottom of the **Inspector**. Click it to show a list of ECS
    components converted from the cube’s original components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.9: Entity Baking Preview showing the ECS components created from
    your original Cube'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the scene camera is pointing to the cube, and then play the game.
    You must see the cube being rendered in the **Game** panel. Make sure that the
    camera is not inside the subscene; we need it to be a classic GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that’s it! You created your very first entity! Of course, it doesn’t do
    anything fancy, but now we are ready to add custom behavior to it, starting by
    adding ECS components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating components and bakers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before creating ECS components, let’s discuss how they differ from GameObject
    components. Think of GameObject components as individual tools in a toolbox –
    each one is designed for a specific task, like rendering shapes or detecting collisions.
    They work independently but together create the functionality of an object in
    your game. On the other hand, ECS components are more like raw materials in a
    factory line; they don’t do anything on their own. Instead, they are efficiently
    processed and assembled by systems to create the desired behavior. This shift
    from using individual tools (GameObject components) to processing raw materials
    (ECS components) enables Unity to optimize game performance, especially in complex
    scenes with many objects.
  prefs: []
  type: TYPE_NORMAL
- en: While we still want to add components to entities to add behavior to them, the
    responsibilities of ECS components are limited to holding only data. This means
    they won’t have Updates or other events like `OnTriggerEnter`; it’s just pure
    data. They can have methods to facilitate operating on that data but not the core
    gameplay logic.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering where our logic will be placed then, and the answer is
    systems. We will create them later in this chapter, but first, let’s add the entity
    data required for our gameplay logic to work.
  prefs: []
  type: TYPE_NORMAL
- en: With data, I am referring to variables like our character’s bullets, the score,
    health points, position, and so on. We usually create fields in `MonoBehaviours`
    for such purposes, and here’s no different, but this time, we won’t use classes
    that inherit from `MonoBehaviour`. Instead, we are going to use structs that implement
    `IComponentData`. Structs allow the Entities package to manage the memory of our
    components differently from how the **Garbage Collector** works by organizing
    it in a way that leverages the CPU cache. Structs are also compatible with HPC#,
    the subset of C# compatible with Burst. More about Burst and CPU caching will
    be discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between structs and classes in C# is outside the scope of this
    book. You can learn more about this here: [https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a component by creating a script using the plus button in the
    **Project** panel, selecting the **C# script** option, and naming the script like
    the component you want to create. Don’t create the script using the **Add Component**
    button in the Inspector, as we need some extra steps before adding components
    to the to-be-converted GameObjects. We recommend putting all your ECS components’
    scripts inside a `Scripts/ECS/Components` folder to easily distinguish between
    your regular Unity scripts and the ECS scripts.
  prefs: []
  type: TYPE_NORMAL
- en: As we want our cube to move forward, we need a velocity value. Components with
    transform data like position and rotation were added by Transform bakers included
    in the Entities package. To create our velocity ECS component, start by creating
    a script called `Velocity` and put the following code inside it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.10: An ECS component that holds the velocity of the entity'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we shouldn’t use classes; use structs instead. While you can use
    classes, they will be a different type of component (managed component) that is
    considerably less performant, and we don’t need them now. Also, notice how we
    included the `Unity.Entities` namespace. And that’s it! We have our first ECS
    component! But we are not finished yet. If you try to add this component to our
    cube in the subscene, it won’t work. Our component won’t be listed in the **Add
    Component** button in the **Inspector**, and you can’t even drag and drop the
    script file as usual. Remember that the baker system needs a baker for our ECS
    component and a MonoBehaviour to convert.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to use GameObjects and `MonoBehaviours` to use the existing Unity
    tools to create scenes and convert them to entities through bakers. So far, we
    created the ECS component, but we still need the `MonoBehaviour` version of that
    component to add it to the subscene GameObjects. The `MonoBehaviour` version of
    our component is called the **Authoring Component**, and the ECS component is
    the **Runtime Component**. To create the authoring component, create a regular
    component with the fields we want to configure from the editor. In the following
    image, you can see the `VelocityAuthoring` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.11: The authoring component for our Velocity runtime component'
  prefs: []
  type: TYPE_NORMAL
- en: It’s just the classic MonoBehaviour component we are used to creating, with
    the same fields our runtime component will have. Now that we have a component
    that we can add to our authoring GameObjects in the subscene, just add it to the
    cube. If you check the **Entity Baking Preview** pane at the bottom of the **Inspector**,
    no new ECS component was added. We still need to create the baker to convert `VelocityAuthoring`
    into `Velocity`. A baker is a class that inherits from the `Baker` class and converts
    authoring components into runtime components. In the next image, you can see the
    baker for our `VelocityAuthoring` component.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.12: The baker that converts the VelocityAuthoring component to the
    runtime component'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we created a class that inherits from `Baker<VelocityAuthoring>`,
    meaning that this will be the baker for `VelocityAuthoring` when the baking system
    does the conversion. In the `Bake` method, we receive the instance of the authoring
    component to convert, accessing its data to create the runtime component.
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the entity created for the converted GameObject by using the `GetEntity`
    method. Its only parameter highlights that we want this object to move during
    play mode. Hence, it’s dynamic. Then, we create the instance of the runtime component,
    and we set its velocity value to be the same as the authoring component. This
    way, we make sure that the value set in the Inspector is the one that the runtime
    component will have. Finally, we use the `AddComponent` method to add the runtime
    component to the converted entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the different transform usage flags used in `GetEntity`,
    check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html)'
  prefs: []
  type: TYPE_NORMAL
- en: If you save your scripts and make sure the authoring component is added to the
    cube, the **Entity Baking Preview** pane should show the **Velocity** runtime
    component. You can click it and confirm that its value is the same as the authoring
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.13: The Entity Baking Preview shows how our runtime component reflects
    the authoring component value'
  prefs: []
  type: TYPE_NORMAL
- en: While this seems like a lot to create a component, in real projects, this becomes
    a powerful tool. Authoring components might add several runtime components, sometimes
    conditionally. For example, the **Rigidbody** baker in the **Unity Physics** package
    will add different components depending on whether **Is Kinematic** is checked
    or unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the needed data, let’s create the system to move our cube.
  prefs: []
  type: TYPE_NORMAL
- en: Creating systems using Jobs and Burst
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular MonoBehaviours not only have data but also the logic to create the behavior
    they represent. Sometimes, they need data from other components, like the position
    in `Transform`, so they use methods like `GetComponent` to access other components’
    data. In ECS, this works quite differently.
  prefs: []
  type: TYPE_NORMAL
- en: Given ECS components have just data, the logic goes into a different place called
    **Systems**. They apply the game logic, such as moving or rotating objects, to
    the entities that require such logic. The way for systems to identify which entities
    must have their logic applied is via their data. Systems will query all entities
    that have specific sets of components for their logic to work and will iterate
    the resulting entities to apply that logic. In this case, we want to move entities,
    but not all entities, just the entities that have the `Velocity` component and
    position data.
  prefs: []
  type: TYPE_NORMAL
- en: The clarification that our system requires to have position data might be confusing,
    given that all GameObjects have a **Transform** component. This is not necessarily
    true in DOTS, and it’s explained in more detail in the `TransformUsageFlags` property
    info box we mentioned before. In this project, we will always use `TransformUsageFlag.Dynamic`,
    so for this case, we can assume all entities will have transformation data such
    as position, rotation, and scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our movement system, first, we need to create a script, as seen in
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.14: An empty ECS system that serves as the base to create our movement
    system'
  prefs: []
  type: TYPE_NORMAL
- en: A system consists of a partial struct that implements the `ISystem` interface.
    It needs to be partial given that DOTS relies on code generators, meaning that
    lots of boilerplate code to make a system work will be in another `MovementSystem`
    partial struct created automatically for us. We also added an `OnUpdate` method,
    the equivalent to the MonoBehaviour’s `Update` method, but with a very important
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the `partial` keyword is outside the scope of the book. Check the following
    link for more info: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods)'
  prefs: []
  type: TYPE_NORMAL
- en: The regular `Update` method belongs to specific components, meaning that the
    `Update` will be executed once per component instance. If we have 100 `GameObjects`
    with a `MonoBehaviour` that has an `Update` method, that method will be executed
    100 times per frame, once for each `GameObject`. But in this case, by default,
    there’s always a single instance of our system in the game, which is created automatically
    by the Entities package, regardless of the entities present in the scene. This
    means that our movement systems `OnUpdate` method will be executed once per frame
    as soon as we play the game, just because the system script exists. There are
    ways to prevent the automatic system creation, to have more than one instance
    of a system, and to prevent the `OnUpdate` execution, but let’s keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: After saving your system script, to make sure it is working, play the game and,
    during play mode, open the `Systems` panel in **Window | Entities | System**.
    This window will list all the systems that are running and their performance metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.15: The Systems window showing our Movement System.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to iterate all entities that have the `Velocity` and the `LocalTransform`
    component. The latter is one of the several Transform ECS equivalents added by
    the Transform bakers. There are several ways to iterate entities, but let’s first
    see the most common and performant way, using jobs. Jobs are structs that contain
    the logic we want to apply in multiple threads, and the data needed to apply it,
    such as delta time or the positions of the objects to move. In our case, the data
    will be the entity components and some extra data, like delta time. To iterate
    entities, we have a type of job called `IJobEntity`. There are plenty of job types
    for different purposes, but for ECS, we will be using `IJobEntity` most of the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see a job script that moves all entities with
    `Velocity` and `LocalTransform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.16: A job to move entities that have LocalTransform and Velocity
    components'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of things happening here, so let’s analyze this script piece
    by piece:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a partial struct that implements `IJobEntity`in a script that uses
    the `Unity.Entities` and `Unity.Transforms` namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This struct has an execute method with two parameters, one of type `LocalTransform`and
    the other of `Velocity`type. It’s no coincidence that these parameters match the
    exact components we need to move entities. The parameters defined in the `Execute`method
    of an `IJobEntity`serve to tell ECS that we want to iterate entities with such
    components, ignoring the ones without them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `LocalTransform`parameter is prefixed by a `ref` keyword, while `Velocity`is
    prefixed by an `in` keyword. Those are ways to tell ECS the privileges we want
    over those components. `Ref` means that we will modify `LocalTransform`, while
    `in` means we will only read the data of `Velocity`. For the job system to make
    sure any job is safe to execute in parallel with others, it needs to know how
    the data in them will be treated. Two jobs that write the same data (for example,
    two jobs that move objects in different ways) cannot be executed in parallel to
    prevent race conditions and using locks. However, two jobs that read the same
    data can execute in parallel, given that read-only operations are thread-safe.
    Always define parameters as `in` (read-only) whenever possible, using `re` only
    when necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We calculate the number of meters to move as usual by multiplying the velocity
    with delta time. We didn’t access delta time, as usual, using `Time.deltaTime`.
    To allow for safe job parallelization, they are designed to deal only with the
    data inside the job, avoiding accessing static variables whenever possible. That’s
    why delta time is a field in the struct so that later when we instantiate the
    job in our system, we will fill this data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MonoBehaviours`, modifying the axes returned by `transform.position` directly
    (not storing it in a variable) is not possible; given that `transform.position`
    returns a copy of the position, modifying it will throw an error. The same applies
    to any other getter. But in ECS, it’s perfectly valid, given that we are manipulating
    the data by reference, not just a copy. We accessed `LocalTransform`via a `ref`
    keyword, meaning that we are accessing the position memory directly. In regular
    `MonoBehaviours`, this is not possible, given the position of our GameObjects
    is stored in the C++ side of a Transform, so copies are necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jobs can access mutable static data if they are not Burst-compiled (more on
    this later). But even if that is possible, it is highly dangerous as the ECS safety
    systems cannot prevent two jobs from modifying such static data. That’s why it
    is safer to copy the data to the job as we did with `Time.deltaTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the only responsibility of `MovementSystem` is to instantiate the job,
    fill in its data, and schedule it. By scheduling it, the job system will take
    care of checking when it is safe to execute our job, considering how other systems’
    jobs might read and write the same data our job needs. Remember that the idea
    of defining read-write or read-only access for our components when using the `ref`
    and `in` keywords is to allow the job scheduler to take such considerations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our system’s OnUpdate method will look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.17: The movement system instancing MoveJob and scheduling it'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we simply instantiate the job, filling the `DeltaTime` field
    with this frame’s delta time, and then we schedule the job using `ScheduleParallel`.
    The first thing to notice is that we used `SystemAPI.Time.DeltaTime` is the ECS
    way to get the frame’s delta time.
  prefs: []
  type: TYPE_NORMAL
- en: ECS has its own timing mechanism, and while we can still use `Time.DeltaTime`,
    we should stick to the ECS version to work properly with the rest of the systems.
    Also, we didn’t specify the entities the job will iterate. Systems code generators
    know the entities we want to iterate based on the system job’s `Execute` method
    parameters, so we don’t need to worry about providing this data to the job.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the `ScheduleParallel` method to not only tell the job scheduler
    to schedule our job but also to tell it that we want to iterate the entities in
    parallel. This means that the job worker threads (usually one for each CPU core)
    will be processing different entities, reducing the time it takes to execute our
    logic by spreading the work. You can also use `Schedule` instead, which processes
    all our entities in a single core but still in parallel with other jobs. For now,
    we will stick with `ScheduleParallel` for most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need the final piece of the DOTS tri-force, Burst. Remember, Burst will
    take HPC# compliant code and convert it into performant native code. Here’s a
    non-comprehensive list of requirements of HPC#:'
  prefs: []
  type: TYPE_NORMAL
- en: Using managed references (objects) is not possible. This includes strings, arrays,
    lists, dictionaries, and most of the C# libraries, like `System.Collections`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions (try/catch) work in the editor, but they will abort execution in
    builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Debug.Log` support is limited to constant strings, string interpolation, and
    `string.Format`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static read-only data and constants are safe. Mutable static data isn’t unless
    the `SharedStatic`struct is used: [https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html](mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used HPC# in the code so far, so we just need to tag the code to Burst-compile
    using the `BurstCompile` attribute. In systems, you can add this attribute to
    the `OnUpdate` method, and for jobs, add the attribute to the `job` struct to
    Burst-compile its `Execute` method.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.18: Burst-compiling our systems and jobs'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some considerations to follow in your code to make Burst work even
    faster. Check this link for more information: [https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html](mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can play the game and observe how our cube will move forward. Feel
    free to copy the cube several times over the scene until you have hundreds or
    even thousands of them. See how the game performance doesn’t suffer!
  prefs: []
  type: TYPE_NORMAL
- en: It is easy for the systems to not work as expected when entities are misconfigured,
    like forgetting to add the `Velocity` component. This can cause systems to not
    find the entities they need. Let’s see how to debug systems to see the entities
    they found, which jobs they are scheduling, and check if their code is Burst-compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging system jobs and queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Systems apply logic by iterating entities that have specific components, using
    jobs and other methods. To debug a non-working system, we should check if it is
    finding entities. To do so, the system code generator creates instances of `EntityQuery`,
    a type responsible for finding entities with specific components. Our `MoveJob`
    job requires entities with `LocalTransform` and `Velocity`, so an entity query
    is generated automatically in the `MovementSystem` for it to schedule its job.
    Systems could iterate different groups of entities (for example, when scheduling
    more than one job), so systems can have several queries. Entity queries can also
    be created manually for other purposes, but we don’t need them now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entity queries are fast due to them caching archetype chunks. These memory
    chunks store entities that have the same set of components, so it’s easy to track
    where the required entities are located. For more info on archetypes, see the
    following link: [https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the **Systems** window (**Window | Entities | Systems**) during play
    mode to see how many entities our system is finding and all the queries that find
    them. Check the **Entity Count** column of a system. Also, after selecting the
    system in the list, the **Inspector** will show the system queries, informing
    each query component.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_19.png)Figure 21.19: Checking system’s queries using the
    Systems window and the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: Use the **Relationships** tab to see which entities match the query. In the
    following image, you can see that our query is finding our cube.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.20: Checking the entities matching the system’s queries.'
  prefs: []
  type: TYPE_NORMAL
- en: If your queries don’t match the expected entities, check if such entities have
    the required components. It’s easy to forget to add the authoring components into
    our entities or even forget to put the authoring GameObjects inside the subscene,
    mistakenly leaving them in the main scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to check is if our system is scheduling the job and to see if
    the system and the jobs are Burst-compiled. To do so, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Unity Profiler as we saw in *Chapter 18*, *Performance Wizardry: Optimizing
    Your Game with Profiler Tools*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capture profiling data during play mode and select any frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the **Timeline** view if you are not already there by clicking any place
    in the CPU usage module, clicking the **Hierarchy** button to display the selection
    box, and clicking **Timeline**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.21: Enabling Timeline mode in the Profiler’s CPU module'
  prefs: []
  type: TYPE_NORMAL
- en: Search for your job in the **timeline** by using the mouse wheel to zoom in.
    Your system should be inside the **SimulationSystemGroup** profiler marker. Note
    that even if we have thousands of entities, our system is only scheduling a job
    to iterate them, so its marker will be very small.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.22: Finding our systems in the profiler'
  prefs: []
  type: TYPE_NORMAL
- en: Check the marker color. If it’s light green, it means it is burst compiled.
    If it is light blue, it is not, meaning we didn’t add the `BurstCompile`attribute
    to the `OnUpdate`method, or we tried to Burst-compile non-HPC# code. Notice how
    the non-Burst-compiled version is significantly slower than the Burst-compiled
    one in the following image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.23: Non-Burst compiled system code'
  prefs: []
  type: TYPE_NORMAL
- en: In the profiler, click the three dots button in the top-right part of the timeline
    (not the similar button in the top-right corner of the window) and enable **Show
    Flow Events**. This will enable us to see the jobs our system schedules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.24: Enabling flow events'
  prefs: []
  type: TYPE_NORMAL
- en: Select our system in the timeline and follow the lines to the jobs. You should
    see several instances of it in different threads, as each instance deals with
    different groups of entities (if there are enough). Remember to expand the job
    thread group using the gray triangle at its left to see the job’s details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_21_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.25: Checking the jobs scheduled by our system.'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the job’s marker color is light green. If it’s not, remember to add
    the `BurstCompile`method to the `job` struct (not the `Execute` method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we discussed how to create and configure a DOTS project and
    how to create a subscene where we placed GameObjects to convert them to entities.
    We also created a runtime component (`Velocity`), added to our converted entities
    by a baker (`VelocityBaker`), which converted the authoring component (`VelocityAuthoring`)
    to the runtime component. We used the velocity value to create a system that scheduled
    a job that applied that velocity to each entity’s `LocalTransform` position, moving
    the entities. Finally, we saw how to debug our systems, check the queries they
    created to iterate entities in jobs, and see the system-job relationship and performance
    using the Unity Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have just scratched the DOTS surface. In the next section, we
    will see how to create more interesting gameplay, like moving and spawning enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating gameplay in DOTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lots of things we do in MonoBehaviours, like instantiating objects or getting
    other object data (for example, their position), are quite differently implemented
    in DOTS. In this section, we will examine how to achieve these things in DOTS:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving using input and tag components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating seeking missiles using component lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying the character with entity command buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with errors in bursted code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating missiles with entity Prefabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the camera follow our character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other DOTS features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing how to modify our movement code to respond to input.
  prefs: []
  type: TYPE_NORMAL
- en: Moving using input and tag components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start creating gameplay by using input to move the cube. We need to change
    our movement job to provide it with the input values. We will do this the same
    way as we provided delta time by passing the input values to the job. In the next
    image, you can see the needed changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.26: Moving our character based on our input'
  prefs: []
  type: TYPE_NORMAL
- en: While `LocalTransform` has a `Translate` method, it doesn’t move in relative
    coordinates. That’s why we needed to construct the movement vectors by using the
    `Right` and `Forward` methods, which provide such directions relative to our object.
    We apply a similar update to our position for forward movement by adding a vector
    along the forward direction, multiplied by the current input’s `Vertical` value
    and `DeltaTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we modified our system to provide the input values like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.27: Providing input values to the move job'
  prefs: []
  type: TYPE_NORMAL
- en: We used the legacy input system here for simplicity. Feel free to use the new
    one. Now, you can play the game and control the cubes with input. We deleted all
    the extra cubes, leaving just one to represent our player.
  prefs: []
  type: TYPE_NORMAL
- en: Something to consider is that while our movement system will move anything with
    the `Velocity` component, there can be other objects with velocity that could
    move in different ways (for example, via AI). We need to differentiate the objects
    that will apply velocity via input and the ones that apply it differently. One
    way would be to rename our `velocity` component to something like “`PlayerVelocity`”
    and then create other velocity components for the other future movement methods.
    While that will work, it might not be the best approach, depending on your game
    requirements. Let’s say we have a velocity area that speeds up any entity in an
    area. If we use the multi-component approach, our area will need to consider all
    the different velocity components we have, complicating our code.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach could be adding a unique component to our player entity to
    differentiate it from other entities, requesting such a component in our job.
    But such a component doesn’t need any data. Can we add a component with no data?
    Yes! We call them tag components. As the name suggests, they serve as a way to
    mark entities for systems to find them easily.
  prefs: []
  type: TYPE_NORMAL
- en: If you read the archetypes link provided before, you should be aware that adding
    tag components will split entities into different chunks. Avoid adding too many
    unique tag components to individual entities to prevent having too many chunks
    with just a few entities inside. This phenomenon is called archetype fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create the runtime component, authoring component, and baker for
    our `Player` tag. Remember to add the `PlayerAuthoring` component to our player
    entity (the cube).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_28.png)Figure 21.28: Scripts needed to create a player tag
    component'
  prefs: []
  type: TYPE_NORMAL
- en: 'We didn’t create a new `Player` component to add. Instead, we used the `AddComponent<Player>`
    API specifying `Player` as the component to add. Once added to the player entity,
    let’s use this tag component in our job to make it only move entities with it.
    While we can add `Player` as a job’s `execute` method parameter, as we did with
    the previous components, we won’t read or write data on it – it doesn’t have data
    after all. Instead, another way to tell our job to iterate entities with specific
    components is by using the `WithAll` attribute, as seen in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.29: Making the job’s autogenerated query to look for entities with
    the Player tag.'
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can reuse the `Velocity` component with the guarantee that each
    entity receives the required logic. Now, let’s add an enemy to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating seeking missiles using component lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example project, we will make the player evade seeking missiles that
    will constantly spawn. To do so, we will need a missile entity with the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Position and rotation**: represented by `LocalTransform`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movement velocity**: the same `Velocity` we already have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steering velocity**: a new `Steering` component we will create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A target entity to follow**: a new `Target` component we will create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Steering velocity should be a straightforward component to create. Just do
    the same as we did to create the movement velocity component, but name it differently.
    Regarding the Target component, it will look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.30: Creating the Target component'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that we are using the `Entity` type as the `Target`
    component value. This is the ECS equivalent of having a reference to a target
    GameObject. We use the entity reference to get data from it, like its position.
    Notice that the authoring component references a GameObject because, while editing,
    we still use GameObjects, so we are referencing the `Player` GameObject that will
    be converted to an entity. Finally, the baker not only needs to call `GetEntity`
    to get the entity we are converting to add components but also to get the converted
    entity of the target GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can create a sphere called `Missile` in the subscene and add the `Velocity`,
    `SteeringVelocity`, and `Target` authoring components. Remember to configure the
    `Target` component by dragging the player GameObject in the subscene to the **Value**
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.31: Creating the missile authoring GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can create a system to move the missiles towards the player. While we
    could create a `Missile` tag component as we did with the player, we have enough
    components to make the steering system find the missiles. We will make this system
    iterate entities with `Velocity`, `SteeringVelocity`, and `Target`, given that
    non-steering entities are unlikely to have this specific set of entities in our
    game so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the steering job will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.32: Steering job'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is the `TransformLookup` field of type `ComponentLookup`.
    So far, for the data we read from the entities we are iterating, we used the `ref`
    and `in` parameters as ways to access them, but this time, we need access to data
    from entities other than the ones the job iterates, so we can’t use the parameters.
    As the name suggests, a lookup allows us to get data from other entities, meaning
    we can retrieve components from entities using them. We are using it to get the
    target’s transform into the `targetTransform` variable, providing the target entity
    in brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to notice is that we have the `LocalToWorld` lookup. The ECS transform
    systems use this other component to store the local-to-world matrices. This means
    that this component has the world position, rotation, and scale of the target
    entity, unlike `LocalTransform`, which provides the local ones. This component
    allows us to get the world space entity position, regardless of where the parent
    transforms are.
  prefs: []
  type: TYPE_NORMAL
- en: We also used this component due to a tricky issue. Our job is to modify the
    position of entities in relation to other entities’ positions. We also use `ScheduleParallel`
    to schedule jobs, creating several jobs that handle different entities. This can
    lead to one job instance reading the position of an entity that another job instance
    is writing, which can cause several issues. Unity can detect such cases and warn
    us, but in this case, it is not needed, given we are reading the `LocalToWorld`
    component to get the target’s position while we are modifying the missile entities’
    positions via `LocalTransform`. This way, we don’t risk reading and writing the
    same component simultaneously. Actually, `LocalToWorld’s` data is derived from
    the `LocalTransform` value by one of the several ECS transform systems. Also,
    notice how the lookup is declared as `ReadOnly`, given we won’t modify other entities’
    `LocalToWorld`; we just read them. Modifying `LocalToWorld` won’t make sense because,
    as we mentioned before, its value is calculated from `LocalTransform` before rendering
    the entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We tried to explain the transform system as briefly as possible, but for more
    info about how it works, check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also check if the target entity is null, although we are not using
    the regular null, but `Entity.Null`. Structs cannot be null, given they are not
    reference types; they always have a value. `Entity.Null` is a special value that
    entity variables have when not referencing entities. The rest of the steering
    job uses regular vector math to apply steering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the system that schedules this job looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.33: Steering system scheduling the steering job'
  prefs: []
  type: TYPE_NORMAL
- en: We used the `GetComponentLookup`method to provide the component lookup to our
    job. We used `true` as the first parameter to let it know that we needed a read-only
    lookup. Component lookups are expensive to use, given they introduce indirection,
    causing cache misses. It is always preferred to use jobs to get entity data, but
    in this case, they are the only way to get other entity data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about what a cache miss is and how DOTS deals with them,
    check the following blog post: [https://blog.innogames.com/unitys-performance-by-default-under-the-hood/](https://blog.innogames.com/unitys-performance-by-default-under-the-hood/)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, just play the game and observe the missile following the player. Consider
    setting a small velocity but a high steering velocity (like `2.0`) to let the
    missile rotate fast enough to approach the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the missile, let’s make it destroy the player when it is close
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the character with entity command buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To let the missile destroy the player, we need to detect when it’s close enough.
    In regular GameObjects, we can implement this via triggers (`OnTriggerEnter`),
    but discussing the DOTS physics package is out of the scope of this chapter. Instead,
    we are going to create a job with simple distance checks, as seen in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.34: Distance checks in ECS'
  prefs: []
  type: TYPE_NORMAL
- en: This job works similarly to the steering job but does squared distance checks.
    Now, the tricky part is destroying the entity. Given there could be several jobs
    running in parallel iterating entities, it’s not safe to delete an entity right
    away. The only safe place to delete, create, or modify entities’ components, operations
    also known as structural changes, is on the main thread, and jobs run in job worker
    threads. When a system makes structural changes on the main thread, a sync point
    is generated, meaning that the main thread will be blocked until all jobs iterating
    entities finish, which can cause severe delays. Another issue is that, given we
    can have several systems that require structural changes, we run the risk of introducing
    several sync points. The best approach is to accumulate several structural changes
    and let specific systems execute them – ideally, just one. This way, we reduce
    the number of sync points, and that’s the exact purpose of **Entity Command Buffer**
    (**ECB**) systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structural changes can be costly in terms of performance. For more details
    on them, check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: ECB systems have APIs to create **Entity Command Buffers** (**ECBs**), allowing
    systems and jobs to enqueue commands in them, such as to instantiate or destroy
    entities. Our destroy system will use them to enqueue the player destruction when
    the missile is near enough. Let’s start by modifying our job to receive an ECB
    and use it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.35: Using ECBs to destroy the target entity'
  prefs: []
  type: TYPE_NORMAL
- en: We added a variable to pass the ECB to our job, which will be provided by the
    system when creating it. Then, we used the ECB’s `DestroyEntity` method, specifying
    that we want to destroy the target entity. The zero we provide is a way to sort
    the commands before executing them, but in this case, we don’t need any specific
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the need for a sorting key in ECBs, check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to create a system like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.36: Destroy close target system'
  prefs: []
  type: TYPE_NORMAL
- en: 'We accessed the `Singleton` component from an ECB system called `EndSimulationEntityCommandBufferSystem`,
    using the `GetSingleton` API. This method allows us to get the unique instance
    of an ECS component, provided we are sure there’s only one. You might be wondering:
    can systems have components? And yes, they can. In data-driven games, all data
    sharing happens through components. Every system has an entity to which they can
    add components and share data with other systems and jobs. Given there’s only
    one instance of this ECB system, we know we have just one instance of the `Singleton`
    component. It has the `CreateCommandBuffer` method, which creates an ECB whose
    commands will be executed when the ECB system updates. The `EndSimulationEntityCommandBufferSystem`
    system will execute its ECB commands at the end of the simulation system before
    the presentation of the ones that render our entities’ graphics. This way, our
    jobs can enable structural changes (like destroy) to be executed safely in the
    main thread later, along with commands from other systems that use the same ECB
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to provide the world our system lives in as the first parameter of this
    method. A world is a set of entities and systems that can run in parallel to other
    worlds. For example, in the `Netcode for Entities` package, we can run the server
    and client worlds in parallel when the player acts as the game’s host. We have
    just one world in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about worlds here: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We also called the `AsParallelWriter` method, which returns an ECB version that
    allows it to be used in several threads. Remember that our job executes multiple
    instances in parallel, so the parallel writer version makes sure it’s safe to
    use in our job’s instances. Finally, we provided the ECB to the job.
  prefs: []
  type: TYPE_NORMAL
- en: If you press play now and let the missile catch the player, you will see how
    it disappears! But wait! Now the console is spamming errors. While familiar, these
    errors are not quite the same as the ones we are used to receiving in GameObject-based
    projects; these are more cryptic. That’s because the error happened in bursted
    code (short for Burst-compiled code), and errors here behave a little bit differently.
    Let’s explore how to debug them.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors in bursted code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next image, you can see the error we received in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.37: Burst error logs'
  prefs: []
  type: TYPE_NORMAL
- en: First is a familiar C# error, but the stack trace is very verbose. After carefully
    reading it, you can see that each stack trace line is prefixed by a “#” symbol,
    showing the name of the called method. Following these symbols, we can find our
    job in line 5, but not much more info. We can infer where our code failed by checking
    the next line – in this case, the `ComponentLookup` call. Given our job uses lookups
    just once, we can infer that we are trying to get the transform of the target
    entity, but that it doesn’t exist anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.38: Burst error stack trace'
  prefs: []
  type: TYPE_NORMAL
- en: To make stack traces clearer, you can disable Burst in the editor. That will
    make the error logs look like usual, indicating the line where the error happened.
    Disable it by unchecking the **Jobs | Burst | Enable Compilation** option. Play
    again to see that now the logs indicate the line of the job where the error happens
    (line 21). I recommend getting familiar with the Burst errors log, as in builds,
    we cannot fall back into non-bursted code without recompiling our player after
    removing the `BurstCompile` attributes. Moreover, disabling Burst while developing
    can help iteration times, given that compiling Burst code takes longer than regular
    code, and while developing, we don’t need peak performance all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the error, it happened because the entity the missile was steering
    to (the player) was destroyed when we got close to it. To solve this, we can modify
    the `SteeringJob` job’s `Execute` method, like in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.39: Checking if the entity has LocalToWorld components'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to do the same for the `DestroyCloseTargetJob` job’s `Execute`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.40: Checking if the entity has LocalToWorld components'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we not only check if the target entity is null but also if it has a transform
    using the `TryGetComponent` lookup method. This method returns a boolean indicating
    whether the requested entity has the requested component, returning it in the
    out parameter. If the entity doesn’t have the component or the entity doesn’t
    exist, the method will return `false`. This way, we are quitting the job early
    if the target entity doesn’t have the component or was destroyed. In MonoBehaviours,
    a null check would be enough, but in DOTS, it isn’t. Leaving aside the specifics
    that allow that in MonoBehaviours, an `Entity` variable like target, internally,
    is just an integer ID. ECS uses it in a lookup table to determine where the entity
    data is stored (which chunk). `Entity.Null` is just an invalid ID, and given Unity
    won’t set all the entity references to have an invalid ID when it is destroyed,
    the null check is still successful. This way, even if the target entity is destroyed,
    the entity referenced in our `Target` component still has a valid ID. Also, observe
    how we removed the line where we used the lookup, given the `TryGetMethod` already
    gives us the target’s `LocalToWorld` component in the `out` parameter, so there’s
    no need to get the component twice.
  prefs: []
  type: TYPE_NORMAL
- en: You can go the extra mile and set the target to `Entity.Null` if the `TryGetComponent`
    method fails. Given using lookups is performance-heavy, early-quitting the method
    before we use it would be better.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s instantiate more missiles to make the game more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating missiles with entity Prefabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can approach the missile spawner by creating `spawner` entities – entities
    with a `Spawner` component that references the Prefab to instantiate and has the
    amount to instantiate and the frequency of instantiation. You might think, shouldn’t
    we create separate components for each piece of spawner data? We can do that,
    but there’s a performance overhead for each component used in a job and entity
    queries. We don’t have any reason to think that, in this example, any of our spawner
    data will be used in a different way, so this time we will use a single component.
    Try to mix data into a single component whenever you know all of it will be accessed
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Spawner` component will look like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.41: The Spawner component and baker'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `Spawner` runtime component has a `Prefab` entity field. Before,
    we used such a field to reference the missile’s target, but now we are using it
    to reference the Prefab to instantiate. We will create the missile Prefab and
    reference it in the spawner authoring component using a `GameObject` field. The
    Prefab reference can be converted using the `GetEntity` method again. We also
    have a target reference, given we want the spawned missiles to follow the player.
    The spawner needs to provide the target reference to the missiles. Remember to
    create the `spawner` GameObject with the `spawner` components in the subscene
    and configure it, dragging the `player` to the `target` property and the missile
    `Prefab` to the `Prefab` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Prefabs referenced by an ECS component will also be converted as an entity
    in our subscene, but they will have the special Prefab tag component. This allows
    the Prefab entity to exist in the subscene but will make ECS ignore it to prevent
    rendering or updating it. For more information about Prefab baking, check this:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a system and a job to iterate all spawner entities, using an ECB
    to instantiate missiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.42: The missile spawner job'
  prefs: []
  type: TYPE_NORMAL
- en: While we can instantiate our Prefabs one by one, it is better to instantiate
    several in one shot, so we instead created an array of entities and provided it
    to the Instantiate method. This Instantiate method overload creates as many instances
    as elements in the provided array, filling it with references to the soon-to-be-created
    instances (we are using ECBs). Then, we iterate that array and set the position
    of the missiles in a way that they spawn one separated from the others by 5 units.
    We also make them target the player by setting their target component. It might
    be confusing to change the value of a component by replacing it with a new component
    instance, but it’s a common practice in ECS. It is also very cheap, as components
    are structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need the system to schedule the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.43: The spawner system'
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnUpdate` method, the only new thing is the usage of `Time.ElapsedTime`
    to get the current game time. But then you can see the addition of an `OnCreate`
    method, the equivalent of `Awake` for a system. Here, we use the `RequireForUpdate`
    method to specify that we need the existence of at least one entity with the `Player`
    component for this system to execute. This way, we prevent the system from instantiating
    missiles when the `Player` is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our spawner system, let’s make the camera follow our character.
  prefs: []
  type: TYPE_NORMAL
- en: Making the camera follow our character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our camera is still a regular GameObject, but our player is an entity. Systems
    can access GameObjects in their `OnUpdate` method, provided that the method has
    not been compiled with the Burst compiler. The system to make the camera follow
    our character will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_21_44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.44: The system for the camera to follow the player'
  prefs: []
  type: TYPE_NORMAL
- en: As stated before, `OnUpdate` is not burst (it doesn’t have the *BurstCompile*
    attribute) and won’t use jobs, given it needs to access the main camera and its
    transform, which are non-HPC#-compatible reference types. Then, we used the `TryGetSingletonEntity`
    API to retrieve the reference to the only entity we expect to have the `Player`
    tag. Given missiles can destroy the player, we also use this API to check if the
    player entity still exists. Then, we use the `GetComponent` method to get the
    position of the existing player entity. While we could have used component lookups
    as we did before, given we are writing code directly in the system, we can use
    this method as a short way to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: You have created your first DOTS game! Remember, you can get access to the full
    project made in this chapter in the book’s Git repository. Finally, as always,
    there is way more to learn about DOTS, so let’s do a brief exploration of some
    of the most important remaining APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other DOTS features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several topics in this book deserve their own books, and ECS is no exception.
    Picking the most essential APIs to explain in this chapter and keeping the chapter
    as short as possible was quite difficult, as there is so much to explore. Because
    of that, aside from all the useful additional info we left in the info boxes,
    here I leave you a list of other DOTS concepts worth checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SystemAPI.Query**: A way to iterate entities in a system without jobs. Useful
    for entity-iterating code that uses managed references or static variables. Also,
    for simple things that are fast to execute, avoiding job scheduling costs. Link:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Queries**: As explained before, the way jobs and other ECS APIs (like
    `SystemAPI.Query`) iterate entities. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enableable Components**: Components that can be disabled. Entity queries
    will ignore entities that have their required components disabled. Useful for
    toggling on and off entity behaviors without adding/removing tag components, which
    is expensive because they need structural changes. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cleanup Components**: The ECS equivalent to the `OnDestroy` event. Link:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Buffers**: The ECS way to have array-like data in components. Link:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blob Assets**: The ECS equivalent of scriptable objects. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content Management**: The ECS version of Addressables. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scene Loading: The ECS way of loading subscenes. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Physics and Collisions: The ECS version of the physics system. Link: [https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Netcode for Entities: The ECS version of the networking system. Link: [https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOTS Best Practices: An extensive guide about DOTS best practices to maximize
    your game’s performance and understand DOTS internals: [https://learn.unity.com/course/dots-best-practices](https://learn.unity.com/course/dots-best-practices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ECS Samples: A Git repository containing several ECS samples and tutorials:
    [https://github.com/Unity-Technologies/EntityComponentSystemSamples](https://github.com/Unity-Technologies/EntityComponentSystemSamples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the links provided point to the ECS documentation. It’s recommended
    to read it entirely to know about all the tools you have for creating ECS applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have used input and tag components to move our player and
    component lookups to get info about other entities, and looked at diverse usages
    of entity command buffers to instantiate and destroy entities, and how to make
    our GameObject camera follow our ECS character. We also discussed different extra
    topics to deepen your DOTS knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to start using DOTS by creating our own components
    and systems to add gameplay to a simple game. We saw how to use input, and the
    DOTS transform API to move and rotate objects, and we also saw how to spawn and
    destroy objects.
  prefs: []
  type: TYPE_NORMAL
- en: DOTS is a new engine on its own, running inside Unity. The way it works is vastly
    different, and except for a few systems like the rendering pipelines, almost all
    DOTS features work very differently from their GameObject counterparts. Also,
    DOTS is still quite new, meaning it still has missing features and could be subjected
    to substantial changes in the next versions.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it a possible risk for creating new projects, but on the other hand,
    the performance it can achieve could be decisive for big and ambitious projects.
    It is an interesting piece of technology that can revolutionize game development,
    and every day, it is getting more powerful and stable. It’s a good time to start
    learning about it and be prepared for the future.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1498477041053909218.png)'
  prefs: []
  type: TYPE_IMG
