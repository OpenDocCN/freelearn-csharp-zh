- en: Using Cameras
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用相机
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating the basic scene for this chapter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建本章的基本场景
- en: Creating a picture-in-picture effect
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建画中画效果
- en: Switching between multiple cameras
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个相机之间切换
- en: Making textures from screen content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从屏幕内容制作纹理
- en: Zooming a telescopic camera
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整望远镜相机的缩放
- en: Displaying a minimap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示小地图
- en: Creating an in-game surveillance camera
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏中的监控相机
- en: Working with Unity's multi-purpose camera rig
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Unity的多用途相机装置协同工作
- en: Using Cinemachine ClearShot to switch cameras to keep the player in shot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cinemachine ClearShot切换相机以保持玩家在画面中
- en: Letting the player switch to a Cinemachine FreeLook camera
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许玩家切换到Cinemachine FreeLook相机
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As developers, we should never forget to pay attention to **Cameras**. After
    all, they are the windows through which our players see our games. In this chapter,
    we will take a look at interesting ways of using **Cameras** that enhance the
    player's experience.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们永远不应该忘记关注**相机**。毕竟，它们是我们玩家看到我们游戏窗口。在本章中，我们将探讨一些有趣的使用**相机**的方法，这些方法可以增强玩家的体验。
- en: The big picture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体情况
- en: A **Scene** can contain multiple **Cameras**. Often, we have one Main Camera
    (we're given one by default with a new Scene). For **First-Person** viewpoint
    games, we control the position and rotation of the **Camera** directly, since
    it acts as our eyes. In **Third-Personal** viewpoint games, our main **Camera**
    follows an animated 3D character (usually from above/behind/over the shoulder),
    and may slowly and smoothly change its position and rotation as if a person were
    holding the **Camera** and moving to keep us in view.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**可以包含多个**相机**。通常，我们有一个主**相机**（新场景默认提供）。对于**第一人称**视角的游戏，我们直接控制**相机**的位置和旋转，因为它充当我们的眼睛。在**第三人称**视角的游戏中，我们的主要**相机**跟随一个动画3D角色（通常是从上方/后方/肩上），并且可能缓慢而平滑地改变其位置和旋转，就像有人拿着**相机**移动以保持我们的视线一样。'
- en: 'Perspective **Cameras** have a triangular pyramid-shaped volume of space in
    front of them, called a **frustrum.** Objects inside this space are projected
    onto a plane, which determines what we see from the **Camera.** We can control
    this volume of space by specifying the clipping planes and the field of view.
    The clipping planes define the minimum and maximum distance objects have to be
    between to be considered viewable. The field of view is decided by how wide or
    narrow the pyramid shape is:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 透视**相机**前方有一个三角形金字塔形状的空间体积，称为**视锥体**。空间内的物体被投影到一个平面上，这决定了我们从**相机**看到的内容。我们可以通过指定裁剪平面和视野来控制这个空间体积。裁剪平面定义了物体之间的最小和最大距离，以确定它们是否可见。视野由金字塔形状的宽窄决定：
- en: '![](img/544a4efb-3a80-4b82-bf37-888035c50bbc.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/544a4efb-3a80-4b82-bf37-888035c50bbc.png)'
- en: 'Cameras can be customized in many ways:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相机可以通过多种方式定制：
- en: They can exclude objects on specific layers from rendering
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以排除特定层上的对象以进行渲染
- en: They can be set to render in Orthographic mode (that is, without perspective)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被设置为正交模式（即，没有透视）进行渲染
- en: They can have their **Field of View** (**FOV**) manipulated to simulate a wide-
    or narrow-angle lenses
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的**视野**（**FOV**）可以被调整以模拟广角或窄角镜头
- en: They can be rendered on top of other cameras or within specific areas of the
    screen (viewports)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被渲染在其他相机之上或屏幕的特定区域（视口）内
- en: They can be rendered into Textures files
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被渲染成纹理文件
- en: 'The list goes on. The following screenshot illustrates several of these Camera
    features. The same Scene has a perspective Camera, outputting to a viewport taking
    up the entire Game screen (from 0,0 to 1,1). On top of this is a second viewport
    for an Orthographic Camera, showing a 2D top-down view of the same Scene''s contents.
    This viewport is just the top-left quarter of the screen `(0, 0.5)` to `(0.5,
    1.0)`. The "ghost" character is on a layer that is ignored (culled) by the second
    **Orthographic** Camera:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。以下截图展示了这些相机功能中的几个。相同的场景有一个透视**相机**，输出到占据整个游戏屏幕（从0,0到1,1）的视口。在其上方是一个用于正交**相机**的第二个视口，显示相同场景内容的2D俯视图。这个视口只是屏幕的右上四分之一
    `(0, 0.5)` 到 `(0.5, 1.0)`。"幽灵"角色在一个被第二**正交**相机忽略（裁剪）的层上：
- en: '![](img/b4994613-9dc7-41e5-b6ea-45a88357a702.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4994613-9dc7-41e5-b6ea-45a88357a702.png)'
- en: '**Cameras** have a depth property. This is used by Unity to determine in what
    sequence **Cameras** are rendered. Unity renders **Cameras** starting with the
    lowest depth number, and working up to the highest. This is needed to ensure that
    **Cameras** that are not rendered to fill the whole screen are rendered after
    **Cameras** that are. You''ll see this illustrated in several recipes, including
    the picture-in-picture recipe.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**相机** 有一个深度属性。Unity使用这个属性来确定相机的渲染顺序。Unity从最低的深度数字开始渲染相机，然后逐步增加到最高的。这是为了确保那些没有渲染到整个屏幕的相机在渲染到整个屏幕的相机之后被渲染。你将在包括画中画食谱在内的几个食谱中看到这一点。'
- en: Cinemachine
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cinemachine
- en: Developed by Adam Myhill, and now available free as a Unity Package, **Cinemachine**
    is a powerful automated system for camera control. It offers much to Unity developers,
    both for **Run-Time** in-game camera control and also cinematic creation for cut
    scenes or complete animated films. We end this chapter with examples of how to
    add some **Run-Time** camera controls to your games using **Cinemachine.**
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Adam Myhill 开发，现在作为Unity包免费提供，**Cinemachine** 是一个强大的自动相机控制系统。它为Unity开发者提供了很多帮助，包括游戏运行时的相机控制和电影场景或完整动画电影的制作。我们以如何使用
    **Cinemachine** 添加一些运行时相机控制到你的游戏中的示例结束本章。
- en: At the core of Cinemachine is the concept of a set of Virtual Cameras in a Scene and
    a Cinemachine Brain component, which decides which virtual camera's properties
    should be used to control the Scene's **Main Camera**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine的核心概念是在场景中设置一组虚拟相机和一个Cinemachine Brain组件，该组件决定应该使用哪个虚拟相机的属性来控制场景的
    **主相机**。
- en: Learn more about the history and development of Cinemachine at [http://www.cinemachineimagery.com/](http://www.cinemachineimagery.com/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://www.cinemachineimagery.com/](http://www.cinemachineimagery.com/) 了解更多关于Cinemachine的历史和发展。
- en: Creating the basic scene for this chapter
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本章的基本场景
- en: All the recipes in this chapter start off with the same basic scene, featuring
    a 3D maze, some objects, and a keyboard-controllable 3D character. In this recipe,
    you'll create a project with such a scene, which can be duplicated and adapted
    for each recipe that follows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有食谱都以相同的基本场景开始，包括一个3D迷宫、一些对象和一个可由键盘控制的3D角色。在这个食谱中，你将创建一个包含此类场景的项目，该场景可以复制并适应后续的每个食谱。
- en: '![](img/a8611645-76d7-4231-8804-b8b3bd0d5a96.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8611645-76d7-4231-8804-b8b3bd0d5a96.png)'
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity package named `CamerasChapter.unity`,
    containing all the resources needed for this chapter. The package can be found
    in the `06_01` folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们准备了一个名为 `CamerasChapter.unity` 的Unity包，其中包含本章所需的所有资源。该包位于 `06_01` 文件夹中。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create the basic scene for this chapter, just follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建本章的基本场景，只需按照以下步骤操作：
- en: Create a new 3D project.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目。
- en: Import the CamerasChapter package into your Unity Project.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 CamerasChapter 包导入到你的Unity项目中。
- en: In the Project panel, you'll find three Prefabs in the `Prefabs` folder (`maze-floor-walls`,
    `maze-objects`, `character-MsLazer`). Create GameObjects for each of these three
    Prefabs by dragging the Prefabs from the Project panel into the Hierarchy or Scene
    panels.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，你会在 `Prefabs` 文件夹中找到三个预制体（`maze-floor-walls`，`maze-objects`，`character-MsLazer`）。通过将预制体从项目面板拖动到层次或场景面板中，为这三个预制体创建GameObject。
- en: You should now have a maze with a floor, some walls, some **Sphere** objects,
    a green respawn point, and the keyboard-controllable character-MsLazer 3D character.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该有一个带有地板、一些墙壁、一些 **球体** 对象、一个绿色重生点和可由键盘控制的 character-MsLazer 3D角色的迷宫。
- en: Let's attach the Scene's **Main Camera** to the character, so that you'll see
    this Third Person Controller character all the time as you move it around the
    maze. Child the Main Camera to `character-MsLazer`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将场景的 **主相机** 附接到角色上，这样你就可以在迷宫中移动角色时始终看到这个第三人称控制器角色。将主相机作为 `character-MsLazer`
    的子对象。
- en: In the Inspector, set the Main Camera Position to (0, 3, -5), and Rotation to
    (5, 0, 0).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将主相机位置设置为（0，3，-5），并将旋转设置为（5，0，0）。
- en: Now, as you use the arrow keys to move the character around the maze, the **Main
    Camera** should move and rotate automatically with the character, and you should
    be able to see the back of the character at all times.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你使用箭头键在迷宫中移动角色时，**主相机**应自动跟随角色移动和旋转，并且你应该能够始终看到角色的背面。
- en: Save and run the Scene. As you move the character, the **Main Camera** should
    move around with the character.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行场景。当你移动角色时，**主相机** 应该随着角色移动。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By cloning Prefabs, you have added a maze and some objects to an empty Scene.
    You have also added a keyboard-controller character to the Scene.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过克隆预制体，你将迷宫和一些对象添加到了一个空场景中。你还将一个键盘控制器角色添加到了场景中。
- en: By childing the **Main Camera** to the character GameObject, the **Main Camera**
    maintains the same position and rotation relative to the character at all times.
    Therefore, as the character moves so does the **Main Camera****,** giving a simple,
    over-the-shoulder type viewpoint for the game action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将**主相机**作为子对象附加到角色GameObject，**主相机**始终相对于角色保持相同的位置和旋转。因此，随着角色的移动，**主相机**也会移动**，为游戏动作提供了一个简单、肩上视角**。
- en: Creating a picture-in-picture effect
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建画中画效果
- en: 'Having more than one viewport displayed can be useful in many situations. For
    example, you may want to show simultaneous events going on in different locations,
    or you may want to have a separate window for hot-seat multiplayer games:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，显示多个视口可能很有用。例如，你可能想显示在不同地点同时发生的事件，或者你可能想为热座多人游戏有一个单独的窗口：
- en: '![](img/ecea56b2-9da5-463d-bd88-73ca4c01cbd6.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecea56b2-9da5-463d-bd88-73ca4c01cbd6.png)'
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是在本章第一个配方创建的场景的基础上添加的，所以请复制那个项目文件夹，并使用该副本进行这个配方的操作。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a picture-in-picture display, just follow these steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建画中画显示，只需按照以下步骤操作：
- en: 'Add a new Camera to the scene named `Camera-pic-in-pic`. Choose menu: Create
    | Camera.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个名为`Camera-pic-in-pic`的新相机。选择菜单：创建 | 相机。
- en: In the Inspector, for the `Camera` component, set the Depth property to `1`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，对于`相机`组件，将深度属性设置为`1`。
- en: Uncheck or remove the camera's Audio Listener component, since there should
    only be one active Audio Listener in a Scene.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中或删除相机的音频监听器组件，因为场景中应该只有一个活动的音频监听器。
- en: 'Create a new C# script-class named `PictureInPicture`, and add an instance-object
    as a component to the Camera-pic-in-pic GameObject:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类名为`PictureInPicture`，并将实例对象作为组件添加到`Camera-pic-in-pic`GameObject：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the Inspector, change some of the Picture In Picture (Script) parameters:
    choose top and right for vertical and horizontal alignment. Choose 0.25 for vertical
    and horizontal percentage.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，更改一些画中画（脚本）参数：选择顶部和右侧作为垂直和水平对齐。选择0.25作为垂直和水平百分比。
- en: Play your Scene. In the Game panel, your picture-in-picture Camera's viewport
    should be visible in the top-left corner of the screen, taking up a quarter (25%)
    of the screen.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的场景。在游戏面板中，你的画中画**相机**的视口应该在屏幕的左上角可见，占据屏幕的四分之一（25%）。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, you added a second **Camera** in order to display the scene
    from a different point of view.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你添加了一个第二个**相机**，以便从不同的视角显示场景。
- en: The default Main Camera has the default `depth` of `0`. You set the depth for
    our Camera-pic-in-pic to `1`, so the **Main Camera** is rendered first, covering
    the whole Game window, and then our second Camera (picture-in-picture) is rendered
    last, on top of the Main Camera rendering.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认主相机的默认`深度`为`0`。你将我们的`Camera-pic-in-pic`的深度设置为`1`，因此**主相机**首先渲染，覆盖整个游戏窗口，然后我们的第二个相机（画中画）最后渲染，位于主相机渲染之上。
- en: The Picture In Picture script changes the camera's Normalized Viewport Rect,
    thus resizing and positioning the viewport according to the user's preferences.
    The four values of Vertical and Horizontal Alignment, plus `width` and `height`
    percentage, are used to create a rectangle in the (0,0) - (1.0, 1.0) **normalized**
    coordinates of the the Game panel. The `rect` property of the **Camera** is set
    to the new rectangle calculated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 画中画脚本更改相机的标准化视口矩形，从而根据用户的偏好调整视口的尺寸和位置。垂直和水平对齐的四个值，加上`宽度`和`高度`百分比，用于在游戏面板的（0,0）-（1.0,
    1.0）**标准化**坐标中创建一个矩形。**相机**的`rect`属性被设置为计算出的新矩形。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following are some aspects of your picture-in-picture that you could change.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可能更改的画中画的一些方面。
- en: Changing the size and location of the picture-in-picture viewport on the screen
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上更改画中画视口的尺寸和位置
- en: You can change the **size** of the picture-in-picture rectangle by setting the
    horizontal and vertical percentage values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过设置水平和垂直百分比值来更改画中画矩形的**大小**。
- en: The Vertical Alignment and Horizontal Alignment options can be used to change
    the viewport's vertical and horizontal alignment. Use them to place it where you
    wish, such as top-left, bottom-right, center-center, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直对齐和水平对齐选项可以用来改变视口的垂直和水平对齐。使用它们将其放置在所需的位置，例如左上角、右下角、中心中心等。
- en: Adding further contols for depth-of-field and aspect-ratio
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对景深和宽高比的进一步控制
- en: 'You can add additional public variables to the code, and corresponding **Camera**
    adjustments, for **field-of-view**, **aspect ratio**, and so on:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向代码中添加额外的公共变量，并对应地进行**视野**、**宽高比**等**相机**调整：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The camera field-of-view is how much of the world the camera captures; often,
    we think of this as how wide or narrow our view is. Learn more at [https://en.wikipedia.org/wiki/Field_of_view](https://en.wikipedia.org/wiki/Field_of_view)
    and  [https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html](https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 相机视野是指相机捕捉到的世界范围；通常，我们将其视为视野的宽窄。更多信息请参阅[https://en.wikipedia.org/wiki/Field_of_view](https://en.wikipedia.org/wiki/Field_of_view)和[https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html](https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html)。
- en: Camera aspect ratio is the relationship of the width to the height of the rectangle.
    It is calculated as the width divided by the height. Learn more at [https://docs.unity3d.com/ScriptReference/Camera-aspect.html](https://docs.unity3d.com/ScriptReference/Camera-aspect.html)
    and [https://en.wikipedia.org/wiki/Aspect_ratio_(image)](https://en.wikipedia.org/wiki/Aspect_ratio_(image)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相机宽高比是矩形宽度与高度的关系。它是通过宽度除以高度来计算的。更多信息请参阅[https://docs.unity3d.com/ScriptReference/Camera-aspect.html](https://docs.unity3d.com/ScriptReference/Camera-aspect.html)和[https://en.wikipedia.org/wiki/Aspect_ratio_(image)](https://en.wikipedia.org/wiki/Aspect_ratio_(image))。
- en: Manually changing Camera viewport properties in the Inspector
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在检查器中手动更改相机视口属性
- en: 'Once you are happy working with the normalized viewport coordinate system of
    (0,0) to (1.0, 1.0), you can manually edit **Camera Viewport** settings for the Camera component
    directly in the Inspector, without having to use any C# script-classes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了使用(0,0)到(1.0, 1.0)的标准化视口坐标系，你就可以直接在检查器中手动编辑**相机视口**设置，而不需要使用任何C#脚本类：
- en: '![](img/82251c09-f35d-442d-af9e-18ef299d4c9b.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82251c09-f35d-442d-af9e-18ef299d4c9b.png)'
- en: See also
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying a minimap* recipe in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的**显示迷你图**配方。
- en: Switching between multiple cameras
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个相机之间切换
- en: 'Choosing from a variety of cameras is a common feature in many genres: racing,
    sports, tycoon/strategy, and many others. In this recipe, you will learn how to
    give players the ability to choose from many cameras by using their keyboards.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏类型中，从多种相机中选择是一个常见功能：赛车、体育、大亨/策略等。在本配方中，你将学习如何通过使用键盘让玩家能够从许多相机中进行选择。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方是在本章第一配方创建的场景基础上进行的，因此请复制那个项目文件夹，并使用该副本来完成本配方的操作。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To implement switchable cameras, follow these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现可切换的相机，请按照以下步骤操作：
- en: Create a new Camera in the Scene named Camera-1 (Create | Camera). Set its position
    to (`0,0,0`). Set the Tag for this Camera to be **MainCamera**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的相机，命名为Camera-1（创建 | 相机）。将其位置设置为(`0,0,0`)。将此相机的标签设置为**主相机**。
- en: Duplicate Camera-1, naming the copy Camera-2\. Set its Position to (`0, 0, -15`),
    and its Rotation to (`20, 0, 0`).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Camera-1，将副本命名为Camera-2。将其位置设置为(`0, 0, -15`)，并将其旋转设置为(`20, 0, 0`)。
- en: Disable the Camera and AudioListener components for both Camera-1 and Camera-2.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用Camera-1和Camera-2的相机和AudioListener组件。
- en: Create an empty GameObject named switchboard (Create | Create Empty).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为switchboard的空GameObject（创建 | 创建空对象）。
- en: 'Create a new C# script-class named `CameraSwitch` containing the following,
    and add an object-instance as a component to the switchboard GameObject:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CameraSwitch`的新C#脚本类，包含以下内容，并将其作为组件添加到switchboard GameObject中：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Ensure the switchboard GameObject is selected in the Hierarchy. In the Inspector
    for the Camera Switch (Script) component, set the size of the **Cameras** array
    to `3`. Then, drag and populate the **Camera** slots with the cameras from the
    scene, including the **Main Camera **and the child of the MsLazer character:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次结构中选择**开关板**GameObject。在相机切换（脚本）组件的检查器中，将**相机**数组的大小设置为`3`。然后，将场景中的相机拖动并填充到**相机**槽中，包括**主相机**和MsLazer角色的子对象：
- en: '![](img/a7fc2a89-2722-487d-a9b0-95da84fe2dcc.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7fc2a89-2722-487d-a9b0-95da84fe2dcc.png)'
- en: Save and Play the scene. Pressing keys *0*, *1*, and *2* should switch between
    each of the three **Cameras.**
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并播放场景。按下键*0*、*1*和*2*应在三个**相机**之间切换。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each frame, a test is made for each of the three shortcut key presses (0, 1,
    or 2). If one of those keys has been pressed, then the corresponding **Camera**
    is enabled, and the other two **Cameras** are disabled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧，都会对三个快捷键（0、1或2）中的每一个进行测试。如果按下了这些键中的任何一个，则相应的**相机**被启用，而其他两个**相机**被禁用。
- en: If the public Boolean property `changeAudioListener` has been checked, then
    the `AudioListener` inside the selected Camera is enabled and the `AudioListeners`
    in the other two Cameras are disabled.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公共布尔属性`changeAudioListener`已被勾选，则所选相机内的`AudioListener`被启用，而其他两个**相机**中的`AudioListeners`被禁用。
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some ideas about how you could try adapting this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于如何尝试调整这个食谱的想法。
- en: Using a single-enabled camera
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单个启用的相机
- en: A different approach to the problem would be keeping all secondary cameras disabled
    and assigning their position and rotation to the **Main Camera** via a script-class
    (you would need to make a copy of the **Main Camera** and add it to the list,
    in case you wanted to save its Transform settings). This is similar to the virtual
    **Camera** properties applied to the **Main Camera** approach that the `Cinemachine`
    package implements (see the last two recipes in this chapter to learn more about
    `Cinemachine`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法是将所有辅助相机禁用，并通过脚本类将它们的位置和旋转分配给**主相机**（如果你想要保存其变换设置，你需要复制**主相机**并将其添加到列表中）。这与`Cinemachine`包实现的将虚拟**相机**属性应用于**主相机**的方法类似（参见本章最后两个食谱，了解更多关于`Cinemachine`的信息）。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The Creating an in-game surveillance camera recipe in this chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中创建游戏内监控相机食谱。
- en: Making textures from screen content
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从屏幕内容制作纹理
- en: 'If you want your game or player to take in-game snapshots and apply them as
    textures, this recipe will show you how. This can be very useful if you plan to
    implement an in-game photo gallery or display a snapshot of a key moment at the
    end of a level (racing games and stunt simulations use this feature a lot). For
    this particular example, we will take a snapshot of a framed region of the screen
    and print it in the top-right corner of the display:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要你的游戏或玩家在游戏中捕捉快照并将其作为纹理应用，这个食谱将向你展示如何操作。如果你计划实现游戏内照片库或在关卡结束时显示关键时刻的快照，这将非常有用（赛车游戏和特技模拟大量使用此功能）。对于这个特定的例子，我们将捕捉屏幕的一个框架区域并将其打印在显示器的右上角：
- en: '![](img/fefcf742-7a2f-4b0c-a22e-40be43be685f.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fefcf742-7a2f-4b0c-a22e-40be43be685f.png)'
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱增加了本章第一个食谱中创建的场景，所以请复制那个项目文件夹，并使用该副本来完成这个食谱的工作。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create textures from screen content, follow these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要从屏幕内容创建纹理，请按照以下步骤操作：
- en: 'In the Hierarchy, create a new **UI Image** named **Image-frame** by choosing
    the following from the **Hierarchy** panel menu: Create | UI | Image. Since this
    is the first UI GameObject to be created in this Scene, new Canvas and `EventSystem`
    GameObjects should be created automatically, and the Image-frame UI should be
    a child of the Canvas GameObject.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，通过选择以下内容从**层次结构**面板菜单创建一个新的**UI Image**，命名为**Image-frame**：创建 | UI |
    Image。由于这是在此场景中创建的第一个UI GameObject，应自动创建新的Canvas和`EventSystem`GameObject，Image-frame
    UI应成为Canvas GameObject的子对象。
- en: From the Inspector panel, find the Image (Script) component of the frame GameObject
    and set `InputFieldBackground` as its **Source Image**. Also, uncheck the **Fill
    Center** option.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从检查器面板中，找到frame GameObject的Image（脚本）组件，并将其**源图像**设置为`InputFieldBackground`。同时，取消选中**填充中心**选项。
- en: Sprite `InputFieldBackground` comes bundled with Unity, and it's already sliced
    for resizing purposes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite `InputFieldBackground`是Unity附带的一部分，并且已经为了调整大小而切片。
- en: Set the Anchors for Image-frame to: Min (`0.25`), (`0.25`); Max (`0.75`), (`0.750`).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为图像框架设置锚点：**最小**(`0.25`)，(`0.25`)；**最大**(`0.75`)，(`0.750`)。
- en: 'Zero the Position (Left: `0`, Top: `0`, Pos Z: `0`) and Size (Width: `0`, Height:
    `0`).'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位置（左：`0`，上：`0`，位置Z：`0`）和大小（宽度：`0`，高度：`0`）归零。
- en: 'The **Image-frame** GameObject should appear in the center of the screen, taking
    up half the screen:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图像框架**GameObject应出现在屏幕中央，占据屏幕的一半：'
- en: '![](img/e7e24165-9431-4a03-8774-031a77737a57.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7e24165-9431-4a03-8774-031a77737a57.png)'
- en: 'In the Hierarchy, create a new **UI Raw Image** named **RawImage-Photo** by
    choosing the following from the **Hierarchy** panel menu: **Create** | **UI**
    | **RawImage****.** Ensure its **Texture** is **None** for its **Raw Image (Script)**
    component.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，通过从**层次结构**面板菜单中选择以下内容创建一个新的**UI原始图像**名为**原始图像-照片**：**创建** | **UI** |
    **原始图像**。确保其**纹理**对于其**原始图像（脚本）**组件为**无**。
- en: In the **Inspector,** now disable the entire **RawImage-Photo** GameObject.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，现在禁用整个**原始图像-照片**GameObject。
- en: 'Set the **Width** and **Height** to `1`. Set the Anchors for **RawImage-Photo**
    to: **Min** (`0`), (`1`); **Max** (`0`), (`1`).'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**宽度**和**高度**设置为`1`。为**原始图像-照片**设置锚点：**最小**(`0`)，(`1`)；**最大**(`0`)，(`1`)。
- en: Set the **Pivot** to `(0, 1)`. And zero the Position by setting **Left** to `0`,
    **Top** to `0`, and **Z** to `0`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**原点**设置为`(0, 1)`。并通过将**左**设置为`0`，**上**设置为`0`，**Z**设置为`0`来归零位置。
- en: Create a new C# script-class named `TextureFromCamera,` and add an instance-object
    as a component to the **Main Camera** GameObject (child of `MsLazer):`
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类名为`TextureFromCamera`，并将实例对象作为组件添加到**主相机**GameObject（`MsLazer`的子对象）中：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the **Inspector,** find the **Screen Texture** component and populate the Raw
    Image Photo field with **GameObject****RawImage-Photo;** and the **Image Frame** field with
    the **Image-frame** GameObject.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，找到**屏幕纹理**组件，并将**原始图像照片**字段填充为**GameObject** **原始图像-照片**；并将**图像框架**字段设置为**图像框架**GameObject。
- en: Play the **Scene**. Each time you click the mouse, you'll take a snapshot of
    the screen within the rectangular frame, and the snapshop should be displayed
    in the top-left of the screen.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放**场景**。每次您点击鼠标，您都会在矩形框架内捕获屏幕的快照，并且快照应该显示在屏幕的左上角。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we created a UI frame from which to take a snapshot, and a UI Raw Image
    at the top-left of the screen, onto which to apply the snapshot textures.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个用于捕获快照的UI框架，以及一个位于屏幕左上角的UI原始图像，用于应用快照纹理。
- en: Each frame, the `LateUpdate()` method of C# script-class `TextureFromCamera`
    is executed. Each time this happens a test is made to see whether the mouse button
    has been clicked. If it has, then the UI Raw Image is disabled (so previous snapshots
    don't appear in new snapshots) and the `CaptureScreen()` coroutine method is invoked.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧，C#脚本类`TextureFromCamera`的`LateUpdate()`方法都会执行。每次发生这种情况时，都会进行测试以查看是否点击了鼠标按钮。如果是，则禁用UI原始图像（这样以前的快照就不会出现在新的快照中），并调用`CaptureScreen()`协程方法。
- en: We use `LateUpdate()` here to ensure all rendering has been completed before
    we capture the image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`LateUpdate()`来确保在捕获图像之前所有渲染都已经完成。
- en: Coroutine `CaptureScreen()` calculates a `Rect` area, copies screen pixels from
    that area, and applies them to a texture to be displayed by the **UI Raw Image**
    element, which is also resized to fit the texture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 协程`CaptureScreen()`计算一个`Rect`区域，从该区域复制屏幕像素，并将它们应用于要由**UI原始图像**元素显示的纹理，该元素也被调整大小以适应纹理。
- en: The size of the `Rect` is calculated from the screen's dimensions and the frame's
    Rect Transform settings, particularly its Pivot, Anchors, Width, and Height. The
    screen pixels are then captured by the `ReadPixels()` command and applied to the
    texture, which is then applied to the Raw Image photo, which is itself resized
    to fit the desired ratio between the photo size and the original pixels.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect`的大小是根据屏幕尺寸和框架的Rect Transform设置计算的，特别是其原点，锚点，宽度和高度。然后，通过`ReadPixels()`命令捕获该区域的屏幕像素，并将其应用于纹理，然后将纹理应用于原始图像照片，该照片本身被调整大小以适应照片大小和原始像素之间的所需比例。'
- en: The `CaptureScreen()` method is a coroutine, which allows it to wait until the
    end of a frame (`yield return new WaitForEndOfFrame()`), before attempting to
    capture a copy of the image from the **Camera.**
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CaptureScreen()`方法是一个协程，它允许它等待直到帧的结束（`yield return new WaitForEndOfFrame()`），然后再尝试从**相机**捕获图像的副本。'
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from displaying the texture as a UI element, you can use it in other ways.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将纹理显示为UI元素外，你还可以以其他方式使用它。
- en: Applying your texture to a material
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的纹理应用到材质上
- en: You can apply your texture to an existing object's material by adding a line
    similar to `GameObject.Find("MyObject").renderer.material.mainTexture`= texture to
    the end of the `CaptureScreen` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`CaptureScreen`方法的末尾添加类似`GameObject.Find("MyObject").renderer.material.mainTexture
    = texture`的行，将你的纹理应用到现有对象的材质上。
- en: Using your texture as a screenshot
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用你的纹理作为截图
- en: 'You can encode your texture as a PNG image file and save it. This is explored
    in the Unity documentation pages about encoding PNG images: [https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html](https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的纹理编码为PNG图像文件并保存。这可以在Unity文档页面中关于编码PNG图像的部分找到：[https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html](https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html)。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The Saving screenshots from the game recipe in Chapter 10, *Working with External
    Resource Files and Devices*, Saving and Loading Data Files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章“与外部资源文件和设备一起工作”，保存和加载数据文件中，有关从游戏中保存截图的菜谱。
- en: Zooming a telescopic camera
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放望远镜相机
- en: In this recipe, we will create a telescopic camera that zooms in whenever the
    left mouse button is pressed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个望远镜相机，每当按下左鼠标按钮时，它就会放大。
- en: Getting ready...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作...
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱增加了本章第一个菜谱中创建的场景，所以请复制那个项目文件夹，并使用该副本来完成这个菜谱的工作。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a telescopic camera, follow these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个望远镜相机，请按照以下步骤操作：
- en: 'Create a new C# script-class named `TelescopicView`, and add an instance-object
    as a component to the **Main Camera** (child of `MsLazer`):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类名为`TelescopicView`，并将一个实例对象作为组件添加到**主相机**（`MsLazer`的子对象）：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Play the level. You should see an animated zooming effect when you click and
    hold the right mouse button.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡。当你点击并按住右鼠标按钮时，你应该会看到一个动画缩放效果。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The zooming effect is actually caused by changes to the value of the camera's
    **Field Of View** (**FOV**) property; small values result in closer views of a
    smaller area, while larger values enlarge the FOV.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放效果实际上是由相机**视野**（**FOV**）属性值的改变引起的；较小的值会导致较小区域的更近距离视图，而较大的值会扩大FOV。
- en: The `TelescopicView` script-class changes the camera's field of view by reducing
    it whenever the left mouse button is pressed. It also adds to the FOV value when
    the right mouse button is not being held, until it reaches its original value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`TelescopicView`脚本类通过在按下左鼠标按钮时减少视野（FOV）来改变相机的视野。当不按住右鼠标按钮时，它还会增加FOV值，直到达到原始值。'
- en: The zoom limit of the FOV can be deduced from the `minFov = initFov / zoom` code.
    This means that the minimum value of the FOV is equal to its original value divided
    by the zoom amount. For instance, if our **Camera** originally features an FOV
    of 60, and we set the **Telescopic View Zoom** amount to `2.0`, the minimum FOV
    allowed will be 60/2 = 30.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: FOV的缩放限制可以从`minFov = initFov / zoom`代码中推断出来。这意味着FOV的最小值等于其原始值除以缩放量。例如，如果我们的**相机**原始FOV为60，我们将**望远镜视图缩放**设置为`2.0`，则允许的最小FOV将是60/2
    = 30。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Adding a vignette effect when you zoom
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在缩放时添加晕影效果
- en: 'Often in games, a visual vignette effect is applied at the same time as camera
    zooming. Vignetting is when the edges of an image are made less bright or more
    blurred (often in an oval or circular shape). It used to be an unintended (and
    often unwanted) effect of older cameras and lenses, but can be purposely applied
    in games to help the player focus on the content at the center of the screen,
    and to add a more intense atmosphere at a certain point in the game:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，通常在相机缩放的同时应用视觉晕影效果。晕影是指图像边缘变得不那么明亮或更加模糊（通常是椭圆形或圆形）。这曾经是旧相机和镜头的一个意外（并且通常是希望避免的）效果，但可以在游戏中有意应用，以帮助玩家专注于屏幕中央的内容，并在游戏中的某个特定点增加更强烈的氛围：
- en: '![](img/1fbf8906-51a5-4ae8-a2ca-382bb363e4b0.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fbf8906-51a5-4ae8-a2ca-382bb363e4b0.png)'
- en: 'To add a vignette effect, do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加晕影效果，请执行以下操作：
- en: Open the Asset Store panel, then download and import the free Post-Processing
    Stack assets published by Unity Technologies.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开资产商店面板，然后下载并导入Unity Technologies发布的免费后处理堆栈资产。
- en: In the Inspector, select the Main Camera GameObject (child of **MsLazer**).
    Then, add a Post-Processing Behaviour component. Go to Add Component | Effects
    | Post-Processing Behaviour.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，选择主摄像机GameObject（`MsLazer`的子对象）。然后，添加一个后处理行为组件。转到添加组件 | 效果 | 后处理行为。
- en: 'In the Project panel, create a new Post-Processing Profile file named my-vignette by
    choosing the following from the Project panel menu: Create | Post-Processing Profile.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，通过选择项目面板菜单中的创建 | 后处理配置文件，创建一个名为`my-vignette`的新后处理配置文件。
- en: 'With the `my-vignette` file selected in the Project panel, in the Inspector,
    check the my-vignette effect and click it once to reveal its properties. Set its
    properties as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中选择`my-vignette`文件，在检查器中勾选my-vignette效果并单击一次以显示其属性。设置其属性如下：
- en: 'Center: (X: 0.5, Y: 0.5)'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '中心：(X: 0.5, Y: 0.5)'
- en: 'Intensity: 0.75'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强度：0.75
- en: 'Smoothness: 0.5'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平滑度：0.5
- en: 'Roundness: 1'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆度：1
- en: With the **Main Camera** selected in the **Inspector,** drag the `my-vignette` file from
    the **Project** panel into the **Inspector** to populate the **Profile** property
    of the **Post-Processing Behaviour** component.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中选择**主摄像机**，从**项目**面板中将`my-vignette`文件拖到**检查器**中，以填充**后处理行为**组件的**配置文件**属性。
- en: You should now see the dark, fuzzy vignetting circular effect around the edges
    of the **Game** panel camera view.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该看到**游戏**面板摄像机视图边缘的暗模糊晕影圆形效果。
- en: In the **Inspector,** select the **Main Camera** and disable its **Post-Processing
    Behaviour** component (uncheck the box for this component in the **Inspector).**
    We'll be enabling this effect in the script only when the zoom effect is switched
    on.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，选择**主摄像机**并禁用其**后处理行为**组件（在**检查器**中取消勾选此组件）。**我们将在脚本中仅当缩放效果开启时启用此效果**。
- en: 'Add a new using statement at the top of the `TelescopicView` script-class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TelescopicView`脚本类顶部添加一个新的using语句：
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a new private variable to the `TelescopicView` script-class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TelescopicView`脚本类中添加一个新的私有变量：
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add a statement to get and store a reference to the **Post-Processing Behaviour**
    component at the end of the `Start()` method in the `TelescopicView` script-class:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TelescopicView`脚本类的`Start()`方法末尾添加一个语句以获取并存储对**后处理行为**组件的引用：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add statements in the `Update()` method of script-class `TelescopicView,` to
    enable the Post-Processing Behaviour when the mouse key is pressed and disable
    it when not pressed:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本类`TelescopicView`的`Update()`方法中添加语句，以在鼠标按键按下时启用后处理行为，在未按下时禁用它：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Play the Scene. You should see an animated vignette effect, in addition to the
    zooming, when the mouse button is clicked and held.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。当鼠标按钮被点击并保持时，你应该会看到除了缩放效果外，还有一个动画晕影效果。
- en: 'Learn more about the Vignette effect and the Post-processing Stack in the Unity
    documentation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity文档中了解更多关于晕影效果和后处理堆栈的信息：
- en: '[https://docs.unity3d.com/Manual/PostProcessing-Vignette.html](https://docs.unity3d.com/Manual/PostProcessing-Vignette.html)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Manual/PostProcessing-Vignette.html](https://docs.unity3d.com/Manual/PostProcessing-Vignette.html)'
- en: '[https://docs.unity3d.com/Manual/PostProcessing-Stack.html](https://docs.unity3d.com/Manual/PostProcessing-Stack.html)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Manual/PostProcessing-Stack.html](https://docs.unity3d.com/Manual/PostProcessing-Stack.html)'
- en: Going further with version 2 of the Unity Post Processing Stack
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步了解Unity后处理堆栈的版本2
- en: At the time of printing, Unity have published an experimental version 2 of their
    Post Processing Stack.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印时，Unity发布了他们后处理堆栈的实验性版本2。
- en: 'To add a vignette effect, do the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加晕影效果，请执行以下操作：
- en: Select the **Main Camera** in the **Inspector** (child of `MsLazer`). In the
    **Inspector,** create a new **Layer** named `PostProcessing,` and set the **Layer**
    of the **Main Camera** to **PostProcessing**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中选择**主摄像机**（`MsLazer`的子对象）。在**检查器**中创建一个名为`PostProcessing`的新**层**，并将**主摄像机**的**层**设置为**PostProcessing**。
- en: Download the ZIP from the Unity GitHub account at [https://github.com/Unity-Technologies/PostProcessing](https://github.com/Unity-Technologies/PostProcessing).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity GitHub账户[https://github.com/Unity-Technologies/PostProcessing](https://github.com/Unity-Technologies/PostProcessing)下载ZIP文件。
- en: Then, unzip the folder into your project's Assets folder.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将文件夹解压到项目 Assets 文件夹中。
- en: Add a Post-Process Layer component to the **Main Camera**. Do this in the **Inspector**
    by clicking **Add Component** | **Rendering** | **Post Process Layer**. Set the
    **Layer** property of this component to **Post Processing**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后处理层组件添加到 **主相机**。在 **检查器** 中通过点击 **添加组件** | **渲染** | **后处理层** 来完成此操作。将此组件的
    **层** 属性设置为 **后处理**。
- en: Now, add a **Post-process Volume Component** by clicking **Add Component** |
    **Rendering** | **Post Process Volume**. Check the Is Global property. Create
    a New profile (click the New button). Then, click the Add Effect... button and
    choose Vignette from the drop-down menu.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击 **添加组件** | **渲染** | **后处理体积** 来添加一个 **后处理体积组件**。检查 Is Global 属性。创建一个新的配置文件（点击新建按钮）。然后，点击添加效果...按钮，从下拉菜单中选择
    Vignette。
- en: 'Add a using statement at the top of the `TelescopicView` script-class:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TelescopicView` 脚本类顶部添加一个 using 语句：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add two more properties to the `TelescopicView` script-class:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `TelescopicView` 脚本类添加两个额外的属性：
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following statements to the end of the `Start()` method of script-class
    `TelescopicView`, in order to get a reference to the Vignette effect in the Post-Processing
    Volume component:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下语句添加到脚本类 `TelescopicView` 的 `Start()` 方法末尾，以便在 Post-Processing Volume 组件中获取
    Vignette 效果的引用：
- en: '[PRE11]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following statements to the end of the `Update()` method of script-class
    `TelescopicView,` in order to update the vignette settings:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下语句添加到脚本类 `TelescopicView` 的 `Update()` 方法末尾，以便更新 Vignette 设置：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Play the Scene. You should see an animated vignette effect, in addition to the
    zooming, when the mouse button is clicked and held.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。当鼠标按钮被点击并按住时，你应该会看到一个动画的 Vignette 效果，除了缩放效果。
- en: 'Learn more about this new version at the following locations:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下位置了解更多关于这个新版本的信息：
- en: 'The project Wiki: [https://github.com/Unity-Technologies/PostProcessing/wiki](https://github.com/Unity-Technologies/PostProcessing/wiki)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 Wiki：[https://github.com/Unity-Technologies/PostProcessing/wiki](https://github.com/Unity-Technologies/PostProcessing/wiki)
- en: 'Unity GitHub account from which to download it: [https://github.com/Unity-Technologies/PostProcessing](https://github.com/Unity-Technologies/PostProcessing)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载它的 Unity GitHub 账户：[https://github.com/Unity-Technologies/PostProcessing](https://github.com/Unity-Technologies/PostProcessing)
- en: 'This article about scripting with the Post Processing Stack v2 by Juan Sebastian
    Munoz Arango: [http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/](http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Juan Sebastian Munoz Arango 使用 Post Processing Stack v2 编写的文章：[http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/](http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/)
- en: Displaying a minimap
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示小地图
- en: 'In many games, a broader view of the scene can be invaluable for navigation
    and information. Minimaps are great for giving players that extra perspective
    that they may need when in first- or third-person mode. In this recipe, we''ll
    first create a simple square minimap that appears at the top-right of the screen;
    then, you''ll learn how to make it circular and add a rotating compass effect:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏中，更宽的视野对于导航和信息非常有价值。小地图对于在第一人称或第三人称模式下提供玩家可能需要的额外视角非常有用。在这个配方中，我们首先创建一个简单的方形小地图，它出现在屏幕的右上角；然后，你将学习如何将其变为圆形并添加旋转罗盘效果：
- en: '![](img/efbb987f-89dc-4ca1-9e59-f7877904b412.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efbb987f-89dc-4ca1-9e59-f7877904b412.png)'
- en: Getting ready...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中...
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是在本章第一个配方创建的场景基础上添加的，所以请复制那个项目文件夹，并使用该副本来完成这个配方的制作。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a minimap, follow these steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建小地图，请按照以下步骤操作：
- en: From the **Hierarchy** panel, create a new UI Panel object (Create | UI | Panel)
    named `Panel-miniMap`. Since this is the first UI GameObject to be created in
    this Scene, new Canvas and `EventSystem` GameObjects should be created automatically,
    and the UI Panel should be a child of the Canvas GameObject.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 面板中创建一个新的 UI Panel 对象（创建 | UI | Panel），命名为 `Panel-miniMap`。由于这是在这个场景中创建的第一个
    UI GameObject，应该会自动创建新的 Canvas 和 `EventSystem` GameObject，UI Panel 应该是 Canvas
    GameObject 的子对象。
- en: 'With the `Panel-miniMap` GameObject selected in the **Inspector,** do the following:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 中选择 `Panel-miniMap` GameObject，执行以下操作：
- en: In the Rect Transform, set the alignment to top-right (click the top-right box
    while holding down the Shift and Alt keys)
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rect Transform 中，设置对齐方式为右上角（在按住 Shift 和 Alt 键的同时点击右上角框）
- en: In the Rect Transform, set Width to `128` and Height to `128`
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在矩形变换中，将宽度设置为`128`，高度设置为`128`
- en: We'll create a Render Texture file to which our minimap Camera will copy its
    view. In the **Project** panel, create a new Render Texture and name it `RenderTextureMap.`
    In the **Inspector,** ensure its Size is set to 256 x 256.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个渲染纹理文件，我们的缩略图相机将复制其视图。在**项目**面板中，创建一个新的渲染纹理并将其命名为`RenderTextureMap`。在**检查器**中，确保其大小设置为256
    x 256。
- en: In the **Inspector,** select GameObject Panel-minimap and add a new child UI
    Raw Image named `RawImage-TextureMap` (Create | UI | Raw Image).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，选择GameObject面板-minimap并添加一个新的子UI原始图像，命名为`RawImage-TextureMap`（创建 |
    UI | 原始图像）。
- en: For the UI `RawImage-TextureMap` GameObject, populate the Source Image field
    with the `RenderTextureMap` image. This means when our minimap Camera updates
    its view to the Render Texture, what the **Camera** sees will be automatically
    displayed in this UI Raw Image.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于UI `RawImage-TextureMap` GameObject，将源图像字段填充为`RenderTextureMap`图像。这意味着当我们的缩略图相机更新其视图到渲染纹理时，**相机**所看到的内容将自动显示在这个UI原始图像中。
- en: 'After ensuring UI Raw `Image-RenderTextureMap` is a child of `Panel-minimap,`
    make it fill the whole panel by choosing **Stretch** for both the vertical and
    horizontal axes in the Rect Transform (while holding down the Shift and Alt keys):'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确保UI原始`Image-RenderTextureMap`是`Panel-minimap`的子项后，通过在矩形变换中选择**拉伸**来使它填充整个面板，同时按住Shift和Alt键：
- en: '![](img/73bd3b55-b8a7-4901-8055-446295cddd11.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73bd3b55-b8a7-4901-8055-446295cddd11.png)'
- en: From the **Hierarchy** panel, create a new Camera **(****Create** | **Camera****)**
    and rename it `Camera-minimap.` Uncheck (or remove) the camera's **Audio Listener**
    component, since there should only be one active **Audio Listener** in a **Scene**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次**面板中，创建一个新的相机**（创建** | **相机**）**，并将其重命名为`Camera-minimap`。取消选中（或移除）相机的**音频监听器**组件，因为在**场景**中应该只有一个活动的**音频监听器**。
- en: 'In the Hierarchy child `Camera-minimap` to the `character-MsLazer` character. 
    Then, in the **Inspector,** set its properties as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构子项`Camera-minimap`到`character-MsLazer`角色。然后，在**检查器**中，设置其属性如下：
- en: 'Position: `(0, 10, 0)`'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：`(0, 10, 0)`
- en: 'Rotation: `(90, 0, 0)`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转：`(90, 0, 0)`
- en: 'Clear Flags: Depth Only'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除标志：仅深度
- en: 'Projection: Orthographic'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影：正交
- en: 'Camera: Size: 5 (default)'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机：大小：5（默认）
- en: 'Depth: 1 (or higher)'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度：1（或更高）
- en: 'Target Texture: RenderTextureMap'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标纹理：`RenderTextureMap`
- en: 'Play the Scene. You should be able to see the square-shaped minimap functioning
    in the top-right corner of the screen:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。你应该能够在屏幕右上角看到正方形缩略图的功能：
- en: '![](img/dc403a8d-3ef3-4efa-b825-fd5a1ea589bb.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc403a8d-3ef3-4efa-b825-fd5a1ea589bb.png)'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main element of the minimap is a UI Raw Image element `(RawImage-TextureMap),`
    displaying the contents of the Render Texture file named `RenderTextureMap.`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 缩略图的主要元素是一个UI原始图像元素`(RawImage-TextureMap)`，显示名为`RenderTextureMap`的渲染纹理文件的内容。
- en: You created a second Camera in the Scene `(Camera-minimap),` and set its Target
    Texture to the `RenderTextureMap` file; this means that the view seen by the Camera
    updates the contents of `RenderTextureMap` each frame, which in turn is then displayed
    to the user in UI `RawImage-TextureMap.`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你在场景中创建了一个第二个相机`(Camera-minimap)`，并将其目标纹理设置为`RenderTextureMap`文件；这意味着相机的视图在每一帧更新`RenderTextureMap`的内容，然后这些内容再通过UI
    `RawImage-TextureMap`显示给用户。
- en: '`Camera-minimap` is an orthographic camera that follows the player''s character
    from a top-down viewpoint. You removed/disabled the `AudioListener` component
    in this new Camera, since there should only be one active `AudioListener` in a
    **Scene,** and there is already one in the default **Main Camera** GameObject.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera-minimap`是一个正交相机，从俯视角度跟随玩家的角色。你在这个新相机中移除/禁用了`AudioListener`组件，因为**场景**中应该只有一个活动的`AudioListener`，而默认的**主相机**GameObject中已经有一个了。'
- en: You childed this new Camera to `character-MsLazer,` so it moves with the character.
    You positioned it 10 units above the character (Y = 10), and you made it point
    downwards towards the character (X-rotation of 90 degrees).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你将这个新相机子类化到`character-MsLazer`角色上，因此它随着角色移动。你将其定位在角色上方10个单位（Y = 10），并使其向下指向角色（X旋转90度）。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you want to experiment more with your minimap, read on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对你的缩略图进行更多实验，请继续阅读。
- en: Using a UI Mask to make the minimap circular in shape
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UI遮罩使缩略图呈圆形
- en: 'One way to make the minimap stand out in the UI is to make it circular. We
    can do this easily by adding a UI Mask based on a circle:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使缩略图在UI中突出，一种方法是将它做成圆形。我们可以通过添加基于圆形的UI遮罩来轻松实现这一点：
- en: '![](img/ab73d37f-e236-40c4-a636-a15489db6f22.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab73d37f-e236-40c4-a636-a15489db6f22.png)'
- en: 'A good way to make the minimap stand out in the UI is to present it as a circular
    shape, do the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使缩略图在 UI 中突出显示的一个好方法是将其呈现为圆形形状，请执行以下操作：
- en: In the **Project** panel, select the circleMask file in the `Textures` folder,
    and in the **Inspector** ensure the Texture Type is **Sprite** **(2D and UI)**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 面板中，选择 `Textures` 文件夹中的 circleMask 文件，并在 **检查器** 中确保纹理类型为 **精灵** **（2D
    和 UI）**。
- en: To change a Texture type to **Sprite (2D and UI)**, select the file in the **Project**
    panel, then in the **Inspector** change its **Texture Type** to **Sprite (2D and
    UI)** and click on **Apply** to confirm the changes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要将纹理类型更改为 **精灵（2D 和 UI）**，在 **项目** 面板中选择文件，然后在 **检查器** 中将其 **纹理类型** 更改为 **精灵（2D
    和 UI）** 并点击 **应用** 以确认更改。
- en: 'Ensure the `Panel-miniMap` GameObject is selected in the **Hierarchy.** In
    the **Inspector** for the **Image (Script)** component, populate the Source Image
    field with the circleMask texture, click the Color property, and set the Alpha
    value to `255`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 **层次结构** 中选择 `Panel-miniMap` GameObject。在 **检查器** 中为 **Image (Script)**
    组件，将源图像字段填充为 circleMask 纹理，点击颜色属性，并将 Alpha 值设置为 `255`：
- en: '![](img/df09b696-695c-4870-92e4-01128de5b044.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df09b696-695c-4870-92e4-01128de5b044.png)'
- en: Now, add a Mask component to `Panel-miniMap` in the **Inspector,** by choosing
    menu: Add Component | UI | Mask. Uncheck the Show Mask Graphic property (it will
    become invisible).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **检查器** 中为 `Panel-miniMap` 添加一个遮罩组件，通过选择菜单：添加组件 | UI | 遮罩。取消选中显示遮罩图形属性（它将变为不可见）。
- en: The circle image serves as a mask for the minimap, so that only images inside
    the `circleMask` area will be displayed, resulting in a circular minimap.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形图像作为缩略图的遮罩，因此只有 `circleMask` 区域内的图像将被显示，从而形成一个圆形缩略图。
- en: Hiding player character image at center of minimap and showing triangle marker
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏缩略图中心玩家角色图像并显示三角形标记
- en: 'With most minimaps, the center of the minimap is the location of the player''s
    character, so we don''t need to show the player''s character in the minimap. Let''s
    create a Layer named `Player` and place `character-MsLazer` onto that **Layer.**
    We can then improve efficiency and reduce visual clutter by creating a **Culling
    Mask** that ignores the **Player**** Layer**. We can display a simple **2D Sprite**
    in the center of our minimap, pointing upwards, to indicate that our player is
    always facing upwards relative to what is displayed in the minimap:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数缩略图中，缩略图中心是玩家角色的位置，因此我们不需要在缩略图中显示玩家角色。让我们创建一个名为 `Player` 的层，并将 `character-MsLazer`
    放置在该 **层** 上。然后我们可以通过创建一个忽略 **Player** **层** 的 **剔除遮罩** 来提高效率并减少视觉杂乱。我们可以在我们的缩略图中心显示一个简单的
    **2D 精灵**，向上指，以表明我们的玩家相对于缩略图显示始终向上：
- en: Create a new User Layer named `Player`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的用户层名为 `Player`。
- en: Select the `character-MsLaser` GameObject (the player's character) in the Hierarchy,
    and set the **Layer** property to **Player** (click Yes in the **Change Children**
    popup dialog).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 `character-MsLaser` GameObject（玩家角色），并将 **层** 属性设置为 **Player**（在 **更改子项**
    弹出对话框中点击是）。
- en: With `Camera-minimap` selected in the **Hierarchy,** in the **Inspector** for
    the **Culling Mask** property of the **Camera,** deselect **Layer Player**. This
    property should now say **Mixed...,** which means that GameObjects on the **Player Layer** will
    be ignored by our our `Camera-minimap.`
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中选择 `Camera-minimap`，在 **检查器** 中为 **Camera** 的 **剔除遮罩** 属性取消选择 **Layer
    Player**。此属性现在应显示为 **混合...**，这意味着 **Player** **层** 上的 GameObject 将被我们的 `Camera-minimap`
    忽略。
- en: Let's add a triangle marker 2D image at the center of the **Panel.** Create
    a new UI Image as a child of `Panel-minimap;` rename this `Image-marker.` In the
    **Inspector,** set the Source Image property to Texture asset file `triangleMarker`.
    Click the Set Native Size button.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 **面板** 的中心添加一个三角形标记 2D 图像。创建一个新的 UI Image 作为 `Panel-minimap` 的子项；将此重命名为
    `Image-marker`。在 **检查器** 中，将源图像属性设置为纹理资产文件 `triangleMarker`。点击设置原生大小按钮。
- en: 'Run the Scene. Rather than the top-down view of the player''s character, you
    should now see a triangle at the center of the minimap (always pointing upwards):'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。而不是以玩家角色的自上而下视角，你现在应该看到在缩略图中心的一个三角形（始终向上指）：
- en: '![](img/326756ab-832b-42b4-a3e7-b3e1bfc1acf9.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/326756ab-832b-42b4-a3e7-b3e1bfc1acf9.png)'
- en: 'Rather than just having a triangle image in the center representing the player,
    you can create, for example, colored 3D objects that in Orthographic projection
    look like circles, squares, and so on by using **Layers** further. This involves
    having a **Layer** for objects to be displayed in the minimap, and another **Layer**
    (such as **Player)** that will be ignored by the minimap Camera. The Knights Of
    Unity have published a short tutorial that explains just how to do this kind of
    thing: [http://blog.theknightsofunity.com/implementing-minimap-unity/](http://blog.theknightsofunity.com/implementing-minimap-unity/).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是只在中心有一个代表玩家的三角形图像，你可以通过使用**Layers**进一步创建，例如，彩色的3D对象，在正交投影中看起来像圆形、正方形等。这涉及到为要在小地图中显示的对象创建一个**Layer**，以及另一个（例如**Player**）将被小地图相机忽略的**Layer**。Unity的骑士们发布了一个简短的教程，解释了如何做到这一点：[http://blog.theknightsofunity.com/implementing-minimap-unity/](http://blog.theknightsofunity.com/implementing-minimap-unity/)。
- en: Rotating a compass-style image
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转罗盘风格的图像
- en: Sometimes we want a compass-style image around our minimaps, so we can see any
    differences between the current bearing (forward direction) of our player's character
    and the direction we were originally facing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想在我们的最小地图周围有一个罗盘风格的图像，这样我们就可以看到玩家角色的当前航向（前进方向）和原始面向之间的任何差异。
- en: 'To add a rotating compass-style image around our minimap, do the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的最小地图周围添加一个旋转的罗盘风格图像，请执行以下操作：
- en: Let's add a compass-style circular image at the center of the Panel (with the
    letter N pointing upwards). To do this, create a new UI Image as a child of **Panel-minimap;**
    rename this **Image-compass.** In the **Inspector,** set the **Source Image**
    property to Texture compass.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在面板的中心添加一个罗盘风格的圆形图像（字母N向上指）。为此，创建一个新的UI Image作为**Panel-minimap**的子对象；将此重命名为**Image-compass**。在**Inspector**中，将**Source
    Image**属性设置为Texture compass。
- en: 'Ensure both **Image-compass** and **Image-marker** appear below **RawImage-TextureMap**
    in the **Hierarchy** of the children of the `Panel-minimap` GameObject; this ensures
    the triangle marker and compass circle images are drawn after the Camera texture
    (that is, on top of the Camera''s view image):'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`Panel-minimap`游戏对象的子对象层级中，**Image-compass**和**Image-marker**都位于**RawImage-TextureMap**下方；这确保了三角形标记和罗盘圆圈图像在相机纹理之后（即在相机视图图像之上）被绘制：
- en: '![](img/e955c146-8a5e-4163-a5d4-28231ad98d8d.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e955c146-8a5e-4163-a5d4-28231ad98d8d.png)'
- en: Create a C# script-class MiniMap, and add an `instance-object` as a component
    to `Camera-minimap:`
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C#脚本类MiniMap，并将一个`instance-object`作为组件添加到`Camera-minimap:`。
- en: '[PRE13]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Play the Scene. You should be able to see the minimap functioning in the top-right
    corner of the screen. As you rotate the player character's orientation, you'll
    see the "N" north indicator in the circle around the minimap rotate too (but in
    the opposite direction).
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。你应该能够在屏幕的右上角看到小地图正在工作。当你旋转玩家角色的方向时，你会看到围绕小地图的“N”北指示器也在旋转（但方向相反）。
- en: Every frame, the compass UI Image is rotated to match the rotation of the player's
    3D character in the Scene.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧，罗盘UI Image都会旋转以匹配场景中玩家3D角色的旋转。
- en: Making the range of the map larger or smaller
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整地图的范围更大或更小
- en: Since our Camera-minimap is Orthographic, changing the height of the **Camera**
    above the character will make no difference (since distance doesn't change how
    objects are projected onto an Orthographic camera). However, changing the Size
    property of the **Camera** component in the **Inspector** will control how large
    or small an area of the world is projected to the **Camera.**
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的Camera-minimap是正交的，改变位于角色上方的**Camera**的高度将不会产生影响（因为距离不会改变对象在正交相机上的投影）。然而，在**Inspector**中更改**Camera**组件的Size属性将控制世界投影到**Camera**上的区域大小。
- en: 'Try increasing the size to 20, and your minimap will show much more of the
    surrounding maze around your character:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将大小增加到20，你的小地图将显示你角色周围更多的迷宫区域：
- en: '![](img/97c67c73-4b99-466a-be13-68afb82cb79b.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97c67c73-4b99-466a-be13-68afb82cb79b.png)'
- en: When increasing the range of the minimap, you may wish to make the triangle
    marker Image in the center of the minimap smaller. You can do this easily by centering
    its Rect Transform, then setting a smaller Width and Height (such as 16 x 16).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当增加小地图的范围时，你可能希望将小地图中心的三角标记图像缩小。你可以通过将其Rect Transform居中，然后设置较小的宽度和高度（例如16 x
    16）来实现这一点。
- en: Adapting your minimap to other styles
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的小地图适应到其他风格
- en: You can easily modify this recipe to make a top-down or isometric view of a
    racing game circuit map. In the **Inspector,** unchild the `Camera-minimap` GameObject; this
    will prevent it from following any of the **Scene** characters.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松修改这个菜谱，使其成为赛车游戏电路图的俯视或等距视图。在**检查器**中，取消`Camera-minimap` GameObject的子对象；这将防止它跟随场景中的任何**角色**。
- en: Creating an in-game surveillance Camera
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏中的监控摄像头
- en: 'In the previous recipe, we rendered the output from our minimap **Camera**
    to a **Render Texture**, and displayed the contents of that image in a **UI Raw
    Image**. Another example of when we may wish to capture and output the view of
    a **Camera** at runtime is to simulate an in-game surveillance **Camera,** such
    as a **Closed-Circuit Television** (**CCTV**) system. In this recipe, we will
    make use of a **Render Texture** to create an in-game surveillance camera that
    transmits its video to a 3D monitor elsewhere in the **Scene**:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们将最小地图**摄像头**的输出渲染到**渲染纹理**中，并在**UI原始图像**中显示该图像的内容。我们可能希望捕获和输出**摄像头**运行时视图的另一个例子是模拟游戏中的监控**摄像头**，例如**闭路电视**（**CCTV**）系统。在这个菜谱中，我们将使用**渲染纹理**创建一个在场景中其他地方传输视频到3D监控器的游戏内监控摄像头：
- en: '![](img/6c449ebd-34e9-48a5-b2e3-4ea3db5c8582.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c449ebd-34e9-48a5-b2e3-4ea3db5c8582.png)'
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱增加了本章第一个菜谱中创建的场景，所以请复制那个项目文件夹，并使用该副本来完成这个菜谱的工作。
- en: For this recipe, we have also prepared two 3D models (FBX files) needed for
    the monitor and `cctv-camera` objects. These 3D model files can be found in the
    `06_07` folder.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们还准备了两个3D模型（FBX文件），用于监控器和`cctv-camera`对象。这些3D模型文件可以在`06_07`文件夹中找到。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an in-game surveillance **Camera,** just follow these steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建游戏中的监控**摄像头**，请按照以下步骤操作：
- en: Import the monitor and `cctv-camera` models into your Unity Project.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将监控器和`cctv-camera`模型导入到您的Unity项目中。
- en: Create clones of the monitor and `cctv-camera` models by dragging them from
    the **Project** panel into the Hierarchy panel.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从**项目**面板拖动它们到**层次结构**面板来创建监控器和`cctv-camera`模型的克隆。
- en: 'In the **Inspector,** set the following properties for the monitor GameObject:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，为monitor GameObject设置以下属性：
- en: 'Position: (`-3, 0, 6`)'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：(`-3, 0, 6`)
- en: 'Rotation: (`0, 180, 0`)'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转：(`0, 180, 0`)
- en: 'Scale: (`1,1,1`)'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放：(`1,1,1`)
- en: 'In the **Inspector,** set the following properties for the `cctv-camera` GameObject:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，为`cctv-camera` GameObject设置以下属性：
- en: 'Position: (`-6, 0, 1`)'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：(`-6, 0, 1`)
- en: 'Rotation: (`0, 90, 0`)'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转：(`0, 90, 0`)
- en: From the **Project** panel, create a new **Render Texture** file and rename
    it `screenRenderTexture.` In the **Inspector,** change its **Size** to **512 x
    512**.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板创建一个新的**渲染纹理**文件，并将其重命名为`screenRenderTexture`。在**检查器**中，将其**大小**更改为**512
    x 512**。
- en: 'Add a new **Camera** to the scene (menu: Create | Camera) named `Camera-surveillance.`
    Child this new GameObject to `cctv-camera.` Uncheck (or remove) the camera''s
    **Audio Listener** component, since there should only be one active **Audio Listener**
    in a Scene.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个新的**摄像头**（菜单：创建 | 摄像头），命名为`Camera-surveillance`。将这个新的GameObject作为`cctv-camera`的子对象。取消选中（或移除）摄像头的**音频监听器**组件，因为场景中应该只有一个活动的**音频监听器**。
- en: 'In the **Inspector,** set the following properties for the `Camera-surveillance`
    GameObject:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，为`Camera-surveillance` GameObject设置以下属性：
- en: 'Position: (`0, 2, 0`)'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：(`0, 2, 0`)
- en: 'Rotation: (`0, 0, 0`)'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转：(`0, 0, 0`)
- en: 'Clipping Planes: Near: `0.6`'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪裁平面：近：`0.6`
- en: 'Target Texture: `screenRenderTexture`.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标纹理：`screenRenderTexture`。
- en: Create a new **Material** named `m_renderTexture,` and set its **Albedo Texture**
    to `screenRenderTexture.`
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**材质**，命名为`m_renderTexture`，并将其**漫反射纹理**设置为`screenRenderTexture`。
- en: In the **Hierarchy,** find the screen child of the monitor GameObject and set
    its **Mesh Renderer Material** to `m_renderTexture.`
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，找到monitor GameObject的屏幕子对象，并将其**网格渲染器材质**设置为`m_renderTexture`。
- en: 'Play your Scene. You should be able to see your actions in front of the `cctc-camera`
    displayed in real time on the monitor''s screen:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放您的场景。您应该能够在监控器的屏幕上实时看到`cctc-camera`前的动作：
- en: '![](img/5ddf90bc-c267-41a4-ab7c-90fc03fb9d0f.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ddf90bc-c267-41a4-ab7c-90fc03fb9d0f.png)'
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We achieved the final result by using the surveillance camera as a source for
    the **Render Texture** applied to the screen. The camera was made a child of the
    camera's 3D model for easier relocation. Also, its **Near Clipping** plane was
    readjusted in order to avoid displaying parts of the camera's 3D model geometry,
    and its **Audio Source** component was disabled so that it wouldn't clash with
    the main camera's component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将监控相机作为应用到屏幕上的**渲染纹理**的来源，实现了最终结果。为了便于重新定位，将相机设置为3D模型的子项。此外，重新调整了其**近裁剪**平面，以避免显示相机3D模型几何形状的一部分，并禁用了其**音频源**组件，以免与主相机的组件冲突。
- en: Finally, our **Render Texture** was applied to the material of the monitor GameObject.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的**渲染纹理**被应用到监视器GameObject的材料上。
- en: There's more...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want to experiment more with your minimap, read on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对你的小地图进行更多实验，请继续阅读。
- en: Using Post-Processing to add a grainy, grayscale effect to the CCTV
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后处理添加颗粒、灰度效果到CCTV
- en: 'A great effect to add for in-game TV systems is grainy (visual noise) grayscale
    **Post-Processing.** This adds the feel of cheap, old-style CCTV systems, such
    as might be used for a security system, and to add some kind of menacing film
    noir effect:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏中的电视系统添加一个很好的效果是带有颗粒（视觉噪声）的灰度**后处理**。这增加了廉价、老式CCTV系统的感觉，例如可能用于安全系统，并添加一种威胁性的电影黑帮效果：
- en: '![](img/33ad43ad-f915-4cd8-b998-413dded2a69e.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33ad43ad-f915-4cd8-b998-413dded2a69e.png)'
- en: 'To add a vignette effect, do the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加晕影效果，请执行以下操作：
- en: Open the **Asset Store** panel, then download and import the free **Post-Processing
    Stack** assets published by Unity Technologies.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**资产商店**面板，然后下载并导入Unity Technologies发布的免费**后处理堆栈**资产。
- en: In the **Project** panel, create a new **Post-Processing** Profile file by going
    to Create | Post-Processing Profile. Name this new profile `film-noir.`
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，通过转到创建 | 后处理配置文件创建一个新的**后处理**配置文件文件。将此新配置文件命名为`film-noir.`。
- en: 'In the **Hierarchy,** select the `Camera-surveillance` child of the `cctv-camera` GameObject.
    Add a **Post-Processing Behaviour** component to this **Camera,** by chosing menu:
    **Add Component** | **Effects** | **Post-Processing** Behaviour.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择`cctv-camera`GameObject的`Camera-surveillance`子项。通过选择菜单：**添加组件**
    | **效果** | **后处理行为**，为此**相机**添加一个**后处理行为**组件。
- en: Drag the `film-noir` file from the **Project** panel into the **Inspector** to
    populate the **Profile** property of the **Post-Processing Behaviour** component.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`film-noir`文件从**项目**面板拖动到**检查器**中，以填充**后处理行为**组件的**配置文件**属性。
- en: 'In the **Inspector,** set the following properties for the **Post-Processing
    Profile** `film-noir` file:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，为**后处理配置文件**`film-noir`文件设置以下属性：
- en: 'Check the **Color Grading** option, and set Basic: Saturation to zero'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**色彩分级**选项，并将基本：饱和度设置为零
- en: Check the **Grain** option, uncheck **Colored,** and set the maximum values
    for **Intensity (1), Luminescence Contribution (1)**, and **Size (3)**.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**颗粒**选项，取消选择**彩色**，并设置**强度（1）**、**发光贡献（1）**和**大小（3）**的最大值。
- en: Run the Scene.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。
- en: By processing the image generated from the **Camera,** the image in the monitor
    should now be an old-style grainy, grayscale video feed from `cctv-camera.` The
    image is made grayscale, since color saturation is zero, and a grainy effect has
    also been applied.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过处理从**相机**生成的图像，监视器中的图像现在应该是来自`cctv-camera.`的老式颗粒、灰度视频流。图像被转换为灰度，因为颜色饱和度为零，并且还应用了颗粒效果。
- en: Working with Unity's multi-purpose camera rig
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity的多功能相机装置
- en: 'Unity provides some **Camera** rigs, which can make setting up scenes much
    faster and help to test out ideas. In this recipe, you''ll use a 3rd Person Character
    and the multi-purpose camera rig from the default Unity asset packages to quickly
    create a scene with a camera that automatically follows a character as it moves,
    smoothing rotating behind the character as the character changes direction:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一些**相机**装置，可以使设置场景更快，并有助于测试想法。在这个菜谱中，你将使用一个第三人称角色和默认Unity资产包中的多功能相机装置，快速创建一个带有相机的场景，该相机在角色移动时自动跟随角色，并在角色改变方向时平滑旋转：
- en: '![](img/e08f6a53-935c-481e-a1f7-bc370bf474ad.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e08f6a53-935c-481e-a1f7-bc370bf474ad.png)'
- en: How to do it...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To work with Unity''s multi-purpose camera rig, just follow these steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Unity的多功能相机装置，只需遵循以下步骤：
- en: Create a new Unity 3D scene.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D场景。
- en: 'Import the **Characters** and **Cameras Asset Packages**: use menu: **Assets**
    | **Import Package ...** | **Cameras & Characters**.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入**Characters**和**Cameras Asset Packages**：使用菜单：**Assets** | **Import Package
    ...** | **Cameras & Characters**。
- en: You should now have a `Standard Assets` folder in your **Project** panel, containing
    the `Cameras` and `Characters` folders (and possibly some others, such as `CrossPlatformInput`, `Editor`,
    and so on).
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该在你的**项目**面板中有一个`Standard Assets`文件夹，其中包含`Cameras`和`Characters`文件夹（以及可能的一些其他文件夹，如`CrossPlatformInput`、`Editor`等）。
- en: Create a 3D Plane in your **Scene.**
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的**场景**中创建一个3D平面。
- en: Add a clone of the `ThirdPersonController Prefab` to your Scene. Do this by
    dragging the `ThirdPersonController Prefab` from the `Standard Assets` | `Characters`
    | `ThirdPersonController` | `Prefabs` folder into the **Scene.**
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ThirdPersonController Prefab`的副本添加到你的场景中。通过将`ThirdPersonController Prefab`从`Standard
    Assets` | `Characters` | `ThirdPersonController` | `Prefabs`文件夹拖动到**场景**中完成此操作。
- en: With GameObject `ThirdPersonController` selected in the **Hierarchy,** in the
    **Inspector** tag this GameObject with the **Player** tag.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择GameObject `ThirdPersonController`，在**检查器**中使用**Player**标签标记此GameObject。
- en: Add a clone of the `MultipurposeCameraRig Prefab` to your Scene. Do this by
    dragging the `MultipurposeCameraRig` Prefab from the `Standard Assets` | `Cameras`
    | `Prefabs` folder into the Scene.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MultipurposeCameraRig Prefab`的副本添加到你的场景中。通过将`MultipurposeCameraRig` Prefab从`Standard
    Assets` | `Cameras` | `Prefabs`文件夹拖动到场景中完成此操作。
- en: Disable the **Main** Camera GameObject.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用**Main** Camera GameObject。
- en: Run the **Scene.** As you move the character around the **Scene,** the **Camera**
    should smoothly follow behind.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**场景**。当你移动角色在**场景**中时，**相机**应该平滑地跟随后面。
- en: How it works...
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added a `ThirdPersonController` to the Scene and tagged it **Player.** You
    added a `MultipurposeCameraRig` to the **Scene.** The code attached to the camera
    rig automatically looks for a target GameObject tagged Player, and positions itself
    to follow from above and behind this GameObject.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你已将`ThirdPersonController`添加到场景并标记为**Player**。你已将`MultipurposeCameraRig`添加到**场景**中。相机架上的代码会自动寻找标记为Player的目标GameObject，并从上方和后方定位以跟随此GameObject。
- en: You can adjust the speed at which the camera follows and turns by changing the
    public properties for the `MultipurposeCameraRig` in its **Inspector** component
    **Auto Cam (Script)**.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改`MultipurposeCameraRig`在**检查器**组件**Auto Cam (Script)**中的公共属性来调整相机跟随和转向的速度。
- en: Using Cinemachine ClearShot to switch cameras to keep the player in shot
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cinemachine ClearShot切换相机以保持玩家在画面中
- en: 'A new feature of Unity is the `Cinemachine` set of components:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的新特性是`Cinemachine`组件集：
- en: '![](img/cc0390fe-7d99-4d56-bde8-db64840934c3.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc0390fe-7d99-4d56-bde8-db64840934c3.png)'
- en: Getting ready
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方添加到本章第一个配方创建的场景中，因此复制该项目文件夹，并使用该副本完成此配方的操作。
- en: How to do it...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To use **Cinemachine ClearShot** to switch cameras to keep the player in shot,
    just follow these steps:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**Cinemachine ClearShot**切换相机以保持玩家在画面中，只需遵循以下步骤：
- en: Open the scene provided, containing a 3D maze and `character-MsLazer.`
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开提供的场景，其中包含一个3D迷宫和`character-MsLazer`。
- en: Un-child the **Main Camera** from `character-MsLazer,` since we need this camera
    free for `Cinemachine` to take control of it.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Main Camera`从`character-MsLazer`中解除关联，因为我们需要这个相机空闲，以便`Cinemachine`可以控制它。
- en: Install the `Cinemachine` package using the Unity Package Manager (to get the
    most up-to-date version).
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Unity Package Manager安装`Cinemachine`包（以获取最新版本）。
- en: 'Add a **Cinemachine ClearShot** camera GameObject to the scene (menu: **Cinemachine**
    | **Ceate ClearShot Camera****).** You should see a new GameObject in the Hierarchy
    named CM Clearshot 1\. Set the position of this new GameObject to (0,0,0).'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个**Cinemachine ClearShot**相机GameObject（菜单：**Cinemachine** | **Create
    ClearShot Camera**）。你应该在层次结构中看到一个名为CM Clearshot 1的新GameObject。将这个新GameObject的位置设置为（0,0,0）。
- en: CM Clearshot 1 should have a child GameObject, Cinemachine Virtual Camera CM
    vcam 1\. Set the position of this virtual camera, CM vcam 1, to (10, 4, -10).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CM Clearshot 1应该有一个子GameObject，Cinemachine Virtual Camera CM vcam 1。将这个虚拟相机，CM
    vcam 1的位置设置为（10, 4, -10）。
- en: 'You will also see that a Cinemachine Brain component has been added to the
    **Main Camera,** and in the **Hierarchy** you''ll see the Cinemacine Brain icon
    next to the **Main Camera** name (half gray cog, half red camera):'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还会看到已经添加了一个到**Main Camera**的Cinemachine Brain组件，在**层次结构**中，你会在**Main Camera**名称旁边看到Cinemacine
    Brain图标（一半灰色齿轮，一半红色相机）：
- en: '![](img/3287b4cb-90a2-4cbe-a49b-bc22ab98081d.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3287b4cb-90a2-4cbe-a49b-bc22ab98081d.png)'
- en: Locate the `mixamorig:neck` GameObject in the Hierarchy inside character-MsLazer.
    We'll use this part of `character-MsLazer` to be the part that our `Cinemachine`
    cameras will use to orient towards.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`character-MsLazer`的层级中定位`mixamorig:neck` GameObject。我们将使用`character-MsLazer`的这一部分作为我们的`Cinemachine`相机将用来定位的部分。
- en: Select **CM Clearshot 1**, and in the **Inspector** populate the **Look At**
    property of the **Cinemachine ClearShot** component with a reference to the `mixamorig:neck` GameObject (drag
    the GameObject from Hierarchy into the property in the **Inspector):**
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**CM Clearshot 1**，然后在**检查器**中，将**Cinemachine ClearShot**组件的**Look At**属性填充为对`mixamorig:neck`
    GameObject的引用（将GameObject从层级拖动到**检查器**中的属性）：**
- en: '![](img/045f5ca2-2cdc-4f42-848a-13417bc3fb16.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/045f5ca2-2cdc-4f42-848a-13417bc3fb16.png)'
- en: Run the **Scene.** As you move `character-MsLazer` around the scene, the Main
    Camera (controlled by the `Cinemachein` Brain) should rotate to always look at
    the character. However, sometimes a wall obscures the view.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**场景**。当您在场景中移动`character-MsLazer`时，主相机（由`Cinemachein`大脑控制）应该旋转以始终面向角色。然而，有时墙壁会遮挡视线。
- en: Create a second child Virtual Camera by selecting CM Clearshot 1 in the Hierarchy,
    and then in the Inspector, click the + button for the **Virtual Camera Children**
    property of the `Cinemachine` Clear Shot component. You should see a new virtual
    camera child named CM vcam 2 has been created. Set the **Position** of CM vcam
    2 to (27, 4, -18).
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在层级中选择CM Clearshot 1，创建第二个子虚拟相机，然后在检查器中点击`Cinemachine` Clear Shot组件的**虚拟相机子代**属性的+按钮。您应该看到一个名为CM
    vcam 2的新虚拟相机子代被创建。将CM vcam 2的**位置**设置为（27, 4, -18）。
- en: Run the **Scene**. Initially, CM vcam 1 has the best shot, and so this camera's
    position will be used to direct the **Main Camera**. However, if you move `character-MsLazer`
    along the corridor towards CM vcam 2, `Cinemachine` will then switch control to
    CM vcam 2.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**场景**。最初，CM vcam 1拥有最佳的拍摄角度，因此将使用这个相机的位置来引导**主相机**。但是，如果您将`character-MsLazer`沿着走廊移动到CM
    vcam 2，`Cinemachine`将切换控制到CM vcam 2。
- en: How it works...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A Cinemachine Brain component was added to the **Scene.** This takes control
    of the **Main Camera** and uses properties of one or more **Virtual Cinemachine
    Camera** to decide what properties to apply to the **Main Camera**. You added
    a **Cinemachine ClearShot** GameObject, whose purpose is to tell the **Cinemachine
    Brain** which of its **Virtual Camera** children has the best shot.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景**中添加了一个Cinemachine Brain组件。它控制**主相机**并使用一个或多个**虚拟Cinemachine相机**的属性来决定应用于**主相机**的属性。您添加了一个**Cinemachine
    ClearShot** GameObject，其目的是告诉**Cinemachine Brain**哪个其**虚拟相机**子代拥有最佳的拍摄角度。
- en: You set the **Look At** property of the `ClearShot` component to the neck component
    of `character-MsLazer;` the position of this GameObject is used by the `ClearShot`
    component to rank each **Virtual Camera's** quality of shot.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您将`ClearShot`组件的**Look At**属性设置为`character-MsLazer`的颈部组件；此GameObject的位置被`ClearShot`组件用于对每个**虚拟相机**的拍摄质量进行排名。
- en: There's more...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We've only just touched the surface of what **Cinemachine** has to offer. Here
    are some suggestions for how to learn more.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及了Cinemachine所能提供的表面。以下是一些学习更多知识的建议。
- en: Unity Cinemachine tutorials
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity Cinemachine教程
- en: 'In the learn section of the Unity website, you''ll find many video tutorials
    introducing the different animation features of Unity. There is a special category
    for **Cinemachine** tutorials, which provide a great overview of the features
    and uses of Cinemachine: [https://unity3d.com/learn/tutorials/s/animation](https://unity3d.com/learn/tutorials/s/animation).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity网站的“学习”部分，您可以找到许多介绍Unity不同动画功能的视频教程。有一个专门的类别是**Cinemachine**教程，它提供了Cinemachine功能和用途的全面概述：[https://unity3d.com/learn/tutorials/s/animation](https://unity3d.com/learn/tutorials/s/animation)。
- en: Will Goldstone's ClearShot turtorial
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威尔·戈尔茨坦（Will Goldstone）的ClearShot教程
- en: 'This recipe was inspired by Will Goldstone''s ClearShot tutorial, available
    on YouTube: [https://www.youtube.com/watch?v=kLcdrDljakA](https://www.youtube.com/watch?v=kLcdrDljakA).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方受到了YouTube上威尔·戈尔茨坦（Will Goldstone）的ClearShot教程的启发：[https://www.youtube.com/watch?v=kLcdrDljakA](https://www.youtube.com/watch?v=kLcdrDljakA)。
- en: Adam Myhill's Cinemachine blog posts
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚当·迈希尔（Adam Myhill）的Cinemachine博客文章
- en: 'Adam Myhill''s blog posts (he is the creator of **Cinemachine)** have lots
    of information and video links about many different Cinemachine features: [https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/](https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Adam Myhill的博客文章（他是**Cinemachine**的创造者）中包含大量关于许多不同Cinemachine功能的信息和视频链接：[https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/](https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/)。
- en: Read the installed Cinemachine documentation
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读已安装的Cinemachine文档
- en: 'Later versions of **Cinemachine (2.1+)** have documentation installed with
    the package. Display the **Cinemachine** About panel **(Menu:** **Cinemachine**
    | **About****),** then click the **Documentation** button:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cinemachine**的后续版本（2.1+）包含与包一起安装的文档。显示**Cinemachine**关于面板（菜单：**Cinemachine**
    | **About**），然后点击**Documentation**按钮：'
- en: '![](img/545c2654-1926-4021-aa19-c5c37017cb56.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/545c2654-1926-4021-aa19-c5c37017cb56.png)'
- en: You can also find the documentation online at [https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在网上找到文档，链接为[https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html)。
- en: Letting the player switch to a Cinemachine FreeLook camera
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许玩家切换到Cinemachine FreeLook相机
- en: It's always good to give players choices and control in their game experience.
    In this recipe, we'll set up a mouse-controllable **Cinemachine FreeLook** camera
    and let the player switch to it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 总是给玩家提供选择和控制他们的游戏体验是件好事。在这个配方中，我们将设置一个鼠标可控制的**Cinemachine FreeLook**相机，并允许玩家切换到它。
- en: Getting ready
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方在先前的配方基础上添加内容，因此请复制那个项目文件夹，并使用该副本进行此配方的操作。
- en: How to do it...
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To explore Cinemachine, just follow these steps:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索Cinemachine，只需遵循以下步骤：
- en: Ensure the **Default Blend** property of the **Cinemachine Brain** component
    in the **Main Camera** is set to Ease In Out. This means we'll have a smooth transition
    when switching between cameras.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**Main Camera**中的**Cinemachine Brain**组件的**Default Blend**属性设置为Ease In Out。这意味着我们在切换相机之间将会有平滑的过渡。
- en: 'Add a **Cinemachine FreeLook** camera GameObject to the scene (menu: **Cinemachine**
    | **Ceate FreeLook Camera****).** You should see a new GameObject in the **Hierarchy**
    named `CM FreeLook 1`. Set the **Priority** property of the **Cinemachine** **Free
    Look (Script)** component to zero.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**Cinemachine FreeLook**相机GameObject添加到场景中（菜单：**Cinemachine** | **Create
    FreeLook Camera**）。**您应该会在**“Hierarchy”**中看到一个名为`CM FreeLook 1`的新GameObject。将**Cinemachine**
    **Free Look (Script)**组件的**Priority**属性设置为零。
- en: Locate the `mixamorig:neck` GameObject in the **Hierarchy** inside **MsLazer.**
    We'll use this part of the **MsLazer** character to be the part that our **Cinemachine**
    cameras will use to orient towards and follow at a steady distance.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**MsLazer**中的**Hierarchy**内找到`mixamorig:neck` GameObject。我们将使用**MsLazer**角色的这部分作为我们的**Cinemachine**相机将用来定位和以恒定距离跟随的部分。
- en: Select **CM FreeLook 1**, and in the **Inspector** populate the **Look At**
    and **Follow** properties of the **Cinemachine** **Free Look (Script)** component
    with a reference to the `mixamorig:neck` GameObject (drag the GameObject from
    Hierarchy into the properties in the **Inspector).**
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**CM FreeLook 1**，并在**Inspector**中填充**Cinemachine** **Free Look (Script)**组件的**Look
    At**和**Follow**属性，以引用`mixamorig:neck` GameObject（从**Hierarchy**拖动GameObject到**Inspector**中的属性）。**
- en: 'Create a new `FreeLookSwitcher` C# Script-class containing the following code,
    and add an instance-object as a component to the **CM FreeLook 1** GameObject:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`FreeLookSwitcher` C# Script类，包含以下代码，并将一个实例对象作为组件添加到**CM FreeLook 1**
    GameObject中：
- en: '[PRE14]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the **Scene.** When moving around the maze, initially the **Cinemachine
    ClearShot** cameras will be chosen by the **Cinemachine** Brain. But, pressing
    the *1* key will make it switch to the **FreeLook** camera following the player's
    character. Pressing *2* will switch back to the **ClearShot** cameras.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**Scene**。当在迷宫中移动时，最初**Cinemachine ClearShot**相机将由**Cinemachine** Brain选择。但是，按下*1*键将使其切换到跟随玩家角色的**FreeLook**相机。按下*2*键将切换回**ClearShot**相机。
- en: How it works...
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added a **FreeLook Cinemachine** GameObject, but with a priority of zero,
    so it will be ignored initially. When the *1* key is pressed, the script increases
    the **Priority** to `99` (much higher than the default 10 of the **ClearShot**
    cameras), so then the **Cinemachine** Brain will make the **FreeLook** virtual
    camera control the **Main Camera**. Pressing the *2* key reduces the **FreeLook**
    component's **Priority** back to **zero,** so the **ClearShot** cameras will be
    used again.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加了一个**FreeLook Cinemachine**游戏对象，但优先级为零，因此最初会被忽略。当按下*1*键时，脚本将**Priority**提升到`99`（比**ClearShot**相机的默认值10高得多），因此**Cinemachine**脑部将使**FreeLook**虚拟相机控制**Main
    Camera**。按下*2*键将**FreeLook**组件的**Priority**降低回**zero**，因此将再次使用**ClearShot**相机。
- en: There should be a smooth transition from **FreeLook** to **ClearShot** and back
    again, since you set the **Default Blend** property of the **Cinemachine Brain**
    component in the **Main Camera** to **Ease In Out**.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 从**FreeLook**到**ClearShot**以及返回的过渡应该是平滑的，因为你已经将**Main Camera**中的**Cinemachine
    Brain**组件的**Default Blend**属性设置为**Ease In Out**。
