<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence</h1></div></div></div><p>After having given a rendering (<a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 4</a>, <em>No Longer Alone – Sweet-Toothed Pandas Strike</em>) and a physical shape (<a class="link" title="Chapter 5. The Secret Ingredient Is a Dash of Physics" href="part0062.xhtml#aid-1R42S1">Chapter 5</a>, <em>The Secret Ingredient Is a Dash of Physics</em>) to our Pandas, it's now time to give them intelligence. In particular, the ability to walk/navigate through the map towards the player's cake to eat it. In fact, as we have already pointed out, <strong>artificial intelligence</strong> (<strong>AI</strong>) is at the core of giving life to NPCs, so that they can move around and act within the world. However, this chapter will focus on navigation.</p><p>In particular, we will implement a waypoint system for our Pandas. We will do it twice, so that we can have two different perspectives on the same thing, and we will highlight the advantages and disadvantages of each method.</p><p>Here is an outline of the topics that we will cover:</p><div><ul class="itemizedlist"><li class="listitem">The importance of AI in video games</li><li class="listitem">Navigation in video games and an overview of the main techniques</li><li class="listitem">Implementing a waypoint system as a static list</li><li class="listitem">Implementing a waypoint system as a dynamic pool of game objects (and display them as icons on the map)</li><li class="listitem">Getting an idea of what's beyond navigation</li></ul></div><p>As in all the other chapters of this book, you can practice your skill at the end with the Homework section. So, let's get ready to start!</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Getting ready</h1></div></div></div><p>The only requirement for this chapter, is that you have already done all the parts of the book that dealt with the <code class="literal">PandaScript</code> so far.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Introduction to artificial intelligence</h1></div></div></div><p><strong>Artificial intelligence</strong> (<strong>AI</strong>) is an extensive topic, even if we limit ourselves just to video games. In fact, due to its complexity, it's one of the hardest parts to program for a video game. A good AI programmer should have knowledge of math (such as graph theory, Bayesian networks, operational research, and so on), physics (such as the motion equations) and psychology (to understand how the player reacts to AI in the game). Whereas the first two are well known, the last one is sometimes neglected, but is just as equally important. In fact, sometimes the most believable behavior of an NPC character is not the most enjoyable for the player. If you are interested in learning more, I wrote an article that you can find on my website at <a class="ulink" href="http://francescosapio.com/">francescosapio.com</a></p><p>However, I hope I haven't scared you by quoting such concepts of mathematics. In fact, in these sections, we won't cover such complicated things, but it is useful to have an idea about the foundations of what we will do, even if we will only create a simple ground to make our tower defense game work. In any case, I invite you to learn more about artificial intelligence in video games, since what you can achieve is really awesome!</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec70"/>The importance of artificial intelligence in video games</h1></div></div></div><p>Imagine a tower defense game without enemies to compete against, it's just you and a bunch of towers. Games like <em>SimCity</em> (<a class="ulink" href="http://www.simcity.com">www.simcity.com</a>) would cease to exist. Games would become predictable experiences, their replay value would be greatly diminished, and MMOs would become ordinary. It would be the apocalypse of dynamic gameplay, without being too dramatic. Therefore, for any game to provide a dynamic and growing experience, AI is essential.</p><p>Artificial intelligence, or simply AI, allows systems to think and then behave just like humans, <em>or </em>animals<em>. </em>Over time, these systems can learn from the behavior of its user; for example, if they are progressing too easily, or if they are struggling, then the system is able to make adjustments to the game (in real time) so that the game adapts to the player. This concept refers to <strong>machine learning</strong><em>. </em></p><p>AI in computer games refers to the behaviour and decision-making process of game components such as non-player characters, or NPCs for short. In modern games, there is real-time, very dynamic AI that in some cases feels like you're playing against other real players. In this way, well done AI allows you to make fast and intelligent decisions in order to progress through the game and achieve greatness. Some examples of AI in games can range from early arcade games such as <em>Pac-Man</em>, to enemies in first person shooters, such as <em>Battlefield</em>, <em>Call of Duty</em>, and <em>Alpha Protocol</em>; or <em>hordes of orcs</em> and beasts in strategy games, such as <em>World of Warcraft</em> and <em>Guild Wars 2</em>.</p><p>In a book about AI (<em>Artificial Intelligence for Games</em> by Ian Millington and John Funge), which I recommend you to have a look at, we can think of AI as having the following states:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Movement</strong>: This refers to AI that involves NPCs making decisions that then produce a type of motion, such as attacking or fleeing the player.</li><li class="listitem"><strong>Decision making</strong>: As the name suggests, this requires that a decision is made by the NPC about what to do next. For instance, if the enemy sees you, will it attack, run, or call for help?</li><li class="listitem"><strong>Strategy</strong>: Imagine trying to coordinate a whole team, like in <em>S.W.A.T</em> or Tom Clancy's <em>Rainbow Six</em>. In these situations, AI does not affect just one or two characters, but the entire team who, in turn, may have his or her own decision making tree, such as what to do when they sight an enemy; do they take them out on their own or do they notify you?</li><li class="listitem"><strong>Infrastructure</strong>: This refers to how the AI is structured, which will ultimately determine how well it works in a game. This isn't just about creating the write algorithms to make NPCs perform certain actions, it is also about utilizing the computer's resources in an efficient way.</li><li class="listitem"><strong>Agent-based AI</strong>: This refers to the concept of creating autonomous NPCs that take in information from the game data, determine what actions to take, and then carry out those actions.</li></ul></div><div><h3 class="title"><a id="tip91"/>Tip</h3><p>A great site to check out is Intel's: <a class="ulink" href="http://tinyurl.com/IntelAI">http://tinyurl.com/IntelAI</a>, which provides a nice explanation and introduction to the use of AI in games.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Navigation</h1></div></div></div><p>Now, we should have a better understanding of why AI is so important and vital for video games, but it's such an extensive topic that it cannot be dealt with in a small chapter like this. Therefore, we will focus on just one particular aspect, which is navigation. Since this is an introductory chapter to the topic, we will hope to understand the basic concepts of navigation, but implement just one of the simple techniques that we will use in our game.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Aspects of navigation</h2></div></div></div><p>Game characters move within the game and its levels. The movement can be quite simple, such as that of arcade games or NPCs following or targeting you, and others can be quite complex like in fast paced action and adventure games. Fixed routes are simple to implement within a game, but keep in mind that it is possible to break their illusion when objects and other characters get in the way. For example, in games that are highly populated by NPCs (such as <em>Assassin's Creed</em>), characters that roam the environment can get stuck on environmental objects and appear to be moon walking, or in other words moving but not going anywhere. In a more dynamic situation, characters that will follow you or come towards you (friend or foe) will not know your future movements and therefore must act accordingly, as you do. This can range from waves of enemies in real-time strategy games, to guards who you need to avoid in order to infiltrate high-level security buildings.</p><p>For each of these characters (and situations), the AI must be able to calculate a suitable route within the game level, ensuring that it can respond to objects that come into its path, in order to reach its goal. Ideally, you want the character to act as natural as possible.</p><div><h3 class="title"><a id="note92"/>Note</h3><p>In larger contexts, navigation can be used in a space, which can represent the environment, but also more abstract things, such as the space of moves of a problem. For example, in the famous <em>Eight queens</em> game (placing eight queens on a chess board such that each one of them doesn't attack another; you should try it), finding a path in the space of moves might be equivalent to finding a solution.</p></div><p>In video games, navigation can exist in various forms, such as:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Steering behaviours</strong>: These find an immediate path in front of the agent to avoid collisions. It can be used for basic obstacle avoidance, also in multi-agent system contexts. Since these behaviours are at a low-level, in video games they always have been implemented in a Kinematic way (in the same way we saw in <a class="link" title="Chapter 5. The Secret Ingredient Is a Dash of Physics" href="part0062.xhtml#aid-1R42S1">Chapter 5</a>, <em>The Secret Ingredient Is a Dash of Physics</em>). However recently, some dynamic steering behaviours have arisen in the game development world, bringing more realistic games.</li><li class="listitem"><strong>Pathfinding</strong>: These finds a path from a starting location to a destination. This level is the most used, and many techniques have been discovered/invented and implemented. It is this type of navigation that will be the focus of this chapter.</li><li class="listitem"><strong>Driven pathfinding</strong>: These finds one or multiple paths according to some driven behaviours. This is still a level that has never been implemented in the game industry, but it's a field of research for game development in academia, and therefore it's worth mentioning. This level is placed between decision making and pathfinding. In fact, some decisions are taken at pathfinding time, bringing a more intelligent pathfinding and efficiency in decision processes.</li></ul></div><div><h3 class="title"><a id="note93"/>Note</h3><p>More information about the different types of navigation can be found in more detail on my website. Moreover, my research involves directly driven pathfinding, such as the BDP (we will see later in the chapter). Here is the link: <a class="ulink" href="http://francescosapio.com">francescosapio.com</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Pathfinding and its techniques</h2></div></div></div><p>Over the last few decades, many pathfinding algorithms and techniques have been explored. One of the very first pathfinding algorithms that was invented was the <strong>dijkstra algorithm</strong>, which gave the foundation for modern pathfinding algorithms. Of course, since Dijkstra, much progress has been made and algorithms have become much more efficient (especially when we deal with specific information or we have a priori knowledge about the problem that we can use). The most used of these in video games is the <strong>A* algorithm</strong> (along with all its derivations), which uses some additional information about the map. The main concept of Dijkstra was to explore in all directions until a route was found; the main concept of A* is to explore towards the direction of the destination (which may sound simple, but it is not always easy to determine a function that in some way tells you which is the direction towards the destination). Of course, this is a simplification, but good enough to gain a better overview.</p><p>The preceding mentioned algorithms work in many situations, but if the route which we want to find is easy enough to be found in a small map, it wouldn't be worthwhile developing such algorithms, since there are easier techniques. One of these techniques is the use of waypoints, which is the technique we will use for our game. The main concept is that the map is split into a graph which, potentially, is very small (enough to be drawn by hand) and finding a path can happen in a distributed way. Of course, there is another entire world beyond distributed pathfinding (a practical application would be IP packets that need to travel the world on the Internet, and the path between the different routers is determined in a distributed way since the map of the network changes continuously).</p><p>Another important fact that influences pathfinding (but also other techniques of AI) is whether the algorithm needs to work online or offline. Online means that the algorithm needs to find a solution in real time, whereas offline means that the solution can be found a priori. In video games, there are situations in which we need to use online solutions (such as finding the path for your NPCs) and others where we need an offline solution (for instance, when you have more time to compute, such as with turn-based games, or when some AI calculations are performed at loading time).</p><p>Unfortunately, we would need another book just to describe navigation in video games, but this chapter is giving you a nice and gentle introduction to the world that's behind all of this, and you can use the references (suggested books and links) to continue your journey in learning AI in games.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Waypoints for enemies</h1></div></div></div><p>A waypoint is a special point on the map where NPCs change their direction to move towards another waypoint. They can contain logic to actually lead the character to specific places that change over time, such as next to the player. For instance, in a shooting game, enemies want to get closer to the player to shoot him/her. Waypoints can also perform part of the decision-making process. For example, imagine a tower defense level where the path of the enemies splits in two. In this case, the waypoints can be used to decide which direction a particular enemy should take (we will see this in the last chapter of this book). The advantages of waypoints are that, in some cases, they can be more efficient than implementing a complete pathfinding algorithm.</p><div><h3 class="title"><a id="note94"/>Note</h3><p>In more complex implementations, waypoints can be connected in different ways and these connections can also be created automatically by letting the waypoints find each other. Furthermore, they can also contain other information, such as which is the closest waypoint to the player. Here, the enemy can ask or query the waypoints where to head towards in order to find the player without running a complete pathfinding algorithm on the map itself.</p></div><p>At the moment, we don't need to implement a particular logic behind the waypoints. However, they are a useful tool since they allow us to move enemies around the map easily, and they are modular enough so to be able to create other levels of our game without many problems.</p><p>In this section, we will learn how to create waypoints. In particular, we will see two ways to implement them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec73"/>Getting the waypoint coordinates</h1></div></div></div><p>Before we start creating waypoints, we first need to decide where to place them on the map. Therefore, we need to find all the places where our Pandas change their direction. In this simple map, they are located at all corners of their path. In the following image, they are indicated by the red dots:</p><div><img src="img/image00581.jpeg" alt="Getting the waypoint coordinates"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, there are 11 and we need one waypoint that is on the cake in the map. This final waypoint is the finishing spot, where the Panda has succeeded in his mission to steal a big bite of the player's cake.</p><p>Now that we have spotted them, we need to take note of their coordinates on the map. A fast way to do it is to drag the Panda Prefab around the map in the <strong>Scene</strong> view and then take note of the position of our waypoints. In this case, we could obtain the following data:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><strong>Waypoint number</strong></p>
</td><td>
<p><strong>X coordinate</strong></p>
</td><td>
<p><strong>Y coordinate</strong></p>
</td></tr><tr><td>
<p>1</p>
</td><td>
<p><code class="literal">-28</code></p>
</td><td>
<p><code class="literal">8</code></p>
</td></tr><tr><td>
<p>2</p>
</td><td>
<p><code class="literal">-28</code></p>
</td><td>
<p><code class="literal">-16</code></p>
</td></tr><tr><td>
<p>3</p>
</td><td>
<p><code class="literal">-16</code></p>
</td><td>
<p><code class="literal">-16</code></p>
</td></tr><tr><td>
<p>4</p>
</td><td>
<p><code class="literal">-16</code></p>
</td><td>
<p><code class="literal">7</code></p>
</td></tr><tr><td>
<p>5</p>
</td><td>
<p><code class="literal">-2</code></p>
</td><td>
<p><code class="literal">7</code></p>
</td></tr><tr><td>
<p>6</p>
</td><td>
<p><code class="literal">-2</code></p>
</td><td>
<p><code class="literal">-6</code></p>
</td></tr><tr><td>
<p>7</p>
</td><td>
<p><code class="literal">12</code></p>
</td><td>
<p><code class="literal">-6</code></p>
</td></tr><tr><td>
<p>8</p>
</td><td>
<p><code class="literal">12</code></p>
</td><td>
<p><code class="literal">9</code></p>
</td></tr><tr><td>
<p>9</p>
</td><td>
<p><code class="literal">25</code></p>
</td><td>
<p><code class="literal">9</code></p>
</td></tr><tr><td>
<p>10</p>
</td><td>
<p><code class="literal">25</code></p>
</td><td>
<p><code class="literal">-17</code></p>
</td></tr><tr><td>
<p>11</p>
</td><td>
<p><code class="literal">32</code></p>
</td><td>
<p><code class="literal">-17</code></p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Implementing waypoints – the first/static way</h1></div></div></div><p>Now that we have all the waypoint coordinates, we can implement them. In this section, we will explore the first way to implement them. The main advantage of this method is the simplicity of the implementation and the possibility to learn more about static variables and iterating over waypoints.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Implementing waypoints in the Game Manager</h2></div></div></div><p>In this first implementation of waypoints, they won't be separate entities in the game, but rather a collection of positions in a specific order. All the enemies will consult this list, and based on which waypoint they are currently at, take the next one in the list.</p><p>Of course, this method has some limitations such as we won't be able to implement custom features in the waypoints, as we will see in <a class="link" title="Chapter 8. What Is beyond the Cake?" href="part0100.xhtml#aid-2VBO82">Chapter 8</a>, <em>What Is beyond the Cake?</em>. However, it is simpler to implement, and it gives us the opportunity to explore how to use static variables.</p><p>First of all, we need to create another script, and call it <code class="literal">GameManagerScript</code>. We will implement more functionality in this script in the next chapter. But at the moment, it is needed to store the waypoints. In fact, for now, we just need to add an array of positions, so you can write the following in the script:</p><pre class="programlisting">
<em>//public waypoint list as an array of positions</em> &#13;
public Vector3[] waypoints; &#13;
</pre><p>It is a <code class="literal">Vector3</code> array, which basically just stores a set of positions in a specific order. Save the code, and create an empty GameObject in the <strong>Scene</strong>, which you can rename <code class="literal">Game Manager</code>. Attach the script on it, and in the <strong>Inspector</strong> you should see something like the following:</p><div><img src="img/image00582.jpeg" alt="Implementing waypoints in the Game Manager"/></div><p style="clear:both; height: 1em;"> </p><p>We need to set the number of elements of our array with the number of waypoints we have found, in this case 11. Therefore, our <strong>Inspector</strong> looks like the following:</p><div><img src="img/image00583.jpeg" alt="Implementing waypoints in the Game Manager"/></div><p style="clear:both; height: 1em;"> </p><p>Finally, we can fill all those values with our waypoint positions. But what about the <em>z</em>-axis? Since we don't want the Pandas to change their <em>z</em>-axis, we can just set its value to the same <em>z</em>-axis value of our <code class="literal">PandaPrefab</code>, which is <code class="literal">-1</code>. At the end, we should have something like this:</p><div><img src="img/image00584.jpeg" alt="Implementing waypoints in the Game Manager"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note95"/>Note</h3><p>The reader may wonder if it was worthwhile using <code class="literal">Vector2</code> instead of <code class="literal">Vector3</code>. The answer is: it's your choice. Nothing prevents you from using <code class="literal">Vector2</code> and forgetting about <code class="literal">Vector3</code>. But, since we have made the choice to handle the depth of our game with z-buffering, I personally prefer to have direct control over the <em>z</em>-axis as well, so be sure to achieve the intended behavior.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Moving along the designed path – static</h2></div></div></div><p>Next, we need to give an opportunity for the enemies to have access to the waypoints stored in the <code class="literal">GameManagerScript</code>. Therefore, we need to get a reference it. There are many ways to do so, but for learning's sake, we will use a static variable (so as to unravel the use of such variables). In fact, all the Pandas share the same game manager, and it's a waste of computational resources if every time a Panda is created, it needs to search for the <code class="literal">Game Manager</code>. A static variable is a value which is shared among all the instances of the <code class="literal">PandaScript</code>. Of course, we need to be careful not to assign this variable many times.</p><div><h3 class="title"><a id="note96"/>Note</h3><p>Remember that static variables are persistent over different scenes/levels. Therefore, if you are planning to release a game with more than one level, most likely you will need to reset this variable when the level is changed. We will explore this better in <a class="link" title="Chapter 8. What Is beyond the Cake?" href="part0100.xhtml#aid-2VBO82">Chapter 8</a>, <em>What Is beyond the Cake?</em>.</p></div><p>Open the <code class="literal">PandaScript</code>, and let's add the static variable to store the reference to the <code class="literal">Game Manager</code>:</p><pre class="programlisting">
<em>//Private static variable to store the Game Manager</em> &#13;
private static GameManagerScript gameManager; &#13;
</pre><p>At the beginning of the <code class="literal">Start()</code> function we need to check if another instance (another Panda) has already been assigned this variable. If not, we will assign it by finding its reference in the scene, even though there will only be one game manager in the scene at the time. As a result, this Panda will actually initialize the variable. As such, all the other instances of Pandas that will be created will have a reference to the <code class="literal">Game Manager</code> ready, and thanks to this check, we are sure that we are assigning it only once:</p><pre class="programlisting">
<em>//If the reference to the Game Manager is missing, the script gets it</em> &#13;
if(gameManager == null) { &#13;
  gameManager = FindObjectOfType&lt;GameManagerScript&gt;(); &#13;
} &#13;
</pre><p>Now, we have to make the Panda move. But first, we need a variable to store the current waypoint that the Panda is heading towards:</p><pre class="programlisting">
<em>//Private counter for the waypoints</em> &#13;
private int currentWaypointNumber; &#13;
</pre><p>Then, we need a constant to establish a threshold after which the waypoint is considered as having been reached. In fact, there are numerical instabilities, and we cannot check directly if the distance from the waypoint is actually zero, only a value very close to it. As you can see, the value assigned to this constant is very low:</p><pre class="programlisting">
<em>//Private constant under which a waypoint is considered reached</em> &#13;
private const float changeDist = 0.001f; &#13;
</pre><p>Finally, we need to implement the mechanism under which the Panda heads towards the right waypoint, and changes direction to the next one when the previous is reached. Since the <code class="literal">MoveTowards()</code> function we will use to move the Panda deals with physics, we need to implement this whole mechanism of the waypoints within the <code class="literal">FixedUpdate()</code> function, as we learnt from <a class="link" title="Chapter 5. The Secret Ingredient Is a Dash of Physics" href="part0062.xhtml#aid-1R42S1">Chapter 5</a>, <em>The Secret Ingredient Is a Dash of Physics</em>. So, we can start writing the following:</p><pre class="programlisting">void FixedUpdate() { &#13;
  <em>//Add here the rest of the code of this section</em> &#13;
} &#13;
</pre><p>In particular, we need to do three things within the <code class="literal">FixedUpdate()</code> function. The first one is to check if the Panda has reached the end of the waypoint list, which means it is in front of the delicious player's cake. If so, we need to trigger the eat animation in the same fashion we triggered the others in <a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 4</a>, <em>No Longer Alone – Sweet-Toothed Pandas Strike</em>. Then, we need to remove this script from the Panda. In fact, the <code class="literal">State Machine Behaviour</code> script we wrote in <a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 4</a>, <em>No Longer Alone – Sweet-Toothed Pandas Strike</em>, will take care of removing the Panda from the scene. Finally, we return so that the rest of the function is not executed:</p><pre class="programlisting">
<em>//if the Panda has reached the cake, then it will eat it, by triggering&#13;
  the right animation,</em>
<em>//and remove this script, since the State Machine Behaviour will take&#13;
  care of removing the Panda</em> &#13;
if (currentWaypointNumber == gameManager.waypoints.Length) { &#13;
  animator.SetTrigger(AnimEatTriggerHash); &#13;
  Destroy(this); &#13;
  return; &#13;
} &#13;
</pre><p>The second thing, in case the Panda is not at the last waypoint yet, is to calculate the distance between the current Panda's position, through its Transform, and the waypoint it is heading towards. This value is stored within a local variable <code class="literal">dist</code>:</p><pre class="programlisting">
<em>//Calculate the distance between the Panda and the waypoint that the&#13;
  Panda is moving towards</em> &#13;
float dist = Vector2.Distance(transform.position,&#13;
  gameManager.waypoints[currentWaypointNumber]); &#13;
</pre><p>The last thing is to check if the Panda is close enough to the waypoint. Enough means below the constant threshold stored in the <code class="literal">changeDist</code>. If so, we just increase the counter of the waypoints so that at the next iteration, the Panda will head to the next waypoint. Otherwise, we just use the <code class="literal">MoveTowards()</code> function implemented in the previous chapter to move the Panda towards the waypoint:</p><pre class="programlisting">
<em>//If the waypoint is considered reached because below the threshold of&#13;
  the constant changeDist</em>
<em>//the counter of waypoints is increased, otherwise the Panda moves&#13;
  towards the waypoint</em> &#13;
if(dist &lt;= changeDist) { &#13;
  currentWaypointNumber++; &#13;
}else { &#13;
  MoveTowards(gameManager.waypoints[currentWaypointNumber]); &#13;
} &#13;
</pre><p>We can save our script and test it out. By placing a Panda in the scene somewhere near the first waypoint and pressing play, we will see it moving along the path.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Implementing waypoints – the second/dynamic way</h1></div></div></div><p>In this section, we will explore a second way to implement the waypoint system of our game. Of course, the outcome will be the same, but this approach offers many other advantages. First of all, it's easier for designers to collocate, change, move, and replace waypoints within the map itself. Second, it allows a great flexibility in behaviors, which can be implemented in such a way to make it easier for designers to use the script created. We will exploit some of the potentiality of this system later in the last chapter of the book.</p><p>Nonetheless, this approach does suffer from some drawbacks, as with every choice in life. In particular, the complexity of the system increases. Moreover, it uses a different game object for each one of the waypoints, and this is critical if the number of waypoints is really high.</p><div><h3 class="title"><a id="note97"/>Note</h3><p>To overcome this last problem of having different game objects for each of the waypoints, we have many possibilities, but making each one of them work is a challenge and at the same time, easy for designers to use. In fact, waypoints can still be stored as a list, not as positions this time, but rather of the <code class="literal">waypoint</code> class, and at the same time expose functionalities to allow designers to edit and place them within the <strong>Scene</strong> view. This is left as a challenge in the <em>Homework</em> section.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Implementing waypoints as separate entities</h2></div></div></div><p>So far, we have seen a simple implementation of the waypoints. Now, we will implement them again, but this time as separate entities. As such, in <a class="link" title="Chapter 8. What Is beyond the Cake?" href="part0100.xhtml#aid-2VBO82">Chapter 8</a>, <em>What Is beyond the Cake?</em>, we will explore how to unlock the potential of waypoints in a game. In fact, at the end of this section, the effect on our game will be the same; however, we will change the script in <a class="link" title="Chapter 8. What Is beyond the Cake?" href="part0100.xhtml#aid-2VBO82">Chapter 8</a>, <em>What Is beyond the Cake?</em>, by implementing more features.</p><p>First of all, we need to erase the <code class="literal">waypoints</code> variable from the <code class="literal">GameManagerScript</code> (but don't erase the script, even if it is empty, because we will use it; for the same reasons, don't erase the <code class="literal">gameManager</code> variable from the <code class="literal">PandaScript</code>).</p><p>Now, we need to create a new script, which will be the actual waypoint. As such, we can rename it as <code class="literal">Waypoint</code>.</p><p>We need a variable of the same class to store the next waypoint. In this way, each waypoint will be able to point/reference towards another waypoint. The goal is to build a chain which the Pandas will follow. Since the variable is private but we still need to have access to it in the <strong>Inspector</strong>, we need to add the serializable property. So, we can add the following to our script:</p><pre class="programlisting">
<em>//Private variable to store the next waypoint in the chain &#13;
//It is serializable, so it can be set in the Inspector</em> &#13;
[SerializeField] &#13;
private Waypoint nextWaypoint; &#13;
</pre><p>Now, from the waypoint, a Panda would like to retrieve its position and the next waypoint to follow, once the current one is reached. To achieve this, we can expose two functions from our <code class="literal">Waypoint</code> script.</p><p>The <code class="literal">GetPosition()</code> function will return a <code class="literal">Vector3</code> with the position of the waypoint, which (in this specific implementation) is stored in the Transform of the waypoint. The code is the following:</p><pre class="programlisting">
<em>//Function to retrieve the position of the waypoint</em> &#13;
public Vector3 GetPosition() { &#13;
  return transform.position; &#13;
} &#13;
</pre><p>The <code class="literal">GetNextWaypoint()</code> function, instead, will return just the next waypoint (at least for the moment), stored in the <code class="literal">nextWaypoint</code> variable. In fact, the <code class="literal">nextWaypoint</code> variable is private, and so Pandas need a function to retrieve it. Therefore, we can just write the following:</p><pre class="programlisting">
<em>//Function to retrieve the next waypoint in the chain</em> &#13;
public Waypoint GetNextWaypoint() { &#13;
  return nextWaypoint; &#13;
} &#13;
</pre><p>We have finished with this script for now, so we can save it.</p><p>The next step is to create a Prefab for our waypoints. Create an empty GameObject and attach the <code class="literal">Waypoint</code> script. Then, in the <strong>Project</strong> panel, create a Prefab called <code class="literal">WaypointPrefab</code> and drag and drop the empty GameObject you have created. Finally, erase the empty GameObject from the scene, since now we have our Prefab.</p><p>Drag and drop as many Prefabs as the number of waypoints you have identified; in our example, there are 11. For your convenience, I suggest you rename them in a progressive order, as shown in the following screenshot:</p><div><img src="img/image00585.jpeg" alt="Implementing waypoints as separate entities"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we need to link them to each other. In particular, <code class="literal">waypoint1</code> will be linked to <code class="literal">waypoint2</code>, which will be linked to <code class="literal">waypoint3</code>, and so on. For instance, <code class="literal">waypoint4</code> should look linked in the <strong>Inspector</strong> as follows:</p><div><img src="img/image00586.jpeg" alt="Implementing waypoints as separate entities"/></div><p style="clear:both; height: 1em;"> </p><p>The only exception is in the last waypoint, which has nothing in the <code class="literal">nextWaypoint</code> variable, as shown in the following screenshot:</p><div><img src="img/image00587.jpeg" alt="Implementing waypoints as separate entities"/></div><p style="clear:both; height: 1em;"> </p><p>Finally, we need to place them at the coordinates we have identified in the <em>Getting the waypoint coordinates</em> section. To quickly recognize them, I recommend that you add a Gizmo icon. As the name suggests, a Gizmo is an icon that will be shown in the Scene view to quickly and easily recognize specific objects, but won't be visible once the game is built. Recently, Unity added also the possibility to see them within the <strong>Game</strong> view.</p><p>The easiest way to insert a Gizmo is by clicking the cube-shaped icon next to the name of the GameObject, highlighted in the following screenshot:</p><div><img src="img/image00588.jpeg" alt="Implementing waypoints as separate entities"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note98"/>Note</h3><p>The same holds for Prefabs, but their icon is a blue cube.</p></div><p>Once you have clicked on this icon, a menu appears as shown in the following screenshot:</p><div><img src="img/image00589.jpeg" alt="Implementing waypoints as separate entities"/></div><p style="clear:both; height: 1em;"> </p><p>By selecting one of the ellipse-shaped icons, you will place a label to the object with its name in it. We will choose one of these for our waypoints. If you click on the circle-shaped or crystal-shaped icons, the Gizmo will look like a circle or a crystal, without any text. If you click the <strong>Other…</strong> button, you can use your own graphics.</p><div><h3 class="title"><a id="note99"/>Note</h3><p>A more complex way to insert Gizmos is through scripting. In fact, there is a special function called <code class="literal">OnDrawGizmos()</code> which is called by Unity when rendering Gizmos is enabled. Within this function, you are able to use any of the functions listed at <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Gizmos.html">https://docs.unity3d.com/ScriptReference/Gizmos.html</a>, which allow you to draw shapes on the screen. This is a very powerful tool, because it can enhance tremendously the usability of your scripts. For instance, in our specific case of waypoints, we could draw the path that Pandas will follow. This is left as an exercise in the <em>Homework</em> section.</p></div><p>In our case, we can select one of the ellipse-shaped icon for all the waypoints. As a result, we are able to see them in the <strong>Scene</strong> view (even if they don't have any explicit rendering component and thus they won't be visible in any way in the final game) and quickly place them.</p><p>At the end, your <strong>Scene</strong> view should look like the following:</p><div><img src="img/image00590.jpeg" alt="Implementing waypoints as separate entities"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we need to specify to the game, which one of these waypoints is the first of the chain. As such, we can store this information within the <code class="literal">Game Manager</code>. So, let's add the following variable to the <code class="literal">GameManagerScript</code>:</p><pre class="programlisting">
<em>//The first waypoint of the chain</em> &#13;
public Waypoint firstWaypoint; &#13;
</pre><p>Finally, after having saved the script, set the variable in the <strong>Inspector</strong>, as shown in the following screenshot:</p><div><img src="img/image00591.jpeg" alt="Implementing waypoints as separate entities"/></div><p style="clear:both; height: 1em;"> </p><p>In conclusion, we have created a chain of waypoints, which is exactly what we need for our game. However, we still need to define how the Pandas get to them.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Moving along the designed path – dynamic</h2></div></div></div><p>The next step is to slightly modify the <code class="literal">PandaScript</code> to take care of this new waypoint system. So, let's open the script again.</p><p>First, we need to substitute the integer variable, <code class="literal">currentWaypointNumber</code>, with a proper waypoint variable, as shown here:</p><pre class="programlisting">
<em>//Private reference to the current waypoint</em> &#13;
private Waypoint currentWaypoint; &#13;
</pre><p>Then, we need to initialize this new variable; we can do it in the <code class="literal">Start()</code> function, by retrieving the first waypoint from the <code class="literal">Game Manager</code>, as shown here:</p><pre class="programlisting">
<em>//Get the first waypoint from the Game Manager</em> &#13;
currentWaypoint = gameManager.firstWaypoint; &#13;
</pre><p>Then, in the first check of the <code class="literal">FixedUpdate()</code> function, we need to check if the variable itself is null (which means that the Panda has reached the cake, because the last waypoint will return a null pointer). Here is the code, with the modified parts highlighted:</p><pre class="programlisting">if (<strong>currentWaypoint == null</strong>) { &#13;
  animator.SetTrigger(AnimEatTriggerHash); &#13;
  Destroy(this); &#13;
  return; &#13;
} &#13;
</pre><p>Going on in the <code class="literal">FixedUpdate()</code> function, we need to change how the distance is calculated, by using the <code class="literal">GetPosition()</code> function of our waypoint in the following way:</p><pre class="programlisting">float dist = Vector2.Distance(transform.position,&#13;
  <strong>currentWaypoint.GetPosition()</strong>); &#13;
</pre><p>Finally, we need to change the last <code class="literal">if</code> statement of the <code class="literal">FixedUpdate()</code> function to get the next waypoint when the previous one is reached. We also need to decide which parameter we should give to our <code class="literal">MoveTowards()</code> function. Again, the modified parts are highlighted:</p><pre class="programlisting">if(dist &lt;= changeDist) { &#13;
  <strong>currentWaypoint = currentWaypoint.GetNextWaypoint();</strong> &#13;
}else { &#13;
  MoveTowards(<strong>currentWaypoint.GetPosition()</strong>); &#13;
} &#13;
</pre><p>Save the script. We have finished this second way of implementing waypoints. <a class="link" title="Chapter 8. What Is beyond the Cake?" href="part0100.xhtml#aid-2VBO82">Chapter 8</a>, <em>What Is beyond the Cake?</em>, will suggest some ways to take advantage of this structure to implement more complex behaviors.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec76"/>More about artificial intelligence in games</h1></div></div></div><p>In the previous sections, we have seen a couple of implementations of a waypoint system to move characters within the game environment. However, as we already said in the introduction, this is not even scratching the surface of AI in games. This section presents some techniques, without entering into detail, as they are not needed to develop our tower defense game. In fact, to master AI in games, you need a specific book about it. Therefore, feel free to skip this section, or read it. You can always come back here later, maybe when you finish the book, for a deeper look at its content. The main goal of this section is just to give you a basic understanding of AI in games.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Other techniques for navigation at the pathfinding level</h2></div></div></div><p>The <em>Pathfinding and its techniques</em> section at the beginning of this chapter was in no way exhaustive, and of course thousands of other techniques exist at the pathfinding level which are used in video games.</p><p>However, it's worth quoting one in particular: Navigation Mesh. This is important, because it's built into the Unity engine for 3D games. The main concept behind this technique is a pre-analysis of the geometry of the level to extract a graph (this is for instance, an offline algorithm) where other pathfinding algorithms can extract paths when needed (these, instead, work online).</p><p>You can generate such a graph by setting some parameters by clicking in the top menu bar on <strong>Window | Navigation</strong>. Specifically, you can set the general options in the <strong>Bake</strong> tab, as shown in the following screenshot:</p><div><img src="img/image00592.jpeg" alt="Other techniques for navigation at the pathfinding level"/></div><p style="clear:both; height: 1em;"> </p><p>Once this graph is built, agents can have access to it through specific classes in scripts.</p><p>In any case, this belongs to the 3D part of Unity, and we won't go into it any further. But if you are interested in learning more, you can start from the official documentation at: <a class="ulink" href="https://docs.unity3d.com/Manual/Navigation.html">https://docs.unity3d.com/Manual/Navigation.html</a> (as you may notice from the table of contents, it's quite a large and extensive tool in Unity, but powerful).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Navigation at the level of steering behaviours</h2></div></div></div><p>Remember how we could implement physics equations in Unity from <a class="link" title="Chapter 5. The Secret Ingredient Is a Dash of Physics" href="part0062.xhtml#aid-1R42S1">Chapter 5</a>, <em>The Secret Ingredient Is a Dash of Physics</em>? We can implement all the equations of the motion and we will obtain any kind of movement. If then, we mix this with a goal, a destination, or even just a direction, along with some obstacle avoidance techniques, we have made a steering behaviour.</p><p>For instance, if you implement obstacle avoidance as magnets that repulse the NPC, and the goal as an attractive magnet, you obtain a pretty nice steering behaviour. Characters could reach destinations without any pathfinding algorithms. Note that I said <em>could</em>. In fact, they can get stuck, and there are many other issues related to steering behaviours as an end-solution. But integrating steering behaviours in a pathfinding algorithm (the first deals with high-level navigation, such as going from one room to another, the second can navigate within the room to reach the door to the next room) is a great addition, which can lead to highly-realistic behaviours with very low performance overhead.</p><div><img src="img/image00593.jpeg" alt="Navigation at the level of steering behaviours"/><div><p>Example of steering behaviour with magnets</p></div></div><p style="clear:both; height: 1em;"> </p><p>Usually, the attraction range of the goal is extended to the whole map, whereas the repulsion force of the obstacles is just local. Moreover, these forces can follow different potential laws, and have different shapes. To help you to visualize magnetic fields, you can give a look at the picture by Dayna Mason at: <a class="ulink" href="https://www.flickr.com/photos/daynoir/2180507211">https://www.flickr.com/photos/daynoir/2180507211</a>. Each compass represents which kind of force the character is subject to when he/she is in that position. The same happens in our example, where the character is pushed away from obstacles and attracted by goals. It is also interesting to note that our goals and obstacles are single pole magnets, but in our physical world they don’t exist (only magnetic dipoles exist).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Navigation at the level of pathfinding/decision making – belief-driven pathfinding</h2></div></div></div><p>As I have already mentioned, research in academia has recently started to merge portions of decision-making within pathfinding. An example of this is one of my own publications about <strong>Belief-Driven Pathfinding</strong> (<strong>BDP</strong>).</p><p>The key concept is that NPCs do not necessarily know the entire map. Imagine there was a bridge to cross a river, but the player had destroyed the bridge; therefore, when the character navigates through the environment, the character should consider the map as if the bridge was still there, because he is not aware that the bridge is down. Only when he approaches the river, he realizes that the bridge is down, and therefore, takes action on it (such as find another path, build another bridge, create a raft with the wood, or swim). That is why it is belief-driven, because the character navigates through the environment as he/she believes the environment is and, as such, makes assumptions.</p><div><h3 class="title"><a id="note100"/>Note</h3><p>If you are interested in learning more about BDP, you can check out my website at: <a class="ulink" href="http://francescosapio.com">francescosapio.com</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Beyond navigation</h2></div></div></div><p>AI in games is not limited to only navigation, but as we said in the introduction, there are many levels that AI can be applied to in video games. Imagine turn-based games, in which NPCs needs to take strategic decisions.</p><p>But AI does not only apply to non-player characters. Some games implement algorithms to adapt the difficulty to the game (adaptive and learning algorithms), others handle how the camera should move in order to raise a specific emotional state in the player (such as in the work of Georgios N. Yannakakis in particular, in the paper, <em>Space Maze: Experience-Driven Game Camera Control</em>). Other games have algorithms of <strong>Procedural Content Generation</strong> (<strong>PCG</strong>), like the famous <em>Temple Run</em> (Imangi studios, 2011) which procedurally generates the level, or even <em>Minecraft</em> (Mojang, 2011) in which a whole world is procedurally generated.</p><p>AI is also applied for analysis of games and players, such as to study the inner structures of games or to gather psychological player profiles. Regarding the latter, you need to imagine the application in serious games, where games can be used to evaluate the performance of people within specific contexts. You can find an interesting introductory paper titled; <em>Towards personalized, gamified systems: an investigation into game design, personality and player typologies</em> by Lauren S. Ferro (available at: <a class="ulink" href="http://dl.acm.org/citation.cfm?id=2513024">http://dl.acm.org/citation.cfm?id=2513024</a>).</p><p>Lastly, it's worth mentioning that the relationship between games and AI is not mono-directional. In fact, not only do games use AI, but also the opposite applies. Some studies and research on AI are helped by video games, which can provide a perfect simulation environment (for instance, for robots), and also create algorithms that take the place of the player and play the game (without cheating, because the AI within the game always uses additional extra data to gather the specific state of the game).</p><p>In any case, keep in mind that when AI is used in games, the most important aim is not to be realistic, but to create an immersive and entertaining experience for the player (which may also result in learning experiences, if the design of the game includes that).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec77"/>Homework</h1></div></div></div><p>In this chapter, we gained an overview of AI in games. However, we focused only on navigation, and in particular, implementing the waypoint system for our game. But you can still improve it, and this section proposes some exercises to achieve that. Therefore, before the next chapter, I invite you to do the following exercises to develop your skills even more:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Becoming an AI designer and programmer</strong>: Think of five games that you play, and select a part of that game that contains NPCs such as the enemies or even the boss. Now, write down a list of behaviors that each of them have. Now, remove some behaviors, or even add some and think about how it would alter the experience. Does it improve it, or does it change the atmosphere entirely? Could you make a relatively realistic behavior into intelligent, yet not realistic, by changing some of the behaviors, and vice versa? By doing this, you will begin to understand the importance that some behaviors play in not only providing life to your characters, but in also giving emotions to the player.</li><li class="listitem"><strong>Waypoints as colliders</strong>: From the previous chapter, we learnt how to use colliders and detect collisions. In particular, we saw how the sprinkles collided with Pandas to trigger actions (in this case, to shoot down the Panda). However, the same principle can be applied here as well. Instead, to use the <code class="literal">changeDist</code> constant and check the distance from the Panda to the waypoint, we can use the <code class="literal">OnTriggerEnter2D()</code> function again to check when a Panda has reached a waypoint. Implement the changing of waypoints in this way, regardless of whether you are using the first or second implementation. Little hint: you probably need to set a new tag (remember how to set a tag from <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers</em>?) for the waypoints, and add colliders on them too.</li><li class="listitem"><strong>Waypoints that auto-reach themselves</strong>: In more complex waypoint systems, you shouldn't manually create the chain (even though the solution becomes hard to scale when the map becomes bigger). As such, try to design and implement a system where the waypoints auto-connect themselves once placed.</li><li class="listitem"><strong>Create a Gizmo path displayer</strong>: Back in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers</em>, we saw how it was possible to use some Gizmo functions to draw useful stuff on the scene. Use those functions, and in particular <code class="literal">Gizmos.DrawLine()</code>, to show the chain of waypoints on the <strong>Scene</strong> view.<p>And finally, there is a challenge for you:</p></li><li class="listitem"><strong>Easy waypoint</strong>: In the second implementation, we use a different game object for each one of the waypoints. Design and implement a system that is as easy as the one implemented in this chapter for designers (so they can drag around the waypoints in the <strong>Scene</strong> view, and possibly see the chain from the previous exercise), but at the same time is efficient, since it won't use game objects for waypoints (but rather an array stored somewhere).</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Summary</h1></div></div></div><p>In this chapter, we learnt the very basics of artificial intelligence in video games. We went through an overview about navigation and some common techniques used.</p><p>Then, we built our navigation system for our game, based on waypoints. In particular, we have implemented two types of waypoint systems for our game, to learn different ways of achieving the same results.</p><p>Finally, we had another general overview about AI in games.</p><p>In the next chapter we will finish our game! Already excited? Well, what are you waiting for? The next chapter is just a page away.</p></div></body></html>