- en: Documenting Your API Using Swagger
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swagger 记录您的 API
- en: 'In this chapter, we will learn how to document our API using the OpenAPI Specification
    and how to use Swagger tools to parse and generate the documentation. Documenting
    APIs is particularly significant when our web service is consumed by an external
    company or a foreign organization team. Moreover, some services can be considerably
    complex and expose a lot of endpoints. For this reason, some tools related to
    the .NET ecosystem guarantee up-to-date API documentation. Two main toolchains
    can be used in this process: NSwag and Swashbuckle. In this book, we will cover
    and use NSwag to document our APIs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 OpenAPI 规范记录我们的 API，以及如何使用 Swagger 工具解析和生成文档。当我们的 Web 服务被外部公司或外国组织团队消费时，记录
    API 特别重要。此外，一些服务可能相当复杂，并公开大量端点。因此，一些与 .NET 生态系统相关的工具保证了 API 文档的更新。在此过程中可以使用两个主要工具链：NSwag
    和 Swashbuckle。在本书中，我们将介绍并使用 NSwag 来记录我们的 API。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding OpenAPI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 OpenAPI
- en: Implementing OpenAPI in ASP.NET Core services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 服务中实现 OpenAPI
- en: By the end of this chapter, you will be able to automatically generate up-to-date
    documentation that's compliant with the OpenAPI Specification using Swagger and
    the NSwag package.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用 Swagger 和 NSwag 包自动生成符合 OpenAPI 规范的最新文档。
- en: Understanding OpenAPI
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OpenAPI
- en: The OpenAPI initiative is part of the Linux Foundation and defines the **OpenAPI**
    **Specification** (**OAS**) standard. The OpenAPI Specification aims to provide
    a language-agnostic interface for REST APIs. This kind of approach guarantees
    that both humans and client applications understand and discover the capabilities
    of a web service by referring to a unique entry point. In addition, it provides
    a high-level abstraction that can also be used for business or design purposes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 创新是 Linux 基金会的一部分，并定义了 **OpenAPI** **规范**（**OAS**）标准。OpenAPI 规范旨在为 REST
    API 提供一个语言无关的接口。这种方法保证了人类和客户端应用程序可以通过参考一个唯一的入口点来理解和发现 Web 服务的功能。此外，它还提供了一个高级抽象，也可以用于商业或设计目的。
- en: Furthermore, its standard way of querying services facilitates every kind of
    automation – from the autogeneration of a client to the autogeneration of the
    documentation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其查询服务的标准方式简化了各种自动化——从客户端的自动生成到文档的自动生成。
- en: Implementing the Swagger project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Swagger 项目
- en: Just like the OpenAPI Specification, Swagger was born as a language-agnostic
    specification for describing REST APIs. It has recently been adopted by the OpenAPI
    project, which means there are no differences between these two projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 OpenAPI 规范一样，Swagger 作为一个描述 REST API 的语言无关规范而诞生。它最近已被 OpenAPI 项目采用，这意味着这两个项目之间没有差异。
- en: 'The main aim of Swagger is to autogenerate and expose a document called `swagger.json`,
    also known as the **Swagger Specification**. The Swagger Specification is the
    autogenerated documentation of the API and provides information about every single
    route that''s exposed by the web services. The following code shows the structure
    of an example `swagger.json` file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 的主要目标是自动生成并公开一个名为 `swagger.json` 的文档，也称为 **Swagger 规范**。Swagger 规范是
    API 的自动生成文档，提供了关于 Web 服务公开的每个单独路由的信息。以下代码展示了示例 `swagger.json` 文件的结构：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding snippet describes some of the routes that are defined in the
    **catalog service** API. As you can see, at the first level of the JSON, there
    is some general information about the service, such as the `apiVersion`, `title`,
    and `basePath` of the service. Furthermore, we can also see a node called `paths`,
    which contains all the paths of our service. For each route, it describes the
    different response types, the different HTTP verbs, and all the payload information
    that''s accepted by the service. Since we have a unique standard for describing
    our APIs, it is also possible to define a unique user interface so that we can
    query and send information to the service; this is what **Swagger UI** does. Swagger
    UI is a tool that uses the `swagger.json` file to provide a user-friendly UI:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段描述了在**目录服务**API中定义的一些路由。正如你所见，在JSON的第一级中，有一些关于服务的一般信息，例如服务的`apiVersion`、`title`和`basePath`。此外，我们还可以看到一个名为`paths`的节点，它包含我们服务的所有路径。对于每个路由，它描述了不同的响应类型、不同的HTTP动词以及服务接受的全部有效负载信息。由于我们有一个独特的标准来描述我们的API，因此也可以定义一个独特的用户界面，以便我们可以查询并向服务发送信息；这就是**Swagger
    UI**的作用。Swagger UI是一个使用`swagger.json`文件提供用户友好UI的工具：
- en: '![](img/68000202-f3d8-455b-928f-d5a3f0a2952f.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68000202-f3d8-455b-928f-d5a3f0a2952f.png)'
- en: The preceding screenshot shows an example of a useful UI that we can use to
    browse the different routes that are exposed by the APIs. Furthermore, it allows
    the consumer to have an immediate overall view of the data that's provided by
    the API. Now, let's learn how to implement OpenAPI in ASP.NET Core.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我们可以用来浏览API公开的不同路由的有用UI示例。此外，它还允许消费者立即全面了解API提供的数据。现在，让我们学习如何在ASP.NET
    Core中实现OpenAPI。
- en: Implementing OpenAPI in ASP.NET Core services
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET Core服务中实现OpenAPI
- en: 'There are two different packages that we can use to implement OpenAPI in ASP.NET
    Core:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两个不同的包在ASP.NET Core中实现OpenAPI：
- en: '**Swashbuckle**: [https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swashbuckle**: [https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.2)'
- en: '**NSwag**: [https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NSwag**: [https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-nswag?view=aspnetcore-2.2)'
- en: 'Both of these use middleware to generate and serve the `swagger.json` file
    and allow the user interface to browse the service definition. In this section,
    we will discuss how to integrate NSwag into our vinyl catalog service. The following
    schema shows how NSwag is plugged into our ASP.NET Core service:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都使用中间件来生成和提供`swagger.json`文件，并允许用户界面浏览服务定义。在本节中，我们将讨论如何将NSwag集成到我们的vinyl目录服务中。以下架构显示了NSwag是如何集成到我们的ASP.NET
    Core服务中的：
- en: '![](img/9316aeb8-6ddc-4e23-b63f-140dc116b563.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9316aeb8-6ddc-4e23-b63f-140dc116b563.png)'
- en: 'Let''s start by adding `NSwag.AspNetCore` to the `Catalog*.*API` project by
    using the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通过以下命令将`NSwag.AspNetCore`添加到`Catalog*.*API`项目开始：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, we can proceed by combining the middleware to generate and provide
    the OpenAPI specification and the middleware to initialize the UI. As we saw in
    [Chapter 3](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml), *Working with the Middleware
    Pipeline*, we need to use the `Configure` and `ConfigureServices` methods, which
    are implemented in the `Startup` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过结合生成和提供OpenAPI规范的中介件以及初始化UI的中介件来继续操作。正如我们在[第3章](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml)“与中介件管道一起工作”中看到的，我们需要使用在`Startup`类中实现的`Configure`和`ConfigureServices`方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`AddOpenApiDocument` adds the services that are required for OpenAPI 3.0 generation.
    `UseOpenApi` adds the OpenAPI/Swagger generator, which uses API description to
    perform Swagger generation, and `UseSwaggerUi3` creates and instantiates the middleware
    that provides the UI of Swagger. Since we integrated the OpenAPI middleware into
    our service, we can proceed by running our service and browse the `https://localhost/swagger`
    URL using our preferred browser.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOpenApiDocument` 添加了生成 OpenAPI 3.0 所需的服务。`UseOpenApi` 添加了 OpenAPI/Swagger
    生成器，它使用 API 描述来执行 Swagger 生成，而 `UseSwaggerUi3` 创建并实例化提供 Swagger UI 的中间件。由于我们已经将
    OpenAPI 中间件集成到我们的服务中，我们可以通过运行我们的服务并使用我们首选的浏览器浏览 `https://localhost/swagger` URL
    来继续操作。'
- en: NSwag and Swashbuckle use reflection to browse the action methods inside our
    controllers. Fortunately, this process is only executed the first time the service
    runs. Sometimes, complex response types can prevent the `swagger.json` file from
    being generated. For that reason, it is strongly suggested that you check all
    the response types that are provided by the action methods of our controllers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NSwag 和 Swashbuckle 使用反射来浏览我们控制器内的操作方法。幸运的是，这个过程只在服务第一次运行时执行。有时，复杂的响应类型可能会阻止生成
    `swagger.json` 文件。因此，强烈建议您检查我们控制器操作方法提供的所有响应类型。
- en: 'NSwag also provides some useful utilities so that we can perform code generation
    on our web services, such as the following ones:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NSwag 还提供了一些有用的工具，以便我们可以在我们的 Web 服务上执行代码生成，例如以下这些：
- en: '`NSwag.CodeGeneration.CSharp` ([https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/](https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/))'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSwag.CodeGeneration.CSharp` ([https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/](https://www.nuget.org/packages/NSwag.CodeGeneration.CSharp/))'
- en: '`NSwag.CodeGeneration.TypeScript` ([https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/](https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/))'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSwag.CodeGeneration.TypeScript` ([https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/](https://www.nuget.org/packages/NSwag.CodeGeneration.TypeScript/))'
- en: These allow us to autogenerate client classes for C# and Typescript, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许我们分别为 C# 和 Typescript 自动生成客户端类。
- en: In this section, we learned how to install and configure NSwag so that we can
    expose Swagger documentation that's compatible with the OpenAPI Specification.
    In the next section, we will learn how to explicitly define the conventions for
    our APIs, as well as how to include additional information in the `swagger.json`
    contract.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何安装和配置 NSwag，以便我们可以公开与 OpenAPI 规范兼容的 Swagger 文档。在下一节中，我们将学习如何显式定义我们
    API 的约定，以及如何在 `swagger.json` 合同中包含额外的信息。
- en: Understanding ASP.NET Core's conventions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 的约定
- en: 'The default response type of the Swagger UI produces some incorrect information.
    If we take a look at the responses section, we will see that the response code
    is incorrect and that it doesn''t correspond with the actual HTTP code that''s
    returned by the web service. When using ASP.NET Core 2.2 or later, it is possible
    to use conventions to specify the response types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 的默认响应类型会产生一些错误信息。如果我们查看响应部分，我们会看到响应代码是不正确的，并且它与由 Web 服务返回的实际 HTTP
    代码不对应。当使用 ASP.NET Core 2.2 或更高版本时，可以使用约定来指定响应类型：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For example, the preceding code uses the `ApiConventionMethod` attribute to
    pass a custom type and a method name. The `ApiConventionMethod` attribute is part
    of the `Microsoft.AspNetCore.Mvc` namespace and uses the `DefaultApiConventions`
    static class, which provides a default set of conventions for each action in a
    generic API. In the same way, we can add that attribute to the writing methods
    of `ItemController`, such as the `Create`, `Update`, and `Delete` methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的代码使用 `ApiConventionMethod` 属性传递一个自定义类型和方法名称。`ApiConventionMethod` 属性是
    `Microsoft.AspNetCore.Mvc` 命名空间的一部分，并使用 `DefaultApiConventions` 静态类，它为通用 API 中的每个操作提供一组默认约定。同样，我们还可以将此属性添加到
    `ItemController` 的写入方法中，例如 `Create`、`Update` 和 `Delete` 方法：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This kind of approach is a shortcut that we can use to declare action method
    responses without explicitly using the `ProducesResponseType` attribute. Let''s
    take a look at the `DefaultApiConventions` static class, which provides a set
    of default response types if we declare some static void methods:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是一种快捷方式，我们可以用它来声明操作方法响应，而无需显式使用 `ProducesResponseType` 属性。让我们看看 `DefaultApiConventions`
    静态类，如果我们声明一些静态 void 方法，它将提供一组默认响应类型：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For example, for the `Get` method, it states the `HTTP 200 OK` response and
    `HTTP 404 Not found`. By doing this, we can easily declare the proper response
    types for each action. The `DefaultApiConventions` class is part of the `Microsoft.AspNetCore.Mvc`
    namespace.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 `Get` 方法，它声明了 `HTTP 200 OK` 响应和 `HTTP 404 Not found`。通过这样做，我们可以轻松地为每个操作声明适当的响应类型。`DefaultApiConventions`
    类是 `Microsoft.AspNetCore.Mvc` 命名空间的一部分。
- en: Custom conventions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义约定
- en: 'The `DefaultApiConvention` class isn''t always suitable for our controllers.
    Furthermore, it is too generic, and action methods are usually too specific to
    suit the `DefaultApiConvention` class. Due to this, ASP.NET Core allows us to
    create our custom API conventions based on our needs. To declare a new convention,
    we need to create a new static class with the corresponding static methods, like
    so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultApiConvention` 类并不总是适合我们的控制器。此外，它过于通用，操作方法通常过于具体，不适合 `DefaultApiConvention`
    类。因此，ASP.NET Core 允许我们根据我们的需求创建自定义的 API 约定。要声明一个新的约定，我们需要创建一个新的静态类，其中包含相应的静态方法，如下所示：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The conventions we''ve implemented here describe the `Get` action method of
    `ItemController`. As you can see, this method produces the following HTTP responses:
    `200`, `404`, and `400`. This approach also allows us to generate and extend the
    response types that are returned by a route. Furthermore, it is possible to assign
    and use these conventions by applying the attribute in the following way:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实现的约定描述了 `ItemController` 的 `Get` 操作方法。如您所见，此方法产生以下 HTTP 响应：`200`、`404`
    和 `400`。这种方法还允许我们生成和扩展由路由返回的响应类型。此外，我们可以通过以下方式应用属性来分配和使用这些约定：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This approach allows us to customize and group API conventions into a unique
    class and fully-customize the contract of the API. The same approach can be used
    for the other action methods that are present in the controller classes of your
    services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们能够将 API 约定自定义并分组到一个独特的类中，并完全自定义 API 的合同。同样的方法也可以用于您服务中控制器类中存在的其他操作方法。
- en: Summary
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to improve the discoverability of web services
    by documenting them using the OpenAPI Specification. The OpenAPI technique also
    provides us with a standard way to generate clients in every language and generate
    auto-maintainable documentation. Documenting APIs is useful when the service is
    utilized by third-party teams and consumers, and also provides us with a high-level
    overview of the information and actions that are exposed by the service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过使用 OpenAPI 规范来记录 Web 服务，从而提高其可发现性。OpenAPI 技术还为我们提供了一种标准方式，以生成每种语言的客户端并生成自动维护的文档。当服务被第三方团队和消费者使用时，记录
    API 是有用的，并且它还为我们提供了服务公开的信息和动作的高级概述。
- en: In the next chapter, we will learn about Postman and how to use it to query,
    test, and check the responses of a web service.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于 Postman 以及如何使用它来查询、测试和检查 Web 服务的响应。
