<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing Microservices</h1>
                
            
            
                
<p>In the previous chapter, we discussed the problems of a layered monolith architecture. In this chapter, we will discuss how we can refactor them from the existing system and build separate microservices for products and orders. In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to C# 7.0, Entity Framework Core, Visual Studio 2017, and Microsoft SQLServer</li>
<li>Size of microservices</li>
<li>What makes a good service?</li>
<li>Domain-driven design (DDD) and its importance for microservices</li>
<li>The concept of Seam</li>
<li>Communication between microservices</li>
<li>Revisiting the Flix One case study</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Before we proceed with the concepts to implement microservices, it is worth mentioning the core concepts, languages, and tools that we're using to implement these microservices. In this chapter, we will get an overview of these topics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">C# 7.0</h1>
                
            
            
                
<p>C# is a programming language developed by Microsoft. The current release at the time of writing this book is C# 7.0. The language appeared in 2002. This language is an object-oriented language and component-oriented. The current version has various new features such as ValueTuple, Deconstructors, pattern matching, the switch statement local function, and so on.</p>
<p>We are not going into details of these features as it's beyond the scope of this book. Refer to <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/</a> for more details.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Entity Framework Core</h1>
                
            
            
                
<p><strong>Entity Framework Core</strong> (<strong>EF Core</strong>) is a cross-platform version of Microsoft Entity Framework that is one of the most popular <strong>object-relational mappers</strong> (<strong>ORMs</strong>).</p>
<p>ORM is a technique that helps you to query and manipulate data as per required business output. Refer to the discussion at <a href="https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it">https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it</a> for more details.</p>
<p>EF Core supports various databases. A complete list of databases is available here: <a href="https://docs.microsoft.com/en-us/ef/core/providers/index">https://docs.microsoft.com/en-us/ef/core/providers/index</a>. The current version of EF Core is 2.0. To get familiar with EF Core, I suggest you read this: <a href="https://docs.microsoft.com/en-us/ef/core/get-started/index">https://docs.microsoft.com/en-us/ef/core/get-started/index</a> in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Visual Studio 2017</h1>
                
            
            
                
<p>Visual Studio is one of the best <strong>Integrated Development Environments</strong> (<strong>IDE</strong>) created by Microsoft. It enables developers to work in various ways using famous languages(for example, C#, VB.NET F#, and so on). The current release of Visual Studio 2017 is update 3 (VS15.3).</p>
<p>An IDE is a software application that provides a facility for programmers to write programs using programming languages. For more information, visit <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">https://en.wikipedia.org/wiki/Integrated_development_environment.</a></p>
<p>Microsoft also released Visual Studio for macOS, and the new avatar of Visual Studio has many tremendous features. For more information please refer to <a href="https://www.visualstudio.com/vs/whatsnew/">https://www.visualstudio.com/vs/whatsnew/</a>. In this book, all examples are written using Visual Studio 2017 update 3. You can also download a community edition that is free: <a href="https://www.visualstudio.com/">https://www.visualstudio.com/.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Microsoft SQLServer</h1>
                
            
            
                
<p><strong>Microsoft SQLServer</strong> (<strong>MSSQL</strong>) is a software application that is a relational database management system. It's mainly used as  database software to store and retrieve data. This is built on top of SQL, that is, Structured Query Language: <a href="http://searchsqlserver.techtarget.com/definition/SQL">http://searchsqlserver.techtarget.com/definition/SQL</a>.</p>
<p>The current release, that is, SQL Server 2017, is more robust and can be used on Windows and Linux. You can get SQL Server 2017 from here: <a href="https://www.microsoft.com/en-IN/sql-server/sql-server-2017">https://www.microsoft.com/en-IN/sql-server/sql-server-2017</a>. Please note that we will use SQL Server 2008 R2 or later in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Size of microservices</h1>
                
            
            
                
<p>Before we start building our microservices, we should be clear about a few of their basic aspects, such as what factors to consider while sizing our microservices and how to ensure their isolation from the rest of the system.</p>
<p>As the name suggests, microservices should be micro. A question arises: what is micro? Microservices are all about size and granularity. To understand this better, let's consider the application discussed in <a href="274437a4-3708-4913-96b3-539e376c71fb.xhtml">Chapter 1</a>, <em>An Introduction to Microservices</em>.</p>
<p>We wanted the teams working on this project to stay synchronized at all times with respect to their code. Staying synchronized is even more important when we release the complete project. We needed to first decompose our application/specific parts into smaller functionalities/segments of the main service. Let's discuss the factors that need to be considered for the high-level isolation of microservices:</p>
<ul>
<li>Risks due to requirement changes: Changes in the requirements of one microservice should be independent of other microservices. In such a case, we will isolate/split our software into smaller services in such a way that if there are any requirement changes in one service, they will be independent of another microservice.</li>
<li>Functionality changes: We will isolate the functionalities that are rarely changed from the dependent functionalities that can be frequently modified. For example, in our application, the customer module notification functionality will rarely change. But its related modules, such as <kbd>Order</kbd>, are more likely to have frequent business changes as part of their life cycle.</li>
<li>Team changes: We should also consider isolating modules in such a way that one team can work independently of all the other teams. If the process of making a new developer productive—regarding the tasks in such modules—is not dependent on people outside the team, it means we are well placed.</li>
<li>Technology changes: Technology use needs to be isolated vertically within each module. A module should not be dependent on a technology or component from another module. We should strictly isolate the modules developed in different technologies or stacks, or look at moving them to a common platform as a last resort.</li>
</ul>
<p>Our primary goal should not be to make services as small as possible; instead, our goal should be to isolate the identified bounded context and keep it small.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What makes a good service?</h1>
                
            
            
                
<p>Before microservices were conceptualized, whenever we thought of enterprise application integration, middleware looked like the most feasible option. Software vendors offered <strong>Enterprise Service Bus</strong> (<strong>ESB</strong>), and it was one of the best options for middleware.</p>
<p>Besides considering these solutions, our main priority should be inclined toward the architectural features. When microservices arrived, middleware was no longer a consideration. Rather, the focus shifted to contemplation of business problems and how to tackle those problems with the help of the architecture.</p>
<p>In order to make a service that can be used and maintained easily by developers and users, the service must have the following features (we can also consider these as characteristics of good services):</p>
<ul>
<li>Standard data formats: Good services should follow standardized data formats while exchanging services or systems with other components. The most popular data formats used in the .NET stack are XML and JSON.</li>
<li>Standard communication protocol: Good services should obey standard communication formats, such as SOAP and REST.</li>
<li>Loose coupling: One of the most important characteristics of a good service is that it follows loose coupling. When services are loosely coupled, we don't have to worry about changes. Changes in one service will not impact other services.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">DDD and its importance for microservices</h1>
                
            
            
                
<p><strong>Domain-Driven Design</strong> (<strong>DDD</strong>) is a methodology and a process of designing complex systems. In these sections, we will briefly discuss DDD and how it is important in the context of microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Domain model design</h1>
                
            
            
                
<p> The main objective of domain design is to understand the exact domain problems and then draft a model that can be written in any language or set of technologies. For example, in our Flix One bookstore application, we need to understand <em>Order Management</em> and <em>Stock Management</em>.</p>
<p>Here are a few characteristics of the domain-driven model:</p>
<ul>
<li>A domain model should focus on a specific business model and not multiple business models</li>
<li>It should be reusable</li>
<li>It should be designed so that it can be called in a loosely coupled way, unlike the rest of the system</li>
<li>It should be designed independently of persistence implementations</li>
<li>It should be pulled out from a project to another location, so it should not be based on any infrastructure framework</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Importance for microservices</h1>
                
            
            
                
<p>DDD is the blueprint and can be implemented by microservices. In other words, once DDD is done, we can implement it using microservices. This is just like how, in our application, we can easily implement <em>Order services</em>, <em>Inventory services</em>, <em>Tracking services</em>, and so on.</p>
<p>Once you have dealt with the transition process to your satisfaction, a simple exercise should be performed. This will help you verify that the size of the microservice is small enough. Every system is unique and has its own complexity level. Considering these levels of your domain, you need to have a baseline for the maximum number of domain objects that can talk to each other. If any service fails this evaluation criterion, then you have a possible candidate to evaluate your transition once again. However, don't get into this exercise with a specific number in mind; you can always go easy. As long as you have followed all the steps correctly, the system should be fine for you.</p>
<p>If you feel that this baseline process is difficult for you to achieve, you can take another route. Go through all the interfaces and classes in each microservice. Considering all the steps we have followed, and the industry standard coding guidelines, anybody new to the system should be able to make sense of its purpose.</p>
<p>You can also perform another simple test to check whether the correct vertical isolation of the services was achieved. You can deploy each one of them and make them live with the rest of the services, which are still unavailable. If your service goes live and continues listening for incoming requests, you can pat yourself on the back.</p>
<p>There are many benefits that you can derive from the isolated deployment capability. The capability to just deploy them independently allows the host in them to enter its own independent processes. It allows you to harness the power of the cloud and other hybrid models of hosting that you can think of. You are free to independently pick different technologies for each one of them as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The concept of seam</h1>
                
            
            
                
<p>At the very core of microservices lies the capability to work on a specific functionality in isolation from the rest of the system. This translates into all the advantages discussed earlier, such as reduced module dependency, code reusability, easier code maintenance, and better deployment.</p>
<p>In my opinion, the same attributes that were attained with the implementation of microservices should be maintained during the process of implementation. Why should the whole process of moving monoliths to microservices be painful and not be as rewarding as using the microservices themselves? Just remember that the transition can't be done overnight and will need meticulous planning. Many capable solution architects have differed in their approaches while presenting their highly capable teams. The answer lies not just in the points already mentioned, but in the risk to the business itself.</p>
<p>This is very well attainable. However, we must identify our method correctly in order to achieve it. Otherwise, there is a possibility that the whole process of transitioning a monolithic application to microservices could be a dreadful one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Module interdependency</h1>
                
            
            
                
<p>This should always be the starting point when trying to transition a monolithic application to microservice-style architecture. Identify and pick up those parts of the application that are least dependent on other modules and have the least dependency on them, as well.</p>
<p>It is very important to understand that by identifying such parts of the application, you are not just trying to pick up the least challenging parts to deal with. However, at the same time, you have identified seams, which are the most easily visible ones. These are parts of the application where we will perform the necessary changes first. This allows us to completely isolate this part of the code from the rest of the system. It should be ready to become a part of the microservice or deployed in the final stage of this exercise.</p>
<p>Even though such seams have been identified, the capability to achieve microservice-style development is still a little further away. This is a good start, though.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technology</h1>
                
            
            
                
<p>A two-pronged approach is required here. First, you must identify what different features of the application's base framework are being utilized. The differentiation could be, for example, implemented on the basis of heavy dependency on certain data structures, interprocess communication being performed, or the activity of report generation. This is the easier part.</p>
<p>However, as the second step, I recommend that you become more confident and pick up pieces that use a type of technology that is different from what is being used currently. For example, there could be a piece of code relying on simple data structures or XML-based persistence. Identify such baggage in the system and mark it for a transition. A lot of prudence is required in this twin-pronged approach. Making a selection that is too ambitious could set you on a path similar to what we have been trying to avoid altogether.</p>
<p>Some of these parts might not look like very promising candidates for the final microservice-style architecture application. They should still be dealt with now. In the end, they will allow you to easily perform the transition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Team structure</h1>
                
            
            
                
<p>With every iteration of this identification process being executed, this factor becomes more and more important. There could be teams that are differentiated on various grounds, such as their technical skill set, geographical location, or security requirements (employees versus outsourced).</p>
<p>If there is a part of the functionality that requires a specific skill set, then you could be looking at another probable Seam candidate. Teams can be composed of varying degrees of these differentiation factors. As part of the transition to microservices, the clear differentiation that could enable them to work independently could further optimize their productivity.</p>
<p>This can also provide a benefit in the form of safeguarding the intellectual property of the company—outsourcing to consultants for specific parts of the application is not uncommon. The capability to allow consultants or partners to help you only on a specific module makes the process simpler and more secure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Database</h1>
                
            
            
                
<p>The heart and soul of any enterprise system is its database. It is the biggest asset of the system on any given day. It is also the most vulnerable part of the whole system in such an exercise. No wonder database architects can sound mean and intruding whenever you ask them to make even the smallest change. Their domain is defined by database tables and stored procedures.</p>
<p>The health of their domain is judged by the referential integrity and the time it takes to perform various transactions. I don't hold them guilty for overdoing it anymore. They have a reason for this—their past experiences. It's time to change that. Let me tell you, this won't be easy, as we will have to utilize a completely different approach to handle data integrity once we embark on this path.</p>
<p>You might think that the easiest approach is to divide the whole database in one go, but this is not the case. It can lead us to the situation we have been trying to avoid all along. Let's look at how to go about doing this in a more efficient manner.</p>
<p>As you move along, picking up pieces after the module dependency analysis, identify the database structures that are being used to interact with the database. There are two steps that you need to perform here. First, check whether you can isolate the database structures in your code to be broken down, and align this with the newly defined vertical boundaries. Second, identify what it would take to break down the underlying database structure as well.</p>
<p>Don't worry yet if breaking down the underlying data structure seems difficult. If it appears that it is involving other modules that you haven't started to move to microservices, it is a good sign. Don't let the database changes define the modules that you would pick and migrate to microservice-style architecture. Keep it the other way round. This ensures that when a database change is picked up, the code that depends on the change is already ready to absorb the change.</p>
<p>This ensures that you don't pick up the battle of data integrity while you are already occupied with modifying the code that would rely on this part of the database. Nevertheless, such database structures should draw your attention so that the modules that depend on them are picked next. This will allow you to easily complete the move to microservices for all the associated modules in one go. Refer to the following diagram:</p>
<div><img class="image-border" height="313" src="img/041baa4c-439d-4fd5-97ec-6d6b82f20456.png" width="446"/></div>
<p>Here, we have not broken the database yet. Instead, we have simply separated our database access part into layers as part of the first step.</p>
<p>What we have simply done is map the code data structure the database, and they no longer depend on each other. Let's see how this step would work out when we remove foreign key relationships.</p>
<p>If we can transition the code structures being used to access the database along with the database structure, we will save time. This approach might differ from system to system and can be affected by our personal bias. If your database structure changes seem to be impacting modules that are yet to be marked for transition, move on for now.</p>
<p>Another important point to understand here is what kind of changes are acceptable when you break down this database table or merge it with another partial structure? The most important thing is not to shy away from breaking those foreign key relationships apart. This might sound like a big difference from our traditional approach to maintaining data integrity. However, removing your foreign key relationships is the most fundamental challenge when restructuring your database to suit the microservice architecture. Remember that a microservice is meant to be independent of other services. If there are foreign key relationships with other parts of the system, it makes it dependent on the services owning that part of the database. Refer to the following diagram:</p>
<div><img class="image-border" height="127" src="img/d192da44-e0e3-4344-b40a-29bb63c009b4.png" width="455"/></div>
<p>As part of step two, we have kept the foreign key fields in the database tables but have removed the foreign key constraint. So the <strong>ORDER</strong> table is still holding information about <strong>ProductID</strong>, but the foreign key relation is broken now. Refer to the following diagram:</p>
<div><img class="image-border" height="191" src="img/cfefb0b7-e7e8-439e-87e1-34f2f8a05e41.png" width="338"/></div>
<p class="CDPAlignLeft CDPAlign">This is what our microservice-style architecture would finally look like. The central database would be moved away in favor of each service having their own database. So, separating the data structures in the code and removing foreign key relationships is our preparation to finally make the change. The connected boundaries of microservices in the preceding figure signify the interservice communication.</p>
<p>With the two steps performed, your code is now ready to split <strong>ORDER</strong> and <strong>PRODUCT</strong> into separate services, with each having their own database.</p>
<p>If all of the discussion here has left you bewildered about all those transactions that have been safely performed up to now, you are not alone. This outcome of the challenge with the transactions is not a small one by any means, and deserves focused attention. We'll talk about this in detail a bit later. Before that, there is another part that becomes a no man's land in the database. It is master data or static data, as some may call it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Master data</h1>
                
            
            
                
<p>Handling master data is more about your personal choice and system-specific requirements. If you see that the master data is not going to change for ages and occupies an insignificant amount of records, you are better off with the configuration files or even code enumerations.</p>
<p>This requires someone to push out the configuration files once in a while when the changes do happen. However, this still leaves a gap for the future. As the rest of the system would depend on this one module, it will be responsible for these updates. If this module does not behave correctly, other parts of the system relying on it could also be impacted negatively.</p>
<p>Another option could be to wrap up the master data in a separate service altogether. Having the master data delivered through a service would provide the advantage of the services knowing the change instantly and understanding the capability to consume it as well.</p>
<p>The process of requesting this service might not be much different from the process of reading configuration files when required. It might be slower, but then it is to be done only as many times as necessary.</p>
<p>Moreover, you could also support different sets of master data. It would be fairly easy to maintain product sets that differ every year. With the microservice architecture style, it is always a good idea to be independent of any kind of outside reliance in future.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transaction</h1>
                
            
            
                
<p>With our foreign keys gone and the database split into smaller parts, we need to devise our own mechanisms for handling data integrity. Here, we need to factor in the possibility that not all services would successfully go through a transaction in the scope of their respective data stores.</p>
<p>A good example is a user ordering a specific product. At the time the order is being accepted, there is a sufficient quantity available to be ordered. However, by the time the order is logged, the Product service cannot log the orders for some reason. We don't know yet whether is was due to insufficient quantity or some other communication fault within the system. There are two possible options here. Let's discuss them one by one.</p>
<p>The first option is to try again and perform the remaining part of the transaction sometime later. This would require us to orchestrate the whole transaction in a way that tracks individual transactions across services. So every transaction that leads to transactions being performed for more than one service must be tracked. In case one of them does not go through, it deserves a retry. This might work for long-lived operations.</p>
<p>However, for other operations, this could cause a real problem. If the operation is not long-lived and you still decide to retry, the outcome will result in either locking out other transactions or making the transaction wait—meaning it is impossible to complete it. </p>
<p>Another option that we can contemplate here is to cancel the entire set of transactions spread across various services. This means that a single failure at any stage of the entire set of transactions would result in the reversal of all the previous transactions.</p>
<p>This is one area where maximum prudence would be required, and it would be time well invested. A stable outcome is only guaranteed when the transactions are planned out well in any microservice-style architecture application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication between microservices</h1>
                
            
            
                
<p>In the preceding section, we separated our <em>Order module</em> into <strong>Order services</strong> and discussed how we can break down the foreign key relationship between <strong>ORDER</strong> and <strong>PRODUCT</strong> tables.</p>
<p>In a monolithic application, we have a single repository that queries the database to fetch the records from both <strong>ORDER</strong> and <strong>PRODUCT</strong> tables. However, in our upcoming microservice application, we will segregate repositories between <strong>Order service</strong> and <strong>Product service</strong>. With each service having its respective database, each one would access its own database only. <strong>Order service</strong> would only be able to access order <strong>Database</strong>, whereas <strong>Product service</strong> would be able to access product <strong>Database</strong> only. <strong>Order service</strong> should not be allowed to access product <strong>Database</strong> and vice versa. </p>
<p>We will discuss communication between microservices in Chapter 3, <em>Integration Techniques and Microservices</em>, in detail.</p>
<p class="mce-root CDPAlignLeft CDPAlign">Refer to the following diagram:</p>
<div><img class="image-border" height="225" src="img/357146ab-c997-4a2c-8a36-26bae14d8155.png" width="304"/></div>
<p class="CDPAlignLeft CDPAlign">In the preceding figure, we can see that our UI is interacting with <strong>Order Service</strong> and <strong>Product service</strong> via <strong>API gateway</strong>. Both the services are physically separated from each other and there is no direct interaction between these services. Communication performed in this manner is also referred to as communication that is based on the <em>API Gateway Pattern</em>.</p>
<p>The API gateway is nothing but a middle tier via which the UI can interact with the microservices. It also provides a simpler interface and makes the process of consuming these services simpler. It provides a different level of granularity to different clients as required (browser and desktop).</p>
<p>We can say that it provides coarse-grained APIs to mobile clients and fine-grained APIs to desktop clients, and it can use a high-performance network underneath its hood to provide some serious throughput.</p>
<p>The definition of granularity from Wikipedia is as follows (<a href="https://en.wikipedia.org/wiki/Granularity">https://en.wikipedia.org/wiki/Granularity</a>):</p>
<p>"<strong>Granularity</strong> is the extent to which a system is broken down into small parts, either the system itself or its description or observation. It is the extent to which a larger entity is subdivided. For example, a yard broken into inches has a finer granularity than a yard broken into feet.<br/>
Coarse-grained systems consist of fewer, larger components than fine-grained systems; a coarse-grained description of a system regards large subcomponents while a fine-grained description regards smaller components of which the larger ones are composed."</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of the API gateway for microservices</h1>
                
            
            
                
<p>There is no doubt that the API gateway is beneficial for microservices. With its use, you can do the following:</p>
<ul>
<li>Invoke services through the API gateway </li>
<li>Reduce round trips between the client and the application </li>
<li>The client has the ability to access different APIs in one place, as segregated by the gateway</li>
</ul>
<p>It provides flexibility to clients in such a manner that they are able to interact with different services as and when they need to. This way, there is no need to expose complete/all services at all. API gateway is a component of complete API management. In our solution, we will use Azure API management, and we will explain it further in Chapter 3, <em>Integration Techniques and Microservices</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API gateway versus API management</h1>
                
            
            
                
<p>In the preceding section, we discussed how the API gateway hides the actual APIs from its client and then simply redirects the calls to the actual API from these clients. The API management solution provides a complete management system to manage all the APIs of its external consumers. All API management solutions, such as Azure API management (<a href="https://docs.microsoft.com/en-us/azure/api-management/">https://docs.microsoft.com/en-us/azure/api-management/</a>), provide various capabilities and functionalities, such as:</p>
<ul>
<li>Design</li>
<li>Development</li>
<li>Security</li>
<li>Publishing</li>
<li>Scalability</li>
<li>Monitoring</li>
<li>Analysis</li>
<li>Monetization</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Revisiting the Flix One case study</h1>
                
            
            
                
<p>In the preceding chapter, we looked at an example of an imaginary company, Flix One Inc., operating in the e-commerce domain and having its own .NET monolithic application: the Flix One bookstore. We have already discussed the following:</p>
<ul>
<li>How to segregate the code</li>
<li>How to segregate the database</li>
<li>How to denormalize the database</li>
<li>How to begin transitioning</li>
<li>The available refactoring approaches </li>
</ul>
<p>In the next sections, we will start writing/transitioning .NET monolith to a microservice application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Prerequisites</h1>
                
            
            
                
<p>We will use the following tools and technologies while transitioning our monolithic application to microservice-style architecture:</p>
<ul>
<li>Visual Studio 2017 update 3 or later</li>
<li>C# 7.0 </li>
<li>ASP.NET Core MVC/Web API</li>
<li>Entity Framework Core</li>
<li>SQL Server 2008R2 or later</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Transitioning to our product service</h1>
                
            
            
                
<p>We already have our product module in place. We are going to pull back this module now and start with a new ASP.NET Core MVC project. To do this, follow all the steps we discussed in the preceding sections and in <a href="6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml">Chapter 1</a>, <em>An Introduction to Microservices</em>, Let's examine the technology and database we will use:</p>
<ul>
<li>Technology stack: We have already selected this for our product service; we will go with ASP.NET Core, C#, <strong>Entity framework </strong>(<strong>EF</strong>), and so on. Microservices can be written using different technology stacks and can be consumed by clients created by different technologies. For our product service, we will go with ASP.NET Core.</li>
<li>Database: We have already discussed this in <a href="6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml">Chapter 1</a>, <em>An Introduction to Microservices</em>, when talking about a monolithic application and segregating its database. Here, we will go with SQL Server, and the database schema will be <kbd>Product</kbd> instead of <kbd>dbo</kbd>.</li>
</ul>
<p>Our product database is segregated. We will use this database in our product service, as shown in the following screenshot:</p>
<div><img class="image-border" height="511" src="img/2b8f6813-6396-4dec-989e-9aeeaeffd95b.png" width="561"/></div>
<p>We have created a separated product database for our product service. We did not migrate the entire data. In the following sections, we will discuss product database migration as well. Migration is important as we have numerous existing records of FlixOne bookstore customers. We can't ignore these records, and they need to be migrated to our modified structure. Let's get started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Migrations</h1>
                
            
            
                
<p>In the preceding section, we separated our product database to ensure that it would only be used by our product service. We also selected a technology stack of our choice to build our microservice (product service). In this section, we will discuss how we can migrate both our existing code and database to ensure that they fit right in with our new architectural style.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code migration</h1>
                
            
            
                
<p>Code migration does not involve just pulling out a few layers of code from the existing monolithic application and then bundling it with our newly created <strong>Product service</strong>. In order to achieve this, you'll need to implement all that you have learned up until now. In the existing monolithic application, we have a single repository, which is common to all modules, whereas, for microservices, we will create repositories for each module separately and keep them isolated from each other:</p>
<div><img class="image-border" height="276" src="img/5e671df5-24e4-49e7-8c3b-70ae5507352d.png" width="214"/></div>
<p class="CDPAlignLeft CDPAlign">In the preceding image, <strong>Product service</strong> has a <strong>Product repository</strong>, which further interacts with its designated data store, named <strong>Product database</strong>. We will now discuss microcomponents a bit more. They are nothing but isolated parts of the application (microservice), namely common classes and business functionalities. It is worthwhile to note here that the <strong>Product repository</strong> itself is a microcomponent in the world of microservices.</p>
<p>In our final product service, which is to be done in ASP.NET Core 2.0, we will work with a model and controller to create our REST API. Let's talk about both of these briefly:</p>
<ul>
<li>Model: This is an object that represents the data in the product service. In our case, the identified models are stacked into product and category fields. In our code, models are nothing but a set of simple C# classes. When we talk in terms of EF Core, they are commonly referred to as <strong>plain old CLR objects</strong> (<strong>POCOs</strong>). POCOs are nothing but simple entities without any data access functionality.</li>
<li>Controller: This is a simple C# class that inherits an abstract class controller of the <kbd>Microsoft.AspNetCore.Mvc </kbd>namespace. It handles HTTP requests and is responsible for the creation of the HTTP response to be sent back. In our <strong>Product</strong> service, we have a product controller that handles everything.</li>
</ul>
<p>Let's follow a step-by-step approach to create our product service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our project</h1>
                
            
            
                
<p>As already decided in the previous sections, we will create our <kbd>ProductService</kbd> in ASP.NET Core 2.0 or C# 7.0, using Visual Studio. Let's look at what steps are required to do this:</p>
<ol>
<li>Start Visual Studio.</li>
<li>Create a new project by navigating to File | New | Project.</li>
<li>From the template options available, select ASP.NET Core Web Application.</li>
<li>Enter the project name as <kbd>FlixOne.BookStore.ProductService</kbd>, and click on ok.</li>
</ol>
<p> </p>
<ol start="5">
<li>From the template screen, select Web Application (Model-View-Controller) and make sure you have selected .NET Core and ASP.NET Core 2.0 from the options, as shown in the following screenshot:</li>
</ol>
<div><img height="348" src="img/02d9049b-d80a-4141-8e6c-f6924ca39bac.png" width="532"/></div>
<p style="padding-left: 60px">6. Leave rest options as the default and click on ok.</p>
<p style="padding-left: 60px">The new solution should look like the following screenshot:</p>
<div><img height="165" src="img/ffc4e6f9-bc82-4013-a5a3-1d1ff156a5cd.png" width="183"/></div>
<ol start="7">
<li>From the solution explorer, right-click (or press <em>Alt</em> + <em>Enter</em>) on the project and click on Properties.</li>
<li>From the Properties window, click on Build and click on Advance. The Language version should be C#7.0, as shown in the following screenshot:</li>
</ol>
<div><img src="img/fa3860db-5a10-4058-9e42-ce6490740072.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the model</h1>
                
            
            
                
<p>In our monolithic application, we do not have any model classes yet. So let's go ahead and add a new model as required.</p>
<p>To add the new model, add a new folder and name it <kbd>Models</kbd>. In the Solution Explorer, right-click on the project and then click on options from Add | New Folder:</p>
<div><img src="img/062c2d4c-7372-4fbb-ad95-7d72e74618e2.png"/></div>
<p>There is no hard and fast rule for putting all the model classes in a folder named <kbd>Models</kbd>. As a matter of fact, we can put our model classes anywhere in the project in our application. We follow this practice as it becomes self-explanatory from folder names. At the same time, it easily identifies that this folder is for the model classes.<br/></p>
<p>To add new Product and Category classes (these classes will represent our POCOs), do as follows:  </p>
<ol>
<li>Right-click on the <kbd>Models</kbd> folder and chose Option.</li>
<li>Add New Item|Class. We will name them <kbd>Product</kbd> and <kbd>Category</kbd>.</li>
<li>Now add the properties that depict our product database column name to the tables <kbd>Product</kbd> and <kbd>Category</kbd>.</li>
</ol>
<p>There is no restriction regarding having the property name match the table column name. It is just general practice.</p>
<p>The following code snippet depicts what our <kbd>Product.cs</kbd> model class will look like:</p>
<pre> namespace FlixOne.BookStore.ProductService.Models<br/> {<br/>   public class Product<br/>   {<br/>     public Guid Id { get; set; }<br/>     public string Name { get; set; }<br/>     public string Description { get; set; }<br/>     public string Image { get; set; }<br/>     public decimal Price { get; set; }<br/>     public Guid CategoryId { get; set; }<br/>   }<br/> }</pre>
<p>The following code snippet shows what our <kbd>Category.cs</kbd> model class will look like:</p>
<pre> namespace FlixOne.BookStore.ProductService.Models<br/> {<br/>   public class Category<br/>   {<br/>     public Category()<br/>     {<br/>       Products = new List&lt;Product&gt;();<br/>     }<br/>     public Guid Id { get; set; }<br/>     public string Name { get; set; }<br/>     public string Description { get; set; }<br/>     public IEnumerable&lt;Product&gt; Products { get; set; }<br/>   }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a repository</h1>
                
            
            
                
<p>In our monolithic application, we have a common repository throughout the project. In <kbd>ProductService</kbd>, by virtue of following all the principals learned up until now, we will create microcomponents, which means separate repositories encapsulating the data layer.</p>
<p>A repository is nothing but a simple C# class that contains the logic to retrieve data from the database and maps it to the model.</p>
<p>Adding a repository is as simple as following these steps:</p>
<ol>
<li>Create a new folder and name it <kbd>Persistence</kbd>.</li>
<li>Add the <kbd>IProductRepository</kbd> interface and a <kbd>ProductRepository</kbd> class that will implement the <kbd>IProductRepository</kbd> interface.</li>
<li>Again, we name the folder <kbd>Persistence</kbd> in an effort to follow the general principal for easy identification.</li>
</ol>
<p>The following code snippet provides an overview of the <kbd>IProductRepository</kbd> interface:</p>
<pre>namespace FlixOne.BookStore.ProductService.Persistence<br/>{<br/>  public interface IProductRepository<br/>  {<br/>    void Add(Product product);<br/>    IEnumerable&lt;Product&gt; GetAll();<br/>    Product GetBy(Guid id);<br/>    void Remove(Guid id);<br/>    void Update(Product product);<br/>  }<br/>}</pre>
<p>The following code snippet provides an overview of the <kbd>ProductRepository</kbd> class (it is still without any implementation and it does not have any interaction with the database yet):</p>
<pre> namespace FlixOne.BookStore.ProductService.Persistence<br/> {<br/>   public class ProductRepository : IProductRepository<br/>   {<br/>     public void Add(Product Product)<br/>     {<br/>       throw new NotImplementedException();<br/>     }<br/>     public IEnumerable&lt;Product&gt; GetAll()<br/>     {<br/>       throw new NotImplementedException();<br/>     }<br/>     public Product GetBy(Guid id)<br/>     {<br/>       throw new NotImplementedException();<br/>     }<br/>     public bool Remove(Guid id)<br/>     {<br/>       throw new NotImplementedException();<br/>     }<br/>     public void Update(Product Product)<br/>     {<br/>       throw new NotImplementedException();<br/>     }<br/>   }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering the repositories</h1>
                
            
            
                
<p>For <kbd>ProductService</kbd>, we will use built-in dependency injection support with ASP.NET Core. To do so, follow these simple steps:</p>
<ol>
<li>Open <kbd>Startup.cs</kbd>. </li>
<li>Add the repository to the <kbd>ConfigureServices</kbd> method. It should look like this:</li>
</ol>
<pre style="padding-left: 60px">public void ConfigureServices(IServiceCollection services)<br/>{<br/>  // Add framework services.<br/>  services.AddMvc();<br/>  services.AddSingleton&lt;IProductRepository, <br/>  ProductRepository&gt;();<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a product controller</h1>
                
            
            
                
<p>Finally, we have reached the stage where we can proceed to add our controller class. This controller will actually be responsible for responding to the incoming HTTP requests with the applicable HTTP response. In case you are wondering what is to be done with that, you can see the <kbd>HomeController</kbd> class, as it is a default class provided by the ASP.NET core template.</p>
<p>Right-click on the <kbd>controllers</kbd> folder, chose the Add | New Item option, and select Web API Controller Class. Name it <kbd>ProductController</kbd>. Here we are going to utilize whatever code/functionality we can from the monolithic application. Go back to the legacy code and look at the operations you're performing there; they can be borrowed for our <kbd>ProductController</kbd> class. Refer to the following screenshot:</p>
<div><img src="img/13d111e8-9d32-4c0e-8c50-7305312f1990.png"/></div>
<p>After we have made the required modifications to <kbd>ProductController</kbd>, it should look something similar to this:</p>
<pre> using Microsoft.AspNetCore.Mvc;<br/> using FlixOne.BookStore.ProductService.Persistence;<br/> namespace FlixOne.BookStore.ProductService.Controllers<br/> {<br/>   [Route("api/[controller]")]<br/>   public class ProductController : Controller<br/>   {<br/>     private readonly IProductRepository _ProductRepository;<br/>     public ProductController(IProductRepositoryProductRepository)<br/>     {<br/>       _ProductRepository = ProductRepository;<br/>     }<br/>   }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The ProductService API</h1>
                
            
            
                
<p>In our monolithic application, for the <kbd>Product</kbd> module, we are doing the following:</p>
<ul>
<li>Adding a new <kbd>Product</kbd> module</li>
<li>Updating an existing <kbd>Product</kbd> module</li>
<li>Deleting an existing <kbd>Product</kbd> module</li>
<li>Retrieving a <kbd>Product</kbd> module</li>
</ul>
<p>Now we will create <kbd>ProductService</kbd>; we require the following APIs:</p>
<table style="width: 765px;height: 462px">
<tbody>
<tr>
<td><strong>API Resource</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>GET</kbd> /<kbd>api</kbd>/<kbd>Product</kbd></td>
<td>Gets a list of products</td>
</tr>
<tr>
<td><kbd>GET</kbd> /<kbd>api</kbd>/<kbd>Product{id}</kbd></td>
<td>Gets a product</td>
</tr>
<tr>
<td><kbd>PUT</kbd> /<kbd>api</kbd>/<kbd>Product{id}</kbd></td>
<td>Updates an existing product</td>
</tr>
<tr>
<td><kbd>DELETE</kbd> /<kbd>api</kbd>/<kbd>Product{id}</kbd></td>
<td>Deletes an existing product</td>
</tr>
<tr>
<td><kbd>POST</kbd> /<kbd>api</kbd>/<kbd>Product</kbd></td>
<td>Adds a new product</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding EF core support</h1>
                
            
            
                
<p>Before going further, we need to add EF so that our service can interact with the actual product database. Until now, we did not add any method to our repository that could interact with the database.</p>
<p>To add EF core support, we need to add EF's core <kbd>sqlserver</kbd> package (we are adding the <kbd>sqlserver</kbd> package because we are using SQL Server as our DB server). Open the NuGet Package Manager (Tools | NuGet Package Manager | Manage NuGet Package).</p>
<p>Open the NuGet Package and search for <kbd>Microsoft.EntityFrameworkCore.SqlServer</kbd>:</p>
<div><img src="img/b9de49b9-e010-4ae5-b66d-2035e6473095.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">EF Core DbContext</h1>
                
            
            
                
<p>In the preceding section, we added the EF Core 2.0 package for SQL Server support; now we need to create a context so our models can interact with our product database. We have the Product and Category models, refer to this list:</p>
<ol>
<li>Add a new folder and name it <kbd>Contexts</kbd>—it is not compulsory to add a new folder.</li>
<li>In the <kbd>context</kbd> folder, add a new C# class and name it <kbd>ProductContext</kbd>. We are creating <kbd>DbContext</kbd> for <kbd>ProductDatabase</kbd>, so to make it similar here, we are creating <kbd>ProductContext</kbd>.</li>
<li>Make sure the <kbd>ProductContext</kbd> class inherits the <kbd>DbContext</kbd> class.</li>
<li>Make the changes, and our <kbd>ProductContext</kbd> class will look like this:</li>
</ol>
<pre style="padding-left: 60px"> using FlixOne.BookStore.ProductService.Models;<br/> using Microsoft.EntityFrameworkCore;<br/> namespace FlixOne.BookStore.ProductService.Contexts<br/> {<br/>   public class ProductContext : DbContext<br/>   {<br/>     public ProductContext(DbContextOptions&lt;<br/>     ProductContext&gt;options): base(options)<br/>     { }<br/>     public ProductContext()<br/>     { }<br/>     public DbSet&lt;Product&gt; Products { get; set; }<br/>     public DbSet&lt;Category&gt; Categories { get; set; }<br/>   }<br/> }</pre>
<p style="padding-left: 60px">We have created our context, but this context is independent of the product database. We need to add a provider and connection string so that <kbd>ProductContext</kbd> can talk with our database.</p>
<ol start="5">
<li>Once again, open the <kbd>Startup.cs</kbd> file and add the <kbd>SQL Server db</kbd> provider for our EF Core support, under the <kbd>ConfigureServcies</kbd> method. Once you add the provider's <kbd>ConfigureServcies</kbd> method, our <kbd>Startup.cs</kbd> file will look like this:</li>
</ol>
<pre style="padding-left: 60px"> public void ConfigureServices(IServiceCollection services)<br/> {<br/>   // Add framework services.<br/>   services.AddMvc();<br/>   services.AddSingleton&lt;IProductRepository, ProductRepository&gt;();<br/>   services.AddDbContext&lt;ProductContext&gt;(o =&gt;o.UseSqlServer<br/>   (Configuration.GetConnectionString("ProductsConnection" )));<br/> }</pre>
<ol start="6">
<li>Open the <kbd>appsettings.json</kbd> file and add the required database connection string. In our provider, we have already set the connection key as <kbd>ProductsConnection.</kbd> So now, add the following line to set the connection string with the same key (change Data Source to your data source):</li>
</ol>
<pre style="padding-left: 60px"> {<br/>   "ConnectionStrings": <br/>   {<br/>     "ProductConnection":<br/>     "Data Source=.SQLEXPRESS;Initial Catalog=ProductsDB;<br/>     IntegratedSecurity=True;MultipleActiveResultSets=True"<br/>   }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">EF Core migrations</h1>
                
            
            
                
<p>Although we have already created our product database, it is not time to underestimate the power of EF Core migrations. EF Core migrations will be helpful for us to perform any future modifications to the database. This modification could be in the form of a simple field addition or any other update to the database structure. We can simply rely on these EF Core migration commands every time to do the necessary changes for us. In order to utilize this capability, follow these simple steps:</p>
<ol>
<li>Go to Tools | NuGet Package Manager | Package Manager Console.</li>
<li class="mce-root">Run the following commands from Package Manager Console:</li>
</ol>
<pre style="padding-left: 60px"><strong>Install--Package Microsoft.EntityFrameworkCore.Tools --pre</strong><br/><strong>Install--Package Microsoft.EntityFrameworkCore.Design</strong> </pre>
<ol start="3">
<li class="mce-root">To initiate the migration, run this command:</li>
</ol>
<pre style="padding-left: 60px"><strong> Add-Migration ProductDB</strong></pre>
<p style="padding-left: 60px">It is important to note that this is to be done only the first time (when we do not yet have a database created by this command).</p>
<ol start="4">
<li>Now, whenever there are any changes in your model, simply execute the following command: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>Update-Database</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Database migration</h1>
                
            
            
                
<p>At this point, we are done with our <kbd>ProductDatabase</kbd> creation. Now it's time to migrate our existing database. There are many different ways to do this. Our monolithic application, which presently has a huge database, contains a large number of records as well. It is not possible to migrate them by simply using a database SQL script.</p>
<p>We need to explicitly create a script to migrate the database with all of its data. Another option is to go ahead and create a DB package as required. Depending on the complexity of your data and the records, you might need to create more than one data package to ensure that the data is migrated correctly to our newly created database, <kbd>ProductDB</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Revisiting repositories and the controller</h1>
                
            
            
                
<p>We are now ready to facilitate interaction between our model and database via our newly created repositories. After making the appropriate changes to <kbd>ProductRepository</kbd>, it will look like this:</p>
<pre> using System.Collections.Generic;<br/> using System.Linq;<br/> using FlixOne.BookStore.ProductService.Contexts;<br/> using FlixOne.BookStore.ProductService.Models;<br/> namespace FlixOne.BookStore.ProductService.Persistence<br/> {<br/>   public class ProductRepository : IProductRepository<br/>   {<br/>     private readonly ProductContext _context;<br/>     public ProductRepository(ProductContext context)<br/>     {<br/>       _context = context;<br/>     }<br/>     public void Add(Product Product)<br/>     {<br/>       _context.Add(Product);<br/>       _context.SaveChanges();<br/>     }<br/>     public IEnumerable&lt;Product&gt; GetAll() =&gt;<br/>     _context.Products.Include(c =&gt; c.Category).ToList();<br/>     //Rest of the code has been deleted<br/>   }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing ViewModel</h1>
                
            
            
                
<p>Add a new class to the <kbd>models</kbd> folder and name it <kbd>ProductViewModel</kbd>. We do this because, in our monolithic application, whenever we search for a product, it should be displayed in its product category. In order to support this, we need to incorporate the necessary fields into our view model. Our <kbd>ProductViewModel</kbd> class will look like this:</p>
<pre> using System;<br/> namespace FlixOne.BookStore.ProductService.Models<br/> {<br/>   public class ProductViewModel<br/>   {<br/>     public Guid ProductId { get; set; }<br/>     public string ProductName { get; set; }<br/>     public string ProductDescription { get; set; }<br/>     public string ProductImage { get; set; }<br/>     public decimal ProductPrice { get; set; }<br/>     public Guid CategoryId { get; set; }<br/>     public string CategoryName { get; set; }<br/>     public string CategoryDescription { get; set; }<br/>   }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Revisiting the product controller</h1>
                
            
            
                
<p>Finally, we are ready to create a REST API for <kbd>ProductService</kbd>. After the changes are made, here is what <kbd>ProductController</kbd> will look like:</p>
<pre> using System.Linq;<br/> using FlixOne.BookStore.ProductService.Models;<br/> using FlixOne.BookStore.ProductService.Persistence;<br/> using Microsoft.AspNetCore.Mvc;<br/> namespace FlixOne.BookStore.ProductService.Controllers<br/> {<br/>   [Route("api/[controller]")]<br/>   public class ProductController : Controller<br/>   {<br/>     private readonly IProductRepository _productRepository;<br/>     public ProductController(IProductRepository <br/>     productRepository) =&gt; _productRepository = productRepository;<br/><br/>    [HttpGet]<br/>    [Route("productlist")]<br/>    public IActionResult GetList() =&gt; new<br/>    OkObjectResult(_productRepository.GetAll().<br/>    Select(ToProductvm).ToList());<br/><br/>    [HttpGet]<br/>    [Route("product/{productid}")]<br/>    public IActionResult Get(string productId)<br/>    {<br/>      var productModel = _productRepository.GetBy(new Guid(productId));<br/>      return new OkObjectResult(ToProductvm(productModel));<br/>    }<br/><br/>     //Rest of code has been removed<br/>   }<br/> }</pre>
<p>We have completed our all the tasks that are required for web API creation. Now, we need to tweaks few things so that client can get information about our web APIs. So, in the upcoming sections, we will add Swagger to our web API documentation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Swagger support</h1>
                
            
            
                
<p>We are using Swagger in our API documentation. We will not dive into the details of Swagger here (for more information, refer to <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger">https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger</a>).</p>
<p>Swagger is an open source and famous library that provides documentation for Web APIs. Refer to the official link, <a href="https://swagger.io/">https://swagger.io/</a>, for more information.</p>
<p>It is very easy to add documentation using Swagger. Follow these steps:</p>
<ol>
<li>Open NuGet Package Manager.</li>
<li>Search for the <kbd>Swashbuckle.AspNetCore</kbd> package.</li>
<li>Select the package and then install the package:</li>
</ol>
<div><img src="img/f71fad12-faa2-4147-833b-53ac1361df19.png"/></div>
<ol start="4">
<li>It will install the following:
<ul>
<li>Swashbuckle.AspNetCore</li>
<li>Swashbuckle.AspNetCore.Swagger</li>
<li>Swashbuckle.AspNetCore.SwaggerGen</li>
<li>Swashbuckle.AspNetCore.SwaggerUI</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">This is shown in the following screenshot:</p>
<div><img height="342" src="img/20ceaa41-dd98-46f8-ace6-39f8a46fc3c5.png" width="404"/></div>
<ol start="5">
<li>Open the <kbd>Startup.cs</kbd> file, move to the ConfigureServices method, and add the following lines to register the Swagger generator:</li>
</ol>
<pre style="padding-left: 60px">services.AddSwaggerGen(swagger =&gt;<br/>{<br/>  swagger.SwaggerDoc("v1", new Info <br/>  { Title = "Product APIs", Version = "v1" });<br/>});</pre>
<ol start="6">
<li>Next, in the Configure method, add the following code:</li>
</ol>
<pre style="padding-left: 60px">app.UseSwagger();<br/>app.UseSwaggerUI(c =&gt;<br/>{<br/>  c.SwaggerEndpoint("/swagger/v1/swagger.json", <br/>  "My API V1");<br/>});<br/><br/></pre>
<ol start="7">
<li>Press <em>F5</em> and run the application; you'll get a default page.</li>
<li>Open the Swagger documentation by adding swagger in the URL. So, the URL would be <kbd>http://localhost:43552/swagger/</kbd>:</li>
</ol>
<div><img height="297" src="img/64e5272f-fc8a-4a65-be37-8a765d25ae75.png" width="633"/></div>
<p>The preceding image shows the Product API resources, and you can try these APIs from within the Swagger documentation page.</p>
<p>Finally, we have completed the transition of our monolith .NET application to microservices and discussed the step-by-step transition of <kbd>ProductService</kbd>. There are more steps to come for this application:</p>
<ul>
<li>How microservices communicate: This will be discussed in <em>Chapter 3, Integration Techniques and Microservices</em></li>
<li>How to test a microservice: This will be discussed in <em><em>Chapter 4, Testing Microservices</em></em></li>
<li>Deploying microservices: This will be discussed in <em><a href="6843b0a1-0287-4d15-9e72-fdf228e52604.xhtml">Chapter 5</a>, Deploying Microservices</em></li>
<li>How can we make sure our microservices are secure, and monitoring our microservices: This will be discussed in <em>Chapter 6, Securing Microservices</em>, and <em>Chapter 7, Monitoring Microservices</em></li>
<li>How microservices are scaled: This will be discussed in <em>Chapter 8, Scaling Microservices</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discussed the different factors that can be used to identify and isolate microservices at a high level. We also discussed the various characteristics of a good service. When talking about DDD, we learned its importance in the context of microservices.</p>
<p>Furthermore, we analyzed how we can correctly achieve the vertical isolation of microservices through various parameters in detail. We tried to draw on our previous understanding of the challenges posed by a monolithic application and its solution in microservices, and we learned that we can use factors such as module interdependency, technology utilization, and team structure to identify seams and perform the transition from a monolithic architecture to microservices in an organized manner.</p>
<p>It became apparent that the database can pose a clear challenge in this process. However, we identified how we can still perform the process using a simple strategy and the possible approaches to do this. We then established that, with the foreign keys reduced/removed, the transactions can be handled in a completely different manner.</p>
<p>Moving on from a monolith to bounded contexts, we further applied our knowledge to transition the FlixOne application to a microservice architecture.</p>
<p class="mce-root"/>


            

            
        
    </body></html>