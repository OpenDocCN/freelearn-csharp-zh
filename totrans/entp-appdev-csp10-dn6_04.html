<html><head></head><body>
		<div id="_idContainer042">
			<p><a id="_idTextAnchor173"/><a id="_idTextAnchor174"/></p>
			<h1 id="_idParaDest-53"><em class="italic"><a id="_idTextAnchor175"/>Chapter 3</em>: Introducing C# 10</h1>
			<p>C# is an elegant and type-safe object-oriented programming language that allows developers to build a wide range of secure and robust applications that run in the .NET ecosystem and is in the top 5 of the popular programming languages list published by GitHub.</p>
			<p>C# was initially developed by Anders Hejlsberg at Microsoft as part of the .NET initiative. Since its first release in January 2002, there have been new features added consistently to the language to improve performance and productivity.</p>
			<p>C# 10 released with .NET 6 comes with some cool new language features along with enhancements to the features released in earlier versions, which improve developer productivity. In this chapter, we will explore some of the new C# language features:</p>
			<ul>
				<li>Simplification of the using directives</li>
				<li>The record structs</li>
				<li>Improvements to the Lambda expressions</li>
				<li>Enhancements to interpolated strings</li>
				<li>Extended property patterns</li>
				<li>Additions to the caller argument attributes</li>
			</ul>
			<p>By end of this chapter, you'll be familiar with the major new additions to C# 10. Also, this chapter will help us to upskill ourselves to build our next enterprise application in C#.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>Technical requirements</h1>
			<p>You will need the following to understand the concepts of this chapter:</p>
			<ul>
				<li>Visual Studio 2022 version 17.0 Community Edition with the .NET 6.0 runtime</li>
				<li>A basic understanding of Microsoft .NET</li>
			</ul>
			<p>The code used in this chapter can be found at <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor178"/><a id="_idTextAnchor179"/>Simplification of the using directives</h1>
			<p>A top-level statement is a new feature introduced in C# 9.0, which makes it easy for developers to <a id="_idIndexMarker163"/>remove the ceremony code. The project templates that come with Visual Studio 2022 embrace the language changes introduced in C# such as top-level statements. For example, if you create a <strong class="source-inline">Console</strong> application, you will see the <strong class="source-inline">Program.cs</strong> file contains the code shown in the following snippet:</p>
			<pre class="source-code">// See https://aka.ms/new-console-template for more //information</pre>
			<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
			<p>The preceding code came with a <strong class="source-inline">console</strong> application template that did not have the ceremony code such as class definition and the <strong class="source-inline">main</strong> method. This simplified the number of lines we could write by removing the redundant code.</p>
			<p>The concepts of the <strong class="source-inline">implicit</strong> using directives and <strong class="source-inline">global</strong> using directives introduced in C# 10 reduce the repetition of the <strong class="source-inline">using</strong> statements in each CS file. </p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor180"/>The global using directives</h2>
			<p>With the <strong class="source-inline">global</strong> <strong class="source-inline">using</strong> <a id="_idIndexMarker164"/>directives, we do not repeat the namespace <strong class="source-inline">using</strong> statements in all the <strong class="source-inline">.cs</strong> files. The <strong class="source-inline">global</strong> keyword is used to mark a <strong class="source-inline">global</strong> <strong class="source-inline">using</strong> directive as shown in the following code snippet:</p>
			<pre class="source-code">global using System.Threading;</pre>
			<p>In the preceding code, we marked <strong class="source-inline">System.Threading</strong> as <strong class="source-inline">global</strong>. Now, we can reference the types under <strong class="source-inline">System.Threading</strong> by having the <strong class="source-inline">using</strong> directive at the start of the <strong class="source-inline">.cs</strong> file.</p>
			<p>We can also create <strong class="source-inline">global</strong> aliases to the namespaces to resolve the namespace conflicts, as shown in the following code snippet:</p>
			<pre class="source-code">global using SRS = System.Runtime.Serialization;</pre>
			<p>By defining this, we can refer to all the classes defined under <strong class="source-inline">System.Runtime.Serialization</strong> using the alias name, <strong class="source-inline">SRS</strong>. We can also define a <strong class="source-inline">global using static</strong> directive as shown here:</p>
			<pre class="source-code">global using static System.Console;</pre>
			<p>With this, we can use all the <strong class="source-inline">static</strong> functions defined in the <strong class="source-inline">System.Console</strong> class directly <a id="_idIndexMarker165"/>without referring to the class name. For example, to write a line to the console, we can just call the <strong class="source-inline">WriteLine</strong> method without referring to the <strong class="source-inline">Console</strong> class name, as shown here:</p>
			<pre class="source-code">WriteLine("Hello C# 10");</pre>
			<p>We can specify <strong class="source-inline">global</strong> <strong class="source-inline">using</strong> directives in any <strong class="source-inline">.cs</strong> file of the project. The only constraint is they should appear before any regular file-scoped using directives. The common practice seen among the developers is to create a <strong class="source-inline">.cs</strong> with the name <strong class="source-inline">GlobalUsings.cs</strong> and add the <strong class="source-inline">global</strong> <strong class="source-inline">using</strong> directive in that file. This will help to restrict the change to a single file when we need to add or remove a <strong class="source-inline">global</strong> <strong class="source-inline">using</strong> directive. The scope of the <strong class="source-inline">global</strong> <strong class="source-inline">using</strong> directives is the complication unit that is the current project.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor181"/>The implicit using directives</h2>
			<p>In C#, we find a few framework namespaces, such as <strong class="source-inline">System</strong> and <strong class="source-inline">System.Linq</strong>, are present in <a id="_idIndexMarker166"/>almost all the classes. With C# 10, these commonly-used namespaces are implicitly added as <strong class="source-inline">global</strong> using directives. The namespaces added implicitly are based on the project target SDK and are documented here: https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives.</p>
			<p>In addition to these, if we wish to include any other namespace to be part of these implicit directives or remove any of the predefined namespaces, we can do so by adding <strong class="source-inline">ItemGroup</strong> to the <strong class="source-inline">.csproj</strong> file, as shown here:</p>
			<pre class="source-code">&lt;ItemGroup&gt;</pre>
			<pre class="source-code">  &lt;Using Include="System.Threading" /&gt;</pre>
			<pre class="source-code">  &lt;Using Remove="System.IO" /&gt;</pre>
			<pre class="source-code">&lt;/ItemGroup&gt;</pre>
			<p>In the previous snippet, we are including <strong class="source-inline">System.Threading</strong> and removing <strong class="source-inline">System.IO</strong> from the <strong class="source-inline">implicit</strong> <strong class="source-inline">using</strong> directives.</p>
			<p>To completely remove the <strong class="source-inline">implicit</strong> <strong class="source-inline">using</strong> directives, we can uncheck the <strong class="bold">Implicit global usings</strong> option from the project properties under the <strong class="bold">Build</strong> | <strong class="bold">General</strong> tab, or by disabling the <strong class="source-inline">ImplicitUsings</strong> flag in the <strong class="source-inline">.csproj</strong> file as shown here:</p>
			<pre class="source-code">&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;</pre>
			<p>The simplification <a id="_idIndexMarker167"/>of <strong class="source-inline">using</strong> directives is another step toward removing the redundant ceremony code and making the content in the <strong class="source-inline">.cs</strong> files concise.</p>
			<p>In the next section, we will explore the <strong class="source-inline">record</strong> structs introduced with C# 10.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor182"/>The record structs</h1>
			<p>The <em class="italic">record types</em> introduced in C# 9 provide type declaration to create immutable reference types <a id="_idIndexMarker168"/>with synthesized methods for equality check and <strong class="source-inline">ToString</strong>. C# 10 brings us the <em class="italic">record structs</em>. In this section, we will see what <strong class="source-inline">record struct</strong> is and how it is different from <strong class="source-inline">record class</strong>. </p>
			<p>We use the <strong class="source-inline">record</strong> keyword to declare <strong class="source-inline">record class</strong>, and we use the same <strong class="source-inline">record</strong> keyword to declare <strong class="source-inline">record struct</strong>, as shown in the following code: </p>
			<pre class="source-code">public <strong class="bold">record</strong> struct Employee(string Name);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">In C# 9, to declare a <strong class="source-inline">record</strong> class, we don't explicitly use the <strong class="source-inline">class</strong> keyword. We simply specify <strong class="source-inline">record</strong> to declare it as shown here: <strong class="source-inline">public</strong> record <strong class="source-inline">Shape(string Name);</strong></p>
			<p class="callout">Simply using the <strong class="source-inline">record</strong> keyword will continue to work in C# 10 to declare a <strong class="source-inline">record</strong> class, but it is recommended to specify <strong class="source-inline">class</strong> or <strong class="source-inline">struct</strong> explicitly for better readability.</p>
			<p><strong class="source-inline">record struct</strong> offers similar benefits to what <strong class="source-inline">record class</strong> offers, such as the following:</p>
			<ul>
				<li>Simplified declaration syntax</li>
				<li>Value equality</li>
				<li>Reference semantics</li>
				<li>Deconstruction</li>
				<li>Meaningful <strong class="source-inline">ToString</strong> output </li>
			</ul>
			<p>Let's understand <a id="_idIndexMarker169"/>these by creating a sample <strong class="source-inline">Console</strong> application and defining an <strong class="source-inline">EmployeeRecord</strong> record struct. Add the following code to the <strong class="source-inline">Program.cs</strong> file, which is using the <strong class="source-inline">EmployeeRecord</strong> record struct defined in the previous code snippet:</p>
			<pre class="source-code">using static System.Console;</pre>
			<pre class="source-code"> public <strong class="bold">record</strong> struct EmployeeRecord(string Name);</pre>
			<pre class="source-code">Employee employee1 = new EmployeeRecord("Suneel", "Kunani");</pre>
			<pre class="source-code">Employee employee2 = new EmployeeRecord("Suneel", "Kunani");</pre>
			<pre class="source-code">WriteLine(employee1.ToString());</pre>
			<pre class="source-code">WriteLine($"HashCode of s1 is :{ employee1.GetHashCode()}");</pre>
			<pre class="source-code">WriteLine($"HashCode of s2 is :{ employee2.GetHashCode()}");</pre>
			<pre class="source-code">WriteLine($"Is s1 equals s2 : { employee1 == employee2}");</pre>
			<pre class="source-code">//deconstruct the fields from the employee object</pre>
			<pre class="source-code">string firstName;</pre>
			<pre class="source-code"> (firstname, var lastname) = employee1;</pre>
			<pre class="source-code">Console.WriteLine($"firstname: {firstname}, lastname:{lastname}");</pre>
			<p>In the preceding code, we are creating two instances of the <strong class="source-inline">EmployeeRecord</strong> record struct with name field values using the simplified declaration syntax, then printing the hash code of the instance objects, and then checking the equality. Here, we are also deconstructing the fields from the <strong class="source-inline">employee</strong> object.</p>
			<p>When we run the code, we see the output as shown in the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_3.1_B18507.jpg" alt="Figure 3.1 – Output of record struct example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Output of record struct example</p>
			<p>When we look at the output, we observe that <strong class="source-inline">ToString</strong> is overridden to include the contents of <a id="_idIndexMarker170"/>the instance. As expected, the hash code of both instances is the same, as the field values are the same. In a regular struct, the hash code of the object is generated based on the first non-nullable field. In the <strong class="source-inline">record</strong> struct, the <strong class="source-inline">GetHashCode</strong> method is also overridden to include all the fields to generate the hash code. </p>
			<p>The <strong class="source-inline">record</strong> struct synthesizes the implementation of the <strong class="source-inline">IEquatable&lt;T&gt;</strong> interface. It also implements the <strong class="source-inline">==</strong> and <strong class="source-inline">!=</strong> operators. The regular struct does not have these operators implemented by default. The regular struct has the <strong class="source-inline">Equals</strong> method inherited from <strong class="source-inline">ValueType</strong>, which uses reflection to do the equality check. So, the synthesized equality check in the <strong class="source-inline">record</strong> struct is more performant. The <strong class="source-inline">record</strong> struct also synthesizes the <strong class="source-inline">Deconstruct</strong> method to populate the fields out of the object. If you take a closer look at the deconstruction code, you will notice the mixed declaration of the variables. We have <strong class="source-inline">lastName</strong> being declared during deconstruction, whereas <strong class="source-inline">firstName</strong> was declared in the preceding statement. This mixed declaration of variables is only possible in C#10 and above.</p>
			<p>When we disassemble the code in a disassembler tool such as ILSpy or Reflector, we see the generated code as shown in the following figure:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_3.2_B18507.jpg" alt="Figure 3.2 – Generated code of the Employee class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Generated code of the Employee class</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can <a id="_idIndexMarker171"/>install ILSpy from <a href="https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy">https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy</a>.</p>
			<p>If we look <a id="_idIndexMarker172"/>closely at the <strong class="source-inline">Employee</strong> type definition, we can see all the plumbing synthesized by the C# compiler for the <strong class="source-inline">record struct</strong> type. From this, we can understand that the <strong class="source-inline">record</strong> struct is basically a struct that implements the <strong class="source-inline">IEquatable</strong> interface and overrides the <strong class="source-inline">GetHashCode</strong> and <strong class="source-inline">ToString</strong> methods. You can overwrite the <strong class="source-inline">ToString</strong> method to create your own string representation for the record type. Beginning with C# 10, you can also mark the <strong class="source-inline">ToString</strong> override as sealed, which prevents the compiler from synthesizing a <strong class="source-inline">ToString</strong> method or derived types from overriding it. Sealing the <strong class="source-inline">ToString</strong> method in the base record type ensures that the string representation is consistent across all derived types. The compiler also provides the <strong class="source-inline">Deconstruct</strong> method, which is used to deconstruct the <strong class="source-inline">record</strong> struct into its component properties. Unlike <strong class="source-inline">record</strong> classes, the <strong class="source-inline">record</strong> structs are mutable. To make a <strong class="source-inline">record</strong> struct immutable, we can add a <strong class="source-inline">readonly</strong> modifier to the declaration:</p>
			<pre class="source-code">public readonly <strong class="bold">record</strong> struct Employee(string Name);</pre>
			<p>To change <a id="_idIndexMarker173"/>the fields of the <strong class="source-inline">readonly record</strong> struct, we can use the operator as shown here like with the <strong class="source-inline">record</strong> class:</p>
			<pre class="source-code">Employee employee2 = employee1 with { LastName = string.Empty };</pre>
			<p>In this section, we have learned about the <strong class="source-inline">record</strong> struct introduced in C# 10 and how it compares with the <strong class="source-inline">record</strong> class and regular struct. In the next section, let's learn about improvements to Lambda expressions.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor183"/>Improvements to Lambda expressions</h1>
			<p>A Lambda expression is a way to represent an anonymous method. It allows us to define the method implementation inline.</p>
			<p>A delegate <a id="_idIndexMarker174"/>type may be created from any Lambda expression. The types of a Lambda expression's parameters and return value determine the delegate type to which it can be transformed. A Lambda expression can be changed to an <strong class="source-inline">Action</strong> delegate type if it doesn't return a value; otherwise, it can be converted to one of the <strong class="source-inline">Func</strong> delegate types. In this section, we will learn about the improvements C# 10 brings to Lambda expressions. </p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor184"/>Inferring the expression type </h2>
			<p>C# language <a id="_idIndexMarker175"/>compiler will now infer the expression type if the parameter's types are explicit and the return type can be inferred. For example, consider the following code snippet where we defined a Lambda expression to find the square of the given integer:</p>
			<pre class="source-code">Var Square = (int x) =&gt; x * x;</pre>
			<p>In the preceding code, the parameter <strong class="source-inline">x</strong> type is specified as <strong class="source-inline">int</strong> and the return type is inferred as <strong class="source-inline">int</strong> from the expression. If we mouse-hover on <strong class="source-inline">var</strong> in Visual Studio, we can see the inferred type of the <strong class="source-inline">Square</strong> Lambda expression, as shown in the next screenshot, which uses the <strong class="source-inline">Func</strong> delegate:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_3.3_B18507.jpg" alt="Figure 3.3 – Inferred type of Square expression&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Inferred type of Square expression</p>
			<p>For the code <a id="_idIndexMarker176"/>shown here, the compiler will use the <strong class="source-inline">Action</strong> delegate, as the expression return type is <strong class="source-inline">void</strong>:</p>
			<pre class="source-code">var SayHello = (string name) =&gt; Console.WriteLine($"Hello {name}");</pre>
			<p>The inferred type will use <strong class="source-inline">Func</strong> or <strong class="source-inline">Action</strong> delegates if it is suitable. Otherwise, the compiler will synthesize a delegate type, for example, if the Lambda expression is taking a <strong class="source-inline">ref</strong> type, as shown in the following code snippet:</p>
			<pre class="source-code">Var SayWelcome = (ref string name) =&gt; Console.WriteLine($"Welcome {name}");</pre>
			<p>The synthesized type for the previous expression will be an <strong class="source-inline">anonymous</strong> delegate type.</p>
			<p>The compiler will try to infer the return type based on the expression. Sometimes, it may not be possible to infer the type. We will get a compilation error if it is unable to infer the type information. </p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor185"/>Return types for Lambda expressions</h2>
			<p>In situations <a id="_idIndexMarker177"/>where it is not possible for the compiler to infer the return type, we can specify explicitly in C# 10. Consider the following code snippet, where we have <strong class="source-inline">record</strong> classes of <strong class="source-inline">Employee</strong> and <strong class="source-inline">Manager</strong> inherited from a <strong class="source-inline">Person</strong> record class: </p>
			<pre class="source-code">public record class Person();</pre>
			<pre class="source-code">public record class Employee() : Person();</pre>
			<pre class="source-code">public record class Manager() : Person();</pre>
			<pre class="source-code">var createExpression = (bool condition) =&gt; condition ? new Employee() : new Manager();</pre>
			<p>The <strong class="source-inline">createExpression</strong> term in the preceding code snippet creates an instance of an <strong class="source-inline">Employee</strong> or <strong class="source-inline">Manager</strong> type based on the condition passed in. In this situation, the compiler cannot infer the return type, which will result in a compilation error. With C#10, we can <a id="_idIndexMarker178"/>now explicitly specify the return type for a Lambda expression as shown in the following code:</p>
			<pre class="source-code">var createEmployee = Person (bool hasReportees) =&gt; condition ? new Manager() : new Employee();</pre>
			<pre class="source-code">// Create the Person object based on condition</pre>
			<pre class="source-code">var manager = createEmployee(true);</pre>
			<p>The expression type inferred for the preceding code is <strong class="source-inline">Func&lt;bool, Person&gt;</strong>. </p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor186"/>Adding attributes to Lambda expressions</h2>
			<p>Starting from C# 10, we can add attributes to the Lambda expressions and their parameters <a id="_idIndexMarker179"/>and return types. The following code snippet defines a Lambda expression to retrieve employees for the given ID: </p>
			<pre class="source-code">var GetEmployeeById =  [Authorize] Employee ([FromRoute]int id) =&gt; { return new Employee { }; };</pre>
			<p>The <strong class="source-inline">GetEmployeeeById</strong> expression has the <strong class="source-inline">[Authorize]</strong> attribute and the <strong class="source-inline">id</strong> parameter is attributed with <strong class="source-inline">[FromRoute]</strong>. </p>
			<p>Attributes on Lambda expressions don't have any effect when they are invoked, as the invocation is via the underlying delegate type. The attributes defined on Lambda expressions can be discovered via reflection. </p>
			<p>The minimal API introduced with ASP.NET 6.0 is one of the driving factors behind these improvements. We will <a id="_idIndexMarker180"/>see the usage of this in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>. </p>
			<p>In this section, we have learned about the improvements to the Lambda expressions; in the next section, we will see improvements to interpolated strings.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor187"/>Enhancements to interpolated strings</h1>
			<p>Almost every application will have some sort of text processing. In .NET, there are many ways available <a id="_idIndexMarker181"/>for string manipulation, such as the <strong class="source-inline">string</strong> primitive type, <strong class="source-inline">StringBuilder</strong>, <strong class="source-inline">ToString</strong> overrides on types, String concatenation, and <strong class="source-inline">string.Format</strong>, which provides functionality to build a string from a composite format string. <strong class="source-inline">String.Format</strong> takes a format string and format items as input and generates the formatted string as depicted in the following code:</p>
			<pre class="source-code">string message = string.Format("{0}, {1}!", Greeting, Message);</pre>
			<p>In the previous code, the positions <strong class="source-inline">{0}</strong> and <strong class="source-inline">{1}</strong> in the format string will be filled with the <strong class="source-inline">Greeting</strong> and <strong class="source-inline">Message</strong> format items respectively passed in as arguments. To make it more friendly and readable, C# 6 added a new language syntax called <strong class="bold">interpolated strings</strong>, as shown in the following code snippet: </p>
			<pre class="source-code">string Greeting = "Hello";</pre>
			<pre class="source-code">string Language = "C#";</pre>
			<pre class="source-code">int version = 10;</pre>
			<pre class="source-code">string message = $"{Greeting}, {Language}!";</pre>
			<pre class="source-code">string messageWithVersion = $"{Greeting}, {Language} {version}!";</pre>
			<p>When interpolated strings syntax is used, the .NET compiler generates the code that is best suited for the interpolated string to produce the same result. </p>
			<p>Use a disassembler such as ILSpy or SharpLab to look at the generated code for the previous code snippet; it will look something like the following code snippet:</p>
			<pre class="source-code">String text = "Hello";</pre>
			<pre class="source-code">string text2 = "C#";</pre>
			<pre class="source-code">int num = 10;</pre>
			<pre class="source-code">string text3 = text + ", " + text2 + "!";</pre>
			<pre class="source-code">string text4 = string.Format("{0}, {1} {2}!", text, text2, num);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout"><a href="https://sharplab.io/">https://sharplab.io/</a> is a .NET code playground that shows the intermediate results of code compilation.</p>
			<p>For the <strong class="source-inline">message</strong> interpolated <a id="_idIndexMarker182"/>string, the code was generated using concatenation. For the second string, <strong class="source-inline">messageWithVersion</strong>, where a non-string literal is involved, the generated code uses <strong class="source-inline">string.Format</strong>. </p>
			<p>The compiler did what was intended, but it had a few issues where the code was generated using <strong class="source-inline">string.Format</strong>:</p>
			<ul>
				<li>The compiler parsed the interpolated string to generate code with <strong class="source-inline">string.Format</strong>. The same string must be parsed by the .NET runtime also to find the literal positions. </li>
				<li>The argument type of the literals in the <strong class="source-inline">string.Format</strong> method is <strong class="source-inline">Object</strong>. So, any value type used in <strong class="source-inline">string.Format</strong> involves boxing.</li>
				<li>The overload of <strong class="source-inline">string.Format</strong> takes a maximum of three arguments. Beyond three is served by the overload that takes <strong class="source-inline">params object[]</strong>. So, more than three arguments require the instantiation of an array.</li>
				<li>Since <strong class="source-inline">string.Format</strong> accepts only the <strong class="source-inline">Object</strong> type, we cannot use <strong class="source-inline">ref struct</strong> types such as <strong class="source-inline">Span&lt;T&gt;</strong> and <strong class="source-inline">ReadOnlySpan&lt;char&gt;</strong>.</li>
				<li>Since <strong class="source-inline">ToString</strong> is called on the captured expression, multiple transient strings will be created.</li>
			</ul>
			<p>All the shortcomings mentioned here will be addressed with C# 10 by generating code with a series of appends to the string builder. For the same code that we discussed, if you look at the generated code in C# 10, it uses <strong class="source-inline">DefaultInterpolatedStringHandler</strong> as shown in the following code snippet:</p>
			<pre class="source-code">string Greeting = "Hello";</pre>
			<pre class="source-code">string Language = "C#";</pre>
			<pre class="source-code">int version = 10;</pre>
			<pre class="source-code">string message = Greeting + ", " +<a id="_idTextAnchor188"/> Language + "!";</pre>
			<pre class="source-code">DefaultInterpolatedStringHandler defaultInterpolatedStringHandler = new DefaultInterpolatedStringHandler(4, 3);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendFormatted(Greeting);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendLiteral(", ");</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendFormatted(Language);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendLiteral(" ");</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendFormatted(version);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendLiteral("!");</pre>
			<pre class="source-code">string messageWithVersion = defaultInterpolatedStringHandler.ToStringAndClear();</pre>
			<p>For interpolated <a id="_idIndexMarker183"/>strings, instead of using <strong class="source-inline">string.Format</strong>, C# 10 compiler now uses <strong class="bold">interpolated string handlers</strong>. The built-in interpolated string handler in C# 10 is <strong class="source-inline">DefaultInterpolatedStringHandler</strong>. In the previously-generated code, <strong class="source-inline">DefaultInterpolatedStringHandler</strong> is constructed by passing in the two arguments, the number of characters in the literal portion of the interpolated string, and the number of <a id="_idIndexMarker184"/>positions in the string to be filled. <strong class="source-inline">AppendLiteral</strong> or <strong class="source-inline">AppendFormatted</strong> are called to append the literal or to append the formatted string, respectively. With the introduction of interpolated string handlers, the concerns discussed previously were addressed.</p>
			<p>For the same interpolated string code written in earlier versions of C#, there will be an improvement in the performance in C# 10. We can also build our custom interpolated string handlers, which may be useful in situations when the data isn't going to be used as a string, or where conditional execution would be a logical fit for the target method.</p>
			<p>In this section, we have learned about the improvements to the interpolated string, which gives us better performance over earlier versions. In the next section, let's learn about the extended property patterns.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor189"/>Extended property patterns </h1>
			<p>Pattern matching is a way to check an object's value or the value of a property having a full or partial <a id="_idIndexMarker185"/>match to a sequence. This is supported in C# in the form of <strong class="source-inline">if…else</strong> and <strong class="source-inline">switch…case</strong> statements. In modern languages, especially in functional programming languages such as F#, there is advanced support for pattern matching. With C# 7.0, new pattern matching concepts were introduced. Pattern matching provides a different way to express conditions to have more human-readable code. Pattern matching is being extended with every major release of C# since its introduction in C# 7.</p>
			<p>In this section, let's learn about the extended property pattern introduced in C# 10.</p>
			<p>Consider the following code snippet:</p>
			<pre class="source-code">Product product = new Product</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    Name ="Men's Shirt",</pre>
			<pre class="source-code">    Price =10.0m,</pre>
			<pre class="source-code">    Location = new Address</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        Country ="USA",</pre>
			<pre class="source-code">        State ="NY"</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">};</pre>
			<p>In this code snippet, we have an object of the <strong class="source-inline">Product</strong> type, which contains the location of the product origin. Prior to C# 10, if we wanted to check whether the country of origin of this product was the USA, we would do something similar to the following code snippet:</p>
			<pre class="source-code">if (product is Product { Location: { Country: "USA" } })</pre>
			<pre class="source-code">    Console.WriteLine("USA"); </pre>
			<p>With C# 10, we can access the extended properties to make it more readable, as shown in the following code snippet:</p>
			<pre class="source-code">if (product is Product { Location.Country : "USA"  })</pre>
			<pre class="source-code">    Console.WriteLine("USA");</pre>
			<p>In the <a id="_idIndexMarker186"/>preceding code, we are validating the <strong class="source-inline">Country</strong> property of <strong class="source-inline">Location</strong> using an extended property pattern.</p>
			<p>In this section, we have learned about extended property patterns. Let's learn about the new addition to <strong class="source-inline">caller</strong> argument attributes in the next section.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor190"/>Addition to the caller argument attributes</h1>
			<p>C# 5 first introduced <strong class="source-inline">caller</strong> argument attributes. They are <strong class="source-inline">CallerMemberName</strong>, <strong class="source-inline">CallerFilePath</strong>, and <strong class="source-inline">CallerLineNumber</strong>. These attributes make the compiler populate the <a id="_idIndexMarker187"/>method arguments in the generated code. They are used in various scenarios such as populating more data in the debug traces while firing an <strong class="source-inline">OnNotifyPropertyChanged</strong> event in the MVVM pattern. For example, consider the following code snippet, which defines a <strong class="source-inline">Gift</strong> model:</p>
			<pre class="source-code">public class Gift : INotifyPropertyChanged</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    private string _description;</pre>
			<pre class="source-code">    public string Description</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        get</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            return _description;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        set</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            _description = value;</pre>
			<pre class="source-code">            OnPropertyRaised();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public event PropertyChangedEventHandler </pre>
			<pre class="source-code">      PropertyChanged;</pre>
			<pre class="source-code">    private void OnPropertyRaised([CallerMemberName] string </pre>
			<pre class="source-code">      propertyname="")</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        if (PropertyChanged != null)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            PropertyChanged(this, new </pre>
			<pre class="source-code">              PropertyChangedEventArgs(propertyname));</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} </pre>
			<p>In the preceding <strong class="source-inline">Gift</strong> class definition, the <strong class="source-inline">OnPropertyChanged</strong> method is called every time <a id="_idIndexMarker188"/>the setter of the <strong class="source-inline">Description</strong> prop<a id="_idTextAnchor191"/>erty is called. In the <strong class="source-inline">OnProperyChanged</strong> method implementation, we have the <strong class="source-inline">propertyName</strong> argument attributed with <strong class="source-inline">CallerMemberName</strong>. This will make the compiler generate a setter as shown in the following code:</p>
			<pre class="source-code">public string Description</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    get { return _description;     }</pre>
			<pre class="source-code">    set</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        _description = value;</pre>
			<pre class="source-code">        OnPropertyRaised("Description");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this generated code, the argument to <strong class="source-inline">OnProperyChanged</strong> is auto-populated with the property name, <strong class="source-inline">Description</strong>, by the compiler. This is a handy feature for the developer that helps to write error-free code. The other two <strong class="source-inline">caller</strong> argument attributes, <strong class="source-inline">CallerFilePath</strong> and <strong class="source-inline">CallerLineNumber</strong>, populate the file path of the <strong class="source-inline">caller</strong> method and line number respectively.</p>
			<p><strong class="source-inline">CallerArgumentExpression</strong> is a new addition to these in C# 10. As the name suggests, the attribute makes the compiler auto-populate the argument expression. Let's build <a id="_idIndexMarker189"/>a simple argument validation helper class that does the <strong class="source-inline">null</strong> check for the parameters passed. Consider the following implementation of an <strong class="source-inline">ArgumentValidation</strong> class, which implements a helper method that throws <strong class="source-inline">ArgumentException</strong> if the argument value is <strong class="source-inline">null</strong>:</p>
			<pre class="source-code">public static class ArgumentValidation</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public static void ThrowIfNull&lt;T&gt;(T value,</pre>
			<pre class="source-code">    [CallerArgumentExpression("value")] string expression = </pre>
			<pre class="source-code">      null) where T : class</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        if (value == null)</pre>
			<pre class="source-code">            Throw(expression);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private static void Throw(string expression)</pre>
			<pre class="source-code">        =&gt; throw new ArgumentException($"Argument </pre>
			<pre class="source-code">           {expression} must not be null");</pre>
			<pre class="source-code">} </pre>
			<p>In the <strong class="source-inline">ThrowIfNull</strong> method, we are performing the <strong class="source-inline">null</strong> check and throwing <strong class="source-inline">ArgumentException</strong> with the details including the parameter name, which is picked from <strong class="source-inline">CallerArgumentExpression</strong>. We can use the preceding helper class to perform the <strong class="source-inline">null</strong> check on the arguments passed to a method. For example, consider the following <a id="_idIndexMarker190"/>method, which adds the passed-in product to the cart:</p>
			<pre class="source-code"><strong class="source-inline">public async Task&lt;ProductDetailsViewModel&gt; AddProductAsync (ProductDetailsViewModel product)</strong></pre>
			<pre class="source-code"><strong class="source-inline">{</strong></pre>
			<pre class="source-code"><strong class="source-inline">    ArgumentValidation.ThrowIfNull(product);</strong></pre>
			<pre class="source-code"><strong class="source-inline">    // Implementation to add the product to cart</strong></pre>
			<pre class="source-code"><strong class="source-inline">}</strong></pre>
			<p>In this method, we use the <strong class="source-inline">ArgumentValidation</strong> helper class to check the <strong class="source-inline">null</strong> condition of the <strong class="source-inline">product</strong> argument. The generated code for the call to the <strong class="source-inline">ThrowIfNull</strong> helper method will be <strong class="source-inline">ArgumentValidation.ThrowIfNull(product, "product");</strong>.</p>
			<p>The compiler auto-populated the parameter name in the string argument. Caller arguments will be useful where we want to add more details to the traces, which will help in tr<a id="_idTextAnchor192"/><a id="_idTextAnchor193"/><a id="_idTextAnchor194"/><a id="_idTextAnchor195"/><a id="_idTextAnchor196"/><a id="_idTextAnchor197"/><a id="_idTextAnchor198"/><a id="_idTextAnchor199"/>oubleshooting the issue.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor200"/>Summary</h1>
			<p>In this chapter, we have learned about the major additions to the C# language features in version 10. We have seen how C# 10 simplifies the code written with <strong class="source-inline">implicit</strong> and <strong class="source-inline">global</strong> using directives. We have learned about <strong class="source-inline">record</strong> structs and how they compare with the <strong class="source-inline">record</strong> class introduced in C# 9. We have also learned about the improvements to Lambda expressions, expression type inference, and explicitly specifying the return type for the expression. We have also seen performance improvements in interpolated strings. We have also learned how to build throw helpers using the <strong class="source-inline">CallerArgumentExpression</strong> attribute.</p>
			<p>With this chapter, we have gained the skills to leverage these new features of C# 10 features in the enterprise e-commerce application that we are going to build in the coming chapters. In addition to these, there are a few more small enhancements. You can refer to the C# language documentation to learn more here: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10</a>. We will be highlighting the new features of C# 10 and .NET 6 throughout this book while implementing different features of our e-commerce application.</p>
			<p>In the upcoming part, we will learn about the cross-cutting concerns that form the building blocks of our<a id="_idTextAnchor201"/><a id="_idTextAnchor202"/> e-commerce application.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor203"/>Questions</h1>
			<p>After reading the chapter, you should be able to answer the following questions:</p>
			<ol>
				<li>True or false? Record structs are mutable:</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="2">Which keyword should you use to make a record struct immutable?</li>
			</ol>
			<p>a. A record struct is immutable by default.</p>
			<p>b. <strong class="source-inline">readonly</strong>.</p>
			<p>c. <strong class="source-inline">finally</strong>.</p>
			<p>d. <strong class="source-inline">sealed</strong>.</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="3">True or false? A compiler will infer the type expressions in all the scenarios:</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="4">In which version of C# were caller argument attributes first introduced?</li>
			</ol>
			<p>a. C# 9</p>
			<p>b. C# 8</p>
			<p>c. C# 5</p>
			<p>d. C# 7</p>
			<p><strong class="bold">Answer: c</strong></p>
		</div>
	</body></html>