<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>11. What is Reactive Programming?</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="8afe24fba552.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;11.&#160;What is Reactive Programming?">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11"></a>Chapter&#160;11.&#160;What is Reactive Programming?</h1>
            </div>
          </div>
        </div>
        <p>By now we have seen how parallel and functional programming constructs in the .NET world help one naturally compose algorithms/business logic and model programs/data flows. These paradigms help realize a software system that has close correlation with the real world in which they exist. We have seen relevance of data structures and their role in program composition. We also saw the benefits (in terms of concurrency and parallelism) of keeping the data structures (modeled in an object-oriented way) different from the algorithms (modelled as pure function compositions) that consume them. To take this one knot further, in order to keep up with growing system complexity, there's a growing software revolution called <span class="strong"><strong>reactive programming</strong></span>, which defines how to model applications from a behavior stand-point. In this chapter, we will try to unravel the concept through some examples, and understand how this programming paradigm becomes a natural succession, but more importantly, a unifying model for creating responsive systems. We will look at the various reactive programming constructs (including key data structures, interfaces, and operators) available in .NET <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>). By the end of the chapter, you will understand how natural it is to model responsiveness, which becomes quite relevant in this new world of multicore, cloud, mobile, and web-scale systems.
</p>
        <div class="section" title="Being reactive">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch11lvl1sec79"></a>Being reactive</h1>
              </div>
            </div>
          </div>
          <p>To start with, let's look at the classic definition of reactive programming, and try to understand the concept brought forth by this model. This is important to undo any misconceptions that govern one's mind on this topic.</p>
          <div class="blockquote">
            <table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote">
              <tbody><tr>
                <td valign="top">&#160;</td>
                <td valign="top">
                  <p>
<span class="emphasis"><em>In computing, reactive programming is a programming paradigm that maintains a continuous interaction with their environment, but at a speed which is determined by the environment, not the program itself.</em></span>
</p>
                </td>
                <td valign="top">&#160;</td>
              </tr>
              <tr>
                <td valign="top">&#160;</td>
                <td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>GÃ¨rard Berry</em></span></span></td>
              </tr>
            </tbody>
</table>
          </div>
          <p>This implies that this programming model helps, or rather, has an inherent capability to propagate changes without the programmer having to explicitly wire any such logic (the conventional way, which was error prone and rendered programs inconsistent; a nightmare that still haunts some of us). This would mean that the programming model would be declarative and provide the needed constructs (including data structures and interfaces) to capture the relationship between attributes in order to ensure seamless propagation or synchronization of changes through data flows.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note52"></a>Note</h3>
              <p>The design pattern that really powers this model is observer, where the relationships between subscribers and publishers are declaratively modeled.</p>
            </div>
          </div>
          <p>Let's try to understand this further via this example. In typical assignment statements (in the imperative world), relations are implicitly declared (say <span class="emphasis"><em>c<sup>2</sup> = a<sup>2</sup> + b<sup>2</sup></em></span> , the Pythagorean equation that symbolizes the Pythagorean theorem), or functions (in the functional programming world) are defined explicitly, say <span class="emphasis"><em>c = Compute Hypotenuse(a, b)</em></span>. On the other hand, in the reactive world, computation (value of <span class="emphasis"><em>c</em></span>) is automatically done with new values of the sides (<span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span>). The computation is automatically triggered every time the value changes for <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span> in the relation <span class="emphasis"><em>c<sup>2</sup> = a<sup>2</sup> + b<sup>2</sup></em></span>. This behavior is termed as <span class="strong"><strong>reactive</strong></span>. You could say that this is similar to event-driven programming, but there is a very distinct difference here that you need to understand.</p>
          <p>This behavior is extremely important to model concurrent real-world systems including real-time analytics, control systems with feedback loops, electronic circuits and <span class="strong"><strong>printed circuit board</strong></span> (<span class="strong"><strong>PCB</strong></span>) design, rule engine, state machines, simulators, and so on.
</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Electronic spread sheets - A quintessential example">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11lvl1sec80"></a>Electronic spread sheets - A quintessential example</h1>
            </div>
          </div>
        </div>
        <p>Electronic spreadsheets such as Excel software help one to input values in Cells, in a program-specific manner (for example-<span class="emphasis"><em>A7</em></span> , <span class="emphasis"><em>B6</em></span>, and so on). They also allow you to embed computation as a value of a cell (such as&#160;<span class="emphasis"><em>=$A7*$B6</em></span> ) using formulas. Whenever a value is changed in <span class="emphasis"><em>A7</em></span> or <span class="emphasis"><em>B6</em></span>, the resulting formula will be recomputed. Actually, the change is propagated to cells where there is reference to the cell which changed. This can be called a type of reactive computation. Let's see our Pythagorean triple generation in action on Excel:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_11_01.jpg" alt="Electronic spread sheets - A quintessential example"/>
        </div>
        <p>
</p>
        <p>In the preceding table, you can see that column <span class="strong"><strong>F</strong></span> indicates (achieved with conditional formatting using icon sets) whether <span class="strong"><strong>a</strong></span>, <span class="strong"><strong>b,</strong></span> and <span class="strong"><strong>c</strong></span> are Pythagorean triples or not.</p>
        <p>The hidden columns <span class="strong"><strong>D</strong></span> and <span class="strong"><strong>F</strong></span> compute the values of (<span class="strong"><strong>a<sup>2</sup> + b<sup>2</sup></strong></span>) and <span class="strong"><strong>c<sup>2</sup></strong></span> independently, and column F just checks for an equality in order to display a potential match. All these are done, of course, using formulas, and the changes across cells are propagated automatically.</p>
        <p>The following screenshot illustrates this:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_11_02.jpg" alt="Electronic spread sheets - A quintessential example"/>
        </div>
        <p>
</p>
        <p>This example should give you an idea of how reactive programming works, and more interestingly, we will use this trivial example to illustrate a deep consequence beyond reactive programming. This spreadsheet program elegantly models the <span class="strong"><strong>Model-View-ViewModel</strong></span> (<span class="strong"><strong>MVVM</strong></span>) pattern, an architectural pattern heavily employed in WPF, Silverlight, and now, most of the prevalent HTML UI frameworks (JS-based). The Model in this case would be columns <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span> (consider each row as entities and the columns as entity attributes). The View Model would be columns <span class="strong"><strong>D</strong></span> and <span class="strong"><strong>E</strong></span> (derived attributes from the model attributes). And column <span class="strong"><strong>F</strong></span> would be the View which is bound to the View Model (and any change in View Model would be synchronized with the View; as a matter of fact, any changes in the Model would be propagated to the View Model and further down to the View).</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Reactive programming model">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11lvl1sec81"></a>Reactive programming model</h1>
            </div>
          </div>
        </div>
        <p>Simply put, reactive programming is nothing but programming with asynchronous data streams. By applying various operations on stream, we can achieve different computational goals. The primary task in a reactive program is to convert the data into streams, regardless of what the source of the data is. While writing modern graphical user interface applications, we process mouse move-and-click events. Currently, most systems get a callback, and process these events as and when they happen. Most of the time, the handler does a series of filtering operations before it invokes the action methods associated with the event calls.</p>
        <p>In this particular context, reactive programming helps us in aggregating the mouse move-and-click events into a collection, and sets filters on them before notifying the handler logic. In this way, the application/handler logic does not get executed unnecessarily.</p>
        <p>Stream-processing model is well known, and it is very easy to encode by application developers. Pretty much anything can be converted into a stream. Such candidates include messages, logs, properties, twitter feeds, blog posts, RSS feeds, and so on. Functional programming techniques are really good at processing streams. A language like C#, with its inherent support for functional programming idioms, becomes a natural choice for writing reactive programs.</p>
        <p>The basic idea behind reactive programming is that there are certain datatypes that represent a value over time. These datatypes (or rather data sequences) are represented as observable sequences in this programming paradigm. Computations that involve these changing (time dependent) values will, in turn, themselves have values that change over time, and would need to asynchronously receive notifications (as and when the dependent data changes). Remember the spreadsheet application discussed earlier?</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Functional reactive programming">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11lvl1sec82"></a>Functional reactive programming</h1>
            </div>
          </div>
        </div>
        <p>Most modern programming languages support functional programming constructs. Functional programming constructs such as Map/Reduce, Filter, Fold, and so on are good for processing streams. Programming asynchronous data streams using functional programming constructs is called functional reactive programming. This is gaining more&#160;traction among the developers these days.</p>
        <p>The FRP programs can be classified as <span class="strong"><strong>push-based</strong></span> and <span class="strong"><strong>pull-based</strong></span>. The pull-based system waits for a demand to push the data streams to the requestor (or subscriber in our case). This is the classic case where the data source is actively polled for more information. This employs the iterator pattern, and <code class="literal">IEnumerable &lt;T&gt;</code>/<code class="literal">IEnumerator &lt;T&gt;</code> interfaces are specifically designed for such scenarios that are synchronous in nature (application can block while pulling data). On the other hand, a push-based system aggregates the events and pushes through a signal network to achieve the computation. In this case, unlike the pull-based system, data and related updates are handed to the subscriber from the source (observable sequences in this case). This asynchronous nature is achieved by not blocking the subscriber, but rather making it react to the changes. The observer pattern is put to extensive use here using the <code class="literal">IObservable &lt;T&gt;</code> and <code class="literal">IObserver&lt;T&gt;</code> interfaces (which have been introduced as part of .NET framework 4.0). As you can see, employing this push pattern is more beneficial in rich UI environments where you wouldn't want to block the main UI thread while waiting for some events. This becomes ideal, thus making reactive programs responsive.</p>
        <div class="section" title="Reactive programming principles">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec47"></a>Reactive programming principles</h2>
              </div>
            </div>
          </div>
          <p>Reactive systems are composed of small subsystems, which have got reactive properties at the subsystems level. This is possible, because reactive applications apply sound design principles to maintain the responsiveness of their constituents.</p>
          <p>According to&#160;the reactive manifesto, the following are the four principles of reactive programming:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Responsiveness</strong></span>: A reactive system is supposed to respond to events in a time-bound manner. This helps in usability and utilizability of the systems. Responsive systems help us to detect anomalies very early, and can maintain good <span class="strong"><strong>Quality of Service</strong></span> (<span class="strong"><strong>QoS</strong></span>). This is very important for systems that have <span class="strong"><strong>service level agreement</strong></span> (<span class="strong"><strong>SLA</strong></span>) and <span class="strong"><strong>operations level agreement</strong></span> (<span class="strong"><strong>OLA</strong></span>).</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resilience</strong></span>: Reactive systems should stay responsive even in the case of a system failure. Failures are contained in each component by careful isolation of subsystems, and making sure that failure does not get propagated to other parts. By good modularization, we can recover from failure by replacing components that fail without affecting the other modules of the system.</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Elasticity</strong></span>: Reactive systems should stay responsive under varying levels of stress due to the workloads. By effective throttling of event streams and dynamic resource management, we can write systems that can handle varying workloads.</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Message driven</strong></span>: Reactive systems rely on asynchronous messaging-based programming models to establish strict boundaries between components by maintaining loose coupling and location transparency (in the case of distributed systems). Employing explicit message-passing helps to manage load better, and to provide elasticity and explicit flow control through throttling. Non-blocking communication between components makes sure that resource management is done diligently. Moreover, system failures can be propagated as messages.</li>
            </ul>
          </div>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_11_03.jpg" alt="Reactive programming principles"/>
          </div>
          <p>
</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Rx from Microsoft">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11lvl1sec83"></a>Rx from Microsoft</h1>
            </div>
          </div>
        </div>
        <p>Microsoft brought out&#160;<span class="strong"><strong>software development kit</strong></span> (<span class="strong"><strong>SDK</strong></span>) for reactive programming, which it monikers as .NET Rx. According to them, Rx extensions is a unified library for composing asynchronous and event-based programs using observable sequences and LINQ style query operations. The key aspects of their descriptions are as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Asynchronous event streams</li>
            <li class="listitem" style="list-style-type: disc">Composition</li>
            <li class="listitem" style="list-style-type: disc">Observable sequences (streams)</li>
            <li class="listitem" style="list-style-type: disc">LINQ style queries</li>
          </ul>
        </div>
        <p>The sequences can be contents of a file, network socket, web service response, input streams, and so on. Microsoft gives a symbolic formula for Rx, that is, <span class="emphasis"><em>Rx = Observables + LINQ + Schedulers</em></span>.</p>
        <div class="section" title="Key data structures of Rx">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec48"></a>Key data structures of Rx</h2>
              </div>
            </div>
          </div>
          <p>The Microsoft Rx SDK specifies some key data types, which a programmer can leverage to implement reactive programs. Some of the key types are as follows:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">
                <code class="literal">IObservable&lt;T&gt;</code>
              </li>
              <li class="listitem" style="list-style-type: disc">
                <code class="literal">IObserver&lt;T&gt;</code>
              </li>
              <li class="listitem" style="list-style-type: disc">
                <code class="literal">Subject&lt;T&gt;</code>
              </li>
            </ul>
          </div>
          <p>The signature of <code class="literal">IObserver</code> and <code class="literal">IObservable</code> is given as follows:</p>
          <pre class="programlisting"> 
    public interface IObserver&lt;T&gt; 
    { 
      void OnCompleted(); 
      void OnError(Exception exception); 
      void OnNext(T value); 
    }  
 
 
    public interface IObservable&lt;T&gt; 
    { 
      IDisposable Subscribe(IObserver&lt;T&gt; observer); 
    } 
</pre>
        </div>
        <div class="section" title="IEnumberable/IObservable duality">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec49"></a>IEnumberable/IObservable duality</h2>
              </div>
            </div>
          </div>
          <p>The .NET framework has&#160;built-in support for the Iterator pattern (through <code class="literal">IEnumerable&lt;T&gt;</code>) and observer pattern (through <code class="literal">IObservable&lt;T&gt;</code>). If you take a closer look, there is only a subtle difference between these two patterns. <code class="literal">IEnumerable&lt;T&gt;</code> can be considered the pull-based equivalent of the push-based <code class="literal">IObservable&lt;T&gt;</code>. In fact, they are duals. When two entities exchange information, one entity's action of pull corresponds to other entity pushing the information. This duality is illustrated in the following image:</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_11_04.jpg" alt="IEnumberable/IObservable duality"/>
          </div>
          <p>
</p>
          <p>Let's understand this duality by looking at this sample code, an even number sequence generator:</p>
          <pre class="programlisting">    static void Main(string[] args) 
    { 
      int[] number_array = new int[] { 1,2,3,4,5,6,8}; 
      IEnumerable&lt;int&gt; number_sequence = number_array; 
      foreach (var n in number_sequence) 
        if (n % 2 == 0) 
          Console.WriteLine(n); 
    } 
</pre>
          <p>We will write a number sequence generator to demonstrate how these data types work together in converting a pull-based program to an Rx push program. First we will write a toy implementation of <code class="literal">IDisposable</code> to be used later: The robustness aspect is given low priority to keep the listing terse:</p>
          <pre class="programlisting">    class EmptyDisposable : IDisposable 
    { 
      internal Action action {get;  set;} 
      void IDisposable.Dispose() 
      { this.action(); } 
    } 
 
    class EvenNumberObservable : IObservable&lt;int&gt; 
    { 
      public EvenNumberObservable(IEnumerable&lt;int&gt; numbers) 
      { 
        this._numbers = numbers; 
      } 
 
      private IEnumerable&lt;int&gt; _numbers; 
 
      public IDisposable Subscribe(IObserver&lt;int&gt; observer) 
      { 
        foreach(int number in _numbers) 
        { 
          if (number%2 == 0 ) 
          observer.OnNext(number); 
        } 
        observer.OnCompleted(); 
 
        return new EmptyDisposable { action = () =&gt; { ;  } };  
      } 
    } 
 
    class SimpleObserver : IObserver&lt;int&gt; 
    { 
      public void OnNext(int value) {  Console.WriteLine(value);} 
      public void OnCompleted() { Console.WriteLine("Completed"); } 
      public void OnError(Exception ex){ 
      Console.WriteLine("An Error Encountered"); 
      throw ex; 
    } 
  }  
</pre>
          <p>The following code snippet invokes the preceding code:</p>
          <pre class="programlisting">    static void Main(string[] args) 
    { 
      new EvenNumberObservable( 
      new[] { 1,2, 3, 4,6,7,8 }) 
      .Subscribe(new SimpleObserver()); 
      Console.ReadLine(); 
    } 
</pre>
          <p>From this preceding example, you see how one can naturally subscribe for even numbers from an observable sequence of natural numbers. The system will automatically push (publish) the values to the observer (subscriber) when an even number is detected. The code gives explicit implementations for the key interfaces so that one can understand or speculate what really happens under the hood.</p>
          <p>Another example would be Pythagorean triple generation from observable sequences of base, altitude, and hypotenuse. We have already seen the <span class="strong"><strong>functional</strong></span> code for achieving this, and now, let's see the <span class="strong"><strong>reactive</strong></span> equivalent (or should we say, a better one):</p>
          <pre class="programlisting">    void Main() 
    { 
      var result = 
        from i in Observable.Range(1, 100) 
        from j in Observable.Range(1, 100) 
        from k in Observable.Range(1, 100) 
        where k * k == i * i + j * j 
        select new { a = i, b = j, c = k };   
 
      // A Subscriber with 
      // A callback (Lambda) which prints value, 
      // A callback for Exception 
      // A callback for Completion  
 
      IDisposable subscription = result.Subscribe( 
      x =&gt; Console.WriteLine("OnNext: {0}", x),  
      ex =&gt; Console.WriteLine("OnError: {0}", ex.Message), 
      () =&gt; Console.WriteLine("OnCompleted")); 
    } 
</pre>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Converting entities to streams (IObservable&lt;T&gt;)">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11lvl1sec84"></a>Converting entities to streams (IObservable&lt;T&gt;)</h1>
            </div>
          </div>
        </div>
        <p>The following constructs can be converted to a sequence source. <code class="literal">IObservable&lt;T&gt;</code> can be generated from the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Events</li>
            <li class="listitem" style="list-style-type: disc">Delegates</li>
            <li class="listitem" style="list-style-type: disc">Tasks</li>
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">IEnumerable&lt;T&gt;</code>
            </li>
            <li class="listitem" style="list-style-type: disc">Asynchronous programming model</li>
          </ul>
        </div>
        <div class="section" title="Converting events into stream">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec50"></a>Converting events into stream</h2>
              </div>
            </div>
          </div>
          <p>We have now understood how one can convert an <code class="literal">IEnumerable&lt;T&gt;</code>-based pull program to an <code class="literal">IObservable&lt;T&gt;</code>/<code class="literal">IObserver&lt;T&gt;</code>-based push program. In real life, the event source is not as simple as we found in the number stream example given previously. Let us see how we can convert a <code class="literal">MouseMove</code> event into a stream with a small WinForms program:</p>
          <pre class="programlisting">    static void Main()  
    { 
      var mylabel = new Label(); 
      var myform = new Form { Controls = { mylabel } }; 
 
      IObservable&lt;EventPattern&lt;MouseEventArgs&gt;&gt;  
      mousemove =  
      Observable. 
      FromEventPattern&lt;MouseEventArgs&gt;(myform, "MouseMove"); 
 
      mousemove.Subscribe( 
        (evt)=&gt;{mylabel.Text = evt.EventArgs.X.ToString();}, 
        ()=&gt;{}); 
 
      Application.Run(myform); 
    } 
</pre>
          <p>Please see the following form, which displays the mouse positions:</p>
          <p>
</p>
          <div class="mediaobject">
            <img src="graphics/B05691_11_05.jpg" alt="Converting events into stream"/>
          </div>
          <p>
</p>
        </div>
        <div class="section" title="Reduction of streams (sequences)">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec51"></a>Reduction of streams (sequences)</h2>
              </div>
            </div>
          </div>
          <p>The whole idea of converting data to streams is to apply functional programming operators such as Reduce, Aggregate, Fold, and so on. This is quite relevant in terms of choosing the needed data (and also in an efficient way) from an enormous pile that is ever growing with respect to time:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Filter and partition operators</strong></span>: These operations help to reduce the source sequence into a sequence of elements that we are interested in</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Aggregation operators</strong></span>: Reduce the source sequence to a sequence with a single element</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fold operators</strong></span>: Reduce the source sequence to a single element as a scalar value</li>
            </ul>
          </div>
          <p>Some of the common sequence/stream operators supported by Rx/LINQ are as follows:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><code class="literal">Where</code>: As the name implies, and for those familiar with this operator from LINQ days, it does the very purpose of filtering of sequences. If we were to rewrite our earlier example-that of extracting/filtering even numbers-it would declaratively be as simple as this:
<pre class="programlisting">        var evenNumbers = Observable.Range(0, 10) 
        .Where(i =&gt; i % 2 == 0) 
        .Subscribe(Console.WriteLine); 
</pre></li>
              <li class="listitem" style="list-style-type: disc">In the preceding example, the input is 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, and the output will be 2, 4, 6, and 8.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">Skip</code>: This helps in skipping <span class="emphasis"><em>n</em></span> items in a sequence.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">Take</code>: This helps in taking <span class="emphasis"><em>n</em></span> items (skipping the rest) in a sequence.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">SkipWhile</code>: This helps in skipping items (while a certain condition is satisfied) in a sequence. Please note that the element would be skipped until the predicate evaluates to <code class="literal">true</code>. Beyond this, all items would be returned.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">TakeWhile</code>: This is the converse of <code class="literal">SkipWhile</code>, and helps in taking items (while a certain condition is satisfied) in a sequence.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">SkipUntil</code>: This requires two observable sequences, and continues to skip all the values in the first sequence until any value is produced by the second sequence.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">TakeUntil</code>: Again, this requires two observable sequences, and forces the first sequence to completion when the second sequence starts producing any value.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">SkipLast</code>: Intelligently queues elements, skips the last <span class="emphasis"><em>n</em></span> elements, and returns the rest.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">TakeLast</code>: Returns the last <span class="emphasis"><em>n</em></span> elements.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">Zip</code>: Merges two observable sequences into one observable sequence.</li>
            </ul>
          </div>
        </div>
        <div class="section" title="Inspection of streams (sequences)">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec52"></a>Inspection of streams (sequences)</h2>
              </div>
            </div>
          </div>
          <p>Rx provides a set of operators, which can help us to inspect the contents of a stream. Some of them are:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><code class="literal">Any</code>: This returns an observable sequence (result), which returns one value (<code class="literal">True</code> or <code class="literal">False</code>) and completes. <code class="literal">True</code> indicates that the source sequence produced a value that caused the result sequence to produce <code class="literal">True</code>. On the other hand, the result sequence returns <code class="literal">False</code> if the source sequence completes without any values.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">All</code>: This works similar to <code class="literal">Any</code> except that the results sequence returns <code class="literal">True</code> if the predicate is evaluated to <code class="literal">True</code> and <code class="literal">False</code> vice versa.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">Contains</code>: This shows the same behavior as <code class="literal">All</code> except that it helps seek a specific value instead of a value that fits the predicate.</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">ElementAt</code>: This returns an observable sequence (result), which returns the value in the source sequence (specified by the index) and completes. It uses a 0-based index.</li>
            </ul>
          </div>
        </div>
        <div class="section" title="Aggregation of streams (sequences)">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec53"></a>Aggregation of streams (sequences)</h2>
              </div>
            </div>
          </div>
          <p>Rx provides a series of operators, which help us to aggregate the content of a stream. Some of the most important ones are as follows:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">
                <code class="literal">Count</code>
              </li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">Min</code>, <code class="literal">Max</code>, <code class="literal">Average</code>, <code class="literal">Sum</code> (descriptive statistics)</li>
              <li class="listitem" style="list-style-type: disc"><code class="literal">MinBy</code>, <code class="literal">MaxBy</code>, <code class="literal">GroupBy</code> (partitioning)</li>
              <li class="listitem" style="list-style-type: disc">Custom aggregators and scans</li>
            </ul>
          </div>
        </div>
        <div class="section" title="Transformation of streams (sequences)">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec54"></a>Transformation of streams (sequences)</h2>
              </div>
            </div>
          </div>
          <p>The values produced by our event source are not in the formats that we might want, and we are required to make the transformation on each element in the sequence. The most important functional transformation is bind, where we apply a function (morphism) on each element of the sequence to produce a new sequence.</p>
          <p>In functional programming parlance, the transformations available are the following:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Anamorphism, which transforms&#160;<code class="literal">T</code> to <code class="literal">IObservable&lt;T&gt;</code>:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Unfold</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Generate</code></li>
</ul>
</div></li>
              <li class="listitem" style="list-style-type: disc">Catamorphism, which transforms an <code class="literal">IObservable&lt;T&gt;</code> to <code class="literal">T</code>:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Fold</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Reduce</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Accumulate</code></li>
</ul>
</div></li>
              <li class="listitem" style="list-style-type: disc">Bind, which transforms an <code class="literal">IObservable&lt;T&gt;</code> to <code class="literal">IObservable&lt;T&gt;</code>:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Map</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">SelectMany</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Projection</code></li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Transform</code></li>
</ul>
</div></li>
            </ul>
          </div>
        </div>
        <div class="section" title="Combining streams (sequences)">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch11lvl2sec55"></a>Combining streams (sequences)</h2>
              </div>
            </div>
          </div>
          <p>We get data from different data sources, and it is necessary to combine streams to do processing. Rx provides a series of operators, which can be grouped into the following:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Sequential concatenation:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Concat</code>: As the name indicates, the resulting sequence concatenates multiple input sequences without interleaving them</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Repeat</code>: Creates a sequence that emits a particular item multiple times</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">StartWith</code>: Emits a specified sequence of items before beginning to emit the items from the source sequence</li>
</ul>
</div></li>
              <li class="listitem" style="list-style-type: disc">Concurrent sequences:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Amb</code>: This returns one of the sequences (from two or more source sequences), which first starts emitting an item or notification</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Merge</code>: As the name indicates, this operator combines multiple sequences into one</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Switch</code>: This returns a sequence (from two or more source sequences) that emits the items emitted by the most recently emitted one of those input/source sequences</li>
</ul>
</div></li>
              <li class="listitem" style="list-style-type: disc">Pairing sequences:

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CombineLatest</code>: Combines the most recently emitted items from each of the participating input sequences using a function that is provided, and emits the return value of that function</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">Zip</code>: The behavior is similar to that of <code class="literal">CombineLatest</code> except that the function is applied in a strict sequence (in terms of combining items from the participating input sequences)</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">And</code>/<code class="literal">Then</code>/<code class="literal">When</code>: The behavior is very similar to <code class="literal">Zip</code>, but certain intermediary data structures (namely pattern and plan objects) are used as part of combining the input sequences before emitting the resulting sequence</li>
</ul>
</div></li>
            </ul>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="A philosophy for reactive programming">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11lvl1sec85"></a>A philosophy for reactive programming</h1>
            </div>
          </div>
        </div>
        <p>We started this chapter with a lot of verbose description about the reactive programming model. Then, we showed how one can convert an <code class="literal">IEnumerable&lt;T&gt;</code>-based sequence generator to an <code class="literal">IObservable&lt;T&gt;</code>/<code class="literal">IObserver&lt;T&gt;-</code>based push program. We also demonstrated how one can convert mouse-event data to a stream, using a toy program. The rest of the chapter was about the tools available for manipulating streams or sequences. You learned about the different genres of stream processing operators. One needs to consult the Microsoft documentation on Rx to understand the specifics of stream processors.</p>
        <p>The basic philosophy here can be summarized as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Aggregate data into asynchronous or synchronous streams from the event source.</li>
            <li class="listitem" style="list-style-type: disc">Apply preprocessing methods using various operators available at the data source itself (outside the stream consumer).</li>
            <li class="listitem" style="list-style-type: disc">Process the resulting stream pushed from the data source at the data sink level by applying functional transformation techniques. We can compose stream operations to produce compound operations. By doing this, the whole program becomes a linear chain of functions applied on a stream. If the data stream is not mutated, there is no need for a compensating transaction logic as well.</li>
          </ul>
        </div>
        <pre class="programlisting">    try { 
      outstream =  f(g(h(immutablestream))); 
    } 
    catch {} 
</pre>
        <p>Schematically, the preceding code snippets can be interpreted as that we can apply a series of functions on a stream to produce output stream. Since the input stream is immutable when we process at the data sink level, there is no need for a compensating transaction in the catch handler. The whole processing can be easily debugged as well.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch11lvl1sec86"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, you learned the conceptual underpinnings of (functional) reactive programming, and how Microsoft Rx helps you to write reactive programs using a scheduler, observable interface, and LINQ. We have avoided API documentation in this book (as that is exhaustive and redundant considering the nature of this book). We urge you to refer to the ReactiveX website (<a class="ulink" href="http://reactivex.io/documentation/operators">http://reactivex.io/documentation/operators</a>), MSDN, interactive Rx illustrations website (<a class="ulink" href="http://rxmarbles.com">http://rxmarbles.com</a>), and the online book <span class="emphasis"><em>Introduction to Rx</em></span> by Lee Campbell (<a class="ulink" href="http://www.introtorx.com">http://www.introtorx.com</a>) for specifics and usage examples on the various operators that we have discussed. In the following chapters, we will see detailed examples in C# and JavaScript-based functional reactive programs.</p>
      </div>
    </div>
</body>
</html>