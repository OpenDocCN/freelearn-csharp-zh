- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Containerization of Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的容器化
- en: After building clients and services with the previous chapters, now is the time
    to make the services ready for publishing. With Docker, we can prepare images
    that have everything included to run the complete solution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章构建了客户端和服务之后，现在是时候让服务为发布做好准备。使用Docker，我们可以准备包含运行完整解决方案所需所有内容的镜像。
- en: In this chapter, you’ll start learning the most important parts of Docker, building
    Docker images, running containers, and using .NET Aspire to run a solution consisting
    of multiple services locally on your developer system, including SQL Server running
    in a Docker container, as well as making use of native **ahead-of-time** (**AOT**)
    to create platform-specific native applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开始学习Docker最重要的部分，包括构建Docker镜像、运行容器以及使用.NET Aspire在本地开发系统上运行由多个服务组成的解决方案，包括在Docker容器中运行的SQL
    Server，以及利用本地的**预编译**（**AOT**）创建特定平台的本地应用程序。
- en: 'In this chapter, you’ll learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Working with Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker
- en: Building a Docker image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: Running the solution with .NET Aspire
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET Aspire运行解决方案
- en: Using native AOT with ASP.NET Core
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中使用原生AOT
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: What you need to go through this chapter is **Docker Desktop**. Docker Desktop
    is free for individual developers and education and open source communities. You
    can download Docker Desktop from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/),
    best used with the **Windows Subsystem for Linux** (**WSL**). Check the README
    file of this chapter to install WSL 2 and Docker Desktop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章你需要的是**Docker Desktop**。Docker Desktop对个人开发者、教育和开源社区是免费的。你可以从[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)下载Docker
    Desktop，最佳搭配**Windows子系统Linux**（**WSL**）使用。查看本章的README文件以安装WSL 2和Docker Desktop。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `dotnet publish` command supports building and publishing Docker images.
    While some features of `dotnet publish` can be used without Docker Desktop being
    installed, we start using Docker directly, as this also helps in understanding
    what can be done using the .NET CLI, and often you need a lot more in regard to
    Docker than offered by the .NET CLI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet publish`命令支持构建和发布Docker镜像。虽然`dotnet publish`的一些功能可以在不安装Docker Desktop的情况下使用，但我们直接开始使用Docker，因为这也有助于理解可以使用.NET
    CLI做什么，而且通常你需要比.NET CLI提供的更多关于Docker的功能。'
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).
- en: The `ch05` source code folder contains the code samples for this chapter. For
    different sections of this chapter, different subfolders are available. For a
    start, working through the instructions, you can use the `StartXX` folders. `StartDocker`
    contains the projects before creating Docker containers have been added and the
    `FinalDocker` folder contains the project in the final state after building the
    Docker container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch05`源代码文件夹包含本章的代码示例。对于本章的不同部分，有不同的子文件夹可供选择。为了开始，按照说明操作，你可以使用`StartXX`文件夹。`StartDocker`文件夹包含在创建Docker容器之前添加的项目，而`FinalDocker`文件夹包含构建Docker容器后的最终状态的项目。'
- en: The `StartAspire` folder contains multiple projects that the .NET Aspire-specific
    projects we created in the previous chapters are already part of. Use this as
    a starting point to work through the .NET Aspire part of this chapter. `FinalAspire`
    contains the complete result, which you can use as a reference. The `NativeAOT`
    folder contains the code for the games API that compiles with .NET native AOT.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartAspire`文件夹包含多个项目，我们在前几章创建的.NET Aspire特定项目已经包含在内。将其作为本章.NET Aspire部分的起点。`FinalAspire`包含完整的结果，你可以将其作为参考。`NativeAOT`文件夹包含用于编译.NET原生AOT的游戏API的代码。'
- en: 'In the subfolders of the `ch05` folder, you’ll see these projects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch05`文件夹的子文件夹中，你会看到以下项目：
- en: '`Codebreaker.GameAPIs` – The games API project we used in the previous chapter
    from our client application. In this chapter, we make minor updates to specify
    the connection string to the SQL Server database. This project has a reference
    to NuGet packages with implementations of the `IGamesRepository` interface for
    SQL Server and Azure Cosmos DB.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs` – 我们在前一章客户端应用程序中使用的游戏API项目。在本章中，我们对项目进行了少量更新，以指定连接到SQL
    Server数据库的连接字符串。该项目引用了NuGet包，其中实现了`IGamesRepository`接口的SQL Server和Azure Cosmos
    DB实现。'
- en: '`Codebreaker.Bot` – This is a new project that implements a REST API and calls
    the games API to automatically play games with random game moves. This project
    makes use of the client library we created in [*Chapter 4*](B21217_04.xhtml#_idTextAnchor092)
    – it has a reference to the `CNinnovation.Codebreaker.Client` NuGet package to
    call the games API.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Bot` – 这是一个新项目，它实现了REST API并调用游戏API以自动进行随机游戏操作。该项目利用我们在[*第4章*](B21217_04.xhtml#_idTextAnchor092)中创建的客户端库
    – 它引用了`CNinnovation.Codebreaker.Client` NuGet包来调用游戏API。'
- en: '`Codebreaker.AppHost` – This project is enhanced to orchestrate the different
    services.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost` – 该项目得到了增强，以协调不同的服务。'
- en: '`Codebreaker.ServiceDefaults` – This project is unchanged in this chapter.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.ServiceDefaults` – 在本章中，该项目没有变化。'
- en: '`Codebreaker.GameAPIs.NativeAOT` – A new project that offers the same games
    API with some changes to support native AOT with .NET 8.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.NativeAOT` – 一个新项目，它提供了经过一些修改以支持.NET 8原生AOT的游戏API。'
- en: Working with Docker
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker
- en: Although nowadays, it’s possible just to work with .NET tools to create microservices
    and run Docker containers, it helps to know about Docker. Thus, here, we look
    at the most important concepts about Docker, starting up a SQL Server instance
    running within a Docker container, creating a Dockerfile to build a Docker image
    for the games API service, and running these containers on the local system. In
    case you already know all about Docker, you can skip and move over to the *.NET
    Aspire* section, which does not need the Docker containers created here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如今，仅使用.NET工具创建微服务和运行Docker容器是可能的，但了解Docker仍然很有帮助。因此，在这里，我们查看Docker的一些重要概念，包括启动在Docker容器中运行的SQL
    Server实例，创建用于构建游戏API服务的Dockerfile，以及在本地系统上运行这些容器。如果你已经对Docker了如指掌，你可以跳过并转到*.NET
    Aspire*部分，该部分不需要在此处创建的Docker容器。
- en: Before diving into building Docker images, why do we need containers at all?
    When deploying an application, it often occurs that the application fails to run.
    Often, a reason for this is a missing runtime on the target system or wrong or
    missing configuration settings. One way to resolve this is to prepare **virtual
    machines** (**VMs**) where everything is preinstalled. The disadvantage of this
    is the resources that the VM needs. A VM comes with an operating system and allocates
    CPU and memory resources. Docker is a lot more lightweight. A Docker image can
    be small as an operating system is not part of the image – and multiple Docker
    containers can share the same CPU and memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入构建Docker镜像之前，我们为什么需要容器呢？在部署应用程序时，应用程序经常无法运行。通常，原因是在目标系统上缺少运行时或配置设置错误或缺失。解决这一问题的方法之一是准备**虚拟机**（**VM**），其中所有内容都已预先安装。这种方法的缺点是虚拟机需要的资源。虚拟机包含操作系统并分配CPU和内存资源。Docker要轻量得多。Docker镜像可以小到操作系统不是镜像的一部分的程度
    – 而多个Docker容器可以共享相同的CPU和内存。
- en: 'Here’s a brief list of important terms when using Docker before going into
    the details:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解细节之前，这里有一个使用Docker时的重要术语简要列表：
- en: A Docker **image** is an executable package that contains everything to run
    an application
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker **镜像** 是一个包含运行应用程序所需所有内容的可执行包
- en: One image might have different versions, which are identified by Docker **tags**
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个镜像可能有不同的版本，这些版本通过Docker **标签**来识别
- en: A **Dockerfile** is a text file with instructions to build a Docker image
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile** 是一个包含构建Docker镜像指令的文本文件'
- en: A Docker **container** is the running instance of a Docker image
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker **容器** 是Docker镜像的运行实例
- en: The Docker **registry** is where Docker images are stored
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker **仓库** 是Docker镜像的存储位置
- en: A Docker **repository** is a collection of different versions of a Docker image
    in the registry
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker **仓库** 是在仓库中不同版本的Docker镜像的集合
- en: Using Docker Desktop
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker Desktop
- en: 'Docker Desktop for Windows offers an environment to build Docker images and
    run Docker containers on Windows. You can configure it to use Windows or Linux
    containers. With a previous edition of Docker Desktop for Windows, it was required
    to install Hyper-V. Docker Desktop then used a Linux VM to run all Linux containers
    on this VM. Because Windows now supports Linux more natively with WSL, Docker
    Desktop can use WSL and doesn’t need a VM. With the Docker Desktop configuration,
    you can select WSL distros (see *Figure 5**.1*) that should use the same Docker
    environment as on the Windows system itself. Using these Linux distributions,
    you can use the same Docker commands to manage your Docker environment:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop for Windows提供了一个环境，可以在Windows上构建Docker镜像和运行Docker容器。你可以配置它使用Windows或Linux容器。在Docker
    Desktop for Windows的早期版本中，需要安装Hyper-V。Docker Desktop随后使用Linux虚拟机在该虚拟机上运行所有Linux容器。因为Windows现在通过WSL更原生地支持Linux，所以Docker
    Desktop可以使用WSL，不需要虚拟机。在Docker Desktop配置中，你可以选择使用与Windows系统本身相同的Docker环境的WSL发行版（见*图5.1*）。使用这些Linux发行版，你可以使用相同的Docker命令来管理你的Docker环境：
- en: '![Figure 5.1 – WSL integration in Docker Desktop](img/B21217_05_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – Docker Desktop中的WSL集成](img/B21217_05_01.jpg)'
- en: Figure 5.1 – WSL integration in Docker Desktop
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – Docker Desktop中的WSL集成
- en: Instead of configuring a VM with the amount of CPU and memory you allocate,
    WSL shares CPU and memory with Windows – but there are some limits for WSL. With
    the Windows build version 20176 and later, the memory is limited to 50% and 8
    GB (whichever is less); with builds before that, WSL can use 80% of the total
    memory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与配置使用你分配的CPU和内存数量的虚拟机不同，WSL与Windows共享CPU和内存——但WSL有一些限制。在Windows构建版本20176及以后的版本中，内存限制为50%和8GB（取较小者）；在之前的版本中，WSL可以使用总内存的80%。
- en: For the number of logical processors, by default, all available can be used.
    You can change memory and CPU limits globally for the complete subsystem but also
    define different limits for each Linux distribution you install. Check the settings
    configuration in WSL at [https://learn.microsoft.com/windows/wsl/wsl-config](https://learn.microsoft.com/windows/wsl/wsl-config).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逻辑处理器的数量，默认情况下，可以使用所有可用的处理器。你可以为整个子系统全局更改内存和CPU限制，也可以为安装的每个Linux发行版定义不同的限制。检查WSL的设置配置，请参阅[https://learn.microsoft.com/windows/wsl/wsl-config](https://learn.microsoft.com/windows/wsl/wsl-config)。
- en: Running a Docker container
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Docker容器
- en: After you’ve installed Docker Desktop and you are running Windows, you can select
    to run Windows or Linux containers. While Windows containers are great for legacy
    applications that only run on Windows (for example, using .NET Framework), Linux
    containers offer more features, and Linux Docker images are smaller. The solution
    we build will run with Linux containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你安装了Docker Desktop并且正在运行Windows后，你可以选择运行Windows或Linux容器。虽然Windows容器非常适合仅运行在Windows上的旧版应用程序（例如，使用.NET
    Framework），但Linux容器提供更多功能，Linux Docker镜像也较小。我们构建的解决方案将使用Linux容器运行。
- en: 'The Docker Desktop environment needs to be started, then to run the first container,
    use this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要先启动Docker Desktop环境，然后要运行第一个容器，请使用以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the first run, the `hello-world` Docker image is downloaded from the Docker
    registry and started. This container just writes a message to the screen to verify
    that everything is running. Starting it a second time, you’ll see that the image
    is no longer downloaded but started immediately.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行时，`hello-world` Docker镜像从Docker仓库下载并启动。这个容器只是将一条消息写入屏幕以验证一切是否正常运行。再次启动它时，你会看到镜像不再下载，而是立即启动。
- en: 'To see all images downloaded, you can use this command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有下载的镜像，你可以使用以下命令：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see running containers, use the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看正在运行的容器，请使用以下命令：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There’s also a shorthand notation to show all running containers: `docker ps`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个简写符号来显示所有正在运行的容器：`docker ps`。
- en: You will not see the `hello-world` container because this already stopped immediately
    after writing the output.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看不到`hello-world`容器，因为这个容器在写入输出后立即停止了。
- en: Running an image again and again, you start fresh again. But there’s also a
    state kept with a running image. This allows you to continue a previously stopped
    container with the same state as before. The `docker container ls -a` command
    not only shows running but also stopped containers. Using `docker container prune`,
    you can delete the state from all stopped containers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重复运行一个镜像，你就可以从头开始。但同时也保留了一个与运行中的镜像相关的状态。这允许你继续之前停止的容器，并保持之前的状态。`docker container
    ls -a` 命令不仅显示了正在运行的容器，还显示了已停止的容器。使用 `docker container prune`，你可以从所有已停止的容器中删除状态。
- en: Running SQL Server in a Docker container
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Docker 容器中运行 SQL Server
- en: In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we used SQL Server and an
    Azure Cosmos DB emulator on the local system to access it from the games service.
    Instead of installing these products on your local system, you can also use Docker
    images.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B21217_03.xhtml#_idTextAnchor063) 中，我们使用了本地系统上的 SQL Server 和 Azure
    Cosmos DB 模拟器来从游戏服务访问它。您也可以使用 Docker 镜像，而不是在本地系统上安装这些产品。
- en: 'Let’s start downloading the Docker image for SQL Server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始下载 SQL Server 的 Docker 镜像：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Previously, we used `docker run` to start a container and implicitly download
    it from a registry. `docker pull` just downloads the image from the registry.
    `mcr.microsoft.com` is the Microsoft repository where Microsoft stores images.
    `mssql/server` is the name of the image. You can read information about this image
    at [https://hub.docker.com/_/microsoft-mssql-server](https://hub.docker.com/_/microsoft-mssql-server).
    This is an Ubuntu-based image. `2022-latest` is a tag name. This is the actual
    version of SQL Server 2022\. With SQL Server, other tags are `2019-latest`, `2017-latest`,
    and `latest`. These correspond to SQL Server 2019 and 2017\. The `latest` tag
    is the latest version of SQL Server. At the time of this writing, the image is
    the same with both the `2022-latest` and the `latest` tags. If you download both
    images, a second download is not needed, and you will see images with the same
    image ID but with different tags.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用 `docker run` 启动容器并隐式地从注册表中下载它。`docker pull` 只是从注册表中下载镜像。`mcr.microsoft.com`
    是微软存储镜像的 Microsoft 仓库。`mssql/server` 是镜像的名称。您可以在 [https://hub.docker.com/_/microsoft-mssql-server](https://hub.docker.com/_/microsoft-mssql-server)
    上阅读有关此镜像的信息。这是一个基于 Ubuntu 的镜像。`2022-latest` 是一个标签名称。这是 SQL Server 2022 的实际版本。对于
    SQL Server，其他标签是 `2019-latest`、`2017-latest` 和 `latest`。这些对应于 SQL Server 2019
    和 2017。`latest` 标签是 SQL Server 的最新版本。在撰写本文时，该镜像与 `2022-latest` 和 `latest` 标签相同。如果您下载了这两个镜像，则不需要第二次下载，您将看到具有相同镜像
    ID 但不同标签的镜像。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The default configuration to use SQL Server with the Docker image is the SQL
    Server Developer Edition. You can also configure to use the Express, Standard,
    Enterprise, and Enterprise Core editions by setting an environmental variable.
    Pay attention to required licenses with non-developer editions. Read the image
    documentation for setting environment variables for the different editions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 镜像与 SQL Server 的默认配置是 SQL Server 开发者版。您也可以通过设置环境变量来配置使用 Express、标准、企业和企业核心版。请注意非开发者版本的必要许可证。阅读镜像文档以设置不同版本的环境变量。
- en: Another option to use a SQL Server edition within a Docker environment is Azure
    SQL Edge. Check [https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment](https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment)
    for running Azure SQL Edge.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 环境中使用 SQL Server 版本的另一个选项是 Azure SQL Edge。请检查 [https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment](https://learn.microsoft.com/en-us/azure/azure-sql-edge/disconnected-deployment)
    了解如何运行 Azure SQL Edge。
- en: 'To run the SQL Server image, you can use the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 SQL Server 镜像，您可以使用以下命令：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this command, these options are used:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，这些选项被使用：
- en: '`-e` specifies an environmental variable. With the two variables, the license
    is accepted, and a password for the `sa` account is defined. `sa` is a privileged
    account configured, and a short name for *system administrator*.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e` 指定环境变量。使用这两个变量，许可证被接受，并为 `sa` 账户定义了一个密码。`sa` 是一个配置了权限的账户，是 *系统管理员* 的简称。'
- en: The `-p` option maps the port from the host to the container. On the target
    host, the same port cannot be used for multiple applications; for example, by
    having a local SQL Server running, the first value cannot use 1433\. Make sure
    to use an available port.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p` 选项将主机上的端口映射到容器。在目标主机上，不能为多个应用程序使用相同的端口；例如，如果有一个本地 SQL Server 正在运行，第一个值不能使用
    1433。请确保使用一个可用的端口。'
- en: The `--name` option specifies a name for the container. By default, a random
    name combined from two lists is used.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name` 选项指定容器的名称。默认情况下，使用两个列表的组合生成一个随机名称。'
- en: The `--hostname` option specifies the hostname for the container.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--hostname` 选项指定容器的主机名。'
- en: The `-d` option runs the container in the background.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 选项在后台运行容器。'
- en: 'For some useful information to find out what the container does, use `docker`
    `container logs`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关容器做什么的有用信息，请使用 `docker container logs`：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command needs the name of the container. To connect and wait for all the
    logs to come, add the `-f` option (for *follow*).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令需要容器的名称。要连接并等待所有日志到来，请添加 `-f` 选项（表示 *跟随*）。
- en: To open a command prompt within the container and see what’s there, use `docker
    exec -it sql1 bash`, which allocates a terminal, keeps `stdin` open (interactive
    mode), and executes the Bash shell within the container.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要在容器内打开命令提示符并查看内容，请使用 `docker exec -it sql1 bash`，这将分配一个终端，保持 `stdin` 打开（交互模式），并在容器内执行
    Bash shell。
- en: After the container with SQL Server is running, we can publish the database
    we created in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 容器启动后，我们可以发布在 [*第 3 章*](B21217_03.xhtml#_idTextAnchor063) 中创建的数据库。
- en: Using volumes with a Docker container
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker 容器中的卷
- en: The Docker container for SQL Server contains state (the database files). We
    can start a previous running container again (using `docker start`). When using
    `docker run`, we start fresh again, and the previous state is not used. Using
    `docker commit`, you can create a new image from a container. This keeps the database
    and the state together, and the Docker images grow in size. A better practice
    is to keep the state outside of the Docker container. You can mount external directories,
    files, and Docker volumes within a container. Docker volumes are completely managed
    by Docker. Let’s use this for SQL Server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 的 Docker 容器包含状态（数据库文件）。我们可以再次启动之前运行的容器（使用 `docker start`）。当使用 `docker
    run` 时，我们会重新开始，并且不会使用之前的状态。使用 `docker commit`，您可以从容器创建一个新的镜像。这样，数据库和状态就在一起了，Docker
    镜像的大小也会增长。更好的做法是将状态保存在 Docker 容器之外。您可以在容器内挂载外部目录、文件和 Docker 卷。Docker 卷完全由 Docker
    管理。让我们用这个来为 SQL Server 使用。
- en: 'First, create a volume:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个卷：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This creates a volume with the name `gamessqlstorage`. To check the volumes
    available, use `docker volume ls`. To get more information about a volume, execute
    `docker` `volume inspect`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `gamessqlstorage` 的卷。要检查可用的卷，请使用 `docker volume ls`。要获取有关卷的更多信息，请执行
    `docker volume inspect`。
- en: 'Let’s run the container with the database using this volume:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个卷运行带有数据库的容器：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-v` option mounts the `/var/opt/mssql` folder within the container to the
    `gamessqlstorage` volume. All data written by SQL Server to this folder now goes
    into this volume. The state is now kept externally from the container. So, let’s
    create a database next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v` 选项将容器内的 `/var/opt/mssql` 文件夹挂载到 `gamessqlstorage` 卷上。现在，SQL Server 写入此文件夹的所有数据现在都进入这个卷。状态现在保存在容器外部。因此，让我们创建一个数据库。'
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When creating backups of the database, you should also use volumes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据库备份时，也应使用卷。
- en: Creating a database in the Docker container
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Docker 容器中创建数据库
- en: 'As the container is running, you can access it with a tool such as **SQL Server
    Object Explorer** from Visual Studio or **SQL Server Management Studio**. The
    connection string you can use is shown in the following .NET configuration file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时，您可以使用 Visual Studio 中的 **SQL Server Object Explorer** 或 **SQL Server Management
    Studio** 等工具访问它。您可以使用以下 .NET 配置文件中的连接字符串：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the `appsettings.json` file, you also need to change the `DataStore` key
    to the `SqlServer` value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `appsettings.json` 文件，您还需要将 `DataStore` 键更改为 `SqlServer` 值。
- en: 'Using Docker with a Linux host system, you can use the IP address of the Docker
    container with the port number to access services within the Docker container.
    This might not work with Windows. That’s why the `host.docker.internal` hostname
    was introduced: to map to the service via a gateway using the local port number.
    With the connection string to the database, you need to add the port number after
    the hostname, separated by a comma. To pass the user and password, use the `user
    id` and `password` keys. Because the certificate from the server Docker container
    might not be from a trusted authority on the Windows system, add the `TrustServerCertificate`
    setting to the connection string.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux 主机系统与 Docker 结合，您可以使用 Docker 容器的 IP 地址和端口号来访问 Docker 容器内的服务。这可能不适用于
    Windows。这就是为什么引入了 `host.docker.internal` 主机名：通过使用本地端口号通过网关映射到服务。在数据库连接字符串中，您需要在主机名后添加端口号，并用逗号分隔。要传递用户名和密码，请使用
    `user id` 和 `password` 键。因为来自 Docker 容器的证书可能不是 Windows 系统上受信任的权威机构颁发的，所以请在连接字符串中添加
    `TrustServerCertificate` 设置。
- en: 'In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we published a database
    using the `dotnet ef` command line. Now is the time to create this database within
    the Docker container. With the following command, your current directory needs
    to be the directory of the games API service (`Codebreaker.GameAPIs`), the `DataStorage`
    configuration value in `appsettings` set to `SqlServer`, and the connection string
    specified as shown before:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B21217_03.xhtml#_idTextAnchor063)中，我们使用`dotnet ef`命令行发布了一个数据库。现在是时候在Docker容器中创建这个数据库了。使用以下命令，您的当前目录需要是游戏API服务（`Codebreaker.GameAPIs`）的目录，`appsettings`中的`DataStorage`配置值设置为`SqlServer`，并且连接字符串指定如前所述：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this, the database is created – or migrated to the latest version. The
    `-p` option is needed because the EF Core context is in a different project than
    the `-c`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，数据库就创建好了——或者迁移到了最新版本。需要`-p`选项，因为EF Core上下文位于与`-c`不同的项目中。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With the games service project, you have another option to create the database.
    For an easier way to create a SQL Server database, the `/createsql` API is offered
    now in addition to the other APIs. Sending a `POST` request creates or upgrades
    the database (if SQL Server is configured) using the EF Core `MigrateAsync` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游戏服务项目，您有另一种创建数据库的选择。为了更方便地创建SQL Server数据库，现在除了其他API之外，还提供了`/createsql` API。发送`POST`请求会创建或升级数据库（如果已配置SQL
    Server），使用EF Core的`MigrateAsync`方法。
- en: 'Next, let’s create a custom Docker image for the games API service. *Figure
    5**.2* shows a C4 container diagram to give you an overview picture of the containers
    we use. The first container we create is the one on the right, hosting SQL Server.
    Next, we create a Docker image for the game APIs, which accesses the SQL Server
    container. The container on the left is the new bot project, which invokes the
    services running in the game APIs’ container to automatically play games:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为游戏API服务创建一个自定义Docker镜像。*图5**.2*显示了C4容器图，为您提供一个我们使用的容器的概览图。我们首先创建的是右侧的容器，托管SQL
    Server。接下来，我们为游戏API创建一个Docker镜像，该镜像访问SQL Server容器。左侧的容器是新的机器人项目，它调用在游戏API容器中运行的服务，以自动玩游戏：
- en: '![Figure 5.2 – C4 container diagram](img/B21217_05_02.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – C4容器图](img/B21217_05_02.jpg)'
- en: Figure 5.2 – C4 container diagram
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – C4容器图
- en: Building a Docker image
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: The .NET CLI `dotnet publish` command supports creating Docker images without
    using a Dockerfile. However, to understand Docker, we need to know about Dockerfiles.
    That’s why we start building a Docker image defining a Dockerfile first.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI的`dotnet publish`命令支持不使用Dockerfile创建Docker镜像。然而，为了理解Docker，我们需要了解Dockerfile。这就是为什么我们首先通过定义Dockerfile来构建Docker镜像。
- en: 'In this section, we will do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将执行以下操作：
- en: Create a Dockerfile for the games API
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏API创建Dockerfile
- en: Build a Docker image using the Dockerfile
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建Docker镜像
- en: Run the games API with a Docker container
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器运行游戏API
- en: Create a Docker image using `dotnet publish`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dotnet publish`创建Docker镜像
- en: Creating a Dockerfile
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Dockerfile
- en: Docker images are created using instructions in Dockerfiles. Using Visual Studio,
    you can easily create a Dockerfile from Solution Explorer, using `Codebreaker.GamesAPI`
    project creates a multi-stage Dockerfile. A multi-stage Dockerfile creates interim
    images for different stages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是通过Dockerfile中的指令创建的。使用Visual Studio，您可以从解决方案资源管理器轻松创建Dockerfile，使用`Codebreaker.GamesAPI`项目创建一个多阶段Dockerfile。多阶段Dockerfile为不同的阶段创建临时镜像。
- en: Base stage
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础阶段
- en: 'With the following code snippets, the different stages are explained. The first
    stage prepares a Docker image for the production environment:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段解释了不同的阶段。第一个阶段为生产环境准备Docker镜像：
- en: Codebreaker.GameAPIs/Dockerfile
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Dockerfile
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Every Dockerfile starts with a `FROM` instruction. The `FROM` instruction defines
    the base image that is used. `mcr.microsoft.com/dotnet/aspnet` is an image optimized
    for production. With .NET 8, this image is based on Debian 12 (Bookworm). The
    `Debian:12-slim` image is defined by a Dockerfile with `FROM scratch`, so this
    is the root of the hierarchy of instructions. The `dotnet/aspnet` image contains
    the .NET runtime and the ASP.NET Core runtime. The .NET SDK is not available with
    this image. The `AS` instruction defines a name that allows using the result of
    this stage with another stage. The `USER` instruction defines the user that should
    be used with the instructions of the stage. The `WORKDIR` instruction sets the
    working directory for following instructions. If the directory does not exist
    in the image, it’s created. The last step in the first stage is the `EXPOSE` instruction.
    With `EXPOSE`, you define the ports that the application is listening to. By default,
    `TCP` is used, but you can also specify to have an `UDP` receiver.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Dockerfile都以`FROM`指令开始。`FROM`指令定义了使用的基镜像。`mcr.microsoft.com/dotnet/aspnet`是一个针对生产优化的镜像。在.NET
    8中，此镜像基于Debian 12（Bookworm）。`Debian:12-slim`镜像由一个包含`FROM scratch`的Dockerfile定义，因此这是指令层次结构的根。`dotnet/aspnet`镜像包含.NET运行时和ASP.NET
    Core运行时。此镜像中不包含.NET SDK。`AS`指令定义了一个名称，允许在另一个阶段中使用此阶段的输出。`USER`指令定义了应与阶段指令一起使用的用户。`WORKDIR`指令设置后续指令的工作目录。如果该目录在镜像中不存在，则将其创建。第一阶段中的最后一步是`EXPOSE`指令。使用`EXPOSE`，您定义应用程序正在监听的端口。默认情况下使用`TCP`，但您也可以指定使用`UDP`接收器。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '.NET 8 has some changes with Docker image generation: the default container
    images run with non-root users (the app user), and the default port is no longer
    port 80\. Port 80 is a privileged port that requires the root user. The new default
    port is now 8080.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8在Docker镜像生成方面有一些变化：默认容器镜像以非root用户（应用程序用户）运行，默认端口不再是80。80是一个特权端口，需要root用户。新的默认端口现在是8080。
- en: Build stage
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建阶段
- en: 'The second stage builds the ASP.NET Core application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段构建ASP.NET Core应用程序：
- en: Codebreaker.GameAPIs/Dockerfile
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Dockerfile
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the second stage, we ignore the first stage for a moment and use a different
    base image: `dotnet/sdk`. This image contains the .NET SDK and is used to build
    the application. First, a `src` directory is created, and the current directory
    is set to `src`. The `ARG` instruction specifies an argument that can be passed
    when invoking building the Docker image. If this argument is not passed, the default
    value is `Release`. Next, you’ll see multiple `COPY` instructions to copy the
    project files to subfolders within the current directory. The project files contain
    the package references. In case the `dotnet restore` command that is started using
    the `RUN` instruction fails, there’s no need to continue with the next steps.
    `dotnet restore` downloads the NuGet packages. In case you use a different NuGet
    feed, the Dockerfile needs some changes to copy `nuget.config` as well. When `dotnet
    restore` succeeds, the complete source code from `.` is copied to the current
    directory (which is `src` at this time) with the `COPY` instruction. Next, the
    working directory is changed to the directory of the games API project, and the
    `dotnet build` command is invoked to create release code for the application.
    With `dotnet build`, the `BUILD_CONFIGURATION` argument is used, which was specified
    with `ARG`. Having the release build in the `src/app/build` folder is the result
    for the interim image after the last command.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段，我们暂时忽略第一阶段，并使用不同的基础镜像：`dotnet/sdk`。这个镜像包含.NET SDK，并用于构建应用程序。首先，创建一个`src`目录，并将当前目录设置为`src`。`ARG`指令指定了在调用构建Docker镜像时可以传递的参数。如果没有传递此参数，则默认值为`Release`。接下来，您将看到多个`COPY`指令，用于将项目文件复制到当前目录下的子文件夹中。项目文件包含包引用。如果在`RUN`指令启动的`dotnet
    restore`命令失败的情况下，无需继续执行下一步。`dotnet restore`下载NuGet包。如果您使用不同的NuGet源，Dockerfile需要一些更改，以复制`nuget.config`文件。当`dotnet
    restore`成功时，使用`COPY`指令将`.`目录下的完整源代码复制到当前目录（此时为`src`）。接下来，将工作目录更改为游戏API项目的目录，并调用`dotnet
    build`命令来为应用程序创建发布代码。使用`dotnet build`时，使用`ARG`指定的`BUILD_CONFIGURATION`参数。在最后一条命令之后，`src/app/build`文件夹中的发布构建是中间镜像的结果。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To make sure that unnecessary files are not copied with instructions such as
    `COPY . .`, the `.dockerignore` file is used. Similar to the `.gitignore` file
    where files are specified to be ignored, with a `.dockerignore` file, you specify
    what files should not be copied to the image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保不会因使用如`COPY . .`之类的指令而复制不必要的文件，使用了`.dockerignore`文件。与指定要忽略的文件的`.gitignore`文件类似，使用`.dockerignore`文件，你可以指定哪些文件不应该被复制到镜像中。
- en: Publish stage
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布阶段
- en: 'Next, the second stage is used as a base for the third stage:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，第二个阶段被用作第三个阶段的基础：
- en: Codebreaker.GameAPIs/Dockerfile
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Dockerfile
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `FROM build` instruction uses the result from the previous stage and continues
    here. The `dotnet publish` command results in code that’s needed to publish the
    application. The files needed for publication are copied to the `/src/app/publish`
    folder. While the working directory was configured with the previous stage, continuing
    on the build image, the working directory is still set.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM build`指令使用前一个阶段的结果并继续此处。`dotnet publish`命令生成发布应用程序所需的代码。需要发布的文件被复制到`/src/app/publish`文件夹。虽然工作目录在之前阶段已配置，但在构建镜像时，工作目录仍然被设置。'
- en: Final stage
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终阶段
- en: 'With the final stage, we continue with the first stage, which was named `base`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最终阶段，我们继续使用第一个阶段，该阶段被命名为`base`：
- en: Codebreaker.GameAPIs/Dockerfile
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Dockerfile
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first instruction with this stage is to set the working directory to `app`.
    Then, referencing the third state with `--from=publish`, the `/app/publish` directory
    from the `publish` stage is copied to the current directory. The `ENTRYPOINT`
    instruction defines what should be done on running the image: the `dotnet bootstrapper`
    command starts and receives `Codebreaker.GameAPIs.dll` as an argument. You can
    do this from the command line as well: `dotnet Codebreaker.GameAPIs.dll` starts
    the entry point of the application to kick off the Kestrel server, and the application
    is available to receive requests.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段的第一条指令是将工作目录设置为`app`。然后，通过使用`--from=publish`引用第三个状态，将`publish`阶段中的`/app/publish`目录复制到当前目录。`ENTRYPOINT`指令定义了在运行镜像时应执行的操作：`dotnet
    bootstrapper`命令启动并接收`Codebreaker.GameAPIs.dll`作为参数。你也可以从命令行执行此操作：`dotnet Codebreaker.GameAPIs.dll`启动应用程序的入口点以启动Kestrel服务器，应用程序可以接收请求。
- en: Before building the Dockerfile, make sure the `DataStore` configuration in `appsettings.json`
    is set to `InMemory` to use the in-memory provider by default when starting the
    container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Dockerfile之前，请确保`appsettings.json`中的`DataStore`配置设置为`InMemory`，以便在启动容器时默认使用内存提供程序。
- en: Building a Docker image with a Dockerfile
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建Docker镜像
- en: 'To build the image, set the current directory to the directory of the solution,
    and use this command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，将当前目录设置为解决方案目录，并使用以下命令：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With simple Dockerfiles, using just `docker build` can be enough to build the
    image. However, the Dockerfile we use contains references to other projects. With
    this, we need to pay attention to the context. With the games API service, multiple
    projects need to be compiled, and the paths used as specified with the Dockerfile
    use the parent directory. Setting the current directory to the directory of the
    solution, the context is set to this directory with the first argument after the
    build command (`.`). The `-f` option next references the location of the Dockerfile.
    With the `-t` option, the image is tagged. The repository name (`codebreaker/gamesapi`)
    needs to be lowercase, followed by the `3.5.3` tag name and the `latest` tag name.
    Tag names can be strings; there’s no requirement on the version. It’s just a good
    practice to always tag the latest version with the `latest` tag. Specifying the
    `-t` option two times, we get two image names that reference the same image with
    the same image identifier.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的Dockerfile，使用`docker build`可能就足够构建镜像。然而，我们使用的Dockerfile包含了其他项目的引用。因此，我们需要注意上下文。对于游戏API服务，需要编译多个项目，并且Dockerfile中指定的路径使用的是父目录。将当前目录设置为解决方案目录，构建命令后的第一个参数（`.`）将上下文设置为该目录。`-f`选项接下来引用Dockerfile的位置。使用`-t`选项对镜像进行标记。仓库名称（`codebreaker/gamesapi`）需要小写，后跟`3.5.3`标签名称和`latest`标签名称。标签名称可以是字符串；没有对版本的要求。只是良好的实践，始终使用`latest`标签标记最新版本。指定`-t`选项两次，我们得到两个引用相同镜像且具有相同镜像标识符的镜像名称。
- en: 'To list the images built, use `docker images`. To restrict the output to `codebreaker`
    images, you can define a filter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出构建的镜像，使用`docker images`。要限制输出为`codebreaker`镜像，你可以定义一个过滤器：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To check a Docker image for how it was built, we can use the `docker` `history`
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查Docker镜像的构建方式，我们可以使用 `docker` 的 `history` 命令：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Figure 5**.3* shows the result of the `docker history` command. This shows
    every instruction from the Dockerfile that was used to build the image. Of course,
    what you don’t see with the `codebreaker/gamesapi` image is the `dotnet build`
    and `dotnet restore` commands. The `build` and `publish` stages have only been
    used for interim images to build the application and to create the files needed.
    Comparing the output to the Dockerfile we created, you see `ENTRYPOINT` on top,
    followed by `COPY`, `WORKDIR`, and so on. With each of these instructions, you
    can also see the size result of the instruction. The `COPY` command copied 3,441
    MB into the image. The `USER` instruction was the first instruction coming from
    our Dockerfile; the instructions before that (in the lines below the `USER` instruction)
    show the instructions when the base image was created:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3* 展示了 `docker history` 命令的结果。这显示了用于构建镜像的Dockerfile中的每条指令。当然，您在 `codebreaker/gamesapi`
    镜像中看不到的是 `dotnet build` 和 `dotnet restore` 命令。`build` 和 `publish` 阶段仅用于构建应用程序和创建所需文件的临时镜像。将输出与创建的Dockerfile进行比较，您会看到最上面是
    `ENTRYPOINT`，然后是 `COPY`、`WORKDIR` 等等。对于这些指令中的每一个，您还可以看到指令的大小结果。`COPY` 命令将 3,441
    MB 复制到镜像中。`USER` 指令是我们Dockerfile中的第一条指令；在 `USER` 指令之前的指令（在 `USER` 指令下面的行）显示了在创建基础镜像时的指令：'
- en: '![Figure 5.3 – Result of docker history command](img/B21217_05_03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – `docker history` 命令的结果](img/B21217_05_03.jpg)'
- en: Figure 5.3 – Result of docker history command
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – `docker history` 命令的结果
- en: 'To see the exposed ports, environmental variables, the entry point, and more
    of an image, use the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看镜像的暴露端口、环境变量、入口点等信息，请使用以下命令：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result is presented in JSON information and shows information such as exposed
    ports, environment variables, the entry point, the operating system, and the architecture
    this image is based on. When running the image, it helps to know what port number
    needs to be mapped and which environment variables could be useful to override.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以JSON信息的形式呈现，显示了诸如暴露端口、环境变量、入口点、操作系统以及此镜像基于的架构等信息。在运行镜像时，了解需要映射哪个端口号以及哪些环境变量可能很有用。
- en: Running the games API using Docker
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker运行游戏API
- en: 'You can start the Docker image of the games API service with the following
    command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令启动游戏API服务的Docker镜像：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you can check the log output using `docker logs <container-id>` (get
    the ID of the running container with `docker ps`). You can interact with the games
    service using any client using the following HTTP address: `http://localhost:8080`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `docker logs <container-id>`（使用 `docker ps` 获取运行容器的ID）检查日志输出。您可以使用以下HTTP地址使用任何客户端与游戏服务交互：`http://localhost:8080`。
- en: 'With the default configuration of the data store, games are just stored in
    memory. To change this, we need to do the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据存储的默认配置下，游戏仅存储在内存中。要更改此设置，我们需要执行以下操作：
- en: Configure a network to let multiple Docker containers directly communicate
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置网络以允许多个Docker容器直接通信
- en: Start the Docker container for the SQL Server instance
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动SQL Server实例的Docker容器
- en: Pass configuration values to the Docker container for the games API to use the
    SQL Server instance
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将配置值传递给Docker容器，以便游戏API使用SQL Server实例
- en: Configuring a network for Docker containers
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Docker容器配置网络
- en: 'To let containers communicate with each other, we create a network:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要让容器之间相互通信，我们创建一个网络：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Docker supports multiple network types, which can be set using the `--driver`
    option. The default is a `docker network ls` to show all networks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持多种网络类型，可以使用 `--driver` 选项进行设置。默认情况下，使用 `docker network ls` 显示所有网络。
- en: Starting the Docker container with SQL Server
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以SQL Server启动Docker容器
- en: 'To start the Docker container for SQL Server where the database already exists,
    you can either use the Docker image we committed or access the state of the previous
    running container. Here, we do the latter, where we define the name `sql1` as
    the name of the container:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动已存在数据库的SQL Server Docker容器，您可以使用我们提交的Docker镜像或访问先前运行容器的状态。在这里，我们后者，我们定义名称
    `sql1` 作为容器的名称：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Use `docker ps` to check for the running container and see the port mapping
    as it was defined earlier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker ps` 检查正在运行的容器，并查看之前定义的端口映射。
- en: 'Using the command adds the running container to the `codebreakernet` network:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令将运行中的容器添加到 `codebreakernet` 网络中：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Starting the Docker container with the games API
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用游戏API启动Docker容器
- en: 'Now, we need to start the games API but override the configuration values.
    This can be done by setting environmental variables. Passing environmental variables
    at the start of a Docker container can not only be done by setting the `-e` option
    but also by using `--env-file` and passing a file with environmental variables.
    This is the content of the `gameapis.env` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要启动游戏API，但覆盖配置值。这可以通过设置环境变量来完成。在Docker容器启动时传递环境变量不仅可以通过设置`-e`选项来完成，还可以使用`--env-file`并传递包含环境变量的文件。这是`gameapis.env`文件的内容：
- en: gameapis.env
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: gameapis.env
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating the DI container of the application with the default container registers
    multiple configuration providers. A provider that uses environmental variables
    wins against the JSON file providers because of the order the providers are configured
    with the `WebApplicationBuilder` class (or the `Host` class). The `DataStore`
    key is used to select the storage provider. `GamesSqlServerConnection` is a key
    within the hierarchy of `ConnectionStrings`. Using command-line arguments to pass
    configuration values, you can specify a hierarchy of configuration values using
    `:` as a separator; for example, pass `ConnectionStrings:GamesSqlServerConnection`.
    Using `:` does not work everywhere; for example, with environmental variables
    on Linux. Using `__` translates to this hierarchy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认容器注册创建应用程序的DI容器会注册多个配置提供程序。由于`WebApplicationBuilder`类（或`Host`类）配置提供程序的顺序，使用环境变量的提供程序会战胜JSON文件提供程序。使用`DataStore`键来选择存储提供程序。`GamesSqlServerConnection`是`ConnectionStrings`层次结构中的一个键。使用命令行参数传递配置值时，您可以使用`:`作为分隔符来指定配置值的层次结构；例如，传递`ConnectionStrings:GamesSqlServerConnection`。使用`:`在所有地方都不起作用；例如，在Linux上的环境变量中。使用`__`转换为这个层次结构。
- en: With the environment variables file, the connection to the SQL Server Docker
    container is using the hostname of the Docker container and the port that is used
    by SQL Server. Being in the same network, the containers can communicate directly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量文件，连接到SQL Server Docker容器时使用Docker容器的主机名和SQL Server使用的端口。由于在同一个网络中，容器可以直接通信。
- en: 'Starting the container, the environmental variables file is passed using `--env-file`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器时，使用`--env-file`传递环境变量文件：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In case you get an error that the container name is already in use, you can
    stop running containers with `docker container stop <containername>`. To remove
    the state of the container, you can use `docker container rm <containername>`
    or the `docker rm <containername>` shorthand notation. To delete the state of
    all stopped containers, use `docker container prune`. When starting a new container
    with `dotnet run`, you can also add the `--rm` option to remove a container after
    exit.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到容器名称已被使用的错误，您可以使用`docker container stop <containername>`停止正在运行的容器。要删除容器的状态，您可以使用`docker
    container rm <containername>`或`docker rm <containername>`简写形式。要删除所有已停止容器的状态，请使用`docker
    container prune`。当使用`dotnet run`启动新容器时，您还可以添加`--rm`选项，以便在退出后删除容器。
- en: Specifying the name of the `gamesapi` container, the container is added to the
    `codebreakernet` network. Now, we have two containers running communicating with
    each other, and can play games using the games service.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`gamesapi`容器的名称，容器被添加到`codebreakernet`网络中。现在，我们有两个容器正在运行并相互通信，可以使用游戏服务来玩游戏。
- en: Let’s create another Docker image, but this time without using a Dockerfile.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个Docker镜像，但这次不使用Dockerfile。
- en: Building a Docker image using dotnet publish
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用dotnet publish构建Docker镜像
- en: In this chapter, we use multiple containers running at the same time. A project
    we didn’t use in previous chapters is `Codebreaker.Bot`. This project offers an
    API and is also a client to the games service – to automatically play games in
    the background after requested by some API calls. In this section, we’ll build
    a Docker image for this project – but without creating a Dockerfile first.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用多个同时运行的容器。在之前的章节中没有使用的一个项目是`Codebreaker.Bot`。该项目提供了一个API，也是游戏服务的客户端——在API调用请求后自动在后台玩游戏。在本节中，我们将为该项目构建一个Docker镜像——但首先不创建Dockerfile。
- en: Since .NET 7, the `dotnet publish` command directly supports creating Docker
    images without a Dockerfile. Using the `docker build` command, we had to pay attention
    to some specific .NET behaviors, such as the need to compile multiple projects.
    With this, it was necessary to specify the context when building the image. The
    .NET CLI knows about the solutions and project structure. The .NET CLI also knows
    about the default Docker base images that are used to build an application with
    ASP.NET Core.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自 .NET 7 以来，`dotnet publish` 命令直接支持创建 Docker 镜像，无需 Dockerfile。使用 `docker build`
    命令时，我们必须注意一些特定的 .NET 行为，例如需要编译多个项目。因此，在构建镜像时需要指定上下文。.NET CLI 了解解决方案和项目结构。.NET
    CLI 还了解用于构建 ASP.NET Core 应用程序的默认 Docker 基础镜像。
- en: 'Options to configure the generation can be specified in the project file and
    using the parameters of `dotnet publish`. Here are some of the configurations
    specified in the project file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在项目文件中指定配置生成选项，并使用 `dotnet publish` 的参数。以下是项目文件中指定的一些配置：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`ContainerImageTags` and `ContainerPort` are just two of the elements that
    are used by `dotnet publish`. You can change the base image with `ContainerBaseImage`,
    specify container runtime identifiers (`ContainerRuntimeIdentifier`), name the
    registry (`ContainerRegistry`), define environmental variables, and more. See
    [https://learn.microsoft.com//dotnet/core/docker/publish-as-container](https://learn.microsoft.com//dotnet/core/docker/publish-as-container)
    for details.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContainerImageTags` 和 `ContainerPort` 是 `dotnet publish` 使用的元素中的两个。您可以使用 `ContainerBaseImage`
    更改基础镜像，指定容器运行时标识符 (`ContainerRuntimeIdentifier`)，命名注册表 (`ContainerRegistry`)，定义环境变量等。有关详细信息，请参阅
    [https://learn.microsoft.com//dotnet/core/docker/publish-as-container](https://learn.microsoft.com//dotnet/core/docker/publish-as-container)。'
- en: 'With `dotnet publish`, the name of the repository is specified:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet publish`，指定存储库的名称：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The bot API service communicates with the games service, and the games service
    uses a container running SQL Server. Now, we already have three Docker containers
    collaborating. The games API needs a connection to the database, and the bot needs
    a link to the games API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人 API 服务与游戏服务进行通信，游戏服务使用运行 SQL Server 的容器。现在，我们已经有三个 Docker 容器协同工作。游戏 API
    需要连接到数据库，机器人需要连接到游戏 API。
- en: Running the solution with .NET Aspire
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire 运行解决方案
- en: In [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031), we added .NET Aspire to
    the solution, which contained only the games API service. In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063),
    we added a SQL Server database running in a Docker container without keeping state.
    Here, we’ll extend the .NET Aspire configuration by using SQL Server running in
    a Docker container using a volume and configure the bot service to access the
    games API.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B21217_02.xhtml#_idTextAnchor031) 中，我们将 .NET Aspire 添加到只包含游戏 API
    服务的解决方案中。在 [*第 3 章*](B21217_03.xhtml#_idTextAnchor063) 中，我们添加了一个运行在 Docker 容器中的
    SQL Server 数据库，没有保留状态。在这里，我们将通过使用在 Docker 容器中运行的 SQL Server 来扩展 .NET Aspire 配置，并配置机器人服务以访问游戏
    API。
- en: Configuring a Docker container for SQL Server
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 SQL Server 的 Docker 容器
- en: 'Using a Docker container with .NET Aspire can be orchestrated using .NET code
    – with extension methods of the `IDistributedApplication` interface:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire 的 Docker 容器可以通过 .NET 代码进行编排 – 使用 `IDistributedApplication` 接口的扩展方法：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `AddSqlServer` method adds SQL Server as a .NET Aspire resource to the app
    model. On the developer system, a Docker container is used to run SQL Server.
    When we created the container before in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063),
    we assigned a password using the default password configuration. Here we explicitly
    create an app model parameter using the `AddParameter` method. With this, parameters
    are retrieved from the Parameters configuration section. Thus, the parameter named
    `SqlConfiguration` is retrieved from `Paramters:SqlConfiguration`. This parameter
    resource is passed with the second parameter of `AddSqlServer`. If the password
    is not assigned, and a parameter named with the resource (sql) postfixed with
    -password does not exist, a random password is created. This is great if no volume
    mounts are used, and the database is created newly every time the container starts
    up. Using a persistent volume, the same password needs to be used with every run
    of the container. This is done by supplying the password configuration. The password
    is needed with the database connection string to access the database.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSqlServer` 方法将 SQL Server 添加为 .NET Aspire 资源到应用模型。在开发系统上，使用 Docker 容器来运行
    SQL Server。在我们之前在 [*第 3 章*](B21217_03.xhtml#_idTextAnchor063) 中创建容器时，我们使用默认密码配置分配了一个密码。在这里，我们使用
    `AddParameter` 方法显式创建一个应用模型参数。有了这个，参数就从“参数”配置部分检索。因此，从 `Parameters:SqlConfiguration`
    检索名为 `SqlConfiguration` 的参数。此参数资源通过 `AddSqlServer` 的第二个参数传递。如果没有分配密码，并且不存在以资源（sql）后缀为
    -password 命名的参数，则会创建一个随机密码。如果没有使用卷挂载，并且每次容器启动时都创建新的数据库，这将非常棒。使用持久卷，每次运行容器时都需要使用相同的密码。这是通过提供密码配置来完成的。访问数据库需要数据库连接字符串，因此需要密码。'
- en: The `WithDataVolume` method defines the use of a Docker volume for the SQL Server
    container. Within the container, the database is stored within the `/var/opt/mssql`
    folder. Remember – without using a volume, the database is stored within the container
    itself, and the state is not kept when running a new container instance. While
    invoking `WithDataVolume`, there's no need to know what directories of the container
    need to mapped. This is known by the WithDataVolume method. We just pass the optional
    name of the volume, and if the volume should be read-only. With this volume, the
    database files are written to, thus it’s not read-only. In [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263),
    when adding Grafana and Prometheus Docker containers, we’ll use read-only mounts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithDataVolume` 方法定义了 SQL Server 容器使用 Docker 卷。在容器内部，数据库存储在 `/var/opt/mssql`
    文件夹中。记住——不使用卷时，数据库存储在容器本身中，并且当运行新的容器实例时不会保留状态。在调用 `WithDataVolume` 时，无需知道需要映射容器的哪些目录。这是由
    `WithDataVolume` 方法知道的。我们只需传递卷的可选名称，以及卷是否应该是只读的。使用此卷，数据库文件将被写入，因此它不是只读的。在 [*第
    11 章*](B21217_11.xhtml#_idTextAnchor263) 中，当添加 Grafana 和 Prometheus Docker 容器时，我们将使用只读挂载。'
- en: The `AddDatabase` method adds the SQL Server database as a child resource to
    SQL Server. The name passed here defines the name of the resource and the name
    of the database.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDatabase` 方法将 SQL Server 数据库添加为 SQL Server 的子资源。这里传递的名称定义了资源的名称和数据库的名称。'
- en: So that .NET Aspire adds implicit service discovery, the database is referenced
    from the game APIs project using the `WithReference` method. With this, the `CodebreakerSql`
    database name can be used to reference the connection string.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 .NET Aspire 添加隐式服务发现，数据库通过 `WithReference` 方法从游戏 API 项目引用。有了这个，可以使用 `CodebreakerSql`
    数据库名称来引用连接字符串。
- en: 'Using the `AddSqlServer` method, there’s no need to know the Docker image name
    for SQL Server or the environment variables that need to be specified, as we’ve
    done this earlier using the SQL Server Docker image. All this is done within the
    implementation of this method. To see how any Docker image can be added to the
    .NET Aspire app model, let’s look at the implementation of this method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddSqlServer` 方法，无需知道 SQL Server 的 Docker 镜像名称或需要指定的环境变量，因为我们之前已经使用 SQL
    Server Docker 镜像完成了这些操作。所有这些都在此方法的实现中完成。要了解如何将任何 Docker 镜像添加到 .NET Aspire 应用模型中，让我们看看此方法的实现：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this code, an endpoint is defined to map a passed port number to the port
    number `1433` that is used by SQL Server running in the container; the container
    registry, image name, and tag values are specified, and environment variables
    are created to accept the `AddSqlServer` method. Using .NET Aspire, we don’t need
    to know this with available components.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，定义了一个端点，将传递的端口号映射到容器中运行的 SQL Server 使用的端口号 `1433`；指定了容器注册表、镜像名称和标签值，并创建了环境变量以接受
    `AddSqlServer` 方法。使用 .NET Aspire，我们不需要知道这些信息，因为已有可用组件。
- en: 'Before starting the application, make sure to set configuration via a user
    secret to store the password for SQL Server within the `Codebreaker.AppHost` project;
    for example, using the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，请确保通过用户密钥设置配置，以在 `Codebreaker.AppHost` 项目中存储 SQL Server 的密码；例如，使用以下命令：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we have to configure the .NET Aspire SQL Server component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须配置 .NET Aspire SQL Server 组件。
- en: Configuring the .NET Aspire SQL Server component
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 .NET Aspire SQL Server 组件
- en: 'With the games API, the EF Core context is configured with the DI container
    using the .NET Aspire SQL Server EF Core component:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏 API，使用 .NET Aspire SQL Server EF Core 组件通过 DI 容器配置 EF Core 上下文：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first part of the configuration is just the usual .NET EF Core configuration
    to specify the EF Core database provider and the connection string. Just make
    sure to use the connection string key that was used with the app model definition.
    The connection string is forwarded from the `AppHost` project to the games API
    service. The parameter with the value `CodebreakerSql` matches the name of the
    database that has been configured with the app model. Using .NET Aspire orchestration
    (which uses `Microsoft.Extensions.ServiceDiscovery`) gets the connection string
    with this name from the orchestrator configuration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的第一部分只是通常的 .NET EF Core 配置，用于指定 EF Core 数据库提供者和连接字符串。只需确保使用与应用程序模型定义一起使用的连接字符串密钥。连接字符串从
    `AppHost` 项目转发到游戏 API 服务。值为 `CodebreakerSql` 的参数与已通过应用程序模型配置的数据库名称相匹配。使用 .NET
    Aspire 协调器（使用 `Microsoft.Extensions.ServiceDiscovery`）从协调器配置中获取具有此名称的连接字符串。
- en: The `EnrichSqlServerDbContext` method adds .NET Aspire configuration for retries,
    logging, and metrics.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnrichSqlServerDbContext` 方法添加了 .NET Aspire 的重试、日志和指标配置。'
- en: With this, the games API service with the database configuration is in place.
    Next, add interaction between the bot service and the games API service.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，带有数据库配置的游戏 API 服务就设置好了。接下来，添加机器人服务和游戏 API 服务之间的交互。
- en: Configuring interaction with multiple services
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置与多个服务的交互
- en: 'Both the games API service and the bot service are configured by adding a project
    to the distributed application:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向分布式应用程序中添加一个项目来配置游戏 API 服务和机器人服务：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The SQL Server Docker container was added using the `AddSqlServer` method. All
    .NET projects that should be orchestrated with .NET Aspire need to be added using
    the `AddProject` method. The class definition for the project is created from
    a source generator when adding a project reference to the `AppHost` project. Adding
    a reference to the `Codebreaker.Bot` project created a class named `Codebreaker_Bot`.
    All project classes are defined within the `Projects` namespace.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddSqlServer` 方法添加了 SQL Server Docker 容器。所有应该使用 .NET Aspire 协调的项目都需要使用 `AddProject`
    方法添加。当将项目引用添加到 `AppHost` 项目时，会从源生成器创建项目类定义。将 `Codebreaker.Bot` 项目的引用添加后，创建了一个名为
    `Codebreaker_Bot` 的类。所有项目类都定义在 `Projects` 命名空间内。
- en: The bot service needs a reference to the games API, thus the `WithReference`
    method is used to generate implicit service discovery. The bot can use the name
    `http://gameapis` to reference the games API service.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人服务需要引用游戏 API，因此使用 `WithReference` 方法生成隐式服务发现。机器人可以使用 `http://gameapis` 名称来引用游戏
    API 服务。
- en: 'The configuration to retrieve the link to the games API is configured with
    the `HttpClient` configuration:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HttpClient` 配置配置检索游戏 API 链接的配置：
- en: Codebreaker.Bot/ApplicationServices.cs
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Bot/ApplicationServices.cs
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `BaseAddress` of `HttpClient` is configured with the name of the games API,
    as defined with the `gameapis` orchestration configuration – prefixed with `http://`.
    There’s no need to specify .NET configuration to configure the link.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 的 `BaseAddress` 配置为游戏 API 的名称，如 `gameapis` 协调器配置中定义的，前面加上 `http://`。无需指定
    .NET 配置来配置链接。'
- en: With just these few updates in place, we can start the `Codebreaker.AppHost`
    project in the next step.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过这些少数更新，我们就可以在下一步开始 `Codebreaker.AppHost` 项目。
- en: Running the solution with .NET Aspire
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire 运行解决方案
- en: 'Using `dotnet run` to build and run the `Codebreaker.AppHost` project starts
    up the Docker container for SQL Server, the games API, the bot service, and the
    .NET Aspire dashboard. *Figure 5**.4* shows all started resources in the .NET
    Aspire dashboard. From here, you can see if services started successfully and
    access configured environment variables for services, logs, as well as accessible
    endpoints:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 构建并运行 `Codebreaker.AppHost` 项目启动 SQL Server 的 Docker 容器、游戏 API、机器人服务和
    .NET Aspire 仪表板。*图 5.4* 显示了 .NET Aspire 仪表板中所有启动的资源。从这里，你可以看到服务是否成功启动，以及访问为服务、日志以及可访问端点配置的环境变量：
- en: '![Figure 5.4 – .NET Aspire resources in the dashboard](img/B21217_05_04.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 仪表板中的 .NET Aspire 资源](img/B21217_05_04.jpg)'
- en: Figure 5.4 – .NET Aspire resources in the dashboard
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 仪表板中的 .NET Aspire 资源
- en: With resources, make sure to open the **Details** column to see the environment
    variables configured. When checking logs with the SQL Server Docker container,
    you can see issues when using an invalid password – for example, a password that
    doesn’t fulfill the requirements or a password that doesn’t match the volume that
    was initially set.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资源时，请确保打开 **详细信息** 列以查看配置的环境变量。当使用 SQL Server Docker 容器检查日志时，你可以看到使用无效密码时的问题
    – 例如，不符合要求的密码或与最初设置的卷不匹配的密码。
- en: 'Clicking on the endpoint of the bot to show the OpenAPI test page, you can
    start multiple game runs, as shown in *Figure 5**.5*. Specify the number of games
    the bot should play in a sequence, the delay time between the games, and the delay
    time with every move, and click the **Execute** button:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 点击机器人端点以显示 OpenAPI 测试页面，你可以启动多个游戏运行，如图 5.5 所示。指定机器人应按顺序玩的游戏数量、游戏之间的延迟时间和每次移动的延迟时间，然后点击
    **执行** 按钮：
- en: '![Figure 5.5 – OpenAPI test page for the bot service](img/B21217_05_05.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 机器人服务的 OpenAPI 测试页面](img/B21217_05_05.jpg)'
- en: Figure 5.5 – OpenAPI test page for the bot service
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 机器人服务的 OpenAPI 测试页面
- en: 'With the logs of the bot service, you can monitor live information about games
    played by the bot. With every move set, the bot logs information about how good
    the result from the move was and how many possible options are remaining to find
    the solution:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过机器人服务的日志，你可以监控机器人所玩游戏的实时信息。每当设置一个移动组合时，机器人会记录关于移动结果的好坏以及找到解决方案剩余的可能选项数量：
- en: '![Figure 5.6 – Structured logging of the bot service](img/B21217_05_06.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 机器人服务的结构化日志](img/B21217_05_06.jpg)'
- en: Figure 5.6 – Structured logging of the bot service
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 机器人服务的结构化日志
- en: After the services are running, you can also access the games API service, see
    the games played today, and use the client created in the previous chapter to
    play some games. Monitor the running Docker container using the Docker CLI, and
    also check the volume created.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务运行后，你还可以访问游戏 API 服务，查看今天玩的游戏，并使用上一章创建的客户端玩一些游戏。使用 Docker CLI 监控正在运行的 Docker
    容器，并检查创建的卷。
- en: Let’s get into an exciting feature with .NET 8 – native AOT – next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 .NET 8 的一个令人兴奋的功能 – 原生 AOT – 下一步。
- en: Using native AOT with ASP.NET Core
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 的原生 AOT
- en: Comparing Docker images with VM images, Docker images are a lot smaller as they
    don’t need to contain the operating system. With ASP.NET Core applications, the
    Docker image contains the application – and the .NET runtime. Over the last years,
    images have become smaller because more and more optimization has been done. Having
    smaller images means faster startup of the application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 Docker 镜像和虚拟机镜像，Docker 镜像要小得多，因为它们不需要包含操作系统。对于 ASP.NET Core 应用程序，Docker 镜像包含应用程序
    – 以及 .NET 运行时。在过去几年中，镜像变得越来越小，因为进行了越来越多的优化。拥有更小的镜像意味着应用程序启动速度更快。
- en: Since .NET 7, it’s possible to create native applications with C# using **native
    AOT**. With this, many changes are required with .NET. With .NET 7, the native
    AOT functionality was very limited. With .NET 8, we can already create ASP.NET
    Core services, which results in faster startup and less memory footprint.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 .NET 7 以来，使用 C# 创建原生应用程序成为可能，使用 **原生 AOT**。因此，需要对 .NET 进行许多更改。在 .NET 7 中，原生
    AOT 功能非常有限。在 .NET 8 中，我们已可以创建 ASP.NET Core 服务，这导致启动速度更快，内存占用更少。
- en: Using native AOT, an AOT compiler is used to compile `dotnet publish`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生 AOT，使用 AOT 编译器来编译 `dotnet publish`。
- en: 'Not all applications can be changed to use native AOT: libraries cannot be
    dynamically loaded, runtime code generation is not possible… With native AOT,
    the code is trimmed, and all libraries need to be native AOT compatible. With
    .NET 8, EF Core is not part of the libraries supporting native AOT. It’s on the
    roadmap, and partial support is planned with EF Core 9.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有应用程序都可以更改为使用本地 AOT：库不能动态加载，运行时代码生成不可行……使用本地 AOT，代码被精简，所有库都需要与本地 AOT 兼容。使用
    .NET 8，EF Core 不是支持本地 AOT 的库之一。它位于路线图上，并计划在 EF Core 9 中提供部分支持。
- en: By creating a solution based on microservices, it’s possible to differentiate
    technologies with different services. What are the most used services where native
    AOT can give improvements?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建基于微服务的解决方案，可以区分具有不同服务的不同技术。哪些是最常用的服务，其中本地 AOT 可以提供改进？
- en: With the `codebreaker` solution, the games service can be enhanced with faster
    startup and less memory footprint. This is the most important service of the solution
    where the users should have a fast response at every point in time. However, with
    the lack of support in EF Core, using .NET 8, this is only possible with the in-memory
    games provider.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `codebreaker` 解决方案中，游戏服务可以通过更快的启动和更小的内存占用得到增强。这是解决方案中最重要的服务，用户应该在任何时间点都应获得快速响应。然而，由于
    EF Core 的支持不足，使用 .NET 8，这仅适用于内存中的游戏提供程序。
- en: 'To create an API project to support native AOT, a template is available:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建支持本地 AOT 的 API 项目，有一个模板可用：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The most important difference with this project generated is the `<PublishAot>true</PublishAot>`
    setting in the project file. With this, using `dotnet publish` compiles the application
    to native platform-specific code. Because the compiler needs more time to compile
    native code, during development time, IL code is still generated, and the .NET
    runtime is used. As help during development to build native code, analyzers run
    and give compiler errors and warnings if code might not be compatible with native
    AOT.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与此项目生成的最重要的区别是项目文件中的 `<PublishAot>true</PublishAot>` 设置。有了这个设置，使用 `dotnet publish`
    编译应用程序为本地平台特定代码。因为编译器需要更多时间来编译本地代码，所以在开发时间，仍然生成 IL 代码，并使用 .NET 运行时。作为开发期间构建本地代码的帮助，分析器会运行，并在代码可能不兼容本地
    AOT 时提供编译错误和警告。
- en: With the `Codebreaker.GameAPIs.NativeAOT` project, you can start copying the
    code from the `Codebreaker.GameAPIs` project, but some changes are required. We’ll
    focus on the changes needed for native AOT here.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Codebreaker.GameAPIs.NativeAOT` 项目，你可以开始从 `Codebreaker.GameAPIs` 项目复制代码，但需要进行一些更改。我们将重点关注本地区域
    AOT 所需的更改。
- en: OpenAPI document generation is removed – including methods to enhance OpenAPI
    documentation. This feature makes use of reflection and dynamic code generation,
    which is not supported. The EF Core SQL Server and Cosmos providers are removed
    from this project as well. Instead, the project only uses the in-memory games
    repository.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 文档生成功能已被移除 - 包括增强 OpenAPI 文档的方法。此功能利用反射和动态代码生成，但不受支持。EF Core SQL Server
    和 Cosmos 提供程序也从此项目中移除。相反，该项目仅使用内存中的游戏存储库。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: .NET 7 included an extremely limited functionality for native AOT. .NET 8 brings
    many more features, but many libraries are not supported yet. With .NET 8, you
    can’t use ASP.NET Core controllers, OpenAPI documentation is not available, the
    authentication library cannot be used, and most EF Core providers don’t support
    native AOT. Over time, more features will be added to support native AOT.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 7 包含了非常有限的本地 AOT 功能。.NET 8 带来了更多功能，但许多库尚不支持。使用 .NET 8，你不能使用 ASP.NET Core
    控制器，OpenAPI 文档不可用，认证库无法使用，并且大多数 EF Core 提供程序不支持本地 AOT。随着时间的推移，将添加更多功能以支持本地 AOT。
- en: Native AOT doesn’t allow the creation of code dynamically at runtime. Here,
    source generators are of big use. Instead of using reflection emit to create code
    at runtime, with source generators, code is created at compile time. This is not
    only an advantage with native AOT; even without using native AOT, source generators
    can improve the runtime performance.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 AOT 不允许在运行时动态创建代码。在这里，源生成器非常有用。与使用反射发射在运行时创建代码不同，使用源生成器，代码是在编译时创建的。这不仅对本地
    AOT 有优势；即使不使用本地 AOT，源生成器也可以提高运行时性能。
- en: Using the slim builder
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用精简构建器
- en: 'Native AOT services make use of a slim application builder, as shown in the
    following code snippet:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 AOT 服务使用了一个精简的应用程序构建器，如下面的代码片段所示：
- en: Codebreaker.GameAPIs.NativeAOT/Program.cs
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.NativeAOT/Program.cs
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Contrary to the default builder, the number of services registered with the
    DI container is reduced. Logging is reduced as well. The only logging provider
    that is configured with the slim builder is the simple console logging provider.
    In case more functionality is needed, additional services can be added. To reduce
    the number of registered services even further, the `CreateEmptyBuilder` method
    can be used.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认构建器不同，DI 容器中注册的服务数量减少了。日志记录也减少了。仅配置了精简构建器的简单控制台日志提供程序。如果需要更多功能，可以添加额外的服务。为了进一步减少注册的服务数量，可以使用
    `CreateEmptyBuilder` 方法。
- en: Using the JSON serializer source generator
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON 序列化器源生成器
- en: 'The use of the `System.Text.Json` serializer needs to be changed to use a source
    generator. Without a source generator, the serializer uses reflection and creates
    code at runtime. This is not supported with native AOT. To generate code at compile
    time, source generators are used. To use the `System.Text.Json` source generator,
    the `AppJsonSerializerContext` class is added:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将 `System.Text.Json` 序列化器的使用方式更改为使用源生成器。如果没有源生成器，序列化器将使用反射并在运行时创建代码。这不支持原生
    AOT。为了在编译时生成代码，使用源生成器。要使用 `System.Text.Json` 源生成器，添加 `AppJsonSerializerContext`
    类：
- en: Codebreaker.GameAPIs.NativeAOT/Program.cs
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.NativeAOT/Program.cs
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The class is declared partial to allow the source generator to create additional
    sources to extend the class with additional members. For every type that’s serialized
    with JSON, the `JsonSerializable` attribute is added.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该类被声明为部分类，以允许源生成器创建额外的源，以扩展类并添加额外的成员。对于每个使用 JSON 序列化的类型，都会添加 `JsonSerializable`
    属性。
- en: 'This class is used with the DI configuration of the JSON serialization:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此类与 JSON 序列化的 DI 配置一起使用：
- en: Codebreaker.GameAPIs.NativeAOT/Program.cs
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.NativeAOT/Program.cs
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this code, the default instance of the context class is added to the type
    resolvers of the `System.Text.Json` serializer.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，将上下文类的默认实例添加到 `System.Text.Json` 序列化器的类型解析器中。
- en: Building for Windows
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Windows 版本
- en: 'After removing the code for the OpenAPI, removing SQL Server and Cosmos library
    references, and adding the `PublishAot` element to the project file, after a successful
    build, `dotnet publish` can be used to create a native application. This is the
    command to create a native image for Windows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除 OpenAPI 代码、SQL Server 和 Cosmos 库引用，并将 `PublishAot` 元素添加到项目文件后，在成功构建之后，可以使用
    `dotnet publish` 创建原生应用程序。这是创建 Windows 原生镜像的命令：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using `dotnet publish` with the `win-x64` runtime identifier starts the native
    compiler and writes the binary to the `pubwin` directory. The code is trimmed
    to remove not-used types and members from the binary. As a result, you receive
    a trimmed native executable that doesn’t need to have the .NET runtime installed
    on the target system. Starting the application, you can use any client to play
    games with the in-memory provider.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet publish` 并指定 `win-x64` 运行时标识符将启动原生编译器并将二进制文件写入 `pubwin` 目录。代码被精简以从二进制文件中删除未使用的类型和成员。结果，你将收到一个精简的原生可执行文件，不需要在目标系统上安装
    .NET 运行时。启动应用程序时，可以使用任何客户端与内存提供程序一起玩游戏。
- en: Creating a Linux Docker image
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Linux Docker 镜像
- en: 'This is the new Dockerfile we need for the native AOT games service:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要用于原生 AOT 游戏服务的新的 Dockerfile：
- en: Codebreaker.GameAPIs.NativeAOT/Dockerfile
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.NativeAOT/Dockerfile
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To compile the application to native code, using the same SDK-included base
    image, the `clang` and `zlib1g-dev` dependencies need to be installed with the
    Linux environment. This is done as the first step before copying the project files.
    For production, a different base image is used: `dotnet/runtime-deps`. This is
    the new base image containing native dependencies needed by .NET. This image does
    not include the .NET runtime; instead, it can be used for self-contained applications.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序编译为原生代码，使用相同的 SDK 包含的基础镜像，需要在 Linux 环境中安装 `clang` 和 `zlib1g-dev` 依赖项。这是在复制项目文件之前的第一步。对于生产环境，使用不同的基础镜像：`dotnet/runtime-deps`。这是包含
    .NET 所需原生依赖项的新基础镜像。此镜像不包含 .NET 运行时；相反，它可以用于自包含应用程序。
- en: 'Building the Docker image can be done using the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建 Docker 镜像：
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Running the solution with the native AOT container
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生 AOT 容器运行解决方案
- en: After building the image, you can start the Docker container and use different
    clients (for example, the bot service, the HTTP files, and the client from the
    previous chapter) to test the service. With this, you can also do some performance
    comparisons – but remember that some features have been removed to be native AOT
    compatible.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像之后，你可以启动 Docker 容器，并使用不同的客户端（例如，机器人服务、HTTP 文件和上一章中的客户端）来测试服务。通过这种方式，你还可以进行一些性能比较——但请记住，为了与原生
    AOT 兼容，已经移除了一些功能。
- en: Note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With .NET 8, native AOT is in its early stages. I expect many libraries to be
    updated to support native AOT in time. With a microservices architecture, for
    services that can improve from fast startup times, it can be useful to already
    use native AOT. A native AOT service can make use of gRPC (covered in [*Chapter
    14*](B21217_14.xhtml#_idTextAnchor330), *gRPC for Binary Communication*), and
    the service accessible via gRPC can access the database. In any case, non-AOT
    services can also get improvements from features you’ve seen here, such as the
    slim builder or the JSON serializer source generator.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 中，原生 AOT 处于早期阶段。我预计许多库将及时更新以支持原生 AOT。在微服务架构中，对于可以从快速启动时间中受益的服务，已经使用原生
    AOT 可能是有用的。原生 AOT 服务可以利用 gRPC（在第 14 章中介绍，*二进制通信的 gRPC*），并且通过 gRPC 可访问的服务可以访问数据库。无论如何，非
    AOT 服务也可以从你在这里看到的特性中获得改进，例如精简构建器或 JSON 序列化器源生成器。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the foundation of Docker, pulling, creating, and
    running Docker images. You used containers that store state with volumes running
    databases in Docker containers, passed environmental variables and secrets to
    running Docker containers, and used .NET Aspire to run multiple containers at
    once.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Docker 的基础知识，包括拉取、创建和运行 Docker 镜像。你使用了存储状态的容器，在 Docker 容器中运行数据库，并将环境变量和机密信息传递给正在运行的
    Docker 容器，还使用了 .NET Aspire 来一次性运行多个容器。
- en: Using .NET Aspire, you configured orchestration for multiple services – including
    the configuration of a SQL Server Docker container. Comparing this to the work
    needed with Docker, this was an easy task – but it’s still useful to understand
    the foundations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire，你为多个服务配置了编排，包括 SQL Server Docker 容器的配置。与使用 Docker 所需的工作相比，这是一个简单的任务——但仍然有用了解其基础。
- en: With native AOT, you reduced startup times and the memory footprint, which you
    might be able to use with some of your services.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生 AOT，你减少了启动时间和内存占用，这你可能可以用在你的某些服务上。
- en: Before moving on to the next chapter, using the bot, you can now easily play
    thousands of games. The bot uses a simple algorithm to set random moves from a
    list of possible moves. Using the games query, check the number of moves the bot
    needs to find the result. Try to play a game using the client you created in the
    previous chapter to access the Docker container from this chapter. Can you solve
    games in fewer moves?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，使用机器人，你现在可以轻松地玩成千上万的游戏。机器人使用一个简单的算法从可能的移动列表中设置随机移动。使用游戏查询，检查机器人需要多少步才能找到结果。尝试使用你在上一章中创建的客户端来访问本章中的
    Docker 容器，你能用更少的步骤解决游戏吗？
- en: As you’ve seen in this chapter, you can run databases in Docker containers.
    With this, you still need to manage your database in the same way as you manage
    your natively installed on-premises database. Another option you’ll see in the
    next chapter is to use **platform-as-a-service** (**PaaS**) cloud services such
    as Azure Cosmos DB. In the next chapter, we’ll create Azure resources and publish
    Docker images we created in this chapter to **Azure Container Registry** (**ACR**)
    and Azure Container Apps.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中看到的，你可以在 Docker 容器中运行数据库。有了这个，你仍然需要以与你在本地安装的数据库相同的方式管理你的数据库。下一章中你将看到的另一个选项是使用
    **平台即服务**（**PaaS**）云服务，例如 Azure Cosmos DB。在下一章中，我们将创建 Azure 资源，并将本章中创建的 Docker
    镜像发布到 **Azure 容器注册库**（**ACR**）和 Azure 容器应用。
- en: Further reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，你可以参考以下链接：
- en: '*Get started with Docker remote containers on WSL* *2*: [https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers](https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 WSL 2 上开始使用 Docker 远程容器*：[https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers](https://learn.microsoft.com/windows/wsl/tutorials/wsl-containers)'
- en: '*How does Docker generate container names?*: [https://frightanic.com/computers/docker-default-container-names/](https://frightanic.com/computers/docker-default-container-names/)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker 如何生成容器名称？*: [https://frightanic.com/computers/docker-default-container-names/](https://frightanic.com/computers/docker-default-container-names/)'
- en: '*Configure and customize SQL Server Docker* *containers*: [https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure](https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置和自定义 SQL Server Docker* *容器*: [https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure](https://learn.microsoft.com/sql/linux/sql-server-linux-docker-container-configure)'
- en: 'Azure SQL Edge Docker image: [https://hub.docker.com/_/microsoft-azure-sql-edge](https://hub.docker.com/_/microsoft-azure-sql-edge)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure SQL Edge Docker 镜像: [https://hub.docker.com/_/microsoft-azure-sql-edge](https://hub.docker.com/_/microsoft-azure-sql-edge)'
- en: 'Run the Azure Cosmos DB emulator on Docker for Linux: [https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux](https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 Linux Docker 上运行 Azure Cosmos DB 模拟器: [https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux](https://learn.microsoft.com/azure/cosmos-db/docker-emulator-linux)'
- en: 'Dockerfile instructions: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dockerfile 指令: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
- en: '*Containerize a .NET app with dotnet* *publish*: [https://learn.microsoft.com/dotnet/core/docker/publish-as-container](https://learn.microsoft.com/dotnet/core/docker/publish-as-container)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 *dotnet* *发布* 将 .NET 应用程序容器化: [https://learn.microsoft.com/dotnet/core/docker/publish-as-container](https://learn.microsoft.com/dotnet/core/docker/publish-as-container)'
- en: '.NET service discovery: [https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery](https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.NET 服务发现: [https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery](https://learn.microsoft.com/en-us/dotnet/core/extensions/service-discovery)'
- en: '*.NET Aspire* *documentation*: [https://learn.microsoft.com/en-us/dotnet/aspire](https://learn.microsoft.com/en-us/dotnet/aspire)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET Aspire* *文档*: [https://learn.microsoft.com/en-us/dotnet/aspire](https://learn.microsoft.com/en-us/dotnet/aspire)'
- en: '*Native AOT* *deployment*: [https://learn.microsoft.com/dotnet/core/deploying/native-aot/](https://learn.microsoft.com/dotnet/core/deploying/native-aot/)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原生 AOT* *部署*: [https://learn.microsoft.com/dotnet/core/deploying/native-aot/](https://learn.microsoft.com/dotnet/core/deploying/native-aot/)'
