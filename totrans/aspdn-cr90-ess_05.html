<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-77">
    <a id="_idTextAnchor078">
    </a>
    
     5
    
   </h1>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor079">
    </a>
    
     Working with Data and Persistence
    
   </h1>
   <p>
    
     Every application, at some point, will consume data, whether through services or even in a data source, such as a SQL Server database or MySQL.
    
    
     Interacting with the database is an important feature, and ASP.NET Core 9 offers mechanisms such as Entity Framework Core and easily integrates with other database interface providers, such as Dapper, a library optimized for abstracting data access in a
    
    
     
      simple way.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Connecting to a
     
     
      
       SQL database
      
     
    </li>
    <li>
     
      Understanding SQL, NoSQL, ORM, and
     
     
      
       Micro ORM
      
     
    </li>
    <li>
     
      Working with Entity Framework core
     
     
      
       and Dapper
      
     
    </li>
   </ul>
   <p>
    
     We will explore communication between web applications and databases using technologies such as Entity Framework and Dapper, in addition to understanding important concepts such as the use of ORM and different data
    
    
     
      persistence models.
     
    
   </p>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor080">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     This chapter has some prerequisites in order to get the most out of it.
    
    
     Therefore, you will need to install Docker and Azure
    
    
     
      Data Studio.
     
    
   </p>
   <p>
    
     All source code and examples for this chapter can be found in the GitHub repository
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor081">
    </a>
    
     Docker installation
    
   </h2>
   <p>
    
     We will use Docker
    
    <a id="_idIndexMarker290">
    </a>
    
     as the basis for running a SQL database server.
    
    
     Using Docker will avoid the problems associated with installing databases on different operating systems as it is a
    
    
     
      portable option.
     
    
   </p>
   <p>
    
     To install Docker, follow the instructions for your
    
    
     
      operating system.
     
    
   </p>
   <h3>
    
     Windows
    
   </h3>
   <p>
    
     Run
    
    <a id="_idIndexMarker291">
    </a>
    
     the following
    
    <a id="_idIndexMarker292">
    </a>
    
     command as an administrator on
    
    
     
      the terminal:
     
    
   </p>
   <pre class="console">
winget install -e --id Docker.DockerDesktop</pre>
   <h3>
    
     Mac
    
   </h3>
   <p>
    
     Access
    
    <a id="_idIndexMarker293">
    </a>
    
     the following link
    
    <a id="_idIndexMarker294">
    </a>
    
     and follow the tutorial for installation
    
    <a id="_idIndexMarker295">
    </a>
    
     according to your
    
    
     
      processor:
     
    
    <a href="https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac">
     
      
       https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac
      
     
    </a>
    
     
      .
     
    
   </p>
   <h3>
    
     Linux
    
   </h3>
   <p>
    
     Docker
    
    <a id="_idIndexMarker296">
    </a>
    
     supports
    
    <strong class="bold">
     
      Ubuntu
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Debian
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      Fedora
     
    </strong>
    
     .
    
    
     Use
    
    <a id="_idIndexMarker297">
    </a>
    
     the instructions
    
    <a id="_idIndexMarker298">
    </a>
    
     according to
    
    <a id="_idIndexMarker299">
    </a>
    
     your
    
    <a id="_idIndexMarker300">
    </a>
    
     platform
    
    
     
      at
     
    
    <a href="https://docs.docker.com/desktop/install/linux-install/">
     
      
       https://docs.docker.com/desktop/install/linux-install/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor082">
    </a>
    
     Azure Data Studio
    
   </h2>
   <p>
    
     Azure Data Studio is
    
    <a id="_idIndexMarker301">
    </a>
    
     a specialized database editor and will be used to perform database operations, such as table creation, inclusion, and
    
    
     
      record querying.
     
    
   </p>
   <p>
    
     Its installation is simple, and it
    
    <a id="_idIndexMarker302">
    </a>
    
     supports different operating
    
    
     
      systems:
     
    
    <a href="https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio">
     
      
       https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-82">
    <a id="_idTextAnchor083">
    </a>
    
     Connecting to a SQL database
    
   </h1>
   <p>
    
     In each chapter, we have learned about
    
    <a id="_idIndexMarker303">
    </a>
    
     different aspects involving ASP.NET Core 9 and how this platform provides a large number of resources for the development of the most diverse types of applications.
    
    
     Each application has a purpose, which is to process data that generates information for users.
    
    
     However, at some point, your application will end up interacting with a data
    
    
     
      persistence model.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Data persistence
     
    </strong>
    
     occurs
    
    <a id="_idIndexMarker304">
    </a>
    
     in several ways, but in general, it is the serialization of information allocated in memory to the disk, which can be in the form of files, and commonly takes place using a data persistence platform, such as a
    
    <strong class="bold">
     
      Database Management System
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DBMS
     
    </strong>
    
     ) or
    
    <a id="_idIndexMarker305">
    </a>
    
     non-relational data.
    
    
     We will discuss these two persistence models in more
    
    
     
      depth soon.
     
    
   </p>
   <p>
    
     Most applications use a persistence model based on databases such as SQL Server, Oracle, and MySQL.
    
    
     Each DBMS has models of administration, typing, and organization of resources; however, they share the same purpose of persisting data in a tabular format and
    
    <a id="_idIndexMarker306">
    </a>
    
     use
    
    <strong class="bold">
     
      Structured Query Language
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SQL
     
    </strong>
    
     ) to manipulate and manage all
    
    
     
      persisted data.
     
    
   </p>
   <p>
    
     ASP.NET Core 9 can communicate with different types of DBMS, but we will focus on the SQL
    
    
     
      Server database.
     
    
   </p>
   <p>
    
     For an application to connect to a database, the following
    
    
     
      are necessary:
     
    
   </p>
   <ul>
    <li>
     
      A database driver (a
     
     
      
       NuGet package)
      
     
    </li>
    <li>
     
      A
     
     
      
       connection string
      
     
    </li>
    <li>
     
      Access to the
     
     
      
       desired resource
      
     
    </li>
   </ul>
   <p>
    
     With this model, we
    
    <a id="_idIndexMarker307">
    </a>
    
     can connect to any database that has a NuGet package ported to the .NET platform, such as the
    
    <strong class="source-inline">
     
      System.Data.SqlClient
     
    </strong>
    
     package for SQL databases, allowing applications to easily implement a
    
    
     
      persistence model.
     
    
   </p>
   <p>
    
     Now that we know the principles related to the interaction between applications and data persistence, let’s learn how the ASP.NET Core 9 platform communicates with a SQL
    
    
     
      Server database.
     
    
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor084">
    </a>
    
     Preparing SQL Server
    
   </h2>
   <p>
    
     In current versions
    
    <a id="_idIndexMarker308">
    </a>
    
     of the .NET platform, they work mainly with the
    
    <strong class="bold">
     
      dependency injection
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DI
     
    </strong>
    
     ) design pattern, which allows
    
    <a id="_idIndexMarker309">
    </a>
    
     the use of a technique
    
    <a id="_idIndexMarker310">
    </a>
    
     called
    
    <strong class="bold">
     
      inversion of control
     
    </strong>
    
     (
    
    <strong class="bold">
     
      IoC
     
    </strong>
    
     ), causing classes and their dependencies to be managed by the .NET
    
    
     
      dependency container.
     
    
   </p>
   <p class="callout-heading">
    
     DI in .NET
    
   </p>
   <p class="callout">
    
     The DI pattern design’s main objective is to abstract the management of class instances and their respective dependencies.
    
    
     It is a common practice in most high-performance solutions.
    
    
     If you want to learn more about
    
    <a id="_idIndexMarker311">
    </a>
    
     DI,
    
    
     
      visit
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Through DI, we can register a class to control the connection to the database.
    
    
     We will work with this approach in the topic where we will learn about using the Entity Framework in the
    
    <em class="italic">
     
      Working with EF Core and
     
    </em>
    
     <em class="italic">
      
       Dapper
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     For now, it is important to understand the fundamentals of communicating between an application and the database.
    
    
     We will use SQL Server as the DBMS and for this, you must consult the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section and install the Docker Engine.
    
    
     How Docker works is beyond the scope of this book.
    
    
     However, its use will allow you to continue with the examples described in this chapter without any
    
    
     
      compatibility problems.
     
    
   </p>
   <p>
    
     Let’s start configuring
    
    
     
      the database:
     
    
   </p>
   <ol>
    <li>
     
      The first step is to run a Docker container to run SQL Server.
     
     
      We will use the following command to start an instance of
     
     
      
       SQL Server:
      
     
     <pre class="source-code">
<strong class="bold">docker run -d -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=Password123" -p 1433:1433 mcr.microsoft.com/mssql/server:2019-latest</strong></pre>
     <p class="list-inset">
      
       Let’s review the
      
      
       
        preceding command:
       
      
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        
         docker run
        
       </strong>
       
        : This uses the Docker Engine to run
       
       
        
         a container.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         -d
        
       </strong>
       
        : This parameter is used to execute the command in
       
       
        
         the background.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         -e
        
       </strong>
       
        : These are definitions of environment variables, used when starting the container.
       
       
        In this case, the
       
       <strong class="source-inline">
        
         ACCEPT_EULA
        
       </strong>
       
        variable is configured to agree with Microsoft’s terms and the
       
       <strong class="source-inline">
        
         MSSQL_SA_PASSWORD
        
       </strong>
       
        parameter is where a password is defined for the SA user, the default SQL
       
       
        
         user administrator.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         -p
        
       </strong>
       
        : This defines the port of the host machine that will be used to communicate with port 1433 of the container.
       
       
        In this scenario, we’re defining the host and container ports as the
       
       
        
         same, 1433.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         mcr.microsoft.com/mssql/server:2019-latest
        
       </strong>
       
        : This is the type and version of the Docker image that will
       
       
        
         be run.
        
       
      </li>
     </ul>
     <p class="list-inset">
      
       Docker does all
      
      <a id="_idIndexMarker312">
      </a>
      
       the magic of downloading the SQL Server image onto your machine and running it in a virtualized way.
      
      
       The preceding command will return a hash code indicating that the image
      
      
       
        is running.
       
      
     </p>
    </li>
    <li>
     
      Now, run the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">docker ps</strong></pre>
    </li>
    <li>
     
      The running image will be listed as shown in
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     <em class="italic">
      
       .1
      
     </em>
     
      , and the number of images listed may be different if you already
     
     
      
       use Docker.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.1 – Docker image running" src="img/B21788_05_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.1 – Docker image running
    
   </p>
   <p class="callout-heading">
    
     Learn more about Docker
    
   </p>
   <p class="callout">
    
     To learn more about Docker, take a look at the
    
    <a id="_idIndexMarker313">
    </a>
    
     following official
    
    
     
      documentation:
     
    
    <a href="https://docs.docker.com/">
     
      
       https://docs.docker.com/
      
     
    </a>
    
     
      .
     
    
   </p>
   <ol>
    <li value="4">
     
      Now that we have the image
     
     <a id="_idIndexMarker314">
     </a>
     
      running, open
     
     <strong class="bold">
      
       Azure Data Studio
      
     </strong>
     
      , installed as described in the
     
     <em class="italic">
      
       Technical requirements
      
     </em>
     
      section, and click the
     
     <strong class="bold">
      
       Create a connection
      
     </strong>
     
      button, as highlighted in
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     
      <em class="italic">
       
        .2
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.2 – Creating a connection to the database" src="img/B21788_05_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.2 – Creating a connection to the database
    
   </p>
   <ol>
    <li value="5">
     
      Fill in the fields
     
     
      
       as follows:
      
     
     <ul>
      <li>
       
        <strong class="bold">
         
          Server
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          localhost,1433
         
        </strong>
       
      </li>
      <li>
       <strong class="bold">
        
         Authentication type
        
       </strong>
       
        :
       
       
        <strong class="source-inline">
         
          SQL Login
         
        </strong>
       
      </li>
      <li>
       <strong class="bold">
        
         User
        
       </strong>
       
        <strong class="bold">
         
          name
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          sa
         
        </strong>
       
      </li>
      <li>
       
        <strong class="bold">
         
          Password
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          Password123
         
        </strong>
       
      </li>
     </ul>
    </li>
    <li>
     
      Keep the
     
     <a id="_idIndexMarker315">
     </a>
     
      other parameters as they are, then click
     
     <strong class="bold">
      
       Connect
      
     </strong>
     
      .
     
     
      In some cases, a popup will be displayed informing you about the use of certificates.
     
     
      Just click the
     
     <strong class="bold">
      
       Enable Trust server certificate
      
     </strong>
     
      button.
     
     
      This certificate is automatically created by Azure Data Studio, so
     
     
      
       don’t worry.
      
     
    </li>
    <li>
     
      After making the connection, you will have access to the server, which only has the standard databases.
     
     
      Click on the
     
     <strong class="bold">
      
       New Query
      
     </strong>
     
      option and you will see a new tab, as shown in
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     <em class="italic">
      
       .3
      
     </em>
     
      , that we will use to create a database and
     
     
      
       a table.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.3 – New Query tab" src="img/B21788_05_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.3 – New Query tab
    
   </p>
   <ol>
    <li value="8">
     
      Now, in the book GitHub repository, in the
     
     <a href="B21788_05.xhtml#_idTextAnchor078">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
     
      folder, copy the code from the
     
     <strong class="source-inline">
      
       InitialDb.sql
      
     </strong>
     
      file and paste it into the
     
     <strong class="bold">
      
       New Query
      
     </strong>
     
      tab, created previously, in Azure
     
     
      
       Data Studio.
      
     
    </li>
    <li>
     
      Then click the
     
     <strong class="bold">
      
       Run
      
     </strong>
     
      button.
     
     
      The
     
     <strong class="source-inline">
      
       DbStore
      
     </strong>
     
      database and the
     
     <strong class="source-inline">
      
       Product
      
     </strong>
     
      table will be created, and
     
     <a id="_idIndexMarker316">
     </a>
     
      some products will be inserted as an example
     
     
      
       of data.
      
     
    </li>
   </ol>
   <p>
    
     Now that we have prepared the SQL database, it’s time to create a simple console application, make the connection, and list the data from the
    
    
     
      product table.
     
    
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor085">
    </a>
    
     Using the SQL client
    
   </h2>
   <p>
    
     As mentioned
    
    <a id="_idIndexMarker317">
    </a>
    
     previously, the .NET platform has more modern ways of establishing a connection to the database and we will talk more about this subject in the
    
    <em class="italic">
     
      ORM and Micro ORM
     
    </em>
    
     section.
    
    
     However, it is important that you understand the fundamentals of communication between an application and
    
    
     
      a database.
     
    
   </p>
   <p>
    
     To do this, we will create a console application and add the necessary NuGet package to connect to the previously prepared
    
    
     
      SQL Server.
     
    
   </p>
   <p>
    
     Then, we’ll open the terminal in a folder of your choice and execute the following commands
    
    
     
      in sequence:
     
    
   </p>
   <pre class="console">
dotnet new console -n MyFirstDbConnection
cd MyFirstDbConnection
dotnet add package System.Data.SqlClient
code.</pre>
   <p>
    
     With the project ready, we will need to carry out the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a connection to the database.
     
     
      We will use the
     
     
      <strong class="source-inline">
       
        SqlConnection
       
      </strong>
     
     
      
       class.
      
     
    </li>
    <li>
     
      Open
     
     
      
       the connection.
      
     
    </li>
    <li>
     
      Create a SQL command that will be executed.
     
     
      We will use the
     
     
      <strong class="source-inline">
       
        SqlCommand
       
      </strong>
     
     
      
       class.
      
     
    </li>
    <li>
     
      Read data
     
     <a id="_idIndexMarker318">
     </a>
     
      based on the SQL command.
     
     
      We will use the
     
     
      <strong class="source-inline">
       
        SQLDataReader
       
      </strong>
     
     
      
       class.
      
     
    </li>
    <li>
     
      Display the data on
     
     
      
       the screen.
      
     
    </li>
    <li>
     
      Close
     
     
      
       the connection.
      
     
    </li>
   </ol>
   <p>
    
     In just six steps, we will be able to interact with a data source.
    
    
     The code in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file must be identical to
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
using System.Data.SqlClient;
SqlConnection sql = new SqlConnection("Server=localhost,
  1433;Database=DbStore; user id=sa;
  password=Password123");
try
{
    sql.Open();
    Console.WriteLine("Connection Opened");
    SqlCommand cmd = new SqlCommand(
      "select * from Product", sql);
    SqlDataReader reader = cmd.ExecuteReader();
    while (reader.Read())
    {
        Console.WriteLine($"{reader[0]} - {reader[1]}
          - {reader[2]:C2}");
    }
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
}
finally
{
    sql.Close();
    Console.WriteLine("Connection Closed");
}</pre>
   <p>
    
     Let’s discuss the
    
    <a id="_idIndexMarker319">
    </a>
    
     most important details of
    
    
     
      this implementation.
     
    
   </p>
   <p>
    
     The first step was to create the database connection class,
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     , which receives a connection string as a parameter in the constructor.
    
    
     The connection string can be understood as the address of the database server.
    
    
     In this case, this address is made up of three basic properties:
    
    <strong class="source-inline">
     
      Server
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      user id
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      password
     
    </strong>
    
     .
    
    
     The default connection port is
    
    <strong class="source-inline">
     
      1433
     
    </strong>
    
     , which can be omitted, but you must explicitly define it if the connection port is different.
    
    
     These are the same parameters used previously to connect to the database through Azure Data Studio through
    
    
     
      the UI.
     
    
   </p>
   <p>
    
     The connection string offers
    
    <a id="_idIndexMarker320">
    </a>
    
     several other types of parameters to determine how the connection will be made.
    
    
     The version we are currently using is
    
    
     
      the simplest.
     
    
   </p>
   <p class="callout-heading">
    
     Connection String
    
   </p>
   <p class="callout">
    
     As mentioned, the
    
    <a id="_idIndexMarker321">
    </a>
    
     connection string is made up of different parameters, including sensitive data such as username and password.
    
    
     For this reason, it is good practice to keep connection string management out of the source code, to prevent vulnerabilities and to prevent sensitive data from being available in the application’s version control.
    
    
     We will learn secure credential management approaches in
    
    <a href="B21788_09.xhtml#_idTextAnchor146">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     .
    
    
     More details about
    
    <a id="_idIndexMarker322">
    </a>
    
     connection strings can be found in this great
    
    
     
      reference:
     
    
    <a href="https://www.connectionstrings.com/sql-server/">
     
      
       https://www.connectionstrings.com/sql-server/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     After creating the
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     object, it is time to open the connection using the
    
    <strong class="source-inline">
     
      sql.Open()
     
    </strong>
    
     code.
    
    
     Next, the
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     class is created, where the constructor receives an SQL string and also the database
    
    
     
      connection object.
     
    
   </p>
   <p>
    
     The SQL code used performs a simple query on the
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     table, obtaining all available rows
    
    
     
      and columns.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     has different methods, such as
    
    <strong class="source-inline">
     
      ExecuteNonQuery
     
    </strong>
    
     , that are generally used to execute commands that change the database, such as
    
    <strong class="source-inline">
     
      Insert
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Delete
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      Update
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      ExecuteReader
     
    </strong>
    
     , which is being used in this example to obtain data from the Product table.
    
    
     The
    
    <strong class="source-inline">
     
      ExecuteReader
     
    </strong>
    
     method returns an object of type
    
    <strong class="source-inline">
     
      SqlDataReader
     
    </strong>
    
     , which abstracts the rows and columns into an object, where it is possible to perform interactions and access
    
    
     
      table information.
     
    
   </p>
   <p>
    
     All this abstraction work is done by the
    
    <strong class="source-inline">
     
      System.Data.SqlClient
     
    </strong>
    
     library, which has access to the SQL Server database connection driver and provides several classes for
    
    
     
      manipulating data.
     
    
   </p>
   <p>
    
     After obtaining the data by executing the
    
    <strong class="source-inline">
     
      ExecuteReader
     
    </strong>
    
     method, we finally iterate on the returned object by displaying the data obtained from
    
    
     
      the database.
     
    
   </p>
   <p>
    
     All code is protected by a
    
    <strong class="source-inline">
     
      try..catch..finally
     
    </strong>
    
     block to guarantee error handling and, above all, to close the connection at the end
    
    
     
      of use.
     
    
   </p>
   <p>
    
     We can analyze the result of listing the database records in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .4
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.4 – Displaying records in the Product table" src="img/B21788_05_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.4 – Displaying records in the Product table
    
   </p>
   <p>
    
     Despite being a
    
    <a id="_idIndexMarker323">
    </a>
    
     simple application, we learned important concepts and fundamentals related to interactions between applications and databases.
    
    
     We use SQL Server as a base, but the lessons learned apply to other data sources, such as MySQL or Oracle, varying, of course, the connection, command, and
    
    
     
      reading objects.
     
    
   </p>
   <p>
    
     Furthermore, we prepared the basis of the environment for the remainder of the chapter, where we will explore other concepts, starting with the differences between relational and non-relational databases, in addition to understanding what ORM and Micro
    
    
     
      ORMs are.
     
    
   </p>
   <h1 id="_idParaDest-85">
    <a id="_idTextAnchor086">
    </a>
    
     Understanding SQL, NoSQL, ORM, and Micro ORM
    
   </h1>
   <p>
    
     With the emergence of different application structures and needs, different ways of managing data have also been developed.
    
    
     Choosing the right database and interaction methods has a significant impact on application performance, scalability,
    
    
     
      and maintainability.
     
    
   </p>
   <p>
    
     Likewise, with the increase in systems complexity, new technologies for manipulating data obtained through DBMSs have also emerged, such
    
    <a id="_idIndexMarker324">
    </a>
    
     as
    
    <strong class="bold">
     
      Object-relational mapping
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ORM
     
    </strong>
    
     ) and
    
    <a id="_idIndexMarker325">
    </a>
    
     micro ORM.
    
    
     Each of the technologies has benefits for certain contexts, and it is important to know them correctly as there are no
    
    
     
      silver bullets.
     
    
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor087">
    </a>
    
     SQL versus NoSQL
    
   </h2>
   <p>
    
     The complexity of applications and
    
    <a id="_idIndexMarker326">
    </a>
    
     different data management needs have led to
    
    <a id="_idIndexMarker327">
    </a>
    
     several challenges for companies, such as having suitable performance for managing large amounts of data, which leads to maintainability and
    
    
     
      scalability challenges.
     
    
   </p>
   <p>
    
     Along with these variables, keeping the servers running perfectly is expensive.
    
    <strong class="bold">
     
      Relational Database Management System
     
    </strong>
    
     (
    
    <strong class="bold">
     
      RDBMS
     
    </strong>
    
     ) were
    
    <a id="_idIndexMarker328">
    </a>
    
     the main means of tracking organizations’ information, and their approach in a relational model that prioritizes the integrity and relationship between information has defined how development teams handle data manipulation
    
    
     
      for years.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Relational databases
     
    </strong>
    
     have
    
    <a id="_idIndexMarker329">
    </a>
    
     tables that represent a type of information.
    
    
     This information is distributed in columns, representing the characteristics of a piece of data.
    
    
     Complete data is determined in a row of a table.
    
    
     Tables can have relationships with other tables, associating different data to compose information.
    
    
     That’s why they are called relational models.
    
    
     The example in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .5
     
    </em>
    
     shows some tables and their relationships, representing a data abstraction from a bank
    
    
     
      account application:
     
    
   </p>
   <div><div><img alt="Figure 5.5 – Basic bank account data model" src="img/B21788_05_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.5 – Basic bank account data model
    
   </p>
   <p>
    
     In the figure, you can see that a customer has an account that has transactions.
    
    
     This is a basic representation of this context.
    
    
     But in large contexts, this relational structure model leads to different challenges for companies and follows the application development model based on how data should
    
    
     
      be persisted.
     
    
   </p>
   <p>
    
     Relational databases
    
    <a id="_idIndexMarker330">
    </a>
    
     provide flexibility; however, basing applications on the data
    
    <a id="_idIndexMarker331">
    </a>
    
     model shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .5
     
    </em>
    
     leads to
    
    
     
      several challenges.
     
    
   </p>
   <p>
    
     Modern systems need to have flexibility and elasticity, and in some cases must be
    
    
     
      technology agnostic.
     
    
   </p>
   <p>
    
     With the emergence of the cloud, the possibility of having elastic resources also emerged.
    
    
     However, maintaining a cluster of data and synchronizing and managing it is not an easy or cheap task, even in cloud environments.
    
    
     Nowadays, through
    
    <strong class="bold">
     
      Platform as a Service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      PaaS
     
    </strong>
    
     ), such
    
    <a id="_idIndexMarker332">
    </a>
    
     activities are abstracted by cloud providers; however, they come at
    
    
     
      a cost.
     
    
   </p>
   <p>
    
     With the evolution of technology, other types of persistence models and different opportunities for applications and companies have emerged.
    
    
     One of the big terms generally misunderstood in the technical community a few years ago was the term
    
    <strong class="bold">
     
      NoSQL
     
    </strong>
    
     , which means
    
    <strong class="bold">
     
      non-relational database
     
    </strong>
    
     or
    
    
     <strong class="bold">
      
       not-only SQL
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This persistence model has a different approach to the traditional relational model.
    
    
     NoSQL databases have a more flexible data structure that does not have many restrictions about how data will
    
    
     
      be persisted.
     
    
   </p>
   <p>
    
     For many years, NoSQL
    
    <a id="_idIndexMarker333">
    </a>
    
     was seen as the new persistence model for DBMSs, causing
    
    <a id="_idIndexMarker334">
    </a>
    
     companies to try to migrate to this model without fully understanding the fundamentals and using relational database approaches in
    
    
     
      NoSQL structures.
     
    
   </p>
   <p>
    
     This way of interacting with a different source of data persistence had several benefits, including making developers, engineers, and companies change their perspective on application development, but focused on the business instead of how the data should
    
    
     
      be persisted.
     
    
   </p>
   <p>
    
     In
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .6
     
    </em>
    
     , we can see most of the differences between relational databases and
    
    
     
      NoSQL databases.
     
    
   </p>
   <div><div><img alt="Figure 5.6 – Biggest differences in relational databases and NoSQL" src="img/B21788_05_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.6 – Biggest differences in relational databases and NoSQL
    
   </p>
   <p>
    
     The NoSQL
    
    <a id="_idIndexMarker335">
    </a>
    
     approach offers different types of data persistence that bring several benefits to applications.
    
    
     The most common are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     
      Key-value stores (
     
     
      
       Redis, Memcached)
      
     
    </li>
    <li>
     
      Document databases (
     
     
      
       MongoDB, Couchbase)
      
     
    </li>
    <li>
     
      Column-family databases (
     
     
      
       Cassandra, HBase)
      
     
    </li>
    <li>
     
      Graph databases (
     
     
      
       Neo4j, OrientDB)
      
     
    </li>
   </ul>
   <p>
    
     Likewise, the data manipulation model for NoSQL is different from relational databases, and query methods vary depending on the NoSQL database type and may not be as standardized
    
    
     
      as SQL.
     
    
   </p>
   <p>
    
     Furthermore, it is important to understand that NoSQL databases often prioritize scalability, performance for specific query patterns, and flexibility to handle evolving
    
    
     
      data structures.
     
    
   </p>
   <p>
    
     But when should we use
    
    <a id="_idIndexMarker336">
    </a>
    
     one approach
    
    <a id="_idIndexMarker337">
    </a>
    
     over
    
    
     
      the other?
     
    
   </p>
   <p>
    
     Let’s analyze the
    
    <a id="_idIndexMarker338">
    </a>
    
     following table to understand the differences between
    
    
     
      persistence approaches:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Feature
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           RDBMS
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           NoSQL
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Structure
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Rigid,
        
        
         
          predefined schemas
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Flexible, adaptable, schemas can be schema-less or
        
        
         
          defined on-the-fly
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Scalability
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Usually scales vertically (increase
        
        
         
          hardware power)
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Often designed for horizontal scaling (adding
        
        
         
          more servers)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Consistency
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Strong
        
        
         
          ACID guarantees
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Eventual consistency is common for
        
        
         
          faster writes
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Querying
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Powerful, expressive
        
        
         
          SQL queries
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Varies by database type, potentially less powerful than SQL for
        
        
         
          complex relationships
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Use cases
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Data with rigid schemas, complex relationships, strong
        
        
         
          consistency needs
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         High-volume
        
        <a id="_idIndexMarker339">
        </a>
        
         data, rapidly changing data models, high performance, specific query patterns,
        
        
         
          distributed systems
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 5.1 – Comparison between data persistence models
    
   </p>
   <p>
    
     As shown in
    
    <em class="italic">
     
      Table 5.1
     
    </em>
    
     , RDBMSs
    
    <a id="_idIndexMarker340">
    </a>
    
     excel in predictable and structured data models, where data
    
    <a id="_idIndexMarker341">
    </a>
    
     accuracy and relationships are key.
    
    
     NoSQL stands out in scenarios where flexibility, massive scalability, and high performance for specific needs take priority.
    
    
     Both are excellent proposals for different types of applications, with their varied applicability, such as an application persisting data in SQL Server and using Redis to manage the cache of some information, avoiding constant access to the database.
    
    
     Both approaches are used for the
    
    
     
      same application.
     
    
   </p>
   <p>
    
     Fortunately, ASP.NET Core 9 allows us to work with different types of data models because it is extensible and dynamic.
    
    
     Let’s delve a little deeper into two important concepts for manipulating data in relational databases, which are ORMs and
    
    
     
      Micro ORMs.
     
    
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor088">
    </a>
    
     ORM and Micro ORM
    
   </h2>
   <p>
    
     ORM is a
    
    <a id="_idIndexMarker342">
    </a>
    
     technique that acts as a bridge between the world of
    
    <strong class="bold">
     
      object-oriented programming
     
    </strong>
    
     (
    
    <strong class="bold">
     
      OOP
     
    </strong>
    
     ) and
    
    <a id="_idIndexMarker343">
    </a>
    
     the relational world of databases.
    
    
     OOP models data as objects with properties and behaviors, while databases work with tables, rows,
    
    
     
      and columns.
     
    
   </p>
   <p>
    
     As we learned at the beginning of the chapter, we use objects such as
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      SqlDatReader
     
    </strong>
    
     to read data in SQL Server.
    
    
     This is a simple approach, but as businesses become more complex, it can be a big problem to work with obtaining and mapping data to apply the required business rules in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     In the example of the
    
    <strong class="source-inline">
     
      Products
     
    </strong>
    
     table, we implemented in the
    
    <em class="italic">
     
      Using the SQL Client
     
    </em>
    
     section, a SQL query was used to obtain all existing records.
    
    
     In real, large-scale applications, it is impractical for any interaction by users to be necessary to obtain all records from a table.
    
    
     This could cause serious performance problems in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     It is necessary to insert, delete, and update data, and even customize searches through filters, meaning that a SQL command is written for each situation.
    
    
     Furthermore, for data to be processed efficiently, it is necessary to abstract what persistence is and what the business domain is.
    
    
     In C#, we can work with the concept
    
    <a id="_idIndexMarker344">
    </a>
    
     of
    
    <strong class="bold">
     
      object orientation
     
    </strong>
    
     at a high level and, in this context, ORM emerges as a powerful technique that allows us to focus on the business, in addition to
    
    
     
      other flexibilities.
     
    
   </p>
   <p>
    
     The implementation of an ORM on the .NET platform is called
    
    <strong class="bold">
     
      Entity Framework
     
    </strong>
    
     (
    
    <strong class="bold">
     
      EF
     
    </strong>
    
     ).
    
    
     EF
    
    <a id="_idIndexMarker345">
    </a>
    
     provides all the high-level mechanisms for manipulating and translating data either from objects to databases or from databases to
    
    
     
      C# objects.
     
    
   </p>
   <p>
    
     With EF, we don’t need to worry about
    
    <a id="_idIndexMarker346">
    </a>
    
     writing SQL queries for the various operations in a database.
    
    
     EF also has other features, such as
    
    <strong class="bold">
     
      migrations
     
    </strong>
    
     , which allow you to update the database according to the developed code model, providing a great solution for
    
    
     
      database versioning.
     
    
   </p>
   <p>
    
     To better understand how
    
    <a id="_idIndexMarker347">
    </a>
    
     ORM works, look at
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .7
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.7 – Simple data model of a banking system" src="img/B21788_05_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.7 – Simple data model of a banking system
    
   </p>
   <p>
    
     We know that it is
    
    <a id="_idIndexMarker348">
    </a>
    
     possible to obtain data in a C# application, as we learned previously.
    
    
     To translate the data objects shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .7
     
    </em>
    
     , it would be necessary to create three C# classes:
    
    <strong class="source-inline">
     
      Customer.cs
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Account.cs
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      Movement.cs
     
    </strong>
    
     .
    
    
     However, for each of the classes, it would be necessary to write different SQL queries to perform any operations on the database.
    
    
     Furthermore, for each business need, it would be necessary to map the data to C# classes and vice versa to
    
    
     
      persist data.
     
    
   </p>
   <p>
    
     This means that to obtain customer data, such as their accounts and transactions, it would be necessary to carry out at least three database queries, interact with
    
    <strong class="source-inline">
     
      SqlDataReader
     
    </strong>
    
     objects, and create the respective C# objects.
    
    
     Although it is not a very complex job, as the software becomes more complex, with various changes, this model
    
    
     
      becomes problematic.
     
    
   </p>
   <p>
    
     Imagine changing the name of the
    
    <strong class="source-inline">
     
      Description
     
    </strong>
    
     column in the
    
    <strong class="source-inline">
     
      Movement
     
    </strong>
    
     table to
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     .
    
    
     It would even be necessary to change all the SQL queries created in C#, in addition to the mappings.
    
    
     When it comes to more complex data models, maintenance difficulties and possible problems
    
    
     
      grow exponentially.
     
    
   </p>
   <p>
    
     When working
    
    <a id="_idIndexMarker349">
    </a>
    
     with an ORM, this entire task is abstracted and less complicated.
    
    
     Fortunately, EF provides a great solution for this scenario, requiring
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Connection string
      
     </strong>
     
      : Database
     
     <a id="_idIndexMarker350">
     </a>
     
      address and
     
     
      
       access credentials
      
     
    </li>
    <li>
     <strong class="bold">
      
       DbContext object
      
     </strong>
     
      : Orchestrator
     
     <a id="_idIndexMarker351">
     </a>
     
      of the connection to the database and management of objects
     
     
      
       and mappings
      
     
    </li>
    <li>
     <strong class="bold">
      
       DbSet
      
     </strong>
     
      : Domain
     
     <a id="_idIndexMarker352">
     </a>
     
      objects that will be mapped to
     
     
      
       database objects
      
     
    </li>
   </ul>
   <p>
    
     EF Core manages all the communication with the database, mapping, and migrations, allowing developers to focus on
    
    
     
      the business.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     class for the example in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .7
     
    </em>
    
     would look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
public class BankingDbContext : DbContext
  {
    public BankingDbContext (DbContextOptions
      &lt; BankingDbContext &gt; options)
      : base(options)
    {
    }
    public DbSet&lt;Customer&gt; Customers { get; set; }
    public DbSet&lt;Account&gt; Accounts { get; set; }
    public DbSet&lt;Movement&gt; Movements { get; set; }
  }</pre>
   <p>
    
     We will implement this class in more detail in the next section.
    
    
     At this point, it is important to understand that all the tables that will be managed by
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     are properties of the class
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     with the
    
    
     
      type
     
    
    
     <strong class="source-inline">
      
       DbSet
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The mapping
    
    <a id="_idIndexMarker353">
    </a>
    
     of database objects is generally done by conventions, where EntityFramework Core compares the property names and types against the table column names and types in the database, but can be easily customized using specialized attributes
    
    
     
      or classes.
     
    
   </p>
   <p class="callout-heading">
    
     Conventions in EF Core
    
   </p>
   <p class="callout">
    
     To learn more about
    
    <a id="_idIndexMarker354">
    </a>
    
     conventions,
    
    
     
      visit
     
    
    <a href="https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions">
     
      
       https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     With mapping database conventions, we can obtain all the customers in the database through the
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     class,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;ICollection&lt;Account&gt;&gt;
  GetAllAccountsAsync()
{
     return await _context.Accounts.ToListAsync();
}</pre>
   <p>
    
     As you can see in the previous code, the
    
    <strong class="source-inline">
     
      GetAllAccountsAsync
     
    </strong>
    
     method searches for all the accounts in the database.
    
    
     The EF Core
    
    <strong class="source-inline">
     
      ToListAsync
     
    </strong>
    
     method will query the database asynchronously, returning a list of
    
    
     <strong class="source-inline">
      
       Account
      
     </strong>
    
    
     
      objects.
     
    
   </p>
   <p>
    
     The preceding code shows a simple and powerful approach using ORM, without needing to manage the connection or write SQL commands, as they are generated by EF, in addition to there being no need to map database objects into classes.
    
    
     All these functionalities are
    
    
     
      already abstracted.
     
    
   </p>
   <p>
    
     In this way, ORMs
    
    <a id="_idIndexMarker355">
    </a>
    
     provide
    
    
     
      several benefits:
     
    
   </p>
   <ul>
    <li>
     <em class="italic">
      
       Reduced boilerplate code
      
     </em>
     
      : ORMs automatically generate much of the repetitive SQL code (
     
     <strong class="source-inline">
      
       SELECT
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       INSERT
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       UPDATE
      
     </strong>
     
      ), allowing developers to focus on application logic, not data
     
     
      
       access code.
      
     
    </li>
    <li>
     <em class="italic">
      
       Enhanced productivity
      
     </em>
     
      : Working with objects is often more intuitive for developers who are used to OOP principles, speeding
     
     
      
       up development.
      
     
    </li>
    <li>
     <em class="italic">
      
       Increased maintainability
      
     </em>
     
      : ORMs provide a certain level of abstraction between your application code and the specific database, making it easier to switch database
     
     <a id="_idIndexMarker356">
     </a>
     
      providers or refactor your data model with less impact on
     
     
      
       your codebase.
      
     
    </li>
   </ul>
   <p>
    
     However, ORM technologies have
    
    <a id="_idIndexMarker357">
    </a>
    
     pros and cons
    
    
     
      to consider:
     
    
   </p>
   <ul>
    <li>
     <em class="italic">
      
       Performance overhead
      
     </em>
     
      : In some cases, the SQL queries generated by an ORM might not be the most efficient.
     
     
      Experienced developers can often write more performant SQL
     
     
      
       by hand.
      
     
    </li>
    <li>
     <em class="italic">
      
       Potential abstraction issues
      
     </em>
     
      : ORMs
     
     <a id="_idIndexMarker358">
     </a>
     
      can hide some of the underlying database concepts, which can be beneficial, but might make optimization or troubleshooting more challenging for those unfamiliar with
     
     
      
       database fundamentals.
      
     
    </li>
   </ul>
   <p>
    
     EF Core
    
    <a id="_idIndexMarker359">
    </a>
    
     is in version 8 and, over the years, it has been improved, with different features added.
    
    
     However, we still recommend using the best technology offered to
    
    
     
      us wisely.
     
    
   </p>
   <p>
    
     Although ORM technologies are becoming increasingly modern, there is still a concern about performance, especially when you have a complex data model, with several levels of relationships between objects.
    
    
     ORMs are often not capable of generating extremely performant queries, and, in some cases, it is necessary to use other resources, such as the Micro ORM approach learned at the beginning of
    
    
     
      the chapter.
     
    
   </p>
   <p>
    
     In this context of facilitating work between the application and database objects, the concept of Micro
    
    
     
      ORM emerged.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Micro ORMs
     
    </strong>
    
     are
    
    <a id="_idIndexMarker360">
    </a>
    
     conceptually very similar to the ORM model.
    
    
     However, micro ORMs abstracts the database mapping objects into C# classes but prioritize performance.
    
    
     In some cases, they even provide some automatic generation
    
    
     
      of queries.
     
    
   </p>
   <p>
    
     Some differences
    
    <a id="_idIndexMarker361">
    </a>
    
     between
    
    <a id="_idIndexMarker362">
    </a>
    
     Micro ORM and ORM are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <em class="italic">
      
       Footprint
      
     </em>
     
      : Micro ORMs have a much smaller code base and fewer dependencies, resulting in significantly
     
     
      
       less overhead.
      
     
    </li>
    <li>
     <em class="italic">
      
       Complexity
      
     </em>
     
      : Micro ORMs offer a basic set of features for mapping and executing queries, leaving behind many of the complexities found in
     
     
      
       traditional ORMs.
      
     
    </li>
    <li>
     <em class="italic">
      
       Control
      
     </em>
     
      : With less abstraction, developers have more direct control over the SQL queries
     
     
      
       being executed.
      
     
    </li>
    <li>
     <em class="italic">
      
       Features
      
     </em>
     
      : Micro ORMs typically lack these features often found in
     
     
      
       larger ORMs:
      
     
     <ul>
      <li>
       
        Extensive object
       
       
        
         relationship management
        
       
      </li>
      <li>
       
        
         Change tracking
        
       
      </li>
      <li>
       
        Automatic
       
       
        
         schema migrations
        
       
      </li>
      <li>
       
        Identity maps (entity tracking to prevent
       
       
        
         duplicate payloads)
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     There are some Micro ORM technologies commonly used by the .NET community, the most famous of which is
    
    
     
      called Dapper.
     
    
   </p>
   <p class="callout-heading">
    
     Dapper is open source
    
   </p>
   <p class="callout">
    
     The Dapper library
    
    <a id="_idIndexMarker363">
    </a>
    
     is open source and is constantly being updated.
    
    
     There is a comparison between different ORM engines, including EF Core, on
    
    
     
      GitHub:
     
    
    <a href="https://github.com/DapperLib/Dapper">
     
      
       https://github.com/DapperLib/Dapper
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Using a Micro ORM does not preclude using an ORM.
    
    
     They can coexist in an application, depending on the need and context.
    
    
     It is important to keep in mind that this approach allows us to bring greater quality to
    
    
     
      our applications.
     
    
   </p>
   <p>
    
     In the next section, we will cover, in a practical way, the use of EF Core and Dapper based on the previously mentioned
    
    <em class="italic">
     
      bank
     
    </em>
    
     <em class="italic">
      
       account
      
     </em>
    
    
     
      concept.
     
    
   </p>
   <p>
    
     Now that we understand what an ORM and a Micro ORM are, the time has come to implement solutions using
    
    
     
      these approaches.
     
    
   </p>
   <h1 id="_idParaDest-88">
    <a id="_idTextAnchor089">
    </a>
    
     Working with EF Core and Dapper
    
   </h1>
   <p>
    
     ORM and Micro ORM are widely techniques used in modern applications due to their various benefits.
    
    
     As we have learned, ASP.NET Core 9 has several options for working with data models from different technologies.
    
    
     We will learn how to use EF Core as an ORM, and we will also use Dapper as a
    
    
     
      Micro ORM.
     
    
   </p>
   <h2 id="_idParaDest-89">
    <a id="_idTextAnchor090">
    </a>
    
     EF Core
    
   </h2>
   <p>
    
     Based on the example of the
    
    <a id="_idIndexMarker364">
    </a>
    
     bank account data model, we have tables
    
    <em class="italic">
     
      Customer
     
    </em>
    
     ,
    
    <em class="italic">
     
      Account
     
    </em>
    
     , and
    
    <em class="italic">
     
      Movement
     
    </em>
    
     , we will create a project to connect to the SQL database we configured at the beginning of the chapter, which is running in a
    
    
     
      Docker container.
     
    
   </p>
   <p>
    
     The complete solution code will therefore be available in the GitHub repository mentioned in the
    
    <em class="italic">
     
      Technical
     
    </em>
    
     <em class="italic">
      
       requirements
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     For this project, we will use a Minimal API project and, to do this, open the terminal in administrator mode and execute the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet new webapi -n WorkingWithOrm
cd WorkingWithOrm</pre>
   <p>
    
     Now, we need to add the EF Core libraries that will be necessary for the application to connect to the SQL server database.
    
    
     Additionally, we will need to install an EF CLI tool.
    
    
     This tool will be used to apply some updates to
    
    
     
      the database.
     
    
   </p>
   <p>
    
     Run the following commands in
    
    
     
      the terminal:
     
    
   </p>
   <pre class="console">
dotnet tool install –global dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Design</pre>
   <p>
    
     The first command installs the EF CLI tool, and the following commands are the EF libraries that will be used to connect the application to
    
    
     
      the database.
     
    
   </p>
   <p class="callout-heading">
    
     EF Core database providers
    
   </p>
   <p class="callout">
    
     EF Core has the
    
    <a id="_idIndexMarker365">
    </a>
    
     ability to work with different databases; it is not restricted to SQL Server.
    
    
     More details about the available providers can be found
    
    
     
      at
     
    
    <a href="https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli">
     
      
       https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The project is now
    
    <a id="_idIndexMarker366">
    </a>
    
     ready to be configured, and we will perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Configure the
     
     
      
       connection string.
      
     
    </li>
    <li>
     
      Create
     
     
      
       model classes.
      
     
    </li>
    <li>
     
      Create a class that inherits
     
     
      
       from
      
     
     
      <strong class="source-inline">
       
        DbContext
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Configure the
     
     <strong class="source-inline">
      
       DbContext
      
     </strong>
     
      created in the ASP.NET Core 9
     
     
      
       DI container.
      
     
    </li>
    <li>
     
      
       Add migrations.
      
     
    </li>
    <li>
     
      Update
     
     
      
       the database.
      
     
    </li>
   </ol>
   <p>
    
     As you perform these steps, you will notice some differences from implementing communication with the database in the traditional approach using
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     ,
    
    
     
      and
     
    
    
     <strong class="source-inline">
      
       SqlDataReader
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Open the project in Visual Studio Code with the following command in
    
    
     
      the terminal:
     
    
   </p>
   <pre class="console">
code .</pre>
   <p>
    
     The complete project has the structure shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .8
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.8 – Banking project project structure" src="img/B21788_05_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.8 – Banking project project structure
    
   </p>
   <p>
    
     To configure the
    
    <a id="_idIndexMarker367">
    </a>
    
     connection string, we will use
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     .
    
    
     It is important to mention that information containing user credentials should not be available directly in a code repository.
    
    
     The best practice is to use secrets or even a configuration server such
    
    <a id="_idIndexMarker368">
    </a>
    
     as
    
    <strong class="bold">
     
      Azure App Configurator
     
    </strong>
    
     to manage this information.
    
    
     We’ll talk more about good security practices in
    
    <a href="B21788_06.xhtml#_idTextAnchor093">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     For teaching purposes, we will add the connection string to the
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
{
   "Logging": {
     "LogLevel": {
       "Default": "Information",
       "Microsoft.AspNetCore": "Warning"
     }
   },
   "AllowedHosts": "*",
   <strong class="bold">"ConnectionStrings": {</strong>
<strong class="bold">    "BankingDbContext": "Server=localhost;</strong>
<strong class="bold">      Database=dbBanking;User Id=sa;</strong>
<strong class="bold">      Password=Password123;</strong>
<strong class="bold">      TrustServerCertificate=True"</strong>
<strong class="bold">   }</strong>
}</pre>
   <p>
    
     We are using the
    
    <a id="_idIndexMarker369">
    </a>
    
     same connection string as the database server running through Docker, with an additional default,
    
    <strong class="source-inline">
     
      Database=dbBanking
     
    </strong>
    
     , which will be used for this application.
    
    
     The JSON
    
    <strong class="source-inline">
     
      ConnectionStrings
     
    </strong>
    
     object is an ASP.NET Core 9 convention, with each property of this object representing a different
    
    
     
      connection string.
     
    
   </p>
   <p>
    
     EF Core does all the work of managing the connection and mapping database entities into C# objects, as well as generating SQL commands.
    
    
     For this to be possible, there is a base object that we must use to map the domain classes.
    
    
     This base object is
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       DbContext
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      DBContext
     
    </strong>
    
     implements
    
    <a id="_idIndexMarker370">
    </a>
    
     the
    
    <strong class="bold">
     
      Unit of Work
     
    </strong>
    
     design pattern, managing all states of the objects manipulated in memory and persisting changes
    
    
     
      when necessary.
     
    
   </p>
   <p class="callout-heading">
    
     Unit of Work pattern
    
   </p>
   <p class="callout">
    
     The Unit of Work design pattern
    
    <a id="_idIndexMarker371">
    </a>
    
     is used in different contexts, favoring the separation of responsibilities, such as separating all the business rules of an application from the responsibility of communicating with and manipulating data in
    
    
     
      a database.
     
    
   </p>
   <p class="callout">
    
     Learn more about the
    
    <a id="_idIndexMarker372">
    </a>
    
     Unit of Work pattern
    
    
     
      at
     
    
    <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance">
     
      
       https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     According to the
    
    <a id="_idIndexMarker373">
    </a>
    
     project structure shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .8
     
    </em>
    
     , we will create a class called
    
    <strong class="source-inline">
     
      BankingDbContext.cs
     
    </strong>
    
     that will have the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
namespace WorkingWithOrm.Context;
using Microsoft.EntityFrameworkCore;
using WorkingWithOrm.Model;
public class BankingDbContext : <strong class="bold">DbContext</strong>
{
    public BankingDbContext(<strong class="bold">DbContextOptions</strong>
<strong class="bold">      &lt;BankingDbContext&gt; options</strong>) : base(options)
    {
    }
<strong class="bold">    public DbSet&lt;Account&gt; Accounts { get; set; }</strong>
<strong class="bold">    public DbSet&lt;Customer&gt; Customers { get; set; }</strong>
<strong class="bold">    public DbSet&lt;Movement&gt; Movements { get; set; }</strong>
}</pre>
   <p>
    
     For the
    
    <a id="_idIndexMarker374">
    </a>
    
     application we are creating, the class is quite simple.
    
    
     Let’s explore the most important points of
    
    
     
      this code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       DbContext
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       BankingDbContext
      
     </strong>
     
      class inherits from the
     
     <strong class="source-inline">
      
       DbContext
      
     </strong>
     
      superclass, which has the necessary abstractions for communication between the application and the database, state management, mapping, and the generation of
     
     
      
       SQL commands.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       BankingDbContext
      
     </strong>
     
      constructor: The class constructor receives, as a parameter, the generic
     
     <strong class="source-inline">
      
       DbContextOptions&lt;BankingDbContext&gt;
      
     </strong>
     
      class, which allows us to pre-define configurations that will be used in the DI container to create an instance of the
     
     <strong class="source-inline">
      
       DbContext
      
     </strong>
     
      object.
     
     
      The constructor can also receive a connection string; however, it is good practice to use the C#
     
     
      
       options pattern.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       DbSet
      
     </strong>
     
      : Each property of the
     
     <strong class="source-inline">
      
       DbSet
      
     </strong>
     
      type represents a table in the database, and it is these properties that provide information to EF Core to transform data from tables into objects and
     
     
      
       vice versa.
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     C# options pattern
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="bold">
     
      options pattern
     
    </strong>
    
     is
    
    <a id="_idIndexMarker375">
    </a>
    
     widely used in the .NET platform with the aim of providing strongly typed access to groups of
    
    
     
      related settings.
     
    
   </p>
   <p class="callout">
    
     Learn more about the
    
    <a id="_idIndexMarker376">
    </a>
    
     options pattern
    
    
     
      at
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     class is now complete and provides everything needed to interact with the SQL database.
    
    
     The mapping model used, in this case, is based on the EF Core convention, which infers the name of the table and columns from the name of the class and
    
    
     
      its properties.
     
    
   </p>
   <p>
    
     Let’s look at the
    
    
     <strong class="source-inline">
      
       Account.cs
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
public class Account
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Balance { get; set; }
    public int <strong class="bold">CustomerId</strong> { get; set; }
    public virtual <strong class="bold">Customer</strong>? Customer { get; set; }
    public virtual <strong class="bold">ICollection&lt;Movement&gt;</strong>? Movements
      { get; set; }
}</pre>
   <p>
    
     Based on this class and the
    
    <a id="_idIndexMarker377">
    </a>
    
     EF Core convention, it is expected that there will be a table named
    
    <strong class="source-inline">
     
      Account
     
    </strong>
    
     and columns called
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Balance
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      CustomerId
     
    </strong>
    
     in
    
    
     
      the database.
     
    
   </p>
   <p>
    
     But there is, in addition, a property called
    
    <strong class="source-inline">
     
      Customer
     
    </strong>
    
     and a collection of
    
    <strong class="source-inline">
     
      Movement
     
    </strong>
    
     objects.
    
    
     Due to the existence of the
    
    <strong class="source-inline">
     
      CustomerId
     
    </strong>
    
     property, EF infers that there is a relationship with the
    
    <strong class="source-inline">
     
      Customer
     
    </strong>
    
     table, which has a foreign key (
    
    <strong class="source-inline">
     
      &lt;TableName&gt;+Id
     
    </strong>
    
     ) in the
    
    <strong class="source-inline">
     
      Account
     
    </strong>
    
     table.
    
    
     Likewise, because there is a
    
    <strong class="source-inline">
     
      Movement
     
    </strong>
    
     collection, EF infers that the
    
    <strong class="source-inline">
     
      Account
     
    </strong>
    
     class may have one or more
    
    <strong class="source-inline">
     
      Movements
     
    </strong>
    
     in the
    
    
     <strong class="source-inline">
      
       Movement
      
     </strong>
    
    
     
      table.
     
    
   </p>
   <p>
    
     However, if it is necessary to follow different naming standards from database to database, the names of tables, columns, primary keys, and so on can be mapped directly into the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     class using the fluent API.
    
    
     This can be done using data annotation in the domain classes, or even by implementing a specific mapping class for each entity using the
    
    
     <strong class="source-inline">
      
       IEntityTypeConfiguration&lt;TEntity&gt;
      
     </strong>
    
    
     
      interface.
     
    
   </p>
   <p>
    
     The following code example represents a custom or manual mapping of the
    
    <strong class="source-inline">
     
      Customer
     
    </strong>
    
     class to the
    
    <strong class="source-inline">
     
      tbl_customer
     
    </strong>
    
     table.
    
    
     In order to customize the mapping of classes in database entities, it is necessary to override the
    
    <strong class="source-inline">
     
      OnModelCreating
     
    </strong>
    
     method, inherited from the
    
    
     <strong class="source-inline">
      
       DbContext
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
override protected void OnModelCreating(
  ModelBuilder modelBuilder)
  {
    modelBuilder.Entity&lt;Customer&gt;(obj =&gt; {
      obj.ToTable("tbl_customer");
      obj.HasKey(c =&gt; c.Id).HasName
        ("pk_customer_id");
      obj.Property(c =&gt; c.Name).HasColumnName
        ("customer_name").HasMaxLength(100).IsRequired();
      obj.HasMany(c =&gt; c.Accounts)
        .WithOne(a =&gt; a.Customer)
        .HasForeignKey(a =&gt; a.CustomerId);
    });
  }</pre>
   <p>
    
     As you can see in the code, it is possible to define all the attributes required for the correct mapping
    
    
     
      of entities.
     
    
   </p>
   <p>
    
     With the
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     class finalized, we must configure it in the DI container and configure the
    
    
     
      connection string.
     
    
   </p>
   <p>
    
     We will add the following line
    
    <a id="_idIndexMarker378">
    </a>
    
     to the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
// Code omitted for readability
<strong class="bold">builder.Services.AddDbContext&lt;BankingDbContext&gt;(options =&gt;</strong>
<strong class="bold">  options.UseSqlServer(builder.Configuration</strong>
<strong class="bold">    .GetConnectionString("BankingDbContext")));</strong>
var app = builder.Build();
// Code omitted for readability</pre>
   <p>
    
     We use the
    
    <strong class="source-inline">
     
      AddDbContext&lt;BankingDbContext&gt;
     
    </strong>
    
     extension method to configure the connection string that will be used for the connection.
    
    
     Note that we are using the
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     property, which is expected in the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     constructor, and through the use of the
    
    <strong class="source-inline">
     
      UseSqlServer
     
    </strong>
    
     extension method, we are recovering the connection string that we configured in the
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     The application is practically ready to communicate with the database; however, it will still be necessary to add migrations and update
    
    
     
      the database.
     
    
   </p>
   <p>
    
     Open the terminal in the project directory and run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet ef migrations add InitialDatabase</pre>
   <p>
    
     This command uses the EF CLI tool that we installed previously, adding migrations with the
    
    
     
      name
     
    
    
     <strong class="source-inline">
      
       InitialDatabase
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The objective of
    
    <a id="_idIndexMarker379">
    </a>
    
     migrations is to allow the application and the database to remain synchronized in the objects that are used.
    
    
     In real applications, changes to the database, such as creating new tables or adding or removing columns, can happen constantly.
    
    
     These changes impact both the database in question and the application that consumes the objects in this database.
    
    
     When adding a migration, such as in the preceding command, we are taking a picture of the domain model that the application uses, and EF Core generates the scripts that will be applied to the database to keep it up
    
    
     
      to date.
     
    
   </p>
   <p>
    
     Migrations create a set of classes in the project.
    
    
     These classes must not be changed manually.
    
    
     As we can see in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .9
     
    </em>
    
     , three files were added to the application’s
    
    
     <strong class="source-inline">
      
       Migrations
      
     </strong>
    
    
     
      folder:
     
    
   </p>
   <div><div><img alt="Figure 5.9 – Initial database migration files" src="img/B21788_05_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.9 – Initial database migration files
    
   </p>
   <p>
    
     When observing a snippet of code extracted from the
    
    <strong class="source-inline">
     
      InitialDatabase.cs
     
    </strong>
    
     suffix file, we observe that they are resource creation scripts in
    
    
     
      the database:
     
    
   </p>
   <pre class="source-code">
…
protected override void Up(MigrationBuilder
  migrationBuilder)
  {
    migrationBuilder.CreateTable(
      name: "Customers",
      columns: table =&gt; new
      {
          Id = table.Column&lt;int&gt;(type: "int",
            nullable: false)
            .Annotation("SqlServer:Identity", "1, 1"),
          Name = table.Column&lt;string&gt;(
            type: "nvarchar(max)", nullable: false)
        },
        constraints: table =&gt;
        {
          table.PrimaryKey("PK_Customers", x =&gt; x.Id);
        });
…</pre>
   <p>
    
     With each change in your application’s domain model, a new migration must be added.
    
    
     This way, you will maintain a history of changes, and this will facilitate the maintenance and evolution of the database and
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Now, you will need to update the
    
    <a id="_idIndexMarker380">
    </a>
    
     database.
    
    
     So far, we have not run any SQL scripts on SQL Server, much less created the database.
    
    
     Instead of opening Azure Data Studio to perform this task, we will use the EF Core CLI tool to update the database according to the version mapped in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     To do this, run the following command in the terminal, in the
    
    
     
      project directory:
     
    
   </p>
   <pre class="console">
dotnet ef database update</pre>
   <p>
    
     The CLI tool will
    
    <a id="_idIndexMarker381">
    </a>
    
     connect to SQL Server and execute scripts to create the database and tables mapped in the application.
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .10
     
    </em>
    
     displays the
    
    
     
      created objects:
     
    
   </p>
   <div><div><img alt="Figure 5.10 – Objects created in the database using the EF CLI tool" src="img/B21788_05_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.10 – Objects created in the database using the EF CLI tool
    
   </p>
   <p>
    
     All communication with the database has been properly configured.
    
    
     The time has come to add the APIs to interact with the database.
    
    
     Therefore, create the following routes in the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/customers", async (CancellationToken
  cancellationToken, <strong class="bold">BankingDbContext dbContext</strong>) =&gt;
  {
    var customers = await <strong class="bold">dbContext.Customers</strong>
<strong class="bold">      .ToListAsync(</strong>cancellationToken<strong class="bold">);</strong>
    return Results.Ok(customers);
        });
    app.MapGet("/customers/{id}", async (int id,
      BankingDbContext dbContext,
      CancellationToken cancellationToken) =&gt;
      {
        var customer = await dbContext.Customers
          .FindAsync(id, cancellationToken);
        return Results.Ok(customer);
      });
      app.MapPost("/customers", async (
        [FromBody]Customer customer,
        BankingDbContext dbContext,
        CancellationToken cancellationToken) =&gt;
        {
          <strong class="bold">await dbContext.Customers.AddAsync(</strong>
<strong class="bold">            customer, </strong>cancellationToken<strong class="bold">);</strong>
<strong class="bold">          await dbContext</strong>
<strong class="bold">            .SaveChangesAsync(</strong>cancellationToken<strong class="bold">);</strong>
          return Results.Created();
        });</pre>
   <p>
    
     The above routes perform operations on the Customer table.
    
    
     Notice the first Get method.
    
    
     This method receives as a parameter an instance of the
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     object that is automatically resolved through the .NET Core dependency injection
    
    
     
      DI context.
     
    
   </p>
   <p>
    
     Then, using the
    
    <strong class="source-inline">
     
      dbContext.Customers.ToListAsync(cancellationToken)
     
    </strong>
    
     code, all existing customers in the database are retrieved.
    
    
     We only use the
    
    <strong class="source-inline">
     
      Customers
     
    </strong>
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      DbSet
     
    </strong>
    
     , and EF Core takes care of creating the SQL query to select the records.
    
    
     There is no need to open connections, create commands, or even map manually.
    
    
     Everything is
    
    
     
      done transparently.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Post
     
    </strong>
    
     method
    
    <a id="_idIndexMarker382">
    </a>
    
     performs the
    
    
     
      following operations:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       dbContext.Customers.AddAsync
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       Customer
      
     </strong>
     
      object is passed as a parameter in the request body.
     
     
      This is then added to
     
     <strong class="source-inline">
      
       DbSet
      
     </strong>
     
      in the same way as we would add an item to
     
     
      
       a list.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       dbContext.SaveChangesAsync
      
     </strong>
     
      : When executing this method,
     
     <strong class="source-inline">
      
       dbContext
      
     </strong>
     
      updates the database.
     
     
      This means that if there were other operations on the
     
     <strong class="source-inline">
      
       DbSets
      
     </strong>
     
      , such as removal, updates, or additions, this information would only be updated in the
     
     <a id="_idIndexMarker383">
     </a>
     
      database after executing the
     
     <strong class="source-inline">
      
       SaveChanges
      
     </strong>
     
      or
     
     
      <strong class="source-inline">
       
        SaveChangesAsync
       
      </strong>
     
     
      
       methods.
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Asynchronous processing and cancellation token
    
   </p>
   <p class="callout">
    
     Asynchronous processing is a
    
    <a id="_idIndexMarker384">
    </a>
    
     fundamental aspect of modern web application development.
    
    
     In ASP.NET Core 9, asynchronous methods allow the server to handle more requests simultaneously by not blocking threads during operations such as database queries, file access, or consuming HTTP resources.
    
    
     This approach allows the application to scale and respond quickly under load.
    
    
     The
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     keywords make it possible to write asynchronous code that is easy to maintain and read, and the .NET platform abstracts the complexity of managing
    
    
     
      asynchronous mechanisms.
     
    
   </p>
   <p class="callout">
    
     In conjunction with asynchronous methods, it is a good practice to use cancellation tokens, which allow applications to properly handle the cancellation of requests, making applications more responsive and resilient.
    
    
     The
    
    <a id="_idIndexMarker385">
    </a>
    
     cancellation token associated with an asynchronous method propagates a cancellation signal throughout all of the application’s asynchronous operations, allowing them to terminate early and free up resources.
    
    
     ASP.NET Core 9 and C# simplify asynchronous programming and the use of cancellation tokens, providing a robust framework that ensures applications remain responsive even under
    
    
     
      varying loads.
     
    
   </p>
   <p class="callout">
    
     For more information about
    
    <a id="_idIndexMarker386">
    </a>
    
     asynchronous programming
    
    <a id="_idIndexMarker387">
    </a>
    
     and token cancellation, visit
    
    <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">
     
      https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/
     
    </a>
    
     
      and
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads">
     
      
       https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     With this, we can run the application to interact with the database in a simple way, making it possible to perform any operations using
    
    <strong class="bold">
     
      Language Integrated Query
     
    </strong>
    
     (
    
    <strong class="bold">
     
      LINQ
     
    </strong>
    
     ), such as advanced
    
    <a id="_idIndexMarker388">
    </a>
    
     filters or obtaining records ordered by
    
    
     
      specific columns.
     
    
   </p>
   <p>
    
     The use of an ORM provides several benefits for high-level applications and, likewise, several challenges when we delegate the management of data management complexity to the ORM.
    
    
     This makes them slow, since, despite several innovations and improvements, in many cases, they are not the best choice when it comes
    
    
     
      to performance.
     
    
   </p>
   <p>
    
     In this case, Micro ORMs are great options; they have similar performance to traditional approaches and mapping capabilities like ORMs.
    
    
     Therefore, let’s explore how Dapper can be used to add more features to the database
    
    
     
      communication model.
     
    
   </p>
   <h2 id="_idParaDest-90">
    <a id="_idTextAnchor091">
    </a>
    
     Dapper
    
   </h2>
   <p>
    <strong class="bold">
     
      Dapper
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker389">
    </a>
    
     Micro ORM that gives us the ability to interact with the database in a performative way while mapping database entities into
    
    
     
      C# objects.
     
    
   </p>
   <p>
    
     It is a simple-to-use yet powerful library.
    
    
     Its mapping model is interesting and flexible, allowing you to create different types of query result projections quickly
    
    
     
      and effectively.
     
    
   </p>
   <p>
    
     Dapper and EF Core are not mutually exclusive technologies, and using both approaches in a project can provide
    
    
     
      great benefits.
     
    
   </p>
   <p>
    
     Let’s add the Dapper library to the project created previously by executing the following command in the terminal, in the
    
    
     
      application directory:
     
    
   </p>
   <pre class="console">
dotnet add package Dapper</pre>
   <p>
    
     All the prerequisites required to work with Dapper have already been implemented in the project, the main one being the connection string that we configured in the
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     Let’s change the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file to add two new routes that use Dapper to perform a query where we can
    
    <a id="_idIndexMarker390">
    </a>
    
     obtain all the customers in the database and query a customer
    
    
     
      by
     
    
    
     <strong class="source-inline">
      
       Id
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
<strong class="bold">builder.Services.AddScoped(_ =&gt; new SqlConnection(builder</strong>
<strong class="bold">  .Configuration.GetConnectionString("BankingDbContext")));</strong>
var app = builder.Build();
// Codes omitted for readability
app.MapGet("GetAllCustomersUsingDapper", async(SqlConnection connection) =&gt;
{
  <strong class="bold">var customers = await connection.QueryAsync&lt;Customer&gt;</strong>
<strong class="bold">    ("SELECT Id, Name FROM Customers ORDER BY Name");</strong>
  return Results.Ok(customers);
});
app.MapGet("GetCustomerByIdUsingDapper",
  async(int id, SqlConnection connection) =&gt;
{
    <strong class="bold">var customer = await connection</strong>
<strong class="bold">      .QueryFirstOrDefaultAsync&lt;Customer&gt;("SELECT Id,</strong>
<strong class="bold">      Name FROM Customers WHERE Id = @Id", new {</strong>
<strong class="bold">        Id = id });</strong>
    if (customer is null) return Results.NotFound();
    return Results.Ok(customer);
});</pre>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker391">
    </a>
    
     explore the
    
    
     
      preceding code:
     
    
   </p>
   <ul>
    <li>
     
      In C# and ASP.NET Core 9, the
     
     <strong class="source-inline">
      
       _ =&gt; new
      
     </strong>
     
      syntax is known as discarded lambda and is used when there is no need to use the input parameter of the
     
     
      
       lambda expression.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       SqlConnection
      
     </strong>
     
      : We are adding the
     
     <strong class="source-inline">
      
       SqlConnection
      
     </strong>
     
      object to the DI container using the same connection string used by the
     
     <strong class="source-inline">
      
       DbContext
      
     </strong>
     
      .
     
     
      We are using the
     
     <strong class="source-inline">
      
       AddScoped
      
     </strong>
     
      method, which means that each time the
     
     <strong class="source-inline">
      
       SqlConnection
      
     </strong>
     
      object is used during a request, it will
     
     
      
       be reused.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       QueryAsync
      
     </strong>
     
      : We are getting all the customers from the database using a simple SQL query.
     
     
      The desired columns have been added to the SQL command, along with an
     
     <strong class="source-inline">
      
       ORDER BY NAME
      
     </strong>
     
      statement.
     
     <strong class="source-inline">
      
       QueryAsync
      
     </strong>
     
      is a
     
     <strong class="source-inline">
      
       SqlConnection
      
     </strong>
     
      extension method and, when it obtains the result, it will automatically map the data to C# objects based on the names of the properties
     
     
      
       and columns.
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Get all the data from the database
    
   </p>
   <p class="callout">
    
     Generally, it is not recommended to fetch all the records from a database in a single query as there may be thousands or millions of records in the database tables, which can cause performance problems.
    
    
     Keep in mind that the example proposed here is intended to facilitate understanding of the concept and should not be used in production applications.
    
    
     The recommended solution is to use pagination.
    
    
     Pagination involves breaking data into small, manageable chunks.
    
    
     To learn more, the following page contains implementation
    
    
     
      examples:
     
    
    <a href="https://learn.microsoft.com/en-us/ef/core/querying/pagination">
     
      
       https://learn.microsoft.com/en-us/ef/core/querying/pagination
      
     
    </a>
    
     
      .
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       QueryFirstOrDefaultAsync
      
     </strong>
     
      : In the same way as the previous method, a query is made in the database and if the record is found, it will be returned and mapped to a Customer object.
     
     
      If the record is not found, then it returns the value
     
     <strong class="source-inline">
      
       Null
      
     </strong>
     
      .
     
     
      The important point
     
     <a id="_idIndexMarker392">
     </a>
     
      in the SQL query is the use of the
     
     <strong class="source-inline">
      
       @Id
      
     </strong>
     
      parameter.
     
     
      Dapper methods can substitute named parameters in the string.
     
     
      So, after defining the SQL command with the parameters, we must define an object that contains the named properties of the same parameters as the parameters defined in the SQL command.
     
     
      In the code example above, the defined parameter is named
     
     <strong class="source-inline">
      
       @Id
      
     </strong>
     
      , which requires that the object passed as a parameter has a property named Id, like the snippet
     
     <strong class="source-inline">
      
       new {Id = id}
      
     </strong>
     
      .
     
     
      Using an object allows us to define more than one parameter
     
     
      
       if necessary.
      
     
    </li>
   </ul>
   <p>
    
     The use of
    
    <a id="_idIndexMarker393">
    </a>
    
     SQL commands, in this case, allows us to create more performant queries for different purposes.
    
    
     Likewise, Dapper can be used to add, change, and remove records in
    
    
     
      the database.
     
    
   </p>
   <p>
    
     In this case, we do not need to manage the SQL connections that are controlled by the DI container, and we benefit from the ORM’s automatic
    
    
     
      mapping approach.
     
    
   </p>
   <p class="callout-heading">
    
     Dapper SqlBuilder
    
   </p>
   <p class="callout">
    
     Dapper also has an extension that makes it easier to write SQL commands in the format needed by the Micro ORM called Dapper SQL Builder.
    
    
     It is a very useful extension, even when it is necessary to manipulate
    
    <a id="_idIndexMarker394">
    </a>
    
     SQL strings according to
    
    
     
      some conditions.
     
    
   </p>
   <p class="callout">
    
     You can find out more about the
    
    <a id="_idIndexMarker395">
    </a>
    
     Dapper SQL Builder extension by
    
    
     
      visiting
     
    
    <a href="https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder">
     
      
       https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     As we have seen, both ORM and Micro ORM are great allies in the communication model with the database and can be used together, providing different benefits in
    
    
     
      different contexts.
     
    
   </p>
   <p>
    
     This flexibility of ASP.NET Core 9 allows us to create different types of applications, from the simplest to the most complex, and interact with databases using
    
    
     
      best practices.
     
    
   </p>
   <h1 id="_idParaDest-91">
    <a id="_idTextAnchor092">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned about data persistence in ASP.NET Core 9, exploring how applications interact with databases to store and manage critical information.
    
    
     You’ve compared the strengths of relational (SQL) and non-relational (NoSQL) databases, allowing you to choose the right fit for your project.
    
    
     Additionally, you’ve seen how ORMs such as EF Core simplify development by mapping objects to database records, and you’ve learned about the benefits of Micro ORMs such as Dapper for fine-grained control over performance-critical
    
    
     
      database operations.
     
    
   </p>
   <p>
    
     We’ll take another step toward developing high-quality applications by learning about security best practices in
    
    <a href="B21788_06.xhtml#_idTextAnchor093">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     .
    
    
     We’ll explore essential best practices and strategies for defending your applications against vulnerabilities.
    
    
     You’ll learn how to ensure user data protection, authentication security, and overall application integrity – vital foundations for building robust, reliable
    
    
     
      web applications.
     
    
   </p>
  </div>
 </body></html>