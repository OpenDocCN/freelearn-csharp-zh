<html><head></head><body>
		<div><h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor206"/>13</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor207"/>Applying Cross-Cutting Concerns</h1>
			<p>As software projects evolve, they gain a certain structure, and if the team is disciplined, it will be somewhat consistent. When you get more team members, you might even document the structure. In addition to structure, you might also have ways of doing things and clear recipes of what needs to be done when creating different types of functionalities for the different parts of the stack. For global ownership, you might have these written down as well.</p>
			<p>This is where cross-cutting concerns can come to the rescue. In this chapter, we will look at how to increase productivity for you as a developer by removing mundane tasks and improving consistency, and reducing risks. We will also look at how cross-cutting concerns can improve the maintainability of your software.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>What are cross-cutting concerns?</li>
				<li>Leveraging the ASP.NET pipeline</li>
				<li>Authorization based on metadata or structure</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor208"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13</a>), and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>).</p>
			<p>You will need Postman (<a href="https://www.postman.com">https://www.postman.com</a>) for testing the APIs created in this chapter.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor209"/>What are cross-cutting concerns?</h1>
			<p>As the lead-in to <a id="_idIndexMarker460"/>the chapter suggests, you might find yourself in your project with guidelines, formalized or not, that give you recipes for how to do things. For instance, to<a id="_idIndexMarker461"/> write a <strong class="bo d">representational state transfer</strong> (<strong class="bo d">REST</strong>) API that performs actions in your application, you might have a list of things defined that is there to help you remember what to do:</p>
			<ul>
				<li>Check authorization</li>
				<li>Check whether the input is valid</li>
				<li>Check whether the action is allowed as per business rules</li>
				<li>Add logging for the action</li>
				<li>Perform the action by calling the domain logic</li>
				<li>Translate the result from the domain to something digestible for REST consumption</li>
				<li>Remember to wrap the call to the domain in <strong class="source-in ine">try {} catch {}</strong> and return the correct error</li>
			</ul>
			<p>For each of these steps, there is always the risk that the developer will forget. This can pose a risk, cause security issues, data consistency, or other problems.</p>
			<p>Personally, I’m a huge fan of automating anything that is repetitive. Computers are really good at doing repetitive tasks, so why not let the human in front focus on delivering the business value?</p>
			<p>Cross-cutting concerns are basically those things that are applied once and henceforth continue to be there. Some cross-cutting concerns can be entirely automatic and need no extra intervention from the developer once applied, while others tend to be more configurable and context-based.</p>
			<p>Logging is probably the most canonical example of a cross-cutting concern. If you, for instance, know what to add in a log statement for every call to a Web API controller in your ASP.NET application, you can quite easily do so by adding an action filter.</p>
			<p>I tend to focus a lot on how we can boost the productivity of a team. With that in mind, you can do quite a bit of automation. To understand this better, we can use an example from ASP.NET Web APIs. Let’s say you’re building an application that has a frontend, and you need to provide an API for the frontend. Typically, your domain logic shouldn’t be in the API layer, as that is just a transport mechanism. An opportunity here is to automatically generate the API layer from the domain layer based on a convention. The convention could be derived from the namespace that could then automatically create the correct route. This would then remove an entire layer.</p>
			<p>One of the possible benefits of applying cross-cutting concerns is that you end up writing less code in the implementations where you’d normally add the things it automates. This is also a good thing from a maintenance perspective. It makes it easier to maintain. For instance, if you want to change the behavior of your system rather than having to change it in multiple places, you’d have a single place to change it.</p>
			<p>One of my favorite cross-cutting concerns is for Web APIs to have a consistent result and also not just <a id="_idIndexMarker462"/>rely on the HTTP status codes but rather consistently include all needed information to the consumer about the cal<a id="_idTextAnchor210"/>l.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor211"/>Leveraging the ASP.NET pipeline</h1>
			<p>REST APIs <a id="_idIndexMarker463"/>are based on the HTTP standard. The standard is a protocol standard and will not necessarily reflect in a good way what really happened when you performed an operation.</p>
			<p>One way to do this would be to create a common result object that all Web API controller actions need to return. But that would then become one of these recipes that could be forgotten and leave the solution in an inconsistent state.</p>
			<p>The idea of having a common result object is undoubtedly desirable, but we should work towards returning it automatically for all Web API calls. However, there is a difference between performing an operation and getting data. Basically, in HTTP, that is what the different verbs are for, HTTP GET represents getting data, while verbs such as POST, PUT, or DELETE represent the operations you want to perform.</p>
			<p>These types of operations are typically what you tend to perform as operations on a database in a data-driven application. You’ll often use the same model for all the operations, and you’re basically just modifying data.</p>
			<p>I’m an advocate for the <strong class="bo d">Command Query Responsibility Segregation</strong> (<strong class="bo d">CQRS</strong>) principle, coined by Greg Young (<a href="https://www.martinfowler.com/bliki/CQRS.html">https://www.martinfowler.com/bliki/CQRS.html</a>), which is a further formalization of Bertrand Meyers’ <strong class="bo d">Command Query Separation</strong> (<strong class="bo d">CQS</strong>) principle (<a href="https://www.martinfowler.com/bliki/CommandQuerySeparation.html">https://www.martinfowler.com/bliki/CommandQuerySeparation.html</a>).</p>
			<p>The CQRS principle challenges the common approach of treating everything as data in a <strong class="bo d">Create, Read, Update, and Delete</strong> (<strong class="bo d">CRUD</strong>) manner. It focuses on explicitly modeling the state change in a system and represents the intention of changing with a <strong class="bo d">command</strong>, while retrieving data is represented as <strong class="bo d">queries</strong>. Since CQRS is an evolution of CQS, it also implies that commands represent a changing state and do not return a value, while queries return a value but do not change any state.</p>
			<p>We’re not going to dive any deeper into CQRS or CQS, but we want to utilize the concept of command and, with that, limit the surface area for what we want to support in the sample in this chapter. The sample here has nothing to do with CQRS, but being an <a id="_idIndexMarker464"/>advocate for it, I figured I’d slip it into the conversation, hoping it triggers some curiosity…h<a id="_idTextAnchor212"/>aha.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor213"/>Building consistent result objects</h2>
			<p>Let’s build a <a id="_idIndexMarker465"/>simple system that <a id="_idIndexMarker466"/>registers employees exposed as a REST API. The goal is to provide a consistent result object for all commands being performed. We define a command in this context to be an HTTP POST call to any Web API controller.</p>
			<p>Start by creating a folder called <strong class="source-in ine">Chapter13</strong>. Change into this folder in your command line and create a new web-based project:</p>
			<pre class="source-code">
dotnet new web</pre>
			<p>Let’s take advantage of the <strong class="bo d">Fundamentals</strong> project in the GitHub repository mentioned in the <em class="ita ic">Technical requirements</em> section. You should add a project reference to it for this chapter by doing the following in your terminal:</p>
			<pre class="source-code">
dotnet add reference ../Fundamentals/Fundamentals.csproj</pre>
			<p>We will leverage the concept of an <strong class="bo d">action filter</strong>, a building block provided by ASP.NET Core. In <a href="B19418_03.xhtml#_idTextAnchor041"><em class="ita ic">Chapter 3</em></a>, <em class="ita ic">Demystifying through Existing Real-World Examples</em>, we touched on this building block for changing the default behavior related to validation—a good example of a cross-cutting concern.</p>
			<p>In ASP.NET Core, you, as a developer, have 100% flexibility on the behavior of your Web API controllers. That means that you decide what to return to the client, and you also decide whether or not you really care about the validation result. As we did in <a href="B19418_03.xhtml#_idTextAnchor041"><em class="ita ic">Chapter 3</em></a>, <em class="ita ic">Demystifying through Existing Real-World Examples</em>, we will be a bit more opinionated and not let the controller’s actions decide whether or not something is valid, but handle this in a cross-cutting manner. In addition to this, we want to wrap this up in a nice way for the consumer to get the result consistently.</p>
			<p>Create a subfolder in <strong class="source-in ine">Chapter13</strong> called <strong class="source-in ine">Commands</strong>. This is where you’ll create the necessary infrastructure.</p>
			<p>Let’s start by adding a consistent representation of a validation result. ASP.NET Core has the concept of <strong class="source-in ine">ModelError</strong>; you could use this directly if you’d like. But <strong class="source-in ine">ModelError</strong> represents both <strong class="source-in ine">Exception</strong> and a validation error. Those are different concerns that I personally would like to separate and make clearer. Being in an invalid state is different from having an exceptional non-recoverable state.</p>
			<p>Add a file in<a id="_idIndexMarker467"/> the <strong class="source-in ine">Commands</strong> folder<a id="_idIndexMarker468"/> called <strong class="source-in ine">ValidationResult.cs</strong>. You can make it look like the following:</p>
			<pre class="source-code">
namespace Chapter13.Commands;
public record ValidationResult(string Message, string Member);</pre>
			<p>The code introduces a type called <strong class="source-in ine">ValidationResult</strong>, which holds an error and the member the error is for. With the member clearly in the result, the consumer can map the error back to the object it sent. As a user interface, this is very useful as you can then easily show the error directly for the user input field that is invalid.</p>
			<p>Since ASP.NET Core has its <strong class="source-in ine">ModelError</strong> and you’ve now introduced a type representing just the validation result, you would want something that converts to your type. Add a file called <strong class="source-in ine">ModelErrorExtensions.cs</strong> to the <strong class="source-in ine">Commands</strong> folder and make it look like the following:</p>
			<pre class="source-code">
using Fundamentals;
using Microsoft.AspNetCore.Mvc.ModelBinding;
namespace Chapter13.Commands;
public static class ModelErrorExtensions
{
    public static ValidationResult ToValidationResult(this
      ModelError error, string member)
    {
        member = string.Join('.',
          member.Split('.').Select(_ =&gt; _.ToCamelCase()));
        return new ValidationResult(error.ErrorMessage,
          member);
    }
}</pre>
			<p>The code introduces an extension method for the <strong class="source-in ine">ModelError</strong> type and takes a specific member as a string to associate the error. By default, all JSON serialization in ASP.NET Core will be camel cased; the code, therefore, converts the member to camel case. It even supports deeply nested members by its navigational path represented <a id="_idIndexMarker469"/>with a dot for each level in<a id="_idIndexMarker470"/> the nested hierarchy. The <strong class="source-in ine">ToCamelCase()</strong> method call comes from <strong class="source-in ine">StringExtensions</strong> found in the <strong class="source-in ine">Fundamentals</strong> project referenced previously.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor214"/>CommandResult</h2>
			<p>With a representation<a id="_idIndexMarker471"/> of validation, you can now create<a id="_idIndexMarker472"/> the common result type for all operations or commands. We call this <strong class="source-in ine">CommandResult</strong>. It will encapsulate all the different aspects of an API call in a structured manner. To do this, add a file called <strong class="source-in ine">CommandResult.cs</strong> to the <strong class="source-in ine">Commands</strong> folder and make it look like the following:</p>
			<pre class="source-code">
namespace Chapter13.Commands;
public class CommandResult
{
    public Guid CorrelationId { get; init; }
    public bool IsSuccess =&gt; IsAuthorized &amp;&amp; IsValid &amp;&amp;
      !HasExceptions;
    public bool IsAuthorized { get; init; } = true;
    public bool IsValid =&gt; !ValidationResults.Any();
    public bool HasExceptions =&gt; ExceptionMessages.Any();
    public IEnumerable&lt;ValidationResult&gt; ValidationResults
      {get; init;} = Enumerable.Empty&lt;ValidationResult&gt;();
    public IEnumerable&lt;string&gt; ExceptionMessages { get;
      init; } = Enumerable.Empty&lt;string&gt;();
    public string ExceptionStackTrace { get; init; } =
      string.Empty;
    public object? Response { get; init; }
}</pre>
			<p>The code <a id="_idIndexMarker473"/>introduces a <strong class="source-in ine">CommandResult</strong> type that holds<a id="_idIndexMarker474"/> the concrete information related to validation results and whether there was an exception that might have occurred. In addition, it contains properties that allow you to easily conclude whether or not the result represents success. If the result is not a success, you can dive into whether or not it is related to authorization, validity, or an exception. It also introduces the <strong class="source-in ine">CorrelationId</strong> property, which identifies the call that was performed and could be used for tracing back in logs or tracing systems to understand whether an exception occurred and why it happened.</p>
			<p>With the formalized <strong class="source-in ine">CommandResult</strong> in place, you’ll need something that will produce this. This is where the ASP.NET Core action filter mechanism comes in handy.</p>
			<p>Add a file called <strong class="source-in ine">CommandActionFilter.cs</strong> to the <strong class="source-in ine">Commands</strong> folder and make it look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
namespace Chapter13.Commands;
public class CommandActionFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(
      ActionExecutingContext context,
      ActionExecutionDelegate next)
    {
        if (context.HttpContext.Request.Method ==
          HttpMethod.Post.Method)
        {
        }
        else
        {
            await next();
        }
    }
}</pre>
			<p>The code gives you a<a id="_idIndexMarker475"/> bare-bones action filter by<a id="_idIndexMarker476"/> implementing the <strong class="source-in ine">IAsyncActionFilter</strong> interface. The action filter is only interested in HTTP POST methods, as discussed earlier, and the rest of the implementation will take place within that clause. If it is not an HTTP POST method, it just forwards the request to the next middleware using the <strong class="source-in ine">next()</strong> method.</p>
			<p>Let’s start filling in the blanks. Inside the scope of the HTTP POST method clause, add the following code:</p>
			<pre class="source-code">
var exceptionMessages = new List&lt;string&gt;();
var exceptionStackTrace = string.Empty;
ActionExecutedContext? result = null;
object? response = null;
if (context.ModelState.IsValid)
{
    result = await next();
    if (result.Exception is not null)
    {
        var exception = result.Exception;
        exceptionStackTrace = exception.StackTrace;
        do
        {
            exceptionMessages.Add(exception.Message);
            exception = exception.InnerException;
        }
        while (exception is not null);
        result.Exception = null!;
    }
    if (result.Result is ObjectResult objectResult)
    {
        response = objectResult.Value;
    }
}</pre>
			<p>The code handles whether <strong class="source-in ine">ModelState</strong> is valid, meaning that all validators have run successfully and thus didn’t report anything invalid. This can mean one of two things:</p>
			<ul>
				<li>There is an exception</li>
				<li>It’s all OK, and the action was performed</li>
			</ul>
			<p>Within the <strong class="source-in ine">IsValid</strong> clause, the code calls <strong class="source-in ine">next()</strong>, which invokes the rest of the ASP.NET Core pipeline, ultimately calling the Web API controller action. The <strong class="source-in ine">result</strong> object is of the <strong class="source-in ine">ActionExecutedContext</strong> type, which holds information about the call to the action. On it, you’ll find <strong class="source-in ine">Exception</strong> and <strong class="source-in ine">Result</strong>. If there is an exception, the code unwinds all the messages recursively through <strong class="source-in ine">InnerException</strong> of each exception and then resets the <strong class="source-in ine">Exception</strong> property on the <strong class="source-in ine">result</strong> object to <strong class="source-in ine">null</strong> to avoid the default output of exceptions of ASP.NET Core from kicking in. If there are no exceptions, the code looks to capture the actual result if<a id="_idIndexMarker477"/> it is <strong class="source-in ine">ObjectResult</strong> from<a id="_idIndexMarker478"/> the action.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Even though we said commands should only perform a state change and not return a result, there are cases where you need to return something to the client. This could be important information, such as the key of an object created, which could then be leveraged directly by the consumer.</p>
			<p>The next thing you will need is to create an instance of <strong class="source-in ine">CommandResult</strong> and populate validation results and exceptions. Add the following code after the previous code:</p>
			<pre class="source-code">
var commandResult = new CommandResult
{
    CorrelationId = Guid.NewGuid(),
    ValidationResults = context.ModelState.SelectMany(_ =&gt;
      _.Value!.Errors.Select(e =&gt; e.ToValidationResult(
      _.Key))),
    ExceptionMessages = exceptionMessages.ToArray(),
    ExceptionStackTrace = exceptionStackTrace ??
      string.Empty,
    Response = response
};</pre>
			<p>The code creates an instance of the <strong class="source-in ine">CommandResult</strong> type and sets the properties on it. <strong class="source-in ine">CorrelationId</strong> is generated as a new <strong class="source-in ine">Guid</strong>, <strong class="source-in ine">ValidationResults</strong> is derived from <strong class="source-in ine">ModelState</strong> using the extension method you put in earlier for converting, and <strong class="source-in ine">ExceptionMessages</strong> comes from the code you put in for unwinding the exceptions. Then it puts in <strong class="source-in ine">ExceptionStackTrace</strong> if there is any or just <strong class="source-in ine">string.Empty</strong> if not. Finally, it forwards the response from the controller action directly, if any.</p>
			<p>Even though you’ve now encapsulated the result in something that is more readable and consistent for the consumer, it is still good practice to set the correct HTTP status code. Add<a id="_idIndexMarker479"/> the following code after the instantiation of <strong class="source-in ine">CommandResult</strong>:</p>
			<pre class="source-code">
if (!commandResult.IsAuthorized)
{
    context.HttpContext.Response.StatusCode = 401;
}
else if (!commandResult.IsValid)
{
    context.HttpContext.Response.StatusCode = 409;
}
else if (commandResult.HasExceptions)
{
    context.HttpContext.Response.StatusCode = 500;
}</pre>
			<p>The code says that when we’re not authorized, it is an HTTP <strong class="source-in ine">401</strong> status code, while if not valid, it is a <strong class="source-in ine">409</strong> status code, and if there is an exception, it is <strong class="source-in ine">500</strong>.</p>
			<p>For <strong class="source-in ine">CommandResult</strong> to be the actual result you get as output, you’ll need to explicitly set the <strong class="source-in ine">Result</strong> property on <strong class="source-in ine">ActionExecutedContext</strong> if we were validly authorized, or directly on <strong class="source-in ine">ActionExecutingContext</strong>, which is passed as the first parameter of the method of the action filter. Add the following code right after the previous block:</p>
			<pre class="source-code">
var actualResult = new ObjectResult(commandResult);
if (result is not null)
{
    result.Result = actualResult;
}
else
{
    context.Result = actualResult;
}</pre>
			<p>The code<a id="_idIndexMarker480"/> creates a new <strong class="source-in ine">ObjectResult</strong> with <strong class="source-in ine">CommandResult</strong> as <a id="_idIndexMarker481"/>content and sets it on either the <strong class="source-in ine">ActionExecutedContext</strong> object or <strong class="source-in ine">ActionExecutingContext</strong>. This will guarantee that you consistently get the same structure whether you’ve called the controller action or not.</p>
			<p>Let’s create a concrete sample that will make use of this new and improved pipeline. Add a file called <strong class="source-in ine">Employee.cs</strong> in the root of the <strong class="source-in ine">Chapter13</strong> project and make it look like the following:</p>
			<pre class="source-code">
using System.ComponentModel.DataAnnotations;
namespace Chapter13;
public record Employee(
    [Required]
    string FirstName,
    [Required]
    string LastName);</pre>
			<p>The code introduces a <strong class="source-in ine">record</strong> type that represents an employee with only two properties: <strong class="source-in ine">FirstName</strong> and <strong class="source-in ine">LastName</strong>. It instructs that these properties are both required by leveraging the <strong class="source-in ine">[</strong><strong class="source-in ine">Required]</strong> attribute.</p>
			<p>For the API to work you’ll need a controller. Add a file called <strong class="source-in ine">EmployeesController</strong> in <a id="_idIndexMarker482"/>the root of the <strong class="source-in ine">Chapter13</strong> project <a id="_idIndexMarker483"/>and make it look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
namespace Chapter13;
[Route("/api/employees")]
public class EmployeesController : Controller
{
    [HttpPost]
    public int Register([FromBody] Employee employee)
    {
        // Todo: Implement logic for actually
        // registering...
        return 1;
    }
}</pre>
			<p>The code introduces a controller with an action for registering an employee. The <strong class="source-in ine">[FromBody]</strong> attribute in front of the <strong class="source-in ine">employee</strong> argument says that the content of <strong class="source-in ine">employee</strong> is found in the HTTP request body. The action returns an integer and is hardcoded to return <strong class="source-in ine">1</strong>. Keep in mind that this is more of an example of where you could return your key if needed. It would be perfectly fine not to return anything and make the method return <strong class="source-in ine">void</strong>. With the <strong class="source-in ine">[Route]</strong> attribute in front of the class, the route for the API will be <strong class="source-in ine">/api/employees</strong>.</p>
			<p>Open up<a id="_idIndexMarker484"/> the <strong class="source-in ine">Program.cs</strong> file and make it look like <a id="_idIndexMarker485"/>the following:</p>
			<pre class="source-code">
using Chapter13.Commands;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers(mvcOptions =&gt; mvcOptions.Filters.
  Add&lt;CommandActionFilter&gt;());
var app = builder.Build();
app.MapControllers();
app.Run();</pre>
			<p>The code adds all controllers by convention and maps the routes of these. When adding controllers, the code adds <strong class="source-in ine">CommandActionFilter</strong> as a filter to the pipeline.</p>
			<p>That should be enough to take it for a spin. Run the project using the following command:</p>
			<pre class="source-code">
dotnet run</pre>
			<p>You should see a similar output to the following:</p>
			<pre class="source-code">
Building...
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: https://localhost:7126
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5234
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /Users/einari/Projects/Metaprogramming-in-C/
          Chapter13/</pre>
			<p>You can <a id="_idIndexMarker486"/>now<a id="_idIndexMarker487"/> test the API using Postman:</p>
			<div><div><img src="img/B19418_13_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Posting with Postman</p>
			<p>Set the verb to be <strong class="bo d">POST</strong>, and then use the URL from the output of your run and add <strong class="source-in ine">/api/employees</strong> to the URL. Then select <strong class="bo d">JSON</strong> in the <strong class="bo d">Body</strong> tab, add an empty JSON document, and click <strong class="bo d">Send</strong>.</p>
			<p>The response should be similar to the following:</p>
			<pre class="source-code">
{
    "correlationId": "f0910061-0e1d-494e-90c2-a7e7c246069f",
    "isSuccess": false,
    "isAuthorized": true,
    "isValid": false,
    "hasExceptions": false,
    "validationResults": [
        {
            "message": "The LastName field is required.",
            "member": "lastName"
        },
        {
            "message": "The FirstName field is required.",
            "member": "firstName"
        }
    ],
    "exceptionMessages": [],
    "exceptionStackTrace": "",
    "response": null
}</pre>
			<p>Use <strong class="source-in ine">POST</strong> for a<a id="_idIndexMarker488"/> valid <a id="_idIndexMarker489"/>object:</p>
			<pre class="source-code">
{
    "firstName": "Jane",
    "lastName": "Doe"
}</pre>
			<p>In Postman, you should then get a successful result back:</p>
			<div><div><img src="img/B19418_13_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – A successful posting in Postman</p>
			<p>You<a id="_idIndexMarker490"/> should <a id="_idIndexMarker491"/>see a response similar to the following:</p>
			<pre class="source-code">
{
    "correlationId": "f44600ee-02f2-4d0c-9187-f02ff02c9353",
    "isSuccess": true,
    "isAuthorized": true,
    "isValid": true,
    "hasExceptions": false,
    "validationResults": [],
    "exceptionMessages": [],
    "exceptionStackTrace": "",
    "response": 1
}</pre>
			<p>You now have a clear, consistent result object for all <strong class="source-in ine">POST</strong> actions. ASP.NET Core is very extensible<a id="_idIndexMarker492"/> and flexible, and most of the parts can<a id="_idIndexMarker493"/> be extended to perform cross-cutting concerns; a<a id="_idTextAnchor215"/>uthorization is a good example.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor216"/>Authorization based on metadata or structure</h1>
			<p>By default, the<a id="_idIndexMarker494"/> approach<a id="_idIndexMarker495"/> for setting authorization for controllers in ASP.NET Core uses the <strong class="source-in ine">[Authorize]</strong> attribute or the fluent interface when registering controllers or endpoints. For some scenarios, this can be very explicit, and in applications with a large number of controller endpoints, you might want to consider securing them in a cross-cutting manner.</p>
			<p>If sections of your application are just meant to be used by users with a given role, this could be a great candidate for applying security policies for all of these based on namespace. Through structure, we get the implicit metadata that follows the types, and we can use that as a way to make decisions for us.</p>
			<p>To do this, we need to put in a few things. First of all, we need to have a mechanism for authenticating users. For this sample, we will use hardcoded users to avoid the complexity of having to set up proper authentication with an identity provider.</p>
			<p>You’ll need a file called <strong class="source-in ine">HardCodedAuthenticationOptions.cs</strong> in the root of <strong class="source-in ine">Chapter13</strong> and then add the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Authentication;
namespace Chapter13;
public class HardCodedAuthenticationOptions :
  AuthenticationSchemeOptions
{
}</pre>
			<p>The code introduces an option type that will be used by the custom hardcoded identity provider. It doesn’t have any options since the provider will be completely hardcoded.</p>
			<p>Next, add a<a id="_idIndexMarker496"/> file <a id="_idIndexMarker497"/>called <strong class="source-in ine">HardCodedAuthenticationHandler.cs</strong> in the root of <strong class="source-in ine">Chapter13</strong> and make it look like the following:</p>
			<pre class="source-code">
using System.Security.Claims;
using System.Text.Encodings.Web;
using Microsoft.AspNetCore.Authentication;
using Microsoft.Extensions.Options;
namespace Chapter13;
public class HardCodedAuthenticationHandler : AuthenticationHandler&lt;HardCodedAuthenticationOptions&gt;
{
    public const string SchemeName =
      "HardCodedAuthenticationHandler";
    public HardCodedAuthenticationHandler(
        IOptionsMonitor&lt;HardCodedAuthenticationOptions&gt;
          options,
        ILoggerFactory logger,
        UrlEncoder encoder,
        ISystemClock clock) : base(options, logger,
          encoder, clock)
    {
    }
    protected override Task&lt;AuthenticateResult&gt;
      HandleAuthenticateAsync() =&gt; Task.FromResult(
        AuthenticateResult.Success(
            new AuthenticationTicket(
                new ClaimsPrincipal(
                    new ClaimsIdentity(
                        new[]
                        {
                            new Claim(ClaimTypes.Name,
                              "Bob"),
                            new Claim(ClaimTypes.Role,
                              "User")
                        },
                        SchemeName)), SchemeName)));
}</pre>
			<p>The <a id="_idIndexMarker498"/>code<a id="_idIndexMarker499"/> implements <strong class="source-in ine">AuthenticationHandler&lt;&gt;</strong> and takes the dependencies the base class needs into the constructor and passes these down. The <strong class="source-in ine">HandleAuthenticateAsync()</strong> method will always return a successful authentication with a hardcoded principal with an identity on it. For the time being, the identity has the role of <strong class="source-in ine">User</strong>.</p>
			<p>You will need an authorization policy that is specific to this sample. It should say you have to be an <strong class="source-in ine">Admin</strong> within namespaces starting with a specific string. In ASP.NET, this is done by implementing a requirement, which is basically the configuration object for the policy, and then a handler that is capable of handling the requirement.</p>
			<p>Add a file called <strong class="source-in ine">AdminForNamespace.cs</strong> in the root of <strong class="source-in ine">Chapter13</strong> and make it look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Authorization;
namespace Chapter13;
public class AdminForNamespace : IAuthorizationRequirement
{
    public AdminForNamespace(string @namespace)
    {
        Namespace = @namespace;
    }
    public string Namespace { get; }
}</pre>
			<p>The code <a id="_idIndexMarker500"/>holds<a id="_idIndexMarker501"/> the configuration in the form of a namespace string that will be used in the code that checks the policy. <strong class="source-in ine">IAuthorizationRequirement</strong> is an empty marker interface with nothing to implement.</p>
			<p>Next, you need the handler. Add a file called <strong class="source-in ine">AdminForNamespaceHandler.cs</strong> in the root of <strong class="source-in ine">Chapter13</strong> and make it look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc.Controllers;
namespace Chapter13;
public class AdminForNamespaceHandler : AuthorizationHandler&lt;AdminForNamespace&gt;
{
    protected override Task HandleRequirementAsync(
      AuthorizationHandlerContext context,
      AdminForNamespace requirement)
    {
        if (context.Resource is HttpContext httpContext)
        {
            var endpoint = httpContext.GetEndpoint();
            if (endpoint is not null)
            {
                var controllerActionDescriptor =
                  endpoint!.Metadata.GetMetadata&lt;Controller
                  ActionDescriptor&gt;();
                if (controllerActionDescriptor?
                        .MethodInfo
                        .DeclaringType?
                        .Namespace?
                        .StartsWith(requirement.Namespace,
                          StringComparison.InvariantCulture
                          ) == true &amp;&amp;
                    !httpContext.User.IsInRole("Admin"))
                {
                    context.Fail();
                }
                else
                {
                    context.Succeed(requirement);
                }
            }
        }
        return Task.CompletedTask;
    }
}</pre>
			<p>This overrides the abstract <strong class="source-in ine">HandleRequirementAsync()</strong> method from the base class. In the <strong class="source-in ine">context</strong> argument, there is a property called <strong class="source-in ine">Resource</strong>. For Web API controller actions, this is typical of type <strong class="source-in ine">HttpContext</strong>. The code, therefore, checks whether it is <strong class="source-in ine">HttpContext</strong> and then has the implementation of the policy within that clause. In <strong class="source-in ine">HttpContext</strong>, you can get the endpoint information. In the endpoint, there is metadata associated with it, and for our purpose, we’re looking for the specific controller information. The <strong class="source-in ine">ControllerActionDescriptor</strong> metadata contains the actual method that is supposed to be called on your controller. On this, the code gets <strong class="source-in ine">DeclaringType</strong> and uses its namespace to see whether the <a id="_idIndexMarker502"/>namespace<a id="_idIndexMarker503"/> requirement matches. If the type has a namespace that starts with the requirement and the user does not have the <strong class="source-in ine">Admin</strong> role, it fails the <strong class="source-in ine">context</strong>, meaning that the user is not authorized. You can provide reasons and more details for failing, but for this sample, we’re just keeping it clean.</p>
			<p class="ca out-heading">Tip</p>
			<p class="ca out">If the user is <strong class="source-in ine">Admin</strong>, it will succeed. It will also succeed if the namespace does not start with the requirement.</p>
			<p>With the policy handler in place, you need it to be hooked up so that it actually gets called. The default approach in ASP.NET Core is to add policies during the setup of the authorization. This approach, however, takes away the cross-cutting opportunity as you would then need to be explicit regarding the controllers whose policies should be applied. Instead, you’ll implement <strong class="source-in ine">IAuthorizationPolicyProvider</strong> and set up the policies in this.</p>
			<p>Add a file called <strong class="source-in ine">CrossCuttingPoliciesProvider.cs</strong> in the root of <strong class="source-in ine">Chapter13</strong>. It <a id="_idIndexMarker504"/>should<a id="_idIndexMarker505"/> be made to look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Authorization;
namespace Chapter13;
public class CrossCuttingPoliciesProvider : IAuthorizationPolicyProvider
{
    readonly AuthorizationPolicy _policy;
    public CrossCuttingPoliciesProvider()
    {
        _policy = new AuthorizationPolicyBuilder()
                .AddRequirements(new
                AdminForNamespace("Chapter13")
            ).Build();
    }
    public Task&lt;AuthorizationPolicy&gt;
      GetDefaultPolicyAsync() =&gt; Task.FromResult(_policy);
    public Task&lt;AuthorizationPolicy?&gt;
      GetFallbackPolicyAsync() =&gt;
      Task.FromResult&lt;AuthorizationPolicy?&gt;(_policy);
    public Task&lt;AuthorizationPolicy?&gt; GetPolicyAsync(string
      policyName) =&gt;
      Task.FromResult&lt;AuthorizationPolicy?&gt;(_policy);
}</pre>
			<p>The code sets up <strong class="source-in ine">AuthorizationPolicy</strong> that includes the <strong class="source-in ine">AdminForNamespace</strong> policy. <strong class="source-in ine">IAuthorizationPolicyProvider</strong> requires you to implement methods for getting policies for different scenarios; all of these return the same policy.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Returning the same policy for <strong class="source-in ine">GetDefaultPolicyAsync()</strong>, <strong class="source-in ine">GetFallbackPolicyAsync()</strong>, and <strong class="source-in ine">GetPolicyAsync()</strong> might not be the desired behavior. This is done for the simplicity of the sample.</p>
			<p>Next, you will be tying the authorization back into <strong class="source-in ine">CommandActionFilter</strong> you created earlier, and to do that, we have to communicate the authorization results that <a id="_idIndexMarker506"/>are<a id="_idIndexMarker507"/> returned. Unfortunately, this information is not easily accessible in the following stages of the ASP.NET Core pipeline.</p>
			<p>Add a file called <strong class="source-in ine">HttpContextExtensions.cs</strong> in the root of <strong class="source-in ine">Chapter13</strong> and make it look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Authorization.Policy;
namespace Chapter13;
public static class HttpContextExtensions
{
    const string AuthorizeResultKey = "_AuthorizeResult";
    public static PolicyAuthorizationResult?
      GetAuthorizationResult(this HttpContext context) =&gt;
      (context.Items[AuthorizeResultKey] as
      PolicyAuthorizationResult)!;
    public static void SetAuthorizationResult(this
      HttpContext context, PolicyAuthorizationResult
      result) =&gt; context.Items[AuthorizeResultKey] =
      result;
}</pre>
			<p>The code uses the <strong class="source-in ine">Items</strong> dictionary on <strong class="source-in ine">HttpContext</strong> and provides both a set method and a get method for working with <strong class="source-in ine">PolicyAuthorizationResult</strong>. <strong class="source-in ine">Items</strong> is a key/value store that can hold anything as part of the current Web request. This is perfect for when you want to make something available to other stages.</p>
			<p>ASP.NET Core <a id="_idIndexMarker508"/>provides<a id="_idIndexMarker509"/> specific middleware for dealing with the result of authorization. Add a file called <strong class="source-in ine">CrossCuttingAuthorizationMiddlewareResultHandler.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Authorization.Policy;
namespace Chapter13;
public class CrossCuttingAuthorizationMiddlewareResultHandler :
  IAuthorizationMiddlewareResultHandler
{
    readonly AuthorizationMiddlewareResultHandler
      _defaultHandler = new();
    public async Task HandleAsync(RequestDelegate next,
      HttpContext context, AuthorizationPolicy policy,
      PolicyAuthorizationResult authorizeResult)
    {
        context.SetAuthorizationResult(authorizeResult);
        await _defaultHandler.HandleAsync(next, context,
          policy, PolicyAuthorizationResult.Success());
    }
}</pre>
			<p>The code implements the <strong class="source-in ine">IAuthorizationMiddlewareResultHandler</strong> interface, which holds a <strong class="source-in ine">HandleAsync()</strong> method. This method gets called after all policies have been handled but before the action filters. The implementation of <strong class="source-in ine">HandleAsync()</strong> puts <strong class="source-in ine">authorizationResult</strong> on <strong class="source-in ine">HttpContext</strong> for the availability of later stages. It then uses the default implementation of the interface called <strong class="source-in ine">AuthorizationMiddlewareResultHandler</strong> to invoke the rest of the pipeline, only<a id="_idIndexMarker510"/> now simulating a<a id="_idIndexMarker511"/> success. The reason it simulates success is to trick the handler to perform the action filters. We want <strong class="source-in ine">CommandActionFilter</strong> to add support for authorization and return the <strong class="source-in ine">CommandResult</strong> structure consistently.</p>
			<p>Open the <strong class="source-in ine">CommandActionFilter.cs</strong> file in the <strong class="source-in ine">Commands</strong> folder within <strong class="source-in ine">Chapter13</strong> and make the top of the method look like the following:</p>
			<pre class="source-code">
if (context.HttpContext.Request.Method == HttpMethod.Post.Method)
    // Adding call to get authorization result and setting
    // authorized variable
    var authorizationResult =
      context.HttpContext.GetAuthorizationResult();
    var isAuthorized = authorizationResult?.Succeeded ??
      true;
    var exceptionMessages = new List&lt;string&gt;();
    var exceptionStackTrace = string.Empty;
    ActionExecutedContext? result = null;
    object? response = null;
    // Using authorized variable, we don't want to call the
    // controller if we are
    if (context.ModelState.IsValid &amp;&amp; isAuthorized)</pre>
			<p>The change you’re performing is making use of the authorization result. If the authorization result has not succeeded, you don’t want to call the rest of the pipeline, but you want to capture it in the command result.</p>
			<p>In the <a id="_idIndexMarker512"/>same <a id="_idIndexMarker513"/>file and method, change how you create <strong class="source-in ine">CommandResult</strong> to include the <strong class="source-in ine">IsAuthorized</strong> property:</p>
			<pre class="source-code">
var commandResult = new CommandResult
{
    CorrelationId = Guid.NewGuid(),
    // Adding isAuthorized
    IsAuthorized = isAuthorized,
    ValidationResults = context.ModelState.SelectMany(_ =&gt;
      _.Value!.Errors.Select(e =&gt;
      e.ToValidationResult(_.Key))),
    ExceptionMessages = exceptionMessages.ToArray(),
    ExceptionStackTrace = exceptionStackTrace ??
      string.Empty,
    Response = response
};</pre>
			<p>The code now has <strong class="source-in ine">CommandResult</strong> that includes <strong class="source-in ine">IsAuthorized</strong>. Since the rest of the action filter takes this into consideration, you should also be getting the correct HTTP status codes.</p>
			<p>Open the <strong class="source-in ine">Program.cs</strong> file in the root of the <strong class="source-in ine">Chapter13</strong> project and change it to look <a id="_idIndexMarker514"/>like<a id="_idIndexMarker515"/> the following:</p>
			<pre class="source-code">
using Chapter13;
using Chapter13.Commands;
using Microsoft.AspNetCore.Authorization;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers(mvcOptions =&gt; mvcOptions.Filters.
  Add&lt;CommandActionFilter&gt;());
// Adding authorization and the handlers
builder.Services.AddAuthorization(options =&gt; options.
  AddPolicy("Chapter13Admins", policy =&gt; policy.Requirements.Add(new AdminForNamespace("Chapter13"))));
builder.Services.AddSingleton&lt;IAuthorizationHandler,
  AdminForNamespaceHandler&gt;();
builder.Services.AddSingleton&lt;IAuthorizationMiddlewareResultHandler,
  CrossCuttingAuthorizationMiddlewareResultHandler&gt;();
builder.Services.AddSingleton&lt;IAuthorizationPolicyProvider,
  CrossCuttingPoliciesProvider&gt;();
// Adding authentication with our hardcoded handler
builder.Services
    .AddAuthentication(options =&gt; options.DefaultScheme =
      HardCodedAuthenticationHandler.SchemeName)
    .AddScheme&lt;HardCodedAuthenticationOptions,
      HardCodedAuthenticationHandler&gt;(
      HardCodedAuthenticationHandler.SchemeName, _ =&gt; {});
var app = builder.Build();
app.MapControllers();
// Use authentication and authorization
app.UseAuthentication();
app.UseAuthorization();
app.Run();</pre>
			<p>The <a id="_idIndexMarker516"/>changes<a id="_idIndexMarker517"/> introduce both authentication and authorization and hooks <strong class="source-in ine">Services</strong> into the different handlers and providers you have created. For the authentication, it sets up the hardcoded handler as the default authentication schema and configures the scheme to use the handler type you created.</p>
			<p>Running the application and performing the same operation as before using Postman should yield the following result:</p>
			<div><div><img src="img/B19418_13_03.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – An unauthorized result in Postman</p>
			<p>The<a id="_idIndexMarker518"/> output <a id="_idIndexMarker519"/>should have <strong class="source-in ine">isAuthorized</strong> set to <strong class="source-in ine">false</strong>:</p>
			<pre class="source-code">
{
    "correlationId": "eb26b553-45f3-43a4-9d92-9860b2fe541e",
    "isSuccess": false,
    "isAuthorized": false,
    "isValid": true,
    "hasExceptions": false,
    "validationResults": [],
    "exceptionMessages": [],
    "exceptionStackTrace": "",
    "response": null
}</pre>
			<p>Let’s try to change the role of the user to <strong class="bo d">Admin</strong>. Open the <strong class="source-in ine">HardCodedAuthenticationHandler.cs</strong> file in the root of <strong class="source-in ine">Chapter13</strong> and change the role from <strong class="source-in ine">User</strong> to <strong class="source-in ine">Admin</strong>. To do this, find the line that says the following:</p>
			<pre class="source-code">
new Claim(ClaimTypes.Role, "User")</pre>
			<p>Then make it look like the following:</p>
			<pre class="source-code">
new Claim(ClaimTypes.Role, "Admin")</pre>
			<p>Running <a id="_idIndexMarker520"/>the <a id="_idIndexMarker521"/>application now and performing the same operation again should give you a result where you’re authorized:</p>
			<div><div><img src="img/B19418_13_04.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – An authorized result in Postman</p>
			<p>The JSON <a id="_idIndexMarker522"/>output should<a id="_idIndexMarker523"/> look like the following:</p>
			<pre class="source-code">
{
    "correlationId": "80191dbc-8908-4c89-9dfb-7bce8b4b9e44",
    "isSuccess": true,
    "isAuthorized": true,
    "isValid": true,
    "hasExceptions": false,
    "validationResults": [],
    "exceptionMessages": [],
    "exceptionStackTrace": "",
    "response": 1
}</pre>
			<p>This should give you an idea of what is possible. With ASP.NET Core, you can go deep into <a id="_idIndexMarker524"/>replacing default<a id="_idIndexMarker525"/> behavior and customizing it to your needs, which is fabul<a id="_idTextAnchor217"/>ous when you’re looking to apply some cross-cutting concerns.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor218"/>Summary</h1>
			<p>Recipes are pieces of code that clearly specify, in a linear manner, what they do, are a great tool for new developers. The developer can really see what’s going on, reason about the code, and find errors. As the developer, team, and project mature, the recipes start to feel like unnecessary chores or at least become very repetitive. Not only is this something that potentially affects productivity, but these kinds of repetitive tasks are easy to get wrong. Getting it wrong could pose multiple risks to the system:</p>
			<ul>
				<li>Security risks</li>
				<li>The risk of persisting invalid data</li>
				<li>The risk of allowing operations that are not allowed</li>
				<li>The risk of losing operational insight due to a lack of logging</li>
			</ul>
			<p>The tradeoff between imperative procedural code that a developer can quickly reason about and the need for a consistent system is one you should consider. In smaller projects, it might not be worth the cognitive load of being “different” in applying things cross-cuttingly, while in larger systems, it might be completely crucial. There could be a correlation with the size of the team as well—the bigger the team, the more things you want to automate and standardize.</p>
			<p>Applying cross-cutting concerns can be extremely powerful, but it can feel like a black box if the developers don’t know about it and can’t understand why something is happening. My advice on that is to make sure all developers are educated on how cross-cutting concerns are handled and ensure that it is possible to follow code paths. Rather than documenting the recipes, my suggestion would be to document how they are automated and how developers can, for instance, debug things.</p>
			<p>In the next chapter, we’ll dive into how you can go deeper by leveraging aspect-oriented programming.</p>
		</div>
	</body></html>