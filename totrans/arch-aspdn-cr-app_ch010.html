<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>9 Options, Settings, and Configuration</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="10">9 Options, Settings, and Configuration</h1>

<h2 data-number="10.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file44.png" style="width:10em"/></p>
<p>This chapter covers the .NET Options pattern, a building block of any application. .NET Core introduced new predefined mechanisms to enhance the usage of application settings available to ASP.NET Core applications. These allow us to divide our configuration into multiple smaller objects, configure them during various stages of the startup flow, validate them, and even watch for runtime changes with minimal effort.</p>
<blockquote>
<p>The new options system repurposed the <code>ConfigurationManager</code> class as an internal piece. We no longer can use it as the old .NET Framework-era static methods are gone. The new patterns and mechanisms help avoid useless coupling, add flexibility to our designs, and are DI-native. The system is also simpler to extend.</p>
</blockquote>
<p>The Options pattern goal is to use settings at runtime, allowing changes to the application to happen without changing the code. The settings could be as simple as a <code>string</code>, a <code>bool</code>, a database connection string, or a complex object that holds an entire subsystem’s configuration.This chapter delves into various tools and methodologies we can use for managing, injecting, and loading configurations and options into our ASP.NET Core applications. Our journey spans a broad spectrum of scenarios, covering everything from commonly encountered to more complex use cases.At the end of the chapter, you will know how to leverage the .NET options and settings infrastructure.In this chapter, we cover the following topics:</p>
<ul>
<li>Loading the configuration</li>
<li>Learning the building blocks</li>
<li>Exploring common usage scenarios</li>
<li>Learning options configuration</li>
<li>Validating our options objects</li>
<li>Validating options using FluentValidation</li>
<li>Injecting options objects directly—a workaround</li>
<li>Centralizing the configuration for easier management</li>
<li>Using the configuration-binding source generator</li>
<li>Using the options validation source generator</li>
<li>Using the options validation source generator</li>
</ul>
<p>Let’s get started!</p>


<h2 data-number="10.2">Loading the configuration</h2>
<p>ASP.NET Core allows us to load settings from multiple sources seamlessly. We can customize these sources from the <code>WebApplicationBuilder</code>, or use the defaults set by calling the <code>WebApplication.CreateBuilder(args)</code> method.The default sources, in order, are as follows:</p>
<ol>
<li><code>appsettings.json</code></li>
<li><code>appsettings.{Environment}.json</code></li>
<li>User secrets; these are only loaded when the environment is <code>Development</code></li>
<li>Environment variables</li>
<li>Command-line arguments</li>
</ol>
<p>The order is essential, as the last to be loaded overrides previous values. For example, you can set a value in <code>appsettings.json</code> and override it in <code>appsettings.Staging.json</code> by redefining the value in that file, user secrets, an environment variable or by passing it as a command-line argument when you run your application.</p>
<blockquote>
<p>You can name your environments as you want, but by default, ASP.NET Core has built-in helper methods for <code>Development</code>, <code>Staging</code>, and <code>Production</code>.</p>
</blockquote>
<p>On top of the default providers, we can register other configuration sources out of the box, like <code>AddIniFile</code>, <code>AddInMemoryCollection</code>, and <code>AddXmlFile</code>, for example. We can also load NuGet packages to install custom providers, like Azure KeyVault and Azure App Configuration, to centralize secrets and configuration management into the Azure cloud. The most interesting part of those configuration providers is that no matter the sources, it does not affect the consumption of the settings, only the composition root. This means we can start loading settings one way, then change our mind later or have different strategies for dev and prod, and none of that affects the codebase but the composition root.We explore a few building blocks next.</p>


<h2 data-number="10.3">Learning the building blocks</h2>
<p>There are four main interfaces to use settings: <code>IOptionsMonitor&lt;TOptions&gt;</code>, <code>IOptionsFactory&lt;TOptions&gt;</code>, <code>IOptionsSnapshot&lt;TOptions&gt;</code>, and <code>IOptions&lt;TOptions&gt;</code>. We must inject that dependency into a class to use the available settings. <code>TOptions</code> is the type that represents the settings that we want to access.The framework returns an empty instance of your options class if you don’t configure it. We learn how to configure options properly in the next subsection; meanwhile, remember that using property initializers inside your options class can also be a great way to ensure certain defaults are used. You can also use constants to centralize those defaults somewhere in your codebase (making them easier to maintain). Nevertheless, proper configuration and validation are always preferred, but both combined can add a safety net. Don’t use initializers or constants for default values that change based on the environment (dev, staging, or production) or for secrets such as connection strings and passwords.</p>
<blockquote>
<p>You should always keep secrets out of your Git history, whether it's out of the C# code or out of setting files. Use ASP.NET Core secrets locally and a secret store like Azure KeyVault for Staging and Production environments.</p>
</blockquote>
<p>If we create the following class, since the default value of an <code>int</code> is <code>0</code>, the default number of items to display per page would be 0, leading to an empty list.</p>
<div><pre><code>public class MyListOption
{
    public int ItemsPerPage { get; set; }
}</code></pre>
</div>
<p>However, we can configure this using a property initializer, as next:</p>
<div><pre><code>public class MyListOption
{
    public int ItemsPerPage { get; set; } = 20;
}</code></pre>
</div>
<p>The default number of items to display per page is now 20.</p>
<blockquote>
<p>In the source code for this chapter, I’ve included a few tests in the <code>CommonScenarios.Tests</code> project that assert the lifetime of the different options interfaces. I haven’t included this code here for brevity, but it describes the behavior of the different options via unit tests. See <a href="https://adpg.link/AXa5">https://adpg.link/AXa5</a> for more information.</p>
</blockquote>
<p>The options served by each interface have different DI lifetimes and other features. The following table exposes some of those features:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Interface</strong></td>
<td><strong>Lifetime</strong></td>
<td><strong>Support named options</strong></td>
<td><strong>Support change notification</strong></td>
</tr>
<tr class="even">
<td><code>IOptionsMonitor&lt;TOptions&gt;</code></td>
<td>Singleton</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td><code>IOptionsFactory&lt;TOptions&gt;</code></td>
<td>Transient</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="even">
<td><code>IOptionsSnapshot&lt;TOptions&gt;</code></td>
<td>Scoped</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="odd">
<td><code>IOptions&lt;TOptions&gt;</code></td>
<td>Singleton</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
Table 9.1: The different options interfaces, their DI lifetime, and support for other features.
<p>Next, we explore those interfaces more in-depth.</p>

<h3 data-number="10.3.1">IOptionsMonitor&lt;TOptions&gt;</h3>
<p>This interface is the most versatile of them all:</p>
<ul>
<li>It supports receiving notifications about reloading the configuration (like when the setting file changed).</li>
<li>It supports caching.</li>
<li>It supports named configuration (identifying multiple different <code>TOptions</code> with a name).</li>
<li>The injected <code>IOptionsMonitor&lt;TOptions&gt;</code> instance is always the same (<strong>singleton lifetime</strong>).</li>
<li>It supports unnamed default settings through its <code>Value</code> property.</li>
</ul>
<blockquote>
<p>If we only configure named options or no instance at all, the consumer will receive an empty <code>TOptions</code> instance (<code>new TOptions()</code>).</p>
</blockquote>


<h3 data-number="10.3.2">IOptionsFactory&lt;TOptions&gt;</h3>
<p>This interface is a factory, as we saw in <em>Chapter 7</em>, <em>Strategy, Abstract Factory, and Singleton</em>, and in <em>Chapter 8</em>, <em>Dependency Injection</em>, we use factories to create instances; this interface is no different.</p>
<blockquote>
<p>Unless necessary, I suggest sticking with <code>IOptionsMonitor&lt;TOptions&gt;</code> or <code>IOptionsSnapshot&lt;TOptions&gt;</code> instead.</p>
</blockquote>
<p>How the factory works is simple: the container creates a new factory every time you ask for one (transient lifetime), and the factory creates a new options instance every time you call its <code>Create(name)</code> method (<strong>transient lifetime</strong>).To get the default instance (non-named options), you can use the <code>Options.DefaultName</code> field or pass an empty string; this is usually handled for you by the framework.</p>
<blockquote>
<p>If we only configure named options or no instance at all, the consumer will receive an empty <code>TOptions</code> instance (<code>new TOptions()</code>) after calling <code>factory.Create(Options.DefaultName)</code>.</p>
</blockquote>


<h3 data-number="10.3.3">IOptionsSnapshot&lt;TOptions&gt;</h3>
<p>This interface is useful when you need a snapshot of the settings for the duration of an HTTP request.</p>
<ul>
<li>The container creates only one instance per request (<strong>scoped lifetime</strong>).</li>
<li>It supports named configuration.</li>
<li>It supports unnamed default settings through its <code>CurrentValue</code> property.</li>
</ul>
<blockquote>
<p>If we only configure named options or no instance at all, the consumer will receive an empty <code>TOptions</code> instance (<code>new TOptions()</code>).</p>
</blockquote>


<h3 data-number="10.3.4">IOptions&lt;TOptions&gt;</h3>
<p>This interface is the first that was added to ASP.NET Core.</p>
<ul>
<li>It does not support advanced scenarios such as what snapshots and monitors do.</li>
<li>Whenever you request an <code>IOptions&lt;TOptions&gt;</code> instance, you get the same instance (<strong>singleton lifetime</strong>).</li>
</ul>
<blockquote>
<p><code>IOptions&lt;TOptions&gt;</code> does not support named options, so you can only access the default instance.</p>
</blockquote>
<p>Now that we looked at the building blocks, we dig into some code to explore leveraging those interfaces.</p>



<h2 data-number="10.4">Project – CommonScenarios</h2>
<p>This first example covers multiple basic use cases, such as injecting options, using named options, and storing options values in settings.Let’s start with the shared building block.</p>

<h3 data-number="10.4.1">Manual configuration</h3>
<p>In the composition root, we can manually configure options, which is very useful for configuring ASP.NET Core MVC, the JSON serializer, other pieces of the framework, or our own handcrafted options.Here’s the first options class we use in the code, which contains only a <code>Name</code> property:</p>
<div><pre><code>namespace CommonScenarios;
public class MyOptions
{
    public string? Name { get; set; }
}</code></pre>
</div>
<p>In the composition root, we can use the <code>Configure</code> extension method that extends the <code>IServiceCollection</code> interface to achieve this. Here’s how we can set the default options of the <code>MyOptions</code> class:</p>
<div><pre><code>builder.Services.Configure&lt;MyOptions&gt;(myOptions =&gt;
{
    myOptions.Name = "Default Option";
});</code></pre>
</div>
<p>With that code, if we inject that options instance into a class, the value of the <code>Name</code> property will be <code>Default Options</code>.We explore loading settings from a non-hardcoded configuration source next.</p>


<h3 data-number="10.4.2">Using the settings file</h3>
<p>Loading configurations from a file is often more convenient than hardcoding the values in C#. Moreover, the mechanism allows overriding the configurations using different sources, bringing even more advantages.To load <code>MyOptions</code> from the <code>appsettings.json</code> file, we must first get the configuration section, then configure the options, like the following:</p>
<div><pre><code>var defaultOptionsSection = builder.Configuration
    .GetSection("defaultOptions");
builder.Services
    .Configure&lt;MyOptions&gt;(defaultOptionsSection);</code></pre>
</div>
<p>The preceding code loads the following data from the appsettings.json file:</p>
<div><pre><code>{
  "defaultOptions": {
    "name": "Default Options"
  }
}</code></pre>
</div>
<p>The <strong>defaultOptions</strong> section maps to objects with the same key in the JSON file (highlighted code). The <code>name</code> property of the <code>defaultOptions</code> section translates to the <code>Name</code> property of the <code>MyOptions</code> class.That code does the same as the preceding hardcoded version. However, manually loading the section this way allows us to load a different section for different named options.Alternatively, we can also “bind” a configuration section to an existing object using the <code>Bind</code> method like this:</p>
<div><pre><code>var options = new MyOptions();
builder.Configuration.GetSection("options1").Bind(options);</code></pre>
</div>
<p>That code loads the settings and assigns them to the object’s properties, matching the settings key to the properties name. However, this does not add the object to the IoC container.To overcome this, if we do not want to register the dependency manually and don’t need the object, we can use the <code>Bind</code> or <code>BindConfiguration</code> methods from the <code>OptionsBuilder&lt;TOptions&gt;</code>. We create that object with the <code>AddOptions</code> method, like for <code>Bind</code>:</p>
<div><pre><code>builder.Services.AddOptions&lt;MyOptions&gt;("Options3")
    .Bind(builder.Configuration.GetSection("options3"));</code></pre>
</div>
<p>The preceding code loads the <code>options3</code> configuration section using the <code>GetSection</code> method (highlighted), then the <code>OptionsBuilder&lt;TOptions&gt;</code> binds that value to the name <code>Options3</code> through the <code>Bind</code> method. This registers a named instance of <code>MyOptions</code> with the container. We dig into named options later.Then again, we can skip the use of the <code>GetSection</code> method by using the <code>BindConfiguration</code> method instead, like this:</p>
<div><pre><code>builder.Services.AddOptions&lt;MyOptions&gt;("Options4")
    .BindConfiguration("options4");</code></pre>
</div>
<p>The preceding code loads the settings from the <code>options4</code> section, then registers that new setting with the IoC container.These are just a subset of the different ways we can leverage the ASP.NET Core Options pattern and configuration system. Now that we know how to configure the options, it is time to use them.</p>


<h3 data-number="10.4.3">Injecting options</h3>
<p>Let’s start by learning how to leverage the <code>IOptions&lt;TOptions&gt;</code> interface, the first and simplest interface that came out of .NET Core.To try this out, let’s create an endpoint and inject the <code>IOptions&lt;MyOptions&gt;</code> interface as a parameter:</p>
<div><pre><code>app.MapGet(
    "/my-options/",
    (IOptions&lt;MyOptions&gt; options) =&gt; options.Value
);</code></pre>
</div>
<p>In the preceding code, the <code>Value</code> property returns the configured value, which is the following, serialized as JSON:</p>
<div><pre><code>{
  "name": "Default Options"
}</code></pre>
</div>
<p>And voilà! We can also use constructor injection or any other method we know to use the value of our options object.Next, we explore configuring multiple instances of the same options class.</p>


<h3 data-number="10.4.4">Named options</h3>
<p>Now, let’s explore named options by configuring two more instances of the <code>MyOptions</code> class. The concept is to associate a configuration of the options with a name. Once that is done, we can request the configuration we need.</p>
<blockquote>
<p>Unfortunately, the ways we explore named options and most online examples break the Inversion of Control principle.</p>
<blockquote>
<p>Why? By injecting an interface that is directly tied to a lifetime, the consuming class controls that part of the dependency.</p>
</blockquote>
<blockquote>
<p>Rest assured, we are revisiting this at the end of the chapter.</p>
</blockquote>
</blockquote>
<p>First, in the <code>appsettings.json</code> file, let’s add the highlighted sections:</p>
<div><pre><code>{
  "defaultOptions": {
    "name": "Default Options"
  },
  "options1": {
    "name": "Options 1"
  },
  "options2": {
    "name": "Options 2"
  }
}</code></pre>
</div>
<p>Now that we have those configs, let’s configure them in the <code>Program.cs</code> file by adding the following lines:</p>
<div><pre><code>builder.Services.Configure&lt;MyOptions&gt;(
    "Options1",
    builder.Configuration.GetSection("options1")
);
builder.Services.Configure&lt;MyOptions&gt;(
    "Options2",
    builder.Configuration.GetSection("options2")
);</code></pre>
</div>
<p>In the preceding code, the highlighted strings represent the names of the options we are configuring. We associate each configuration section with a named instance.Now to consume those named options, we have multiple choices. We can inject an <code>IOptionsFactory&lt;MyOptions&gt;</code>, <code>IOptionsMonitor&lt;MyOptions&gt;</code>, or an <code>IOptionsSnapshot&lt;MyOptions&gt;</code> interface. The final choice depends on the lifetime the consumer of the options needs. However, in our case, we use all of them to ensure we explore them all.</p>

<h4 data-number="10.4.4.1">IOptionsFactory&lt;MyOptions&gt;</h4>
<p>Let’s start with creating an endpoint where we inject a factory:</p>
<div><pre><code>app.MapGet(
    "/factory/{name}",
    (string name, IOptionsFactory&lt;MyOptions&gt; factory)
        =&gt; factory.Create(name)
);</code></pre>
</div>
<p>The factory interface forces us to pass in a name that is convenient for us. When we execute the program, the endpoint serves us the options based on the specified name. For example, when we send the following request:</p>
<div><pre><code>GET https://localhost:8001/factory/Options1</code></pre>
</div>
<p>The endpoint returns the following JSON:</p>
<div><pre><code>{
  "name": "Options 1"
}</code></pre>
</div>
<p>If we pass Options2 instead, we get the following JSON:</p>
<div><pre><code>{
  "name": "Options 2"
}</code></pre>
</div>
<p>As simple as that, we can now choose between three different options. Of course, once again, we can leverage any other technique we know, like constructor injections.Let’s explore the next interface.</p>


<h4 data-number="10.4.4.2">IOptionsMonitor&lt;MyOptions&gt;</h4>
<p>We use the <code>IOptionsMonitor</code> interface similarly to the <code>IOptionsFactory</code> interface when we need named options. So, let’s start by creating a similar endpoint:</p>
<div><pre><code>app.MapGet(
    "/monitor/{name}",
    (string name, IOptionsMonitor&lt;MyOptions&gt; monitor)
        =&gt; monitor.Get(name)
);</code></pre>
</div>
<p>The preceding code is almost the same as the factory one, but the <code>IOptionsMonitor</code> interface exposes a <code>Get</code> method instead of a <code>Create</code> method. This semantically expresses that the code is getting an options instance (singleton) instead of creating a new one (transient).Again, similarly, if we send the following request:</p>
<div><pre><code>GET https://localhost:8001/monitor/Options2</code></pre>
</div>
<p>The server returns the following JSON:</p>
<div><pre><code>{
  "name": "Options 2"
}</code></pre>
</div>
<p>One difference is that we can access the default options as well; here’s how:</p>
<div><pre><code>app.MapGet(
    "/monitor",
    (IOptionsMonitor&lt;MyOptions&gt; monitor)
        =&gt; monitor.CurrentValue
);</code></pre>
</div>
<p>In the preceding code, the <code>CurrentValue</code> property returns the default options. So, when calling this endpoint, we should receive the following JSON:</p>
<div><pre><code>{
  "name": "Default Options"
}</code></pre>
</div>
<p>As simple as that, we can either access the default value or a named value. We explore one other scenario that the <code>IOptionsMonitor</code> interface supports after we cover the <code>IOptionsSnapshot</code> interface next.</p>


<h4 data-number="10.4.4.3">IOptionsSnapshot&lt;MyOptions&gt;</h4>
<p>The <code>IOptionsSnapshot</code> interface inherits the <code>IOptions</code> interface, contributing its <code>Value</code> property, and also offers a <code>Get</code> method (scoped lifetime) that works like the <code>IOptionsMonitor</code> interface.Let’s start with the first endpoint:</p>
<div><pre><code>app.MapGet(
    "/snapshot",
    (IOptionsSnapshot&lt;MyOptions&gt; snapshot)
        =&gt; snapshot.Value
);</code></pre>
</div>
<p>It should be no surprise that the preceding endpoint returns the following default options:</p>
<div><pre><code>{
  "name": "Default Options"
}</code></pre>
</div>
<p>Then the following parametrized endpoint returns the specified named options:</p>
<div><pre><code>app.MapGet(
    "/snapshot/{name}",
    (string name, IOptionsSnapshot&lt;MyOptions&gt; snapshot)
        =&gt; snapshot.Get(name)
);</code></pre>
</div>
<p>Say we are passing the name <code>Options1</code>, then the endpoint will return the following options:</p>
<div><pre><code>{
  "name": "Options 1"
}</code></pre>
</div>
<p>And we are done. It is quite simple to use the options as .NET does most of the work for us. The same goes for configuring options classes.But wait, our exploration isn't over yet! Up next, we delve into the process of reloading options at runtime.</p>



<h3 data-number="10.4.5">Reloading options at runtime</h3>
<p>A fascinating aspect of the ASP.NET Core options is that the system reloads the value of the options when someone updates a configuration file like <code>appsettings.json</code>. To try it out, you can:</p>
<ol>
<li>Run the program.</li>
<li>Query an endpoint using the request available in the <code>CommonScenarios.http</code> file.</li>
<li>Change the value of that option in the <code>appsettings.json</code> file and save the file.</li>
<li>Query the same endpoint again, and you should see the updated value.</li>
</ol>
<p>This is an out-of-the-box feature. However, the system rebuilds the options instance, which does not update the references on the previous instance. The good news is that we can hook into the system and react to the changes.For most scenarios, we don’t need to manually check for change since the value of the <code>CurrentValue</code> property gets updated. However, if you directly reference that value, this mechanism can be useful.In this scenario, we have a notification service that sends emails. The SMTP client’s configurations are settings. In this case, we only have the <code>SenderEmailAddress</code> since sending actual emails is unnecessary. We are logging the notification in the console instead, allowing us to see the configuration changes appear live.Let’s start with the <code>EmailOptions</code> class:</p>
<div><pre><code>namespace CommonScenarios.Reload;
public class EmailOptions
{
    public string? SenderEmailAddress { get; set; }
}</code></pre>
</div>
<p>Next, we have the <code>NotificationService</code> class itself. Let’s start with its first iteration:</p>
<div><pre><code>namespace CommonScenarios.Reload;
public class NotificationService
{
    private EmailOptions _emailOptions;
    private readonly ILogger _logger;
    public NotificationService(IOptionsMonitor&lt;EmailOptions&gt; emailOptionsMonitor, ILogger&lt;NotificationService&gt; logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        ArgumentNullException.ThrowIfNull(emailOptionsMonitor);
        _emailOptions = emailOptionsMonitor.CurrentValue;
    }
    public Task NotifyAsync(string to)
    {
        _logger.LogInformation(
            "Notification sent by '{SenderEmailAddress}' to '{to}'.", 
            _emailOptions.SenderEmailAddress, 
            to
        );
        return Task.CompletedTask;
    }
}</code></pre>
</div>
<p>In the preceding code, the class holds a reference on the <code>EmailOptions</code> class upon creation (highlighted lines). The <code>NotifyAsync</code> method writes an information message in the console and then returns.</p>
<blockquote>
<p>We explore logging in the next chapter.</p>
</blockquote>
<p>Because the <code>NotificationService</code> class has a singleton lifetime and references the options class itself, if we change the configuration, the value will not update since the system recreates a new instance with the updated configuration. Here’s the service registration method:</p>
<div><pre><code>public static WebApplicationBuilder AddNotificationService(
    this WebApplicationBuilder builder)
{
    builder.Services.Configure&lt;EmailOptions&gt;(builder.Configuration
        .GetSection(nameof(EmailOptions)));
    builder.Services.AddSingleton&lt;NotificationService&gt;();
    return builder;
}</code></pre>
</div>
<p>How to fix this? In this case, we could fix the issue by referencing the <code>IOptionsMonitor</code> interface instead of its <code>CurrentValue</code> property. However, if you face a scenario where it’s impossible, we can tap into the <code>OnChange</code> method of the <code>IOptionsMonitor</code> interface. In the constructor, we could add the following code:</p>
<div><pre><code>emailOptionsMonitor.OnChange((options) =&gt;_emailOptions = options);</code></pre>
</div>
<p>With that code, when the <code>appsettings.json</code> file changes, the code updates the <code>_emailOptions</code> field. As easy as this, we reactivated the reloading feature.</p>
<blockquote>
<p>One more thing, the <code>OnChange</code> method returns an <code>IDisposable</code> we can dispose of to stop listening for changes. I implemented two additional methods in the source code: <code>StartListeningForChanges</code> and <code>StopListeningForChanges</code>, and three endpoints, one to send notifications, one to stop listening for changes, and one to start listening for changes again.</p>
</blockquote>
<p>Now that we know how to use the options, let’s explore additional ways to configure them.</p>



<h2 data-number="10.5">Project – OptionsConfiguration</h2>
<p>Now that we have covered basic usage scenarios, let’s attack some more advanced possibilities, such as creating types to configure, initialize, and validate our options.We start by configuring options which happen in two phases:</p>
<ol>
<li>The configuration phase.</li>
<li>The post-configuration phase.</li>
</ol>
<p>In a nutshell, the post-configuration phase happens later in the process. This is a good place to enforce that some values are configured a certain way or to override configuration, for example, in integration tests.To configure an options class, we have many options, starting with the following interfaces:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Interface</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>IConfigureOptions&lt;TOptions&gt;</code></td>
<td>Configure the default <code>TOptions</code> type.</td>
</tr>
<tr class="odd">
<td><code>IConfigureNamedOptions&lt;TOptions&gt;</code></td>
<td>Configure the default and named <code>TOptions</code> type.</td>
</tr>
<tr class="even">
<td><code>IPostConfigureOptions&lt;TOptions&gt;</code></td>
<td>Configure the default and named <code>TOptions</code> type during the post-configuration phase.</td>
</tr>
</tbody>
</table>
Table 9.2: interfaces to configure options classes.
<blockquote>
<p>If a configuration class implements both <code>IConfigureOptions</code> and <code>IConfigureNamedOptions</code> interfaces, the <code>IConfigureNamedOptions</code> interface will take precedence, and the <code>Configure</code> method of the <code>IConfigureOptions</code> interface will not be executed.</p>
<blockquote>
<p>You can configure the default instance using the <code>Configure</code> method of the <code>IConfigureNamedOptions</code> interface; the name of the options will be empty (equal to the member <code>Options.DefaultName</code>).</p>
</blockquote>
</blockquote>
<p>We can also leverage the following methods that extend the <code>IServiceCollection</code> interface:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>Configure&lt;TOptions&gt;</code></td>
<td>Configure the default and named <code>TOptions</code> type inline or from a configuration section.</td>
</tr>
<tr class="odd">
<td><code>ConfigureAll&lt;TOptions&gt;</code></td>
<td>Configure all options of type <code>TOptions</code> inline.</td>
</tr>
<tr class="even">
<td><code>PostConfigure&lt;TOptions&gt;</code></td>
<td>Configure the default and named <code>TOptions</code> type inline during the post-configuration phase.</td>
</tr>
<tr class="odd">
<td><code>PostConfigureAll&lt;TOptions&gt;</code></td>
<td>Configure all options of type <code>TOptions</code> inline during the post-configuration phase.</td>
</tr>
</tbody>
</table>
Table 9.3: configuration methods.
<p>As we are about to see, the registration order is very important. The configurators are executed in order of registration. Each phase is independent of the other; thus, the sequence in which we arrange the configuration and post-configuration phases doesn't influence one another.First, we must lay out the groundwork for our little program.</p>

<h3 data-number="10.5.1">Creating the program</h3>
<p>After creating an empty web application, the first building block is to create the options class that we want to configure:</p>
<div><pre><code>namespace OptionsConfiguration;
public class ConfigureMeOptions
{
    public string? Title { get; set; }
    public IEnumerable&lt;string&gt; Lines { get; set; } = Enumerable.Empty&lt;string&gt;();
}</code></pre>
</div>
<p>We use the <code>Lines</code> property as a trace bucket. We add lines to it to visually confirm the order that the configurators are executed.Next, we define application settings in the <code>appsettings.json</code> file:</p>
<div><pre><code>{
  "configureMe": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json"
    ]
  }
}</code></pre>
</div>
<p>We use the configuration as a starting point. It defines the value of the <code>Title</code> property and adds a first line to the <code>Lines</code> property, allowing us to trace the order it is executed.Next, we need an endpoint to access the settings, serialize the result to a JSON string, and then write it to the response stream:</p>
<div><pre><code>app.MapGet(
    "/configure-me",
    (IOptionsMonitor&lt;ConfigureMeOptions&gt; options) =&gt; new {
        DefaultInstance = options.CurrentValue,
        NamedInstance = options.Get(NamedInstance)
    }
);</code></pre>
</div>
<p>By calling this endpoint, we can consult the values of the default and named instances we are about to create.</p>
<blockquote>
<p>ASP.NET Core configures the options when they are requested for the first time. In this case, both instances of the <code>ConfigureMeOptions</code> class are configured when calling the <code>/configure-me</code> endpoint for the first time.</p>
</blockquote>
<p>If we run the program now, we end up with two empty instances, so before doing that, we need to tell ASP.NET about the <code>configureMe</code> configuration section we added to the <code>appsettings.json</code> file.</p>


<h3 data-number="10.5.2">Configuring the options</h3>
<p>We want two different options to test out many possibilities:</p>
<ul>
<li>A default options (unnamed)</li>
<li>A named instance.</li>
</ul>
<p>To achieve this, we must add the following lines in the <code>Program.cs</code> file:</p>
<div><pre><code>const string NamedInstance = "MyNamedInstance";
builder.Services
    .Configure&lt;ConfigureMeOptions&gt;(builder.Configuration
        .GetSection("configureMe"))
    .Configure&lt;ConfigureMeOptions&gt;(NamedInstance, builder.Configuration
        .GetSection("configureMe"))
;</code></pre>
</div>
<p>The preceding code registers a default instance (highlighted code) and a named instance. Both use the <code>configureMe</code> configuration sections and so start with the same initial values, as we can see when running the project:</p>
<div><pre><code>{
  "defaultInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json"
    ]
  },
  "namedInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json"
    ]
  }
}</code></pre>
</div>
<p>The <code>defaultInstance</code> and <code>namedInstance</code> properties are self-explanatory and relate to their respective options instance.Now that we completed our building blocks, we are ready to explore the <code>IConfigureOptions&lt;TOptions&gt;</code> interface.</p>


<h3 data-number="10.5.3">Implementing a configurator object</h3>
<p>We can encapsulate the configuration logic into classes to apply the single responsibility principle (SRP). To do so, we must implement an interface and create the binding with the IoC container.First, we must create a class that we name <code>ConfigureAllConfigureMeOptions</code>, which configures all <code>ConfigureMeOptions</code> instances; default and named:</p>
<div><pre><code>namespace OptionsConfiguration;
public class ConfigureAllConfigureMeOptions : IConfigureNamedOptions&lt;ConfigureMeOptions&gt;
{
    public void Configure(string? name, ConfigureMeOptions options)
    {
        options.Lines = options.Lines.Append(
            $"ConfigureAll:Configure name: {name}");
        if (name != Options.DefaultName)
        {
            options.Lines = options.Lines.Append(
                $"ConfigureAll:Configure Not Default: {name}");
        }
    }
    public void Configure(ConfigureMeOptions options)
        =&gt; Configure(Options.DefaultName, options);
}</code></pre>
</div>
<p>In the preceding code, we implement the interface (highlighted code), which contains two methods. The second <code>Configure</code> method should never be called, but just in case, we can simply redirect the call to the other method if it happens. The body of the first <code>Configure</code> method (highlighted) adds a line to all options and a second line when the options is not the default one.</p>
<blockquote>
<p>Instead of testing if the options is not the default one (<code>name != Options.DefaultName</code>), you can check for the options name or use a <code>switch</code> to configure specific options by name.</p>
</blockquote>
<p>We can tell the IoC container about this code, so ASP.NET Core executes it like this:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureAllConfigureMeOptions&gt;();</code></pre>
</div>
<p>Now with this binding in place, ASP.NET Core will run our code the first time we request our endpoint. Here’s the result:</p>
<div><pre><code>{
  "defaultInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: "
    ]
  },
  "namedInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: MyNamedInstance",
      "ConfigureAll:Configure Not Default: MyNamedInstance"
    ]
  }
}</code></pre>
</div>
<p>As we can see from that JSON output, the configurator ran and added the expected lines to each instance.</p>
<blockquote>
<p>It is important to note that you must bind the <code>IConfigureOptions&lt;TOptions&gt;</code> to your configuration class even if you implemented the <code>IConfigureNamedOptions&lt;TOptions&gt;</code> interface.</p>
</blockquote>
<p>And voilà—we have a neat result that took almost no effort. This can lead to so many possibilities! Implementing <code>IConfigureOptions&lt;TOptions&gt;</code> is probably the best way to configure the default values of an options class.Next, we add post-configuration to the mix!</p>


<h3 data-number="10.5.4">Adding post-configuration</h3>
<p>We must take a similar path to add post-configuration values but implement the <code>IPostConfigureOptions&lt;TOptions&gt;</code> instead. To achieve this, we update the <code>ConfigureAllConfigureMeOptions</code> class to implement that interface:</p>
<div><pre><code>namespace OptionsConfiguration;
public class ConfigureAllConfigureMeOptions :
    IPostConfigureOptions&lt;ConfigureMeOptions&gt;,
    IConfigureNamedOptions&lt;ConfigureMeOptions&gt;
{
    // Omitted previous code
    public void PostConfigure(string? name, ConfigureMeOptions options)
    {
        options.Lines = options.Lines.Append(
            $"ConfigureAll:PostConfigure name: {name}");
    }
}</code></pre>
</div>
<p>In the preceding code, we implemented the interface (highlighted lines). The <code>PostConfigure</code> method simply adds a line to the <code>Lines</code> property. To register it with the IoC container, we must add the following line:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IPostConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureAllConfigureMeOptions&gt;();</code></pre>
</div>
<p>The big difference is that this runs during the post-configuration phase, independent of the initial configuration phase. Executing the application now leads to the following result:</p>
<div><pre><code>{
  "defaultInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: ",
      "ConfigureAll:PostConfigure name: "
    ]
  },
  "namedInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: MyNamedInstance",
      "ConfigureAll:Configure Not Default: MyNamedInstance",
      "ConfigureAll:PostConfigure name: MyNamedInstance"
    ]
  }
}</code></pre>
</div>
<p>In the preceding JSON, the highlighted lines represent our post-configuration code that was added at the end. You might tell yourself, of course, it’s the last line; it’s the last code we registered, which is a legitimate assumption. However, here’s the complete registration code, which clearly shows the <code>IPostConfigureOptions&lt;TOptions&gt;</code> interface was registered first (highlighted), proving the post-configuration code runs last:</p>
<div><pre><code>builder.Services
    .AddSingleton&lt;IPostConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureAllConfigureMeOptions&gt;()
    .Configure&lt;ConfigureMeOptions&gt;(builder.Configuration
        .GetSection("configureMe"))
    .Configure&lt;ConfigureMeOptions&gt;(NamedInstance, builder.Configuration
        .GetSection("configureMe"))
    .AddSingleton&lt;IConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureAllConfigureMeOptions&gt;()
;</code></pre>
</div>
<p>Next, we create a second configuration class.</p>


<h3 data-number="10.5.5">Using multiple configurator objects</h3>
<p>A very interesting concept with the ASP.NET Core options pattern is that we can register as many configuration classes as we want. This creates many possibilities, including code from one or more assemblies configuring the same options class.Now that we know how this works, let’s add the <code>ConfigureMoreConfigureMeOptions</code> class, which also adds a line to the <code>Lines</code> property:</p>
<div><pre><code>namespace OptionsConfiguration;
public class ConfigureMoreConfigureMeOptions : IConfigureOptions&lt;ConfigureMeOptions&gt;
{
    public void Configure(ConfigureMeOptions options)
    {
        options.Lines = options.Lines.Append("ConfigureMore:Configure");
    }
}</code></pre>
</div>
<p>This time, we want that class only to augment the default instance, so it implements the <strong>IConfigureOptions&lt;TOptions&gt;</strong> interface (highlighted lines).Next, we must register the binding:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureMoreConfigureMeOptions&gt;();</code></pre>
</div>
<p>As we can see, it’s the same binding but pointing to the <code>ConfigureMoreConfigureMeOptions</code> class instead of the <code>ConfigureAllConfigureMeOptions</code> class.Executing the application and querying the endpoint outputs the following JSON:</p>
<div><pre><code>{
  "defaultInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: ",
      "ConfigureMore:Configure",
      "ConfigureAll:PostConfigure name: "
    ]
  },
  "namedInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: MyNamedInstance",
      "ConfigureAll:Configure Not Default: MyNamedInstance",
      "ConfigureAll:PostConfigure name: MyNamedInstance"
    ]
  }
}</code></pre>
</div>
<p>The preceding JSON shows the line our new class added to only the default instance (highlighted) before the post-configure option.The possibilities are great, right? The code can contribute configuration objects and register them in one of the two phases to configure options objects. Next, we explore a few more possibilities.</p>


<h3 data-number="10.5.6">Exploring other configuration possibilities</h3>
<p>We can mix those configuration classes with extension methods. For example:</p>
<ul>
<li>We can call the <code>Configure</code> and <code>PostConfigure</code> methods multiple times.</li>
<li>We can call the <code>ConfigureAll</code> and <code>PostConfigureAll</code> methods to configure all the options of a given <code>TOptions</code>.</li>
</ul>
<p>Here, we use the <code>PostConfigure</code> method to demonstrate that. Let’s add the following two lines of code (highlighted):</p>
<div><pre><code>const string NamedInstance = "MyNamedInstance";
var builder = WebApplication.CreateBuilder(args);
builder.Services.PostConfigure&lt;ConfigureMeOptions&gt;(
    NamedInstance,
    x =&gt; x.Lines = x.Lines.Append("Inline PostConfigure Before")
);
builder.Services
    .AddSingleton&lt;IPostConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureAllConfigureMeOptions&gt;()
    .Configure&lt;ConfigureMeOptions&gt;(builder.Configuration
        .GetSection("configureMe"))
    .Configure&lt;ConfigureMeOptions&gt;(NamedInstance, builder.Configuration
        .GetSection("configureMe"))
    .AddSingleton&lt;IConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureAllConfigureMeOptions&gt;()
    //.AddSingleton&lt;IConfigureNamedOptions&lt;ConfigureMeOptions&gt;, ConfigureAllConfigureMeOptions&gt;()
    .AddSingleton&lt;IConfigureOptions&lt;ConfigureMeOptions&gt;, ConfigureMoreConfigureMeOptions&gt;()
;
builder.Services.PostConfigure&lt;ConfigureMeOptions&gt;(
    NamedInstance,
    x =&gt; x.Lines = x.Lines.Append("Inline PostConfigure After")
);
// ...</code></pre>
</div>
<p>The preceding code registers two configuration delegates that target our named instance. They both run in the post-configuration phase. So running the app and accessing the endpoint shows the order in which all lines are added:</p>
<div><pre><code>{
  "defaultInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: ",
      "ConfigureMore:Configure",
      "ConfigureAll:PostConfigure name: "
    ]
  },
  "namedInstance": {
    "title": "Configure Me!",
    "lines": [
      "appsettings.json",
      "ConfigureAll:Configure name: MyNamedInstance",
      "ConfigureAll:Configure Not Default: MyNamedInstance",
      "Inline PostConfigure Before",
      "ConfigureAll:PostConfigure name: MyNamedInstance",
      "Inline PostConfigure After"
    ]
  }
}</code></pre>
</div>
<p>In the preceding JSON, we can see that the two highlighted lines are the ones we just added, loaded in order, and not applied to the default options.</p>
<blockquote>
<p>There is one more possibility, which comes from the validation API. This is most likely an unintended side effect, but it works nonetheless.</p>
<blockquote>
<p>The following code adds the <code>"Inline Validate"</code> line after the post-configuration phase:</p>
</blockquote>
</blockquote>
<pre><code>builder.Services.AddOptions&lt;ConfigureMeOptions&gt;().Validate(options =&gt;
{
    // Validate was not intended for this, but it works nonetheless...
    options.Lines = options.Lines.Append("Inline Validate");
    return true;
});</code></pre>
<blockquote>
<p>On the separation of concerns aspect, we should stay away from this. However, knowing this may help you work around a post-configuration order issue one day.</p>
</blockquote>
<p>Now that we know the options interface types, their lifetimes, and many ways to configure their values, it is time to validate them and enforce a certain level of integrity in our programs.</p>



<h2 data-number="10.6">Project – OptionsValidation</h2>
<p>Another feature that comes out of the box is options validation, which allows us to run validation code when a <code>TOptions</code> object is created. The validation code is guaranteed to run the first time an option is created and does not account for subsequent options modifications. Depending on the lifetime of your options object, the validation may or may not run. For example:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Interface</strong></td>
<td><strong>Lifetime</strong></td>
<td><strong>Validation</strong></td>
</tr>
<tr class="even">
<td><code>IOptionsMonitor&lt;TOptions&gt;</code></td>
<td>Singleton</td>
<td>Validate the options once.</td>
</tr>
<tr class="odd">
<td><code>IOptionsFactory&lt;TOptions&gt;</code></td>
<td>Transient</td>
<td>Validate the options every time the code calls the <code>Create</code> method.</td>
</tr>
<tr class="even">
<td><code>IOptionsSnapshot&lt;TOptions&gt;</code></td>
<td>Scoped</td>
<td>Validate the options once per HTTP request (per scope).</td>
</tr>
<tr class="odd">
<td><code>IOptions&lt;TOptions&gt;</code></td>
<td>Singleton</td>
<td>Validate the options once.</td>
</tr>
</tbody>
</table>
Table 9.4: the effect of validation on options lifetime.
<blockquote>
<p>I wrote three test cases in the <code>ValidateLifetime.cs</code> file if you are interested to see this in action.</p>
</blockquote>
<p>We can create validation types to validate options classes. They must implement the <code>IValidateOptions&lt;TOptions&gt;</code> interface or use data annotations such as <code>[Required]</code>. Implementing the interface works very similarly to the options configuration.First, let’s see how to force the validation when the program starts.</p>

<h3 data-number="10.6.1">Eager validation</h3>
<p>Eager validation has been added to .NET 6 and allows catching incorrectly configured options at startup time in a fail-fast mindset.The <code>Microsoft.Extensions.Hosting</code> assembly adds the <code>ValidateOnStart</code> extension method to the <code>OptionsBuilder&lt;TOptions&gt;</code> type.There are different ways of using this, including the following, which binds a configuration section to an options class:</p>
<div><pre><code>services.AddOptions&lt;Options&gt;()
    .Configure(o =&gt; /* Omitted configuration code */)
    .ValidateOnStart()
;</code></pre>
</div>
<p>The highlighted line is all we need to apply our validation rules during startup. I recommend using this as your new default so you know that options are misconfigured at startup time instead of later at runtime, limiting unexpected issues.Now that we know that, let’s look at how to configure options validation.</p>


<h3 data-number="10.6.2">Data annotations</h3>
<p>Let’s start by using <code>System.ComponentModel.DataAnnotations</code> types to decorate our options with validation attributes. We activate this feature with the <code>ValidateDataAnnotations</code> extension method. This also works with eager validation by chaining both methods.</p>
<blockquote>
<p>If you are unfamiliar with <code>DataAnnotations</code>, they are attributes used to validate EF Core and MVC model classes. Don’t worry, they are very explicit, so you should understand the code.</p>
</blockquote>
<p>To demonstrate this, let’s look at the skeleton of two small tests:</p>
<div><pre><code>using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using System.ComponentModel.DataAnnotations;
using Xunit;
namespace OptionsValidation;
public class ValidateOptionsWithDataAnnotations
{
    [Fact]
    public void Should_pass_validation() { /*omitted*/ }
    [Fact]
    public void Should_fail_validation() { /*omitted*/ }
    private class Options
    {
        [Required]
        public string? MyImportantProperty { get; set; }
    }
}</code></pre>
</div>
<p>The preceding code shows that the <code>MyImportantProperty</code> property of the <code>Options</code> class is required and cannot be <code>null</code> (highlighted line). Next, we look at the test cases.The first test is expecting the validation to pass:</p>
<div><pre><code>[Fact]
public void Should_pass_validation()
{
    // Arrange
    var services = new ServiceCollection();
    services.AddOptions&lt;Options&gt;()
        .Configure(o =&gt; o.MyImportantProperty = "A value")
        .ValidateDataAnnotations()
        .ValidateOnStart() // eager validation 
    ;
    var serviceProvider = services.BuildServiceProvider();
    var options = serviceProvider
        .GetRequiredService&lt;IOptionsMonitor&lt;Options&gt;&gt;();
    // Act &amp; Assert
    Assert.Equal(
        "Some important value",
        options.CurrentValue.MyImportantProperty
    );
}</code></pre>
</div>
<p>The test simulates the execution of a program where the IoC container creates the options class, and its consumer (the test) leverages it. The highlighted line sets the property to <code>"A value"</code>, making the validation pass. The code also enables eager validation (<code>ValidateOnStart</code>) on top of the validation of data annotations (<code>ValidateDataAnnotations</code>).The second test is expecting the validation to fail:</p>
<div><pre><code>[Fact]
public void Should_fail_validation()
{
    // Arrange
    var services = new ServiceCollection();
    services.AddOptions&lt;Options&gt;()
        .ValidateDataAnnotations()
        .ValidateOnStart() // eager validation 
    ;
    var serviceProvider = services.BuildServiceProvider();
        // Act &amp; Assert
        var error = Assert.Throws&lt;OptionsValidationException&gt;(
            () =&gt; options.CurrentValue);
        Assert.Collection(error.Failures,
            f =&gt; Assert.Equal("DataAnnotation validation failed for 'Options' members: 'MyImportantProperty' with the error: 'The MyImportantProperty field is required.'.", f)
        );
    );
}</code></pre>
</div>
<p>In the preceding code, the <code>MyImportantProperty</code> is never set (highlighted code), leading to the validation failing and throwing an <code>OptionsValidationException</code>. The test simulates catching that exception.</p>
<blockquote>
<p>The eager validation does not work in the tests because it is not an ASP.NET Core program but xUnit test cases (Fascts).</p>
</blockquote>
<p>That’s it—.NET does the job for us and validates our instance of the <code>Options</code> class using the data annotation like you can do when using EF Core or MVC model.Next, we explore how to create validation classes to validate our options objects manually.</p>


<h3 data-number="10.6.3">Validation types</h3>
<p>To implement options validation types or options validators, we can create a class that implements one or more <code>IValidateOptions&lt;TOptions&gt;</code> interfaces. One type can validate multiple options, and multiple types can validate the same options, so the possible combinations should cover all use cases.Using a custom class is no harder than using data annotations. However, it allows us to remove the validation concerns from the options class and code more complex validation logic. You should pick the way that makes the most sense for your project.</p>
<blockquote>
<p>On top of personal preferences, say you use a third-party library with options. You load that library into your application and expect the configuration to be a certain way. You could create a class to validate that the options class provided by the library is configured appropriately for your application and even validate this at startup time.</p>
<blockquote>
<p>You can’t use data annotations for that because you don’t control the code. Moreover, it is not a general validation that should apply to all consumers but specific validation for that one app.</p>
</blockquote>
</blockquote>
<p>Let’s start with the skeleton of the test class:</p>
<div><pre><code>using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Xunit;
namespace OptionsValidation;
public class ValidateOptionsWithTypes
{
    [Fact]
    public void Should_pass_validation() {}
    [Fact]
    public void Should_fail_validation() {}
    private class Options
    {
        public string? MyImportantProperty { get; set; }
    }
    private class OptionsValidator : IValidateOptions&lt;Options&gt;
    {
        public ValidateOptionsResult Validate(
            string name, Options options)
        {
            if (string.IsNullOrEmpty(options.MyImportantProperty))
            {
                return ValidateOptionsResult.Fail(
                    "'MyImportantProperty' is required.");
            }
            return ValidateOptionsResult.Success;
        }
    }
}</code></pre>
</div>
<p>In the preceding code, we have the <code>Options</code> class that is similar to the previous example but without the data annotation. The difference is that instead of using the <code>[Required]</code> attribute, we created the <code>OptionsValidator</code> class (highlighted) containing the validation logic.<code>OptionsValidator</code> implements <code>IValidateOptions&lt;Options&gt;</code>, which only contains a <code>Validate</code> method. This method allows named and default options to be validated. The <code>name</code> argument represents the options’ names. In our case, we implemented the required logic for all options. The <code>ValidateOptionsResult</code> class exposes a few members to help us, such as the <code>Success</code> and <code>Skip</code> fields, and two <code>Fail()</code> methods.<code>ValidateOptionsResult.Success</code> indicates success. <code>ValidateOptionsResult.Skip</code> indicates that the validator did not validate the options, most likely because it only validates certain named options but not the given one.The <code>ValidateOptionsResult.Fail(message)</code> and <code>ValidateOptionsResult.Fail(messages)</code> methods take a single message or a collection of messages as an argument.To make this work, we must make the validator available to the IoC container, as we did with the options configuration. We explore the two test cases next, which are very similar to the data annotation example.Here’s the first test case that passes the validation:</p>
<div><pre><code>[Fact]
public void Should_pass_validation()
{
    // Arrange
    var services = new ServiceCollection();
    services.AddSingleton&lt;IValidateOptions&lt;Options&gt;, OptionsValidator&gt;();
    services.AddOptions&lt;Options&gt;()
        .Configure(o =&gt; o.MyImportantProperty = "A value")
        .ValidateOnStart()
    ;
    var serviceProvider = services.BuildServiceProvider();
    // Act &amp; Assert
    var options = serviceProvider
        .GetRequiredService&lt;IOptionsMonitor&lt;Options&gt;&gt;();
    Assert.Equal(
        "A value",
        options.CurrentValue.MyImportantProperty
    );
}</code></pre>
</div>
<p>The test case simulates an application that configures the <code>MyImportantProperty</code> correctly, which passes validation. The highlighted line shows how to register the validator class. The rest is done by the framework when using the options class.Next, we explore a test that fails the validation:</p>
<div><pre><code>[Fact]
public void Should_fail_validation()
{
    // Arrange
    var services = new ServiceCollection();
    services.AddSingleton&lt;IValidateOptions&lt;Options&gt;, OptionsValidator&gt;();
    services.AddOptions&lt;Options&gt;().ValidateOnStart();
    var serviceProvider = services.BuildServiceProvider();
    // Act &amp; Assert
    var options = serviceProvider
        .GetRequiredService&lt;IOptionsMonitor&lt;Options&gt;&gt;();
    var error = Assert.Throws&lt;OptionsValidationException&gt;(
        () =&gt; options.CurrentValue);
    Assert.Collection(error.Failures,
        f =&gt; Assert.Equal("'MyImportantProperty' is required.", f)
    );
}</code></pre>
</div>
<p>The test simulates a program where the <code>Options</code> class is not configured appropriately. When accessing the options object, the framework builds the class and validates it, throwing an <code>OptionsValidationException</code> because of the validation rules (highlighted lines).Using types to validate options is handy when you don’t want to use data annotations, can’t use data annotations, or need to implement certain logic that is easier within a method than with attributes.Next, we glance at how to leverage options with FluentValidation.</p>



<h2 data-number="10.7">Project – OptionsValidationFluentValidation</h2>
<p>In this project, we validate options classes using FluentValidation. FluentValidation is a popular open-source library that provides a validation framework different from data annotations. We explore FluentValidation more in <em>Chapter 15</em>, <em>Getting Started with Vertical Slice Architecture</em>, but that should not hinder you from following this example.Here, I want to show you how to leverage a few patterns we’ve learned so far to implement this ourselves with only a few lines of code. In this micro-project, we leverage:</p>
<ul>
<li>Dependency injection</li>
<li>The Strategy design pattern</li>
<li>The Options pattern</li>
<li>Options validation: validation types</li>
<li>Options validation: eager validation</li>
</ul>
<p>Let’s start with the options class itself:</p>
<div><pre><code>public class MyOptions
{
    public string? Name { get; set; }
}</code></pre>
</div>
<p>The options class is very thin, containing only a nullable <code>Name</code> property. Next, let’s look at the FluentValidation validator, which validates that the <code>Name</code> property is not empty:</p>
<div><pre><code>public class MyOptionsValidator : AbstractValidator&lt;MyOptions&gt;
{
    public MyOptionsValidator()
    {
        RuleFor(x =&gt; x.Name).NotEmpty();
    }
}</code></pre>
</div>
<p>If you have never used FluentValidation before, the <code>AbstractValidator&lt;T&gt;</code> class implements the <code>IValidator&lt;T&gt;</code> interface and adds utility methods like <code>RuleFor</code>. The <code>MyOptionsValidator</code> class contains the validation rules.To make ASP.NET Core validate <code>MyOptions</code> instances using FluentValidation, we implement an <code>IValidateOptions&lt;TOptions&gt;</code> interface as we did in the previous example, inject our validator in it, and then leverage it to ensure the validity of <code>MyOptions</code> objects. This implementation of the <code>IValidateOptions</code> interface creates a bridge between the FluentValidation features and the ASP.NET Core options validation.Here is a generic implementation of such a class that could be reused for any type of options:</p>
<div><pre><code>public class FluentValidateOptions&lt;TOptions&gt; : IValidateOptions&lt;TOptions&gt;
    where TOptions : class
{
    private readonly IValidator&lt;TOptions&gt; _validator;
    public FluentValidateOptions(IValidator&lt;TOptions&gt; validator)
    {
        _validator = validator;
    }
    public ValidateOptionsResult Validate(string name, TOptions options)
    {
        var validationResult = _validator.Validate(options);
        if (validationResult.IsValid)
        {
            return ValidateOptionsResult.Success;
        }
        var errorMessages = validationResult.Errors.Select(x =&gt; x.ErrorMessage);
        return ValidateOptionsResult.Fail(errorMessages);
    }
}</code></pre>
</div>
<p>In the preceding code, the <code>FluentValidateOptions&lt;TOptions&gt;</code> class adapts the <code>IValidateOptions&lt;TOptions&gt;</code> interface to the <code>IValidator&lt;TOptions&gt;</code> interface by leveraging FluentValidation in the <code>Validate</code> method. In a nutshell, we use the output of one system and make it an input of another system.</p>
<blockquote>
<p>This type of adaptation is known as the Adapter design pattern. We explore the Adapter pattern in the next chapter.</p>
</blockquote>
<p>Now that we have all the building blocks, let’s have a look at the composition root:</p>
<div><pre><code>using FluentValidation;
using Microsoft.Extensions.Options;
var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddSingleton&lt;IValidator&lt;MyOptions&gt;, MyOptionsValidator&gt;()
    .AddSingleton&lt;IValidateOptions&lt;MyOptions&gt;, FluentValidateOptions&lt;MyOptions&gt;&gt;()
;
builder.Services
    .AddOptions&lt;MyOptions&gt;()
    .ValidateOnStart()
;
var app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();</code></pre>
</div>
<p>The highlighted code is the key to this system:</p>
<ul>
<li>It registers the FluentValidation <code>MyOptionsValidator</code> that contains the validation rules.</li>
<li>It registers the generic <code>FluentValidateOptions</code> instance, so .NET uses it to validate <code>MyOptions</code> class.</li>
<li>Under the hood, The <code>FluentValidateOptions</code> class uses the <code>MyOptionsValidator</code> to validate the options internally.</li>
</ul>
<p>When running the program, the console yields the following error, as expected:</p>
<div><pre><code>Hosting failed to start
Unhandled exception. Microsoft.Extensions.Options.OptionsValidationException: 'Name' must not be empty.
[...]</code></pre>
</div>
<p>This may look like a lot of trouble for a simple required field; however, the <code>FluentValidateOptions&lt;TOptions&gt;</code> is reusable. We could also scan one or more assemblies to register the validator with the IoC container automatically.Now that we’ve explored many ways to configure and validate options objects, it is time to look at a way to inject options classes directly, either by choice or to work around a library capability issue.</p>


<h2 data-number="10.8">Workaround – Injecting options directly</h2>
<p>The only negative point about the .NET Options pattern is that we must tie our code to the framework’s interfaces. We must inject an interface like <code>IOptionsMonitor&lt;Options&gt;</code> instead of the <code>Options</code> class itself. By letting the consumers choose the interface, we let them control the lifetime of the options, which breaks the inversion of control, dependency inversion, and open/closed principles. We should move that responsibility out of the consumer up to the composition root.</p>
<blockquote>
<p>As we explored at the beginning of this chapter, the <code>IOptions</code>, <code>IOptionsFactory</code>, <code>IOptionsMonitor</code>, and <code>IOptionsSnapshot</code> interfaces define the options object’s lifetime.</p>
</blockquote>
<p>In most cases, I prefer to inject <code>Options</code> directly, controlling its lifetime from the composition root, instead of letting the class itself control its dependencies. I’m a little <em>anti-control-freak</em>, I know. Moreover, writing tests using the <code>Options</code> class directly over mocking an interface like <code>IOptionsSnapshot</code> is easier.It just so happens that we can circumvent this easily with the following two parts trick:</p>
<ol>
<li>Set up the options class normally, as explored in this chapter.</li>
<li>Create a dependency binding that instructs the container to inject the options class directly using the Options pattern.</li>
</ol>
<p>The xUnit test of the <code>ByPassingInterfaces</code> class from the <code>OptionsValidation</code> project demonstrates this. Here’s the skeleton of that test class:</p>
<div><pre><code>using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Xunit;
namespace OptionsValidation;
public class ByPassingInterfaces
{
    [Fact]
    public void Should_support_any_scope() { /*...*/ }
    private class Options
    {
        public string? Name { get; set; }
    }
}</code></pre>
</div>
<p>The preceding <code>Options</code> class has only a <code>Name</code> property. We are using it next to explore the workaround in the test case:</p>
<div><pre><code>[Fact]
public void Should_support_any_scope()
{
    // Arrange
    var services = new ServiceCollection();
    services.AddOptions&lt;Options&gt;()
        .Configure(o =&gt; o.Name = "John Doe");
    services.AddScoped(serviceProvider =&gt; {
        var snapshot = serviceProvider
            .GetRequiredService&lt;IOptionsSnapshot&lt;Options&gt;&gt;();
        return snapshot.Value;
    });
    var serviceProvider = services.BuildServiceProvider();
    // Act &amp; Assert
    using var scope1 = serviceProvider.CreateScope();
    var options1 = scope1.ServiceProvider.GetService&lt;Options&gt;();
    var options2 = scope1.ServiceProvider.GetService&lt;Options&gt;();
    Assert.Same(options1, options2);
    using var scope2 = serviceProvider.CreateScope();
    var options3 = scope2.ServiceProvider.GetService&lt;Options&gt;();
    Assert.NotSame(options2, options3);
}</code></pre>
</div>
<p>In the preceding code block, we registered the <code>Options</code> class using a factory method. That way, we can inject the <code>Options</code> class directly (with a scoped lifetime). Moreover, the delegate now controls the <code>Options</code> class's creation and lifetime (highlighted code).And voilà, this workaround allows us to inject <code>Options</code> directly into our system without tying our classes with any .NET-specific options interface.</p>
<blockquote>
<p>Consuming options through the <code>IOptionsSnapshot&lt;TOptions&gt;</code> interface results in a <em>scoped</em> lifetime.</p>
</blockquote>
<p>The <em>Act &amp; Assert</em> section of the test validates the correctness of the setup by creating two scopes and ensuring that each scope returns a different instance while returning the same instance within the scope. For example, both <code>options1</code> and <code>options2</code> come from <code>scope1</code>, so they should be the same. On the other hand, <code>options3</code> comes from <code>scope2</code>, so it should be different than <code>options1</code> and <code>options2</code>.This workaround also applies to existing systems that could benefit from the Options pattern without updating its code—assuming the system is dependency injection-ready. We can also use this trick to compile an assembly that does not depend on <code>Microsoft.Extensions.Options</code>. By using this trick, we can set the lifetime of the options from the composition root, which is a more classic dependency injection-enabled flow. To change the lifetime, use a different interface, like <code>IOptionsMonitor</code> or <code>IOptionsFactory</code>.Next, we explore a way to organize all this code.</p>


<h2 data-number="10.9">Project – Centralizing the configuration</h2>
<p>Creating classes and classes is very object-oriented and follows the single-responsibility principle, among others. However, dividing responsibilities into programming concerns is not always what leads to the easiest code to understand because it creates a lot of classes and files, often spread across multiple layers and more.An alternative is to regroup the initialization and validation with the options class itself, shifting the multiple responsibilities to a single one: an end-to-end options class.In this example, we explore <code>ProxyOptions</code> class, which carries the name of the service and the time the proxy service should cache items in seconds. We want to set a default value for the <code>CacheTimeInSeconds</code> property and validate that the <code>Name</code> property is not empty.On the other hand, we don’t want the consumer of that class to have access to any other methods, like <code>Configure</code> or <code>Validate</code>.To achieve this, we can implement the interfaces explicitly, hiding them from the <code>ProxyOptions</code> but showing them to the consumers of the interfaces. For example, binding the <code>ProxyOptions</code> class to the <code>IValidateOptions&lt;ProxyOptions&gt;</code> interface gives the consumer access to the <code>Validate</code> method through the <code>IValidateOptions&lt;ProxyOptions&gt;</code> interface. Explaining this should be simpler in code; here’s the class:</p>
<div><pre><code>using Microsoft.Extensions.Options;
namespace CentralizingConfiguration;
public class ProxyOptions : IConfigureOptions&lt;ProxyOptions&gt;, IValidateOptions&lt;ProxyOptions&gt;
{
    public static readonly int DefaultCacheTimeInSeconds = 60;
    public string? Name { get; set; }
    public int CacheTimeInSeconds { get; set; }
    void IConfigureOptions&lt;ProxyOptions&gt;.Configure(
        ProxyOptions options)
    {
        options.CacheTimeInSeconds = DefaultCacheTimeInSeconds;
    }
    ValidateOptionsResult IValidateOptions&lt;ProxyOptions&gt;.Validate(
        string? name, ProxyOptions options)
    {
        if (string.IsNullOrWhiteSpace(options.Name))
        {
            return ValidateOptionsResult.Fail(
                "The 'Name' property is required.");
        }
        return ValidateOptionsResult.Success;
    }
}</code></pre>
</div>
<p>The preceding code implements both <code>IConfigureOptions&lt;ProxyOptions&gt;</code> and <code>IValidateOptions&lt;ProxyOptions&gt;</code> interfaces explicitly (highlighted) by omitting the visibility modifier and prefixing the name of the method with the name of the interface, like the following:</p>
<div><pre><code>ValidateOptionsResult IValidateOptions&lt;ProxyOptions&gt;.Validate(...)</code></pre>
</div>
<p>Now, to leverage it, we must register it with the IoC container like this:</p>
<div><pre><code>builder.Services
    .AddSingleton&lt;IConfigureOptions&lt;ProxyOptions&gt;, ProxyOptions&gt;()
    .AddSingleton&lt;IValidateOptions&lt;ProxyOptions&gt;, ProxyOptions&gt;()
    .AddSingleton(sp =&gt; sp
        .GetRequiredService&lt;IOptions&lt;ProxyOptions&gt;&gt;()
        .Value
    )
    .Configure&lt;ProxyOptions&gt;(options 
        =&gt; options.Name = "High-speed proxy")
    .AddOptions&lt;ProxyOptions&gt;()
    .ValidateOnStart()
;</code></pre>
</div>
<p>In the preceding code, we combined many notions we explored, like:</p>
<ul>
<li>Registering the options class</li>
<li>Using the workaround to access the <code>ProxyOptions</code> class directly</li>
<li>Configuring the options inline and through a configurator class</li>
<li>Leverage a validation class</li>
<li>Enforcing the validation by eager loading our options during the startup.</li>
</ul>
<blockquote>
<p>If you comment out the highlighted line, the application will throw an exception on startup.</p>
</blockquote>
<p>The only endpoint defined in the application is the following:</p>
<div><pre><code>app.MapGet("/", (ProxyOptions options) =&gt; options);</code></pre>
</div>
<p>When we run the application, we get the following output:</p>
<div><pre><code>{
  "name": "High-speed proxy",
  "cacheTimeInSeconds": 60
}</code></pre>
</div>
<p>As expected, the value of the <code>cacheTimeInSeconds</code> property equals the value of the <code>DefaultCacheTimeInSeconds</code> field, and the value of the <code>name</code> property to what we configured in the <code>Program.cs</code> file.When using the IntelliSense feature inside your favorite IDE, I’m using Visual Studio 2022 here, we can see only the properties, no method:</p>
<figure>
<img alt="Figure 9.1: VS IntelliSense not showing explicitly implemented interfaces members." src="img/file45.png"/><figcaption aria-hidden="true">Figure 9.1: VS IntelliSense not showing explicitly implemented interfaces members.</figcaption>
</figure>
<p>That’s it; we are done with this organizational technique.</p>
<blockquote>
<p>To keep the composition cleaner, we could encapsulate the bindings in an extension method, and, even better, make that extension method register the whole proxy feature. For example, <code>services.AddProxyService()</code>.</p>
<blockquote>
<p>I’ll let you practice this one on your own as we already explored this.</p>
</blockquote>
</blockquote>
<p>Next, we explore code generators!</p>


<h2 data-number="10.10">Using the configuration-binding source generator</h2>
<p>.NET 8 introduces a <strong>configuration-binding source generator</strong> that provides an alternative to the default reflection-based implementation. In simple terms, the name of the options class properties and the settings keys are now hard-coded, accelerating the configuration retrieval.</p>
<blockquote>
<p>Beware, the settings keys are case-sensitive and map one-on-one with the C# class property name, unlike the non-generated code.</p>
</blockquote>
<p>Web applications using Native AOT deployment (ahead-of-time compilation to native code) or trimming self-contained deployments to ship only the bits in use now leverage this option by default.</p>
<blockquote>
<p>The native AOT deployment model compiles the code to a single runtime environment like Windows x64. It does not need the just-in-time (JIT) compiler since the code is already compiled to the native version of the targetted environment. AOT deployments are self-contained and do not need the .NET runtime to work.</p>
</blockquote>
<p>We can use the <code>EnableConfigurationBindingGenerator</code> property in your <code>csproj</code> file to manually activate or deactivate the generator:</p>
<div><pre><code>&lt;PropertyGroup&gt;
  &lt;EnableConfigurationBindingGenerator&gt;true&lt;/EnableConfigurationBindingGenerator&gt;
&lt;/PropertyGroup&gt;</code></pre>
</div>
<p>Now that the generator is enabled, let’ see how this works. The generator looks for a few options, including the Configure and Bind methods. It then generates the binding code.</p>

<h3 data-number="10.10.1">Project – ConfigurationGenerators: Part 1</h3>
<p>In this first part of the project, we create an options class and register it with the IoC container to consume it through an API endpoint.We use the following options class:</p>
<div><pre><code>namespace ConfigurationGenerators;
public class MyOptions
{
    public string? Name { get; set; }
}</code></pre>
</div>
<p>In the <code>Program.cs</code> file, we can use the source generator like this:</p>
<div><pre><code>builder.Services
    .AddOptions&lt;MyOptions&gt;()
    .BindConfiguration("MyOptions")
;</code></pre>
</div>
<p>As you may have noticed, the preceding code is the same as we used before and does what you expect it to do, but the new source generator generates the code under the hood—no functional or usage changes.Let’s explore another source generator next.</p>



<h2 data-number="10.11">Using the options validation source generator</h2>
<p>.NET 8 introduces the <strong>options validation source generator</strong>, which generates the validation code based on data annotations. The idea is similar to the configuration-binding source generator but for the validation code.To leverage the validation generator, we must add a reference on the <code>Microsoft.Extensions.Options.DataAnnotations</code> package.Afterward, we must:</p>
<ol>
<li>Create an empty validator class.</li>
<li>Ensure the class is <code>partial</code>.</li>
<li>Implement the <code>IValidateOptions&lt;TOptions&gt;</code> interface (but not the methods).</li>
<li>Decorate the validator class with the <code>[OptionsValidator]</code> attribute.</li>
<li>Register the validator class with the container.</li>
</ol>
<p>This procedure sounds complicated but is way simpler in code; let's look at that now.</p>

<h3 data-number="10.11.1">Project – ConfigurationGenerators: Part 2</h3>
<p>In this second part of the project, we continue to build on the previous pieces and add validation to our <code>MyOptions</code> class. Of course, we also want to test the new source generator.Here's the updated <code>MyOptions</code> class:</p>
<div><pre><code>using System.ComponentModel.DataAnnotations;
namespace ConfigurationGenerators;
public class MyOptions
{
    [Required]
    public string? Name { get; set; }
}</code></pre>
</div>
<p>The highlighted line represents the changes. We want to ensure the <code>Name</code> property is not empty.Now that we updated our options class, let's create the following validator class:</p>
<div><pre><code>using Microsoft.Extensions.Options;
namespace ConfigurationGenerators;
[OptionsValidator]
public partial class MyOptionsValidator : IValidateOptions&lt;MyOptions&gt;
{
}</code></pre>
</div>
<p>The preceding code is an empty shell that prepares the class for the code generator. The <code>[OptionsValidator]</code> attribute represents the generator hook (a.k.a. that’s the flag the generator is looking for). And with this code, we are done with steps 1 to 4; simpler than English, right?Now, for the last step, we register our validator like normal:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IValidateOptions&lt;MyOptions&gt;, MyOptionsValidator&gt;();</code></pre>
</div>
<p>To test this out, let's add a <code>valid</code> named options instance bound to the following configuration section in the <code>appsettings.json</code> file:</p>
<div><pre><code>{
  "MyOptions": {
    "Name": "Options name"
  }
}</code></pre>
</div>
<p>Here's how we bind it in the <code>Program.cs</code> file:</p>
<div><pre><code>builder.Services
    .AddOptions&lt;MyOptions&gt;("valid")
    .BindConfiguration("MyOptions")
    .ValidateOnStart()
;</code></pre>
</div>
<p>The preceding code registers the <code>valid</code> named options, binds it to the configuration section <code>MyOptions</code>, and validates it when the application starts.</p>
<blockquote>
<p>Other ways to register the named options also work. I used this one for convenience purposes only.</p>
</blockquote>
<p>If we were to inspect the content of the options at runtime, it would be what we expect; nothing is different from what we explored throughout the chapter:</p>
<div><pre><code>{
  "name": "Options name"
}</code></pre>
</div>
<p>At this point, the program should start.Next, to test this out, let's add another named options class, but an invalid one this time. We won't change anything in the <code>appsettings.json</code> file, and add the following registration code:</p>
<div><pre><code>builder.Services
    .AddOptions&lt;MyOptions&gt;("invalid")
    .BindConfiguration("MissingSection")
    .ValidateOnStart() 
;</code></pre>
</div>
<p>The preceding code binds a missing section to the <code>invalid</code> named options, making the <code>Name</code> property equal to <code>null</code>. That object will not pass our validation because the <code>Name</code> property is required.If we run the application now, we get the following message:</p>
<div><pre><code>Hosting failed to start
Microsoft.Extensions.Options.OptionsValidationException: Name: The invalid.Name field is required.</code></pre>
</div>
<p>From that error, we know the validation works as expected. It is not every day that we are happy when our application doesn’t start but this is one of those time.That's it for the code generation, it behaves the same, but the code under the hood is different, enabling technologies like AOT and trimming that do not support reflection-based mechanisms well. Moreover, code generation should speed up the program execution because the behaviors are hard-coded instead of relying on a dynamic reflection-based approach.Next, let’s dig into another class introduced in .NET 8.</p>



<h2 data-number="10.12">Using the ValidateOptionsResultBuilder class</h2>
<p>The <code>ValidateOptionsResultBuilder</code> is a new type in .NET 8. It allows to dynamically accumulate validation errors and create a <code>ValidateOptionsResult</code> object representing its current state.Its basic usage is straightforward, as we are about to see.</p>

<h3 data-number="10.12.1">Project - ValidateOptionsResultBuilder</h3>
<p>In this project, we are validating the <code>MyOptions</code> object. The type has multiple validation rules, and we want to ensure we are not stopping after the first rule fails validation so a consumer would know all the errors in one go. To achieve this, we decided to use the <code>ValidateOptionsResultBuilder</code> class.Let's start with the options class:</p>
<div><pre><code>namespace ValidateOptionsResultBuilder;
public class MyOptions
{
    public string? Prop1 { get; set; }
    public string? Prop2 { get; set; }
}</code></pre>
</div>
<p>Next, let's implement a validator class that enforces both properties are not empty:</p>
<div><pre><code>using Microsoft.Extensions.Options;
namespace ValidateOptionsResultBuilder;
public class SimpleMyOptionsValidator : IValidateOptions&lt;MyOptions&gt;
{
    public ValidateOptionsResult Validate(string? name, MyOptions options)
    {
        var builder = new Microsoft.Extensions.Options.ValidateOptionsResultBuilder();
        if (string.IsNullOrEmpty(options.Prop1))
        {
            builder.AddError(
                "The value cannot be empty.",
                nameof(options.Prop1)
            );
        }
        if (string.IsNullOrEmpty(options.Prop2))
        {
            builder.AddError(
                "The value cannot be empty.",
                nameof(options.Prop2)
            );
        }
        return builder.Build();
    }
}</code></pre>
</div>
<p>In the preceding code, we create a <code>ValidateOptionsResultBuilder</code> object, add errors to it, then returns an instance of the <code>SimpleMyOptionsValidator</code> class by leveraging its <code>Build</code> method. The usage of the <code>ValidateOptionsResultBuilder</code> class is highlighted.Next, to test this out, we must register the options. Let's also create an endpoint. Here's the <code>Program.cs</code> file:</p>
<div><pre><code>using ValidateOptionsResultBuilder;
using Microsoft.Extensions.Options;
var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddSingleton&lt;IValidateOptions&lt;MyOptions&gt;, SimpleMyOptionsValidator&gt;()
    .AddOptions&lt;MyOptions&gt;("simple")
    .BindConfiguration("SimpleMyOptions")
    .ValidateOnStart()
;
var app = builder.Build();
app.MapGet("/", (IOptionsFactory&lt;MyOptions&gt; factory) =&gt; new
{
    simple = factory.Create("simple")
});
app.Run();</code></pre>
</div>
<p>The preceding code is as normal as it can get after a whole chapter on the Options pattern. We register our options class, the validator, and create an endpoint.When we call the endpoint, we get the following result:</p>
<div><pre><code>Hosting failed to start
Microsoft.Extensions.Options.OptionsValidationException: Property Prop1: The value cannot be empty.; Property Prop2: The value cannot be empty.</code></pre>
</div>
<p>As expected, the application failed to start because the validation of the <code>MyOptions</code> class failed. One difference is that we have two combined error messages instead of one.As a reference, a validator doing the same without using the <code>ValidateOptionsResultBuilder</code> type would look like this:</p>
<div><pre><code>using Microsoft.Extensions.Options;
namespace ValidateOptionsResultBuilder;
public class ClassicMyOptionsValidator : IValidateOptions&lt;MyOptions&gt;
{
    public ValidateOptionsResult Validate(string? name, MyOptions options)
    {
        if (string.IsNullOrEmpty(options.Prop1))
        {
            return ValidateOptionsResult.Fail(
                $"Property {nameof(options.Prop1)}: The value cannot be empty."
            );
        }
        if (string.IsNullOrEmpty(options.Prop2))
        {
            return ValidateOptionsResult.Fail(
                $"Property {nameof(options.Prop2)}: The value cannot be empty."
            );
        }
        return ValidateOptionsResult.Success;
    }
}</code></pre>
</div>
<p>The highlighted code represents the standard process which get replaced by the use of the <code>ValidateOptionsResultBuilder</code> type in the <code>SimpleMyOptionsValidator</code> class.This concludes our project. Nothing very complex, yet it is a nice addition to help accumulate multiple error messages. On top of that, the <code>ValidateOptionsResultBuilder</code> type can also accumulate <code>ValidationResult</code> and <code>ValidateOptionsResult</code> objects which can lead to more complex systems like collecting results from multiple validators. I’ll let you fiddle with this one.Let’s recap this chapter before jumping into ASP.NET Core logging.</p>



<h2 data-number="10.13">Summary</h2>
<p>This chapter explored the Options pattern, a powerful tool allowing us to configure our ASP.NET Core applications. It enables us to change the application without altering the code. The capability even allows the application to reload the options at runtime when a configuration file is updated without downtime. We learned to load settings from multiple sources, with the last loaded source overriding previous values. We discovered the following interfaces to access settings and learned that the choice of interface influences the lifetime of the options object:</p>
<ul>
<li><code>IOptionsMonitor&lt;TOptions&gt;</code></li>
<li><code>IOptionsFactory&lt;TOptions&gt;</code></li>
<li><code>IOptionsSnapshot&lt;TOptions&gt;</code></li>
<li><code>IOptions&lt;TOptions&gt;</code></li>
</ul>
<p>We delved into manually configuring options in the composition root and loading them from a settings file. We also learned how to inject options into a class and configure multiple instances of the same options type using named options. We explored encapsulating the configuration logic into classes to apply the single responsibility principle (SRP). We achieved this by implementing the following interfaces:</p>
<ul>
<li><code>IConfigureOptions&lt;TOptions&gt;</code></li>
<li><code>IConfigureNamedOptions&lt;TOptions&gt;</code></li>
<li><code>IPostConfigureOptions&lt;TOptions&gt;</code></li>
</ul>
<p>We also learned that we could mix configuration classes with inline configurations using the <code>Configure</code> and <code>PostConfigure</code> methods and that the registration order of configurators is crucial as they are executed in order of registration.We also delved into options validation. We learned that the frequency at which options objects are validated depends on the lifetime of the options interface used. We also discovered the concept of eager validation, which allows us to catch incorrectly configured options classes at startup time. We learned to use data annotations to decorate our options with validation attributes such as <code>[Required]</code>. We can create validation classes to validate our options objects for more complex scenarios. Those validation classes must implement the <code>IValidateOptions&lt;TOptions&gt;</code> interface. We also learned how to bridge other validation frameworks like <em>FluentValidation</em> to complement the out-of-the-box functionalities or accommodate your taste for a different validation framework.We explored a workaround allowing us to inject options classes directly into their consumers. Doing this allows us to control their lifetime from the composition root instead of letting the types consuming them control their lifetime. This approach aligns better with dependency injection and Inversion of Control principles. That also makes testing the classes easier.Finally, we looked at the .NET 8 code generators that change how the options are handled but do not impact how we use the Options pattern. We also explored the <code>ValidateOptionsResultBuilder</code> type, also introduced in .NET 8.The Options pattern helps us adhere to the SOLID principles, as illustrated next:</p>
<ul>
<li><p><strong>S</strong>: The Options pattern divides managing settings into multiple pieces where each has a single responsibility. Loading unmanaged settings into strongly typed classes is one responsibility, validating options using classes is another, and configuring options from multiple independent sources is one more.</p>
<blockquote>
<p>On the other hand, I find data annotations validation to mix two responsibilities in the options class, bending this principle. If you like data annotations, I don’t want to stop you from using them.</p>
<blockquote>
<p>Data annotations can seem to improve development speed but make testing validation rules harder. For example, testing a <code>Validate</code> method that returns a <code>ValidateOptionsResult</code> object is easier than attributes.</p>
</blockquote>
</blockquote></li>
<li><strong>O</strong>: The different <code>IOptions*&lt;Toptions&gt;</code> interfaces break this principle by forcing the consumer to decide what lifetime and capabilities the options should have. To change the lifetime of a dependency, we must update the consuming class when using those interfaces. On the other hand, we explored an easy and flexible workaround that allows us to bypass this issue for many scenarios and inject the options directly, inverting the dependency flow again, leading to open/closed consumers.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: The <code>IValidateOptions&lt;TOptions&gt;</code> and <code>IConfigureOptions&lt;TOptions&gt;</code> interfaces are two good examples of segregating a system into smaller interfaces where each has a single purpose.</li>
<li><strong>D</strong>: The options framework is built around interfaces, allowing us to depend on abstractions.</li>
</ul>
<blockquote>
<p>Again, the <code>IOptions*&lt;Toptions&gt;</code> interfaces are the exceptions to this. Even if they are interfaces, they tie us to implementation details like the options lifetime. In this case, I think it is more beneficial to inject the options object directly (a data contract) instead of those interfaces.</p>
</blockquote>
<p>Next, we explore .NET logging, which is another very important aspect of building applications; good traceability can make all the difference when observing or debugging applications.</p>


<h2 data-number="10.14">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>Name one interface we can use to inject a settings class.</li>
<li>Name the two phases the ASP.NET Core uses when configuring options.</li>
<li>How significant is the order in which we register configuration objects and inline delegates?</li>
<li>Can we register multiple configuration classes?</li>
<li>What is eager validation, and why should you use it?</li>
<li>What interface must we implement to create a validator class?</li>
</ol>


<h2 data-number="10.15">Further reading</h2>
<p>Here are some links to build upon what we learned in the chapter:</p>
<ul>
<li>Options pattern in ASP.NET Core (official docs): <a href="https://adpg.link/RTGc">https://adpg.link/RTGc</a></li>
<li>Quickstart: Create an ASP.NET Core app with Azure App Configuration: <a href="https://adpg.link/qhLV">https://adpg.link/qhLV</a></li>
<li>Secret storage in the Production environment with Azure Key Vault: <a href="https://adpg.link/Y5D7">https://adpg.link/Y5D7</a></li>
</ul>


<h2 data-number="10.16">Answers</h2>
<ol>
<li>We can use one of the following interfaces: <code>IOptionsMonitor&lt;TOptions&gt;</code>, <code>IOptionsFactory&lt;TOptions&gt;</code>, <code>IOptionsSnapshot&lt;TOptions&gt;</code>, or <code>IOptions&lt;TOptions&gt;</code>.</li>
<li>The configuration and the post-configuration phases.</li>
<li>Configurators are executed in the order of their registration, so their order is crucial.</li>
<li>Yes, we can register as many configuration classes as we want.</li>
<li>Eager validation allows catching incorrectly configured options at startup time, which can save you runtime issues.</li>
<li>We must implement the <code>IValidateOptions&lt;TOptions&gt;</code> interface.</li>
</ol>


</body>
</html>
