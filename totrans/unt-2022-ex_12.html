<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor169" class="pcalibre1 pcalibre calibre6"/>9</h1>
<h1 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor170" class="pcalibre1 pcalibre calibre6"/>Completing the Adventure Game</h1>
<p class="calibre3">In <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, we started by creating a flexible health system that can be added to any object to give it health, take damage, and heal. The system is extensible, meaning the things that can deal with damage and apply healing can be anything without the need to modify the <code>HealthSystem</code> class because we used interfaces to implement the behavior (not concrete class types). With objects now able to take damage, we continued by updating <code>Player</code> and enemy objects to use health – so, we have the semblance of a real game in the making.</p>
<p class="calibre3">We continued by creating a wave spawner that instantiates new enemies on a fixed time interval and integrates with the existing patrol behavior. This allows us to add more complex enemy behavior, which adds new challenges to the game.</p>
<p class="calibre3">Finally, we further explored composition by refactoring some of our reusable components to explore a different approach to destroying the heal pickup object. The importance of good programming practices and interfaces to build flexible and extensible systems was highlighted through examples.</p>
<p class="calibre3">In this chapter, we’ll complete the adventure game by creating a simple quest system for collecting key pieces in the level that are required for solving an entryway security puzzle lock on the habitat station located on the planet’s surface. We will also introduce a new global event system for keeping our code loosely coupled. The event system will efficiently manage communication between various quest system components throughout the code base, so we’ll tackle that first.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre17">
<li class="calibre15">Creating an event system in C# to tie things together loosely</li>
<li class="calibre15">Creating a quest system for a collecting keys mission</li>
<li class="calibre15">Solving the key puzzle and winning the game</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to create a quest system that is integrated across different classes while being loosely coupled (that is, reducing dependency by not having external (concrete) class references) and scalable via the use of a new reusable global event system we’ll also create. You’ll also be able to integrate and customize a puzzle system for your use.</p>
<h1 id="_idParaDest-163" class="calibre5"><a id="_idTextAnchor171" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter while using the same artwork that was created for the project in this book, download the assets from the GitHub link provided in this section.</p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop. Alternatively, you’ll need a graphics program that can export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).</p>
<p class="calibre3"><a id="_idTextAnchor172" class="pcalibre1 pcalibre calibre6"/>You can download the complete project from GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-164" class="calibre5"><a id="_idTextAnchor173" class="pcalibre1 pcalibre calibre6"/>Creating an event system in C# to tie things together loosely</h1>
<p class="calibre3">We won’t need a UML <a id="_idIndexMarker866" class="pcalibre1 pcalibre calibre6"/>diagram here as the design is quite simple. We’ll use a <code>Dictionary</code> collection (a special kind of C# collection) to hold the name of an event that we’ll assign the event’s callback handlers. The added callback handlers will all be invoked when the event is triggered. Although I say this is simple, I didn’t introduce it earlier because a few programming concepts still needed to be covered first.</p>
<h2 id="_idParaDest-165" class="calibre8"><a id="_idTextAnchor174" class="pcalibre1 pcalibre calibre6"/>The new event system</h2>
<p class="calibre3">Since a UML diagram <a id="_idIndexMarker867" class="pcalibre1 pcalibre calibre6"/>won’t illustrate the functionality of <code>EventSystem</code> very well in this case, I’ve decided to create the following diagram as an introduction to the implementation (see <em class="italic">Figure 9</em><em class="italic">.1</em>):</p>
<div><div><img alt="Figure 9.1 – EventSystem diagram" src="img/B18347_09_1.jpg" class="calibre94"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – EventSystem diagram</p>
<p class="calibre3">Before looking at the following code, do a quick mental exercise to see if you can visualize what the code should look like from this diagram.</p>
<p class="calibre3">Given this diagram, here is the class template that makes up the basis for our new event system, minus<a id="_idIndexMarker868" class="pcalibre1 pcalibre calibre6"/> some details we haven’t covered yet; is it similar to what you anticipated seeing?</p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.Events;
using System;
using System.Collections.Generic;
public class EventSystem : MonoBehaviour
{
    private Dictionary&lt;string, Delegate&gt; _events
        = new();
    public void AddListener&lt;T&gt;(
        string eventName, UnityAction&lt;T&gt; listener)
    {
        // UNDONE: Subscribe handler to event name.
    }
    public void RemoveListener&lt;T&gt;(
        string eventName, UnityAction&lt;T&gt; listener)
    {
        // UNDONE: Unsubscribe handler from event name.
    }
    public void TriggerEvent&lt;T&gt;(string eventName, T arg)
    {
        // UNDONE: Invoke handlers for event name.
    }
}</pre> <p class="calibre3">You didn’t necessarily know what the <code>Dictionary</code> declaration would be – we haven’t covered it yet – but <a id="_idIndexMarker869" class="pcalibre1 pcalibre calibre6"/>you at least knew that we needed a declaration for it, right?</p>
<p class="calibre3">We have a few additional things to unpack here and introduce some new C# items, including <code>Dictionary</code>, <code>Delegate</code>, and generic types (as you’ve probably noticed, <code>&lt;T&gt;</code> and <code>T</code> sprinkled throughout the code):</p>
<ul class="calibre17">
<li class="calibre15"><code>Dictionary&lt;string, Delegate&gt;</code>: A C# <code>Dictionary</code> is a collection type that contains a list of <code>List</code>, a collection type that contains a single list of a type.<p class="calibre3">Let’s put this into some game development terms… a C# <code>Dictionary</code> is kind of like a magic bag where you can store lots of items and find anything you want, so long as it has a unique name. You can keep track of all the cool stuff your player will need on their adventure, keeping your game organized and awesome!</p><ul class="calibre22"><li class="calibre15"><code>string</code> type, which indicates the key type for the item in the dictionary. We’ll set the key to identify the specific event by name, and the event handler methods will be <em class="italic">added </em><em class="italic">to it</em>.</li><li class="calibre15"><code>Delegate</code> type and is the value being stored for the specific key item. We’ll set the value to a delegate type, such as <code>UnityAction</code>, that can have method handlers added to it (note that here, <code>delegate</code> is the base type for <code>UnityAction</code>). The event can be triggered later by the event’s name, invoking all the assigned event handler methods. Simples!</li><li class="calibre15"><code>Dictionary</code>, we can assign a new empty dictionary by specifying just the <code>new</code> keyword. This is new for C# in Unity 2022.2 since previously, you’d have to specifically restate <code>Dictionary</code> and the types for <em class="italic">key</em> and <em class="italic">value</em> again here – but you’d still have to do this for serialized variables assignable in the <strong class="bold">Inspector</strong> view!</li></ul></li>
</ul>
<p class="callout-heading">Dictionary (C#)</p>
<p class="callout"><strong class="source-inline1">Dictionary</strong> represents a collection of keys and values. It has similar properties and methods compared<a id="_idIndexMarker870" class="pcalibre1 pcalibre calibre6"/> to a <strong class="bold">List</strong> collection type. For additional reading, go to <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0</a>.</p>
<ul class="calibre17">
<li class="calibre15"><code>AddListener()</code>: We’ll <a id="_idIndexMarker871" class="pcalibre1 pcalibre calibre6"/>call this method when we add an event to <code>EventSystem</code>. The method signature has the following parameters:<ul class="calibre22"><li class="calibre15"><code>&lt;T&gt;</code>: In C#, there is a programming concept <a id="_idIndexMarker872" class="pcalibre1 pcalibre calibre6"/>called <code>T</code> represents <em class="italic">any type</em> as a generic type parameter. This allows you to define a method, class, parameter, or something else that can work with any type specified by the calling code, such as <code>string</code>, <code>int</code>, <code>float</code>, <code>Vector3</code>, <code>GameObject</code>, and so on. This allows reuse across different parts of the code without the need to use specific types and repeat the same code to support those types. It may sound a bit complicated this early on, but I hope it is understandable through the preceding example.</li><li class="calibre15">Our use case for a generic type is to implement an event delegate that can pass in any type as an argument. This will become clearer as we work through the rest of <code>EventSystem</code>.</li><li class="calibre15"><code>eventName</code>: A <code>string</code> type that uniquely identifies the event that’s been <em class="italic">registered</em> with <code>EventSystem</code>. It’s how we add additional listeners to a specific event and how we know what event to trigger.</li><li class="calibre15"><code>listener</code>: <code>UnityAction&lt;T&gt;</code>, which is the event delegate. <code>UnityAction</code> should be familiar since it was first introduced in <a href="B18347_03.xhtml#_idTextAnchor058" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, as an event listener that was used to update the UI. The difference here is that we are adding a generic parameter of the <code>T</code> type, which means the handler method can pass a single argument of any type when invoked.</li></ul></li>
<li class="calibre15"><code>RemoveListener()</code>: This is used when removing an event from <code>EventSystem</code>. The<a id="_idIndexMarker873" class="pcalibre1 pcalibre calibre6"/> method signature is the same as that for <code>AddListener()</code>, so we don’t need to repeat ourselves here. However, there will be one glaringly obvious difference: we’ll be removing a method handler instead of adding one.</li>
<li class="calibre15"><code>TriggerEvent()</code>: We’ll call this method when we want to invoke the specific event for which method handlers were added as listeners (via <code>AddListeners()</code>, of course). The method signature has the following parameters:<ul class="calibre22"><li class="calibre15"><code>eventName</code>: Again, this is the event name string we’ll specify for invoking the method handlers (that is, the added listeners).</li><li class="calibre15"><code>T arg</code>: The parameter value we’ll pass into the invoked methods that will be handled so that they can receive and process any required data. Again, being a generic type, <code>T</code>, we’ll be able to pass in an argument of any type (nice, right?).</li></ul></li>
</ul>
<p class="calibre3">In the preceding code, I said <em class="italic">event name</em>, but we won’t do something as silly as using string literals for the event names throughout the code base. Instead, let’s create an <code>EventConstants</code> class that we’ll use for the event names. This would be similar to how we added a <code>Tags</code> class when referencing tags assigned to our objects in the game through code (for example, <code>Player</code>).</p>
<p class="calibre3">Let’s define our first event name constant by creating the following <code>EventConstants</code> class, saved in the <code>Assets/Scripts/Systems</code> folder:</p>
<pre class="source-code">
public class EventConstants
{
    public const string MyFirstEvent = "MyFirstEvent";
}</pre> <p class="calibre3">The event name will be the <em class="italic">constant</em> (figuratively and literally) that loosely ties things together, so we don’t require concrete class references between classes that would observe and respond to events. Now, we can independently test our classes – via <code>Player</code> doesn’t need to specify a reference to <code>UIManager</code>, <code>Enemy</code>, and so on. We can also move a class to a new project without worrying about bringing in unnecessary classes.</p>
<p class="calibre3">Now that we’ve <a id="_idIndexMarker875" class="pcalibre1 pcalibre calibre6"/>learned about the event system template, as well as how we’ll specify events, let’s dig into the specifics of the implemented methods: <code>AddListener()</code>, <code>RemoveListener()</code>, and <code>TriggerEvent()</code>.</p>
<h3 class="calibre10">Event management methods</h3>
<p class="calibre3">First, let’s look at<a id="_idIndexMarker876" class="pcalibre1 pcalibre calibre6"/> the <code>AddListener()</code> method. To recap, <code>AddListener()</code> is responsible for adding an event to the dictionary of events if it doesn’t already exist (that is, registering the event) and adding the listener to the event’s handler method <code>delegate</code>, like so:</p>
<pre class="source-code">
    public void AddListener&lt;T&gt;(string eventName,
        UnityAction&lt;T&gt; listener)
    {
        if (!_events.ContainsKey(eventName))
            _events.Add(eventName, null);
        _events[eventName] = (UnityAction&lt;T&gt;)_events[eventName]
            + listener;
    }</pre> <p class="calibre3">Let’s break down the code here:</p>
<ul class="calibre17">
<li class="calibre15"><code>ContainsKey()</code>: The very first thing we’ll need to do when adding an event to our dictionary of events is to see if we’ve already registered one of the same event names (pretty logical, right?). A C# <code>Dictionary</code> provides several methods here – similar to a C# <code>List</code> in many ways – for achieving this base functionality that we can leverage.<p class="calibre3">Specifically, we use <code>ContainsKey()</code> and pass in <code>eventName</code>. This will return a Boolean value of <code>true</code> if the key already exists in the dictionary and <code>false</code> if not, so we can use an <code>if</code> statement to evaluate and take the proper action.</p></li>
<li class="calibre15"><code>Add()</code>: Working <a id="_idIndexMarker877" class="pcalibre1 pcalibre calibre6"/>with the result returned from <code>ContainsKey()</code>, we’ll go ahead and add the event – using the event name as the key – to the dictionary using the <code>Add()</code> method (again, similar to C# <code>List</code>).<p class="calibre3">Note that for the value parameter – as in <code>Add(key, value)</code> – we’re specifying <code>null</code> for the delegate. That’s simply because we’ll assign the listener to the delegate in the following line, where it doesn’t matter whether this event was just added.</p></li>
<li class="calibre15"><code>_events[eventName]</code>: We can get the value for a specific event from the <code>_events</code> dictionary by simply specifying the key in square braces (this is similar to how we’d return the value of an array by specifying the index (<code>int</code>) in square braces).</li>
<li class="calibre15"><code>(UnityAction&lt;T&gt;)</code>: Placing a type in parenthesis before another type is called casting in C#. Since <code>_events[eventName]</code> is a <code>Delegate</code> type, and <code>UnityAction</code> has delegate as its base type, we can operate on the event dictionary value as <code>UnityAction</code> via a type conversion by casting it (an explicit conversion). Here, again, <code>&lt;T&gt;</code> indicates we will use a generic for a parameter.</li>
</ul>
<p class="callout-heading">Casting (C#)</p>
<p class="callout">C# is a strongly typed language (or statically typed) at compile time, so once a variable is declared, it cannot be declared again as a different type. To overcome this, should you need to copy a value into a variable of another type, C# provides various type conversion operations, and casting is one of them.</p>
<p class="callout">Here’s some additional reading: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions</a>.</p>
<ul class="calibre17">
<li class="calibre15"><code>+ listener</code>: <code>UnityAction</code> allows you to add additional listeners; using the <code>+</code> (add) operator will enable us to do just that.<p class="calibre3">Note that just the <code>+</code> operator is the correct syntax to add a listener to a delegate that may be <code>null</code> or already has listeners, unlike previously, all the way back in <a href="B18347_03.xhtml#_idTextAnchor058" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, where we used the <code>+=</code> operator to add an event handler method when subscribing to events.</p></li>
</ul>
<p class="calibre3">Now, let’s look at<a id="_idIndexMarker878" class="pcalibre1 pcalibre calibre6"/> the opposite. For <code>RemoveListener()</code>, we want to remove an event listener when it’s no longer needed – especially when an object is destroyed – so that we don’t try invoking an invalid handler method reference. This is generally just good practice – for some listener types, not doing so can cause memory leaks:</p>
<pre class="source-code">
    public void RemoveListener&lt;T&gt;(string eventName,
        UnityAction&lt;T&gt; listener)
    {
        if (_events.ContainsKey(eventName))
            _events[eventName] =
                (UnityAction&lt;T&gt;)_events[eventName] - listener;
    }</pre> <p class="calibre3">We don’t need to break down the code here again because it’s essentially the same as <code>AddListener()</code>. The primary differences are as follows:</p>
<ul class="calibre17">
<li class="calibre15">We don’t need to add the event in case it doesn’t exist; we only care if it does exist so that we can remove a listening handler method</li>
<li class="calibre15">In place of the <code>+</code> operator, we use the <code>-</code> operator to remove the specified listener handler method</li>
</ul>
<p class="calibre3">Lastly, we have the <code>TriggerEvent()</code> method. The naming of these methods has been self-explanatory so far, so it should be no surprise what’s next. However, we are doing something different here to retrieve the dictionary’s value for the <code>eventName</code> key that’s been<a id="_idIndexMarker879" class="pcalibre1 pcalibre calibre6"/> provided to invoke the added handler methods:</p>
<pre class="source-code">
    public void TriggerEvent&lt;T&gt;(string eventName, T arg)
    {
        if (_events.TryGetValue(eventName, out Delegate del))
            (del as UnityAction&lt;T&gt;)?.Invoke(arg);
    }</pre> <p class="calibre3">Here is how things work:</p>
<ul class="calibre17">
<li class="calibre15"><code>_events.TryGetValue()</code>: You may find this syntax familiar since we’ve already used <code>TryGetComponent()</code> a few times. Very simply, we try to get the value for the specified <code>eventName</code> key, and if it exists, we return the value as an <code>out</code> parameter called <code>del</code>. The <code>if</code> evaluation will short-circuit if it’s not found, so <code>Invoke()</code> will only be called if a value is returned.</li>
<li class="calibre15"><code>(del as UnityAction&lt;T&gt;)</code>: We introduce the <code>as</code> operator keyword here. Similar to how we used <code>()</code> to cast to another type, we can also use <code>as</code> for type conversion. Specifically, <code>as</code> is a good choice when working with a nullable type, which we want to do here because we’re also using the null-conditional operator (<code>?.</code>) so that we won’t erroneously try and call <code>Invoke()</code> on a null delegate.</li>
</ul>
<p class="callout-heading">The as operator (C#)</p>
<p class="callout">The <strong class="source-inline1">as</strong> operator <a id="_idIndexMarker880" class="pcalibre1 pcalibre calibre6"/>converts objects to a different type but returns <strong class="source-inline1">null</strong> if the conversion fails instead of throwing an exception like other type conversion techniques would.</p>
<p class="callout">Here’s some additional reading: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator</a>.</p>
<ul class="calibre17">
<li class="calibre15"><code>Invoke(arg)</code>: This is how we tie back into the generic parameter specified by <code>T</code> in the <code>UnityAction&lt;T&gt;</code> declaration for our listener delegate. The last part, bringing it full circle, will be the method signature for the handler method receiving the argument. This should all make sense when we get to the <em class="italic">Creating a quest system for a collecting keys mission</em> section, when we put the event system through its paces. Promise!</li>
</ul>
<p class="calibre3">Next, so that we don’t overlook an essential detail for how we will access the event system from our <a id="_idIndexMarker881" class="pcalibre1 pcalibre calibre6"/>classes that need to work with events, let’s make the event system a Singleton – an actual Singleton!</p>
<h3 class="calibre10">Enforcing a Singleton instance</h3>
<p class="calibre3">Our <code>EventSystem</code> will <a id="_idIndexMarker882" class="pcalibre1 pcalibre calibre6"/>be a <strong class="bold">Singleton</strong> instance so that it can be accessed from anywhere in <a id="_idIndexMarker883" class="pcalibre1 pcalibre calibre6"/>our code. Still, we haven’t implemented a full Singleton pattern yet where only a single instance is guaranteed to exist. We’ll sort this out by enforcing the pattern and destroying any want-to-be duplicates.</p>
<p class="calibre3">We saw a rudimentary implementation back in <a href="B18347_03.xhtml#_idTextAnchor058" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, where we just set the instance to a static variable without even attempting to seek and destroy additional instances being introduced (bad us). Here we go. Add the following <code>Instance</code> public static variable declaration and the new <code>Awake()</code> method code:</p>
<pre class="source-code">
public class EventSystem : MonoBehaviour
{
    public static EventSystem Instance { get; private set; }
    …
    private void Awake()
    {
        if (Instance == null)
            Instance = this;
        else
            Destroy(gameObject);
        DontDestroyOnLoad(gameObject);
    }
    …</pre> <p class="calibre3">The magic <a id="_idIndexMarker884" class="pcalibre1 pcalibre calibre6"/>happens in the <code>Awake()</code> method, where<a id="_idIndexMarker885" class="pcalibre1 pcalibre calibre6"/> we previously just did this:</p>
<pre class="source-code">
private void Awake() =&gt; Instance = this;</pre> <p class="calibre3">We can now check if our static <code>Instance</code> has been assigned yet; if not, assign it. However, if <code>Instance</code> was already assigned, a want-to-be duplicate will be added to our <strong class="bold">Scene Hierarchy</strong>. Let’s destroy it right away!</p>
<p class="calibre3">Our <code>EventManager</code> will need to hang around all the time to respond to registering and triggering events at any time, and from any class, throughout the life of our game, so we’ll need a way to keep it persistent.</p>
<p class="calibre3">Sometimes, the coding process feels like a game: find something, destroy that, keep this. So, if you’re <a id="_idIndexMarker886" class="pcalibre1 pcalibre calibre6"/>not having fun, you’re doing something wrong!</p>
<p class="callout-heading">EventSystem | Complete code</p>
<p class="callout">To view the complete<a id="_idIndexMarker887" class="pcalibre1 pcalibre calibre6"/> code for the <strong class="source-inline1">EventSystem</strong> class and all the event-related code in this chapter, visit this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/</a>.</p>
<h3 class="calibre10">Singleton persistence</h3>
<p class="calibre3">Unity provides a<a id="_idIndexMarker888" class="pcalibre1 pcalibre calibre6"/> way to keep particular objects persistent, no matter the current scene, survive loading new scenes, and more, and that is by using <code>DontDestroyOnLoad</code>. Simply calling it and passing the <code>GameObject</code> object you want to persist as the target parameter is all that’s needed. In our case, in <code>Awake()</code>, we’re passing in <code>gameObject</code>, which represents the current object the component (script) is attached to.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">DontDestroyOnLoad</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml</a>.</p>
<h2 id="_idParaDest-166" class="calibre8"><a id="_idTextAnchor175" class="pcalibre1 pcalibre calibre6"/>Systems GameObject</h2>
<p class="calibre3">Objects <a id="_idIndexMarker889" class="pcalibre1 pcalibre calibre6"/>specified as <code>DontDestroyOnLoad</code> must be in the root of the <code>EventSystem</code> component. I would place this at the very top of the scene hierarchy to maintain some visible order of dependency for things – it’s entirely up to you how you choose to organize things here. Also, remember that you can add empty objects with the sole purpose of having organizational headers (don’t forget to set the tag to <code>EditorOnly</code>), as seen in the <code>Systems</code> object referenced in <em class="italic">Figure 9</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 9.2 – Systems root GameObject" src="img/B18347_09_2.jpg" class="calibre95"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Systems root GameObject</p>
<p class="calibre3">In this section, we learned how to create a global event system that allows our classes to remain loosely coupled because we don’t require type references of one class in another to respond to triggered actions. If the <code>EventSystem</code> component’s usage is still unclear, don’t<a id="_idIndexMarker890" class="pcalibre1 pcalibre calibre6"/> fret – in the next section, we’ll cover an example straight away by creating a simple quest system based on it.</p>
<h1 id="_idParaDest-167" class="calibre5"><a id="_idTextAnchor176" class="pcalibre1 pcalibre calibre6"/>Creating a quest system for a collecting keys mission</h1>
<p class="calibre3">Now that we have<a id="_idIndexMarker891" class="pcalibre1 pcalibre calibre6"/> our super decoupled global event <a id="_idIndexMarker892" class="pcalibre1 pcalibre calibre6"/>system, we’ll immediately put it to good use. Referring again to our GDD, we know that the player, at some point, has to collect some key pieces to solve a puzzle so that they can advance:</p>
<table class="no-table-style" id="table001-5">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is the secondary game mechanic for the </strong><strong class="bold">adventure game?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The player will search the environment for hidden parts of a key. The pieces will need to be combined correctly as input to gain access to the entryway of the habitat station.</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 9.1 – GDD quest reference</p>
<p class="calibre3">A typical game system that can support “collecting a certain number of items” is a quest system. A possibly more simplified approach, but also a system-based approach to solving this problem, could be a basic inventory system. A quest system, however, will offer additional opportunities to provide a more complete example – especially for implementing the event system.</p>
<p class="calibre3">Let’s have a quick look at what the player will be searching for during their quest and interacting with to regain entry to the habitat station constructed on the planet. The Kryk’zylx technology is a mystery to us, but suffice it to say, they like a good challenge when securing their bases. Both the key pieces that the evil plant entity has scattered and the entryway security puzzle lock with the missing pieces can be seen in the following figure:</p>
<div><div><img alt="Figure 9.3 – Keys and security puzzle art" src="img/B18347_09_3.jpg" class="calibre96"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Keys and security puzzle art</p>
<p class="calibre3">Our mission now<a id="_idIndexMarker893" class="pcalibre1 pcalibre calibre6"/> is <a id="_idIndexMarker894" class="pcalibre1 pcalibre calibre6"/>to code the quest system and flesh out the game mechanics required to implement it. So, let’s get started!</p>
<h2 id="_idParaDest-168" class="calibre8"><a id="_idTextAnchor177" class="pcalibre1 pcalibre calibre6"/>The quest system</h2>
<p class="calibre3">I’ll provide the <a id="_idIndexMarker895" class="pcalibre1 pcalibre calibre6"/>code template for a <code>QuestSystem</code> class, similar to how the event system was introduced. However, I’ll give the full implementation this time because you’ll find it shares a similar design to <code>EventSystem</code>. I also won’t provide a diagram this time. I’m going to save it as a challenge for you to create one on your own at the end of this section.</p>
<p class="calibre3">Create a new script named <code>QuestSystem</code> in the <code>Assets/Scripts/Systems</code> folder with the following code:</p>
<pre class="source-code">
using UnityEngine;
using System.Collections.Generic;
public class QuestSystem : MonoBehaviour
{
    private Dictionary&lt;string, bool&gt; _quests = new();
    public void StartQuest(string questName)
    {
        if (!_quests.ContainsKey(questName))
            _quests.Add(questName, false);
    }
    public void CompleteQuest(string questName)
    {
        if (_quests.ContainsKey(questName))
            _quests[questName] = true;
    }
}</pre> <p class="calibre3">Okay, no, you’re<a id="_idIndexMarker896" class="pcalibre1 pcalibre calibre6"/> not experiencing déjà vu. The basic concept for the <code>QuestSystem</code> code is a similar pattern to <code>EventSystem</code>. At its core, there’s also a C# <code>Dictionary</code>.</p>
<p class="calibre3">Here’s the breakdown:</p>
<ul class="calibre17">
<li class="calibre15"><code>Dictionary&lt;string, bool&gt;</code>: The declaration for the <code>_quests</code> dictionary will hold a <code>string</code> key to identify the quest’s name (similar to the event name), and the value for the entry will be of the <code>bool</code> type as an indication of whether the quest has been completed (that is, <code>true</code> equals completed).</li>
<li class="calibre15"><code>StartQuest()</code>: Starting a quest means adding it to the dictionary if it’s not already added. Quests will be identified by a unique <code>questName</code> that’s passed in as the only argument. Simple. As. That.</li>
<li class="calibre15"><code>CompleteQuest()</code>: As stated earlier, we’re going to use the <code>_quest</code> value as the quest completion indicator, so if the specified quest exists in the dictionary, then we’ll assign <code>true</code> for its value (<code>bool</code> has a default value of <code>false</code>, which is why we didn’t need to assign this anywhere).</li>
</ul>
<p class="calibre3">We’ll be repeating ourselves a bit here again with how <code>QuestSystem</code> will be accessed when required since we’ll be using a Singleton pattern again. Primarily, however, we will decouple<a id="_idIndexMarker897" class="pcalibre1 pcalibre calibre6"/> references to <code>QuestSystem</code> whenever possible by going through the global event system (that is, no tightly coupled objects).</p>
<p class="calibre3">Add the following declarations for the public static <code>Instance</code> property and the <em class="italic">Singleton management code</em> to the <code>Awake()</code> method, like so:</p>
<pre class="source-code">
    public static QuestSystem Instance { get; private set; }
    private void Awake()
    {
        if (Instance == null)
            Instance = this;
        else
            Destroy(gameObject);
        DontDestroyOnLoad(gameObject);
    }</pre> <p class="calibre3">Using the Singleton pattern solves a big problem for obtaining references to our core systems, but it also comes with some disadvantages compared to more complex patterns (for example, service locator patterns). We’re going to address one of these shortcomings now before proceeding further.</p>
<p class="calibre3">We have a potential problem with our systems because we require the <code>EventSystem</code> instance to be available to every other system when the game starts – being the core system loosely<a id="_idIndexMarker898" class="pcalibre1 pcalibre calibre6"/> coupling everything together and playing nice. With that being the case, we must ensure it gets initialized first.</p>
<h2 id="_idParaDest-169" class="calibre8"><a id="_idTextAnchor178" class="pcalibre1 pcalibre calibre6"/>Script Execution Order</h2>
<p class="calibre3">To set the execution <a id="_idIndexMarker899" class="pcalibre1 pcalibre calibre6"/>order for which script event functions are run (for example, the <code>Awake()</code> message event), Unity provides a <strong class="bold">Script Execution Order</strong> assignment in <strong class="bold">Project Settings</strong>. Quite simply, you can set a lower-ordered number for scripts you want to be initialized first and specifically before others that would rely on it being initialized.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Script Execution Order settings: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml</a>.</p>
<p class="calibre3">For our usage here, we require <code>EventSystem</code> to be run before <code>QuestSystem</code>.</p>
<ol class="calibre14">
<li class="calibre15">Open <strong class="bold">Edit</strong> | <strong class="bold">Project Settings…</strong> | <strong class="bold">Script </strong><strong class="bold">Execution Order</strong>.</li>
<li class="calibre15">If they’re not already in the list, add these two scripts to the list using the little plus (<strong class="bold">+</strong>) button at the bottom right.</li>
<li class="calibre15">Then, click and drag them into the position indicated:</li>
</ol>
<div><div><img alt="Figure 9.4 – Script Execution Order in Project Settings" src="img/B18347_09_4.jpg" class="calibre97"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Script Execution Order in Project Settings</p>
<ol class="calibre14">
<li value="4" class="calibre15">Click <strong class="bold">Apply</strong> when<a id="_idIndexMarker900" class="pcalibre1 pcalibre calibre6"/> you’re finished.</li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Unity also provides a code solution for specifying the execution order of scripts using an attribute. The attribute is <strong class="source-inline1">[DefaultExecutionOrder(int)]</strong>, and you can decorate the class declaration and set the order value.</p>
<p class="callout">For example, adding this attribute to the <strong class="source-inline1">QuestSystem</strong> class declaration would look like this:</p>
<pre class="source-code">
[DefaultExecutionOrder(-500)]
public class QuestSystem : MonoBehaviour
{ …</pre> <p class="calibre3">And speaking of execution, make sure to add the <code>QuestSystem</code> component to the <code>EventSystem</code>).</p>
<p class="calibre3">Now, what’s a quest system without any quests?!</p>
<h2 id="_idParaDest-170" class="calibre8"><a id="_idTextAnchor179" class="pcalibre1 pcalibre calibre6"/>The quest</h2>
<p class="calibre3">Your mission, should <a id="_idIndexMarker902" class="pcalibre1 pcalibre calibre6"/>you choose to accept it, will be to find and collect the missing pieces that are required to solve the habitat entryway security puzzle lock. The quest object representing the actual quest with its requirements is arguably the essential part of any quest system. As you saw in the <em class="italic">Script Execution Order</em> section, keeping a list of the active quests is quite simple – we add a quest to a list and set a variable to <code>true</code> when it’s completed. Easy-peasy.</p>
<p class="calibre3">The next part of the quest system we’ll cover will be the quest code. Before we even get started, however, we will ensure that any quest we define will have a unique identifier that is easily assignable (even in the <strong class="bold">Inspector</strong> view).</p>
<h3 class="calibre10">Name consistency</h3>
<p class="calibre3">The problem we’ll <a id="_idIndexMarker903" class="pcalibre1 pcalibre calibre6"/>need to solve now is how to guarantee consistency for quest names without using magic strings, reference the quest names from different parts of the code, and have them selectable in the <strong class="bold">Inspector</strong> view.</p>
<p class="calibre3">We saw how to use <code>enum</code> when the <a id="_idIndexMarker904" class="pcalibre1 pcalibre calibre6"/>simple <code>enum</code> similarly now, but instead of states for an FSM, we’re going to use it for unique quest name identifiers; again, as a reminder, we’re not going to rely on string literals! This is similar to how we’ve used string constants before (for example, event names and tags), but being an <code>enum</code> type over a constant means we have some added benefit, including when it comes to selecting from a list of available quests in the <strong class="bold">Inspector</strong> view!</p>
<p class="calibre3">Create a new script named <em class="italic">QuestNames</em> in the <code>Assets/Scripts/Quests</code> folder. Replace all of the default script template code with the following code:</p>
<pre class="source-code">
public enum QuestNames
{
    // Quest name, unique ID.
    CollectKeysQuest = 10
}</pre> <p class="calibre3">This is where we’ll define any new quest we add to the game. We’ve populated the <code>CollectKeysQuest</code> name and given it a unique ID of <code>10</code> (this is any arbitrary number that’s not already being used) – be sure to follow this pattern, assigning the name and ID, when adding additional quest names.</p>
<p class="calibre3">We’ll see how the<a id="_idIndexMarker905" class="pcalibre1 pcalibre calibre6"/> quest names will be declared and referenced as we proceed with our coding mission to complete this quest system!</p>
<h3 class="calibre10">Quest base class</h3>
<p class="calibre3">Yup, that’s right, another<a id="_idIndexMarker906" class="pcalibre1 pcalibre calibre6"/> base class means we will use more OOP design here! And since we covered this already in <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, it’s barely an inconvenience for you to bang this out, right? Our specific quests will then derive from the new quest base class we’ll write next, providing a template for consistency in implementing quests.</p>
<p class="calibre3">We’ve already defined the quest names. A quest name will need to be a part of every quest, so let’s start by setting up the base class for our quests with that.</p>
<p class="calibre3">Create a new script named <code>QuestBase</code> in the <code>Assets/Scripts/Quests</code> folder:</p>
<pre class="source-code">
using UnityEngine;
public abstract class QuestBase : MonoBehaviour
{
    public QuestNames QuestName =&gt; _questName;
    [SerializeField]
    private QuestNames _questName;
    …</pre> <p class="calibre3">The first thing to note is that the <code>QuestBase</code> class is declared as <code>public abstract class</code>. This means we won’t be able to use this class directly – we cannot add an abstract class to a <code>GameObject</code> object in the <code>QuestBase</code> (that is, this is only the <em class="italic">base template</em>).</p>
<p class="calibre3">Second, we can see the declaration for <code>QuestName</code>, which uses the <code>QuestNames</code> <code>enum</code> type we previously wrote. We have encapsulated a <code>private _questName</code> variable and decorated it with the <code>[SerializeField]</code> attribute so that it can be assigned in the <code>enum</code> type draws in the <strong class="bold">Inspector</strong> view:</p>
<div><div><img alt="Figure 9.5 – The Quest Name Inspector view assignment dropdown" src="img/B18347_09_5.jpg" class="calibre98"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The Quest Name Inspector view assignment dropdown</p>
<p class="calibre3">The <code>_questName</code> value is made available to other classes via the <code>public QuestName</code> property – the expression body (<code>=&gt;</code>) declares the property as a getter only (as in, you won’t be able to assign a value).</p>
<p class="calibre3">So far, so good. Still, this<a id="_idIndexMarker907" class="pcalibre1 pcalibre calibre6"/> was a bit of a review since nothing we’ve covered here is new. The same goes for the first two methods we’ll declare for the <code>QuestBase</code> abstract class. We’ll use <code>virtual</code> methods for both <code>StartQuest()</code> and <code>QuestCompleted()</code> because the inheriting class may need to override the provided base functionality:</p>
<pre class="source-code">
    …
    public virtual void StartQuest()
        =&gt; QuestSystem.Instance.StartQuest(QuestName.ToString());
    protected virtual void QuestCompleted(string questName)
        =&gt; Debug.Log($"Quest '{questName}' completed!");
    …</pre> <p class="calibre3">The code may be self-explanatory at this point, but it always helps to explain. Let’s break it down:</p>
<ul class="calibre17">
<li class="calibre15"><code>public virtual void StartQuest()</code>: This method has a <code>public</code> accessor because it is intended to be called from an external class to trigger the start of the quest. We call the quest system’s <code>StartQuest()</code> method (via its Singleton instance) and pass the unique quest identifier (that is, the <code>enum</code>-based quest name) to add it to the active quests <code>Dictionary</code> for later reference.<p class="calibre3">We use <code>virtual</code> in the method signature in case the inheriting class would need to do more than start the quest.</p></li>
<li class="calibre15"><code>protected virtual QuestCompleted()</code>: This method has a <code>protected</code> accessor, so it can only be called within the class and by derived classes – not an external class because the logic to determine quest completion should be evaluated on the specific quest’s requirements and not some external factors.<p class="calibre3">Again, we use <code>virtual</code> in the method signature in case the inheriting class would need to do something else (such as implementing different logic or behavior for different types of quests, such as side quests). For now, we’re simply logging a message to the console that the quest was completed.</p></li>
</ul>
<p class="calibre3">Now for the fun part! We’ll <a id="_idIndexMarker908" class="pcalibre1 pcalibre calibre6"/>be leaning on the event system to implement the following function: listening for when the quest has been completed. This is why we didn’t declare the <code>QuestCompleted()</code> method as <code>public</code> – <code>QuestCompleted()</code> is the handler method that’s passed into the event system as the listener:</p>
<pre class="source-code">
    …
    private void OnEnable() =&gt; AddListeners();
    private void OnDisable() =&gt; RemoveListeners();
    protected virtual void AddListeners()
        =&gt; EventSystem.Instance.AddListener&lt;string&gt;(
            EventConstants.OnQuestCompleted, QuestCompleted);
    protected virtual void RemoveListeners()
        =&gt; EventSystem.Instance.RemoveListener&lt;string&gt;(
            EventConstants.OnQuestCompleted, QuestCompleted);
}</pre> <p class="calibre3">Here are just a few points in need of explanation:</p>
<ul class="calibre17">
<li class="calibre15"><code>OnEnable()</code>, <code>OnDisable()</code>: We add and remove the event system listeners for the base class, respectively. <code>AddListeners()</code> and <code>RemoveListeners()</code> can be overridden in the inheriting class if additional listeners need to be added for the specific quest.</li>
<li class="calibre15"><code>AddListeners()</code>: Here, we add a listener to the event system for quest completion. We’ll use a string argument to pass the quest’s name as the parameter to the handler method.</li>
<li class="calibre15"><code>RemoveListeners()</code>: We just need to remove the listener added in <code>AddListeners()</code> – remember, removing event listeners is always good practice!<p class="calibre3">Note that even though it doesn’t make sense that simply removing a listener would require an argument for passing a parameter, we still need it because the delegate definition must match the method signature of the handler method that was added as the listener.</p></li>
</ul>
<p class="calibre3">As the last step, add the string constant for <code>EventConstants.OnQuestCompleted</code> to the <code>EventConstants</code> script. Or, in your IDE, <em class="italic">OnQuestCompleted</em> should have that red squiggly line indicating the definition was not found. Go ahead and use your IDE’s refactoring tools to generate the variable (but ensure<a id="_idIndexMarker909" class="pcalibre1 pcalibre calibre6"/> it is consistent with the other event name constants).</p>
<p class="calibre3">With that, <code>QuestBase</code> has been completed! Now, prepare to make a specific quest class derived from the base class.</p>
<h3 class="calibre10">Collect keys quest</h3>
<p class="calibre3">We call the missing<a id="_idIndexMarker910" class="pcalibre1 pcalibre calibre6"/> security puzzle key pieces that need to be <a id="_idIndexMarker911" class="pcalibre1 pcalibre calibre6"/>collected <em class="italic">keys</em>, and three will be required to complete our quest. These are simple requirements for a simple quest, but we still need a way to not only explicitly declare the requirement but evaluate and communicate completion, too.</p>
<p class="calibre3">We’ll start by creating a new script called <code>CollectKeysQuest</code> in the <code>Assets/Scripts/Quests</code> folder and inherit from <code>QuestBase</code> instead of <code>MonoBehaviour</code>:</p>
<pre class="source-code">
using UnityEngine;
public class CollectKeysQuest : QuestBase
{
    [SerializeField] private int _numKeysRequired = 3;
    private int _keysCollected = 0;
    …</pre> <p class="calibre3">We also declare the number of keys required to be collected to complete this quest. <code>_numKeysRequired</code> will be <code>private</code> so that no other class has access to it, but we’ll use the <code>[SerializeField]</code> attribute to set this value in the <code>3</code>).</p>
<p class="calibre3"><code>_keysCollected</code> will keep track of the number of keys the player has collected (<code>private</code> – it’s no one else’s business), and we’ll increment that value via the event system (so handy):</p>
<pre class="source-code">
    …
    protected override void AddListeners()
    {
        base.AddListeners();
        EventSystem.Instance.AddListener&lt;bool&gt;(
            EventConstants.OnKeyCollected, KeyCollected);
    }
    protected override void RemoveListeners()
    {
        base.RemoveListeners();
        EventSystem.Instance.RemoveListener&lt;bool&gt;(
            EventConstants.OnKeyCollected, KeyCollected);
    }
    private void KeyCollected(bool arg0)
    {
        _keysCollected++;
        // UNDONE: Evaluate quest completion.
    }
}</pre> <p class="calibre3">Okay, it is a familiar pattern, but let’s clarify it still:</p>
<ul class="calibre17">
<li class="calibre15"><code>override AddListeners()</code>: For this specific quest, we need to listen for when the player<a id="_idIndexMarker912" class="pcalibre1 pcalibre calibre6"/> has collected a key. Using the event<a id="_idIndexMarker913" class="pcalibre1 pcalibre calibre6"/> system, we don’t need to know anything about the <code>Player</code> object or even the script implemented to collect the key; we observe that a key was collected and handled with the <code>KeyCollected()</code> method. We use the <code>override</code> keyword here because we need more functionality than the base class alone provides:<ul class="calibre22"><li class="calibre15"><code>base.AddListeners()</code>: Speaking of what the base class provides, we still need it! We can still ensure the base class methods that are overridden by using the <code>base</code> keyword – for accessing base class members within the derived class.</li></ul></li>
<li class="calibre15"><code>override RemoveListeners()</code>: You got it – maintaining good practice removing what listeners were added:<ul class="calibre22"><li class="calibre15"><code>base.RemoveListeners()</code>: The same as for <code>base.AddListeners()</code></li></ul></li>
<li class="calibre15"><code>KeyCollected()</code>: I promise we won’t have a breadcrumb trail of UNDONE tokens to follow again! But, for now, we’ll just increment the <code>_keysCollected</code> variable when the <code>OnKeyCollected</code> event is triggered:<ul class="calibre22"><li class="calibre15"><code>bool arg0</code>: Our <code>EventSystem</code> requires us to pass an argument with the handler event. We don’t need to pass any parameters for the key collected event, but we must still declare something! A bool value being the smallest type, I feel, is the least evil we can do here.</li><li class="calibre15"><code>EventConstants.OnKeyCollected</code>: Be sure to add it to <code>EventCostants</code> to resolve the missing definition error.</li></ul></li>
</ul>
<p class="calibre3">Excellent – we have a quest! Now, if only we could be given the quest! We don’t have snarky NPCs in our game standing on street corners, just giving out quests to any weary traveler passing<a id="_idIndexMarker914" class="pcalibre1 pcalibre calibre6"/> through, so we’ll leverage some reusable components <a id="_idIndexMarker915" class="pcalibre1 pcalibre calibre6"/>we already have to trigger the start of our quest.</p>
<h4 class="calibre29">Quest giver GameObject</h4>
<p class="calibre3">We don’t need a new<a id="_idIndexMarker916" class="pcalibre1 pcalibre calibre6"/> script for giving the quest to the player; we just need to start <em class="italic">Collect Keys Quest</em>. We can easily do that by creating a trigger volume in the environment, using our ever-so-useful and reusable <code>TriggerEvent</code> component, and simply calling the publicly declared <code>StartQuest()</code> method on a <code>CollectKeysQuest</code> component.</p>
<p class="calibre3">Here’s what it’ll look like in the <strong class="bold">Scene</strong> view and <strong class="bold">Inspector</strong> view:</p>
<div><div><img alt="Figure 9.6 – Quest giver object in the scene" src="img/B18347_09_6.jpg" class="calibre99"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Quest giver object in the scene</p>
<p class="calibre3">Have a go at constructing the object and components that make up the <em class="italic">quest giver</em> object and place it in the level near where the player starts.</p>
<p class="calibre3">Did you manage to <a id="_idIndexMarker917" class="pcalibre1 pcalibre calibre6"/>assemble it successfully? Let’s review the steps:</p>
<ol class="calibre14">
<li class="calibre15">Create a new GameObject in the scene and name it <code>Quest Giver – Keys Quest</code>, then position it in the level near where the player starts (refer to <em class="italic">Figure 9</em><em class="italic">.6</em> for an example).</li>
<li class="calibre15">(<em class="italic">A</em>) Add the <code>CollectKeysQuest</code> script to the new object. <em class="italic">Collect Keys Quest</em> should be selected in the <strong class="bold">Quest Name</strong> dropdown since it’s our only quest, and set the number of keys required to three.</li>
<li class="calibre15">(<em class="italic">B</em>) Add a <code>BoxCollider2D</code> component next (use the <code>true</code> because we don’t want the player to interact with this GameObject physically; we only want to use it as a trigger volume. Adjust the collider’s size to guarantee the player will collide with it.</li>
<li class="calibre15">(<em class="italic">C</em>) Add a <code>TriggeredEvent</code> component and wire up the methods that are called when <code>OnTriggered()</code> is invoked.</li>
<li class="calibre15">Click the little plus (<code>CollectKeysQuest</code> component to the first event field and select the <code>CollectKeysQuest.StartQuest()</code> method from the drop-down list.</li><li class="upper-roman">Drag <code>BoxCollider2D</code> to the second event field, select <code>BoxCollider2D.enabled</code> from the dropdown, and leave the checkbox unticked (that is, set <code>false</code>; this will disable the collider and prevent triggering <em class="italic">start the quest</em> additional times).</li><li class="upper-roman">Ensure only the player can trigger the quest start by ticking off <code>IsTriggeredByPlayer</code>.</li></ol></li>
<li class="calibre15">As the final step, save the <code>Prefab</code> object in the <code>Assets/Prefabs</code> folder (by dragging it from the hierarchy into the <strong class="bold">Project</strong> window). That way, we can quickly drop a quest giver into the level later.</li>
</ol>
<p class="calibre3">Quest accepted! You <a id="_idIndexMarker918" class="pcalibre1 pcalibre calibre6"/>wouldn’t start a quest that was impossible to complete, would you? Now, let’s see how we complete <em class="italic">Collect </em><em class="italic">Keys Quest</em>.</p>
<h4 class="calibre29">Quest completion</h4>
<p class="calibre3">We’ve defined a <a id="_idIndexMarker919" class="pcalibre1 pcalibre calibre6"/>specific quest, we’ve given the quest to the player, and now we must progress on the quest to complete it. Progress is made when we collect keys in the game level (you know, kind of like the collection game we completed as the first project in this book).</p>
<p class="calibre3">In the <code>CollectKeysQuest</code> class, as you know, the <code>KeyCollected()</code> method is called when the <code>OnKeyCollected</code> event is triggered. We left it at only incrementing the variable, keeping track of the number of keys collected. Let’s finish it up by evaluating whether the quest requirements have been satisfied to complete the quest.</p>
<p class="calibre3">Complete the <code>KeyCollected</code> method by adding the <code>if</code> block, like so:</p>
<pre class="source-code">
    private void KeyCollected(int keyId)
    {
        _keysCollected++;
        if (_keysCollected &gt;= _numKeysRequired)
        {
            QuestSystem.Instance.CompleteQuest(
                QuestName.ToString());
            EventSystem.Instance.TriggerEvent(
                EventConstants.OnQuestCompleted, QuestName);
        }
    }</pre> <p class="calibre3">A very simple <code>if</code> statement checks whether the incremented <code>_keysCollected</code> variable is greater than or equal to (<code>&gt;=</code>) the number of keys required to complete the quest, as defined by the <code>_numKeysRequired</code> variable (set in the <code>then</code> we’ll do the following:</p>
<ul class="calibre17">
<li class="calibre15">Call <code>CompleteQuest()</code> on the <code>QuestSystem</code> Singleton instance and pass in the quest name as the parameter. We need to use <code>ToString()</code> on the <code>QuestName</code> variable because it is an <code>enum</code> value, and internally, it is stored as an <code>int</code> type; we need a <code>string</code> type as the argument.</li>
<li class="calibre15">Trigger the <code>OnQuestCompleted</code> event via the <code>EventSystem</code> Singleton instance <a id="_idIndexMarker920" class="pcalibre1 pcalibre calibre6"/>and, again, pass in <code>QuestName</code> as a parameter. This is also a <code>string</code> type.</li>
</ul>
<p class="calibre3">The <em class="italic">UNDONE token quest</em> is complete. Yay!</p>
<h4 class="calibre29">Quest event constants added</h4>
<p class="calibre3">We need to add <a id="_idIndexMarker921" class="pcalibre1 pcalibre calibre6"/>some event name constants to support what we just added for the quest system and <em class="italic">Collect Keys Quest</em>. As a recap, here’s what the <code>EventConstants</code> script should look like now. I have added some comments for some quick organization to keep things tidy:</p>
<pre class="source-code">
public class EventConstants
{
    public const string OnMyEvent = "OnMyEvent";
    // QuestSystem events.
    public const string OnQuestCompleted = "OnQuestCompleted";
    // Quests' events.
    public const string OnKeyCollected = "OnKeyCollected";
}</pre> <p class="calibre3">Our quest system has come together nicely, but we’re still missing one final bit of functionality, and that is being able to know whether or not a quest that was started (that is, added to <a id="_idIndexMarker922" class="pcalibre1 pcalibre calibre6"/>the <code>_quests</code> dictionary) has been completed (that is, the requirements of the quest mission have been satisfied, and <code>CompleteQuest()</code> was called).</p>
<h3 class="calibre10">Quest status</h3>
<p class="calibre3">To know the quest’s <a id="_idIndexMarker923" class="pcalibre1 pcalibre calibre6"/>status, go ahead and add the following <code>IsQuestComplete()</code> method to the <code>QuestSystem</code> class:</p>
<pre class="source-code">
    public bool IsQuestComplete(string questName)
    {
        if (_quests.TryGetValue(questName, out bool status))
            return status;
        return false;
    }</pre> <p class="calibre3">You should recognize a familiar pattern here with <code>TryGetValue()</code> (as a method available in <code>Dictionary</code>) – we’ve covered a similar pattern with <code>TryGetComponent()</code> several times. <code>TryGetValue()</code> will return <code>true</code> if the value exists in the <code>_quests</code> dictionary. Then, set the returned value to the <code>out</code> variable, <code>status</code>, for immediate consumption by the following <code>if</code> block code. This is extremely convenient, and, as I’ve espoused, I’m a big fan of this pattern (even going so far as to replicate this pattern in my code).</p>
<p class="calibre3">We’ll continue with short-circuiting the method by immediately returning the quest’s <code>status</code> from the <code>TryGetValue()</code> call. Otherwise, we return <code>false</code>, indicating a default condition of the quest not being complete due to it not even existing in the dictionary.</p>
<p class="calibre3">Now that we can <a id="_idIndexMarker924" class="pcalibre1 pcalibre calibre6"/>query the status of a specific quest from our <code>QuestSystem</code> Singleton instance, we can create a reusable component to use in our game to respond accordingly.</p>
<h3 class="calibre10">Quest completed component</h3>
<p class="calibre3">We’ll need something <a id="_idIndexMarker925" class="pcalibre1 pcalibre calibre6"/>to check for quest completion when the player gets to the habitat entryway. This will allow us to show the security puzzle lock if the quest has been completed or provide some other action if not.</p>
<p class="calibre3">Create a new script named <code>QuestHasCompleted</code> in the <code>Assets/Scripts/Quests</code> folder:</p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.Events;
public class QuestHasCompleted : MonoBehaviour
{
    public QuestNames QuestName;
    public UnityEvent OnQuestComplete;
    public UnityEvent OnQuestIncomplete;
    public void CheckQuestComplete()
    {
        if (QuestSystem.Instance.
            IsQuestComplete(QuestName.ToString()))
        {
            OnQuestComplete?.Invoke();
            return;
        }
        OnQuestIncomplete?.Invoke();
    }
}</pre> <p class="calibre3">This isn’t anything we haven’t seen before. The <code>QuestName</code> field will allow us to specify which quest we want to know the completion status for in the <code>UnityEvent</code> fields will enable us to set actions for complete and incomplete statuses. Simples.</p>
<p class="calibre3">Here’s how an object<a id="_idIndexMarker926" class="pcalibre1 pcalibre calibre6"/> based on this new component will look in the <strong class="bold">Inspector</strong> view:</p>
<div><div><img alt="Figure 9.7 – Puzzle trigger object setup" src="img/B18347_09_7.jpg" class="calibre100"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Puzzle trigger object setup</p>
<p class="calibre3">Let’s create this <em class="italic">puzzle trigger</em> object now and wire it up so that when the player enters the trigger volume, and if <em class="italic">Collect Keys Quest</em> has been completed, it will disable <code>PlayerInput</code> (ensuring the player can no longer move) and show <strong class="bold">Puzzle</strong> (solving the entryway security<a id="_idIndexMarker927" class="pcalibre1 pcalibre calibre6"/> puzzle lock is the player’s goal for this level).</p>
<p class="calibre3">Here’s how we construct a <em class="italic">Has the quest been </em><em class="italic">completed?</em> object:</p>
<ol class="calibre14">
<li class="calibre15">Create a new empty GameObject in the <code>Puzzle Trigger</code> because we want to show the puzzle when the player reaches the habitat entryway.</li>
<li class="calibre15">(<em class="italic">A</em>) Add a <code>QuestHasCompleted</code> component and select <strong class="bold">Collect Keys Quest</strong> from the dropdown of available quest names.</li>
<li class="calibre15">Assign the following events for <code>OnQuestComplete()</code> (click the plus (<code>PlayerInput.enabled</code> from the dropdown, and leave the checkbox unticked. Disabling <code>PlayerInput</code> in this way will mean no input will be processed to enact with the player – we don’t want the player character to move any longer because it would now be time to solve the puzzle.</li><li class="upper-roman">The following assignment is for our future selves; we’ll use a reference to the <strong class="bold">Key Puzzle</strong> object and make it active (display it) so that the player can work on solving it – <strong class="bold">Key Puzzle</strong> will be added in the last section of this chapter, so we’ll revisit this assignment then.</li></ol></li>
<li class="calibre15">(<em class="italic">B</em>) Add a <code>TriggeredEvent</code> component and assign the <code>QuestHasCompleted</code> component to the <code>OnTriggered</code> event, then select <code>QuestHasCompleted.CheckQuestComplete()</code> from the dropdown. Ensure <strong class="bold">IsTriggeredByPlayer</strong> is ticked.</li>
<li class="calibre15">Don’t forget to add a <code>BoxCollider2D</code> component and set <code>true</code>; the size will be adjusted accordingly concerning the habitat entryway so that the player will interact with it when reaching it.</li>
</ol>
<p class="calibre3">For placement, if you haven’t taken the liberty of adding the habitat entryway to your level yet, now’s the <a id="_idIndexMarker928" class="pcalibre1 pcalibre calibre6"/>time! We haven’t explored every nuance of your level design while bringing everything together – naturally, you’ve been doing your level design homework:</p>
<ol class="calibre14">
<li class="calibre15">Place the habitat entryway sprite <em class="italic">entryway</em> from the <code>Assets/Sprites/Object Elements</code> folder into the environment and use the <code>Background</code> <strong class="bold">Sorting Layer</strong>. You can organize it in the <strong class="bold">Scene Hierarchy</strong> using what we previously established as the <strong class="bold">Level (Default)</strong> | <strong class="bold">In </strong><strong class="bold">Back</strong> structure.</li>
<li class="calibre15">Place the <strong class="bold">Puzzle Trigger</strong> object at the entryway and set the collider size accordingly (refer to <em class="italic">Figure 9</em><em class="italic">.7</em> for an example).</li>
</ol>
<p class="calibre3">As we saw in the preceding code and description, the <code>QuestHasCompleted</code> component has an event that is triggered when we check the status for both complete and incomplete quest statuses. We already populated the <code>OnQuestComplete()</code> event but also have an <code>OnQuestIncomplete()</code> event. We won’t be assigning any function here for now, but imagine that we could display a dialog to our player stating that the quest’s requirements haven’t been met for them to proceed.</p>
<p class="callout-heading">Challenge | Quest system diagram</p>
<p class="callout">Create a basic object reference diagram for the quest system while using the event system diagram in <em class="italic">Figure 9</em><em class="italic">.1</em> as a reference. Don’t be so concerned with the shapes you choose to represent each part, but do be consistent and use the same shape for the same object type. If you want to challenge yourself further, create a UML diagram!</p>
<p class="calibre3">Everything is in<a id="_idIndexMarker929" class="pcalibre1 pcalibre calibre6"/> place for us to fully execute a quest’s life cycle. Now, we need to collect those pesky key pieces!</p>
<h2 id="_idParaDest-171" class="calibre8"><a id="_idTextAnchor180" class="pcalibre1 pcalibre calibre6"/>Collecting keys</h2>
<p class="calibre3">We’ve tackled<a id="_idIndexMarker930" class="pcalibre1 pcalibre calibre6"/> player<a id="_idIndexMarker931" class="pcalibre1 pcalibre calibre6"/> collectible items a few different ways now, so collectible key items will be a familiar concept. The only difference is that we will now rely on <code>EventSystem</code> to trigger a <em class="italic">key collected</em> event. As we already know, the <code>CollectKeysQuest</code> quest is listening for <code>OnKeyCollected</code> being invoked, so this is where we’ll implement triggering it.</p>
<p class="calibre3">As you could probably also guess, we’re going to use a <code>Prefab</code> object for the puzzle piece keys (via <strong class="bold">Prefab Variant</strong>). So, that will require a component to implement the key collection behavior.</p>
<h3 class="calibre10">KeyItem component</h3>
<p class="calibre3">First, let’s prepare<a id="_idIndexMarker932" class="pcalibre1 pcalibre calibre6"/> the artwork we’ll use to make the collectible key pieces. For a visual reference, here’s what we’ll be working with for creating the key pieces and a placeholder security puzzle lock on the habitat entryway door (if it makes you nervous, try disregarding the encroaching plant entity’s vines):</p>
<div><div><img alt="Figure 9.8 – Key variants and entryway security puzzle lock" src="img/B18347_09_8.jpg" class="calibre101"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Key variants and entryway security puzzle lock</p>
<p class="callout-heading">Art assets</p>
<p class="callout">To follow along while using the same artwork that was created for this project, download the assets from this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets</a>.</p>
<p class="calibre3">Import the art assets <a id="_idIndexMarker933" class="pcalibre1 pcalibre calibre6"/>for the security puzzle lock, the puzzle placeholder image, and the individual key pieces into <code>Assets/Sprites/Puzzle</code>. For the provided key pieces artwork, I’ve set the following properties for the desired size and placement:</p>
<ul class="calibre17">
<li class="calibre15"><code>500</code></li>
<li class="calibre15"><code>X</code> and <code>Y</code> values so that the pivot is located in the center of the art:</li>
</ul>
<div><div><img alt="Figure 9.9 – Key pieces art – import settings" src="img/B18347_09_9.jpg" class="calibre102"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Key pieces art – import settings</p>
<p class="calibre3">Now, let’s write the code for the collectible key item so that we’ll be ready to assemble the Prefabs for each key piece.</p>
<p class="calibre3">Create a new script <a id="_idIndexMarker934" class="pcalibre1 pcalibre calibre6"/>named <code>KeyItem</code> in the <code>Assets/Scripts</code> folder with the following code:</p>
<pre class="source-code">
using UnityEngine;
[RequireComponent (typeof(Collider2D))]
public class KeyItem : MonoBehaviour
{
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag(Tags.Player))
        {
            EventSystem.Instance.TriggerEvent(
                EventConstants.OnKeyCollected, false);
            Destroy(gameObject);
        }
    }
}</pre> <p class="calibre3">Finally, yes – there is where we specifically trigger the <code>OnKeyCollected</code> event!</p>
<p class="calibre3">This script for collecting items may be even more straightforward than the ones that came before it. We use <code>OnTriggerEnter2D()</code> to detect when the player enters the trigger volume. Does this mean we need a collider component as a sibling on the GameObject to which we attach the <code>KeyItem</code> script? Yes, that’s right – we need a <code>Collider2D</code> object with <code>CircleCollider2D</code>, keeping it nice and efficient.</p>
<p class="calibre3">Also, note that we’re comparing the tag of the collision object – using our <code>Tags.Player</code> constant – to ensure that only the player interacts with the trigger volume.</p>
<p class="calibre3">Let’s give the event system <code>TriggerEvent()</code> call some additional attention because our event system requires a second parameter to be passed in as an event argument. We have to pass in <em class="italic">something</em>.</p>
<p class="calibre3">As explained when the handler method was introduced, a bool value is the smallest data type in C# (1 byte); we’ll pass in <code>false</code> as the type’s value – we can also take the liberty of this meaning, “<em class="italic">True or false, will I pass an argument value for this event? False.</em>” We don’t even need to specify the <code>bool</code> type – as in <code>TriggerEvent&lt;bool&gt;()</code> – because the type can be inferred from the argument’s value.</p>
<p class="calibre3">Lastly, we’ll destroy the key piece object because we collected it and no longer need it in the level. We’re just using <code>Destroy(gameObject)</code> directly here for brevity. Still, for consistency, if <a id="_idIndexMarker935" class="pcalibre1 pcalibre calibre6"/>you’d like, you should be able to hook up the reusable <code>Destroyer</code> component for yourself by now (challenge accepted?).</p>
<p class="calibre3">Now, it’s time to construct the collectible key item Prefab!</p>
<h3 class="calibre10">KeyItem Prefab and variants</h3>
<p class="calibre3">Creating Prefabs for<a id="_idIndexMarker936" class="pcalibre1 pcalibre calibre6"/> reusable items in our project is second nature by now. Let’s breeze through the steps to create a new collectible key <a id="_idIndexMarker937" class="pcalibre1 pcalibre calibre6"/>item <strong class="bold">Prefab</strong>; then, we’ll make <strong class="bold">variants</strong> that have all three <a id="_idIndexMarker938" class="pcalibre1 pcalibre calibre6"/>key pieces and their individual artwork:</p>
<ol class="calibre14">
<li class="calibre15">Drag the <code>key1</code> Sprite (which we previously imported) from the <code>Assets/Sprites/Puzzle</code> folder in the <strong class="bold">Project</strong> window into the <strong class="bold">Scene Hierarchy</strong>.</li>
<li class="calibre15">Double-click it to focus on it in the <code>(0, 0, 0)</code> if not, <strong class="bold">Reset</strong> the <strong class="bold">Transform</strong> option in the <strong class="bold">Inspector</strong> view so that it is – we don’t want any offsets being saved in the Prefab).</li>
<li class="calibre15">Rename <code>key1</code> to simply <code>key</code> (while selected at the top of the <strong class="bold">Inspector</strong> view, click it a second time, or use the <em class="italic">F2</em>/<em class="italic">Enter</em> key) – this will make sense later when we create the additional key variants.</li>
<li class="calibre15">Right-click on it and select <code>Key1</code>.</li>
<li class="calibre15">Add a <code>CircleCollider2D</code> sibling component to the <code>Key1</code> object and enable <strong class="bold">Is Trigger</strong>. Set the <strong class="bold">Radius</strong> value so that its hitbox is slightly larger than the puzzle piece Sprite (refer to <em class="italic">Figure 9</em><em class="italic">.10</em>).</li>
<li class="calibre15">Add the <code>KeyItem</code> script to the parent <code>Key1</code> object – there’s nothing to configure; all the behavior is handled in code.</li>
<li class="calibre15">Drag <code>Key1</code> from the <code>Assets/Prefabs</code> folder in the <strong class="bold">Project</strong> window to make it a Prefab.</li>
</ol>
<p class="calibre3">Now, to create the additional key piece Prefabs as Prefab variants, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Select <code>Key1</code> in the <strong class="bold">Hierarchy</strong> and press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">D</em> twice to make two duplicates of it.</li>
<li class="calibre15">Rename the duplicates <code>Key2</code> and <code>Key3</code>, respectively.</li>
<li class="calibre15">For <code>Key2</code>, on the child key object, change the <code>SpriteRenderer</code> <code>key2</code>. Then, do the same for <code>Key3</code>, and set the <code>key3</code>.</li>
<li class="calibre15">Drag <code>Key2</code> from the <code>Assets/Prefabs</code> folder. Then, in the <code>Key1</code> Prefab but override the <code>Key3</code>.</li>
</ol>
<p class="callout-heading">Tip | Prefab Edit Mode | Variants</p>
<p class="callout">Note that when opening <strong class="bold">Prefab Variant</strong> in <strong class="bold">Prefab Edit Mode</strong>, all overrides are indicated by a blue indicator along the left edge of the <strong class="bold">Inspector</strong> view.</p>
<p class="calibre3">Here are the key <a id="_idIndexMarker939" class="pcalibre1 pcalibre calibre6"/>Prefabs and variants we just created:</p>
<div><div><img alt="Figure 9.10 – KeyItem pieces Prefabs" src="img/B18347_09_10.jpg" class="calibre103"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.10 – KeyItem pieces Prefabs</p>
<p class="calibre3">The player can now collect the key pieces to complete the quest, but how should we place them in the level? First things first, delete the <code>Key1</code>, <code>Key2</code>, and <code>Key3</code> objects from the scene; we’re going to spawn them in.</p>
<p class="callout-heading">QuestSystem | Complete code</p>
<p class="callout">To view the complete code for the <strong class="source-inline1">QuestSystem</strong> class and all the quest-related code in this chapter, visit <a id="_idIndexMarker940" class="pcalibre1 pcalibre calibre6"/>this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/</a>.</p>
<h3 class="calibre10">Key instantiator – Randomness</h3>
<p class="calibre3">Let’s explore an <a id="_idIndexMarker941" class="pcalibre1 pcalibre calibre6"/>easy way to implement some basic random instantiation of objects so that the game is different every time it’s played – addressing replayability is good for player engagement!</p>
<p class="callout-heading">Randomness in game design</p>
<p class="callout">You’ll come across <a id="_idIndexMarker942" class="pcalibre1 pcalibre calibre6"/>the topic of randomness in games in your game development journey – and not just for card games! The role of randomness in game design is appropriate for this entire chapter – heck, this entire book! So, keeping that in mind, this will be one of the most basic examples of how you can add randomness to a simple mechanic with effective results. In the level design, we will instantiate the three keys at random locations identified by a larger number of spawn points.</p>
<p class="calibre3">The structure of the code will be to take an array of <code>KeyItem</code> (objects) (that is, the key pieces) and an array of <code>Transform</code> (positions) (that is, points placed throughout the level) as input and then output (that is, instantiate) the objects in order at the next randomly selected spawn point (being sure not to reuse any of the spawn points).</p>
<p class="calibre3">Did you visualize what the code could look like? Let’s see. Let’s walk through creating the code for each part.</p>
<p class="calibre3">Start by creating a new script named <code>KeyInstantiator</code> in the <code>Assets/Scripts</code> folder.</p>
<p class="calibre3">We’ll declare the arrays that hold the key objects and the spawn points first:</p>
<pre class="source-code">
using UnityEngine;
using System.Collections.Generic;
public class KeyInstantiator : MonoBehaviour
{
    [SerializeField] private KeyItem[] _keyPrefabs;
    [SerializeField] private Transform[] _spawnPoints;
    …</pre> <p class="calibre3">Here, we declared two arrays:</p>
<ul class="calibre17">
<li class="calibre15"><code>KeyItem[] _keyPrefabs</code>: This has been serialized so that it can be assigned in the <code>KeyItem</code> instead of a more generic <code>GameObject</code> because of the following reasons:<ul class="calibre22"><li class="calibre15">We only want Prefabs that include the <code>KeyItem</code> component to be assignable to the array.</li><li class="calibre15">While referencing an item in the collection, we will consume the item as the <code>KeyItem</code> type and avoid making a <code>GetComponent&lt;KeyItem&gt;()</code> call.</li></ul></li>
<li class="calibre15"><code>Transform[] _spawnPoints</code>; This has been serialized so that it can be assigned in the <strong class="bold">Inspector</strong> view; we’ll assign the GameObjects that are placed throughout the level where key pieces can potentially spawn. With game design in mind, be sure<a id="_idIndexMarker943" class="pcalibre1 pcalibre calibre6"/> to place more than three in a level so that we’re not just randomizing what key piece appears at the same three positions – your limit will be the design or your level (and I’d be sure to place one of them where you happen to have several infected robots patrolling).</li>
</ul>
<p class="callout-heading">Array (C#)</p>
<p class="callout">An array is a type that’s declared with opposing square braces (<strong class="source-inline1">[]</strong>) and represents a collection of items of that type. Items in the array are addressed by their index value, which starts at zero (for example, <strong class="source-inline1">_spawnPoints[0]</strong> is the first <strong class="source-inline1">Transform</strong> stored in the collection).</p>
<p class="callout">Here’s some additional reading: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/</a>.</p>
<p class="calibre3">Next, we’ll add a <code>List</code> type to work with the currently available spawn points from the <code>_spawnPoints</code> array. Why are we doing this? We already have an <code>array</code> type, and now a <code>List</code> type? Yes. Arrays in C# are not easy to work with if we want to resize them (that is, remove an item), but a <code>List</code> type is.</p>
<p class="calibre3">Declare the following <code>List</code> type and add the <code>Start()</code> method with the spawn points assignment:</p>
<pre class="source-code">
    private List&lt;Transform&gt; _availablePoints;
    private void Start()
    {
        _availablePoints = new List&lt;Transform&gt;(_spawnPoints);
        …</pre> <p class="calibre3">We declared a <code>List</code> type<a id="_idIndexMarker944" class="pcalibre1 pcalibre calibre6"/> and initialized it in <code>Start()</code> with the <code>_spawnPoints</code> value:</p>
<ul class="calibre17">
<li class="calibre15"><code>List&lt;Transform&gt; _availablePoints</code>: This is the <code>private</code> member variable because we’ll just work with the points inside the class. We’ll use this to determine the points available to instantiate a key.</li>
<li class="calibre15"><code>Start()</code>: We’ll scatter the key pieces throughout the level when the game starts… so we’ll use the <code>MonoBehaviour</code>-provided Unity message event <code>Start()</code> for that, yeah.</li>
</ul>
<p class="calibre3">Now comes the fun part – random position instantiation! Add the following <code>foreach</code> loop to the <code>Start()</code> method’s implementation:</p>
<pre class="source-code">
        foreach (var item in _keyPrefabs)
        {
            var randomIndex = Random.Range(
                0, _availablePoints.Count);
            Instantiate(item,
                _availablePoints[randomIndex].position,
                Quaternion.identity);
            _availablePoints.RemoveAt(randomIndex);
        }
    }
}</pre> <p class="calibre3">Okay, let’s do a breakdown of this final section:</p>
<ul class="calibre17">
<li class="calibre15"><code>foreach (var item in _keyPrefabs)</code>: We’re using <code>foreach</code> to iterate the available <code>KeyItem</code> Prefabs assigned in the <strong class="bold">Inspector</strong> view (all three of our key Prefab/variant pieces).</li>
<li class="calibre15"><code>Random.Range(0, _availablePoints.Count)</code>: A bit of magic? No, this is <a id="_idIndexMarker945" class="pcalibre1 pcalibre calibre6"/>Unity’s <code>int</code> values, however, like in our use case; otherwise, it’s inclusive of the second number when using <code>float</code> values). We don’t want to use the <code>Count</code> value because array indexes are zero-based (so we’d have to specify <code>Count - </code><code>1</code> otherwise):<p class="calibre3">Note that we obtain <code>_availablePoints.Count</code> every iteration. That’s because, only two lines below, we’re removing the randomly selected point from <code>List</code> by the <code>randomIndex</code> value that’s returned, so it’s not used again.</p></li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">Random.Range()</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml</a>.</p>
<ul class="calibre17">
<li class="calibre15"><code>Instantiate()</code>: We spawn the current <code>item</code> in the array into the scene at the randomly selected spawn point position, <code>randomIndex</code>, with zero rotation (that is, <code>Quaternion.Identity</code>).</li>
<li class="calibre15"><code>RemoveAt(ramdomIndex)</code>: A C# <code>List</code> type provides a remove method that not only deletes an item from the collection but also resizes it. Hence, the <code>Count</code> property reflects the number of items that remain.</li>
</ul>
<p class="calibre3">It sounds like a lot when breaking it down like this, but it’s a short and sweet random placement script.</p>
<p class="calibre3">The last step is, of <a id="_idIndexMarker947" class="pcalibre1 pcalibre calibre6"/>course, setting the instantiator up in our scene so that the key pieces can be placed in the game level.</p>
<h4 class="calibre29">Instantiator scene object setup</h4>
<p class="calibre3">Here’s what we’ll do to<a id="_idIndexMarker948" class="pcalibre1 pcalibre calibre6"/> set up the new <code>KeyInstantiator</code> script on an object in our scene so that our keys are randomly spawned for the player to find:</p>
<ol class="calibre14">
<li class="calibre15">Create a <code>KeyInstantiator</code> component.</li>
<li class="calibre15">In the <code>Assets/Prefabs</code> folder in the <strong class="bold">Project</strong> window to the <strong class="bold">KeyPrefabs</strong> field.</li>
<li class="calibre15">Then, after placing – more than three! – GameObjects in the level that represent the possible spawn position of a key piece, select them in the <strong class="bold">Hierarchy</strong> and drag them to the <strong class="bold">SpawnPoints</strong> field in the <strong class="bold">Inspector</strong> view (don’t forget that you can lock the <strong class="bold">Inspector</strong> window so that it doesn’t change when you’re selecting the objects you want to assign).</li>
</ol>
<p class="calibre3"><em class="italic">Figure 9</em><em class="italic">.11</em> shows the result of the preceding steps:</p>
<div><div><img alt="Figure 9.11 – Key instantiator object setup" src="img/B18347_09_11.jpg" class="calibre104"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Key instantiator object setup</p>
<p class="calibre3">You may have noticed the pink diamonds in the preceding figure. I’ve assigned a pink diamond icon (assignable at the top of the <strong class="bold">Inspector</strong> view) to the key spawn point objects so that they are easy to find in the <strong class="bold">Scene</strong> view while I’m working on the level design. I’ve also <a id="_idIndexMarker949" class="pcalibre1 pcalibre calibre6"/>grouped the key spawn points under a <a id="_idIndexMarker950" class="pcalibre1 pcalibre calibre6"/>parent <strong class="bold">Key Spawn Points</strong> object in the <strong class="bold">Hierarchy</strong>.</p>
<p class="calibre3">With that, we now have key pieces randomly placed in our level when the game starts. Next, we’ll sort out a drawing issue before moving on to solving the key puzzle!</p>
<h4 class="calibre29">Instantiated Sprite drawing order</h4>
<p class="calibre3">The key pieces will be instantiated on the <code>Default</code> <code>0</code> for the default values. Because we’ve set up our environment with <em class="italic">default objects</em> originating “in the center of the depth layers,” we can be confident that the instantiated pieces will not be obstructed. This can be compensated for when instantiated if needed, but this can simply be avoided if we take some care in the environment layout.</p>
<p class="calibre3">In this section, we learned how to create a quest system, make new quests with unique properties and requirements for completion, assign a quest to the player, and query a quest’s status to advance the gameplay. We also saw how to utilize the event system to build other systems on top of its foundation.</p>
<p class="calibre3">In the next section, we’ll<a id="_idIndexMarker951" class="pcalibre1 pcalibre calibre6"/> integrate a sliding puzzle as the habitat entryway’s security lock system, where solving it wins the game.</p>
<h1 id="_idParaDest-172" class="calibre5"><a id="_idTextAnchor181" class="pcalibre1 pcalibre calibre6"/>Solving the key puzzle and winning the game</h1>
<p class="calibre3">We could spend a whole lot of time here designing a novel puzzle for the security lock system. Still, that falls outside the scope of this book and would not provide the learning opportunity I want to cover – that is, using third-party assets in your game. This isn’t to say that you shouldn’t strive to introduce a new and original idea in your game – any way you can differentiate your game and offer players a remarkable and unique experience is time well spent!</p>
<p class="calibre3">We will use the well-known sliding tile puzzle for the habitat entryway’s security puzzle lock.</p>
<h2 id="_idParaDest-173" class="calibre8"><a id="_idTextAnchor182" class="pcalibre1 pcalibre calibre6"/>Sliding tile puzzle</h2>
<p class="calibre3">I’ve only briefly <a id="_idIndexMarker952" class="pcalibre1 pcalibre calibre6"/>mentioned <a id="_idIndexMarker953" class="pcalibre1 pcalibre calibre6"/>the <strong class="bold">Unity Asset Store</strong>, but I want to bring some well-deserved attention to it now. The Unity Asset Store contains a wealth of assets that both Unity and third parties provide. You can find just about anything you would need for your games, including pre-made systems, frameworks, characters, animations, 2D and 3D art assets, music and sound effects, VFX, and more, in almost every genre and style you can imagine.</p>
<p class="calibre3">However, integrating solutions and assets from varying vendors isn’t always trivial. This section will be dedicated to both the value of leveraging existing pre-made assets and identifying some issues you may need to work through to have them functioning in your project. You may be thinking that I’ve alluded to a level of quality for third-party assets that indicates they are not good – while that may be true in some rare cases (buyer beware, as usual), issues can arise that have nothing to do with the asset and all to do with the changes and advances in technologies that comes with newer Unity version releases. Rather than continuing in abstract terms, let’s move forward with the specific example I’ll provide.</p>
<p class="calibre3">For reference, here is the sliding tile puzzle we’ll create with the tiles already scrambled (refer to <em class="italic">Figure 9</em><em class="italic">.3</em> for the unscrambled version):</p>
<div><div><img alt="Figure 9.12 – Sliding puzzle scrambled tiles" src="img/B18347_09_12.jpg" class="calibre105"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Sliding puzzle scrambled tiles</p>
<p class="calibre3">As mentioned previously, we’re going to leverage an existing asset from the Unity Asset Store to rapidly incorporate a sliding puzzle feature that will include everything necessary to slice an image into tiles, scramble the tiles, respond to user input for sliding the tiles, and calculate when the puzzle has been solved. If we had to develop on our own, all of these <a id="_idIndexMarker954" class="pcalibre1 pcalibre calibre6"/>requirements would take significantly more time to create, code, debug, and test. Unity Asset Store assets generally come with the benefit of dozens of developers (or hundreds in some cases) using the assets in their projects and reporting back bugs and discrepancies to the asset developer for further improvement – and you directly benefit from others’ efforts.</p>
<p class="calibre3">Without further ado, we’ll be using a free asset <a id="_idIndexMarker955" class="pcalibre1 pcalibre calibre6"/>called <strong class="bold">Sliding Tile Puzzle Game</strong> by Hyper Luminal Games (<a href="https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798</a>):</p>
<div><div><img alt="Figure 9.13 – Sliding Tile Puzzle Game" src="img/B18347_09_13.jpg" class="calibre106"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Sliding Tile Puzzle Game</p>
<p class="calibre3">Several steps will be required to use the asset in our Unity 2022 project due to changes in the <strong class="bold">Unity Scripting API</strong>, in <a id="_idIndexMarker956" class="pcalibre1 pcalibre calibre6"/>addition to changes required to support <strong class="bold">Universal RP</strong> (<strong class="bold">URP</strong>), the <em class="italic">render pipeline</em> we’ve based the<a id="_idIndexMarker957" class="pcalibre1 pcalibre calibre6"/> project on, since the time the asset was released (way <a id="_idIndexMarker958" class="pcalibre1 pcalibre calibre6"/>back in 2016, for Unity 5).</p>
<p class="calibre3">Let’s get started by obtaining the asset and importing it into the project.</p>
<h3 class="calibre10">Importing the sliding tile puzzle asset</h3>
<p class="calibre3">After going through<a id="_idIndexMarker959" class="pcalibre1 pcalibre calibre6"/> the process of purchasing an asset or clicking <strong class="bold">Add to My Assets</strong>, you have the option of using the <strong class="bold">Open in Unity</strong> button from within the Unity Asset Store. Alternatively, you may open the <strong class="bold">Package Manager</strong> window in the Unity Editor, select <strong class="bold">My Assets</strong> from the <strong class="bold">Packages</strong> dropdown, find the asset in the list, click <strong class="bold">Download</strong>, and then click <strong class="bold">Import</strong>.</p>
<p class="calibre3">In my experience, most assets are designed to be imported into your existing project. Still, some assets are provided as <em class="italic">complete projects</em> and, therefore, cannot be imported directly into your project. The sliding tile puzzle asset requires an additional step to import into your project because it is provided as a complete project, and it’s best not to overwrite any of your current project settings!</p>
<p class="calibre3">Let’s walk through the steps; this won’t take long:</p>
<ol class="calibre14">
<li class="calibre15">Importing the sliding tile puzzle asset from the <strong class="bold">Asset Store</strong> page or <strong class="bold">Package Manager</strong> will produce the following <strong class="bold">Importing a complete project</strong> warning dialog:</li>
</ol>
<div><div><img alt="Figure 9.14 – The Importing complete project dialog" src="img/B18347_09_14.jpg" class="calibre107"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.14 – The Importing complete project dialog</p>
<ol class="calibre14">
<li value="2" class="calibre15">Click the <strong class="bold">Switch Project</strong> button to create a temporary project the asset will be imported into. Unity <a id="_idIndexMarker960" class="pcalibre1 pcalibre calibre6"/>will automatically generate a temporary project name. We’ll delete this project when we’re finished extracting the asset from it, so don’t worry.</li>
<li class="calibre15">When Unity has opened and everything has finished importing, the <code>Assets/HyperLuminal</code> folder (found in the <strong class="bold">Project</strong> window).</li>
<li class="calibre15">Right-click on the <code>SlidingTilePuzzle</code> folder and select <strong class="bold">Export Package…</strong>. This will open an <strong class="bold">Exporting package</strong> dialog, where you can change what’s included in the export. We want everything, so click the <strong class="bold">Export…</strong> button in the bottom-right corner.</li>
<li class="calibre15">When the file save window opens, enter <code>SlidingTilePuzzle</code> for the <code>.unitypackage</code> filename and pick an easily accessible folder; we will be importing from that same folder shortly.</li>
<li class="calibre15">Close Unity. You will be prompted with a <strong class="bold">Keep Project?</strong> dialog. You can safely click the <strong class="bold">Forget</strong> button since we no longer need it:<p class="calibre3">Note that even though you confirmed forgetting it, you may still see an erroneous project show up in Unity Hub that represents this temporary project. If so, remove it and delete the project folder.</p></li>
<li class="calibre15">Now, back in our game’s project, let’s import the saved <code>.unitypackage</code> file by going to <code>SlidingTilePuzzle.unitypackage</code> from the location we saved it in earlier:</li>
</ol>
<div><div><img alt="Figure 9.15 – The Import Unity Package dialog" src="img/B18347_09_15.jpg" class="calibre108"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.15 – The Import Unity Package dialog</p>
<ol class="calibre14">
<li value="8" class="calibre15">All the items should <a id="_idIndexMarker961" class="pcalibre1 pcalibre calibre6"/>be marked as <strong class="bold">New</strong> unless we’ve previously imported the package. Go ahead and click <strong class="bold">Import</strong> so that we can continue integrating the sliding puzzle.</li>
</ol>
<p class="callout-heading">Tip | Project organization</p>
<p class="callout">Asset vendors make their own choices on the location of their assets in the project folder structure, so importing many third-party assets can get a bit messy and unorganized. To maintain some level of sanity in your project files, I suggest placing all third-party assets under this <strong class="source-inline1">Assets/Third </strong><strong class="source-inline1">Party</strong> folder.</p>
<p class="callout">For example, in <em class="italic">Figure 9</em><em class="italic">.15</em>, you can see <em class="italic">SlidingTilePuzzle</em>, which we will import to the <strong class="source-inline1">Assets/HyperLuminal</strong> folder. Please create a new <strong class="source-inline1">Assets/Third Party</strong> folder and move the <strong class="source-inline1">HyperLuminal</strong> folder as a child of it. Mischief managed.</p>
<p class="calibre3">Now, let’s update the <a id="_idIndexMarker962" class="pcalibre1 pcalibre calibre6"/>asset so that it works with our Unity 2022 project requirements.</p>
<h3 class="calibre10">Updating the puzzle tile shader</h3>
<p class="calibre3">Our first order of business <a id="_idIndexMarker963" class="pcalibre1 pcalibre calibre6"/>is to update from the built-in legacy renderer to the URP renderer. In Unity 5, we only had the built-in renderer, so it makes sense that we’d need to convert items related to the render for this asset.</p>
<p class="calibre3">If you were to open the <code>SlidingTilePuzzle</code> example scene in the <code>Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scenes</code> folder and enter <strong class="bold">Play Mode</strong> now, you’d get a giant pink square. Pink (or magenta) is the color Unity uses to represent a material or shader error – unless you’ve specifically made an object this color, seeing it in your <strong class="bold">Scene</strong> or <strong class="bold">Game</strong> view is generally not good.</p>
<p class="calibre3">The asset takes a Prefab approach for the type of sliding puzzle you want to make and provides Prefabs for <code>3x3</code>, <code>4x4</code>, and <code>5x5 </code>sliding puzzles – we will make a 3x3 sliding puzzle and work with that specific <code>3x3</code> Prefab. Follow these steps to update the renderer-specific issues:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs</code> folder, duplicate the <code>SlidingTile_3by3</code> Prefab and rename it <code>SlidingTile_3by3_URP</code>.</li>
<li class="calibre15">Double-click on <code>SlidingTile_3by3_URP</code> to enter <strong class="bold">Prefab </strong><strong class="bold">Edit Mode</strong>.</li>
<li class="calibre15">Find the <code>ST_Puzzle Display</code> component and change the <em class="italic">Puzzle Shader</em> from <code>Mobile/Unlit</code> to <code>Packages/Universal RP/Shaders/2D/Sprite-Unlit-Default</code> – you must drag this shader in from the <code>Packages</code>.</li>
<li class="calibre15">Save the Prefab.</li>
</ol>
<p class="calibre3">We have one more update to make for the renderer issues, and that’s on the puzzle tile itself, but first, we need <a id="_idIndexMarker964" class="pcalibre1 pcalibre calibre6"/>a new <strong class="bold">Universal RP Sprite</strong> material. Follow these steps to update the asset:</p>
<ol class="calibre14">
<li class="calibre15">Create a new <em class="italic">material</em> named <code>PuzzleTile 1</code> in the <code>Assets/Materials</code> folder and select it.</li>
<li class="calibre15">In the <strong class="bold">Shader</strong> drop-down menu at the top of the <strong class="bold">Inspector</strong> view, select the <strong class="bold">Universal Render </strong><strong class="bold">Pipeline/2D/Sprite-Unlit-Default</strong> shader.</li>
<li class="calibre15">In the <code>Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs</code> folder, we also have the <code>SlideTile</code> Prefab. Duplicate it and rename it <code>SlideTile_URP</code>.</li>
<li class="calibre15">Double-click<a id="_idIndexMarker965" class="pcalibre1 pcalibre calibre6"/> on <code>SlideTile_URP</code> to enter <strong class="bold">Prefab </strong><strong class="bold">Edit Mode</strong>.</li>
<li class="calibre15">Find the <code>MeshRenderer</code> component and change <code>Element 0</code> to <code>PuzzleTile 1</code>.</li>
<li class="calibre15">Save the Prefab.</li>
</ol>
<p class="calibre3">Now that the rendering issues of the <code>Sliding Tile Puzzle</code> asset have been updated, we are ready to work within our <strong class="bold">Lit 2D (</strong><strong class="bold">URP)</strong> scenes!</p>
<p class="calibre3">We only have one more issue with updating, and that’s for the interactivity – that is, being able to slide the tiles from player input.</p>
<h3 class="calibre10">Updating the input system</h3>
<p class="calibre3">The new input system<a id="_idIndexMarker966" class="pcalibre1 pcalibre calibre6"/> is called new because… well, it’s new. Unity 5 only had the legacy <code>InputManager</code> system; of course, since we’re using the new input system in our project, we need to make some changes to support it. All the updates for the renderer were done in the editor, but now, we’ll have to change some code.</p>
<p class="calibre3">Make the following code changes:</p>
<ol class="calibre14">
<li class="calibre15">Find the <code>ST_PuzzleTile</code> script in the <code>Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts</code> folder and open it in your IDE.</li>
<li class="calibre15">Add a new <code>using</code> statement at the top of the script. We’ll need this <code>UnityEngine</code> namespace to support the code changes:<pre class="source-code">
using UnityEngine.EventSystems;</pre></li> <li class="calibre15">Add the <code>IPointerClickHandler</code> interface to the class definition to support the new input system’s <code>pointer </code><code>click</code> method:<pre class="source-code">
public class ST_PuzzleTile : MonoBehaviour, IPointerClickHandler</pre></li> <li class="calibre15">At the bottom of the script, replace <code>void OnMouseDown()</code> with the following:<pre class="source-code">
public void OnPointerClick(PointerEventData eventData)</pre></li> <li class="calibre15">Save the script and return to the Unity Editor; you’re done.</li>
</ol>
<p class="calibre3">Unfortunately, you can<a id="_idIndexMarker967" class="pcalibre1 pcalibre calibre6"/> no longer test the sliding puzzle using the vendor’s <code>SlidingTilePuzzle</code> example scene as-is.</p>
<p class="calibre3">To test the updates and the final update requirements for every scene you want to use the sliding puzzle in, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Create a new scene (<strong class="bold">File</strong> | <strong class="bold">New Scene</strong> or <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">N</em>) and select the <strong class="bold">Lit 2D (URP)</strong> new scene template.</li>
<li class="calibre15">Add a <code>PhysicsRaycaster</code> component to <strong class="bold">Main Camera</strong>.</li>
<li class="calibre15">Add <code>UI Event System</code> to the scene. Ensure you update the <code>StandaloneInputModule</code> component for the new input system.</li>
<li class="calibre15">Add the <code>SlidingTile_3by3_URP</code> Prefab to the scene.</li>
<li class="calibre15">Enter <strong class="bold">Play Mode</strong>. Test. Enjoy.</li>
</ol>
<p class="calibre3">And that completes all the updates required to modernize <em class="italic">Sliding Tile Puzzle</em> for the URP render and the new input system. Not too bad.</p>
<p class="calibre3">As you will see, the Unity Asset Store is a great resource with many talented asset publishers. It can help to save you (a lot of) time building game prototypes quickly, polishing your games, and creating vertical slices early (for seeking a publisher or investors in your project).</p>
<p class="calibre3">We will, however, need one additional change to integrate the sliding puzzle into our gameplay. And that is adding an event for when the security puzzle lock has been solved so that we can trigger <a id="_idIndexMarker968" class="pcalibre1 pcalibre calibre6"/>an appropriate action – a logical one at this point would be granting the player access to the habitat station. Open sesame!</p>
<h3 class="calibre10">Adding an event for completion</h3>
<p class="calibre3">We won’t be<a id="_idIndexMarker969" class="pcalibre1 pcalibre calibre6"/> covering any new ground with this task. We’ve added events in several different ways already. Our choice this time will be a <code>UnityEvent</code> event so that we can set the triggered handlers in the <strong class="bold">Inspector</strong> view.</p>
<p class="calibre3">Find the <code>ST_PuzzleDisplay</code> script in the <code>Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts</code> folder and open it in your IDE. Then, modify the script with the following additions:</p>
<ol class="calibre14">
<li class="calibre15">Add a new <code>using</code> statement at the top of the script as required for declaring our event:<pre class="source-code">
using UnityEngine.Events;</pre></li> <li class="calibre15">Add a <code>public</code> <code>UnityEvent</code> event to be triggered when the puzzle is completed:<pre class="source-code">
public class ST_PuzzleDisplay : MonoBehaviour
{
    …
    public UnityEvent OnPuzzleComplete;</pre></li> <li class="calibre15">Modify the <code>CheckForComplete()</code> method by adding the <code>OnPuzzleComplete</code> invocation line within the <code>if(Complete)</code> block:<pre class="source-code">
public IEnumerator CheckForComplete()
{
    …
    // if we are still complete then all the tiles are correct.
    if(Complete)
    {
        Debug.Log("Puzzle Complete!");
        OnPuzzleComplete?.Invoke();
    }
    …</pre></li> </ol>
<p class="calibre3">We now have a convenient way to respond to the entryway security puzzle lock being solved/completed.</p>
<p class="calibre3">When we set up the <code>QuestHasCompleted</code> component on the habitat entryway, we left unfinished<a id="_idIndexMarker970" class="pcalibre1 pcalibre calibre6"/> business for our future selves. We are now our future selves, so we can complete the <code>OnQuestComplete</code> event assignment and show our security puzzle lock to the player.</p>
<h3 class="calibre10">Setting up a new puzzle prefab</h3>
<p class="calibre3">Yup, that’s right – we’ll need <a id="_idIndexMarker971" class="pcalibre1 pcalibre calibre6"/>another Prefab for the sliding puzzle lock. We’ll set that up now so that it’s shown to the player – with our image – when all three keys have been collected and they reach the habitat entryway.</p>
<p class="calibre3">Follow these steps to create the new Prefab:</p>
<ol class="calibre14">
<li class="calibre15">Drag the <code>SlidingTile_3by3_URP</code> Prefab into the <code>0, </code><code>0, 0</code>)).</li>
<li class="calibre15">Right-click on it and select <code>Key Puzzle Lock</code> – you’ll end up with the actual puzzle as the child (yes, this is our standard approach to Prefab structure, if you still weren’t sure).</li>
<li class="calibre15">Find the <code>key_puzzle1-complete_512</code> image in the <code>Assets/Sprites/Puzzle</code> folder (this is one of the images we imported in the previous <em class="italic">KeyItem component</em> section) and change its import settings in the <code>512</code></li></ol></li>
<li class="calibre15">Find the <code>ST_PuzzleDisplay</code> component <a id="_idIndexMarker972" class="pcalibre1 pcalibre calibre6"/>and assign the following:<ol class="calibre42"><li class="upper-roman"><em class="italic">Puzzle </em><em class="italic">Image</em>: <code>key_puzzle1-complete_512</code></li><li class="upper-roman"><em class="italic">Puzzle Scale</em>: <code>0.7</code>, <code>0.7</code>, <code>0.7</code>:</li></ol></li>
</ol>
<div><div><img alt="Figure 9.16 – Sliding puzzle configuration" src="img/B18347_09_16.jpg" class="calibre109"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Sliding puzzle configuration</p>
<ol class="calibre14">
<li value="5" class="calibre15">Now, disable the <code>SlidingTile_3by3_URP</code> object. Yes, you heard that right; we’re going to disable the object with the <code>ST_PuzzleDisplay</code> component on it because we only want the puzzle to show and do its trick when it’s triggered by the player reaching the habitat entryway with all three keys collected.</li>
<li class="calibre15">Drag the <code>Assets/Prefabs</code> folder to create the puzzle lock Prefab.</li>
</ol>
<p class="calibre3">We now have our <a id="_idIndexMarker973" class="pcalibre1 pcalibre calibre6"/>customized security puzzle lock ready to go! The final setup ensures it shows in place when required at the habitat entryway location.</p>
<h3 class="calibre10">Adding the puzzle lock to the entryway</h3>
<p class="calibre3">We already set<a id="_idIndexMarker974" class="pcalibre1 pcalibre calibre6"/> up our <strong class="bold">Puzzle Trigger</strong> at the location of the habitat entryway. Now, let’s add the security puzzle lock to its location so that it shows and is interactable in place at the entryway door. With everything already set up and ready to go, it’s a simple two-step process:</p>
<ol class="calibre14">
<li class="calibre15">Position the <strong class="bold">Key Puzzle Lock</strong> Prefab in the level nearby, slightly above, or right at the habitat entryway door. You can reference <em class="italic">Figure 9</em><em class="italic">.12</em> for where I placed it: at the door and just above the player character’s head.</li>
<li class="calibre15">Show the sliding puzzle from the <code>QuestHasCompleted</code> component’s <code>OnQuestComplete()</code> event by doing the following:<ol class="calibre42"><li class="upper-roman">Add a new entry for <code>OnQuestComplete()</code> as an additional action to <code>PlayerInput.enabled</code> by clicking the little plus (<code>SlidingTile_3by3_URP</code> child object of <code>GameObject</code> | <code>SetActive(bool)</code> from the function dropdown, and tick the checkbox to pass <code>true</code>.</li></ol></li>
</ol>
<p class="calibre3">That’s it! You can now fully test the quest life cycle, collect three keys scattered throughout the level to complete the quest, trigger an event for a completed quest, and solve an in-game<a id="_idIndexMarker975" class="pcalibre1 pcalibre calibre6"/> sliding puzzle. Yay!</p>
<p class="calibre3">All that remains is what we need to do when beating the entryway puzzle lock – that is, winning.</p>
<h2 id="_idParaDest-174" class="calibre8"><a id="_idTextAnchor183" class="pcalibre1 pcalibre calibre6"/>Winning</h2>
<p class="calibre3">When the security puzzle lock <a id="_idIndexMarker976" class="pcalibre1 pcalibre calibre6"/>is solved, we gain entry to the habitat station. The <code>OnPuzzleComplete()</code> <code>UnityEvent</code> event we just added to the <code>Sliding Tile Puzzle Game</code> code gets triggered, so this is our opportunity to do something for a win state.</p>
<p class="calibre3">My game design plan, and plan for this book’s projects, is to continue gameplay within the habitat station interior in <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, where things will start having more depth. I don’t mean that figuratively; the project the next chapter introduces will be a 3D <strong class="bold">first-person shooter</strong> (<strong class="bold">FPS</strong>) game. For <a id="_idIndexMarker977" class="pcalibre1 pcalibre calibre6"/>now, we’ll implement a nice cinematic fade to black and <em class="italic">To be continued…</em>. But how do we solve the problem of implementing a fade-out and on-screen text sequence without figuring out a bunch of synchronized linear timing code? Let’s see.</p>
<h2 id="_idParaDest-175" class="calibre8"><a id="_idTextAnchor184" class="pcalibre1 pcalibre calibre6"/>Timeline</h2>
<p class="calibre3"><strong class="bold">Timeline</strong> is not <a id="_idIndexMarker978" class="pcalibre1 pcalibre calibre6"/>a new <a id="_idIndexMarker979" class="pcalibre1 pcalibre calibre6"/>feature in Unity 2022. It’s been around since Unity 2017, but I feel it’s an underrated core feature that doesn’t get nearly the attention it deserves for game developers. For cinematic content creators, however, it was a game changer since Timeline allows the easy creation of linear sequences affecting almost any object in the scene.</p>
<p class="calibre3">Timeline is based on two elements that<a id="_idIndexMarker980" class="pcalibre1 pcalibre calibre6"/> work in tandem: a <strong class="bold">Timeline</strong> file-based asset and a <strong class="bold">Playable Director</strong> component. An important thing to note is that a Timeline instance is scene-based.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Timeline: <a href="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml</a>.</p>
<p class="calibre3">We will leverage the pure power of Timeline’s simplicity to affect a set of objects linearly to knock out this ending fade-out. Let’s start by creating our Timeline instance:</p>
<ol class="calibre14">
<li class="calibre15">First, create a location in our project to store Timeline assets. Create a new folder called <code>Assets/Timelines</code>.</li>
<li class="calibre15">Staying within the <code>Ending Timeline</code> by right-clicking and choosing <strong class="bold">Create</strong> | <strong class="bold">Timeline</strong>.</li>
<li class="calibre15">We can now open the <strong class="bold">Timeline</strong> window by double-clicking the <strong class="bold">Ending Timeline</strong> asset in the <strong class="bold">Project</strong> window.</li>
<li class="calibre15">If you’re not used to working in a timescale of <strong class="bold">Frames</strong>, use the gear icon in the top-right corner of the <strong class="bold">Timeline</strong> window to select <strong class="bold">Seconds</strong> (as seen in <em class="italic">Figure 9</em><em class="italic">.17</em>).</li>
<li class="calibre15">Finish the Timeline creation by dragging the <strong class="bold">Ending Timeline</strong> asset into the <strong class="bold">Scene Hierarchy</strong> to make the scene-based instance.</li>
</ol>
<p class="calibre3">We’ll use just two UI widgets to achieve the fade-out effect and title while following these steps:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Canvas</code> component to the root of the <code>Image</code> component to fill the screen. We don’t need an image per se; just the default <strong class="bold">Background</strong> sprite will do nicely.</p></li>
<li class="calibre15">Right-click <code>RectTransform</code>: <code>400</code></li><li class="calibre15"><code>TextMeshPro – Text (UI)</code>: <code>To </code><code>be continued…</code></li></ul></li>
</ol>
<p class="calibre3">Lastly, we’ll bring these UI widgets into Timeline to set up the sequence. Follow these steps to add the<a id="_idIndexMarker981" class="pcalibre1 pcalibre calibre6"/> widgets and define their respective sequence:</p>
<ol class="calibre14">
<li class="calibre15">Ensure that <strong class="bold">Ending Timeline</strong> is viewable in the <strong class="bold">Timeline</strong> window. If the <strong class="bold">Timeline</strong> window is not open, you can open it from <strong class="bold">Window</strong> | <strong class="bold">Sequencing</strong> | <strong class="bold">Timeline</strong>, then click on the <strong class="bold">Endling Timeline</strong> instance in the hierarchy.</li>
<li class="calibre15">Drag <code>Image</code> <code>0</code> (transparent) to <code>255</code> (opaque) over 1.5 seconds:</p><ol class="calibre42"><li class="upper-roman">Click the red <em class="italic">Start recording</em> circle button on the <code>000000</code>) with <code>0</code> to set the first keyframe.</li><li class="upper-roman">Scrub <code>255</code> to set the second keyframe.</li><li class="upper-roman">Stop recording.</li></ol></li>
<li class="calibre15">Drag <strong class="bold">Text (TMP)</strong> into the <strong class="bold">Track List</strong> section of the <strong class="bold">Timeline</strong> window and select <strong class="bold">Add Activation Track</strong> when prompted.<p class="calibre3">We want the text to show a heartbeat after the fade has completed, so drag the <strong class="bold">Active</strong> clip to the right in the timeline to 1.8 seconds. The GameObject for the <strong class="bold">Text (TMP)</strong> binding will only be active within the range of the clip in the timeline and deactivated outside of it. We’re done with the text. Easy-peasy.</p></li>
</ol>
<p class="calibre3">To preview the results <a id="_idIndexMarker982" class="pcalibre1 pcalibre calibre6"/>of the timeline sequence in the <strong class="bold">Game</strong> view, click the <strong class="bold">Play</strong> button or press the spacebar:</p>
<div><div><img alt="Figure 9.17 – Timeline ending fade out title" src="img/B18347_09_17.jpg" class="calibre110"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Timeline ending fade out title</p>
<p class="calibre3">If you enter <code>PlayableDirector</code> component was added to the Timeline instance when we dragged it into the scene.</p>
<p class="calibre3">Select the <code>PlayableDirector</code> component values in the <strong class="bold">Inspector</strong> view:</p>
<ul class="calibre17">
<li class="calibre15"><code>PlayOnAwake</code> = <code>false</code></li>
<li class="calibre15"><code>WrapMode</code> = <code>Hold</code></li>
</ul>
<p class="calibre3">We also want to ensure the UI widgets don’t have a visible state at design time in the editor. That way, they are not shown until we trigger the Timeline to play. Make the following changes to the UI widget values in the scene:</p>
<ol class="calibre14">
<li class="calibre15">For the UI <code>Image</code> <code>0</code>.</li>
<li class="calibre15">For the UI <strong class="bold">Text (TMP)</strong> object, deactivate the object (untick the checkbox at the top of the <strong class="bold">Inspector</strong> view).</li>
</ol>
<p class="calibre3">Since we already recorded the color values and active state in the Timeline, we can safely set these values in the scene without affecting their sequenced behavior.</p>
<p class="calibre3">The only thing left to do now is to activate our ending sequence when the sliding puzzle is complete. Find the <code>SlidingTile_3by3_URP</code> object in the hierarchy and, on the <code>ST_PuzzleDisplay</code> component, add an action to <code>OnPuzzleComplete: Runtime Only</code>, <code>PlayableDirector.Play()</code>.</p>
<p class="calibre3">To be continued – or end of Act I, whichever you decide. Either way, this was just the equivalent of a tip-of-the-iceberg introduction to Timeline – it is an extremely powerful cutscenes, cinematics, and gameplay or audio sequences tool!</p>
<p class="calibre3">In this section, you learned how to bring a third-party asset in from the Unity Asset Store, resolved to update the asset for use in Unity 2022, and extended the vendor-provided code with<a id="_idIndexMarker983" class="pcalibre1 pcalibre calibre6"/> our own to trigger an event. You also received an introduction to Unity’s Timeline feature and created a simple but effective cinematic fade to black.</p>
<h1 id="_idParaDest-176" class="calibre5"><a id="_idTextAnchor185" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, you learned how to create an efficient and convenient global event system to build out a quest system with components made in a flexible, scalable, and more maintainable way than with directly coupled classes. You also learned how to create a specific quest with unique requirements needing to be met before setting the quest state as completed while also learning how to introduce randomness for collecting required items.</p>
<p class="calibre3">We continued by learning how to import a third-party sliding puzzle asset from the Unity Asset Store and upgrade it for compatibility with Unity 2022 and the URP renderer while also extending upon the code to integrate it into our game code. We finished solving the security puzzle lock and winning the game with a cinematic Timeline sequence for fading to black.</p>
<p class="calibre3">In the next chapter, we’ll create a 3D FPS to continue the 2D adventure game directly. We will pick up right where we left off and enter the interior habitat environment, where we will learn about gray boxing to flesh out a playable 3D-level design with <strong class="bold">ProBuilder</strong> rapidly. We’ll also leverage another asset from the Unity Asset Store – but this time one provided directly by Unity – for our FPS character controller. We’ll also look at code reuse by converting some of our existing 2D components for use in 3D.</p>
</div>
</div></body></html>