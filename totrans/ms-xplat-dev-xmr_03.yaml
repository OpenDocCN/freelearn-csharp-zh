- en: Chapter 3. Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 异步编程
- en: 'This chapter deep-dives into the asynchronous and multithreaded programming
    concepts. We will discuss platform-specific problems and give an in-depth description
    of how threading scenarios are executed on different platforms. The chapter is
    divided into following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了异步和多线程编程概念。我们将讨论平台特定的问题，并深入描述在不同平台上如何执行线程场景。本章分为以下部分：
- en: Multithreading on Xamarin
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin上的多线程
- en: Asynchronous methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法
- en: Parallel execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行执行
- en: Patterns and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: Background tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台任务
- en: Multithreading on Xamarin
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin上的多线程
- en: Xamarin platforms together with Windows Runtime follow the basic principles
    of a single-threaded apartment model. In this model, in simple terms, a process
    is assigned a single thread which acts as the main trunk for all the other possible
    branches to be created from and yield back to.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin平台与Windows Runtime遵循单线程公寓模型的基本原则。在这个模型中，简单来说，一个进程被分配一个线程，这个线程作为所有其他可能创建并返回的分支的主干。
- en: While developers still have the ability to create and consume multiple threads,
    in modern applications on Xamarin target platforms, this model has been extended
    with concurrency implementations that delegate the responsibility of thread management
    to runtime and allow the developer only to define execution blocks which may or
    may not be executed on a separate thread.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开发者仍然有能力创建和消费多个线程，但在Xamarin目标平台上的现代应用程序中，这种模型已经通过并发实现进行了扩展，将线程管理的责任委托给运行时，并允许开发者仅定义可能或可能不在单独线程上执行的执行块。
- en: Single thread model
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单线程模型
- en: In Android and iOS, each mobile application is started and run on a single thread
    that is generally referred to as the main or the UI thread. Most of the UI interaction
    and process lifecycle event handlers and delegates are executed on this thread.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android和iOS中，每个移动应用程序都是在单个线程上启动和运行的，这个线程通常被称为主线程或UI线程。大多数的UI交互以及进程生命周期事件处理程序和委托都是在该线程上执行的。
- en: In this model, developers' main concern should be keeping the main thread accessible
    to UI interaction as long as possible. If we were to execute a blocking call on
    this thread, it immediately would be reflected to the user as a screen freeze
    or an application nonresponsive error, which will inevitably get terminated by
    the so-called watch-dog implementation of the underlying platform. In addition
    to the platform-specific restrictions, users also expect a responsive UI at all
    times and cannot tolerate frozen screens even for a fraction of a second. If the
    screen freeze lasts any longer, they will try to forcefully terminate the application
    (see the *Feedback* section of [Chapter 7](ch07.html "Chapter 7. View Elements"),
    *View Elements*).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，开发者主要应关注尽可能长时间地保持主线程对UI交互的可用性。如果我们在这个线程上执行一个阻塞调用，它将立即反映给用户，表现为屏幕冻结或应用程序无响应错误，这不可避免地会被底层平台的所谓看门狗实现终止。除了平台特定的限制之外，用户还期望在任何时候都能有一个响应式的UI，并且无法忍受屏幕冻结哪怕是一瞬间。如果屏幕冻结持续更长时间，他们将尝试强制终止应用程序（参见[第7章](ch07.html
    "第7章。视图元素")的*反馈*部分，*视图元素*）。
- en: Developers can still create, consume, and monitor other threads from the main
    thread. It is possible to use background threads and invoke long running processes
    in the background. For this purpose, the `System.Threading` namespace and threading
    related classes are available on Xamarin.iOS and Xamarin.Android projects. Moreover,
    each platform has its own threading implementation under the hood.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者仍然可以在主线程中创建、消费和监控其他线程。使用后台线程并在后台调用长时间运行的过程是可能的。为此，Xamarin.iOS和Xamarin.Android项目上提供了`System.Threading`命名空间和与线程相关的类。此外，每个平台在底层都有自己的线程实现。
- en: 'For example, let''s imagine we want to execute a long running process and we
    do not want this method to block the UI thread. With classic threading, the implementation
    would look similar to:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象我们想要执行一个长时间运行的过程，我们不想这个方法阻塞UI线程。使用经典的多线程，实现将类似于：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each `Thread` can give information about the current execution state, and it
    can be canceled, started, interrupted, or even joined by another thread. Developers
    can use the threading model for throttling their application and/or executing
    their code more efficiently without committing the cardinal sin of blocking the
    UI thread.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Thread` 都可以提供有关当前执行状态的信息，并且可以被取消、启动、中断，甚至可以被另一个线程加入。开发者可以使用线程模型来限制应用程序的速率和/或更有效地执行代码，而不会犯阻塞
    UI 线程的致命错误。
- en: It might get a little complicated when the process you are executing on a separate
    thread needs to update a UI component. This would be a cross-thread violation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在单独的线程上执行的过程需要更新 UI 组件时，可能会变得有些复杂。这将是一个跨线程违规操作。
- en: 'For instance, if we wanted to update a UI component from a separate thread
    in an Android activity, we would need to execute it on the activity as follows
    (using `Activity.RunOnUiThread`):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在 Android 活动中从单独的线程更新一个 UI 组件，我们需要在活动上执行以下操作（使用 `Activity.RunOnUiThread`）：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The same execution on iOS would look similar to (using `NSObject.InvokeOnMainThread`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 上执行相同的操作看起来类似（使用 `NSObject.InvokeOnMainThread`）：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For reference, on Windows Runtime the same execution would look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，在 Windows Runtime 中，同样的执行过程如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The implementation in classic threading gets even more complex when there is
    an exception or the operation has to be canceled, not to mention the fact that
    synchronization between threads and thread-safe data flow is completely left to
    developers or third-party implementations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现异常或操作需要取消时，经典线程模型下的实现变得更加复杂，更不用说线程间的同步和线程安全的数据流完全依赖于开发者或第三方实现。
- en: Another important mishap of using the `System.Threading` namespace and the classic
    threading model in Xamarin, is that this namespace and thread-related classes
    cannot be used in PCLs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin 中使用 `System.Threading` 命名空间和经典线程模型的一个重要错误是，这个命名空间和与线程相关的类不能在 PCLs
    中使用。
- en: Task-based Asynchronous Pattern
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于任务的异步模式
- en: Since the introduction of the Tasks framework in .NET 4.0 and its later adoption
    by Mono, the **Task-based Asynchronous Pattern** (**TAP**) has become de-facto
    the main implementation strategy for mobile applications. While providing the
    required abstraction from the treading structure, it also gives the development
    teams the opportunity to create easily readable, manageable, and scalable application
    projects. As mentioned earlier, since each Xamarin target platform has the threading
    implemented according to the underlying runtime, this abstraction that the Tasks
    framework provides makes it the perfect candidate for asynchronous implementations
    in cross-platform projects and an invaluable part of portable class libraries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 .NET 4.0 中引入 Tasks 框架以及后来 Mono 的采用，**基于任务的异步模式（TAP**）已经成为移动应用程序的主要实现策略。虽然它提供了从线程结构中所需的抽象，但也给了开发团队创建易于阅读、管理和可扩展的应用程序项目的机会。如前所述，由于每个
    Xamarin 目标平台都根据底层运行时实现线程，Tasks 框架提供的这种抽象使其成为跨平台项目中异步实现的理想候选，并且是可移植类库中不可或缺的部分。
- en: In this pattern, each execution block is represented by a `Task` or a `Task<T>`
    according to the return value of the block (for example, if the block is returning
    void, it should be converted to return `Task` and if the block is returning an
    `int`, the method signature should be `Task<int>`). Tasks can be executed either
    synchronously or asynchronously, can be awaited for a result or executed as a
    promise with a callback on completion, can be pushed to another thread-pool or
    executed on the main thread taking processor time when available.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，每个执行块根据块的返回值被表示为 `Task` 或 `Task<T>`（例如，如果块返回 void，则应将其转换为返回 `Task`；如果块返回
    `int`，则方法签名应为 `Task<int>`）。任务可以同步或异步执行，可以等待结果或作为完成时的回调承诺执行，可以将任务推送到另一个线程池或在可用时在主线程上执行，占用处理器时间。
- en: Tasks are especially suited for computationally intensive operations, since
    they provide excellent control over when and how the asynchronous method is executed.
    Cancellation and progress support on these methods makes long running processes
    easily manageable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任务特别适合于计算密集型操作，因为它们提供了对异步方法何时以及如何执行的良好控制。这些方法上的取消和进度支持使得长时间运行的过程易于管理。
- en: Concurrency model on iOS
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS 的并发模型
- en: Concurrency and operation blocks on iOS runtime are Apple's take on the same
    issues that the Tasks framework is trying to resolve. In essence, the Tasks framework
    and concurrency model on iOS are the solution to creating multitasking, robust,
    and easily scalable applications by creating an abstraction layer so that applications
    do not directly manage threads, but let the operating system decide on where and
    when to execute operations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和iOS运行时的操作块是苹果对任务框架试图解决的问题的回应。本质上，任务框架和iOS上的并发模型是通过创建抽象层来解决创建多任务、健壮且易于扩展的应用程序的解决方案，这样应用程序就不直接管理线程，而是让操作系统决定在哪里以及何时执行操作。
- en: The iOS runtime uses operation or dispatch queues to asynchronously dispatch
    tasks in a **first-in-first-out** (**FIFO**) manner. This approach provides automatic
    thread-pool management as well as a simple programming interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: iOS运行时使用操作或调度队列以**先进先出**（**FIFO**）的方式异步调度任务。这种方法提供了自动线程池管理以及简单的编程接口。
- en: While the iOS runtime constructs such as `NSOperation`, `NSBlockOperation`,
    and `NSOperationQueue` are implemented in the Xamarin.iOS framework and are ready
    to use, the implementations would only be targeting the iOS platform while Tasks
    can be used on all three platforms.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然iOS运行时构造，如`NSOperation`、`NSBlockOperation`和`NSOperationQueue`，在Xamarin.iOS框架中实现并可供使用，但它们的实现仅针对iOS平台，而任务可以在所有三个平台上使用。
- en: Asynchronous methods
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步方法
- en: The **Task Parallel Library** (**TPL**) constitutes the core part of parallel
    computing in the .NET framework and has inherently the same stature in Xamarin
    runtime(s).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务并行库**（**TPL**）是.NET框架中并行计算的核心部分，在Xamarin运行时中也具有相同的地位。'
- en: Asynchronous method execution, together with the `async` and `await` keywords
    (introduced with C# 5.0), can make the apps more responsive and efficient and
    decrease the complexity of implementing multithreading and synchronization. Without
    having the need to implement a parameterized thread, start and push are delegated
    to a background thread, with so called "awaitables." You can convert your methods
    to async promises easily with `Task` or `Task<T>` as the return type. In return,
    the runtime chooses the best time to execute the code and returns the result to
    your execution context.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法执行，结合`async`和`await`关键字（自C# 5.0引入），可以使应用程序更加响应和高效，并降低实现多线程和同步的复杂性。无需实现参数化线程，启动和推送都委托给后台线程，所谓的“可等待”对象。您可以通过将方法返回类型转换为`Task`或`Task<T>`来轻松地将方法转换为异步承诺。作为回报，运行时会在最佳时间执行代码，并将结果返回到您的执行上下文。
- en: 'For instance, the previous thread creation example with Tasks would be as simple
    as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用任务的前一个线程创建示例将非常简单：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, the Tasks framework is not only about creating threads or executing
    non-blocking methods, but also about coordinating and managing these asynchronous
    tasks in the easiest way possible. There are many static helper methods as well
    as methods implemented for Tasks that help developers to easily implement some
    of these coordination scenarios.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任务框架不仅关乎创建线程或执行非阻塞方法，还关乎以尽可能简单的方式协调和管理这些异步任务。有许多静态辅助方法以及为任务实现的方法，帮助开发者轻松实现一些这些协调场景。
- en: Continuation
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续阅读
- en: 'The `ContinueWith` function on the `Task` class allows the developers to chain
    dependent Tasks together and execute them as one Task as a whole. The continuation
    delegate is executed once the result from the first task is posted back to the
    task scheduler. It is important to mention that the first task and the continuation
    methods are not necessarily executed on the same thread. The code is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`类上的`ContinueWith`函数允许开发者将依赖的任务链在一起，并将它们作为一个整体的任务执行。一旦第一个任务的结果被发送回任务调度器，就会执行延续代理。重要的是要提到，第一个任务和延续方法不一定在同一个线程上执行。代码如下：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In case the second task was dependent on the result from the first task:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个任务依赖于第一个任务的结果：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cancellation
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消
- en: '`CancellationToken` and `CancellationTokenSource` are used as the remote token
    to control the execution lifetime of an async method, thread, or a number of threads
    and the event source that the token reflects the events of.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationToken`和`CancellationTokenSource`用作远程令牌，以控制异步方法、线程或多个线程的执行生命周期以及令牌反映的事件源。'
- en: In simple terms, `CancellationTokenSource` is responsible for throwing either
    time-based or manual cancel events and these events can be retrieved through the
    token in the context of the asynchronous method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`CancellationTokenSource`负责抛出基于时间或手动的取消事件，这些事件可以通过异步方法上下文中的令牌检索。
- en: 'You can create a cancellation source using the default constructor and time-based
    cancellation can be added to the token:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用默认构造函数创建一个取消源，并可以向令牌添加基于时间的取消操作：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we are executing an async method, we can use the token from this source,
    or we can associate it with a `TaskFactory` to create a cooperating list of tasks:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们正在执行异步方法，我们可以使用此源中的令牌，或者我们可以将其与`TaskFactory`关联以创建一个协作的任务列表：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, you can also cancel the thread or a group of threads using the `Cancel`
    or `CancelAfter` (with a time delay) methods of `CancellationTokenSource`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以使用`CancellationTokenSource`的`Cancel`或`CancelAfter`（带有时间延迟）方法取消线程或一组线程。
- en: Progress
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进度
- en: Another asynchronous control feature that helps keep the user informed about
    the operations being invoked in the background is the progress callback implementation.
    Just like `CancellationToken`, we can supply the asynchronous tasks with an event
    handler for progress events that the asynchronous method can invoke to pass progress
    information back to the main thread.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个帮助用户了解后台正在调用的操作的异步控制功能是进度回调实现。就像`CancellationToken`一样，我们可以向异步任务提供一个事件处理器，用于进度事件，异步方法可以调用该事件处理器将进度信息传递回主线程。
- en: For simple progress reporting, it is enough to expand asynchronous methods with
    an additional parameter that derives from the `IProgress<T>` interface.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的进度报告，只需在异步方法中添加一个继承自`IProgress<T>`接口的额外参数就足够了。
- en: 'For instance, if we were to implement a progress event handler in the `GetFibonacciRangeAsync`
    method, we could use the number of values to be calculated and the current ordinal
    being calculated to report an overall progress in percentages:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在`GetFibonacciRangeAsync`方法中实现一个进度事件处理器，我们可以使用要计算的值的数量和当前正在计算的序号来报告总进度的百分比：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to be able to use the progress value in our view model, we can make
    use of the `Progress<T>` class, which is the default implementation of `IProgress<T>`.
    The code is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在我们的视图模型中使用进度值，我们可以利用`Progress<T>`类，它是`IProgress<T>`的默认实现。代码如下：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Task batches
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务批量
- en: 'In task-based asynchronous pattern, there are other ways than continuation
    to execute tasks in a batch, even in parallel. The example from the previous section
    was awaiting each number calculation separately and executing the next call. However,
    the manner in which the inner methods were implemented made them independent from
    each other. Hence, it is not actually necessary to wait for them one by one to
    return the result. The code is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于任务的异步模式中，除了延续之外，还有其他方法可以批量执行任务，甚至在并行中执行。上一节中的示例是分别等待每个数字计算，并执行下一个调用。然而，内部方法的实现方式使它们彼此独立。因此，实际上没有必要逐个等待它们返回结果。代码如下：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Mvx` static class and the `Trace` method are provided by the MvvmCross
    library. It will be further discussed in later chapters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mvx`静态类和`Trace`方法由MvvmCross库提供。它将在后面的章节中进一步讨论。'
- en: Now, each Fibonacci number in the sequence is calculated in parallel and when
    the sequence range is complete, an array of result values is returned. Finally,
    we sort the array and return the list of values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，序列中的每个斐波那契数都是并行计算的，当序列范围完成时，返回一个结果值数组。最后，我们排序数组并返回值列表。
- en: 'We can extend this implementation by adding a progress notifier with an interlocked
    (thread-safe) counter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个带有互斥（线程安全）计数器的进度通知器来扩展此实现：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting log traces from the calculations above are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述计算产生的日志跟踪如下：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The total time for the calculations was about 1.2 seconds.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的总时间约为1.2秒。
- en: 'Repeating the same calculations with an `await` on each method would give the
    following output (calculating ordinal 4 until 11):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个方法上重复相同的计算将给出以下输出（计算序号4直到11）：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The same calculations took around 6.3 seconds overall.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的计算总共花费了大约6.3秒。
- en: On top of `WhenAll`, developers are also equipped with the `WhenAny`, `WaitAll`,
    `WaitAny` methods on the `Task` class and `ContinueWhenAll` and `ContinueWhenAny`
    on the `TaskFactory` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`WhenAll`之外，开发者还配备了`Task`类上的`WhenAny`、`WaitAll`、`WaitAny`方法以及`TaskFactory`类上的`ContinueWhenAll`和`ContinueWhenAny`方法。
- en: Parallel execution
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行执行
- en: In the previous section, the discussion was centered on the `System.Threading.Tasks`
    namespace and the `Task` class. Even though tasks are the cornerstone of the task-based
    asynchronous model and so-called Task Parallelism, the concurrent collections
    namespace makes up the Data Parallelism side of the async model and provides developers
    with tools to execute code most efficiently and in a thread-safe manner.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，讨论集中在`System.Threading.Tasks`命名空间和`Task`类上。尽管任务是基于异步模型的基础和所谓的任务并行性的基石，但并发集合命名空间构成了异步模型的数据并行性部分，并为开发者提供了执行代码最有效和线程安全的方式的工具。
- en: '`BlockingCollection<T>` is one of the concurrent collection implementations
    that encapsulates the core synchronization and coordination between threads and
    provides a thread-safe data storage to implement a provider-consumer model in
    Xamarin applications.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>`是并发集合实现之一，它封装了线程之间的核心同步和协调，并为实现Xamarin应用程序中的提供者-消费者模型提供了线程安全的数据存储。'
- en: Using `BlockingCollection<T>`, we can easily implement a new method that makes
    use of the parallel execution from the previous example. In this implementation,
    our view model will be the consumer and the Fibonacci source and the range calculation
    tasks will be the provider.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BlockingCollection<T>`，我们可以轻松实现一个新的方法，该方法利用了前面示例中的并行执行。在这个实现中，我们的视图模型将是消费者，斐波那契源和范围计算任务将是提供者。
- en: 'If we were to rewrite the range calculation method using a blocking collection,
    our method signature would be similar to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用阻塞集合重写范围计算方法，我们的方法签名将类似于：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So in a way, the consumer is going to create the blocking collection and will
    pass it to the provider to fill it up with the calculated values. The provider
    in return will need to push each calculated value from the parallel tasks with
    the `TryAdd` or `Add` methods. The code is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从某种意义上说，消费者将创建阻塞集合，并将其传递给提供者以填充计算值。作为回报，提供者需要使用`TryAdd`或`Add`方法将每个计算值从并行任务中推送到集合中。代码如下：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, once all the calculations are completed, the provider needs to mark
    the collection as add-completed. The code is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦所有计算完成，提供者需要将集合标记为添加完成。代码如下：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While these tasks are being executed on the provider side, we can create the
    consumer in our view model with a `while` loop, checking on certain intervals
    if there is a new item with `TryTake` until it is completed. However, there is
    already an implemented method on the concurrent collection for this purpose: `GetConsumingEnumerable`.
    Using this method makes the execution on the consumer thread as simple as a `foreach`
    block. The code is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些任务在提供者端执行时，我们可以在视图模型中使用`while`循环创建消费者，检查特定间隔是否有新项目使用`TryTake`，直到完成。然而，对于此目的，并发集合已经实现了一个方法：`GetConsumingEnumerable`。使用此方法可以使消费者线程的执行变得像`foreach`块一样简单。代码如下：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this model, the provider thread (together with each parallel task being executed)
    and the consumer thread are executed almost instantaneously and the results are
    reflected to the UI almost immediately through the view model.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，提供者线程（以及每个正在执行的并行任务）和消费者线程几乎可以即时执行，并且结果几乎立即通过视图模型反映到UI上。
- en: 'In the previous implementation, even though possibly multiple values are added
    to the blocking collection and the blocking collection''s support for multiple
    consumers, the `foreach` loop follows a more linear execution. We can extend this
    model by adding multiple consumers using the `Parallel.ForEach` extension method
    from the `System.Threading.Tasks.Parallel` namespace. The code is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，尽管可能将多个值添加到阻塞集合中，并且阻塞集合支持多个消费者，但`foreach`循环遵循更线性的执行。我们可以通过添加多个消费者来扩展此模型，使用`System.Threading.Tasks.Parallel`命名空间中的`Parallel.ForEach`扩展方法。代码如下：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are other constructs and implementation patterns that developers can use
    and adapt on concurrent scenarios such as `Partitioner`, `ActionBlock`, `ConcurrentScheduler`,
    among others. However, these concepts are beyond the scope of this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者还可以使用和适应其他并发场景的构造和实现模式，例如`Partitioner`、`ActionBlock`、`ConcurrentScheduler`等。然而，这些概念超出了本书的范围。
- en: Patterns and best practices
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: It is possible to draw parallels with and even convert from the classic threading
    and eventing patterns while implementing asynchronous tasks. However, async methods
    have to be implemented with caution to avoid deadlocks and uncaught exceptions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现异步任务时，可以与经典的多线程和事件模式进行类比，甚至进行转换。然而，异步方法必须谨慎实现，以避免死锁和未捕获的异常。
- en: Async pattern conversions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步模式转换
- en: The Observer pattern—also known as the **Event-based Asynchronous Pattern**
    (**EAP**)—used to be the main development tool for long running processes and
    service/remote application APIs. Events and delegates still make up a considerable
    amount of UI-related implementation in modern applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式——也称为**基于事件的异步模式**（**EAP**）——曾经是长时间运行过程和服务/远程应用程序API的主要开发工具。事件和委托在现代应用程序中仍然构成了相当一部分UI相关实现。
- en: However, asynchronous tasks and awaitables provide a much more convenient way
    to deal with long running processes and chain completion methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步任务和可等待对象提供了一个更方便的方式来处理长时间运行的过程和链式完成方法。
- en: Fortunately, it is possible to implement conversion patterns from other async
    patterns to task-based implementations. These types of scenarios involve using
    the `TaskCompletionSource` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以将其他异步模式转换为基于任务的实现模式。这类场景涉及使用`TaskCompletionSource`类。
- en: 'In order to demonstrate this, we will be using a simplified version of the
    Fibonacci source implementation from previous examples:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将使用之前示例中的简化版斐波那契源实现：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we have an event handler for successful calculations and another
    one for failed calculations (for example, if the ordinal is less than 0, it should
    throw an `ArgumentOutOfRangeException`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个成功计算的事件处理程序，另一个是失败计算的事件处理程序（例如，如果序号小于0，它应该抛出`ArgumentOutOfRangeException`）。
- en: Our aim here is to implement an asynchronous method, which we can execute and
    yield the result to the UI without having to subscribe to the event every time
    a new `FibonacciSource` is created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是实现一个异步方法，我们可以执行它并将结果传递给UI，而无需每次创建新的`FibonacciSource`时都订阅事件。
- en: 'For this purpose, we can implement a new version of `FibonacciSource` and expose
    only async methods instead of event-based methods. The code is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们可以实现`FibonacciSource`的新版本，仅暴露异步方法而不是基于事件的方法。代码如下：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now calls to calculate Fibonacci numbers would look similar to:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在计算斐波那契数的调用将看起来类似：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This implementation can be further extended with progress and cancellation token
    implementations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现可以通过进度和取消令牌实现进一步扩展。
- en: Multi-threading with tasks
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程与任务
- en: One important thing to realize about asynchronous calls is that they don't necessarily
    run on a separate thread. As a matter of fact, calls are "scheduled" to run in
    a so-called Synchronization Context on the main thread unless they are instructed
    otherwise. Synchronization Context is the message queue that takes care of the
    scheduling of the async calls that need to be awaited. Once the async method (or
    `Task` in most of the cases) is successfully executed, the result is posted back
    onto the Synchronization Context (that is, the main UI thread).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异步调用，有一点很重要需要认识到，它们不一定在单独的线程上运行。实际上，调用被“安排”在所谓的同步上下文中运行在主线程上，除非它们被指示否则。同步上下文是负责安排需要等待的异步调用的消息队列。一旦异步方法（或大多数情况下是`Task`）成功执行，结果就会发布回同步上下文（即主UI线程）。
- en: For demonstration purposes, we will be using the async implementation (EAP conversion)
    from the previous example with some additional diagnostic calls to get additional
    information about the threads and synchronization contexts being used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将使用之前示例中的异步实现（EAP转换）以及一些额外的诊断调用，以获取有关正在使用的线程和同步上下文的信息。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `TraceThreadInfo` method and the associated `ThreadInfo` class used in the
    examples here is a custom implementation used through dependency injection. The
    reason for this is that threading namespace only contains task-related classes
    in PCLs and the only way to actually get the current thread ID is to use platform-specific
    implementation. Platform-specific implementation patterns will be discussed in
    detail in later chapters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的 `TraceThreadInfo` 方法及其相关的 `ThreadInfo` 类是一个通过依赖注入使用的自定义实现。原因是 threading
    命名空间只包含 PCL 中的任务相关类，而获取当前线程 ID 的唯一方法是通过平台特定的实现。平台特定的实现模式将在后续章节中详细讨论。
- en: 'In the tracing method, we will be logging the current thread ID and the current
    synchronization context:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪方法中，我们将记录当前线程 ID 和当前同步上下文：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The calculation command attached to the calculate button is:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 附在计算按钮上的计算命令是：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The associated trace log will look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的跟踪日志如下所示：
- en: '![Multi-threading with tasks](img/B04693_03_01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用任务的并行多线程](img/B04693_03_01.jpg)'
- en: Trace for in-line execution of tasks
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Tasks 的内联执行跟踪
- en: Looking at the trace messages of the execution stack above, one can easily see
    that in spite of the fact we are dealing with async tasks, the whole execution
    takes place on the main thread except for the actual call for the internal method
    of the source (that is, it is executed on Thread 106). The rest of the method
    calls have `Android.App.SyncContext` as the synchronization context and the execution
    order is no different than the call sequence that is implemented.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看上述执行堆栈的跟踪消息，可以很容易地看出，尽管我们正在处理异步任务，但整个执行过程都在主线程上完成，除了对源内部方法的实际调用（即它在 Thread
    106 上执行）。其余的方法调用具有 `Android.App.SyncContext` 作为同步上下文，执行顺序与实现的调用序列没有不同。
- en: 'Changing the implementation a little bit and using the `ContinueWith` function
    of the `Task` item, we get slightly different results. The code is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微改变实现并使用 `Task` 项的 `ContinueWith` 函数，我们得到稍微不同的结果。代码如下：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The trace log for this implementation looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现的跟踪日志如下所示：
- en: '![Multi-threading with tasks](img/B04693_03_02.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![使用任务的并行多线程](img/B04693_03_02.jpg)'
- en: Async execution of Tasks
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Tasks 的异步执行
- en: As the trace log suggests, `ContinueWith` lambda is executed on a separate thread
    but the execution is still sequential.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如跟踪日志所示，`ContinueWith` lambda 在单独的线程上执行，但执行仍然是顺序的。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An important note here is that we are assigning the results back to the ViewModel
    on a separate thread. In this example, the cross-thread invocation is handled
    by the MvvmCross framework. If we were to deal with this assignment, the call
    would look similar to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要注意事项是我们正在将结果返回到 ViewModel 的单独线程上。在这个例子中，跨线程调用由 MvvmCross 框架处理。如果我们处理这个赋值，调用将类似于：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, once the execution gets onto a separate thread, the
    synchronization context is nullified. In .NET runtime, asynchronous tasks that
    are not tracked by the main synchronization context are actually assigned a `TaskScheduler`
    instance and the execution is done through this context. In this case, `TaskScheduler`
    is responsible to redirect the success post messages back to the main thread if
    the task is configured to use the same context (that is, `ConfigureAwait(true)`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，一旦执行进入单独的线程，同步上下文就被取消。在 .NET 运行时，未由主同步上下文跟踪的异步任务实际上被分配了一个 `TaskScheduler`
    实例，并通过此上下文执行。在这种情况下，`TaskScheduler` 负责将成功后消息重定向回主线程，如果任务配置为使用相同的上下文（即 `ConfigureAwait(true)`）。
- en: However, the way synchronization context works in .NET and the configured task
    invocations yield back to the main thread can cause deadlocks if the asynchronous
    tasks are called synchronously (that is, with `Task.Result` or `Task.Wait()`)
    on the main thread. In such a scenario, once the async call finishes executing
    and tries to yield back into the main context, the main context will still not
    be accessible since it is actually waiting for the async task itself to complete.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 .NET 中同步上下文的工作方式以及配置的任务调用返回到主线程可能会导致死锁，如果异步任务在主线程上以同步方式（即使用 `Task.Result`
    或 `Task.Wait()`）调用。在这种情况下，一旦异步调用执行完成并尝试返回到主上下文，由于主上下文实际上正在等待异步任务本身完成，因此主上下文仍然不可访问。
- en: '`ConfigureAwait(false)` informs the scheduler not to look for and post back
    the result to the same execution context where the task was invoked, but rather
    just execute and run to completion on the execution context. This avoids the deadlock
    scenario.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureAwait(false)`通知调度器不要在任务被调用的相同执行上下文中寻找并返回结果，而是直接在执行上下文中执行并运行到完成。这避免了死锁场景。'
- en: This deadlock scenario is specific for .NET runtime and because of the way mono
    runtime on Android and Mono.Touch compiler deal with the task executions; the
    deadlocks currently do not happen on these platforms. However, it is important
    to follow the coding conventions associated with asynchronous tasks and awaitables
    to avoid any unexpected behavior.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种死锁场景是.NET运行时的特定问题，因为Android上的Mono运行时和Mono.Touch编译器处理任务执行的方式；在这些平台上目前不会发生死锁。然而，遵循与异步任务和awaitables相关的编码约定非常重要，以避免任何意外行为。
- en: 'In order to execute the whole task on a separate thread we can use `Task.Run`
    (which will push the task to the ThreadPool) or `Task.Factory.StartNew`. Using
    the `StartNew` method would let you define which type of a method you are about
    to execute in this task and let the runtime make an informed decision about using
    a different thread. The code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在单独的线程上执行整个任务，我们可以使用`Task.Run`（这将任务推送到线程池）或`Task.Factory.StartNew`。使用`StartNew`方法可以让你定义即将在任务中执行的方法类型，并让运行时做出使用不同线程的明智决策。代码如下：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the trace below, the biggest difference with the previous examples is that
    the `DoCalculate` method exits before even the execution starts for the task we
    created for the calculations. This type of execution would eloquently fit with
    the MVVM pattern applied on a cross platform mobile app project. It would avoid
    any UI blocking issues and create a sense of continuity for the user.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的跟踪中，与之前的示例最大的不同是，`DoCalculate`方法甚至在为计算创建的任务开始执行之前就退出了。这种执行方式非常适合在跨平台移动应用项目中应用MVVM模式。它可以避免任何UI阻塞问题，并为用户提供连续性的感觉。
- en: '![Multi-threading with tasks](img/B04693_03_03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![使用任务的多线程](img/B04693_03_03.jpg)'
- en: Starting a new async task
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的异步任务
- en: If we want to analyze the same execution on the iOS application (that is, calculate
    the number on the Fibonacci sequence on a certain ordinal), we can easily identify
    the threading pattern with the Xcode Instruments "System Trace" template.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要分析iOS应用程序上的相同执行过程（即计算某个序号上的斐波那契数列中的数字），我们可以很容易地使用Xcode Instruments的“系统跟踪”模板来识别线程模式。
- en: '![Multi-threading with tasks](img/B04693_03_04.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用任务的多线程](img/B04693_03_04.jpg)'
- en: Calculating four different Fibonacci numbers
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 计算四个不同的斐波那契数
- en: Exception handling
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: Handling exceptions can become cumbersome if correct asynchronous paths are
    not followed in multithreaded implementations. However, in most cases, the async/await
    language constructs take the load of the developers. If the async chain is not
    broken and calls are implemented correctly, catching exceptions in asynchronous
    context is no different than catching them with linear code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在多线程实现中不遵循正确的异步路径，处理异常可能会变得繁琐。然而，在大多数情况下，async/await语言构造减轻了开发者的负担。如果异步链没有被中断，并且调用被正确实现，那么在异步上下文中捕获异常与使用线性代码捕获它们没有区别。
- en: 'Using our example from previous sections:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前章节中的示例：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, if the ordinal we pass in as a parameter is a negative number,
    it would throw an exception with the message **Cannot calculate Fibonacci number
    for a negative number** and we would be displaying the error message in the info
    textbox.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果我们传入的参数是一个负数，它将抛出一个包含消息**无法计算负数的斐波那契数**的异常，我们将在信息文本框中显示错误消息。
- en: 'However, if we were to use the `ContinueWith` construct to execute the same
    code the outcome would have been a little different:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用`ContinueWith`结构来执行相同的代码，结果会有所不同：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the exception message we would receive would be **One or more
    errors occurred**. The reason for this is that the exception thrown in the second
    scenario is an `AggregateException` because of the async chain we created.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们会收到**一个或多个错误发生**的异常消息。原因是第二个场景中抛出的异常是由于我们创建的异步链而导致的`AggregateException`。
- en: '![Exception handling](img/B04693_03_05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![异常处理](img/B04693_03_05.jpg)'
- en: AggregateException in async chain
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 异步链中的AggregateException
- en: The result would have been the same if we were using the `.Result` or `.Wait()`
    calls on the task itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在任务本身上使用`.Result`或`.Wait()`调用，结果将会相同。
- en: The important part of this implementation is where we are calling `await` on
    the asynchronous method. The catch block would never have been called if this
    was not the case. Without the `await` keyword, the try/catch block would have
    been just checking if the preparation of the Task went as expected, not the actual
    execution.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的重要部分是我们对异步方法调用`await`。如果不是这样，捕获块永远不会被调用。没有`await`关键字，try/catch块只会检查任务的准备是否按预期进行，而不是实际的执行。
- en: Another type of async execution that cannot be caught with a try/catch block
    is the type of async methods that return `void` instead of a `Task` or `Task<T>`.
    Similar to having an exception thrown in an event handler, the only two places
    they would be caught are the `AppDomain.UnhandledException` or `Application.ThreadException`
    events. It is always a better practice for asynchronous methods to return `Task`
    and then return void.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种无法用try/catch块捕获的异步执行类型是返回`void`而不是`Task`或`Task<T>`的异步方法。类似于在事件处理器中抛出异常，它们只能被捕获在`AppDomain.UnhandledException`或`Application.ThreadException`事件中。对于异步方法来说，始终是一个更好的实践，让它们返回`Task`然后返回`void`。
- en: 'However, in the `ContinueWith` implementation, with the reference to the `Task`
    at hand, we can also check for the status of the task once it runs to completion
    before we make the result assignment. This assignment is what actually causes
    the exception to bubble-up to upper layers. In this case, we do not need a try/catch
    block. The code is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`ContinueWith`实现中，有了手头的`Task`引用，我们也可以在执行完成之前检查任务的状态。这个赋值实际上导致了异常向上层冒泡。在这种情况下，我们不需要try/catch块。代码如下：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Initialization pattern
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化模式
- en: Especially in scenarios where a service is involved, a common requirement is
    to have an initialization function that would prepare the communication channel
    and/or make a "ping" or an authentication call. When developers are confronted
    with this type of a scenario, the biggest mistake they can make is to call the
    asynchronous initialization function in the constructor with a `.Result` and/or
    `.Wait()` statement (making it a synchronous call).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在涉及服务的场景中，一个常见的需求是拥有一个初始化函数，该函数将准备通信通道并/或执行一个“ping”或认证调用。当开发者面临此类场景时，他们可能犯的最大错误就是在构造函数中使用`.Result`和/或`.Wait()`语句调用异步初始化函数（使其成为一个同步调用）。
- en: For this scenario, let's assume we have a service that implements an interface
    with two simple async method implementations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种场景，让我们假设我们有一个实现了两个简单异步方法实现的接口的服务。
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to be able to call `ServiceMethodAsync`, we first need to make an
    `AuthenticateAsync` call and receive the authentication token from the service.
    The code is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够调用`ServiceMethodAsync`，我们首先需要调用`AuthenticateAsync`并从服务接收认证令牌。代码如下：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we implemented the call for authentication in the constructor
    of the service. Even though the implementation might work in some cases, if the
    service constructor is called from the main UI thread, the thread would go into
    a deadlock as it was described in the previous section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在服务的构造函数中实现了认证调用。尽管在某些情况下实现可能有效，但如果服务构造函数是从主UI线程调用的，线程将进入死锁，正如前一个部分所描述的。
- en: 'The easiest solution would be to either expose the initialization function
    to outer layers or have the service call initialization before each service call.
    For this purpose we can wrap the authentication call in an initialization method.
    The code is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是公开初始化函数给外部层，或者让服务在每次服务调用之前调用初始化。为此，我们可以将认证调用包装在初始化方法中。代码如下：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The service method call would look similar to this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 服务方法调用看起来可能如下所示：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As mentioned, we can also expose the initialization through an interface:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们也可以通过接口公开初始化：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, the caller method needs to check if the service needs async initialization
    and check for the required task results. The code is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用方法需要检查服务是否需要异步初始化，并检查所需的任务结果。代码如下：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Semaphores
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量
- en: 'Synchronization and throttling methodology on the asynchronous context is a
    little different than the classic .NET runtime implementations. For instance,
    lock blocks are not allowed on async calls and you will not be able to use `Mutex`
    for synchronization. `Mutex` is inapplicable as a mutex can only be owned by a
    single thread and async executions are not guaranteed to complete on the same
    thread as they started. The code is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步上下文中，同步和节流方法与经典的.NET运行时实现略有不同。例如，不允许在异步调用中使用锁块，并且您将无法使用`Mutex`进行同步。`Mutex`不适用，因为互斥锁只能由单个线程拥有，而异步执行并不保证在它们启动的同一线程上完成。代码如下：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to handle the non-deterministic execution and threading model of asynchronous
    tasks, a new construct was added to .NET: Semaphore. `Semaphore` (implementation
    of `WaitHandle`) and `SemaphoreSlim` (lightweight version of `Semaphore` that
    is implemented with monitors) types do not enforce thread identity on the `Wait`
    and `Release` calls and can be asynchronously awaited.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理异步任务的非确定性执行和线程模型，.NET添加了一个新的结构：信号量。`Semaphore`（`WaitHandle`的实现）和`SemaphoreSlim`（`Semaphore`的轻量级版本，使用监视器实现）类型在`Wait`和`Release`调用上不强制执行线程身份，并且可以异步等待。
- en: 'For instance, let''s execute a number of parallel calculations orchestrated
    with a semaphore that allows 3 access count (`SemaphoreSlim(3)` or `SemaphoreSlim(3,3)`)
    such as:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们执行一系列并行计算，这些计算由允许3个访问计数（`SemaphoreSlim(3)`或`SemaphoreSlim(3,3)`）的信号量编排，如下所示：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This parallel execution can be easily spotted on the average system time view
    of Instruments'' System Trace template. This is shown in the screenshot below
    where each ordinal calculation would give the exact number of peaks on the selected
    calculation threads):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种并行执行可以在Instruments系统跟踪模板的平均系统时间视图中轻松找到。如下面的截图所示，每个序号计算都会给出所选计算线程上的确切峰值数）：
- en: '![Semaphores](img/B04693_03_06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![信号量](img/B04693_03_06.jpg)'
- en: System time average on synchronized threads
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 同步线程的系统时间平均值
- en: Background tasks
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台任务
- en: Threading and task solutions are not the only option when there is a need to
    execute a not time-bound, long running process. Moreover, both of these options
    are for executing code when your application is in the foreground or in an active
    state. When the application is entering the backgrounded or suspended state, the
    application might still require the execution of some longer method before the
    volatile data is lost, or it might require a process to be running in the background
    when the application is not in an interactive state.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要执行非时间限制的长时间运行过程时，线程和任务解决方案并不是唯一的选择。此外，这两种选项都是用于在您的应用程序处于前台或活动状态时执行代码。当应用程序进入后台或挂起状态时，应用程序可能仍然需要在易失性数据丢失之前执行一些较长时间的方法，或者当应用程序不在交互状态时，可能需要后台运行一个进程。
- en: For these types of scenarios, both iOS and Android offer backgrounding and background
    operation options.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些类型的场景，iOS和Android都提供了后台和后台操作选项。
- en: Background tasks on iOS
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS上的后台任务
- en: Background tasks on iOS are the easiest way for your application to execute
    processing tasks without the need for the UI thread or having to respond to lifecycle
    delegates.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: iOS上的后台任务是应用程序执行处理任务的最简单方式，无需UI线程或响应生命周期代理。
- en: 'There are three types of background tasks that can be executed for different
    needs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以执行三种类型的后台任务，以满足不同的需求：
- en: '**Background-safe tasks**: These tasks are the ones that can be executed at
    any stage of the process lifetime. They are not affected and/or interrupted by
    the application going into the background. The code is as follows:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台安全任务**：这些任务可以在过程生命周期的任何阶段执行。它们不会受到应用程序进入后台的影响和/或中断。代码如下：'
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**DidEnterBackground tasks**: Another type of background task is executed to
    pass the state-save or clean-up logic to a background process. The `DidEnterBackground`
    lifetime delegate is used to initialize these tasks and continue processing even
    after the application goes into the background state. The creation of these tasks
    is similar to the background-safe tasks. The only difference is that the `EndBackgroundTask`
    method has to be called inside the execution block rather than the calling thread,
    since the calling process might have already returned not waiting for the execution
    of the background task. The code is as follows:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进入后台任务**：另一种类型的后台任务用于将状态保存或清理逻辑传递给后台进程。`DidEnterBackground`生命周期委托用于初始化这些任务，并在应用程序进入后台状态后继续处理。这些任务的创建与后台安全任务类似。唯一的区别是必须在执行块内部而不是调用线程中调用`EndBackgroundTask`方法，因为调用进程可能已经返回，不再等待后台任务的执行。代码如下：'
- en: '[PRE41]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Background transfers**: These tasks are specific to iOS 7+ and provide a
    longer processing time (a strict limit on other background tasks is 600 seconds,
    while background transfers can last up to 10,000 seconds). Background transfer
    tasks are used to perform long lasting network operations and upload/download
    large files over the wire.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台传输**：这些任务特定于iOS 7+，提供更长的处理时间（其他后台任务的严格限制为600秒，而后台传输可以持续长达10,000秒）。后台传输任务用于执行长时间的网络操作，并通过网络上传/下载大文件。'
- en: Services (Android only)
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务（仅限Android）
- en: On the Android platform, once the activities enter the backgrounded state, they
    cannot perform tasks and are usually stopped soon after entering the background.
    Services are application components introduced to provide an interface for developers
    to start and stop long running processes in the background.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上，一旦活动进入后台状态，它们就无法执行任务，通常在进入后台后不久就会被停止。服务是引入的应用程序组件，为开发者提供一个接口，以便在后台启动和停止长时间运行的过程。
- en: Even though services are created as part of an application, they have their
    own separate lifecycle and can run even if the application and activity that started
    them was stopped or destroyed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管服务是作为应用程序的一部分创建的，但它们有自己的独立生命周期，即使启动它们的程序和活动被停止或销毁，它们也可以运行。
- en: 'A service can take one or both of two forms:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以采取以下两种形式之一：
- en: '**Started**: A service is "started" when an activity explicitly starts it by
    calling the `StartService` method using an intent. A started service is generally
    used as a `BackgroundWorker` and once the processing operation is finished, the
    service itself or the activity stops it.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动状态**：当活动通过使用意图调用`StartService`方法显式启动服务时，服务处于“启动状态”。启动服务通常用作`BackgroundWorker`，一旦处理操作完成，服务本身或活动会停止它。'
- en: '**Bound**: A "bound" service generally acts as the provider to clients in the
    activities of the application or even other applications. A bound service is kept
    alive as long as another component is bound to it.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定状态**：一个“绑定”服务通常作为客户端在应用程序的活动或甚至其他应用程序中的提供者。只要另一个组件绑定到它，绑定服务就会保持活跃。'
- en: Both of these initialization patterns use the callback methods similar but not
    limited to `OnStartCommand`, `OnBind`, `OnCreate`, and `OnDestroy` to start background
    processing and deal with its lifetime.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种初始化模式都使用类似的回调方法，但不限于`OnStartCommand`、`OnBind`、`OnCreate`和`OnDestroy`来启动后台处理并处理其生命周期。
- en: There are various base classes implemented in the Android namespace and according
    to the requirements, these base classes can be implemented and started or bound.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android命名空间中实现了各种基类，根据需求，可以实现这些基类并启动或绑定。
- en: 'In order to implement a started service to do some background processing, the
    first step of the implementation process would be to create the `IntentService`
    class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个用于执行一些后台处理任务的启动服务，实现过程的第一步是创建`IntentService`类：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `IntentService` base class already deals with lifecycle events such as
    `OnStart`, so all we have to implement is the `OnHandleIntent` method to respond
    to intent requests from activities. The two attributes of the class, `Service`
    and `IntentFilter`, are used by Xamarin compiler to generate the entries in the
    application manifest. The debug build for this implementation gives out the following
    service entry in the application manifest. The code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService`基类已经处理了生命周期事件，例如`OnStart`，因此我们只需实现`OnHandleIntent`方法来响应活动发出的意图请求。该类的两个属性`Service`和`IntentFilter`被Xamarin编译器用于在应用程序清单中生成条目。此实现的调试构建会在应用程序清单中输出以下服务条目。代码如下：'
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this implementation in an activity, the intent service can be started by
    either using the intent filter entry or using the type of the service.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在活动中使用此实现时，可以通过使用意图过滤器条目或使用服务类型来启动意图服务。
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Overall, asynchronous/concurrent implementation patterns and background tasks
    allow the developers to push the heavy-lifting away from the UI thread and create
    responsive applications in the single-threaded paradigm of modern mobile applications.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，异步/并发实现模式和后台任务允许开发者将繁重的工作从UI线程推离，并在现代移动应用的单一线程范式下创建响应式应用程序。
- en: The Task-based Asynchronous Pattern provides an efficient and scalable way to
    implement asynchronous operations with ease. Moreover, progress, cancellation,
    and concurrent collections help monitor, scale, and manage the execution of these
    asynchronous blocks while providing a way to cooperate between each other. Implementing
    these blocks, developers do not need to carry the burden of threads, synchronization,
    and scaling the threads according to the hardware resources.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 基于任务的异步模式提供了一种高效且可扩展的方式来轻松实现异步操作。此外，进度、取消和并发集合有助于监控、扩展和管理这些异步块的执行，同时提供了一种相互协作的方式。实现这些块时，开发者无需承担线程、同步以及根据硬件资源扩展线程的负担。
- en: After analyzing memory and CPU-related topics so far in this book, in the next
    chapter we will discuss local storage and how to use it efficiently.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中分析了内存和CPU相关主题之后，在下一章中，我们将讨论本地存储以及如何高效地使用它。
