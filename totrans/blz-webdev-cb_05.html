<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-165">
    <a id="_idTextAnchor165">
    </a>
    
     5
    
   </h1>
   <h1 id="_idParaDest-166">
    <a id="_idTextAnchor166">
    </a>
    
     Managing Application State
    
   </h1>
   <p>
    
     In this chapter, we will explore the crucial aspect of maintaining and manipulating the state of a Blazor application.
    
    
     An
    
    <strong class="bold">
     
      application state
     
    </strong>
    
     is the
    
    <a id="_idIndexMarker218">
    </a>
    
     runtime data that dictates the behavior and appearance of an application, reflecting user interactions
    
    
     
      and decisions.
     
    
   </p>
   <p>
    
     We will walk through various strategies for state management, from encoding state in the URL for bookmarkable states and easy sharing to implementing in-memory state containers for rapid access.
    
    
     You’ll learn how to inject application state as a service, allowing centralized state management across different components, and how to persist state to ensure data continuity across sessions.
    
    
     Furthermore, we will explore techniques to resolve persisted state upon application load, invoking state changes from anywhere within an application, and monitoring these changes with dedicated listening components.
    
    
     We will pay special attention to sharing state across different render
    
    
     
      mode boundaries.
     
    
   </p>
   <p>
    
     By the end of this chapter, you’ll have a solid foundation in state management practices that will help you build dynamic, responsive, and stateful
    
    
     
      Blazor applications.
     
    
   </p>
   <p>
    
     Here are the recipes that will take
    
    
     
      us there:
     
    
   </p>
   <ul>
    <li>
     
      Having a
     
     
      
       bookmarkable state
      
     
    </li>
    <li>
     
      Implementing an in-memory
     
     
      
       state container
      
     
    </li>
    <li>
     
      Injecting application state as
     
     
      
       a service
      
     
    </li>
    <li>
     
      Invoking state changes
     
     
      
       from anywhere
      
     
    </li>
    <li>
     
      
       Persisting state
      
     
    </li>
    <li>
     
      Resolving
     
     
      
       persisted state
      
     
    </li>
    <li>
     
      Sharing state across interactive render
     
     
      
       mode boundaries
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-167">
    <a id="_idTextAnchor167">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The barrier of entry to that chapter is not high.
    
    
     You’ll need the
    
    
     
      following tools:
     
    
   </p>
   <ul>
    <li>
     
      A modern IDE (that supports
     
     
      
       Blazor development)
      
     
    </li>
    <li>
     
      .NET 9 installed on your
     
     
      
       development machine
      
     
    </li>
    <li>
     
      A modern web browser (one that supports Web Assembly and
     
     
      
       has DevTools)
      
     
    </li>
    <li>
     
      A bare-bone Blazor project (where you’ll write
     
     
      
       your code)
      
     
    </li>
   </ul>
   <p>
    
     You can find all the examples and data samples referenced in the following recipes in a dedicated GitHub repository at:
    
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05">
     
      https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05
     
    </a>
    
     .
    
    
     In each recipe that needs any samples, I will also point you to the directory where you can
    
    
     
      find them.
     
    
   </p>
   <h1 id="_idParaDest-168">
    <a id="_idTextAnchor168">
    </a>
    
     Having bookmarkable state
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker219">
    </a>
    
     will introduce the simplest yet powerful pattern of leveraging a URL to maintain and share application state.
    
    
     Unlike more complex state management strategies, embedding state flags directly in the URL doesn’t require in-memory persistence.
    
    
     A static URL allows users to bookmark a specific application state and facilitates the easy sharing of that state with others.
    
    
     We will follow the well-known
    
    <strong class="bold">
     
      restful routing
     
    </strong>
    
     pattern
    
    <a id="_idIndexMarker220">
    </a>
    
     and elegantly map application states to readable and
    
    
     
      shareable URLs.
     
    
   </p>
   <p>
    
     Let’s create a component that allows us to bookmark and view an entire event list or specific
    
    
     
      event information.
     
    
   </p>
   <h2 id="_idParaDest-169">
    <a id="_idTextAnchor169">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we start implementing a component with bookmarkable state, we need to do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory – this will be our
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-170">
    <a id="_idTextAnchor170">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to implement stateful URLs in
    
    
     
      your application:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file of your application and register the
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      service, as scoped in the application’s dependency
     
     
      
       injection container:
      
     
     <pre class="source-code">
builder.Services.AddScoped&lt;Api&gt;();</pre>
    </li>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component with two navigable routes to facilitate user access to different application states through
     
     
      
       the URL:
      
     
     <pre class="source-code">
@page "/ch05r01/events"
@page "/ch05r01/events/{eventId:guid}"</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component, inject the
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      service and declare an
     
     <strong class="source-inline">
      
       EventId
      
     </strong>
     
      parameter
     
     <a id="_idIndexMarker221">
     </a>
     
      that we will use to fetch specific
     
     
      
       event details:
      
     
     <pre class="source-code">
[Inject] private Api Api { get; init; }
[Parameter] public Guid EventId { get; set; }</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, initialize the
     
     <strong class="source-inline">
      
       Collection
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      variables that will hold the fetched data, based on the application’s
     
     
      
       current state:
      
     
     <pre class="source-code">
protected IList&lt;Event&gt; Collection = [];
protected Event Event;</pre>
    </li>
    <li>
     
      Override the
     
     <strong class="source-inline">
      
       OnParametersSetAsync()
      
     </strong>
     
      life cycle method and implement the logic to update the component’s state, based on the parameters passed in
     
     
      
       the URL:
      
     
     <pre class="source-code">
protected override async Task OnParametersSetAsync()
{
    if (EventId != Guid.Empty)
    {
        Event = await Api
            .GetEventAsync(EventId, default);
        return;
    }
    Collection = await Api.GetEventsAsync(default);
}</pre>
    </li>
    <li>
     
      In the markup of the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component, add a section to render
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      
       details conditionally:
      
     
     <pre class="source-code">
@if (Event is not null)
{
    &lt;p&gt;Viewing: @Event.Id&lt;/p&gt;
    return;
}</pre>
    </li>
    <li>
     
      Add another
     
     <a id="_idIndexMarker222">
     </a>
     
      section to the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      markup to render the
     
     
      <strong class="source-inline">
       
        Collection
       
      </strong>
     
     
      
       elements:
      
     
     <pre class="source-code">
@foreach (var item in Collection)
{
    &lt;div class="w-100"&gt;
        &lt;a href="/ch05r01/events/@item.Id"&gt;
            @item.Id
        &lt;/a&gt;
    &lt;/div&gt;
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-171">
    <a id="_idTextAnchor171">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Program
     
    </strong>
    
     of the application and register the API service in the application’s dependency injection container, so we can inject it later
    
    
     
      when required.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component a slightly enhanced routing.
    
    
     We declare two routable paths –
    
    <strong class="source-inline">
     
      /ch05r01/events
     
    </strong>
    
     for rendering all available events and
    
    <strong class="source-inline">
     
      /ch05r01/events/{eventId:guid}
     
    </strong>
    
     for specific event details.
    
    
     By leveraging path parametrization and path constraints, we specify the
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     parameter within the curly braces, setting
    
    <strong class="source-inline">
     
      Guid
     
    </strong>
    
     as its expected
    
    
     
      value type.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, where we declare the
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     parameter expected by the route.
    
    
     Blazor automatically intercepts and assigns path parameter values based on the name matching.
    
    
     We also inject the
    
    <strong class="source-inline">
     
      Api
     
    </strong>
    
     service from the provided sample data, allowing us to fetch event information seamlessly.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      Collection
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     variables.
    
    
     These are essential in supporting the dual states of the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component – one for showcasing a list of available events and another for presenting details of a specific, selected event.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we fine-tune the rendering logic by overriding the
    
    <strong class="source-inline">
     
      OnParametersSetAsync()
     
    </strong>
    
     life cycle method.
    
    
     We determine whether the
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     was correctly resolved and fetch the details of that specific event, using the injected
    
    <strong class="source-inline">
     
      Api
     
    </strong>
    
     service.
    
    
     Otherwise, we retrieve the entire collection of
    
    
     
      available events.
     
    
   </p>
   <p>
    
     From
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     markup that supports two distinct states.
    
    
     To accommodate this, we include two conditional markup sections.
    
    
     If
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     was fetched, indicating that a specific event’s details are ready for display, we render its
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     and quickly return to skip
    
    <a id="_idIndexMarker223">
    </a>
    
     any further logic.
    
    
     We cover the component’s alternative state in
    
    <em class="italic">
     
      step 7
     
    </em>
    
     by iterating over
    
    <strong class="source-inline">
     
      Collection
     
    </strong>
    
     .
    
    
     We render links to each event’s details, utilizing the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component’s parametrized path and providing
    
    <strong class="source-inline">
     
      item.Id
     
    </strong>
    
     where the
    
    <strong class="source-inline">
     
      eventId
     
    </strong>
    
     
      parameter goes.
     
    
   </p>
   <h2 id="_idParaDest-172">
    <a id="_idTextAnchor172">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     You will find parameterized paths most useful in
    
    <strong class="bold">
     
      CRUD
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Create, Read, Update, Delete
     
    </strong>
    
     ) scenarios.
    
    
     Assuming
    
    <a id="_idIndexMarker224">
    </a>
    
     we would implement a form within the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component designed to attach to an
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     object, we could ingeniously treat a
    
    <strong class="source-inline">
     
      Guid.Empty
     
    </strong>
    
     value as a trigger to initiate the creation process and initialize a new, empty
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     model.
    
    
     Conversely, if a valid
    
    <strong class="source-inline">
     
      Guid
     
    </strong>
    
     is provided, we would fetch the existing
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     from the API.
    
    
     We’ve effectively covered two scenarios with the same form and avoided
    
    
     
      code duplication.
     
    
   </p>
   <p>
    
     Specifying the type for a value in a path isn’t a strict requirement.
    
    
     By default, Blazor will map parameters as strings, giving you the flexibility to parse them into the required type at a later stage.
    
    
     However, the real power lies in utilizing route constraints effectively.
    
    
     While parsing parameters later provides flexibility, I strongly recommend leveraging route constraints wherever possible.
    
    
     In the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component example, by specifying a parameter type as
    
    <strong class="source-inline">
     
      Guid
     
    </strong>
    
     , if the route does not match due to the route constraint, Blazor shows a
    
    <strong class="source-inline">
     
      NotFound
     
    </strong>
    
     content – filtering out invalid inputs preemptively and enhancing the robustness and security of your application.
    
    
     We will explore routing and the
    
    <strong class="source-inline">
     
      NotFound
     
    </strong>
    
     content
    
    <a id="_idIndexMarker225">
    </a>
    
     in
    
    <a href="B22020_09.xhtml#_idTextAnchor308">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-173">
    <a id="_idTextAnchor173">
    </a>
    
     Implementing an in-memory state container
    
   </h1>
   <p>
    
     Efficiently managing
    
    <a id="_idIndexMarker226">
    </a>
    
     interactions with external APIs is absolutely crucial in modern web development.
    
    
     An
    
    <strong class="bold">
     
      in-memory state container
     
    </strong>
    
     allows you to persist specific objects for an application lifetime unless configured otherwise.
    
    
     When you receive a comprehensive data object from the API upon the initial call, rather than fetching this data anew for every page transition, an in-memory state container facilitates the smooth transfer of the entire object throughout the various stages and pages of the application.
    
    
     Furthermore, an in-memory state container proves invaluable during multi-stage setup processes, allowing the current state of a complex setup object to be persistently carried forward without loss or repeated
    
    
     
      external calls.
     
    
   </p>
   <p>
    
     Let’s implement a container where we will persist event information and display it after redirecting a user to an event
    
    
     
      details page.
     
    
   </p>
   <h2 id="_idParaDest-174">
    <a id="_idTextAnchor174">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before diving into the implementation of an in-memory container, we need to do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Register the
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      service as scoped in the application’s dependency injection container (you can check the
     
     <em class="italic">
      
       Having a bookmarkable state
      
     </em>
     
      recipe to
     
     
      
       see how)
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-175">
    <a id="_idTextAnchor175">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Implement the in-memory state container with the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a generic
     
     <strong class="source-inline">
      
       StateContainer&lt;T&gt;
      
     </strong>
     
      class to hold any type of object
     
     
      
       in memory:
      
     
     <pre class="source-code">
public class StateContainer&lt;T&gt; { }</pre>
    </li>
    <li>
     
      Within
     
     <strong class="source-inline">
      
       StateContainer&lt;T&gt;
      
     </strong>
     
      , initialize a backing
     
     <strong class="source-inline">
      
       _container
      
     </strong>
     
      as a generic
     
     <strong class="source-inline">
      
       Dictionary
      
     </strong>
     
      where you will persist
     
     
      
       state objects:
      
     
     <pre class="source-code">
private readonly Dictionary&lt;Guid, T&gt; _container = [];</pre>
    </li>
    <li>
     
      Add the
     
     <strong class="source-inline">
      
       Persist()
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Resolve()
      
     </strong>
     
      methods to
     
     <strong class="source-inline">
      
       StateContainer&lt;T&gt;
      
     </strong>
     
      that either store
     
     <a id="_idIndexMarker227">
     </a>
     
      or retrieve objects from
     
     <strong class="source-inline">
      
       _container
      
     </strong>
     
      , using a
     
     
      <strong class="source-inline">
       
        Guid
       
      </strong>
     
     
      
       key:
      
     
     <pre class="source-code">
public void Persist(Guid key, T value)
    =&gt; _container.TryAdd(key, value);
public T Resolve(Guid key) =&gt; _container[key];</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      application root and register the
     
     <strong class="source-inline">
      
       StateContainer&lt;Event&gt;
      
     </strong>
     
      in the dependency
     
     
      
       injection container:
      
     
     <pre class="source-code">
builder.Services.AddScoped&lt;StateContainer&lt;Event&gt;&gt;();</pre>
    </li>
    <li>
     
      Add a static
     
     <strong class="source-inline">
      
       Config
      
     </strong>
     
      class and define a customized
     
     <strong class="source-inline">
      
       PrerenderDisabled
      
     </strong>
     
      render mode, based on
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      but with
     
     
      
       disabled pre-rendering:
      
     
     <pre class="source-code">
internal static class Config
{
    public static readonly IComponentRenderMode
        PrerenderDisabled = new
            InteractiveWebAssemblyRenderMode(
                prerender: false);
}</pre>
    </li>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component that renders in
     
     
      <strong class="source-inline">
       
        PrerenderDisabled
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch05r02"
@rendermode Config.PrerenderDisabled</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      section of
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      , inject
     
     <strong class="source-inline">
      
       StateContainer&lt;Event&gt;
      
     </strong>
     
      to persist
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      objects,
     
     <strong class="source-inline">
      
       NavigationManager
      
     </strong>
     
      to facilitate navigation, and
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      to seed data
     
     <a id="_idIndexMarker228">
     </a>
     
      from an
     
     
      
       external source:
      
     
     <pre class="source-code">
[Inject]
private StateContainer&lt;Event&gt; Container { get; init; }
[Inject]
private NavigationManager Navigation { get; init; }
[Inject]
private Api Api { get; init; }</pre>
    </li>
    <li>
     
      Still inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, initialize a backing
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      collection and override the
     
     <strong class="source-inline">
      
       OnInitializedAsync()
      
     </strong>
     
      life cycle method to fetch
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      objects
     
     
      
       from
      
     
     
      <strong class="source-inline">
       
        Api
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected IList&lt;Event&gt; Data = [];
protected override async Task OnInitializedAsync()
    =&gt; Data = await Api.GetEventsAsync(default);</pre>
    </li>
    <li>
     
      Lastly, in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       ShowDetails()
      
     </strong>
     
      method that stores a requested
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      in the in-memory
     
     <strong class="source-inline">
      
       StateContainer&lt;Event&gt;
      
     </strong>
     
      and redirects to a page displaying the
     
     
      
       event details:
      
     
     <pre class="source-code">
public void ShowDetails(Event @event)
{
    Container.Persist(@event.Id, @event);
    Navigation.NavigateTo(
        $"/ch05r02/events/{@event.Id}"
    );
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      markup, construct a loop where you render navigation buttons to all elements
     
     <a id="_idIndexMarker229">
     </a>
     
      from the
     
     
      <strong class="source-inline">
       
        Data
       
      </strong>
     
     
      
       collection:
      
     
     <pre class="source-code">
@foreach (var item in Data)
{
    &lt;div class="row w-50 m-1"&gt;
        &lt;button @onclick="@(() =&gt; ShowDetails(item))"&gt;
            @item.Id
        &lt;/button&gt;
    &lt;/div&gt;
}</pre>
    </li>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       EventDetails
      
     </strong>
     
      component with a route matching the one specified in the previous step and rendering in
     
     
      <strong class="source-inline">
       
        PrerenderDisabled
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch05r02/events/{eventId:guid}"
@rendermode Config.PrerenderDisabled</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      section of
     
     <strong class="source-inline">
      
       EventDetails
      
     </strong>
     
      , inject
     
     <strong class="source-inline">
      
       StateContainer&lt;Event&gt;
      
     </strong>
     
      and declare an
     
     <strong class="source-inline">
      
       EventId
      
     </strong>
     
      parameter to capture an event identifier from
     
     
      
       the URL:
      
     
     <pre class="source-code">
[Inject]
private StateContainer&lt;Event&gt; Container { get; init; }
[Parameter]
public Guid EventId { get; set; }</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, declare a
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      variable to maintain the current component state and override the
     
     <strong class="source-inline">
      
       OnParametersSet()
      
     </strong>
     
      life cycle method to resolve
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      from the
     
     
      
       injected
      
     
     
      <strong class="source-inline">
       
        Container
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected Event Model;
protected override void OnParametersSet()
    =&gt; Model = Container.Resolve(EventId);</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       EventDetails
      
     </strong>
     
      markup, introduce a nullability check for
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      , and render the
     
     <a id="_idIndexMarker230">
     </a>
     
      current capacity of the underlying event if
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      is
     
     
      
       successfully resolved:
      
     
     <pre class="source-code">
@if (Model is null) return;
It has @Model.Capacity spots left!</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-176">
    <a id="_idTextAnchor176">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We start the implementation by laying the foundation of in-memory state persistence.
    
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we add a generic class,
    
    <strong class="source-inline">
     
      StateContainer&lt;T&gt;
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we initialize a backing collection within
    
    <strong class="source-inline">
     
      StateContainer&lt;T&gt;
     
    </strong>
    
     to persist state objects.
    
    
     We opt for
    
    <strong class="source-inline">
     
      Dictionary&lt;Guid, T&gt;
     
    </strong>
    
     , as we will exploit its straightforward key-value API, but any alternative collection type would also work.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      Persist()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Resolve()
     
    </strong>
    
     methods.
    
    
     The
    
    <strong class="source-inline">
     
      Persist()
     
    </strong>
    
     method, accepting
    
    <strong class="source-inline">
     
      key
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     , allows us to add objects to our in-memory container.
    
    
     Concurrently, the
    
    <strong class="source-inline">
     
      Resolve()
     
    </strong>
    
     method allows to retrieve these objects using their keys.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we add our in-memory state container to the application’s dependency injection container.
    
    
     As we will be working with
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     objects, we register
    
    <strong class="source-inline">
     
      StateContainer&lt;Event&gt;
     
    </strong>
    
     .
    
    
     We give it a
    
    <strong class="source-inline">
     
      Scoped
     
    </strong>
    
     lifetime to ensure that
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     objects are available throughout the
    
    
     
      user session.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we introduce a custom render mode –
    
    <strong class="source-inline">
     
      PrerenderDisabled
     
    </strong>
    
     .
    
    
     We place
    
    <strong class="source-inline">
     
      PrerenderDisabled
     
    </strong>
    
     in a new, static
    
    <strong class="source-inline">
     
      Config
     
    </strong>
    
     class so that it’s easily reusable.
    
    
     Why do we need a custom render mode?
    
    
     When you declare interactivity mode per component, Blazor serves pre-rendered content by default and hydrates the component state subsequently.
    
    
     In our case, this would raise exceptions, as the in-memory state container remains inaccessible during the initial component render.
    
    
     Our
    
    <strong class="source-inline">
     
      PrerenderDisabled
     
    </strong>
    
     mode, based on
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     , solves
    
    
     
      that challenge.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component, referencing the sample data assembly, and we leverage
    
    <strong class="source-inline">
     
      PrerenderDisabled
     
    </strong>
    
     mode, defined in
    
    <strong class="source-inline">
     
      Config
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we inject the required services –
    
    <strong class="source-inline">
     
      StateContainer&lt;Event&gt;
     
    </strong>
    
     for object state persistence,
    
    <strong class="source-inline">
     
      Navigation
     
    </strong>
    
     for user-directed navigation, and
    
    <strong class="source-inline">
     
      Api
     
    </strong>
    
     for fetching events from an external data source.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection within the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component and populate it by invoking
    
    <strong class="source-inline">
     
      Api
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      OnInitializedAsync()
     
    </strong>
    
     life cycle method.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we define a
    
    <strong class="source-inline">
     
      ShowDetails()
     
    </strong>
    
     method that adds the selected
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     object to the in-memory state container and redirects the user to an event details page.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     markup and render buttons, allowing us to navigate to the details of any element from the
    
    
     <strong class="source-inline">
      
       Data
      
     </strong>
    
    
     
      collection.
     
    
   </p>
   <p>
    
     Now, we also need to
    
    <a id="_idIndexMarker231">
    </a>
    
     add the event details page.
    
    
     In
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we create an
    
    <strong class="source-inline">
     
      EventDetails
     
    </strong>
    
     component with a route matching the one chosen in
    
    <em class="italic">
     
      step 9
     
    </em>
    
     .
    
    
     We also declare its render mode to
    
    <strong class="source-inline">
     
      PrerenderDisabled
     
    </strong>
    
     - in line with the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component.
    
    
     In
    
    <em class="italic">
     
      step 12
     
    </em>
    
     , we inject the
    
    <strong class="source-inline">
     
      StateContainer&lt;Event&gt;
     
    </strong>
    
     and declare
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     , allowing Blazor to intercept the event identifier directly from the page URL.
    
    
     In
    
    <em class="italic">
     
      step 13
     
    </em>
    
     , we declare
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     for the
    
    <strong class="source-inline">
     
      EventDetails
     
    </strong>
    
     component and override the
    
    <strong class="source-inline">
     
      OnParametersSet()
     
    </strong>
    
     life cycle method, where we resolve the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     value using the intercepted
    
    <strong class="source-inline">
     
      EventId
     
    </strong>
    
     .
    
    
     Note that we leverage our
    
    <strong class="source-inline">
     
      StateContainer&lt;Event&gt;
     
    </strong>
    
     to fetch the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     details and avoid additional fetching from external sources.
    
    
     As we wrap up the implementation, in
    
    <em class="italic">
     
      step 14
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      EventDetails
     
    </strong>
    
     component with a markup that checks for the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     state and displays information about the event’s
    
    
     
      current capacity.
     
    
   </p>
   <h2 id="_idParaDest-177">
    <a id="_idTextAnchor177">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Interestingly, the in-memory state container isn’t just for holding onto data.
    
    
     It’s also handy when managing multi-step forms or complex configuration processes, as you can save and retrieve the
    
    
     
      progress efficiently.
     
    
   </p>
   <p>
    
     A critical aspect we’ve deliberately omitted is the mechanism for cleaning up the state container.
    
    
     Depending on your application’s requirements, you may need to persist state for different durations.
    
    
     By following our implementation above, simply registering
    
    <strong class="source-inline">
     
      StateContainer&lt;T&gt;
     
    </strong>
    
     as
    
    <strong class="source-inline">
     
      Scoped
     
    </strong>
    
     ensures that the state lives as long as the user session.
    
    
     However, you might face scenarios where you need more control over the life cycle of state objects.
    
    
     Should you need to clear the state when the user navigates away from a specific component or completes a set of steps, implementing
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     or utilizing
    
    <strong class="source-inline">
     
      OwningComponentBase
     
    </strong>
    
     for scoped disposal are more
    
    
     
      effective strategies.
     
    
   </p>
   <p>
    
     A word of caution before we end this recipe – you must strategically assess the feasibility of in-memory state
    
    <a id="_idIndexMarker232">
    </a>
    
     containers in your scenarios.
    
    
     The complexity of the persisted objects and the duration of their persistence might put an unnecessary strain on application memory and lead to
    
    
     
      performance issues.
     
    
   </p>
   <h1 id="_idParaDest-178">
    <a id="_idTextAnchor178">
    </a>
    
     Injecting application state as a service
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker233">
    </a>
    
     will showcase a design
    
    <a id="_idIndexMarker234">
    </a>
    
     pattern to streamline state management across your application by introducing an application state service and leveraging dependency injection.
    
    
     This method simplifies how components interact with each other, enabling them to seamlessly listen to or communicate changes in the application’s state.
    
    
     Leveraging dependency injection, you enhance the responsiveness of your application and maintain a clean architecture by avoiding tight coupling between components.
    
    
     With an application state service, your application remains agile, maintainable, and scalable, adapting to the evolving needs of
    
    
     
      web development.
     
    
   </p>
   <p>
    
     Let’s implement an injectable state service that allows us to post and receive success and
    
    
     
      failure messages.
     
    
   </p>
   <h2 id="_idParaDest-179">
    <a id="_idTextAnchor179">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into an injectable state service, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Config
      
     </strong>
     
      class with customized
     
     <strong class="source-inline">
      
       PrerenderDisabled
      
     </strong>
     
      render mode from the
     
     <em class="italic">
      
       Implementing an in-memory state container
      
     </em>
     
      recipe or the
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-180">
    <a id="_idTextAnchor180">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow this guide
    
    <a id="_idIndexMarker235">
    </a>
    
     to implement
    
    <a id="_idIndexMarker236">
    </a>
    
     an injectable state service in
    
    
     
      your application:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="source-inline">
      
       StateArgs
      
     </strong>
     
      base record and define the
     
     <strong class="source-inline">
      
       SuccessArgs
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       FailureArgs
      
     </strong>
     
      state arguments deriving from
     
     
      
       that base:
      
     
     <pre class="source-code">
public abstract record StateArgs;
public record SuccessArgs : StateArgs;
public record FailureArgs : StateArgs;</pre>
    </li>
    <li>
     
      Introduce a
     
     <strong class="source-inline">
      
       StoreState
      
     </strong>
     
      class with an
     
     <strong class="source-inline">
      
       event
      
     </strong>
     
      delegate that can be subscribed to and a
     
     <strong class="source-inline">
      
       Notify()
      
     </strong>
     
      method that accepts
     
     <strong class="source-inline">
      
       StateArgs
      
     </strong>
     
      and triggers the
     
     
      <strong class="source-inline">
       
        OnChanged
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
public sealed class StoreState
{
    public event Func&lt;StateArgs, Task&gt; OnChanged;
    public Task Notify(StateArgs args)
        =&gt; OnChanged?.Invoke(args);
}</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      class and register
     
     <strong class="source-inline">
      
       StoreState
      
     </strong>
     
      in the dependency
     
     
      
       injection container:
      
     
     <pre class="source-code">
builder.Services.AddScoped&lt;StoreState&gt;();</pre>
    </li>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component that leverages
     
     <strong class="source-inline">
      
       PrerenderDisabled
      
     </strong>
     
      render mode and implements the
     
     
      <strong class="source-inline">
       
        IDisposable
       
      </strong>
     
     
      
       interface:
      
     
     <pre class="source-code">
@page "/ch05r03"
@rendermode Config.PrerenderDisabled
@implements IDisposable</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, inject
     
     <strong class="source-inline">
      
       StoreState
      
     </strong>
     
      and initialize a
     
     
      <strong class="source-inline">
       
        Message
       
      </strong>
     
     
      
       variable:
      
     
     <pre class="source-code">
[Inject] private StoreState State { get; init; }
protected string Message = string.Empty;</pre>
    </li>
    <li>
     
      Still in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       ReactAsync()
      
     </strong>
     
      method to convert
     
     <strong class="source-inline">
      
       StateArgs
      
     </strong>
     
      into
     
     <a id="_idIndexMarker237">
     </a>
     
      user-friendly
     
     <a id="_idIndexMarker238">
     </a>
     
      messages and apply
     
     
      
       UI changes:
      
     
     <pre class="source-code">
private Task ReactAsync(StateArgs args)
{
    Message = args is SuccessArgs
        ? "Success"
        : "Failure";
    return InvokeAsync(StateHasChanged);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      life cycle method to subscribe the
     
     <strong class="source-inline">
      
       ReactAsync()
      
     </strong>
     
      method to the
     
     
      <strong class="source-inline">
       
        StoreState
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; State.OnChanged += ReactAsync;</pre>
    </li>
    <li>
     
      Lastly, within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement the
     
     <strong class="source-inline">
      
       Dispose()
      
     </strong>
     
      method as required by
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      and unsubscribe
     
     <strong class="source-inline">
      
       ReactAsync()
      
     </strong>
     
      from the
     
     
      <strong class="source-inline">
       
        StoreState
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
public void Dispose()
    =&gt; State.OnChanged -= ReactAsync;</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component’s markup, add two buttons that, upon being clicked, call the
     
     <strong class="source-inline">
      
       Notify()
      
     </strong>
     
      method with either
     
     <strong class="source-inline">
      
       SuccessArgs
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       FailureArgs
      
     </strong>
     
      .
     
     
      Include a paragraph
     
     <a id="_idIndexMarker239">
     </a>
     
      to
     
     <a id="_idIndexMarker240">
     </a>
     
      display the current value of the
     
     <strong class="source-inline">
      
       Message
      
     </strong>
     
      variable
     
     
      
       as well:
      
     
     <pre class="source-code">
&lt;button @onclick="@(() =&gt;
        State.Notify(new SuccessArgs()))"&gt;
    Buy!
&lt;/button&gt;
&lt;button @onclick="@(() =&gt;
        State.Notify(new FailureArgs()))"&gt;
    Buy!
&lt;/button&gt;
&lt;p&gt;@Message&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-181">
    <a id="_idTextAnchor181">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we define three object types –
    
    <strong class="source-inline">
     
      StateArgs
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      SuccessArgs
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      FailureArgs
     
    </strong>
    
     – to represent states within our application.
    
    
     Leveraging inheritance and having
    
    <strong class="source-inline">
     
      SuccessArgs
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      FailureArgs
     
    </strong>
    
     inherit from
    
    <strong class="source-inline">
     
      StateArgs
     
    </strong>
    
     allows us to maintain simplicity in our state-handling logic.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      StoreState
     
    </strong>
    
     class, which acts as an application state service.
    
    
     We expose an event – encapsulating an invocation of an asynchronous method with a
    
    <strong class="source-inline">
     
      StateArgs
     
    </strong>
    
     parameter and a
    
    <strong class="source-inline">
     
      Notify()
     
    </strong>
    
     method – allowing any component to communicate state changes.
    
    
     We’ve effectively encapsulated the complexities of state transitions behind a simple, intuitive interface.
    
    
     With
    
    <strong class="source-inline">
     
      StoreState
     
    </strong>
    
     ready to go, in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we integrate it into our application’s dependency injection container within the
    
    
     <strong class="source-inline">
      
       Program
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component to demonstrate the practical use of our application state service.
    
    
     We opt for custom
    
    <strong class="source-inline">
     
      PrerenderDisabled
     
    </strong>
    
     render mode to avoid potential rendering pitfalls; you learned about that in the
    
    <em class="italic">
     
      Implementing an in-memory state container
     
    </em>
    
     recipe.
    
    
     We also declare
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     to implement the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface, indicating that there will be a custom cleanup logic to execute.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we inject
    
    <strong class="source-inline">
     
      StoreState
     
    </strong>
    
     as
    
    <strong class="source-inline">
     
      State
     
    </strong>
    
     and initialize the
    
    <strong class="source-inline">
     
      Message
     
    </strong>
    
     variable, where we will capture user-friendly snapshots of the application’s state for display.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      ReactAsync()
     
    </strong>
    
     method that acts as a dynamic resolver of
    
    <strong class="source-inline">
     
      StateArgs
     
    </strong>
    
     .
    
    
     We update the
    
    <strong class="source-inline">
     
      Message
     
    </strong>
    
     variable based on the
    
    <strong class="source-inline">
     
      args
     
    </strong>
    
     type, pivoting between success and failure states.
    
    
     Afterward, we invoke
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     to notify that the UI state has changed, but we wrap it inside the
    
    <strong class="source-inline">
     
      InvokeAsync()
     
    </strong>
    
     method to ensure that our UI remains responsive
    
    
     
      and thread-safe.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we enable the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component to listen to state changes broadcasted by
    
    <strong class="source-inline">
     
      StoreState
     
    </strong>
    
     .
    
    
     We override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     method and subscribe our
    
    <strong class="source-inline">
     
      ReactAsync()
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      State.OnChanged
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method, enforced by the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface.
    
    
     Here, we unsubscribe
    
    <strong class="source-inline">
     
      ReactAsync()
     
    </strong>
    
     from
    
    <strong class="source-inline">
     
      State.OnChanged
     
    </strong>
    
     to prevent memory leaks and guarantee graceful
    
    
     
      component disposal.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we put
    
    <a id="_idIndexMarker241">
    </a>
    
     the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     markup
    
    <a id="_idIndexMarker242">
    </a>
    
     in place.
    
    
     We add two buttons – one signals success while the other signals failure.
    
    
     Both utilize the
    
    <strong class="source-inline">
     
      State.Notify()
     
    </strong>
    
     method to orchestrate state changes.
    
    
     Below these buttons, we add paragraph tags and render
    
    <strong class="source-inline">
     
      Message
     
    </strong>
    
     to visualize the impact of our button’s interactions.
    
    
     To keep the example simple, we’re triggering state changes with buttons within the same component that listens to those state changes.
    
    
     However, you could place these buttons in any component across the application, and our
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     will still accurately receive and react to the state notifications.
    
    
     That’s the true strength and agility of having an injectable application
    
    
     
      state service.
     
    
   </p>
   <h2 id="_idParaDest-182">
    <a id="_idTextAnchor182">
    </a>
    
     See also
    
   </h2>
   <p>
    
     In this recipe, we’ve
    
    <a id="_idIndexMarker243">
    </a>
    
     touched on the topic of
    
    <a id="_idIndexMarker244">
    </a>
    
     events in .NET.
    
    
     We won’t dive deep into the .NET fundamentals in that book, but if you’re curious to learn more, check out the official Microsoft Learn
    
    
     
      resources:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">
     
      
       https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-183">
    <a id="_idTextAnchor183">
    </a>
    
     Invoking state changes from anywhere
    
   </h1>
   <p>
    
     In this recipe, we’re
    
    <a id="_idIndexMarker245">
    </a>
    
     exploring injecting state service globally in your Blazor application.
    
    
     State service can cover anything from a user’s app personalization to user session details or processing indicators.
    
    
     In our example, we’re implementing an overlay covering our interface during a long-running task.
    
    <strong class="bold">
     
      Overlay
     
    </strong>
    
     serves as
    
    <a id="_idIndexMarker246">
    </a>
    
     a visual cue to users, signaling that their request is being executed and preventing any user interactions that could disrupt the
    
    
     
      ongoing process.
     
    
   </p>
   <h2 id="_idParaDest-184">
    <a id="_idTextAnchor184">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore the strategy to globally inject state service and trigger an overlay, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Overlay.css
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the GitHub repository and rename it
     
     <strong class="source-inline">
      
       Overlay.razor.css
      
     </strong>
     
      ; after renaming, your IDE might display a compilation error – we will explain that behavior and fix the error by the end of
     
     
      
       this recipe
      
     
    </li>
    <li>
     
      Register the
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      service as scoped in the application’s dependency injection container (check out the
     
     <em class="italic">
      
       Having a bookmarkable state
      
     </em>
     
      recipe to
     
     
      
       see how)
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-185">
    <a id="_idTextAnchor185">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to add a globally injected overlay
    
    
     
      state handler:
     
    
   </p>
   <ol>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       OverlayState
      
     </strong>
     
      class with an
     
     <strong class="source-inline">
      
       OnChanged
      
     </strong>
     
      event for subscribers to listen to and an
     
     <strong class="source-inline">
      
       ExecuteAsync()
      
     </strong>
     
      method that triggers
     
     <strong class="source-inline">
      
       OnChanged
      
     </strong>
     
      , both before and after executing any job passed
     
     
      
       to it:
      
     
     <pre class="source-code">
public class OverlayState
{
    public event Func&lt;bool, Task&gt; OnChanged;
    public async Task ExecuteAsync(Func&lt;Task&gt; job)
    {
        await OnChanged.Invoke(true);
        await job.Invoke();
        await OnChanged.Invoke(false);
    }
}</pre>
    </li>
    <li>
     
      Navigate to
     
     <a id="_idIndexMarker247">
     </a>
     
      the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      class and register
     
     <strong class="source-inline">
      
       OverlayState
      
     </strong>
     
      in the dependency
     
     
      
       injection container.
      
     
     <pre class="source-code">
builder.Services.AddScoped&lt;OverlayState&gt;();</pre>
    </li>
    <li>
     
      Navigate to the main
     
     <strong class="source-inline">
      
       _Imports.razor
      
     </strong>
     
      file at the project level and inject the
     
     <strong class="source-inline">
      
       OverlayState
      
     </strong>
     
      , making it available across all components.
     
     
      You might need to reference the missing assembly
     
     
      
       as well:
      
     
     <pre class="source-code">
@inject
    BlazorCookbook.App.Client.Chapters.Chapter05
    .Recipe04.OverlayState OverlayState</pre>
    </li>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       Overlay
      
     </strong>
     
      component that implements the
     
     
      <strong class="source-inline">
       
        IDisposable
       
      </strong>
     
     
      
       interface:
      
     
     <pre class="source-code">
@implements IDisposable</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       Overlay
      
     </strong>
     
      , initialize an
     
     <strong class="source-inline">
      
       IsVisible
      
     </strong>
     
      variable and define a
     
     <strong class="source-inline">
      
       ReactAsync()
      
     </strong>
     
      method to update
     
     <strong class="source-inline">
      
       IsVisible
      
     </strong>
     
      , based on
     
     
      
       state changes:
      
     
     <pre class="source-code">
protected bool IsVisible;
public Task ReactAsync(bool isVisible)
{
    IsVisible = isVisible;
    return InvokeAsync(StateHasChanged);
}</pre>
    </li>
    <li>
     
      Override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      life cycle method in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Overlay
      
     </strong>
     
      , and
     
     <a id="_idIndexMarker248">
     </a>
     
      subscribe the
     
     <strong class="source-inline">
      
       ReactAsync()
      
     </strong>
     
      method to the
     
     <strong class="source-inline">
      
       OverlayState.OnChanged
      
     </strong>
     
      event for state
     
     
      
       change notifications:
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; OverlayState.OnChanged += ReactAsync;</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       Dispose()
      
     </strong>
     <strong class="bold">
      
       method to unsubscribe
      
     </strong>
     <strong class="source-inline">
      
       ReactAsync()
      
     </strong>
     
      from the
     
     
      <strong class="source-inline">
       
        OverlayState.OnChanged
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
public void Dispose()
    =&gt; OverlayState.OnChanged -= ReactAsync;</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Overlay
      
     </strong>
     
      markup, include an
     
     <strong class="source-inline">
      
       &lt;overlay&gt;
      
     </strong>
     
      section that visually represents the overlay, and use the
     
     <strong class="source-inline">
      
       IsVisible
      
     </strong>
     
      variable to toggle the visibility of this
     
     
      
       section with:
      
     
     <pre class="source-code">
&lt;overlay class="@(IsVisible ? "visible" : "")"&gt;
    Loading...
&lt;/overlay&gt;</pre>
    </li>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component that renders in
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch05r04"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      component’s
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, inject the
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      service, and implement a
     
     <strong class="source-inline">
      
       SyncAsync()
      
     </strong>
     
      method to engage the
     
     <strong class="source-inline">
      
       OverlayState
      
     </strong>
     
      for managing overlay visibility while executing the
     
     <strong class="source-inline">
      
       Api
      
     </strong>
     
      
       service request:
      
     
     <pre class="source-code">
[Inject] private Api Api { get; init; }
private Task SyncAsync()
    =&gt; OverlayState.ExecuteAsync(()
        =&gt; Api.SynchronizeAsync(default));</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      markup, embed the
     
     <strong class="source-inline">
      
       Overlay
      
     </strong>
     
      component, and include a button to trigger
     
     <a id="_idIndexMarker249">
     </a>
     
      the
     
     
      <strong class="source-inline">
       
        SyncAsync()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
&lt;Overlay /&gt;
&lt;button @onclick="@SyncAsync"&gt;
    Synchronize data
&lt;/button&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-186">
    <a id="_idTextAnchor186">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create an
    
    <strong class="source-inline">
     
      OverlayState
     
    </strong>
    
     service.
    
    
     As we expect our overlay to have a binary nature – visible or hidden – we build a
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     -based logic.
    
    
     We add a subscribable event of type
    
    <strong class="source-inline">
     
      Func&lt;bool, Task&gt;
     
    </strong>
    
     and implement an
    
    <strong class="source-inline">
     
      ExecuteAsync()
     
    </strong>
    
     method, which accepts an
    
    <a id="_idIndexMarker250">
    </a>
    
     asynchronous
    
    <strong class="source-inline">
     
      job
     
    </strong>
    
     as a parameter.
    
    
     Within
    
    <strong class="source-inline">
     
      ExecuteAsync()
     
    </strong>
    
     , we toggle the overlay’s visibility by invoking the
    
    <strong class="source-inline">
     
      OnChanged
     
    </strong>
    
     event before and after the
    
    <strong class="source-inline">
     
      job
     
    </strong>
    
     execution, effectively showing the overlay during processing and hiding it upon completion.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we integrate
    
    <strong class="source-inline">
     
      OverlayState
     
    </strong>
    
     into the dependency injection container, and in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we achieve
    
    <strong class="source-inline">
     
      OverlayState
     
    </strong>
    
     global accessibility by injecting it into the
    
    <strong class="source-inline">
     
      _Imports.razor
     
    </strong>
    
     file.
    
    <strong class="source-inline">
     
      _Imports.razor
     
    </strong>
    
     files in a Blazor application act as encapsulators of adding namespaces and directives, enabling them to be accessible across sibling or nested Razor components without declaring them explicitly
    
    
     
      in each.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we create an
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     component, interacting with
    
    <strong class="source-inline">
     
      OverlayState
     
    </strong>
    
     .
    
    
     As we will implement event-driven logic in
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     , we declare it to implement the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we initiate an
    
    <strong class="source-inline">
     
      IsVisible
     
    </strong>
    
     variable to track the overlay’s visibility state and a
    
    <strong class="source-inline">
     
      ReactAsync()
     
    </strong>
    
     method to respond to those state changes.
    
    
     Now, we can leverage the
    
    <strong class="source-inline">
     
      ReactAsync()
     
    </strong>
    
     method to listen to the
    
    <strong class="source-inline">
     
      OverlayState
     
    </strong>
    
     event.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     life cycle method to subscribe to the
    
    <strong class="source-inline">
     
      OverlayState.OnChanged
     
    </strong>
    
     event with
    
    <strong class="source-inline">
     
      ReactAsync()
     
    </strong>
    
     .
    
    
     Now, Blazor will communicate any changes in the overlay state to the
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     UI.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we address potential memory leaks and unsubscribe from the
    
    <strong class="source-inline">
     
      OnChanged
     
    </strong>
    
     event within the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     markup.
    
    
     We introduce a custom
    
    <strong class="source-inline">
     
      &lt;overlay&gt;
     
    </strong>
    
     tag to avoid conflicts with other, standard DOM elements.
    
    
     We use the
    
    <strong class="source-inline">
     
      IsVisible
     
    </strong>
    
     flag to toggle the
    
    <strong class="source-inline">
     
      visible
     
    </strong>
    
     class, deciding whether an overlay is currently visible.
    
    
     Blazor will automatically associate the
    
    <strong class="source-inline">
     
      Overlay.razor.css
     
    </strong>
    
     collocated styles (which you’ve copied from the sample directory) and scope that styling to the
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     component we
    
    
     
      just implemented.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we shift to showcasing the practical application of
    
    <strong class="source-inline">
     
      OverlayState
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     .
    
    
     We create a
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     component and set it to render in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we inject the
    
    <strong class="source-inline">
     
      Api
     
    </strong>
    
     service and implement a
    
    <strong class="source-inline">
     
      SyncAsync()
     
    </strong>
    
     method.
    
    
     In the
    
    <strong class="source-inline">
     
      SyncAsync()
     
    </strong>
    
     method, we leverage
    
    <strong class="source-inline">
     
      OverlayState.ExecuteAsync()
     
    </strong>
    
     to encapsulate the execution of potentially time-consuming operations and display a visual cue in the form of an overlay, ensuring that the user is aware that their request is processing.
    
    
     In
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we introduce the
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     markup by
    
    <a id="_idIndexMarker251">
    </a>
    
     adding the
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     component and a trigger button for the
    
    
     <strong class="source-inline">
      
       SyncAsync()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-187">
    <a id="_idTextAnchor187">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     As we’ve injected the
    
    <strong class="source-inline">
     
      OverlayState
     
    </strong>
    
     globally across all components, we can decouple the
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     presence from any component state.
    
    
     We can achieve that by incorporating the
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     tag within the application’s layout file.
    
    
     With that, the overlay functionality is omnipresent – you can leverage the overlay from any application area with
    
    
     
      minimal fuss.
     
    
   </p>
   <p>
    
     Here’s what the layout could
    
    
     
      look like:
     
    
   </p>
   <pre class="source-code">
@inherits LayoutComponentBase
&lt;Overlay /&gt;
&lt;main&gt;
    @Body
&lt;/main&gt;</pre>
   <h1 id="_idParaDest-188">
    <a id="_idTextAnchor188">
    </a>
    
     Persisting state
    
   </h1>
   <p>
    
     In modern web
    
    <a id="_idIndexMarker252">
    </a>
    
     development, the ability to persist application and session states is no longer a luxury but a necessity.
    
    
     Whether it’s to enhance user experience, safeguard user progress, or maintain preferences across sessions, state persistence plays a pivotal role in creating seamless and engaging digital experiences.
    
    
     Consider the convenience of saving local application configurations on the client side, such as a user’s preference for dark mode or their choice to receive push notifications.
    
    
     Similarly, persisting parts of the session state can be crucial for ensuring that users don’t lose valuable progress due to unexpected disruptions – imagine the frustration it would cause.
    
    
     These small touches can significantly boost the usability and personalization of any application.
    
    
     Let’s see how to persist state in your
    
    
     
      Blazor app.
     
    
   </p>
   <p>
    
     Let’s implement an option to switch between light and dark modes and persist a proper setting flag in a
    
    
     
      user’s browser.
     
    
   </p>
   <h2 id="_idParaDest-189">
    <a id="_idTextAnchor189">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before implementing state persistence, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-190">
    <a id="_idTextAnchor190">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to implement
    
    
     
      state persistence:
     
    
   </p>
   <ol>
    <li>
     
      Add an
     
     <strong class="source-inline">
      
       {ASSEMBLY_NAME}.lib.module.js
      
     </strong>
     
      file within the wwwroot directory of your client application, and define a
     
     <strong class="source-inline">
      
       browserStorage
      
     </strong>
     
      object with a
     
     <strong class="source-inline">
      
       set
      
     </strong>
     
      function that is capable of storing a
     
     <strong class="source-inline">
      
       key
      
     </strong>
     
      -
     
     <strong class="source-inline">
      
       value
      
     </strong>
     
      pair in either session storage or local storage, based on a
     
     
      <strong class="source-inline">
       
        type
       
      </strong>
     
     
      
       parameter:
      
     
     <pre class="source-code">
window.browserStorage = {
    set: function (type, key, value) {
        if (type === 'sessionStorage') {
            sessionStorage.setItem(key, value);
        }
        if (type == 'localStorage') {
            localStorage.setItem(key, value);
        }
    }
};</pre>
    </li>
    <li>
     
      Create a generic, abstract
     
     <strong class="source-inline">
      
       StorageValue
      
     </strong>
     
      class with the
     
     <strong class="source-inline">
      
       Key
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Value
      
     </strong>
     
      properties, aligning
     
     <a id="_idIndexMarker253">
     </a>
     
      with the parameters expected by the
     
     
      <strong class="source-inline">
       
        browserStorage.set
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
public abstract record StorageValue&lt;T&gt;
{
    public string Key { get; init; }
    public T Value { get; init; }
}</pre>
    </li>
    <li>
     
      Create
     
     <strong class="source-inline">
      
       LocalStorageValue
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       SessionStorageValue
      
     </strong>
     
      records – specific implementations of
     
     <strong class="source-inline">
      
       StorageValue
      
     </strong>
     
      for different browser
     
     
      
       storage types:
      
     
     <pre class="source-code">
public record LocalStorageValue&lt;T&gt; : StorageValue&lt;T&gt;;
public record SessionStorageValue&lt;T&gt; :
    StorageValue&lt;T&gt;;</pre>
    </li>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      class within your application, and inject the
     
     <strong class="source-inline">
      
       IJSRuntime
      
     </strong>
     
      service available in Blazor
     
     
      
       by default:
      
     
     <pre class="source-code">
public class BrowserStorage
{
    private readonly IJSRuntime _js;
    public BrowserStorage(IJSRuntime js)
    {
        _js = js;
    }
}</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      , define
     
     <strong class="source-inline">
      
       const
      
     </strong>
     
      values to ensure the consistency of
     
     
      
       the logic:
      
     
     <ul>
      <li>
       <strong class="source-inline">
        
         _setFunc
        
       </strong>
       
        to store the JavaScript
       
       
        
         function name
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         _local
        
       </strong>
       
        and
       
       <strong class="source-inline">
        
         _session
        
       </strong>
       
        to reference the
       
       
        
         storage types:
        
       
       <pre class="source-code">
private const string
    _setFunc = "browserStorage.set",
    _local = "localStorage",
    _session = "sessionStorage";</pre>
      </li>
     </ul>
    </li>
    <li>
     
      Still inside
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      , implement a
     
     <strong class="source-inline">
      
       PersistAsync()
      
     </strong>
     
      method, accepting a
     
     <strong class="source-inline">
      
       StorageValue&lt;T&gt;
      
     </strong>
     
      parameter.
     
     
      Utilize
     
     <strong class="source-inline">
      
       JsonSerializer
      
     </strong>
     
      to convert the
     
     <a id="_idIndexMarker254">
     </a>
     
      value to JSON and determine the appropriate storage location, before invoking the
     
     <strong class="source-inline">
      
       browserStorage.set
      
     </strong>
     
      
       function:
      
     
     <pre class="source-code">
public ValueTask PersistAsync&lt;T&gt;(
    StorageValue&lt;T&gt; @object)
{
    var json = JsonSerializer
        .Serialize(@object.Value);
    var storage = @object is LocalStorageValue&lt;T&gt;
        ? _local : _session;
    return _js.InvokeVoidAsync(_setFunc,
        storage, @object.Key, json);
}</pre>
    </li>
    <li>
     
      Navigate to the application’s
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      class and register the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      service in the dependency
     
     
      
       injection container:
      
     
     <pre class="source-code">
builder.Services.AddTransient&lt;BrowserStorage&gt;();</pre>
    </li>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component that renders in
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch05r05"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      , inject
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      and declare constant
     
     <a id="_idIndexMarker255">
     </a>
     
      keys dedicated to managing view
     
     
      
       mode persistence:
      
     
     <pre class="source-code">
[Inject] private BrowserStorage Storage { get; init; }
private const string _key = "viewMode",
                     _light = "lightMode",
                     _dark = "darkMode";</pre>
    </li>
    <li>
     
      Still in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       SetViewModeAsync()
      
     </strong>
     
      method that takes a
     
     <strong class="source-inline">
      
       mode
      
     </strong>
     
      parameter, encapsulates it within a
     
     <strong class="source-inline">
      
       LocalStorageValue&lt;string&gt;
      
     </strong>
     
      object, and persists it using the
     
     
      <strong class="source-inline">
       
        BrowserStorage.PersistAsync()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
public async Task SetViewModeAsync(string mode)
{
    var value = new LocalStorageValue&lt;string&gt;
    {
        Key = _key,
        Value = mode
    };
    await Storage.PersistAsync(value);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component’s markup, introduce two buttons that utilize the
     
     <strong class="source-inline">
      
       SetViewModeAsync()
      
     </strong>
     
      method to adjust the application’s view mode – one to set light mode and the other for
     
     
      
       dark mode:
      
     
     <pre class="source-code">
&lt;button @onclick="@(() =&gt; SetViewModeAsync(_light))"&gt;
    Turn the light on!
&lt;/button&gt;
&lt;button @onclick="@(() =&gt; SetViewModeAsync(_dark))"&gt;
    Turn the light off!
&lt;/button&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-191">
    <a id="_idTextAnchor191">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker256">
    </a>
    
     will require a piece of custom
    
    <strong class="bold">
     
      JavaScript
     
    </strong>
    
     to lay
    
    <a id="_idIndexMarker257">
    </a>
    
     the foundation of our process.
    
    
     We utilize the
    
    <strong class="source-inline">
     
      {ASSEMBLY_NAME}.lib.module.js
     
    </strong>
    
     file, which resides in the
    
    <strong class="source-inline">
     
      wwwroot
     
    </strong>
    
     folder of our client-side project; if you don’t have it yet, create one.
    
    
     Blazor will automatically embed it, so explicit registration is not required.
    
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to that
    
    <strong class="source-inline">
     
      .js
     
    </strong>
    
     file and define a
    
    <strong class="source-inline">
     
      browserStorage
     
    </strong>
    
     API.
    
    
     For now, we implement just a
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     function that accepts the
    
    <strong class="source-inline">
     
      type
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      key
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     parameters, and depending on the specified
    
    <strong class="source-inline">
     
      type
     
    </strong>
    
     , it invokes the
    
    <strong class="source-inline">
     
      setItem
     
    </strong>
    
     function of either the
    
    <strong class="source-inline">
     
      sessionStorage
     
    </strong>
    
     or
    
    
     <strong class="source-inline">
      
       localStorage
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we create a
    
    <strong class="source-inline">
     
      StorageValue
     
    </strong>
    
     generic record with the
    
    <strong class="source-inline">
     
      Key
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Value
     
    </strong>
    
     properties.
    
    
     By marking this record as
    
    <strong class="source-inline">
     
      abstract
     
    </strong>
    
     , we signal our intention to use it as a foundation for more specific storage values.
    
    
     And we implement just that in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , where we add
    
    <strong class="source-inline">
     
      LocalStorageValue
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      SessionStorageValue
     
    </strong>
    
     , both inheriting
    
    
     
      from
     
    
    
     <strong class="source-inline">
      
       StorageValue
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we initiate the
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     service.
    
    
     As we need to call a JavaScript function from our C# code, we inject Blazor’s baked-in
    
    <strong class="source-inline">
     
      IJSRuntime
     
    </strong>
    
     into our service.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we introduce a few
    
    <strong class="source-inline">
     
      const
     
    </strong>
    
     values to anchor our persistence logic.
    
    
     With
    
    <strong class="source-inline">
     
      _setFunc
     
    </strong>
    
     , we encapsulate the naming of the JavaScript function we want to call, while
    
    <strong class="source-inline">
     
      _local
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      _session
     
    </strong>
    
     identify the two available browser storage types.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we finalize the
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     implementation with the
    
    <strong class="source-inline">
     
      PersistAsync()
     
    </strong>
    
     generic method.
    
    
     However, browser storage allows us to store
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     types only.
    
    
     We address that constraint by leveraging the
    
    <strong class="source-inline">
     
      JsonSerializer
     
    </strong>
    
     to transform our
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     object into
    
    <a id="_idIndexMarker258">
    </a>
    
     a
    
    <strong class="bold">
     
      JSON
     
    </strong>
    
     format.
    
    
     Then, using the
    
    <strong class="source-inline">
     
      is
     
    </strong>
    
     operator and our constant values, we resolve the appropriate browser storage type.
    
    
     Having all the required payload, we end the
    
    <strong class="source-inline">
     
      PersistAsync()
     
    </strong>
    
     logic by delegating work to the
    
    <strong class="source-inline">
     
      browserStorage.set
     
    </strong>
    
     function, with the help of the
    
    <strong class="source-inline">
     
      IJSRuntime
     
    </strong>
    
     reference and its
    
    <strong class="source-inline">
     
      InvokeVoidAsync()
     
    </strong>
    
     method.
    
    
     Now, we need to make our
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     available for components.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Program
     
    </strong>
    
     class and register
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     within the dependency injection container.
    
    
     Given the stateless nature of
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     , we opt for a
    
    <strong class="source-inline">
     
      Transient
     
    </strong>
    
     lifetime to avoid unnecessary
    
    
     
      memory use.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we create a
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component
    
    <a id="_idIndexMarker259">
    </a>
    
     and set it to render in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode, ensuring the component’s interactivity.
    
    
     Then, in
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we inject
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     into the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     and declare a few constant variables –
    
    <strong class="source-inline">
     
      _key
     
    </strong>
    
     , which holds the storage value key, and
    
    <strong class="source-inline">
     
      _light
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      _dark
     
    </strong>
    
     , which outline the available view modes.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      SetViewModeAsync()
     
    </strong>
    
     method, where we initialize the
    
    <strong class="source-inline">
     
      LocalStorageValue
     
    </strong>
    
     variable with our
    
    <strong class="source-inline">
     
      _key
     
    </strong>
    
     and the
    
    <strong class="source-inline">
     
      mode
     
    </strong>
    
     parameter and invoke the
    
    <strong class="source-inline">
     
      PersistAsync()
     
    </strong>
    
     method of the injected
    
    <strong class="source-inline">
     
      BrowserStore
     
    </strong>
    
     service.
    
    
     To wrap it up, in
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we add two buttons to the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component markup.
    
    
     With these buttons, users can invoke the
    
    <strong class="source-inline">
     
      SetViewModeAsync()
     
    </strong>
    
     method and set the selected view mode in the browser’s
    
    
     
      local storage.
     
    
   </p>
   <p>
    
     Steps may vary a little between browsers, but here’s how you can peak the
    
    <strong class="source-inline">
     
      viewMode
     
    </strong>
    
     key value with
    
    
     
      Chrome DevTools:
     
    
   </p>
   <div><div><img alt="Figure 5.1: Peaking the value persisted in a browser’s local storage with Chrome DevTools" src="img/Figure_5.1_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.1: Peaking the value persisted in a browser’s local storage with Chrome DevTools
    
   </p>
   <h2 id="_idParaDest-192">
    <a id="_idTextAnchor192">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     We’ve developed a
    
    <a id="_idIndexMarker260">
    </a>
    
     custom JavaScript function to enable access
    
    <a id="_idIndexMarker261">
    </a>
    
     to a browser’s storage, as this implementation remains functional across both server and client-side scenarios, offering broad compatibility and flexibility.
    
    
     When integrating JavaScript into Blazor applications, you must remember that services depending on
    
    <strong class="source-inline">
     
      IJSRuntime
     
    </strong>
    
     cannot be registered as singletons.
    
    <strong class="source-inline">
     
      IJSRuntime
     
    </strong>
    
     requires access to each user’s browser session, which makes it architecturally incompatible with the singleton initialization pattern and
    
    
     
      lifetime model.
     
    
   </p>
   <p>
    
     However, for projects strictly confined to server-side Blazor, you should consider leveraging the built-in
    
    <strong class="source-inline">
     
      ProtectedBrowserStorage
     
    </strong>
    
     API.
    
    <strong class="source-inline">
     
      ProtectedBrowserStorage
     
    </strong>
    
     is a Blazor-native mechanism that enables browser storage access with a data encryption layer that doesn’t require custom JavaScript
    
    
     
      at all.
     
    
   </p>
   <h1 id="_idParaDest-193">
    <a id="_idTextAnchor193">
    </a>
    
     Resolving persisted state
    
   </h1>
   <p>
    
     In the previous
    
    <a id="_idIndexMarker262">
    </a>
    
     recipe, you explored persisting application state within a browser’s storage.
    
    
     Building upon this foundation, in this recipe, we’ll focus on an equally crucial aspect – restoring that persisted state.
    
    
     That functionality is invaluable when dealing with user-specific local application personalization, such as the preference between dark or light mode or the consent to receive push notifications.
    
    
     With state persistence and resolution, you offer users the convenience of rejoining their sessions exactly where they left them.
    
    
     This continuity is fundamental in crafting a user-centric application and offering a
    
    
     
      personalized experience.
     
    
   </p>
   <p>
    
     With the light or dark mode persisted in the last recipe, let’s implement an option to resolve a persisted view mode value when a
    
    
     
      component renders.
     
    
   </p>
   <h2 id="_idParaDest-194">
    <a id="_idTextAnchor194">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you start resolving persisted state, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      , and all
     
     <strong class="source-inline">
      
       StorageValue
      
     </strong>
     
      records from the
     
     <em class="italic">
      
       Persisting state
      
     </em>
     
      recipe or the
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      If you’re not following along the entire chapter but starting with this recipe, copy the
     
     <strong class="source-inline">
      
       BlazorCookbook.App.Client.lib.module.js
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       wwwroot
      
     </strong>
     
      directory of the
     
     <strong class="source-inline">
      
       BlazorCookbook.App.Client
      
     </strong>
     
      in the GitHub repository to
     
     <a id="_idIndexMarker263">
     </a>
     
      the
     
     <strong class="source-inline">
      
       wwwroot
      
     </strong>
     
      of your project, and rename it to match your
     
     
      
       project assembly
      
     
    </li>
    <li>
     
      Register the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      as transient in your application’s
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      class (check out the
     
     <em class="italic">
      
       Persisting state
      
     </em>
     
      recipe to
     
     
      
       see how)
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-195">
    <a id="_idTextAnchor195">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to implement the resolution of
    
    
     
      persisted state:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       {ASSEMBLY_NAME}.lib.module.js
      
     </strong>
     
      script file, and enhance
     
     <strong class="source-inline">
      
       browserStorage
      
     </strong>
     
      by adding a
     
     <strong class="source-inline">
      
       get
      
     </strong>
     
      function that retrieves the persisted value from storage, specified by the
     
     
      <strong class="source-inline">
       
        type
       
      </strong>
     
     
      
       parameter:
      
     
     <pre class="source-code">
get: function (type, key) {
    if (type === 'sessionStorage') {
        return sessionStorage.getItem(key);
    }
    if (type === 'localStorage') {
        return localStorage.getItem(key);
    }
    return '';
},</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      class, introduce a new
     
     <strong class="source-inline">
      
       _getFunc
      
     </strong>
     
      variable to hold the name of the newly created
     
     <strong class="source-inline">
      
       browserStorage.get
      
     </strong>
     
      
       JavaScript function:
      
     
     <pre class="source-code">
private const string _getFunc = "browserStorage.get";</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      , implement a
     
     <strong class="source-inline">
      
       ResolveAsync()
      
     </strong>
     
      generic method, accepting a
     
     <strong class="source-inline">
      
       StorageValue
      
     </strong>
     
      parameter that fetches the persisted value from the appropriate browser storage.
     
     
      Utilize
     
     <strong class="source-inline">
      
       JsonSerializer
      
     </strong>
     
      to transform the
     
     <a id="_idIndexMarker264">
     </a>
     
      retrieved string into the expected
     
     
      
       object type:
      
     
     <pre class="source-code">
public async ValueTask&lt;T&gt; ResolveAsync&lt;T&gt;(
    StorageValue&lt;T&gt; @object)
{
    var storage = @object is LocalStorageValue&lt;T&gt;
        ? _local : _session;
    var value = await _js.InvokeAsync&lt;string&gt;(
        _getFunc, storage, @object.Key);
    return JsonSerializer.Deserialize&lt;T&gt;(value);
}</pre>
    </li>
    <li>
     
      Move to the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component.
     
     
      Extend the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      section with a new
     
     <strong class="source-inline">
      
       ViewMode
      
     </strong>
     
      variable, and override the
     
     <strong class="source-inline">
      
       OnAfterRenderAsync()
      
     </strong>
     
      life cycle method with logic to resolve the persisted
     
     <strong class="source-inline">
      
       viewMode
      
     </strong>
     
      value
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        ViewMode
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected string ViewMode = string.Empty;
protected override async Task
    OnAfterRenderAsync(bool firstRender)
{
    if (!firstRender) return;
    var value = new LocalStorageValue&lt;string&gt;
    {
        Key = _key
    };
    ViewMode = await Storage.ResolveAsync(value);
    StateHasChanged();
}</pre>
    </li>
    <li>
     
      Enhance
     
     <a id="_idIndexMarker265">
     </a>
     
      the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component’s markup by adding a paragraph below the buttons to display the current
     
     
      <strong class="source-inline">
       
        ViewMode
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
&lt;p&gt;@ViewMode&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-196">
    <a id="_idTextAnchor196">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We start by enhancing our
    
    <strong class="source-inline">
     
      browserStorage
     
    </strong>
    
     API.
    
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      {ASSEMBLY_NAME}.lib.module.js
     
    </strong>
    
     script file and expand the
    
    <strong class="source-inline">
     
      browserStorage
     
    </strong>
    
     functionality with a
    
    <strong class="source-inline">
     
      get
     
    </strong>
    
     function.
    
    
     We mirror the
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     function’s implementation, utilizing the
    
    <strong class="source-inline">
     
      type
     
    </strong>
    
     parameter to select the appropriate storage type and fetching the value associated with the
    
    
     
      specified
     
    
    
     <strong class="source-inline">
      
       key
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we refine our
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     service implementation by introducing a
    
    <strong class="source-inline">
     
      _getFunc
     
    </strong>
    
     variable to store the name of our newly created
    
    <strong class="source-inline">
     
      browserStorage.get
     
    </strong>
    
     function, safeguarding against potential typo errors in future references.
    
    
     Following this, in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      ResolveAsync()
     
    </strong>
    
     generic method that mirrors the logic of the existing
    
    <strong class="source-inline">
     
      PersistAsync()
     
    </strong>
    
     method.
    
    <strong class="source-inline">
     
      ResolveAsync()
     
    </strong>
    
     takes a
    
    <strong class="source-inline">
     
      StorageValue
     
    </strong>
    
     parameter, identifies the correct storage using the
    
    <strong class="source-inline">
     
      is
     
    </strong>
    
     operator, and calls the
    
    <strong class="source-inline">
     
      InvokeAsync()
     
    </strong>
    
     generic method provided by
    
    <strong class="source-inline">
     
      IJSRuntime
     
    </strong>
    
     to pull the
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     from browser storage.
    
    
     Since this value returns as a JSON string, we utilize the
    
    <strong class="source-inline">
     
      JsonSerializer
     
    </strong>
    
     API to convert this string back into the desired
    
    
     
      data type.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we shift to the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component, where we initialize a
    
    <strong class="source-inline">
     
      ViewMode
     
    </strong>
    
     variable to hold the resolved value of the user’s persisted view mode choice.
    
    
     We then override the
    
    <strong class="source-inline">
     
      OnAfterRenderAsync()
     
    </strong>
    
     life cycle method, where we use the injected
    
    <strong class="source-inline">
     
      Storage
     
    </strong>
    
     service and the newly introduced
    
    <strong class="source-inline">
     
      ResolveAsync()
     
    </strong>
    
     method to resolve the
    
    <strong class="source-inline">
     
      ViewMode
     
    </strong>
    
     value when the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component initially renders.
    
    
     Leveraging the
    
    <strong class="bold">
     
      fast-return pattern
     
    </strong>
    
     , we
    
    <a id="_idIndexMarker266">
    </a>
    
     ensure that the method exits immediately
    
    <a id="_idIndexMarker267">
    </a>
    
     during subsequent component state changes.
    
    
     Since Blazor executes our resolving logic post-render, we must invoke the
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     method to refresh the UI with the updated values.
    
    
     Finally, in
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , for the sake of simplicity, we add a paragraph below the action buttons within the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     markup to display the current
    
    <strong class="source-inline">
     
      ViewMode
     
    </strong>
    
     value.
    
    
     Alternatively, you can apply CSS classes for light and dark modes to the DOM elements, should you have the supporting CSS
    
    
     
      in place.
     
    
   </p>
   <h2 id="_idParaDest-197">
    <a id="_idTextAnchor197">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     We used the
    
    <strong class="source-inline">
     
      OnAfterRenderAsync()
     
    </strong>
    
     method to resolve the
    
    <strong class="source-inline">
     
      ViewMode
     
    </strong>
    
     value for an
    
    <a id="_idIndexMarker268">
    </a>
    
     architectural reason.
    
    
     Blazor blocks all
    
    <strong class="source-inline">
     
      IJSRuntime
     
    </strong>
    
     interactions in the initial phases of component initialization.
    
    
     Before the DOM is created, the component is essentially in a setup phase, initializing and fetching required data.
    
    
     Once rendering completes and the DOM structure is in place, Blazor allows us to invoke the
    
    <strong class="source-inline">
     
      IJSRuntime
     
    </strong>
    
     API and interact with loaded
    
    
     
      JavaScript functions.
     
    
   </p>
   <h1 id="_idParaDest-198">
    <a id="_idTextAnchor198">
    </a>
    
     Sharing state across interactive render mode boundaries
    
   </h1>
   <p>
    
     Navigating state
    
    <a id="_idIndexMarker269">
    </a>
    
     management in Blazor apps becomes complicated when you switch from running solely in one render mode to mixing render modes, or using
    
    <strong class="source-inline">
     
      InteractiveAuto
     
    </strong>
    
     mode.
    
    
     The challenge arises from the recreation of a scoped state with every render mode change, due to the lack of automatic state sharing between server and client environments.
    
    
     You can tackle this fragmentation by designating a single, consistent source for state persistence.
    
    
     In this recipe, we will dive into a strategy where the client is the source of truth, and we will restore state from the
    
    
     
      browser storage.
     
    
   </p>
   <p>
    
     Let’s implement a generic component base that allows us to share state across interactive render
    
    
     
      mode boundaries.
     
    
   </p>
   <h2 id="_idParaDest-199">
    <a id="_idTextAnchor199">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into state sharing, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       StorageValue
      
     </strong>
     
      objects from the
     
     <em class="italic">
      
       Resolving persisted state
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapters05
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      If you’re not following along the entire chapter but starting with this recipe, copy the
     
     <strong class="source-inline">
      
       BlazorCookbook.App.Client.lib.module.js
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       wwwroot
      
     </strong>
     
      directory of the
     
     <strong class="source-inline">
      
       BlazorCookbook.App.Client
      
     </strong>
     
      in the GitHub repository to the
     
     <strong class="source-inline">
      
       wwwroot
      
     </strong>
     
      of your project, and rename it to match your
     
     
      
       project assembly
      
     
    </li>
    <li>
     
      Register the
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      as transient in your application’s
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      class (check out the
     
     <em class="italic">
      
       Persisting state
      
     </em>
     
      recipe to
     
     
      
       see how)
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-200">
    <a id="_idTextAnchor200">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to implement sharing state across interactive render
    
    
     
      mode boundaries:
     
    
   </p>
   <ol>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       CartState
      
     </strong>
     
      class, with an
     
     <strong class="source-inline">
      
       UpdateTime
      
     </strong>
     
      property and an
     
     <strong class="source-inline">
      
       Add()
      
     </strong>
     
      method that mimics adding to the cart and
     
     
      
       refreshes
      
     
     
      <strong class="source-inline">
       
        UpdateTime
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
public sealed class CartState
{
    public DateTime UpdateTime { get; set; }
    public void Add() =&gt; UpdateTime = DateTime.UtcNow;
}</pre>
    </li>
    <li>
     
      Navigate
     
     <a id="_idIndexMarker270">
     </a>
     
      to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      class and register a global
     
     <strong class="source-inline">
      
       CascadingValue
      
     </strong>
     
      
       for
      
     
     
      <strong class="source-inline">
       
        CartState
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
builder.Services
    .AddCascadingValue(it =&gt; new CartState());</pre>
    </li>
    <li>
     
      Create a generic
     
     <strong class="source-inline">
      
       CrossingInteractiveBoundary
      
     </strong>
     
      component that implements the
     
     
      <strong class="source-inline">
       
        IAsyncDisposable
       
      </strong>
     
     
      
       interface:
      
     
     <pre class="source-code">
@implements IAsyncDisposable
@typeparam T</pre>
    </li>
    <li>
     
      Within the component’s
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      section of
     
     <strong class="source-inline">
      
       CrossingInteractiveBoundary
      
     </strong>
     
      , define a unique state identifier,
     
     <strong class="source-inline">
      
       _key
      
     </strong>
     
      , inject
     
     <strong class="source-inline">
      
       BrowserStorage
      
     </strong>
     
      , and use
     
     <strong class="source-inline">
      
       CascadingParameter
      
     </strong>
     
      to intercept the
     
     
      
       generic
      
     
     
      <strong class="source-inline">
       
        State
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
private const string _key = "state";
[Inject] private BrowserStorage Storage { get; init; }
[CascadingParameter] public T State { get; set; }</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, override the
     
     <strong class="source-inline">
      
       OnAfterRenderAsync()
      
     </strong>
     
      life cycle method to hydrate
     
     <strong class="source-inline">
      
       State
      
     </strong>
     
      by fetching the persisted value with
     
     <strong class="source-inline">
      
       SessionStorageValue
      
     </strong>
     
      , via the
     
     <strong class="source-inline">
      
       ResolveAsync()
      
     </strong>
     
      method
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        Storage
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected override async Task
    OnAfterRenderAsync(bool firstRender)
{
    if (!firstRender) return;
    var value = new SessionStorageValue&lt;T&gt;
    {
        Key = $"{_key}_{State.GetType()}"
    };
    try
    {
        State = await Storage.ResolveAsync(value);
        StateHasChanged();
    }
    catch { }
}</pre>
    </li>
    <li>
     
      Lastly, in
     
     <a id="_idIndexMarker271">
     </a>
     
      the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, to preserve state upon disposal, implement a
     
     <strong class="source-inline">
      
       DisposeAsync()
      
     </strong>
     
      method, as mandated by the
     
     <strong class="source-inline">
      
       IAsyncDisposable
      
     </strong>
     
      contract, and send the updated
     
     <strong class="source-inline">
      
       State
      
     </strong>
     
      back to the browser storage through the
     
     
      <strong class="source-inline">
       
        PersistAsync()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
public ValueTask DisposeAsync()
{
    var value = new SessionStorageValue&lt;T&gt;
    {
        Key = $"{_key}_{State.GetType()}", 
        Value = State
    };
    return Storage.PersistAsync(value);
}</pre>
    </li>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      component that operates in
     
     <strong class="source-inline">
      
       InteractiveAuto
      
     </strong>
     
      render mode and inherits from the
     
     
      <strong class="source-inline">
       
        CrossingInteractiveBoundary&lt;CartState&gt;
       
      </strong>
     
     
      
       type:
      
     
     <pre class="source-code">
@page "/ch05r07"
@rendermode InteractiveAuto
@inherits CrossingInteractiveBoundary&lt;CartState&gt;</pre>
    </li>
    <li>
     
      In the layout of the
     
     <strong class="source-inline">
      
       Cart
      
     </strong>
     
      component, add a button that triggers the
     
     <strong class="source-inline">
      
       Add()
      
     </strong>
     
      method of
     
     <strong class="source-inline">
      
       State
      
     </strong>
     
      and a paragraph to display the current value of the
     
     
      <strong class="source-inline">
       
        UpdateTime
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;button @onclick="@(() =&gt; State.Add())"&gt;
    Add to cart
&lt;/button&gt;
&lt;p&gt;Last cart change: @State.UpdateTime&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-201">
    <a id="_idTextAnchor201">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we
    
    <a id="_idIndexMarker272">
    </a>
    
     create a
    
    <strong class="source-inline">
     
      CartState
     
    </strong>
    
     state class with an
    
    <strong class="source-inline">
     
      UpdateTime
     
    </strong>
    
     property and an
    
    <strong class="source-inline">
     
      Add()
     
    </strong>
    
     method that refreshes
    
    <strong class="source-inline">
     
      UpdateTime
     
    </strong>
    
     with the current UTC, demonstrating the dynamic state interactions.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Program
     
    </strong>
    
     class, and by leveraging Blazor’s
    
    <strong class="source-inline">
     
      AddCascadingValue()
     
    </strong>
    
     extension method, we declare
    
    <strong class="source-inline">
     
      CartState
     
    </strong>
    
     as a globally accessible
    
    <strong class="source-inline">
     
      CascadingValue
     
    </strong>
    
     , ensuring that the state object is available throughout the application.
    
    
     We declare that the initial state of the cart is represented by a new instance of the
    
    
     <strong class="source-inline">
      
       CartState
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we introduce the cornerstone of our state-sharing mechanism – the
    
    <strong class="source-inline">
     
      CrossingInteractiveBoundary
     
    </strong>
    
     component.
    
    
     By implementing the
    
    <strong class="source-inline">
     
      IAsyncDisposable
     
    </strong>
    
     interface, we prepare
    
    <strong class="source-inline">
     
      CrossingInteractiveBoundary
     
    </strong>
    
     to have an asynchronous disposal logic.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we define a unique
    
    <strong class="source-inline">
     
      _key
     
    </strong>
    
     storage identifier and inject
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     to persist state beyond traditional life cycle boundaries.
    
    
     With the
    
    <strong class="source-inline">
     
      CascadingParameter
     
    </strong>
    
     attribute, we dynamically capture the
    
    <strong class="source-inline">
     
      State
     
    </strong>
    
     value, regardless of the currently expected type.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnAfterRenderAsync()
     
    </strong>
    
     life cycle method of the
    
    <strong class="source-inline">
     
      CrossingInteractiveBoundary
     
    </strong>
    
     to rehydrate
    
    <strong class="source-inline">
     
      State
     
    </strong>
    
     with previously persisted values from the browser’s session storage.
    
    
     We utilize the
    
    <strong class="source-inline">
     
      try
     
    </strong>
    
     -
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     structure to gracefully handle scenarios where the user initializes state for the first time, so there’s no value to restore.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we complete the implementation with the
    
    <strong class="source-inline">
     
      DisposeAsync()
     
    </strong>
    
     method, but instead of releasing resources, we add logic to persist the
    
    <strong class="source-inline">
     
      State
     
    </strong>
    
     value with the
    
    <strong class="source-inline">
     
      PersistAsync()
     
    </strong>
    
     method of
    
    <strong class="source-inline">
     
      Storage
     
    </strong>
    
     .
    
    
     This way, we ensure that the state remains updated and recoverable, regardless of navigation actions or rendering
    
    
     
      mode transitions.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we introduce the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     component that renders in dynamic
    
    <strong class="source-inline">
     
      InteractiveAuto
     
    </strong>
    
     mode and inherits from
    
    <strong class="source-inline">
     
      CrossingInteractiveBoundary
     
    </strong>
    
     , with state represented by the
    
    <strong class="source-inline">
     
      CartState
     
    </strong>
    
     object.
    
    
     Blazor will seamlessly alternate between server-side and client-side rendering, which makes it a perfect environment to showcase the
    
    <a id="_idIndexMarker273">
    </a>
    
     adaptive state-sharing logic of
    
    <strong class="source-inline">
     
      CrossingInteractiveBoundary
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we add the
    
    <strong class="source-inline">
     
      Cart
     
    </strong>
    
     markup – a button that invokes the
    
    <strong class="source-inline">
     
      Add()
     
    </strong>
    
     method of
    
    <strong class="source-inline">
     
      CartState
     
    </strong>
    
     and a paragraph displaying the current
    
    
     <strong class="source-inline">
      
       UpdateTime
      
     </strong>
    
    
     
      value.
     
    
   </p>
   <h2 id="_idParaDest-202">
    <a id="_idTextAnchor202">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The strategy we’ve explored in this recipe is not limited to cascading parameters.
    
    
     You can also leverage
    
    <strong class="source-inline">
     
      BrowserStorage
     
    </strong>
    
     to hydrate and persist the state of the state injected as a service (you learned how to implement injectable state in the
    
    <em class="italic">
     
      Injecting application state as a service
     
    </em>
    
     recipe).
    
    
     Depending on your architectural requirements, you can leverage a
    
    <strong class="bold">
     
      REST API
     
    </strong>
    
     or
    
    <strong class="bold">
     
      gRPC
     
    </strong>
    
     service and persist state on the server as well.
    
    
     Moreover, as the
    
    <a id="_idIndexMarker274">
    </a>
    
     complexity
    
    <a id="_idIndexMarker275">
    </a>
    
     and size of the state object grows, you’ll see that state hydration can cause a visible delay before the UI refreshes with the correct data.
    
    
     That’s where the
    
    <strong class="source-inline">
     
      Overlay
     
    </strong>
    
     component, which we implemented in the
    
    <em class="italic">
     
      Invoking state changes from anywhere
     
    </em>
    
     recipe, comes in handy.
    
    
     By temporarily obscuring the UI until state resolution
    
    <a id="_idIndexMarker276">
    </a>
    
     completes, we ensure that users experience a seamless and
    
    
     
      cohesive interface.
     
    
   </p>
  </div>
 </body></html>