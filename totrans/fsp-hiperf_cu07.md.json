["```cs\nif boolean-expression then expression1 [ else expression2 ] \n\n```", "```cs\nif grade.Equals(\"A\") then \"Excellent\" \n\n```", "```cs\nopen System.Collections.Generic \n\n/// <summary>Get row index within a collection</summary> \nlet GetRowIndex (datasource: IEnumerable<'t>) (functionToFind: 't -> bool) : int = \n    let paramcheck = datasource <> null \n    match paramcheck with \n    | true -> Seq.findIndex functionToFind datasource \n    | _ -> -1 \n\n```", "```cs\nusing Microsoft.FSharp.Core; \nusing System.Diagnostics; \n\nnamespace Chapter7.DelegateInteropCSharp \n{ \n    class Program \n    { \n        static void Main(string[] args) \n        { \n            var proclist = Process.GetProcesses(); \n            int index_devenv = FuncInterop.GetRowIndex(proclist, FuncConvert.ToFSharpFunc((Process p) => p.ProcessName.Equals(\"explorer.exe\"))); \n        } \n    } \n} \n\n```", "```cs\n[<AbstractClass>] \n[<Sealed>] \ntype FuncConvert = \nclass \nstatic member FuncFromTupled : ('T1 * 'T2 * 'T3 * 'T4 * 'T5 -> 'U) -> 'T1 -> 'T2 -> 'T3 -> 'T4 -> 'T5 -> 'U \nstatic member FuncFromTupled : ('T1 * 'T2 * 'T3 * 'T4 -> 'U) -> 'T1 -> 'T2 -> 'T3 -> 'T4 -> 'U \nstatic member FuncFromTupled : ('T1 * 'T2 * 'T3 -> 'U) -> 'T1 -> 'T2 -> 'T3 -> 'U \nstatic member FuncFromTupled : ('T1 * 'T2 -> 'U) -> 'T1 -> 'T2 -> 'U \nstatic member ToFSharpFunc : Converter<'T,'U> -> 'T -> 'U \nstatic member ToFSharpFunc : Action<'T> -> 'T -> unit \nend \n\n```", "```cs\nopen System.Collections.Generic \nopen System.Linq \nopen System.Diagnostics \nopen System \n\nlet GetLargeProcesses() = \n    Process.GetProcesses().Where(new Func<Process,bool>(fun proc -> proc.WorkingSet64 > (8L * 1024L * 1024L))).ToList() \n\n```", "```cs\nmatch expression with \n| pattern [ when condition ] -> result-expression \n\n```", "```cs\nlet SimpleGradePattern grade = \n    match grade with \n    | \"A\" -> \"Excellent\" \n    | \"B\" -> \"Very good\" \n    | \"C\" -> \"Good\" \n    | \"D\" -> \"Bad\" \n    | \"E\" -> \"Very Bad\" \n    | _ -> \"undefined\" \n\n```", "```cs\nif boolean-expression then expression1 [ else expression2 ] \n\n```", "```cs\nlet SimpleGradeNoPattern (grade:String) = \n    if grade.Equals(\"A\") then \"Excellent\" \n    elif grade.Equals(\"B\") then \"Very Good\" \n    elif grade.Equals(\"C\") then \"Good\" \n    elif grade.Equals(\"D\") then \"Bad\" \n    elif grade.Equals(\"E\") then \"Very Bad\" \n    else \"undefined\" \n\n```", "```cs\nopen System \nopen System.Diagnostics \n\n```", "```cs\nlet GradeBenchmarkTest() = \n    let mutable swtimer = new Stopwatch() \n    swtimer.Reset()  \n    swtimer.Start() \n    for i = 1 to 5000000 do \n        SimpleGradePattern \"B\" |> ignore \n    swtimer.Stop() \n    let timerSimpleGradePattern = swtimer.Elapsed \n    swtimer.Reset() \n    swtimer.Start() \n    for i = 1 to 5000000 do \n        SimpleGradeNoPattern \"B\" |> ignore \n    swtimer.Stop() \n    let timerSimpleGradeNoPattern = swtimer.Elapsed \n    //Console.WriteLine(\"Elapsed SimpleGradePattern \"B\" =\" + timerSimpleGradePattern.Milliseconds.ToString()+\" ms\") |> ignore \n    //Console.WriteLine(\"Elapsed SimpleGradeNoPattern \"B\" =\" + timerSimpleGradeNoPattern.Milliseconds.ToString()+\" ms\") |> ignore \n    new Tuple<Int32,Int32>(timerSimpleGradePattern.Milliseconds,timerSimpleGradeNoPattern.Milliseconds) \n\n```", "```cs\nlet GradeBenchmarkSamplingTest (freq:Int32) : unit = \n    let mutable TotalPatternMatch : Int32 = 0 \n    let mutable TotalNoPatternMatch : Int32 = 0 \n    for i = 1 to freq do \n        //Console.WriteLine(\"Sampling \"+i.ToString()+\" of \"+freq.ToString()) \n        let result = GradeBenchmarkTest() \n        TotalPatternMatch <- TotalPatternMatch + result.Item1 \n        TotalNoPatternMatch <- TotalNoPatternMatch + result.Item2 \n    let AveragePatternMatch = TotalPatternMatch / freq \n    let AverageNoPatternMatch = TotalNoPatternMatch / freq \n    Console.WriteLine(\"Average Pattern match result for \"+freq.ToString()+\" times = \"+AveragePatternMatch.ToString()+\"ms\") \n    Console.WriteLine(\"Average No Pattern match result for \"+freq.ToString()+\" times = \"+AverageNoPatternMatch.ToString()+\"ms\") \n    () \n\n```", "```cs\n[<EntryPoint>] \nlet main argv =  \n    //printfn \"%A\" argv \n    PatternMatching.SimpleGradePattern \"B\" |> ignore \n    Console.WriteLine(\"Pattern Matching test\") \n    PatternMatching.GradeBenchmarkSamplingTest 30 \n    0 // return an integer exit code \n\n```", "```cs\n.method public static string  SimpleGradePattern(string grade) cil managed \n{ \n  // Code size       116 (0x74) \n  .maxstack  4 \n  .locals init ([0] string V_0) \n  IL_0000:  nop \n  IL_0001:  ldarg.0 \n  IL_0002:  stloc.0 \n  IL_0003:  ldloc.0 \n  IL_0004:  ldstr      \"A\" \n  IL_0009:  call       bool [mscorlib]System.String::Equals(string, \n                                                            string) \n  IL_000e:  brfalse.s  IL_0012 \n  IL_0010:  br.s       IL_0050 \n  IL_0012:  ldloc.0 \n  IL_0013:  ldstr      \"B\" \n  IL_0018:  call       bool [mscorlib]System.String::Equals(string, \n                                                            string) \n  IL_001d:  brfalse.s  IL_0021 \n  IL_001f:  br.s       IL_0056 \n  IL_0021:  ldloc.0 \n  IL_0022:  ldstr      \"C\" \n  IL_0027:  call       bool [mscorlib]System.String::Equals(string, \n                                                            string) \n  IL_002c:  brfalse.s  IL_0030 \n  IL_002e:  br.s       IL_005c \n  IL_0030:  ldloc.0 \n  IL_0031:  ldstr      \"D\" \n  IL_0036:  call       bool [mscorlib]System.String::Equals(string, \n                                                            string) \n  IL_003b:  brfalse.s  IL_003f \n  IL_003d:  br.s       IL_0062 \n  IL_003f:  ldloc.0 \n  IL_0040:  ldstr      \"E\" \n  IL_0045:  call       bool [mscorlib]System.String::Equals(string, \n                                                            string) \n  IL_004a:  brfalse.s  IL_004e \n  IL_004c:  br.s       IL_0068 \n  IL_004e:  br.s       IL_006e \n  IL_0050:  ldstr      \"Excellent\" \n  IL_0055:  ret \n  IL_0056:  ldstr      \"Very good\" \n  IL_005b:  ret \n  IL_005c:  ldstr      \"Good\" \n  IL_0061:  ret \n  IL_0062:  ldstr      \"Bad\" \n  IL_0067:  ret \n  IL_0068:  ldstr      \"Very Bad\" \n  IL_006d:  ret \n  IL_006e:  ldstr      \"undefined\" \n  IL_0073:  ret \n} // end of method PatternMatching::SimpleGradePattern \n\n```", "```cs\n.method public static string  SimpleGradeNoPattern(string grade) cil managed \n{ \n  // Code size       122 (0x7a) \n  .maxstack  4 \n  IL_0000:  nop \n  IL_0001:  ldarg.0 \n  IL_0002:  ldstr      \"A\" \n  IL_0007:  callvirt   instance bool [mscorlib]System.String::Equals(string) \n  IL_000c:  brfalse.s  IL_0010 \n  IL_000e:  br.s       IL_0012 \n  IL_0010:  br.s       IL_0018 \n  IL_0012:  ldstr      \"Excellent\" \n  IL_0017:  ret \n  IL_0018:  ldarg.0 \n  IL_0019:  ldstr      \"B\" \n  IL_001e:  callvirt   instance bool [mscorlib]System.String::Equals(string) \n  IL_0023:  brfalse.s  IL_0027 \n  IL_0025:  br.s       IL_0029 \n  IL_0027:  br.s       IL_002f \n  IL_0029:  ldstr      \"Very Good\" \n  IL_002e:  ret \n  IL_002f:  ldarg.0 \n  IL_0030:  ldstr      \"C\" \n  IL_0035:  callvirt   instance bool [mscorlib]System.String::Equals(string) \n  IL_003a:  brfalse.s  IL_003e \n  IL_003c:  br.s       IL_0040 \n  IL_003e:  br.s       IL_0046 \n  IL_0040:  ldstr      \"Good\" \n  IL_0045:  ret \n  IL_0046:  ldarg.0 \n  IL_0047:  ldstr      \"D\" \n  IL_004c:  callvirt   instance bool [mscorlib]System.String::Equals(string) \n  IL_0051:  brfalse.s  IL_0055 \n  IL_0053:  br.s       IL_0057 \n  IL_0055:  br.s       IL_005d \n  IL_0057:  ldstr      \"Bad\" \n  IL_005c:  ret \n  IL_005d:  ldarg.0 \n  IL_005e:  ldstr      \"E\" \n  IL_0063:  callvirt   instance bool [mscorlib]System.String::Equals(string) \n  IL_0068:  brfalse.s  IL_006c \n  IL_006a:  br.s       IL_006e \n  IL_006c:  br.s       IL_0074 \n  IL_006e:  ldstr      \"Very Bad\" \n  IL_0073:  ret \n  IL_0074:  ldstr      \"undefined\" \n  IL_0079:  ret \n} // end of method PatternMatching::SimpleGradeNoPattern \n\n```", "```cs\n// Complete active pattern definition. \nlet (|identifer1|identifier2|...|) [ arguments ] = expression \n// Partial active pattern definition. \nlet (|identifier|_|) [ arguments ] = expression \n\n```", "```cs\nlet (|Even|Odd|) anumber = if anumber % 2 = 0 then Even else Odd \n\n```", "```cs\nlet TestEvenNumber anumber = \n    match anumber with \n    | Odd -> \"Odd number\" \n    | Even -> \"Even number\"  \n\n```", "```cs\n    Console.WriteLine(ActivePatterns.TestEvenNumber 5) \n    Console.WriteLine(ActivePatterns.TestEvenNumber 6) \n\n```", "```cs\n.method public specialname static class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit> \n        '|Even|Odd|'(int32 anumber) cil managed \n{ \n  // Code size       24 (0x18) \n  .maxstack  8 \n  IL_0000:  nop \n  IL_0001:  ldarg.0 \n  IL_0002:  ldc.i4.2 \n  IL_0003:  rem \n  IL_0004:  brtrue.s   IL_0008 \n  IL_0006:  br.s       IL_000a \n  IL_0008:  br.s       IL_0011 \n  IL_000a:  ldnull \n  IL_000b:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2<!0,!1> class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::NewChoice1Of2(!0) \n  IL_0010:  ret \n  IL_0011:  ldnull \n  IL_0012:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2<!0,!1> class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::NewChoice2Of2(!1) \n  IL_0017:  ret \n} // end of method ActivePatterns::'|Even|Odd|' \n\n```", "```cs\n.method public static string  TestEvenNumber(int32 anumber) cil managed \n{ \n  // Code size       32 (0x20) \n  .maxstack  3 \n  .locals init ([0] int32 V_0, \n           [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_1) \n  IL_0000:  nop \n  IL_0001:  ldarg.0 \n  IL_0002:  stloc.0 \n  IL_0003:  ldloc.0 \n  IL_0004:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit> ActivePatterns::'|Even|Odd|'(int32) \n  IL_0009:  stloc.1 \n  IL_000a:  ldloc.1 \n  IL_000b:  isinst     class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`2/Choice1Of2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit> \n  IL_0010:  brfalse.s  IL_0014 \n  IL_0012:  br.s       IL_001a \n  IL_0014:  ldstr      \"Odd number\" \n  IL_0019:  ret \n  IL_001a:  ldstr      \"Even number\" \n  IL_001f:  ret \n} // end of method ActivePatterns::TestEvenNumber \n\n```", "```cs\n[<StructuralEquality>] \n[<StructuralComparison>] \ntype Choice<'T1,'T2> = \n| Choice1Of2 of 'T1 \n| Choice2Of2 of 'T2 \nwith \ninterface IStructuralEquatable \ninterface IComparable \ninterface IComparable \ninterface IStructuralComparable \nend \n\n```", "```cs\nlet greaterThan a b = if a > b then a else b \n\n```", "```cs\nlet intCompare = greaterThan 5 2 \nlet strCompare = greaterThan \"you\" \"me\" \n\n```", "```cs\n^T -> ^U \n\n```", "```cs\nval inline NonStructural< ^T > : IComparer< ^T > when ^T : (static member ( < ) : ^T * ^T    -> bool) and ^T : (static member ( > ) : ^T * ^T    -> bool) \n\n```", "```cs\nlet inline inlinemul a b = a * b \n\n```", "```cs\nlet inline (^*) a b = a * b \n\n```", "```cs\n01: val inline inlinemul : \n02:  a: ^a -> b: ^b ->  ^c \n03:    when ( ^a or  ^b) : (static member ( * ) :  ^a *  ^b ->  ^c) \n\n```", "```cs\nlet MulDoubleTest = inlinemul 5.2 10.7 \n\nlet MulIntTest = inlinemul 5 12 \n\nlet InlineOpMultiplyTest = 6 ^* 10 \n\n```", "```cs\n.method public static !!c  inlinemul<a,b,c>(!!a a, !!b b) cil managed \n{ \n  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationArgumentCountsAttribute::.ctor(int32[]) = ( 01 00 02 00 00 00 01 00 00 00 01 00 00 00 00 00 )  \n  // Code size       13 (0xd) \n  .maxstack  4 \n  .locals init ([0] !!a V_0, \n           [1] !!b V_1) \n  IL_0000:  nop \n  IL_0001:  ldarg.0 \n  IL_0002:  stloc.0 \n  IL_0003:  ldarg.1 \n  IL_0004:  stloc.1 \n  IL_0005:  ldloc.0 \n  IL_0006:  ldloc.1 \n  IL_0007:  call       !!2 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives::MultiplyDynamic<!!0,!!1,!!2>(!!0,  !!1) \n  IL_000c:  ret \n} // end of method InlineFunctions::inlinemul \n\n```", "```cs\n.property int32 MulIntTest() \n{ \n  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 )  \n  .get int32 InlineFunctions::get_MulIntTest() \n} // end of property InlineFunctions::MulIntTest \n\n```", "```cs\n.method public specialname static int32  get_MulIntTest() cil managed \n{ \n  // Code size       6 (0x6) \n  .maxstack  8 \n  IL_0000:  ldsfld     int32 '<StartupCode$Chapter7-LanguageConstructs>'.$InlineFunctions::MulIntTest@9 \n  IL_0005:  ret \n} // end of method InlineFunctions::get_MulIntTest \n\n```", "```cs\nlet rec factorial n =  \n    match n with \n    | 0 | 1 -> n \n    | _ -> n * factorial (n-1) \n\n```", "```cs\n/// Computes the sum of a list of integers using recursion. \nlet rec sumList xs = \n    match xs with \n    | []    -> 0 \n    | y::ys -> y + sumList ys \n\n```", "```cs\n.method public static int32  sumList(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> xs) cil managed \n{ \n  // Code size       40 (0x28) \n  .maxstack  4 \n  .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> V_0, \n           [1] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> V_1, \n           [2] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> ys, \n           [3] int32 y) \n  IL_0000:  nop \n  IL_0001:  ldarg.0 \n  IL_0002:  stloc.0 \n  IL_0003:  ldloc.0 \n  IL_0004:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull() \n  IL_0009:  brfalse.s  IL_000d \n  IL_000b:  br.s       IL_000f \n  IL_000d:  ldc.i4.0 \n  IL_000e:  ret \n  IL_000f:  ldloc.0 \n  IL_0010:  stloc.1 \n  IL_0011:  ldloc.1 \n  IL_0012:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull() \n  IL_0017:  stloc.2 \n  IL_0018:  ldloc.1 \n  IL_0019:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_HeadOrDefault() \n  IL_001e:  stloc.3 \n  IL_001f:  ldloc.3 \n  IL_0020:  ldloc.2 \n  IL_0021:  call       int32 TailcallSample::sumList(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>) \n  IL_0026:  add \n  IL_0027:  ret \n} // end of method TailcallSample::sumList \n\n```", "```cs\nlet apply f x = f x \n\n```", "```cs\nmethod public static !!b  apply<a,b>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!a,!!b> f, \n                                      !!a x) cil managed \n{ \n  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationArgumentCountsAttribute::.ctor(int32[]) = ( 01 00 02 00 00 00 01 00 00 00 01 00 00 00 00 00 )  \n  // Code size       11 (0xb) \n  .maxstack  8 \n  IL_0000:  nop \n  IL_0001:  ldarg.0 \n  IL_0002:  ldarg.1 \n  IL_0003:  tail. \n  IL_0005:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!a,!!b>::Invoke(!0) \n  IL_000a:  ret \n} // end of method TailcallSample::apply \n\n```", "```cs\nlet accFactorial x = \n    let rec TailCallRecursiveFactorial x acc = \n        if x <= 1 then acc \n        else TailCallRecursiveFactorial (x - 1) (acc * x) \n    TailCallRecursiveFactorial x 1 \n\n```", "```cs\n.method public static int32  accFactorial(int32 x) cil managed \n{ \n  // Code size       18 (0x12) \n  .maxstack  5 \n  .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,int32>> TailCallRecursiveFactorial) \n  IL_0000:  nop \n  IL_0001:  newobj     instance void TailcallSample/TailCallRecursiveFactorial@24::.ctor() \n  IL_0006:  stloc.0 \n  IL_0007:  ldloc.0 \n  IL_0008:  ldarg.0 \n  IL_0009:  ldc.i4.1 \n  IL_000a:  tail. \n  IL_000c:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,int32>::InvokeFast<int32>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>, \n                                                                                                                 !0, \n                                                                                                                 !1) \n  IL_0011:  ret \n} // end of method TailcallSample::accFactorial \n\n```"]