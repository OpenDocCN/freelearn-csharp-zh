- en: The Factory Method
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: 'The Factory Method is probably the most famous design pattern because it offers
    a solid structural base for most software architectures. There are two main variations
    of this pattern:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法可能是最著名的设计模式，因为它为大多数软件架构提供了一个坚实的结构基础。这个模式主要有两种变体：
- en: The Factory Method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Abstract factory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: The main difference between both patterns is that the Factory Method is centered
    around a single Factory Method, while the Abstract Factory provides a way to encapsulate
    and group factories that have a familiar theme. These descriptions might sound
    abstract at the moment, but we will implement both of these variations in separate
    chapters so that we can better understand the core differences between each type
    of Factory pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式之间的主要区别在于，工厂方法围绕一个单一的工厂方法，而抽象工厂提供了一种封装和组合具有相似主题的工厂的方法。这些描述现在可能听起来很抽象，但我们将分别在单独的章节中实现这两种变体，以便我们更好地理解每种工厂模式的核心区别。
- en: On a personal note, my only issue with the Factory pattern, in general, is that
    programmers tend to be irregular in the ways they implement it, and so sometimes
    consistency is lost because of personal style. But as we are going to see throughout
    this book, the most popular patterns tend to have significant alterations in the
    way they are implemented by professional programmers. We are going to try and
    take an approach that's always compatible with Unity's API and coding model.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 说到个人观点，我对工厂模式的一般问题在于程序员在实现它时往往不够规范，因此有时由于个人风格的原因，一致性会丢失。但正如我们将在整本书中看到的那样，最受欢迎的模式往往在专业程序员实现它们的方式上有显著的改变。我们将尝试采取一种始终与Unity的API和编码模型兼容的方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An overview of the Factory Method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法的概述
- en: Implementing a **non-player characters** (**NPC**) spawn system while using
    the Factory Method as the foundation of our architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用工厂方法作为我们架构基础的同时实现**非玩家角色**（**NPC**）生成系统
- en: The core difference between the Factory and Prototype patterns is that the Factory pattern
    is useful when you want to delegate the creation process of objects, while the
    Prototype pattern is an optimal solution when creating new instances of objects
    is too costly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式和原型模式之间的核心区别在于，当您想要委托对象的创建过程时，工厂模式是有用的，而原型模式在创建新实例的成本过高时是一个最优解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands on; you will need to have a basic understanding of Unity
    and C# to continue.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的；你需要对Unity和C#有基本的了解才能继续。
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: Enums
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Composition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成
- en: If you're unfamiliar with these concepts, please review them before starting
    this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请在开始本章之前复习它们。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[http://bit.ly/2WvN2vp](http://bit.ly/2WvN2vp)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2WvN2vp](http://bit.ly/2WvN2vp)'
- en: An overview of the Factory Method
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法的概述
- en: The Factory pattern is one of those patterns whose name is a good indication
    of its core purpose. There's a robust real-world correlation that can help us
    visualize its intent – imagine yourself ordering a new car at a dealership. During
    this process, does the dealer inform you of the manufacturing process of your
    new vehicle? The answer is probably no; usually, the dealer sends your order to
    the factory, and then they ship the requested final product back to you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是那些其名称很好地说明了其核心目的的模式之一。有一个稳健的现实世界相关性可以帮助我们可视化其意图——想象一下你在经销商那里订购一辆新车。在这个过程中，经销商会告诉你新车的制造过程吗？答案很可能是不会；通常，经销商会将你的订单发送到工厂，然后他们把请求的最终产品运回给你。
- en: In other words, as the consumer of a product, you should focus on ordering and
    receiving, not manufacturing and distributing. And that's the primary goal of
    the Factory pattern; it simplifies the *order* process of specific types of objects
    by providing an interface that's abstract to the inner workings of the *manufacturing*
    process of the requested objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，作为产品的消费者，你应该专注于订购和接收，而不是制造和分销。这就是工厂模式的主要目标；它通过提供一个对请求对象制造过程的内部工作抽象的接口，简化了特定类型对象的*订购*过程。
- en: As we mentioned in the introduction, there are two main variations of the Factory,
    but in this chapter, we will review only the simplest form of this pattern, which
    is the Factory Method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在引言中提到的，工厂有两种主要的变化形式，但在这个章节中，我们将只回顾这种模式最简单的形式，即工厂方法。
- en: 'Let''s start by reviewing a UML diagram of a use case that''s using the Factory
    Method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一个使用工厂方法的用例的UML图：
- en: '![](img/071dc34a-e237-45b8-999d-cfea94e4589c.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/071dc34a-e237-45b8-999d-cfea94e4589c.png)'
- en: As we can see from this diagram, the `GetNPC()` method of the `NPCFactory` class
    is responsible for getting a specific type of NPC (**Beggar**, **Shopowner**,
    or **Farmer**). So, if a client requests a particular type of NPC, it needs to
    ask `NPCFactory` to produce it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从这张图中可以看出，`NPCFactory` 类的 `GetNPC()` 方法负责获取特定类型的NPC（**乞丐**、**店主**或**农民**）。因此，如果客户端请求特定类型的NPC，它需要请求`NPCFactory`来生产它。
- en: The core purpose of the Factory pattern is to abstract the creation and localize
    the creation process of a particular type of object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式的核心目的是抽象创建并局部化特定类型对象的创建过程。
- en: Benefits and drawbacks
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和缺点
- en: The Factory Method pattern has an excellent reputation and is often the cornerstone
    of a reliable code base. Let's have a look at a few of the benefits and drawbacks
    of the Factory Method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式享有极好的声誉，并且通常是可靠代码库的基石。让我们看看工厂方法的一些好处和缺点。
- en: 'These are the benefits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是好处：
- en: '**Loose coupling**: Because the client doesn''t need to know the details of
    the initialization process of a specific type of object, it reduces coupling and
    dependencies between classes'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松散耦合**：因为客户端不需要知道特定类型对象的初始化过程的细节，这减少了类之间的耦合和依赖。'
- en: '**Encapsulation of the creation process**: The fact that the Factory Method
    takes the responsibility of creating specific object types, you can localize complex
    initialization processes in a single class'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建过程的封装**：由于工厂方法负责创建特定类型的对象，你可以将复杂的初始化过程局部化在一个类中。'
- en: 'These are the drawbacks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是缺点：
- en: '**Extra code complexity**: Code becomes harder to read because you are adding
    abstraction and additional classes.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的代码复杂性**：由于你正在添加抽象和额外的类，代码变得难以阅读。'
- en: '**Open to interpretation**: Programmers often confuse the Factory Method and
    its cousin, the Abstract Factory. This issue might cause inconsistent implementations,
    which can provoke uncertainty and confusion between programmers working on the
    same code base.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放性解释**：程序员经常混淆工厂方法及其近亲抽象工厂。这个问题可能会导致不一致的实现，这可能会在同一个代码库上工作的程序员之间引起不确定性和混淆。'
- en: It's sometimes difficult to isolate recurrent drawbacks with a specific pattern
    because often it's a question of context. But a universal truth about design patterns
    is that they can become a regressive part of your architecture if you misapply
    them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时很难将反复出现的缺点与特定的模式隔离，因为这通常是一个关于上下文的问题。但关于设计模式的一个普遍真理是，如果你误用它们，它们可能会成为你架构中的退步部分。
- en: Use case example
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: Now that we have a basic understanding of the Factory Method, let's build a
    game system with it. To stay consistent with our previous chapter, we are going
    to implement another spawn system, but this time for NPCs. Because the Factory
    Method is a Creational pattern, it's a natural fit for a spawn system. As we are
    going to see in the following code example, the Factory Method is a perfect pattern
    to use when you need to centralize the initialization pipeline of various entities.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对工厂方法有了基本的了解，让我们用它来构建一个游戏系统。为了与之前的章节保持一致，我们将实现另一个生成系统，但这次是为NPC。因为工厂方法是一种创建型模式，它非常适合生成系统。正如我们将在下面的代码示例中看到的，工厂方法是在需要集中初始化各种实体初始化管道时使用的完美模式。
- en: In a professional game project, you might end up having to build separate spawn
    systems for different groups of entities. For example, in an open-world game,
    you might have a specific method to spawn civilians and one to generate cops because
    each primary type of AI character might have different requirements and loading
    processes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个专业的游戏项目中，你可能会不得不为不同实体组构建独立的出生系统。例如，在一个开放世界游戏中，你可能会有一个特定的方法来生成平民和警察，因为每种主要的AI角色可能有不同的要求和加载过程。
- en: Code example
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'As we mentioned before, the Factory Method is the most straightforward approach
    to implementing a Factory pattern. As its name implies, it primarily focuses on
    providing a standard interface for the creation of specific object types through
    a Factory Method. So, if we have a `Client` class that needs to initialize an
    object of a particular kind (also known as a **product**) but we don''t know the
    exact class or the process to call, instead, we merely refer to a Factory to produce
    the requested product and return it to us. Let''s follow these steps to get started
    with our example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，工厂方法是实现工厂模式最直接的方法。正如其名所示，它主要关注通过工厂方法提供创建特定对象类型的标准接口。因此，如果我们有一个`Client`类需要初始化特定类型的对象（也称为**产品**），但我们不知道确切的类或调用过程，我们只需引用工厂来生产所需的产品并将其返回给我们。让我们按照以下步骤开始我们的示例：
- en: 'Let''s build a simple spawn system for NPCs using the Factory Method as our
    base. But before we do that, we need to declare our general NPC type. The best
    way to do this in code is to have a standard interface for all our NPC characters.
    For reasons of simplicity, all of our NPCs entities will have a common functionality;
    they can speak scripted dialogue:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用工厂方法作为基础，为NPC构建一个简单的出生系统。但在我们这样做之前，我们需要声明我们的通用NPC类型。在代码中，最好的方法是为我们所有的NPC角色提供一个标准接口。出于简单性的考虑，我们所有的NPC实体都将具有一个共同的功能；它们可以说话脚本对话：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have a standard interface for NPCs called `INPC`, we need concrete
    classes for each type of NPC that we might want to spawn. We will limit ourselves
    to the typical characters we might find in a farming village in a classical RPG
    game:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`INPC`的标准NPC接口，我们需要为可能想要生成的每种NPC类型创建具体的类。我们将限制自己到在经典RPG游戏中的农场村庄中可能找到的典型角色：
- en: 'First is our `Beggar`, who begs for precious coins:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是我们的“乞丐”，他们乞求珍贵的硬币：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then there''s our `Shopowner`, who''s always ready to sell us some goods:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是我们的“店主”，他们总是准备好卖给我们一些商品：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we have our `Farmer`, with their words of wisdom:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有我们的“农夫”，他们有智慧的话语：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, now that we have concrete classes for each of our main NPC types, we need
    a way to refer to them when we need to. Let''s write a public `enum` that will
    be easily accessible. We will disclose a list of available NPC types:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们已经为我们的主要NPC类型创建了具体的类，我们需要一种方法在需要时引用它们。让我们编写一个公共的`enum`，它将易于访问。我们将公开一个可用的NPC类型列表：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to implement our `NPCFactory` class with a public Factory
    Method that will create the requested instance (product) of an NPC:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现我们的`NPCFactory`类，它有一个公共的工厂方法，将创建请求的NPC实例（产品）：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, our concrete implementation of the Factory Method is a function
    named `GetNPC()`, which is composed of a switch case that returns an `INPC` instance
    of a specified `NPCType`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的工厂方法的具体实现是一个名为`GetNPC()`的函数，它由一个返回指定`NPCType`的`INPC`实例的switch case组成。
- en: 'But the benefits of this design are evident in our client, which, in this example,
    will be our `NPCSpawner` class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但这种设计的优势在我们的客户端中很明显，在这个例子中，将是我们的`NPCSpawner`类：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can test this implementation of the Factory Method and the `NPCSpawner`
    with the following test class:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下测试类来测试工厂方法实现和`NPCSpawner`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are now able to spawn instances of a specific NPC without having to know
    the location or the exact name of its concrete class. It might not look impressive
    when dealing with just three basic types, but imagine if every type of NPC had
    a different initializing process with multiple dependencies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够生成特定NPC的实例，而无需知道其位置或具体类的确切名称。当只处理三种基本类型时，这可能看起来并不令人印象深刻，但想象一下，如果每种NPC类型都有不同的初始化过程和多个依赖项。
- en: For example, imagine a circumstance in which the `Beggar` NPC is not a character
    but a behavior component that can be attached to any civilian character in our
    scene, while the `Farmer` NPC type is a self-contained prefab. With a Factory
    Method, we don't have to keep in mind all of these specifications every time we
    want to spawn a specific NPC; instead, we let the Factory Method do the dirty
    work for us and decide the best way to create those particular entities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个场景，其中“乞丐”NPC不是一个角色，而是一个可以附加到我们场景中任何平民角色上的行为组件，而“农夫”NPC类型是一个自包含的预制件。使用工厂方法，我们不必每次想要生成特定的NPC时都记住所有这些规范；相反，我们让工厂方法为我们做脏活，并决定创建这些特定实体的最佳方式。
- en: Choosing between using an abstract or an interface when implementing a common
    parent for a specific family of objects can be daunting. In this example, I decided
    to go with an interface because I didn't want to share implementations – I wanted
    to declare a group type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现特定对象家族的通用父类时，在抽象和接口之间进行选择可能会让人感到困惑。在这个例子中，我决定选择接口，因为我不想共享实现——我想声明一个类型组。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to the core principles of the Factory pattern
    and implemented its first variation, the Factory Method. With this pattern, we
    can localize the creation process of types of objects. This might be fine and
    dandy, but what happens if we want complex products that combine various kinds
    of objects each with their specific creation method? Are we going to need to know
    and call each factory separately and assemble them manually?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了工厂模式的核心原则，并实现了其第一种变体，即工厂方法。使用这种模式，我们可以本地化对象的类型创建过程。这可能很好，但如果我们想要复杂的产品，这些产品结合了各种类型的对象，每种对象都有其特定的创建方法呢？我们是否需要分别了解和调用每个工厂，并手动组装它们？
- en: This issue is what we are going to solve in the next chapter by implementing
    a more advanced version of the Factory pattern; the **Abstract Factory**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现工厂模式的更高级版本——**抽象工厂**来解决这个问题的。
- en: When you analyze the usefulness of a design pattern, always keep in mind that
    they are designed for teamwork. The Factory is a perfect example of this. As a
    solo developer, you might find most design patterns redundant, but imagine yourself
    working on a massive code base with dozens of programmers. In that case, layers
    of abstractions and common interfaces can help you maintain your sanity as your
    team and code base grows.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分析设计模式的有用性时，始终记住它们是为团队合作而设计的。工厂是一个完美的例子。作为一个独立开发者，你可能会发现大多数设计模式都是多余的，但想象一下你在一个大型的代码库上工作，有几十个程序员。在这种情况下，抽象层和通用接口可以帮助你在团队和代码库增长时保持理智。
- en: Practice
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践
- en: In the previous chapter, we learned how to design a spawn system by using the
    Prototype pattern as our base. Due to this, our system behaved basically like
    a Xerox machine; it made copies of existing instances. This mechanism reduced
    the initialization overhead, but this was only beneficial if we already had a
    reference in memory to copy.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用原型模式作为基础来设计生成系统。因此，我们的系统基本上就像一台复印机；它复制现有的实例。这种机制减少了初始化开销，但这只有在内存中已经有引用可以复制的情况下才有益。
- en: But now, we have the Factory Method in our toolkit; we can localize the process
    of creating new objects of certain types. What would be interesting to try is
    combining both. Could you have the Factory Method check if an instance of that
    type of object already exists in memory?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们的工具箱中已经有了工厂方法；我们可以将创建特定类型新对象的过程本地化。有趣的是尝试将两者结合起来。工厂方法能否检查该类型对象在内存中是否已经存在一个实例？
- en: Combining patterns is a good exercise and will give you a broader range of approaches
    to complex implementations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结合模式是一个很好的练习，这将为你提供更广泛的方法来处理复杂的实现。
- en: Further reading
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Programming Patterns* by Robert Nystrom: [http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*游戏编程模式*》由Robert Nystrom所著：[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    John Vlissides, Ralph Johnson, and Richard Helm: [http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计模式：可复用面向对象软件元素*》由Erich Gamma、John Vlissides、Ralph Johnson和Richard Helm所著：[http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)
