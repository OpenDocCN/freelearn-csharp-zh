- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Serverless – Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 10*, *Deciding on the Best Cloud-Based Solution*, we explored the
    fundamentals and strategic advantages of different cloud architectures and serverless
    can be considered one of the newest ways to provide flexible cloud-based solutions.
    We delved into how serverless systems offer scalability, cost-efficiency, and
    agility – key factors that drive today’s software architecture decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on that foundation, this chapter delves deeper into a pivotal component
    of serverless architecture: Azure Functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions stands out as the component that Microsoft delivers as a prime
    example of serverless architecture in action. It offers a versatile, event-driven
    approach that integrates seamlessly with the .NET ecosystem, making it the for
    architects and developers aiming to build efficient, scalable, and responsive
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will navigate through the intricacies of Azure Functions, emphasizing their
    application in complex enterprise environments. This chapter will arm you with
    practical insights into leveraging Azure Functions for robust application architecture,
    discussing best practices, design patterns, and advanced features specific to
    the .NET stack.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a comprehensive understanding of Azure Functions, focusing
    on enhancing your technical mastery of this platform. We delve into the specifics
    of Azure Functions, covering its setup, programming using C#, and various hosting
    plans like the Consumption, Premium, and App Service plans. By the end of this
    chapter, you will have a thorough understanding of Azure Functions, equipped with
    the knowledge to deploy, maintain, and optimize its functions effectively in your
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Azure Functions app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Azure Functions using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to use Azure Functions in
    C# to speed up your development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The free Visual Studio 2022 Community Edition or, even better, with all the
    Azure tools installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* section of *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Azure Functions app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Azure Functions app is an Azure **PaaS** (**platform as a service**) where
    you can build pieces of code (functions), connect them to your application, and
    use triggers to start them. The concept is quite simple – you build a function
    in the language you prefer and decide on the trigger that will start it. You can
    write as many functions as you want in your system. There are cases where the
    system is written entirely with functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to create the necessary environment are as simple as the ones we
    need to follow to create the function itself. The following screenshot shows the
    parameters that you must decide on when you create the environment. After you
    select **Create a resource** in Azure and filter by **Function App**, upon clicking
    the **Create** button, you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Creating an Azure function app'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of key points that you should consider while creating your
    Azure Functions environment. The possibilities given for running functions increase
    from time to time, as do the programming language options and publishing styles.
    One of the most important configurations we have is the hosting plan, which is
    where you will run your functions. There are three options for the hosting plan:
    a Consumption (Serverless), Premium, and App Service plan. Let’s talk about them.'
  prefs: []
  type: TYPE_NORMAL
- en: Consumption plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you choose a Consumption plan, your functions will only consume resources
    when they are executed. This means that you will only be charged while your functions
    are running. Scalability and memory resources will be automatically managed by
    Azure. This is truly what we call serverless.
  prefs: []
  type: TYPE_NORMAL
- en: Something we need to take note of while writing functions in this plan is the
    timeout. By default, after 5 minutes, the function will time out. You can change
    the timeout value using the `functionTimeout` parameter in the `host.json` file.
    The maximum value is 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: When you choose the Consumption plan, how you will be charged will depend on
    what you are executing, the execution time, and memory usage. More information
    on this can be found at [https://azure.microsoft.com/en-us/pricing/details/functions/](https://azure.microsoft.com/en-us/pricing/details/functions/).
  prefs: []
  type: TYPE_NORMAL
- en: Note that this can be a good option when you do not have app services in your
    environment, and you are running functions with low periodicity. On the other
    hand, if you need continuous processing, you may want to consider using a Premium
    plan or an App Service plan. Let’s have a look at them below.
  prefs: []
  type: TYPE_NORMAL
- en: Premium plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on what you use your functions for, especially if they need to run
    continuously or almost continuously, or if some function executions take longer
    than 10 minutes, you may want to consider a Premium plan. Besides, you may need
    to connect your function to a VNET/VPN environment, and in this case, you will
    be forced to run in this plan.
  prefs: []
  type: TYPE_NORMAL
- en: You may also need more CPU or memory options than what is provided with the
    Consumption plan. The Premium plan gives you one-core, two-core, and four-core
    instance options.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that even with unlimited time to run your function if
    you decide to use an HTTP trigger function, 230 seconds is the maximum allowed
    for responding to a request. The reason this is a limit is related to the default
    idle timeout value of Azure Load Balancer.
  prefs: []
  type: TYPE_NORMAL
- en: You may have to redesign your solution in such situations to adhere to the best
    practices set by Microsoft ([https://docs.microsoft.com/en-us/azure/azure-functions/functions-best-practices](https://docs.microsoft.com/en-us/azure/azure-functions/functions-best-practices)).
  prefs: []
  type: TYPE_NORMAL
- en: Although the Premium plan is a great alternative, if you want to optimize the
    usage of your App Services instances, the best option is the App Service plan.
    Let’s have a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: The App Service plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The App Service plan is one of the options you can choose when you want to
    create an Azure Functions app. Here are a couple of reasons (suggested by Microsoft)
    why you should use the App Service plan instead of the Consumption plan to maintain
    your functions:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use underutilized existing App Service instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run your function app on a custom image if you want to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the App Service plan scenario, the `functionTimeout` value varies according
    to the Azure Functions runtime version. However, the value needs to be at least
    30 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a tabled comparison between the timeouts in each Consumption plan
    at [https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale#timeout](https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale#timeout).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a foundational understanding of the Azure Functions app and
    its role in serverless architecture, let’s explore how to bring these concepts
    into action. In the following section, we’ll dive into programming Azure Functions
    using C#, turning theoretical knowledge into practical application.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Azure Functions using C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to create Azure Functions. It is worth mentioning
    that there are several ways to create them using C#. The first one is by creating
    the functions and developing them in the Azure portal itself. To do this, let
    us assume that you have created an Azure Functions app with similar configurations
    to the ones in the screenshot at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting the resource created and navigating to the **Functions** menu,
    you will be able to add new functions to this environment, as you can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Adding a function'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will need to decide the kind of trigger that you want to use to start
    the execution. The most frequently used ones are the **HTTP trigger** and the
    **Timer trigger**. The first enables the creation of an HTTP API that will trigger
    the function. The second means functions will be triggered by a timer you set.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you decide on the trigger you want to use, you must name the function.
    Depending on the trigger you decide on, you will have to set up some parameters.
    For instance, an **HTTP trigger** requires that you set up an authorization level.
    Three options are available: **Function**, **Anonymous**, and **Admin**. The **Function**
    option requires a specific key to access each HTTP trigger, while **Anonymous**
    does not require anything. For the **Admin** option, the key used is the master
    one, which is created together with the function app.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interface gráfica do usuário, Texto, Aplicativo  Descrição gerada automaticamente](img/B19820_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Configuring an HTTP function'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that this book does not cover all the options that are
    available when it comes to building functions. As a software architect, you should
    understand that Azure provides a good service for serverless architectures in
    terms of functions. This can be useful in several situations. This was discussed
    in more detail in *Chapter 10*, *Deciding on the Best Cloud-Based Solution*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this is as follows. Notice that Azure provides an editor that
    allows us to run the code, check logs, and test the function that we have created.
    This is a good interface for testing and coding basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: HTTP function environment'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want to create more sophisticated functions, you may need a
    more sophisticated environment so that you can code and debug them more efficaciously.
    This is where the Visual Studio Azure Functions project can help you. Besides,
    using Visual Studio to execute the development of the function moves you in the
    direction of using source control and CI/CD for your functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio, you can create a project dedicated to Azure Functions by
    going to **Create a new project**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Texto  Descrição gerada automaticamente](img/B19820_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Creating an Azure Functions project in Visual Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your project, Visual Studio will ask you for the type
    of triggers you are using and for the Azure version that your function will run
    on. It is worth mentioning that, for some scenarios, a storage account is required
    while creating the function app, such as managing triggers and logging executions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Creating a new Azure Functions application'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that Azure Functions supports different platforms and
    programming languages. At the time of writing, there are two available runtime
    versions of Azure Functions with support provided. The first version (v1) is compatible
    with .NET Framework 4.8\. The v2 and v3 versions are not supported anymore, so
    for .NET 8, you shall use version 4 (v4).
  prefs: []
  type: TYPE_NORMAL
- en: You can always check for up-to-date information about it at [https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions](https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions).
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must keep code reusability in mind. In this case,
    you should pay attention to which version of Azure Functions you decide to build
    your functions in. However, it is always recommended that you use the latest version
    of the runtime as soon as it acquires general availability status.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the code that is generated is similar to that generated when you
    create Azure Functions in the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since you have understood the basis for creating Azure Functions using C#, it
    is also important to understand the number of triggers that are available as templates
    for Azure Functions. Let’s have a look at that.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Azure Functions templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several templates in the Azure portal that you can use to create
    Azure Functions. The number of templates that you can choose from is updated continuously.
    The following are just a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blob Trigger**: You may want to process something for a file as soon as the
    file is uploaded to your blob storage. This can be a good use case for Azure Functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cosmos DB Trigger**: You may want to synchronize data that arrives in a Cosmos
    DB database with a processing method. Cosmos DB was discussed in detail in *Chapter
    12*, *Choosing Your Data Storage in the Cloud*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Grid Trigger**: This is a good way to manage Azure events. Functions
    can be triggered so that they manage each event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Hub Trigger**: With this trigger, you can build functions that are
    linked to any system that sends data to Azure Event Hubs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Trigger**: This trigger is useful for building serverless APIs and web
    app events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IoT Hub Trigger**: When your application is connected to devices using IoT
    Hub, you can use this trigger whenever a new event is received by one of the devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue Trigger**: You can handle queue processing using a function-as-a-service
    solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Bus Queue Trigger**: This is another messaging service that can be
    a trigger for functions. Azure Service Bus was covered in more detail in *Chapter
    11*, *Applying a Microservice Architecture to Your Enterprise Application*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timer Trigger**: This is commonly used with functions and is where you specify
    time triggers so that you can continuously process data from your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the complete list of triggers and bindings available for Azure
    Functions at [https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings).
  prefs: []
  type: TYPE_NORMAL
- en: With a solid understanding of how to program Azure Functions in C#, let’s now
    ensure their longevity and performance. In the upcoming section, we will uncover
    the best practices and tools necessary for the effective management and monitoring
    of your serverless architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created and programmed your function, you need to monitor and
    maintain it. To do this, you can use a variety of tools, all of which you can
    find in the Azure portal. These tools will help you solve problems due to the
    amount of information you will be able to collect with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option when it comes to monitoring your function is using the **Monitor**
    menu inside the Azure Functions interface in the Azure portal. There, you will
    be able to check all your function executions, including successful results and
    failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Monitoring a function'
  prefs: []
  type: TYPE_NORMAL
- en: It will take about 5 minutes for any results to be available. The date shown
    in the grid is in UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on **Run query in Application Insights**, the same interface allows
    you to connect to this tool. This will take you to a world of almost infinite
    options that you can use to analyze your function data. Application Insights is
    an excellent option for **Application Performance Management** (**APM**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Monitoring using Application Insights'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the query interface, you can also check all the performance issues of
    your function using the Application Insights interface in the Azure portal. There,
    you can analyze and filter all the requests that have been received by your solution
    and check their performance and dependencies. You can also trigger alerts when
    something abnormal happens to one of your endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this resource in the Azure portal by selecting your function resource
    and searching for **Application Insights**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_16_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Monitoring using Application Insights live metrics'
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you will find a good daily helper for your projects
    in this tool. Please remember that Application Insights works on several other
    Azure services, such as Web Apps and Virtual Machines. This means that you can
    monitor the health of your system and maintain it using the wonderful features
    provided by Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Durable Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you decide to delve deeper into the usage of serverless, you may consider
    Azure Durable Functions as a good option for designing orchestration scenarios.
    Azure Durable Functions let us write stateful workflows, managing the state behind
    the scenes. To do so, you will have to write an **orchestrator function**, which
    is basically a procedure that defines the workflow that you want to run. You may
    also need some **entity functions** to enable the reading of small pieces of state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some application patterns where this solution can be used;
    however, it is important to remember that it is not suitable for all applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function chaining**: When you need to execute a sequence of functions in
    a particular order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Async HTTP APIs**: A good way to solve long-running operations with external
    clients, where you will have the opportunity to get a status API because of the
    orchestrator function. There is a sample code of this pattern as soon as you create
    an orchestrator function in Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fan-out/fan-in**: The ability to run multiple functions in parallel and wait
    for them to finish to conclude work in an aggregate function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitors**: A way to monitor a process without using a timer trigger, enabling
    configured intervals to monitor many instances of a process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Human interaction**: A way to automate a process even when you need human
    interaction, but you need to monitor the response after a period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregator**: A way to address event data over a period into a single entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to pricing, we should keep in mind that Azure Durable Functions
    are billed the same way common Azure Functions are. The only concern you must
    consider is that orchestrator functions might replay several times throughout
    the lifetime of an orchestration, and you will be billed for each replay.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have covered the possibilities presented by Azure Durable Functions,
    it is also important to evaluate the roadmap of Azure Functions. The reason why
    we keep writing about this arises from the changes Azure Functions has suffered
    since its creation. Considering that a serverless application based on Azure Functions
    can be the kernel of your solution, this is a very important topic that needs
    to be discussed. Let’s check it out now.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of Azure Functions has changed since it was rolled out in 2016\.
    The number of people using the tool and the changes related to .NET caused some
    compatibility problems that saw Microsoft come up with a new way of delivering
    the deployment of functions. This new way is called the isolated process model,
    and it has been available since .NET 5\. It is also important to mention that
    the currently supported available runtime versions for Azure Functions are v1
    and v4\.
  prefs: []
  type: TYPE_NORMAL
- en: According to the current roadmap, using the isolated process model is the only
    way to run Azure Functions in .NET 8 and future versions. There is a plan to have
    the in-process model for .NET 8, but no date has been confirmed yet.
  prefs: []
  type: TYPE_NORMAL
- en: '![thumbnail image 1 captioned A diagram showing the change in release patterns
    after parity. .NET 8 has an in-process model option on a delay after the isolated
    worker model. All subsequent updates use the isolated worker model.](img/B19820_16_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Azure Functions roadmap'
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must keep an eye on the roadmaps provided so that
    you can decide on the best implementation for your solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing an Azure function using the isolated process model, you will
    have access to the startup of the function in a `Program.cs` file. This means
    that you will have to configure and create the instance of your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that to do so, you will need `Microsoft.Azure.Functions.Worker.Extensions`
    packages. You can find a very good guide to doing this at [https://docs.microsoft.com/en-us/azure/azure-functions/dotnet-isolated-process-guide](https://docs.microsoft.com/en-us/azure/azure-functions/dotnet-isolated-process-guide).
  prefs: []
  type: TYPE_NORMAL
- en: The decision to use serverless and Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with the benefits presented during this chapter, there is always a question
    about why one would use a serverless function over having it as part of a bigger
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: If you think exclusively about HTTP Trigger functions, this question is more
    difficult to answer because you can create a Web API application that generally
    solves the problems in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some use cases where an Azure Function is truly the best
    option. Let’s list them to help you with this decision in your scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When you need to execute a periodic task**: Azure Functions with *Timer Trigger*
    is, for sure, a great option. Using Cron expressions, you will be able to set
    different periods to have your function running. You can check out more details
    at [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When you want to execute a task after some data changes**: By using triggers
    like *Blob Trigger*, *Queue Trigger*, or *CosmosDB Trigger*, you can monitor data
    changes and subsequently execute a specific task in response to these changes,
    which may be useful in some scenarios. There is a great example of how to use
    it at [https://learn.microsoft.com/en-us/azure/azure-functions/functions-create-cosmos-db-triggered-function](https://learn.microsoft.com/en-us/azure/azure-functions/functions-create-cosmos-db-triggered-function).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When you want to execute a task after some event happens on devices or another
    system**: Again, without needing to pool data, you can use *Event Grid Trigger*,
    *Event Hub Trigger*, *IoT Hub Trigger*, or *Service Bus Queue Trigger* to track
    an event and start a task with the information provided by it. You can check out
    more information about it at [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-hubs-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-hubs-trigger).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make this decision easier, in *Chapter 21*, *Case Study*, you will find the
    complete tutorial to implement the architecture presented below.
  prefs: []
  type: TYPE_NORMAL
- en: To give users a great experience, all the emails that are sent by the application
    will be queued asynchronously, thereby preventing significant delays in the system’s
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19820_16_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Architectural design for sending emails'
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about this design is that although you have a solution with
    different components, you cannot recognize some computational characteristics,
    like the amount of memory used, the number of CPUs designed for this process,
    or even the storage needed to guarantee the solution quality. This is what we
    call serverless in its essential meaning – a solution where the focus is not on
    where the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the advantages of developing functionality
    with serverless Azure Functions. You can use it as a guideline to check the different
    types of triggers that are available in Azure Functions and to plan how to monitor
    them. We also saw how to program and maintain Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the current news related to ASP.NET Core
    MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the programming options for Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the plans that can be used with Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you deploy Azure Functions with Visual Studio?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What triggers can you use to develop Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between Azure Functions v1, v2, v3, and v4?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Application Insights help us to maintain and monitor Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Azure Durable Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to learn more about creating Azure functions, check out the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Functions scale and hosting: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale](https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microsoft Azure For .NET Developers [Video], by Trevoir Williams:* [https://www.packtpub.com/product/microsoft-azure-for-net-developers-video/9781835465059](https://www.packtpub.com/product/microsoft-azure-for-net-developers-video/9781835465059)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure Serverless Computing Cookbook - Third Edition, by Praveen Kumar Sreeram:*
    [https://www.packtpub.com/product/azure-serverless-computing-cookbook-third-edition/9781800206601](https://www.packtpub.com/product/azure-serverless-computing-cookbook-third-edition/9781800206601)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions runtime overview: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-versions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-versions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An overview of Azure Event Grid: [https://docs.microsoft.com/en-us/azure/event-grid/](https://docs.microsoft.com/en-us/azure/event-grid/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timer trigger for Azure Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *Application Insights* section of the book *Azure for Architects*, by Ritesh
    Modi: [https://subscription.packtpub.com/book/virtualization_and_cloud/9781788397391/12/ch12lvl1sec95/application-insights](https://subscription.packtpub.com/book/virtualization_and_cloud/9781788397391/12/ch12lvl1sec95/application-insights
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *Monitoring Azure Functions using the Application Insights* section of
    the book *Azure Serverless Computing Cookbook*, by Praveen Kumar Sreeram: [https://subscription.packtpub.com/book/virtualization_and_cloud/9781788390828/6/06lvl1sec34/monitoring-azure-functions-using-application-insights](https://subscription.packtpub.com/book/virtualization_and_cloud/9781788390828/6/06lvl1sec34/monitoring-azure-functions-using-application-insights)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get started with Azure Queue storage using .NET: [https://docs.microsoft.com/en-us/azure/storage/queues/storage-dotnet-how-to-use-queues](https://docs.microsoft.com/en-us/azure/storage/queues/storage-dotnet-how-to-use-queues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions triggers and bindings concepts: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Queue Storage bindings for Azure Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure emulator for local Azure Storage Development: [https://docs.microsoft.com/en-us/azure/storage/common/storage-use-azurite](https://docs.microsoft.com/en-us/azure/storage/common/storage-use-azurite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Durable Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/durable/](https://docs.microsoft.com/en-us/azure/azure-functions/durable/   )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
