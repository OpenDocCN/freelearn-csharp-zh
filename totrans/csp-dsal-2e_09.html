<html><head></head><body>
<div id="_idContainer121">
<h1 class="chapter-number" id="_idParaDest-168"><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-169"><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.2.1">See in Action</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As you already know, algorithms are almost everywhere, and there are many types and classifications. </span><span class="koboSpan" id="kobo.3.2">They are supported by numerous data structures and some of them you learned while reading the previous chapters. </span><span class="koboSpan" id="kobo.3.3">After some theoretical parts, it is high time to keep on practicing, based on interesting examples. </span><span class="koboSpan" id="kobo.3.4">They are chosen from various types of algorithms, summarizing many subjects that you have got </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to know.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">First, you will see how to calculate a given number from the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Fibonacci series</span></strong><span class="koboSpan" id="kobo.7.1"> in a few variants that differ significantly in performance results, so you will get to know how you can optimize your code. </span><span class="koboSpan" id="kobo.7.2">Sometimes, even small changes can lead to huge performance improvements. </span><span class="koboSpan" id="kobo.7.3">Then, you will learn how to apply the greedy approach to solve the </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">minimum coin change</span></strong><span class="koboSpan" id="kobo.9.1"> problem, as well as how to benefit from the divide-and-conquer algorithm to find the </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">closest pair of points</span></strong><span class="koboSpan" id="kobo.11.1"> located on the two-dimensional surface. </span><span class="koboSpan" id="kobo.11.2">You will also see a beautiful </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">fractal</span></strong><span class="koboSpan" id="kobo.13.1"> and the code that designs such graphics. </span><span class="koboSpan" id="kobo.13.2">The following examples will be related to applications of back-tracking with recursion to solve puzzles, namely </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">rat in a maze</span></strong><span class="koboSpan" id="kobo.15.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Sudoku</span></strong><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">Coming closer to the end of the chapter, you will see how to apply a genetic algorithm to </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">guess a title</span></strong><span class="koboSpan" id="kobo.19.1"> of this book, based on the rules of Darwinian theory of evolution and natural selection. </span><span class="koboSpan" id="kobo.19.2">The last example will be a brute-force algorithm for </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">guessing a </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.21.1">secret password</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">As you can see, there are a lot of interesting examples just ahead of you, so be ready to write quite a lot of code and solve these tasks together. </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Let’s start!</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">In this chapter, you will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Fibonacci series</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Minimum </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">coin change</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">The closest pair </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">of points</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Fractal generation</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Rat in </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">a maze</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">Sudoku puzzle</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">title guess</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">password guess</span></span></li>
</ul>
<h1 id="_idParaDest-170"><a id="_idTextAnchor369"/><span class="koboSpan" id="kobo.42.1">The Fibonacci series</span></h1>
<p><span class="koboSpan" id="kobo.43.1">As the first example, let’s take </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.44.1">a look at calculating a given number from the </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">Fibonacci series</span></strong><span class="koboSpan" id="kobo.46.1">, using the following </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.47.1">recursive</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1"> function:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.49.1"><img alt="Figure 9.1 – A formula for calculating a number from the Fibonacci series" src="image/B18069_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.50.1">Figure 9.1 – A formula for calculating a number from the Fibonacci series</span></p>
<p><span class="koboSpan" id="kobo.51.1">Its interpretation is </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">very simple:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.53.1">F(0)</span></em><span class="koboSpan" id="kobo.54.1"> is equal </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">to 0</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.56.1">F(1)</span></em><span class="koboSpan" id="kobo.57.1"> is equal </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">to 1</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.59.1">F(n)</span></em><span class="koboSpan" id="kobo.60.1"> is a sum of </span><em class="italic"><span class="koboSpan" id="kobo.61.1">F(n-1)</span></em><span class="koboSpan" id="kobo.62.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.63.1">F(n-2)</span></em><span class="koboSpan" id="kobo.64.1">, which means that this number is a sum of the two </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">preceding ones</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.66.1">As an example, </span><em class="italic"><span class="koboSpan" id="kobo.67.1">F(2)</span></em><span class="koboSpan" id="kobo.68.1"> is equal to the sum of </span><em class="italic"><span class="koboSpan" id="kobo.69.1">F(0)</span></em><span class="koboSpan" id="kobo.70.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.71.1">F(1)</span></em><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">Thus, it is equal to 1, while </span><em class="italic"><span class="koboSpan" id="kobo.73.1">F(3)</span></em><span class="koboSpan" id="kobo.74.1"> is equal to 2. </span><span class="koboSpan" id="kobo.74.2">It is worth mentioning that there are two base cases, namely for </span><em class="italic"><span class="koboSpan" id="kobo.75.1">n</span></em><span class="koboSpan" id="kobo.76.1"> equal to 0 and 1. </span><span class="koboSpan" id="kobo.76.2">For both of them, there is a specific value defined, namely 0 </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">and 1.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">recursive</span></strong><span class="koboSpan" id="kobo.80.1"> implementation in the C# language is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
long </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">Fibonacci</span></strong><span class="koboSpan" id="kobo.84.1">(int n)
{
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    return </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">Fibonacci(n - 1)</span></strong><span class="koboSpan" id="kobo.86.1"> + </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">Fibonacci(n - 2)</span></strong><span class="koboSpan" id="kobo.88.1">;
}</span></pre> <p><span class="koboSpan" id="kobo.89.1">As you see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Fibonacci</span></strong><span class="koboSpan" id="kobo.91.1"> method calls itself twice with different values of parameters, namely smaller by 1 and 2 than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">n</span></strong><span class="koboSpan" id="kobo.93.1"> parameter passed to the method. </span><span class="koboSpan" id="kobo.93.2">If you call the method passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">25,</span></strong><span class="koboSpan" id="kobo.95.1"> you will receive 75025 as a result, </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.97.1">
long result = Fibonacci(25);</span></pre> <p><span class="koboSpan" id="kobo.98.1">Keep in mind that the presented recursive version for calculating a value of the Fibonacci function is very inefficient and will be very slow for larger </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">input numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">You can significantly </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.101.1">improve its performance using </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">dynamic programming</span></strong><span class="koboSpan" id="kobo.103.1">, either with top-down or</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.104.1"> bottom-up approaches. </span><span class="koboSpan" id="kobo.104.2">First, let’s use the </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">top-down approach</span></strong><span class="koboSpan" id="kobo.106.1"> with </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">memoization</span></strong><span class="koboSpan" id="kobo.108.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">cache the calculated results</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.110.1">for subproblems:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.111.1">Dictionary&lt;int, long&gt; cache = [];</span></strong><span class="koboSpan" id="kobo.112.1">
long </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">Fibonacci</span></strong><span class="koboSpan" id="kobo.114.1">(int n)
{
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">if (cache.ContainsKey(n)) { return cache[n]; }</span></strong><span class="koboSpan" id="kobo.116.1">
    long result = Fibonacci(n - 1) + Fibonacci(n - 2);
    </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">cache[n] = result;</span></strong><span class="koboSpan" id="kobo.118.1">
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.119.1">You use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Dictionary</span></strong><span class="koboSpan" id="kobo.121.1"> class as a cache, where keys are values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">n</span></strong><span class="koboSpan" id="kobo.123.1"> passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Fibonacci</span></strong><span class="koboSpan" id="kobo.125.1"> method and values are the calculated results, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Fibonacci(n)</span></strong><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">Within the method, you add the check on whether the cache contains a key equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">n</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">If so, you do not perform further operations and simply return the value from the cache. </span><span class="koboSpan" id="kobo.129.3">If the cache does not have such a key yet, you use the same approach as in the case of the recursive version and add the calculated result to the cache just before returning </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Is it worth introducing such changes? </span><span class="koboSpan" id="kobo.131.2">Let’s see some numbers regarding execution time for the 50</span><span class="superscript"><span class="koboSpan" id="kobo.132.1">th</span></span><span class="koboSpan" id="kobo.133.1"> number from the Fibonacci series. </span><span class="koboSpan" id="kobo.133.2">In the basic recursive version, it took more than 88 seconds on my </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.134.1">machine. </span><span class="koboSpan" id="kobo.134.2">Introducing the top-down approach caused the same result received in... </span><span class="koboSpan" id="kobo.134.3">less than 1 millisecond. </span><span class="koboSpan" id="kobo.134.4">This solution is almost 100,000 </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">times faster!</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">Now you know that dynamic programming can make a huge difference, let’s take a look at the </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">bottom-up approach</span></strong><span class="koboSpan" id="kobo.138.1"> for the Fibonacci </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">number calculation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
long </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Fibonacci</span></strong><span class="koboSpan" id="kobo.142.1">(int n)
{
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">long a = 0;</span></strong><span class="koboSpan" id="kobo.144.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">long b = 1;</span></strong><span class="koboSpan" id="kobo.146.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">for (int i = 2; i &lt;= n; i++)</span></strong><span class="koboSpan" id="kobo.148.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">{</span></strong><span class="koboSpan" id="kobo.150.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">long result = a + b;</span></strong><span class="koboSpan" id="kobo.152.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">a = b;</span></strong><span class="koboSpan" id="kobo.154.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">b = result;</span></strong><span class="koboSpan" id="kobo.156.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">}</span></strong><span class="koboSpan" id="kobo.158.1">
    return b;
}</span></pre> <p><span class="koboSpan" id="kobo.159.1">Here, a bigger modification is introduced because you replace recursion with iteration. </span><span class="koboSpan" id="kobo.159.2">However, the code is very simple, as it consists of only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">for</span></strong><span class="koboSpan" id="kobo.161.1"> loop that iterates from 2 until the given number and calculates the sum of the two preceding values. </span><span class="koboSpan" id="kobo.161.2">Of course, there are separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">if</span></strong><span class="koboSpan" id="kobo.163.1"> conditions for the 0 and 1 values of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">n</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">And what about the performance in this case? </span><span class="koboSpan" id="kobo.166.2">Let’s compare calculating the 5,000</span><span class="superscript"><span class="koboSpan" id="kobo.167.1">th</span></span><span class="koboSpan" id="kobo.168.1"> number from the Fibonacci series using both the top-down and bottom-down approaches. </span><span class="koboSpan" id="kobo.168.2">The top-down approach requires about 2 milliseconds, while the bottom-up still takes less than 1 millisecond</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.169.1"> on my laptop. </span><span class="koboSpan" id="kobo.169.2">Keep in mind that we are now talking about the 5,000</span><span class="superscript"><span class="koboSpan" id="kobo.170.1">th</span></span><span class="koboSpan" id="kobo.171.1"> number from the Fibonacci series, and previously, the tests were made for only the 50</span><span class="superscript"><span class="koboSpan" id="kobo.172.1">th</span></span><span class="koboSpan" id="kobo.173.1"> number. </span><span class="koboSpan" id="kobo.173.2">Incredible performance boost, </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">isn’t it?</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.175.1">Results can differ</span></p>
<p class="callout"><span class="koboSpan" id="kobo.176.1">The performance results are obtained on my computer and are calculated in a very simple way, even without repeating them several times. </span><span class="koboSpan" id="kobo.176.2">Of course, such results can be different in other circumstances, such as while using your machine. </span><span class="koboSpan" id="kobo.176.3">However, it is crucial to present some trend, not a precise result in milliseconds. </span><span class="koboSpan" id="kobo.176.4">This performance testing aims to show you a huge difference between a basic recursive version and any of the optimized versions with </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">dynamic programming.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">After the first example, let’s proceed to solving the minimum coin </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">change problem.</span></span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.180.1">Minimum coin change</span></h1>
<p><span class="koboSpan" id="kobo.181.1">The second example shown in this chapter presents a </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">greedy algorithm</span></strong><span class="koboSpan" id="kobo.183.1"> to solve the </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">minimum coin change</span></strong><span class="koboSpan" id="kobo.185.1"> problem, for </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.186.1">finding the minimum number of coins to receive the amount specified as </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">the input.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 9.2 – ﻿Illustration of denominations in the case of the euro currency" src="image/B18069_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 9.2 – Illustration of denominations in the case of the euro currency</span></p>
<p><span class="koboSpan" id="kobo.190.1">For example, for the coin system consisting of 1, 2, 5, 10, 20, 50, 100, 200, and 500 denominations, if you want to get a value of 158, you need to pick 5 coins, namely 100, 50, 5, 2, and 1. </span><span class="koboSpan" id="kobo.190.2">The greedy approach is very simple because you just </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">pick the largest possible denomination not greater than the remaining amount</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">You perform this operation until the remaining amount is equal to 0. </span><span class="koboSpan" id="kobo.192.3">As you see, the algorithm does not care about the overall solution </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.193.1">and tries to choose the best solution at </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">each step.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">The C#-based implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
int[] den = [1, 2, 5, 10, 20, 50, 100, 200, 500];
List&lt;int&gt; coins = GetCoins(158);
coins.ForEach(Console.WriteLine);
List&lt;int&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">GetCoins</span></strong><span class="koboSpan" id="kobo.199.1">(int amount)
{
    List&lt;int&gt; coins = [];
    </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">for (int i = den.Length - 1; i &gt;= 0; i--)</span></strong><span class="koboSpan" id="kobo.201.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">{</span></strong><span class="koboSpan" id="kobo.203.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">while (amount &gt;= den[i])</span></strong><span class="koboSpan" id="kobo.205.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">{</span></strong><span class="koboSpan" id="kobo.207.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">amount -= den[i];</span></strong><span class="koboSpan" id="kobo.209.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">coins.Add(den[i]);</span></strong><span class="koboSpan" id="kobo.211.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">}</span></strong><span class="koboSpan" id="kobo.213.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">}</span></strong><span class="koboSpan" id="kobo.215.1">
    return coins;
}</span></pre> <p><span class="koboSpan" id="kobo.216.1">The most important role is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">GetCoins</span></strong><span class="koboSpan" id="kobo.218.1"> method, which takes one input, namely the amount to get. </span><span class="koboSpan" id="kobo.218.2">It returns a list of chosen coins. </span><span class="koboSpan" id="kobo.218.3">For example, if you call this method passing 158, you will see 100, 50, 5, 2, and 1 in </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">That’s a quick example! </span><span class="koboSpan" id="kobo.220.2">Now, let’s proceed to something a bit </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">more complex.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.222.1">Closest pair of points</span></h1>
<p><span class="koboSpan" id="kobo.223.1">Another example is an algorithm to </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">find the closest pair of points</span></strong><span class="koboSpan" id="kobo.225.1"> located on the two-dimensional surface. </span><span class="koboSpan" id="kobo.225.2">It is an interesting</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.226.1"> algorithmic problem that can be solved using the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.227.1">divide-and-conquer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1"> paradigm.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">Each point is represented by </span><em class="italic"><span class="koboSpan" id="kobo.230.1">x</span></em><span class="koboSpan" id="kobo.231.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.232.1">y</span></em><span class="koboSpan" id="kobo.233.1"> coordinates, with values starting from (</span><strong class="bold"><span class="koboSpan" id="kobo.234.1">0</span></strong><span class="koboSpan" id="kobo.235.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">0</span></strong><span class="koboSpan" id="kobo.237.1">) in the top-left corner of the surface. </span><span class="koboSpan" id="kobo.237.2">To find the closest pair of points, you first sort all points according to the </span><em class="italic"><span class="koboSpan" id="kobo.238.1">x</span></em><span class="koboSpan" id="kobo.239.1"> coordinate, as shown in the following diagrams, marked from </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">A</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.241.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.242.1">N</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<span class="koboSpan" id="kobo.244.1"><img alt="Figure 9.3 – Diagrams of the algorithm to find the closest pair of points" src="image/B18069_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.245.1">Figure 9.3 – Diagrams of the algorithm to find the closest pair of points</span></p>
<p><span class="koboSpan" id="kobo.246.1">Then, you divide the surface into two halves. </span><span class="koboSpan" id="kobo.246.2">You can do this by calculating half of the points count, namely 7 in our example, and taking the first 7 points as the left half and the next 7 points as the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">right half.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">Here is a task for </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">recursion</span></strong><span class="koboSpan" id="kobo.250.1">, so you recursively find the closest points in both halves and store data as </span><em class="italic"><span class="koboSpan" id="kobo.251.1">r</span></em><span class="subscript"><span class="koboSpan" id="kobo.252.1">l</span></span><span class="koboSpan" id="kobo.253.1"> (points </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">D</span></strong><span class="koboSpan" id="kobo.255.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">E</span></strong><span class="koboSpan" id="kobo.257.1">) and </span><em class="italic"><span class="koboSpan" id="kobo.258.1">r</span></em><span class="subscript"><span class="koboSpan" id="kobo.259.1">r</span></span><span class="koboSpan" id="kobo.260.1"> (points </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">I</span></strong><span class="koboSpan" id="kobo.262.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">K</span></strong><span class="koboSpan" id="kobo.264.1">). </span><span class="koboSpan" id="kobo.264.2">You choose the closer pair by comparing such distances and store the result as </span><em class="italic"><span class="koboSpan" id="kobo.265.1">r</span></em><span class="koboSpan" id="kobo.266.1">, namely points </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">D</span></strong><span class="koboSpan" id="kobo.268.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">E</span></strong><span class="koboSpan" id="kobo.270.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">our case.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">That’s not all – you also need to check the distance between points from the left and the right half, as presented in the preceding diagram, on the right. </span><span class="koboSpan" id="kobo.272.2">To do so, you get an array with data of all points that are closer to the middle point (in respect to the </span><em class="italic"><span class="koboSpan" id="kobo.273.1">x</span></em><span class="koboSpan" id="kobo.274.1"> coordinate only) than the </span><em class="italic"><span class="koboSpan" id="kobo.275.1">r</span></em><span class="koboSpan" id="kobo.276.1"> distance of the already found pair of points (</span><strong class="bold"><span class="koboSpan" id="kobo.277.1">D</span></strong><span class="koboSpan" id="kobo.278.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">E</span></strong><span class="koboSpan" id="kobo.280.1"> in our example). </span><span class="koboSpan" id="kobo.280.2">Then, you find the closest pair of points in this array (</span><strong class="bold"><span class="koboSpan" id="kobo.281.1">G</span></strong><span class="koboSpan" id="kobo.282.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">H</span></strong><span class="koboSpan" id="kobo.284.1"> in the example). </span><span class="koboSpan" id="kobo.284.2">Let’s name the result </span><em class="italic"><span class="koboSpan" id="kobo.285.1">s</span></em><span class="koboSpan" id="kobo.286.1">. </span><span class="koboSpan" id="kobo.286.2">To complete the task, choose which pair, from </span><em class="italic"><span class="koboSpan" id="kobo.287.1">r</span></em><span class="koboSpan" id="kobo.288.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.289.1">D</span></strong><span class="koboSpan" id="kobo.290.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">E</span></strong><span class="koboSpan" id="kobo.292.1">) and </span><em class="italic"><span class="koboSpan" id="kobo.293.1">s</span></em><span class="koboSpan" id="kobo.294.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.295.1">G</span></strong><span class="koboSpan" id="kobo.296.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">H</span></strong><span class="koboSpan" id="kobo.298.1">), is closer. </span><span class="koboSpan" id="kobo.298.2">Then, just return the result (</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">D</span></strong><span class="koboSpan" id="kobo.300.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">E</span></strong><span class="koboSpan" id="kobo.302.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">our case).</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">The most important part of the code is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
Result? </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">FindClosestPair</span></strong><span class="koboSpan" id="kobo.308.1">(Point[] points)
{
    if (points.Length &lt;= 1) { return null; }
    if (points.Length &lt;= 3) { return </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Closest</span></strong><span class="koboSpan" id="kobo.310.1">(points); }
    int m = points.Length / 2;
    Result r = Closer(
        </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">FindClosestPair</span></strong><span class="koboSpan" id="kobo.312.1">(points.Take(m).ToArray())!,
        </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">FindClosestPair</span></strong><span class="koboSpan" id="kobo.314.1">(points.Skip(m).ToArray())!);
    Point[] strip = points.Where(p =&gt; Math.Abs(p.X
        - points[m].X) &lt; r.Distance).ToArray();
    return </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">Closer</span></strong><span class="koboSpan" id="kobo.316.1">(r, </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">Closest</span></strong><span class="koboSpan" id="kobo.318.1">(strip));
}</span></pre> <p><span class="koboSpan" id="kobo.319.1">First, there is the base condition that terminates execution when the array of points is empty or contains only one</span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.320.1"> element. </span><span class="koboSpan" id="kobo.320.2">Then, you check whether the number of points in the array is less than or equal to 3. </span><span class="koboSpan" id="kobo.320.3">If so, you choose the closest pair of points in the collection just by checking all possible variants. </span><span class="koboSpan" id="kobo.320.4">Otherwise, you choose an index of the middle point and call the method recursively for the left and right halves. </span><span class="koboSpan" id="kobo.320.5">Then, you get points from both halves that are close enough to the middle point, taking only </span><em class="italic"><span class="koboSpan" id="kobo.321.1">x</span></em><span class="koboSpan" id="kobo.322.1"> coordinates into account. </span><span class="koboSpan" id="kobo.322.2">Next, you calculate the distance between all points in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">strip</span></strong><span class="koboSpan" id="kobo.324.1"> array to get the closest pair from it. </span><span class="koboSpan" id="kobo.324.2">Finally, you just return the closer pair </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">of points.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">As you see, the main part of the algorithm is pretty simple to implement and understand. </span><span class="koboSpan" id="kobo.326.2">So, let’s talk about the rest, starting with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Point</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1"> definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
public record </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">Point</span></strong><span class="koboSpan" id="kobo.331.1">(int X, int Y)
{
    public float </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">GetDistanceTo</span></strong><span class="koboSpan" id="kobo.333.1">(Point p) =&gt;
        (float)Math.Sqrt(Math.Pow(X - p.X, 2)
            + Math.Pow(Y - p.Y, 2));
};</span></pre> <p><span class="koboSpan" id="kobo.334.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Result</span></strong><span class="koboSpan" id="kobo.336.1"> record is </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
public record </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Result</span></strong><span class="koboSpan" id="kobo.340.1">(Point P1, Point P2, double Distance);</span></pre> <p><span class="koboSpan" id="kobo.341.1">The main part of code uses two auxiliary methods, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Closest</span></strong><span class="koboSpan" id="kobo.343.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Closer</span></strong><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">The first one searches for the</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.346.1"> closest pair of points, and its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
Result </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">Closest</span></strong><span class="koboSpan" id="kobo.350.1">(Point[] points)
{
    Result result = new(points[0], points[0], double.MaxValue);
    for (int i = 0; i &lt; points.Length; i++)
    {
        for (int j = i + 1; j &lt; points.Length; j++)
        {
            double distance = points[i].GetDistanceTo(points[j]);
            if (distance &lt; result.Distance)
            {
                result = new(points[i], points[j], distance);
            }
        }
    }
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.351.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Closer</span></strong><span class="koboSpan" id="kobo.353.1"> method is </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.354.1">presented in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
Result </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">Closer</span></strong><span class="koboSpan" id="kobo.358.1">(Result r1, Result r2) =&gt;
    r1.Distance &lt; r2.Distance ? </span><span class="koboSpan" id="kobo.358.2">r1 : r2;</span></pre> <p><span class="koboSpan" id="kobo.359.1">Finally, let’s take a look at a way of calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">described method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
List&lt;Point&gt; points =
[
    new Point(6, 45),   // A
    new Point(12, 8),   // B
    new Point(14, 31),  // C
    new Point(24, 18),  // D
    new Point(32, 26),  // E
    new Point(40, 41),  // F
    new Point(44, 6),   // G
    new Point(57, 20),  // H
    new Point(60, 35),  // I
    new Point(72, 9),   // J
    new Point(73, 41),  // K
    new Point(85, 25),  // L
    new Point(92, 8),   // M
    new Point(93, 43)   // N
];
</span><strong class="bold"><span class="koboSpan" id="kobo.362.1">points.Sort((a, b) =&gt; a.X.CompareTo(b.X));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.363.1">Result? </span><span class="koboSpan" id="kobo.363.2">closestPair = FindClosestPair(points.ToArray());</span></strong><span class="koboSpan" id="kobo.364.1">
if (closestPair != null)
{
    Console.WriteLine(
        "Closest pair: ({0}, {1}) and ({2}, {3})
         with distance: {4:F2}",
        </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">closestPair.P1.X</span></strong><span class="koboSpan" id="kobo.366.1">,
        </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">closestPair.P1.Y</span></strong><span class="koboSpan" id="kobo.368.1">,
        </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">closestPair.P2.X</span></strong><span class="koboSpan" id="kobo.370.1">,
        </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">closestPair.P2.Y</span></strong><span class="koboSpan" id="kobo.372.1">,
        </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">closestPair.Distance</span></strong><span class="koboSpan" id="kobo.374.1">);
}</span></pre> <p><span class="koboSpan" id="kobo.375.1">You provide the collection of</span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.376.1"> points, sort them by </span><em class="italic"><span class="koboSpan" id="kobo.377.1">x</span></em><span class="koboSpan" id="kobo.378.1"> coordinates, and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">FindClosestPair</span></strong><span class="koboSpan" id="kobo.380.1"> method, passing the whole array as a parameter. </span><span class="koboSpan" id="kobo.380.2">Finally, you show the following result in </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.382.1">
Closest pair: (24, 18) and (32, 26) with distance: 11.31</span></pre> <p><span class="koboSpan" id="kobo.383.1">So, you get the same result as received when you analyzed the example at the beginning of this section. </span><span class="koboSpan" id="kobo.383.2">Good work – </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">congratulations!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.385.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.386.1">The examples shown in this chapter are representatives of various popular algorithmic problems, which you can receive even during interviews while recruiting for a job as a developer. </span><span class="koboSpan" id="kobo.386.2">These topics are also popular on the internet. </span><span class="koboSpan" id="kobo.386.3">For example, you can find more information about the aforementioned approach to the </span><em class="italic"><span class="koboSpan" id="kobo.387.1">closest pair of points</span></em><span class="koboSpan" id="kobo.388.1"> problem and its implementation at </span><a href="https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/"><span class="koboSpan" id="kobo.389.1">https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/</span></a><span class="koboSpan" id="kobo.390.1">. </span><span class="koboSpan" id="kobo.390.2">As </span><em class="italic"><span class="koboSpan" id="kobo.391.1">GeeksForGeeks</span></em><span class="koboSpan" id="kobo.392.1"> contains a huge number of various articles, you can also find entries there about some other problems mentioned in this chapter, together with some implementations, such as about the rat in a maze problem at </span><a href="https://www.geeksforgeeks.org/rat-in-a-maze/"><span class="koboSpan" id="kobo.393.1">https://www.geeksforgeeks.org/rat-in-a-maze/</span></a><span class="koboSpan" id="kobo.394.1"> and about the Sudoku puzzle </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">at </span></span><a href="https://www.geeksforgeeks.org/sudoku-backtracking-7"><span class="No-Break"><span class="koboSpan" id="kobo.396.1">https://www.geeksforgeeks.org/sudoku-backtracking-7</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.397.1">/.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">In my opinion, coding can</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.399.1"> be understood as a kind of art. </span><span class="koboSpan" id="kobo.399.2">Similar to painters who paint beautiful paintings, developers can write beautiful code. </span><span class="koboSpan" id="kobo.399.3">So, while we are talking about art, let’s write beautiful code that will paint </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">beautiful fractals!</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor372"/><span class="koboSpan" id="kobo.401.1">Fractal generation</span></h1>
<p><span class="koboSpan" id="kobo.402.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">recursion</span></strong><span class="koboSpan" id="kobo.404.1"> can be applied to many various</span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.405.1"> algorithms, also related to computer graphics. </span><span class="koboSpan" id="kobo.405.2">For this reason, let’s take a look at another example – </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">fractal generation</span></strong><span class="koboSpan" id="kobo.407.1"> creating interesting patterns, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<span class="koboSpan" id="kobo.409.1"><img alt="Figure 9.4 – An exemplary fractal generated using the recursive function" src="image/B18069_09_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.410.1">Figure 9.4 – An exemplary fractal generated using the recursive function</span></p>
<p><span class="koboSpan" id="kobo.411.1">It’s really beautiful, isn’t it? </span><span class="koboSpan" id="kobo.411.2">Can you see some tree patterns in this image? </span><span class="koboSpan" id="kobo.411.3">If not, let’s follow the bold line in the middle of the image (the tree </span><em class="italic"><span class="koboSpan" id="kobo.412.1">trunk</span></em><span class="koboSpan" id="kobo.413.1">) and note that it is divided into two lines (</span><em class="italic"><span class="koboSpan" id="kobo.414.1">branches</span></em><span class="koboSpan" id="kobo.415.1">), each rotated by a given degree. </span><span class="koboSpan" id="kobo.415.2">Then, follow one of these lines and see that it is divided </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.416.1">according to the same rule. </span><span class="koboSpan" id="kobo.416.2">This process is applied further and further until the specified number of levels </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">is reached.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">The description of this recursive algorithm in the natural language is quite easy, so let’s take a look at code to calculate the coordinates of the start and end points of the following lines that together form the beautiful drawing. </span><span class="koboSpan" id="kobo.418.2">The code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">AddLine</span></strong><span class="koboSpan" id="kobo.420.1"> method is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
void AddLine(int level, float x, float y,
    float length, float angle)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">if (level &lt; 0) { return; }</span></strong><span class="koboSpan" id="kobo.424.1">
    float endX = x + (float)(length * Math.Cos(angle));
    float endY = y + (float)(length * Math.Sin(angle));
    lines.Add(new(x, y, endX, endY));
    </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">AddLine(level - 1, endX, endY, length * 0.8f,</span></strong><span class="koboSpan" id="kobo.426.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">angle + (float)Math.PI * 0.3f);</span></strong><span class="koboSpan" id="kobo.428.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">AddLine(level - 1, endX, endY, length * 0.6f,</span></strong><span class="koboSpan" id="kobo.430.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">angle + (float)Math.PI * 1.7f);</span></strong><span class="koboSpan" id="kobo.432.1">
}</span></pre> <p><span class="koboSpan" id="kobo.433.1">The method takes a few parameters, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.435.1">A level of pattern, starting with the non-negative number and leading </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">to 0</span></span></li>
<li><span class="koboSpan" id="kobo.437.1">The </span><em class="italic"><span class="koboSpan" id="kobo.438.1">x</span></em><span class="koboSpan" id="kobo.439.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.440.1">y</span></em><span class="koboSpan" id="kobo.441.1"> coordinates of the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">start point</span></span></li>
<li><span class="koboSpan" id="kobo.443.1">A length of </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">the line</span></span></li>
<li><span class="koboSpan" id="kobo.445.1">Its angle, provided </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">in radians</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.447.1">Within the method, you check the base</span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.448.1"> condition, namely whether the level is smaller than 0. </span><span class="koboSpan" id="kobo.448.2">If not, you calculate </span><em class="italic"><span class="koboSpan" id="kobo.449.1">x</span></em><span class="koboSpan" id="kobo.450.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.451.1">y</span></em><span class="koboSpan" id="kobo.452.1"> coordinates of the end point and add the line to the collection of lines (</span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">lines</span></strong><span class="koboSpan" id="kobo.454.1">). </span><span class="koboSpan" id="kobo.454.2">At the end, you recursively call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">AddLine</span></strong><span class="koboSpan" id="kobo.456.1"> method, passing different parameters. </span><span class="koboSpan" id="kobo.456.2">You decrease the level, pass the calculated end point coordinates as coordinates of a start point for the next line, decrease the length by 20% and 40% (depending on the branch), and also modify </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">the angle.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">It is worth noting that the preceding code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Line</span></strong><span class="koboSpan" id="kobo.460.1"> record, the code for which is </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
record </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">Line</span></strong><span class="koboSpan" id="kobo.464.1">(float X1, float Y1, float X2, float Y2)
{
    public float </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">GetLength</span></strong><span class="koboSpan" id="kobo.466.1">() =&gt;
        (float)Math.Sqrt(Math.Pow(X1 - X2, 2)
            + Math.Pow(Y1 - Y2, 2));
}</span></pre> <p><span class="koboSpan" id="kobo.467.1">The next part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
using System.Drawing;
using System.Drawing.Drawing2D;
const int maxSize = 1000;
List&lt;Line&gt; lines = [];
</span><strong class="bold"><span class="koboSpan" id="kobo.470.1">AddLine(14, 0, 0, 500, (float)Math.PI * 1.5f);</span></strong></pre> <p><span class="koboSpan" id="kobo.471.1">Here, you specify the maximum </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.472.1">width or height of the bitmap on which the fractal will be drawn (</span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">maxSize</span></strong><span class="koboSpan" id="kobo.474.1">). </span><span class="koboSpan" id="kobo.474.2">Then, you prepare an empty list for the lines. </span><span class="koboSpan" id="kobo.474.3">In the last line, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">AddLine</span></strong><span class="koboSpan" id="kobo.476.1"> method. </span><span class="koboSpan" id="kobo.476.2">You indicate that </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">14</span></strong><span class="koboSpan" id="kobo.478.1"> levels of pattern will </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">be added.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.480.1">The required NuGet package</span></p>
<p class="callout"><span class="koboSpan" id="kobo.481.1">As you use elements from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">System.Drawing</span></strong><span class="koboSpan" id="kobo.483.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">System.Drawing.Drawing2D</span></strong><span class="koboSpan" id="kobo.485.1"> namespaces, it is necessary to install an additional NuGet package, </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">namely </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">System.Drawing.Common</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">As soon as you have the collection of lines, you can calculate the minimum and maximum </span><em class="italic"><span class="koboSpan" id="kobo.490.1">x</span></em><span class="koboSpan" id="kobo.491.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.492.1">y</span></em><span class="koboSpan" id="kobo.493.1"> coordinates, as well as the target </span><em class="italic"><span class="koboSpan" id="kobo.494.1">width</span></em><span class="koboSpan" id="kobo.495.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.496.1">height</span></em><span class="koboSpan" id="kobo.497.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
float xMin = lines.Min(l =&gt; Math.Min(l.X1, l.X2));
float xMax = lines.Max(l =&gt; Math.Max(l.X1, l.X2));
float yMin = lines.Min(l =&gt; Math.Min(l.Y1, l.Y2));
float yMax = lines.Max(l =&gt; Math.Max(l.Y1, l.Y2));
float size = Math.Max(xMax - xMin, yMax - yMin);
float factor = maxSize / size;
</span><strong class="bold"><span class="koboSpan" id="kobo.500.1">int width = (int)((xMax - xMin) * factor);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.501.1">int height = (int)((yMax - yMin) * factor);</span></strong></pre> <p><span class="koboSpan" id="kobo.502.1">The remaining part of code is related to printing the fractal on </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">the bitmap:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.504.1">using Bitmap bitmap = new(width, height);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.505.1">using Graphics graphics = Graphics.FromImage(bitmap);</span></strong><span class="koboSpan" id="kobo.506.1">
graphics.Clear(Color.White);
graphics.SmoothingMode = SmoothingMode.AntiAlias;
</span><strong class="bold"><span class="koboSpan" id="kobo.507.1">using Pen pen = new(Color.Black, 1);</span></strong><span class="koboSpan" id="kobo.508.1">
foreach (Line line in lines)
{
    pen.Width = line.GetLength() / 20;
    float sx = (line.X1 - xMin) * factor;
    float sy = (line.Y1 - yMin) * factor;
    float ex = (line.X2 - xMin) * factor;
    float ey = (line.Y2 - yMin) * factor;
</span><strong class="bold"><span class="koboSpan" id="kobo.509.1">    graphics.DrawLine(pen, sx, sy, ex, ey);</span></strong><span class="koboSpan" id="kobo.510.1">
}
bitmap.Save($"{DateTime.Now:HH-mm-ss}.png");</span></pre> <p><span class="koboSpan" id="kobo.511.1">Within the presented code, you create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Bitmap</span></strong><span class="koboSpan" id="kobo.513.1"> class with the specified size, as well as </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.514.1">prepare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Graphics</span></strong><span class="koboSpan" id="kobo.516.1"> object to draw on this bitmap. </span><span class="koboSpan" id="kobo.516.2">Then, you paint the whole bitmap with a white color, set anti-aliasing, and specify a black pen </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">for drawing.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">The preceding piece of code involves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">foreach</span></strong><span class="koboSpan" id="kobo.520.1"> loop. </span><span class="koboSpan" id="kobo.520.2">Within it, you calculate a line width, as well as the start and end coordinates. </span><span class="koboSpan" id="kobo.520.3">The last line in the loop simply draws the line. </span><span class="koboSpan" id="kobo.520.4">Finally, you save the prepared bitmap in the working directory in the file, whose name is created </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.521.1">based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">current time.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.523.1">Do you see warnings?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.524.1">The prepared code shows some warnings in the IDE. </span><span class="koboSpan" id="kobo.524.2">They </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.525.1">inform you about the availability of graphics-related features only on the Windows platform. </span><span class="koboSpan" id="kobo.525.2">You can hide such warnings by adding the line </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">#pragma warning disable CA1416</span></strong><span class="koboSpan" id="kobo.527.1"> just before the preceding code, as well as adding the line </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">#pragma warning restore CA1416</span></strong><span class="koboSpan" id="kobo.529.1"> just at the end. </span><span class="koboSpan" id="kobo.529.2">What’s more, if you want to also draw graphics on other platforms, you can use other available NuGet packages, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">SkiaSharp</span></strong><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">I strongly encourage you to create this example with </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">SkiaSharp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.533.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">That’s all! </span><span class="koboSpan" id="kobo.534.2">You can now adjust various parameters to paint beautiful fractals, even better than presented in the preceding figure. </span><span class="koboSpan" id="kobo.534.3">Some of the other results are </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<span class="koboSpan" id="kobo.536.1"><img alt="Figure 9.5 – Exemplary fractals generated using the recursive function" src="image/B18069_09_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.537.1">Figure 9.5 – Exemplary fractals generated using the recursive function</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.538.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.539.1">You can find a lot of content about fractals in the internet. </span><span class="koboSpan" id="kobo.539.2">However, an approach similar to presented here, is described </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">at </span></span><a href="http://www.csharphelper.com/howtos/howto_curly_tree.html"><span class="No-Break"><span class="koboSpan" id="kobo.541.1">http://www.csharphelper.com/howtos/howto_curly_tree.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.542.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">As soon as you are satisfied with the design of your fractal, let’s move to the next section, where you will </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.544.1">solve the </span><em class="italic"><span class="koboSpan" id="kobo.545.1">rat in a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.546.1">maze</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1"> puzzle.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.548.1">Rat in a maze</span></h1>
<p><span class="koboSpan" id="kobo.549.1">Let’s continue our adventure with examples by </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.550.1">solving the </span><strong class="bold"><span class="koboSpan" id="kobo.551.1">rat in a maze</span></strong><span class="koboSpan" id="kobo.552.1"> problem with a </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">back-tracking algorithm</span></strong><span class="koboSpan" id="kobo.554.1">. </span><span class="koboSpan" id="kobo.554.2">The diagram is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer119">
<span class="koboSpan" id="kobo.556.1"><img alt="Figure 9.6 – ﻿Illustration of the ﻿rat in a ﻿maze example" src="image/B18069_09_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.557.1">Figure 9.6 – Illustration of the rat in a maze example</span></p>
<p><span class="koboSpan" id="kobo.558.1">Let’s imagine that a rat is located in the top-left field on the board, which is marked as </span><strong class="bold"><span class="koboSpan" id="kobo.559.1">(0, 0)</span></strong><span class="koboSpan" id="kobo.560.1"> in the preceding figure, and we need to find a path to the exit, which is located in the bottom-right field and is marked as </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">(7, 7)</span></strong><span class="koboSpan" id="kobo.562.1">. </span><span class="koboSpan" id="kobo.562.2">Of course, some blocks are disabled (shown in gray) and the rat cannot go through them. </span><span class="koboSpan" id="kobo.562.3">To reach the target, the rat can go up, down, left, or right only using the </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">available blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">You can solve this problem using the </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">recursion</span></strong><span class="koboSpan" id="kobo.566.1"> to check possible paths leading the rat from the entry to the exit. </span><span class="koboSpan" id="kobo.566.2">If the currently calculated path does not reach the exit, you </span><strong class="bold"><span class="koboSpan" id="kobo.567.1">backtrack</span></strong><span class="koboSpan" id="kobo.568.1"> and try </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">other variants.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">The main part of the implementation is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Go</span></strong><span class="koboSpan" id="kobo.572.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
bool </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">Go</span></strong><span class="koboSpan" id="kobo.576.1">(int row, int col)
{
    if (row == size - 1
        &amp;&amp; col == size - 1
        &amp;&amp; maze[row, col])
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">solution[row, col] = true;</span></strong><span class="koboSpan" id="kobo.578.1">
        return true;
    }
    if (row &gt;= 0 &amp;&amp; row &lt; size
        &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; size
        &amp;&amp; maze[row, col])
    {
        if (solution[row, col]) { return false; }
        </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">solution[row, col] = true;</span></strong><span class="koboSpan" id="kobo.580.1">
        if (</span><strong class="bold"><span class="koboSpan" id="kobo.581.1">Go(row + 1, col)</span></strong><span class="koboSpan" id="kobo.582.1">) { return true; }
        if (</span><strong class="bold"><span class="koboSpan" id="kobo.583.1">Go(row, col + 1)</span></strong><span class="koboSpan" id="kobo.584.1">) { return true; }
        if (</span><strong class="bold"><span class="koboSpan" id="kobo.585.1">Go(row - 1, col)</span></strong><span class="koboSpan" id="kobo.586.1">) { return true; }
        if (</span><strong class="bold"><span class="koboSpan" id="kobo.587.1">Go(row, col - 1)</span></strong><span class="koboSpan" id="kobo.588.1">) { return true; }
        </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">solution[row, col] = false;</span></strong><span class="koboSpan" id="kobo.590.1">
        return false;
    }
    return false;
}</span></pre> <p><span class="koboSpan" id="kobo.591.1">The method takes two</span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.592.1"> parameters, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">row</span></strong><span class="koboSpan" id="kobo.594.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">column</span></strong><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">It also uses three additional variables. </span><span class="koboSpan" id="kobo.596.3">The first is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">maze</span></strong><span class="koboSpan" id="kobo.598.1"> and is a two-dimensional array representing the maze with available (filled with </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">true</span></strong><span class="koboSpan" id="kobo.600.1"> values) and unavailable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">false</span></strong><span class="koboSpan" id="kobo.602.1">) fields for the rat. </span><span class="koboSpan" id="kobo.602.2">The second, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">size</span></strong><span class="koboSpan" id="kobo.604.1">, stores the size of the maze, namely the number of rows, which is also equal to the number of columns. </span><span class="koboSpan" id="kobo.604.2">Another variable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">solution</span></strong><span class="koboSpan" id="kobo.606.1">) is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">maze</span></strong><span class="koboSpan" id="kobo.608.1">, but it stores the data of the currently checked path. </span><span class="koboSpan" id="kobo.608.2">The fields forming the solution are filled with </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">true</span></strong><span class="koboSpan" id="kobo.610.1"> values, while others are filled </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">At the beginning of the method, you check whether the rat already reached the exit. </span><span class="koboSpan" id="kobo.614.2">If so, you mark the final field as a part of the solution and return a value indicating that the rat completed its task and exited the maze. </span><span class="koboSpan" id="kobo.614.3">Otherwise, you check whether the rat is still within the maze and not </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.615.1">on any unavailable field. </span><span class="koboSpan" id="kobo.615.2">If all of these conditions are met, you check whether this field is already a part of the path, and if so, you inform that this solution </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">is incorrect.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">If the rat is within the maze and on an available field that has not already been visited, you mark this field as a part of the solution and try to go down, right, up, and left by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">Go</span></strong><span class="koboSpan" id="kobo.619.1"> method recursively. </span><span class="koboSpan" id="kobo.619.2">If none of these moves reaches the target (of course, also after the next steps), you indicate that the current field is not a part of the solution, which </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.620.1">represents </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">back-tracking</span></strong><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">Then, you return a value indicating that the target has not </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">been reached.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">Next, take a look at the code that calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">Go</span></strong><span class="koboSpan" id="kobo.626.1"> method for the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">first time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
int size = 8;
bool t = true;
bool f = false;
bool[,] maze =
{
    { </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">t</span></strong><span class="koboSpan" id="kobo.630.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">t</span></strong><span class="koboSpan" id="kobo.632.1">, f, f, </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">t</span></strong><span class="koboSpan" id="kobo.634.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">t</span></strong><span class="koboSpan" id="kobo.636.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">t</span></strong><span class="koboSpan" id="kobo.638.1"> },
    { </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">t</span></strong><span class="koboSpan" id="kobo.640.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.641.1">t</span></strong><span class="koboSpan" id="kobo.642.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">t</span></strong><span class="koboSpan" id="kobo.644.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">t</span></strong><span class="koboSpan" id="kobo.646.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.647.1">t</span></strong><span class="koboSpan" id="kobo.648.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.649.1">t</span></strong><span class="koboSpan" id="kobo.650.1">, f },
    { </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">t</span></strong><span class="koboSpan" id="kobo.652.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">t</span></strong><span class="koboSpan" id="kobo.654.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">t</span></strong><span class="koboSpan" id="kobo.656.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">t</span></strong><span class="koboSpan" id="kobo.658.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">t</span></strong><span class="koboSpan" id="kobo.660.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">t</span></strong><span class="koboSpan" id="kobo.662.1"> },
    { f, </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">t</span></strong><span class="koboSpan" id="kobo.664.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">t</span></strong><span class="koboSpan" id="kobo.666.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">t</span></strong><span class="koboSpan" id="kobo.668.1">, f, f, </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">t</span></strong><span class="koboSpan" id="kobo.670.1"> },
    { f, </span><strong class="bold"><span class="koboSpan" id="kobo.671.1">t</span></strong><span class="koboSpan" id="kobo.672.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.673.1">t</span></strong><span class="koboSpan" id="kobo.674.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">t</span></strong><span class="koboSpan" id="kobo.676.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">t</span></strong><span class="koboSpan" id="kobo.678.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.679.1">t</span></strong><span class="koboSpan" id="kobo.680.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.681.1">t</span></strong><span class="koboSpan" id="kobo.682.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.683.1">t</span></strong><span class="koboSpan" id="kobo.684.1"> },
    { </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">t</span></strong><span class="koboSpan" id="kobo.686.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">t</span></strong><span class="koboSpan" id="kobo.688.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">t</span></strong><span class="koboSpan" id="kobo.690.1">, f, f, </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">t</span></strong><span class="koboSpan" id="kobo.692.1"> },
    { </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">t</span></strong><span class="koboSpan" id="kobo.694.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">t</span></strong><span class="koboSpan" id="kobo.696.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">t</span></strong><span class="koboSpan" id="kobo.698.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.699.1">t</span></strong><span class="koboSpan" id="kobo.700.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.701.1">t</span></strong><span class="koboSpan" id="kobo.702.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.703.1">t</span></strong><span class="koboSpan" id="kobo.704.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.705.1">t</span></strong><span class="koboSpan" id="kobo.706.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.707.1">t</span></strong><span class="koboSpan" id="kobo.708.1"> },
    { f, </span><strong class="bold"><span class="koboSpan" id="kobo.709.1">t</span></strong><span class="koboSpan" id="kobo.710.1">, f, f, f, </span><strong class="bold"><span class="koboSpan" id="kobo.711.1">t</span></strong><span class="koboSpan" id="kobo.712.1">, f, </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">t</span></strong><span class="koboSpan" id="kobo.714.1"> }
};
bool[,] solution = new bool[size, size];
</span><strong class="bold"><span class="koboSpan" id="kobo.715.1">if (Go(0, 0)) { Print(); }</span></strong></pre> <p><span class="koboSpan" id="kobo.716.1">The remaining code is </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.717.1">related to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">Print</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.719.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.720.1">
void Print()
{
    for (int row = 0; row &lt; size; row++)
    {
        for (int col = 0; col &lt; size; col++)
        {
            Console.Write(solution[row, col] ? </span><span class="koboSpan" id="kobo.720.2">"x" : "-");
        }
        Console.WriteLine();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.721.1">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.723.1">
x-------
x-------
xx------
-x------
-xx-----
--x-----
--xxxxxx
-------x</span></pre> <p><span class="koboSpan" id="kobo.724.1">As we conclude this example, it is worth mentioning how the code is simple and short. </span><span class="koboSpan" id="kobo.724.2">Thus, you can define the solution to a problem in a clear way. </span><span class="koboSpan" id="kobo.724.3">However, keep in mind that if there is more than one path, an algorithm shows </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">only one.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">After helping the rat to find a</span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.727.1"> path in a maze, let’s move on to the next example, where you will learn how to automatically solve a </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">Sudoku puzzle.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.729.1">A Sudoku puzzle</span></h1>
<p><span class="koboSpan" id="kobo.730.1">Have you ever solved </span><strong class="bold"><span class="koboSpan" id="kobo.731.1">Sudoku</span></strong><span class="koboSpan" id="kobo.732.1">? </span><span class="koboSpan" id="kobo.732.2">It is a very </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.733.1">popular game that requires you to </span><strong class="bold"><span class="koboSpan" id="kobo.734.1">fill empty cells of a 9x9 board with numbers from 1 to 9</span></strong><span class="koboSpan" id="kobo.735.1">. </span><span class="koboSpan" id="kobo.735.2">However, </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">each row, each column, and each 3x3 box must contain only unique numbers</span></strong><span class="koboSpan" id="kobo.737.1">. </span><span class="koboSpan" id="kobo.737.2">An exemplary starting board and a solved one are shown </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<span class="koboSpan" id="kobo.739.1"><img alt="Figure 9.7 – An example of non-solved and solved Sudoku puzzles" src="image/B18069_09_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.740.1">Figure 9.7 – An example of non-solved and solved Sudoku puzzles</span></p>
<p><span class="koboSpan" id="kobo.741.1">Now, you will learn how to solve Sudoku not with the usage of a pencil and a piece of paper but with an algorithm! </span><span class="koboSpan" id="kobo.741.2">You can perform this task using the </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">back-tracking</span></strong><span class="koboSpan" id="kobo.743.1"> approach, trying to assign numbers to empty cells if, of course, they meet the conditions regarding unique numbers in each row, column, and box. </span><span class="koboSpan" id="kobo.743.2">If an entered number does not result in solving the whole puzzle, you assign another number and perform the check again. </span><span class="koboSpan" id="kobo.743.3">Let’s take a look at the most important part of </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.745.1">
bool </span><strong class="bold"><span class="koboSpan" id="kobo.746.1">Solve</span></strong><span class="koboSpan" id="kobo.747.1">()
{
    (int row, int col) = GetEmpty();
    </span><strong class="bold"><span class="koboSpan" id="kobo.748.1">if (row &lt; 0 &amp;&amp; col &lt; 0) { return true; }</span></strong><span class="koboSpan" id="kobo.749.1">
    for (int i = 1; i &lt;= 9; i++)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.750.1">if (IsCorrect(row, col, i))</span></strong><span class="koboSpan" id="kobo.751.1">
        {
            </span><strong class="bold"><span class="koboSpan" id="kobo.752.1">board[row, col] = i;</span></strong><span class="koboSpan" id="kobo.753.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">if (Solve()) { return true; }</span></strong><span class="koboSpan" id="kobo.755.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">else { board[row, col] = 0; }</span></strong><span class="koboSpan" id="kobo.757.1">
        }
    }
    return false;
}</span></pre> <p><span class="koboSpan" id="kobo.758.1">At the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">Solve</span></strong><span class="koboSpan" id="kobo.760.1"> method, you get coordinates of the first empty cell. </span><span class="koboSpan" id="kobo.760.2">If there are no empty cells, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">GetEmpty</span></strong><span class="koboSpan" id="kobo.762.1"> method returns (</span><strong class="bold"><span class="koboSpan" id="kobo.763.1">-1</span></strong><span class="koboSpan" id="kobo.764.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">-1</span></strong><span class="koboSpan" id="kobo.766.1">). </span><span class="koboSpan" id="kobo.766.2">Then, you return </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">true</span></strong><span class="koboSpan" id="kobo.768.1">, indicating that the game </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">is solved.</span></span></p>
<p><span class="koboSpan" id="kobo.770.1">Otherwise, you iterate through all possible numbers (namely from 1 to 9), using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">for</span></strong><span class="koboSpan" id="kobo.772.1"> loop. </span><span class="koboSpan" id="kobo.772.2">In each iteration, you check whether </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.773.1">the number can be correctly entered in this cell, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">IsCorrect</span></strong><span class="koboSpan" id="kobo.775.1"> method, ensuring that the number is unique in a row, a column, and a box. </span><span class="koboSpan" id="kobo.775.2">If so, you enter this number into the cell and </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">recursively</span></strong><span class="koboSpan" id="kobo.777.1"> call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">Solve</span></strong><span class="koboSpan" id="kobo.779.1"> method. </span><span class="koboSpan" id="kobo.779.2">If it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">false</span></strong><span class="koboSpan" id="kobo.781.1">, indicating that this variant does not work, you backtrack by clearing the value entered in the cell, which means that it is empty and another variant needs to be used. </span><span class="koboSpan" id="kobo.781.2">If no variants lead to the solution, you </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">The presented code uses two auxiliary methods, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">GetEmpty</span></strong><span class="koboSpan" id="kobo.787.1">, which searches for the first cell that is not already filled. </span><span class="koboSpan" id="kobo.787.2">Its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.789.1">
(int, int) </span><strong class="bold"><span class="koboSpan" id="kobo.790.1">GetEmpty</span></strong><span class="koboSpan" id="kobo.791.1">()
{
    for (int r = 0; r &lt; 9; r++)
    {
        for (int c = 0; c &lt; 9; c++)
        {
            if (board[r, c] == 0) { return (r, c); }
        }
    }
    return (-1, -1);
}</span></pre> <p><span class="koboSpan" id="kobo.792.1">The second auxiliary method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">IsCorrect</span></strong><span class="koboSpan" id="kobo.794.1"> and ensures that after entering a provided number in a given cell (with a specified row and column), the board still meets the criteria of the Sudoku game. </span><span class="koboSpan" id="kobo.794.2">Its </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.795.1">code is </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.797.1">
bool </span><strong class="bold"><span class="koboSpan" id="kobo.798.1">IsCorrect</span></strong><span class="koboSpan" id="kobo.799.1">(int row, int col, int num)
{
    for (int i = 0; i &lt; 9; i++)
    {
        if (board[row, i] == num) { return false; }
        if (board[i, col] == num) { return false; }
    }
    int rs = row - row % 3;
    int cs = col - col % 3;
    for (int r = rs; r &lt; rs + 3; r++)
    {
        for (int c = cs; c &lt; cs + 3; c++)
        {
            if (board[r, c] == num) { return false; }
        }
    }
    return true;
}</span></pre> <p><span class="koboSpan" id="kobo.800.1">At the beginning, you check whether values are unique in a given row and column. </span><span class="koboSpan" id="kobo.800.2">The remaining part checks whether a particular 3x3 box contains only </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">unique numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.802.1">The exemplary code for</span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.803.1"> launching the Sudoku solving algorithm is </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.805.1">
int[,] board = new int[,]
{
    { </span><strong class="bold"><span class="koboSpan" id="kobo.806.1">0</span></strong><span class="koboSpan" id="kobo.807.1">, 5, </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">0</span></strong><span class="koboSpan" id="kobo.809.1">, 4, </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">0</span></strong><span class="koboSpan" id="kobo.811.1">, 1, </span><strong class="bold"><span class="koboSpan" id="kobo.812.1">0</span></strong><span class="koboSpan" id="kobo.813.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.814.1">0</span></strong><span class="koboSpan" id="kobo.815.1">, 6 },
    { 1, </span><strong class="bold"><span class="koboSpan" id="kobo.816.1">0</span></strong><span class="koboSpan" id="kobo.817.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.818.1">0</span></strong><span class="koboSpan" id="kobo.819.1">, 9, 5, </span><strong class="bold"><span class="koboSpan" id="kobo.820.1">0</span></strong><span class="koboSpan" id="kobo.821.1">, 8, </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">0</span></strong><span class="koboSpan" id="kobo.823.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">0</span></strong><span class="koboSpan" id="kobo.825.1"> },
    { 9, </span><strong class="bold"><span class="koboSpan" id="kobo.826.1">0</span></strong><span class="koboSpan" id="kobo.827.1">, 4, </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">0</span></strong><span class="koboSpan" id="kobo.829.1">, 6, </span><strong class="bold"><span class="koboSpan" id="kobo.830.1">0</span></strong><span class="koboSpan" id="kobo.831.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.832.1">0</span></strong><span class="koboSpan" id="kobo.833.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.834.1">0</span></strong><span class="koboSpan" id="kobo.835.1">, 1 },
    { 6, 2, </span><strong class="bold"><span class="koboSpan" id="kobo.836.1">0</span></strong><span class="koboSpan" id="kobo.837.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.838.1">0</span></strong><span class="koboSpan" id="kobo.839.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.840.1">0</span></strong><span class="koboSpan" id="kobo.841.1">, 5, 3, </span><strong class="bold"><span class="koboSpan" id="kobo.842.1">0</span></strong><span class="koboSpan" id="kobo.843.1">, 4 },
    { </span><strong class="bold"><span class="koboSpan" id="kobo.844.1">0</span></strong><span class="koboSpan" id="kobo.845.1">, 9, </span><strong class="bold"><span class="koboSpan" id="kobo.846.1">0</span></strong><span class="koboSpan" id="kobo.847.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.848.1">0</span></strong><span class="koboSpan" id="kobo.849.1">, 7, </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">0</span></strong><span class="koboSpan" id="kobo.851.1">, 2, </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">0</span></strong><span class="koboSpan" id="kobo.853.1">, 5 },
    { 5, </span><strong class="bold"><span class="koboSpan" id="kobo.854.1">0</span></strong><span class="koboSpan" id="kobo.855.1">, 7, </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">0</span></strong><span class="koboSpan" id="kobo.857.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">0</span></strong><span class="koboSpan" id="kobo.859.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">0</span></strong><span class="koboSpan" id="kobo.861.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">0</span></strong><span class="koboSpan" id="kobo.863.1">, 8, 9 },
    { 8, </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">0</span></strong><span class="koboSpan" id="kobo.865.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">0</span></strong><span class="koboSpan" id="kobo.867.1">, 5, 1, 9, </span><strong class="bold"><span class="koboSpan" id="kobo.868.1">0</span></strong><span class="koboSpan" id="kobo.869.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.870.1">0</span></strong><span class="koboSpan" id="kobo.871.1">, 2 },
    { 2, 3, </span><strong class="bold"><span class="koboSpan" id="kobo.872.1">0</span></strong><span class="koboSpan" id="kobo.873.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.874.1">0</span></strong><span class="koboSpan" id="kobo.875.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.876.1">0</span></strong><span class="koboSpan" id="kobo.877.1">, 6, 5, </span><strong class="bold"><span class="koboSpan" id="kobo.878.1">0</span></strong><span class="koboSpan" id="kobo.879.1">, 8 },
    { 4, 1, </span><strong class="bold"><span class="koboSpan" id="kobo.880.1">0</span></strong><span class="koboSpan" id="kobo.881.1">, 2, </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">0</span></strong><span class="koboSpan" id="kobo.883.1">, 8, 6, </span><strong class="bold"><span class="koboSpan" id="kobo.884.1">0</span></strong><span class="koboSpan" id="kobo.885.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">0</span></strong><span class="koboSpan" id="kobo.887.1"> }
};
</span><strong class="bold"><span class="koboSpan" id="kobo.888.1">if (Solve()) { Print(); }</span></strong></pre> <p><span class="koboSpan" id="kobo.889.1">Finally, let’s take a look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">Print</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.891.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.892.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.893.1">Print</span></strong><span class="koboSpan" id="kobo.894.1">()
{
    for (int r = 0; r &lt; 9; r++)
    {
        for (int c = 0; c &lt; 9; c++)
        {
            Console.Write($"{board[r, c]} ");
        }
        Console.WriteLine();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.895.1">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">shown</span></span><span class="No-Break"><a id="_idIndexMarker889"/></span><span class="No-Break"><span class="koboSpan" id="kobo.897.1"> here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.898.1">
7 5 3 4 8 1 9 2 6
1 6 2 9 5 7 8 4 3
9 8 4 3 6 2 7 5 1
6 2 1 8 9 5 3 7 4
3 9 8 1 7 4 2 6 5
5 4 7 6 2 3 1 8 9
8 7 6 5 1 9 4 3 2
2 3 9 7 4 6 5 1 8
4 1 5 2 3 8 6 9 7</span></pre> <p><span class="koboSpan" id="kobo.899.1">As you can see, a back-tracking algorithm can be successfully applied to solve both rat in a maze and Sudoku puzzles. </span><span class="koboSpan" id="kobo.899.2">You can achieve this goal with short and clear code that is also easy to understand. </span><span class="koboSpan" id="kobo.899.3">So, after these examples, let’s move on to the next section where you will see an interesting application of a </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">genetic algorithm.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor375"/><span class="koboSpan" id="kobo.901.1">Title guess</span></h1>
<p><span class="koboSpan" id="kobo.902.1">It is high time to change a type of applied algorithm to a </span><strong class="bold"><span class="koboSpan" id="kobo.903.1">heuristic</span></strong><span class="koboSpan" id="kobo.904.1"> one, which has many applications and also subtypes. </span><span class="koboSpan" id="kobo.904.2">Here, we focus only on </span><strong class="bold"><span class="koboSpan" id="kobo.905.1">genetic algorithms</span></strong><span class="koboSpan" id="kobo.906.1">, which are </span><strong class="bold"><span class="koboSpan" id="kobo.907.1">adaptive heuristic search algorithms</span></strong><span class="koboSpan" id="kobo.908.1">. </span><span class="koboSpan" id="kobo.908.2">They are related to the Darwinian theory of evolution and natural selection. </span><span class="koboSpan" id="kobo.908.3">According to it, individuals in a population compete, and the </span><strong class="bold"><span class="koboSpan" id="kobo.909.1">population evolves to create next generations that are better suited to survive</span></strong><span class="koboSpan" id="kobo.910.1">. </span><span class="koboSpan" id="kobo.910.2">The genetic algorithms </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.911.1">operate on strings that evolve to receive possibly the highest value of </span><strong class="bold"><span class="koboSpan" id="kobo.912.1">fitness</span></strong><span class="koboSpan" id="kobo.913.1">, complying with the </span><strong class="bold"><span class="koboSpan" id="kobo.914.1">rule of survival</span></strong><span class="koboSpan" id="kobo.915.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.916.1">passing on the genes of the fittest parents</span></strong><span class="koboSpan" id="kobo.917.1">, also based on a </span><strong class="bold"><span class="koboSpan" id="kobo.918.1">randomized data exchange</span></strong><span class="koboSpan" id="kobo.919.1">. </span><span class="koboSpan" id="kobo.919.2">The algorithm ends its operation when a suitable value of fitness is reached or when the maximum number of generations </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">is reached.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.921.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.922.1">You can find a lot of content about genetic algorithms in the internet, such as in the article published at </span><a href="https://link.springer.com/article/10.1007/s11042-020-10139-6"><span class="koboSpan" id="kobo.923.1">https://link.springer.com/article/10.1007/s11042-020-10139-6</span></a><span class="koboSpan" id="kobo.924.1">. </span><span class="koboSpan" id="kobo.924.2">The simple approach to a genetic algorithm, which is shown in this chapter, is based on the solution presented </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">at </span></span><a href="https://www.geeksforgeeks.org/genetic-algorithms/"><span class="No-Break"><span class="koboSpan" id="kobo.926.1">https://www.geeksforgeeks.org/genetic-algorithms/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.927.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">Let's take a look at an example of a genetic algorithm application to guess the title of this book. </span><span class="koboSpan" id="kobo.928.2">The first part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.930.1">
const string Genes = "abcdefghijklmnopqrstuvwxyz
    #ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
const string Target = "C# Data Structures and Algorithms";
Random random = new();
int generationNo = 0;
</span><strong class="bold"><span class="koboSpan" id="kobo.931.1">List&lt;Individual&gt; population = [];</span></strong><span class="koboSpan" id="kobo.932.1">
for (int i = 0; i &lt; 1000; i++)
{
    string chromosome = GetRandomChromosome();
    </span><strong class="bold"><span class="koboSpan" id="kobo.933.1">population.Add(new(chromosome,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.934.1">        GetFitness(chromosome)));</span></strong><span class="koboSpan" id="kobo.935.1">
}</span></pre> <p><span class="koboSpan" id="kobo.936.1">First, you create an initial population, with 1,000 individuals. </span><span class="koboSpan" id="kobo.936.2">Each individual has a random chromosome, represented by a random string whose length is equal to the target string, which is a title of the book. </span><span class="koboSpan" id="kobo.936.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">go further:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.938.1">
List&lt;Individual&gt; generation = [];
while (true)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.939.1">population.Sort((a, b) =&gt;</span></strong><span class="koboSpan" id="kobo.940.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.941.1">b.Fitness.CompareTo(a.Fitness));</span></strong><span class="koboSpan" id="kobo.942.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.943.1">if (population[0].Fitness == Target.Length)</span></strong><span class="koboSpan" id="kobo.944.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.945.1">{</span></strong><span class="koboSpan" id="kobo.946.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.947.1">Print();</span></strong><span class="koboSpan" id="kobo.948.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.949.1">break;</span></strong><span class="koboSpan" id="kobo.950.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.951.1">}</span></strong><span class="koboSpan" id="kobo.952.1">
    generation.Clear();
    for (int i = 0; i &lt; 200; i++)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">generation.Add(population[i]);</span></strong><span class="koboSpan" id="kobo.954.1">
    }
    for (int i = 0; i &lt; 800; i++)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.955.1">Individual p1 = population[random.Next(400)];</span></strong><span class="koboSpan" id="kobo.956.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.957.1">Individual p2 = population[random.Next(400)];</span></strong><span class="koboSpan" id="kobo.958.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.959.1">Individual offspring = Mate(p1, p2);</span></strong><span class="koboSpan" id="kobo.960.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">generation.Add(offspring);</span></strong><span class="koboSpan" id="kobo.962.1">
    }
    population.Clear();
    </span><strong class="bold"><span class="koboSpan" id="kobo.963.1">population.AddRange(generation);</span></strong><span class="koboSpan" id="kobo.964.1">
    Print();
    generationNo++;
}</span></pre> <p><span class="koboSpan" id="kobo.965.1">The most interesting part is located in the infinite </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">while</span></strong><span class="koboSpan" id="kobo.967.1"> loop. </span><span class="koboSpan" id="kobo.967.2">Here, you sort the population from the best fitted to survive – that is, by fitness in decreasing order. </span><span class="koboSpan" id="kobo.967.3">To explain it in detail, fitness is equal to 0 when no chars in the chromosome string match the following chars in the target</span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.968.1"> string. </span><span class="koboSpan" id="kobo.968.2">In turn, fitness is equal to 33 (i.e., the number of chars in the book title), when the chromosome string is equal to the target string. </span><span class="koboSpan" id="kobo.968.3">For this reason, if the first element from the population (namely the fittest) has a fitness equal to the target string length, it means that the solution is found, so you just print it and exit </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">the loop.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">Otherwise, you clear the list with data of a new generation and add 200 best-fitted individuals to it. </span><span class="koboSpan" id="kobo.970.2">This means that </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">20% of the best-fitted individuals are moved automatically to the next generation</span></strong><span class="koboSpan" id="kobo.972.1">. </span><span class="koboSpan" id="kobo.972.2">For the remaining 800 places in the new generation, you perform </span><strong class="bold"><span class="koboSpan" id="kobo.973.1">crossover</span></strong><span class="koboSpan" id="kobo.974.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">randomly choose parents, from 40% of the best-fitted individuals, to generate new individuals</span></strong><span class="koboSpan" id="kobo.976.1">. </span><span class="koboSpan" id="kobo.976.2">Then, you replace the current population with the new generation and proceed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">next iteration.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">It’s worth mentioning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">Individual</span></strong><span class="koboSpan" id="kobo.980.1"> record, the code for which is </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.982.1">
record </span><strong class="bold"><span class="koboSpan" id="kobo.983.1">Individual</span></strong><span class="koboSpan" id="kobo.984.1">(string Chromosome, int Fitness);</span></pre> <p><span class="koboSpan" id="kobo.985.1">It contains two properties, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">Chromosome</span></strong><span class="koboSpan" id="kobo.987.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">Fitness</span></strong><span class="koboSpan" id="kobo.989.1">. </span><span class="koboSpan" id="kobo.989.2">The first stores the string adjusted in the evolution, while the other is the number indicating how this particular individual is fit to survive. </span><span class="koboSpan" id="kobo.989.3">Of course, a higher value </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">is better.</span></span></p>
<p><span class="koboSpan" id="kobo.991.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">Mate</span></strong><span class="koboSpan" id="kobo.993.1"> method is used to generate a new individual using </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">two parents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.995.1">
Individual </span><strong class="bold"><span class="koboSpan" id="kobo.996.1">Mate</span></strong><span class="koboSpan" id="kobo.997.1">(Individual p1, Individual p2)
{
    string child = string.Empty;
    for (int i = 0; i &lt; Target.Length; i++)
    {
        float r = random.Next(101) / 100.0f;
        </span><strong class="bold"><span class="koboSpan" id="kobo.998.1">if (r &lt; 0.45f) { child += p1.Chromosome[i]; }</span></strong><span class="koboSpan" id="kobo.999.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">else if (r &lt; 0.9f) { child += p2.Chromosome[i]; }</span></strong><span class="koboSpan" id="kobo.1001.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1002.1">else { child += GetRandomGene(); }</span></strong><span class="koboSpan" id="kobo.1003.1">
    }
    return new Individual(child, GetFitness(child));
}</span></pre> <p><span class="koboSpan" id="kobo.1004.1">The most interesting part of this method is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">for</span></strong><span class="koboSpan" id="kobo.1006.1"> loop in which the chromosome of the child is created, according to</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.1007.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">following rules:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1009.1">Approximately 45% of genes are taken from the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1010.1">first parent</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1011.1">Approximately 45% of genes are taken from the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1012.1">second parent</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1013.1">The remaining 10% </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1014.1">are randomized</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1015.1">And how can you get a random single gene or generate a random whole chromosome? </span><span class="koboSpan" id="kobo.1015.2">You just take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1017.1">
char </span><strong class="bold"><span class="koboSpan" id="kobo.1018.1">GetRandomGene</span></strong><span class="koboSpan" id="kobo.1019.1">() =&gt; Genes[random.Next(Genes.Length)];
string </span><strong class="bold"><span class="koboSpan" id="kobo.1020.1">GetRandomChromosome</span></strong><span class="koboSpan" id="kobo.1021.1">()
{
    string chromosome = string.Empty;
    for (int i = 0; i &lt; Target.Length; i++)
    {
        chromosome += GetRandomGene();
    }
    return chromosome;
}</span></pre> <p><span class="koboSpan" id="kobo.1022.1">The next necessary method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">GetFitness</span></strong><span class="koboSpan" id="kobo.1024.1">, which simply returns the number of characters that matches the target book title. </span><span class="koboSpan" id="kobo.1024.2">Its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1026.1">
int </span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">GetFitness</span></strong><span class="koboSpan" id="kobo.1028.1">(string chromosome)
{
    int fitness = 0;
    for (int i = 0; i &lt; Target.Length; i++)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1029.1">if (chromosome[i] == Target[i]) { fitness++; }</span></strong><span class="koboSpan" id="kobo.1030.1">
    }
    return fitness;
}</span></pre> <p><span class="koboSpan" id="kobo.1031.1">Finally, let’s take a look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">Print</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1034.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1035.1">Print</span></strong><span class="koboSpan" id="kobo.1036.1">() =&gt; Console.WriteLine(
    $"Generation {generationNo:D2}:
    {population[0].Chromosome} / {population[0].Fitness}");</span></pre> <p><span class="koboSpan" id="kobo.1037.1">When you run the code, the</span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.1038.1"> best-fitted individual from each generation is presented, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1040.1">
Generation 00: UvWvvtycVTYAsJYxXZpanLkj#rDrmDIEI / 4
Generation 01: sXDGuQQDPnbjpRvWZs evqRNlg#yiwIPL / 5
Generation 02: j#TvvtmKToXuTjxBegpaCLkmNsornzg R / 7
Generation 03: fZCUBIT QrnuzwuWTskTOf bezodQwhmM / 8
Generation 04: CyDwafZZpinLziuPgs yID AevGrGf bs / 9
Generation 05: C# ZaBawSWwLoturSXOcIq wLeSgQOhme / 12 (...)
Generation 10:  Sboats ttrDcterus Mnt jmvGrifhms / 17 (...)
Generation 15: C kData ltrCkteres entbAagorZthmD / 21 (...)
Generation 20: C#VDatahStrdcturessanU Al#orithmd / 26 (...)
Generation 25: CZ Data StrunturOs awd Algorithms / 29 (...)
Generation 30: C# Data Structures Qjd Algorithms / 31 (...)
Generation 35: C# Data Structures and Algorothms / 32 (...)
Generation 37: C# Data Structures and Algorithms / 33</span></pre> <p><span class="koboSpan" id="kobo.1041.1">Is this </span><em class="italic"><span class="koboSpan" id="kobo.1042.1">magic</span></em><span class="koboSpan" id="kobo.1043.1">? </span><span class="koboSpan" id="kobo.1043.2">No, it’s just the</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.1044.1"> algorithm you wrote that manages the following generations and evolves the individuals, giving you the </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">expected result.</span></span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor376"/><span class="koboSpan" id="kobo.1046.1">A password guess</span></h1>
<p><span class="koboSpan" id="kobo.1047.1">As an example of a </span><strong class="bold"><span class="koboSpan" id="kobo.1048.1">brute-force algorithm</span></strong><span class="koboSpan" id="kobo.1049.1">, let’s</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.1050.1"> create a program to </span><strong class="bold"><span class="koboSpan" id="kobo.1051.1">generate all possible passwords and trying to guess your secret one</span></strong><span class="koboSpan" id="kobo.1052.1">, which consists of small letters and digits only. </span><span class="koboSpan" id="kobo.1052.2">The program starts with passwords of a length equal to 2 and proceeds </span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">until 8.</span></span></p>
<p><span class="koboSpan" id="kobo.1054.1">The first part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1056.1">
using System.Diagnostics;
using System.Text;
const string secretPassword = "csharp";
</span><strong class="bold"><span class="koboSpan" id="kobo.1057.1">int charsCount = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1058.1">char[] chars = new char[36];</span></strong><span class="koboSpan" id="kobo.1059.1">
for (char c = 'a'; c &lt;= 'z'; c++)
{
    chars[charsCount++] = c;
}
for (char c = '0'; c &lt;= '9'; c++)
{
    chars[charsCount++] = c;
}</span></pre> <p><span class="koboSpan" id="kobo.1060.1">First, you specify a secret password, which you will try to guess in the remaining part of the code. </span><span class="koboSpan" id="kobo.1060.2">Then, you create an array with available characters, namely small letters and digits. </span><span class="koboSpan" id="kobo.1060.3">At the end of this code snippet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">charsCount</span></strong><span class="koboSpan" id="kobo.1062.1"> variable stores the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">available characters.</span></span></p>
<p><span class="koboSpan" id="kobo.1064.1">The most interesting part </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.1065.1">of the code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">for</span></strong><span class="koboSpan" id="kobo.1067.1"> loop, where each iteration represents a particular length of a password, between two and eight chars. </span><span class="koboSpan" id="kobo.1067.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1069.1">
for (int length = 2; length &lt;= 8; length++)
{
    Stopwatch sw = Stopwatch.StartNew();
    int[] indices = new int[length];
    for (int i = 0; i &lt; length; i++) { indices[i] = 0; }
    bool isCompleted = false;
    StringBuilder builder = new();
    long count = 0;
    while (!isCompleted)
    {
        builder.Clear();
        for (int i = 0; i &lt; length; i++)
        {
            builder.Append(chars[indices[i]]);
        }
        </span><strong class="bold"><span class="koboSpan" id="kobo.1070.1">string guess = builder.ToString();</span></strong><span class="koboSpan" id="kobo.1071.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1072.1">if (guess == secretPassword)</span></strong><span class="koboSpan" id="kobo.1073.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1074.1">{</span></strong><span class="koboSpan" id="kobo.1075.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.1076.1">Console.WriteLine("Found.");</span></strong><span class="koboSpan" id="kobo.1077.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1078.1">}</span></strong><span class="koboSpan" id="kobo.1079.1">
        count++;
        if (count % 10000000 == 0)
        {
            Console.WriteLine($" &gt; Checked: {count}.");
        }
        indices[length - 1]++;
        if (indices[length - 1] &gt;= charsCount)
        {
            for (int i = length - 1; i &gt;= 0; i--)
            {
                indices[i] = 0;
                indices[i - 1]++;
                if (indices[i - 1] &lt; charsCount) { break; }
                if (i - 1 == 0 &amp;&amp; indices[0] &gt;= charsCount)
                {
                    isCompleted = true;
                    break;
                }
            }
        }
    }
    sw.Stop();
    int seconds = (int)sw.ElapsedMilliseconds / 1000;
    Console.ForegroundColor = ConsoleColor.White;
    Console.WriteLine($"{length} chars: {seconds}s");
    Console.ResetColor();
}</span></pre> <p><span class="koboSpan" id="kobo.1080.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">indices</span></strong><span class="koboSpan" id="kobo.1082.1"> array has a length equal to the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">length</span></strong><span class="koboSpan" id="kobo.1084.1"> variable. </span><span class="koboSpan" id="kobo.1084.2">Each item stores a current index from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">chars</span></strong><span class="koboSpan" id="kobo.1086.1"> array, indicating the char that is currently placed on the </span><em class="italic"><span class="koboSpan" id="kobo.1087.1">i</span></em><span class="koboSpan" id="kobo.1088.1">-th location in the string. </span><span class="koboSpan" id="kobo.1088.2">In each iteration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">while</span></strong><span class="koboSpan" id="kobo.1090.1"> loop, you change values in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">indices</span></strong><span class="koboSpan" id="kobo.1092.1"> array until </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.1093.1">all possible combinations of the indices </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">are used.</span></span></p>
<p><span class="koboSpan" id="kobo.1095.1">Furthermore, you save the guessed password in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">guess</span></strong><span class="koboSpan" id="kobo.1097.1"> variable, and here, it can be either printed on the console or hashed and compared with the hashed password that you want to guess. </span><span class="koboSpan" id="kobo.1097.2">As this is only a demonstration of a brute-force algorithm, it does not stop its operation when the password is guessed. </span><span class="koboSpan" id="kobo.1097.3">Thus, you can get more performance results and observe what impact the password length has on the required time </span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">for guessing.</span></span></p>
<p><span class="koboSpan" id="kobo.1099.1">As you can see, the brute-force approach is very simple, but what about performance? </span><span class="koboSpan" id="kobo.1099.2">In the preceding code, you can see the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">Stopwatch</span></strong><span class="koboSpan" id="kobo.1101.1">, so you can get some results. </span><span class="koboSpan" id="kobo.1101.2">Generating all possible variants of a password consisting of two chars takes less than 1 millisecond. </span><span class="koboSpan" id="kobo.1101.3">For three- and four-char passwords, the time is also very small, much less than 100 milliseconds. </span><span class="koboSpan" id="kobo.1101.4">For five-char passwords, the time goes up to about two seconds, while generating passwords of a length equal to six chars takes almost a minute. </span><span class="koboSpan" id="kobo.1101.5">If you add a mechanism to hash a password and compare it with the target hash, also taking into account that passwords can also contain capital letters and many other chars, the brute-force algorithm seems to be simply impractical in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">longer passwords.</span></span></p>
<p><span class="koboSpan" id="kobo.1103.1">It is worth mentioning that</span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.1104.1"> the presented performance results were received on my computer and can be different on other devices. </span><span class="koboSpan" id="kobo.1104.2">They are shown only to indicate a trend that as a password length increases, the time necessary to guess it is significantly longer with each added character. </span><span class="koboSpan" id="kobo.1104.3">Thus, it is also a useful tip that you should always use a complicated password that contains small and capital letters, digits, and special characters. </span><span class="koboSpan" id="kobo.1104.4">Of course, the length o</span><a id="_idTextAnchor377"/><span class="koboSpan" id="kobo.1105.1">f the password is </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">also important.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.1107.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1108.1">You just completed the ninth chapter of this book, which examined data structures and algorithms in the context of the C# language. </span><span class="koboSpan" id="kobo.1108.2">This time, we focused on practical examples of algorithms, with code snippets, detailed descriptions, and also brief indications of which types of algorithms the aforementioned examples </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">belong to.</span></span></p>
<p><span class="koboSpan" id="kobo.1110.1">First, you learned how to implement a simple algorithm to calculate a given number from the </span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">Fibonacci series</span></strong><span class="koboSpan" id="kobo.1112.1"> in three variants. </span><span class="koboSpan" id="kobo.1112.2">You saw a simple recursive approach as well as top-down and bottom-up approaches to </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">dynamic programming.</span></span></p>
<p><span class="koboSpan" id="kobo.1114.1">The next example showed the greedy approach to solve the </span><strong class="bold"><span class="koboSpan" id="kobo.1115.1">minimum coin change</span></strong><span class="koboSpan" id="kobo.1116.1"> problem. </span><span class="koboSpan" id="kobo.1116.2">It was followed by the divide-and-conquer algorithm to find the </span><strong class="bold"><span class="koboSpan" id="kobo.1117.1">closest pair of points</span></strong><span class="koboSpan" id="kobo.1118.1"> located on a two-dimensional surface. </span><span class="koboSpan" id="kobo.1118.2">The fourth example presented a recursive way of </span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">generating fractals</span></strong><span class="koboSpan" id="kobo.1120.1"> and drawing them on </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">a bitmap.</span></span></p>
<p><span class="koboSpan" id="kobo.1122.1">The following two examples were related to back-tracking algorithms to solve the </span><strong class="bold"><span class="koboSpan" id="kobo.1123.1">rat in a maze</span></strong><span class="koboSpan" id="kobo.1124.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.1125.1">Sudoku</span></strong><span class="koboSpan" id="kobo.1126.1"> puzzles. </span><span class="koboSpan" id="kobo.1126.2">These examples used recursion </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.1128.1">Another interesting approach involved a genetic algorithm as a subtype of a heuristic algorithm. </span><span class="koboSpan" id="kobo.1128.2">It was used to </span><strong class="bold"><span class="koboSpan" id="kobo.1129.1">guess the title of the book</span></strong><span class="koboSpan" id="kobo.1130.1">, with the rules of the Darwinian theory of evolution and </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">natural selection.</span></span></p>
<p><span class="koboSpan" id="kobo.1132.1">The last example used a brute-force algorithm to </span><strong class="bold"><span class="koboSpan" id="kobo.1133.1">guess a secret password</span></strong><span class="koboSpan" id="kobo.1134.1">, by checking all possible variants of passwords. </span><span class="koboSpan" id="kobo.1134.2">You saw that with the increasing password length, the time necessary to guess it </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">increased significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.1136.1">Now, it is high time to proceed to the overall summary to take a look at all of the data structures that have been presented in the book so far. </span><span class="koboSpan" id="kobo.1136.2">Let’s turn the page and proceed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">last chapter!</span></span></p>
</div>
</body></html>