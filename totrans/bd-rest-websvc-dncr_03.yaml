- en: User Registration and Administration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户注册和管理
- en: We built the foundation of the app in the last chapter, where we also explored
    the HTTP verbs in detail while creating a controller inside the ASP.NET Core Web
    API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了应用程序的基础，同时我们也详细探讨了在ASP.NET Core Web API内部创建控制器时使用的HTTP动词。
- en: Now, we are gradually moving toward an important aspect of the API, called **authentication**.
    Authentication is definitely a required component because of the ease of accessibility
    of the API. Limiting the requests and putting a restriction on them would prevent
    malicious attacks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正逐渐转向API的一个重要方面，称为**身份验证**。由于API的易于访问性，身份验证肯定是一个必需的组件。限制请求并对它们进行限制将防止恶意攻击。
- en: Users of your application, or customers, in our case, need a registration form/interface
    where their details can be grabbed by the system. We will see how to register
    users with the API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序的用户，或者在我们的例子中，客户，需要一个注册表单/界面，以便系统可以抓取他们的详细信息。我们将看到如何使用API注册用户。
- en: After you register and have all the details of the customers, such as *email*
    and *password*, it will be easy for you to identify the requests coming from a
    client. Wait, that is easy, but there are principles we need to follow in order
    to authenticate the user to access our resources. That is where *Basic Authentication*
    and *OAuth Authentication* will come into the picture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在您注册并拥有客户的所有详细信息，如*电子邮件*和*密码*后，您将很容易识别来自客户端的请求。等等，这很简单，但我们需要遵循一些原则来验证用户以访问我们的资源。这就是*基本身份验证*和*OAuth身份验证*将出现的地方。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Why authentication and limiting requests?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要身份验证和限制请求？
- en: Using EF Core for bootstrapping our REST API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EF Core为我们的REST API进行引导
- en: Adding basic authentication to our REST API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的REST API添加基本身份验证
- en: Adding Oauth 2.0 authentication to our service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的服务添加Oauth 2.0身份验证
- en: Defining the client-based API consumption architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义基于客户端的API消费架构
- en: Why authentication and limiting requests?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要身份验证和限制请求？
- en: If I told you that there is a Web API exposed from a particular country's government
    that you can use to get all the details of its citizens, then the first thing
    you would ask me is whether you can extract data from the API or not. That is
    exactly what we will be discussing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，有一个来自特定国家政府的Web API可以用来获取其公民的所有详细信息，那么你首先会问我是否可以从API中提取数据。这正是我们将要讨论的内容。
- en: So, if you take the previous example, the data that comes back from that API
    would have the citizens' sensitive data, such as *name*, *address*, *phone number*,
    *country, and social security number*. The government should never allow everyone
    to access this data. Only authenticated sources are allowed, generally. What that
    means is when you call one API, you need to send your identity and ask to it to
    allow you to operate on the data. If the identity is wrong or not in the list
    of allowed sources, it will be rejected by the API. Imagine terrorists trying
    to access the API, you would definitely deny access by detecting their identity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你看之前的例子，从该API返回的数据将包含公民的敏感数据，例如*姓名*、*地址*、*电话号码*、*国家*和*社会保障号码*。政府绝不应该允许每个人访问这些数据。通常只允许经过身份验证的来源。这意味着当你调用一个API时，你需要发送你的身份并请求它允许你操作数据。如果身份错误或不在允许的来源列表中，它将被API拒绝。想象一下恐怖分子试图访问API，你肯定会通过检测他们的身份来拒绝访问。
- en: Now imagine another scenario, where a university has an API that sends out results
    of a particular semester of a certain course. Many other websites would show the
    results on their site by calling this university API. A hacker comes in and uses
    a code block to call the API in a loop. If the time interval is too small, then
    don't be surprised if you get a Server Busy/Server Unreachable message. That is
    because, with a huge number of requests in a short span of time, the server becomes
    overloaded and runs out of resources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象另一个场景，一个大学有一个API，它会发送特定课程的某个学期的成绩。许多其他网站会通过调用这个大学API在其网站上显示成绩。一个黑客进来并使用代码块循环调用API。如果时间间隔太小，那么如果你收到服务器忙/服务器不可达的消息，请不要感到惊讶。这是因为，在短时间内有大量的请求，服务器会过载并耗尽资源。
- en: That is where imposing limitations on the API not to allow more requests from
    the same source in a particular time interval comes into the picture. For example,
    if any consumer accesses our API, we will not allow the request if the consumer
    has already requested it before in the last 10 seconds or so.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在特定时间间隔内对API施加限制，不允许来自同一来源的更多请求的情况出现。例如，如果任何消费者访问我们的API，如果消费者在过去的10秒左右已经请求过，我们将不允许该请求。
- en: First, let's design the database for our app before exploring other concepts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们探索其他概念之前，让我们为我们的应用程序设计数据库。
- en: Database design
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计
- en: We will definitely have a *Customers* table. We will store customer information
    in that table and use the primary key of this table as a reference in other tables,
    such as *Orders* and *Cart*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定会有一个*Customers*表。我们将在这个表中存储客户信息，并使用该表的键作为其他表，如*Orders*和*Cart*的参考。
- en: 'The Customers table can be designed as follows. You can find the database script,
    named `FlixOneStore.sql`, with this book:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 客户表可以设计如下。您可以在本书中找到名为`FlixOneStore.sql`的数据库脚本：
- en: '![](img/13d529d2-2429-4ed7-9d63-2bd5da584ac6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13d529d2-2429-4ed7-9d63-2bd5da584ac6.png)'
- en: CRUD operations will be performed on these tables from the API. Let's start
    by doing some operations on this table from the API. More precisely, we are talking
    about the customer registration and login process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将在这些表上执行CRUD操作。让我们先从API对这个表进行一些操作。更确切地说，我们正在讨论客户注册和登录过程。
- en: User registration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户注册
- en: Let's get the models into the API first so that we can create an object and
    save data in the database. We will use **Entity Framework Core** (**EF Core**)
    version 2.0.2 for this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先获取模型到API中，这样我们就可以创建一个对象并在数据库中保存数据。我们将使用**Entity Framework Core**（**EF Core**）版本2.0.2来完成这项工作。
- en: Setting up EF with the API
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置API的EF
- en: 'To use EF Core, the following package is required, which can be downloaded
    and installed from NuGet Package Manager inside Tools:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用EF Core，需要以下包，可以从工具中的NuGet包管理器下载和安装：
- en: '![](img/0d8b9441-f7c0-4226-867d-0abc0b97fc64.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d8b9441-f7c0-4226-867d-0abc0b97fc64.png)'
- en: 'Additionally, we need another package named Microsoft.EntityFrameworkCore.Tools.
    This will help us with creating model classes from the database:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要另一个名为Microsoft.EntityFrameworkCore.Tools的包。这将帮助我们根据数据库创建模型类：
- en: '![](img/7be0ab79-59d9-415f-8011-7c78d69294ca.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7be0ab79-59d9-415f-8011-7c78d69294ca.png)'
- en: 'Now, we arrive at the point where we need model classes according to the database
    tables. The following powershell command can be executed inside the package manager
    console to create the model class for the *Customers* table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们到达了需要根据数据库表创建模型类的点。以下powershell命令可以在包管理器控制台中执行，以创建*Customers*表的模型类：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have provided the connection string in the command so that it connects to
    our database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在命令中提供了连接字符串，以便它连接到我们的数据库。
- en: 'The following are two important parts of the command we just explored:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚刚探索的命令的两个重要部分：
- en: '`-OutputDir Models`: This defines the folder in which the model class will
    be placed.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-OutputDir Models`：这定义了模型类将被放置的文件夹。'
- en: '`-Tables Customers`: This defines the table that will be extracted as the model
    class. We will be dealing with *Customers* for now.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Tables Customers`：这定义了将被提取为模型类的表。我们现在将处理*Customers*。'
- en: 'After execution, you will see two files, `Customers.cs` and `FixOneStoreContext.cs`,
    inside the `Models` folder. The `Customers.cs` file will be something like the
    following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您将在`Models`文件夹中看到两个文件，`Customers.cs`和`FixOneStoreContext.cs`。`Customers.cs`文件可能如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Configuring DbContext
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置DbContext
- en: The `context` class can be found in the same folder that has the `OnConfiguring`
    and `OnModelCreating` methods with a property for *Customers*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`类可以在包含`OnConfiguring`和`OnModelCreating`方法以及一个名为*Customers*的属性的同一文件夹中找到。'
- en: 'The following code block shows the `FlixOneStoreContext` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了`FlixOneStoreContext`类：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Did you notice that I have commented the `OnConfiguring` method and added a
    constructor so that we can inject dependencies from startup to initialize the
    context with a connection string? Let's do that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我没有注释`OnConfiguring`方法并添加了一个构造函数，以便我们可以从启动程序中注入依赖项以使用连接字符串初始化上下文吗？让我们这样做。
- en: 'So, inside the `ConfigureServices` startup, we will add the context to the
    services collection using the connection string:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`ConfigureServices`启动程序中，我们将使用连接字符串将上下文添加到服务集合中：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Generating the controller
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成控制器
- en: 'The next step is to add the controller. To do so, refer to the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加控制器。为此，请参考以下步骤：
- en: 'Right-click on the `Controller` folder, then click on Add, followed by Controller.
    You will end up on a modal where you will see options to create different types
    of controllers:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`Controller`文件夹，然后点击添加，接着点击控制器。您将结束在一个模态窗口中，您将看到创建不同类型控制器选项：
- en: '![](img/d624fe8b-4518-4322-b5b3-519aa20bad1a.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d624fe8b-4518-4322-b5b3-519aa20bad1a.png)'
- en: 'Select API Controller with actions, using Entity Framework and click on the
    Add button. The following screenshot shows what happens next:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择使用Entity Framework的API控制器和操作，然后点击添加按钮。以下截图显示了接下来会发生什么：
- en: '![](img/dea4c3e2-3769-40b1-8ac8-c9c3224528b9.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dea4c3e2-3769-40b1-8ac8-c9c3224528b9.png)'
- en: 'Click on Add. *Voila!* It did all that hard work and created a fully fledged
    controller using EF Core with actions using all major HTTP verbs. The following
    code block is a small snapshot of the controller with the `GET` methods only.
    I have removed other methods to save space:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加。*哇!*它完成了所有艰苦的工作，并使用EF Core创建了一个完整的控制器，使用了所有主要的HTTP动词。以下代码块是控制器中仅包含`GET`方法的小快照。我已经删除了其他方法以节省空间：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Some points to note here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意以下几点：
- en: 'Notice how `FlixOneStoreContext` is initialized here by injecting it into the
    constructor. Further more, it will be used for database-related operations inside
    all actions:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意`FlixOneStoreContext`是如何在这里通过将其注入构造函数来初始化的。此外，它将在所有操作中用于数据库相关操作：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next thing to focus on is the methods used to return the results from the
    actions. See how `BadRequest()`, `NotFound()`, `Ok()`, and `NoContent()` are used
    to return proper HTTP response codes that can be easily understood by clients.
    We will see what codes they return in a while when we call these actions to perform
    real tasks.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来要关注的是用于从操作中返回结果的方法。看看`BadRequest()`、`NotFound()`、`Ok()`和`NoContent()`是如何被用来返回易于客户端理解的正确HTTP响应代码的。我们将在稍后调用这些操作执行实际任务时看到它们返回什么代码。
- en: Calling the API from a page to register the customer
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从页面调用API以注册客户
- en: 'To simplify things, I have designed a simple HTML page with controls for a
    customer record, as follows. We will input data and try to call the API in order
    to save the record:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我设计了一个简单的HTML页面，其中包含客户记录的控制按钮，如下所示。我们将输入数据并尝试调用API以保存记录：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I have used bootstrap and *jQuery* with my code. You can refer to the whole
    code in the attached files with the book or refer to [https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的代码中使用了bootstrap和*jQuery*。您可以在附带的文件中查看整个代码，或者参考[https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)。
- en: 'Now comes the important part of the code, where we will call the API to store
    the customer record. Refer to the following code block:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是代码的重要部分，我们将调用API来存储客户记录。请参考以下代码块：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice the `http://localhost:57571/api/Customers` URL and `POST` HTTP method.
    This eventually calls the `Post` method present in the API named `PostCustomers`.
    We will definitely have some uniqueness in the table, and in our case, I am taking
    email as unique for each record. That''s why I need to modify the `action` method
    a little bit:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`http://localhost:57571/api/Customers` URL和`POST` HTTP方法。这最终会调用名为`PostCustomers`的API中的`Post`方法。我们肯定会在表中有一些唯一性，在我们的例子中，我将电子邮件视为每条记录的唯一标识。这就是为什么我需要稍微修改一下`action`方法：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I am returning `BadRequest()` by adding an error message for the model property
    email. We will see how this is shown on the browser shortly!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过为模型属性电子邮件添加错误消息来返回`BadRequest()`。我们将在稍后看到如何在浏览器上显示这个错误！
- en: 'The following image captured from the browser shows you a successful *customer*
    creation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从浏览器捕获的图片显示了成功创建*客户*的情况：
- en: '![](img/fdfb7a93-b70c-4ab5-9bc7-dcfaea41c97b.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdfb7a93-b70c-4ab5-9bc7-dcfaea41c97b.png)'
- en: A successful registration of a *customer* would look something like the preceding
    image, which shows us the success message in the alert as we have that inside
    the `success` method of the ajax call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 成功注册一个*客户*将类似于前面的图片，它显示了我们在ajax调用中的`success`方法内的成功消息。
- en: 'You can perform anything you want with the data received from the `action`
    method upon completion, as it returns the whole `customer` object. If you don''t
    believe me, refer to the following screenshot from the source window of the debugger
    tool:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`action`方法完成后对从`action`方法接收到的数据进行任何操作，因为它返回整个`customer`对象。如果你不相信我，请参考以下调试工具源窗口的截图：
- en: '![](img/1f43ff98-4614-4c25-9636-e1bb5afc27d5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f43ff98-4614-4c25-9636-e1bb5afc27d5.png)'
- en: The response to the POST request with the new Customer created inside the jQuery
    Ajax success method
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在jQuery Ajax成功方法中创建新客户后的POST请求的响应
- en: 'So, who did this? Simple, the following return statement, which is inside the
    `POST` method, does all the magic:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是谁做的这件事？简单，以下这个返回语句，它位于`POST`方法内部，完成了所有的魔法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This particular line does a couple of things:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行做了几件事情：
- en: 'Sends Status Code: 201 Created as the `POST` action successfully created the
    resource.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送状态码：201 已创建，因为`POST`操作成功创建了资源。
- en: Sets a Location header with the actual URL for the resource. If you remember
    RESTful characteristics, after the `POST` action, the server should send the URL
    of the resource. That is what it does.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个带有资源实际URL的位置头。如果你记得RESTful特性，在`POST`操作之后，服务器应该发送资源的URL。这正是它所做的事情。
- en: 'Let me show you the network tab of developer tools to prove my point. You can
    also use *Postman* and analyze it. The following screenshot shows you the response
    details:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过展示开发者工具的网络标签来证明我的观点。你也可以使用*Postman*并分析它。以下截图显示了响应细节：
- en: '![](img/0e5ced39-c692-4874-9748-3678ffcec256.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e5ced39-c692-4874-9748-3678ffcec256.png)'
- en: The response received by a POST success request with Status Code and Location
    Header
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的带有状态码和位置头的POST成功请求的响应
- en: '`Guid` is actually the `Customer ID` as we have defined it in the column type
    in database, and I am assigning the value to it inside the `Customer` model class
    constructor.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guid`实际上是`Customer ID`，正如我们在数据库中的列类型中定义的那样，我在`Customer`模型类的构造函数中为其赋值。'
- en: 'Now, if you copy this URL and open it in your browser or Postman, you will
    get the details of the customer, as the following screenshot shows you:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你复制这个URL并在浏览器或Postman中打开它，你将得到客户的详细信息，如下面的截图所示：
- en: '![](img/0361fdff-75a5-40c2-9b8e-831b0a2b1c3b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0361fdff-75a5-40c2-9b8e-831b0a2b1c3b.png)'
- en: 'Let''s see a `BadRequest()` example with a mail ID that already exists. As
    the `taditdash@gmail.com` customer already exists, sending another request with
    the same email ID should send us an error message as a response. Let''s have a
    look:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个带有已存在邮件ID的`BadRequest()`示例。由于`taditdash@gmail.com`客户已经存在，使用相同的电子邮件ID发送另一个请求应该会发送一个错误消息作为响应。让我们看看：
- en: '![](img/b705c323-5591-45a6-955c-0faf6bf710b4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b705c323-5591-45a6-955c-0faf6bf710b4.png)'
- en: Remember, we added a line to check the email ID existence and added a `ModelState`
    error. That is in action now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们添加了一行来检查电子邮件ID的存在，并添加了一个`ModelState`错误。现在它正在执行。
- en: For simplicity of the demo in this book, I am just saving a plain text password.
    You should not do that in the actual project. Implementing proper encryption for
    a password is a must.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本书中的演示，我只是保存了纯文本密码。你实际上不应该这样做。实现密码的正确加密是必须的。
- en: With this, I would end the registration process. However, there is scope to
    implement validation at the client side as well as at the server side. You can
    add attributes to the `Model` class properties to make it solid so that you don't
    get bad data from clients. Send a `BadRequest()` response when `ModelState` validation
    fails. Required email-format and password-comparison attributes can be added to
    the `Model` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，我将结束注册过程。然而，在客户端和服务器端实施验证都有空间。你可以在`Model`类的属性中添加属性，使其更加稳固，这样你就不会从客户端收到不良数据。当`ModelState`验证失败时，发送一个`BadRequest()`响应。可以给`Model`类添加必需的电子邮件格式和密码比较属性。
- en: CORS
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CORS
- en: 'If you see the following error when you call the API action, then you need
    to enable **Cross Origin Resource Sharing** (**CORS**):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用API操作时看到以下错误，那么你需要启用**跨源资源共享**（**CORS**）：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To enable CORS for all origins, follow the steps shown ahead:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要为所有来源启用CORS，请按照以下步骤操作：
- en: 'Install the `Microsoft.AspNetCore.Cors` NuGet package:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`Microsoft.AspNetCore.Cors` NuGet包：
- en: '![](img/22cabbf2-3499-49f6-a794-536a0950a562.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22cabbf2-3499-49f6-a794-536a0950a562.png)'
- en: 'Inside `Startup ConfigureServices`, add the following code to implement a policy
    for CORS that would allow all origins:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup ConfigureServices`内部，添加以下代码以实现一个允许所有来源的CORS策略：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the `Configure` method, add the following line before `app.UseMvc();`
    (it''s important):'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Configure` 方法中，在 `app.UseMvc();` 之前添加以下行（这是很重要的）：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, it should work as expected. If you want to explore CORS more, visit [https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1](https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它应该按预期工作。如果您想了解更多关于 CORS 的信息，请访问 [https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1](https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1)。
- en: Adding basic authentication to our REST API
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基本认证添加到我们的 REST API 中
- en: Now that we registered the *customer*, we can move towards the authentication
    process. Authentication is to verify whether a *customer* is a valid user of our
    site or not. We already have their credentials with us since they registered using
    our registration form. When they try to access any resource from our site using
    those credentials, we will verify first and then allow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了 *客户*，我们可以转向认证过程。认证是为了验证 *客户* 是否是我们站点的有效用户。由于他们使用我们的注册表单进行了注册，我们已经有了他们的凭据。当他们尝试使用这些凭据从我们的网站访问任何资源时，我们将首先进行验证，然后允许访问。
- en: Registration will be allowed for everyone and won't be authenticated. However,
    when a *customer* wants to *read their profile details* or *delete their account,*
    and so on, then we need authentication in place so that the data is returned to
    users who are actual trusted users of the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注册将允许所有人进行，且不需要认证。然而，当 *客户* 想要 *读取他们的个人资料详情* 或 *删除他们的账户* 等操作时，我们需要设置认证，以确保数据返回给实际信任的应用程序用户。
- en: 'For *basic authentication*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *基本认证*：
- en: We will get the *username*, which will be the *email ID* and *password* from
    the client while they request a resource. This will be sent with HTTP headers.
    We will see it when we design the client.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将获取 *用户名*，它将是客户端请求资源时的 *电子邮件 ID* 和 *密码*。这将通过 HTTP 头部发送。当设计客户端时，我们将看到它。
- en: Then, that data will be verified from the database.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将从数据库验证这些数据。
- en: If found, the operation will be allowed, otherwise a `401 Unauthorized` response
    will be sent.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到，将允许操作，否则将发送一个 `401 未授权` 响应。
- en: Step 1 – Adding the (authorize) attribute
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1步 – 添加 (授权) 属性
- en: Let's restrict the action method that is returning the *customer* profile details,
    the `GET` method of `CustomersController` named `GetCustomers([FromRoute] Guid
    id)`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们限制返回 *客户* 个人资料详情的动作方法，即 `CustomersController` 的 `GET` 方法，命名为 `GetCustomers([FromRoute]
    Guid id)`。
- en: 'We will verify the following two things when a *customer* is trying to access
    the profile:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *客户* 尝试访问个人资料时，我们将验证以下两点：
- en: The request is coming from a trusted user of the application. Meaning, the request
    is coming from a *customer* having a valid *email* and *password*.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求来自应用程序的信任用户。这意味着请求来自拥有有效 *电子邮件* 和 *密码* 的 *客户*。
- en: The customer can only access their profile. To check this, we will verify the
    *customer's* credentials (present in the request) with the requested *customer's*
    ID on the URL.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户只能访问他们的个人资料。为了检查这一点，我们将验证 *客户* 的凭据（存在于请求中）与 URL 上请求的 *客户* ID。
- en: 'Let''s get started. Remember that our goal is to achieve the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。记住，我们的目标是实现以下内容：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For now, we will focus our attention on this action method to understand the
    concept. You can see the `Authorize` attribute with an `AuthenticationScheme`
    defined as `Basic` here. That means we have to tell the runtime what the *basic
    authentication* is so that it will execute that first before going into the action
    method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于这个动作方法来理解这个概念。您可以看到这里定义了 `AuthenticationScheme` 为 `Basic` 的 `Authorize`
    属性。这意味着我们必须告诉运行时什么是 *基本认证*，这样它就会在进入动作方法之前先执行。
- en: If the authentication succeeds, the action method will be executed, otherwise
    a 401 Unauthorized response will be sent to the client.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证成功，动作方法将被执行，否则将向客户端发送一个 401 未授权响应。
- en: Step 2 – Designing BasicAuthenticationOptions and BasicAuthenticationHandler
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 – 设计 BasicAuthenticationOptions 和 BasicAuthenticationHandler
- en: 'First of all, we need a class that would derive the `AuthenticationSchemeOptions`
    class present in `Microsoft.AspNetCore.Authentication`, as shown in the following
    code block:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个类，该类将继承 `Microsoft.AspNetCore.Authentication` 中存在的 `AuthenticationSchemeOptions`
    类，如下面的代码块所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is left blank for simplicity but can be loaded with different properties.
    We will not go into that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这里留空，但可以加载不同的属性。我们不会深入探讨这一点。
- en: 'Next, we need a handler for *basic authentication*, where we will have our
    actual logic:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个用于*基本认证*的处理程序，我们将在这里实现实际的逻辑：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can have its constructor-like following with an extra `DbContext` param
    as we will validate the *customer* details from the database:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在其构造函数-like后面添加一个额外的`DbContext`参数，因为我们将从数据库中验证*客户*的详细信息：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`AuthenticationHandler<T>` is an abstract class having properties and methods
    related to authentication especially. We will be overriding two methods, for now,
    `HandleAuthenticateAsync` and `HandleChallengeAsync`. `HandleAuthenticateAsync`
    will have actual logic to authenticate the customer and `HandleChallengeAsync`
    is used to deal with 401 challenge concerns, meaning whenever you decide that
    *customer* is not valid, codes can be written in this method to deal with that
    situation.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticationHandler<T>`是一个具有与认证特别相关的属性和方法的高级类。目前我们将重写两个方法，`HandleAuthenticateAsync`和`HandleChallengeAsync`。`HandleAuthenticateAsync`将包含验证客户的实际逻辑，而`HandleChallengeAsync`用于处理401挑战问题，这意味着每当决定*客户*无效时，可以在该方法中编写代码来处理这种情况。'
- en: 'We are assuming that we will receive the email and password in the HTTP header
    called `Authorization` separated by a delimiter colon (`:`). The following is
    the code to extract the data from the header and validate whether it is correct
    or not:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们将通过名为`Authorization`的HTTP头接收电子邮件和密码，它们由分隔符冒号（`:`）分隔。以下是从头中提取数据并验证其是否正确的代码：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code is very easy to understand. I have added the steps over code blocks.
    Basically, we are trying to validate the header and then process it to see whether
    they are correct. If correct, then create the `ClaimsIdentity` object, which can
    be further used in the application. We will do that in the next section. At each
    step, if validation fails, we send `AuthenticateResult.NoResult()` or `AuthenticateResult.Fail()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常容易理解。我在代码块中添加了步骤。基本上，我们正在尝试验证头部，然后处理它以查看它们是否正确。如果正确，则创建`ClaimsIdentity`对象，这可以在应用程序中进一步使用。我们将在下一节中这样做。在每一步中，如果验证失败，我们发送`AuthenticateResult.NoResult()`或`AuthenticateResult.Fail()`。
- en: 'Let''s work on attaching this authentication to our action method, using something
    like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这个认证附加到我们的操作方法上，使用以下类似的方法：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Step 3 – Registering basic authentication at startup
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 – 在启动时注册基本认证
- en: 'Looks like everything is set up, however, we have missed one step of registering
    this basic authentication in the startup. Otherwise, how could the `BasicAuthenticationHandler`
    handler be called? Have a look:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都已经设置好了，然而，我们遗漏了在启动时注册这个基本认证的一个步骤。否则，`BasicAuthenticationHandler`处理程序是如何被调用的呢？看看下面的代码：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test the API, you can design an HTML page to show the profile of the user
    by getting details from the API using the `Id`. You can use the *jQuery Ajax*
    call to the API and operate on the result received:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试API，你可以设计一个HTML页面，通过使用`Id`从API获取详细信息来显示用户的个人资料。你可以使用对API的*jQuery Ajax*调用并操作接收到的结果：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the header part where we have the `Authorization` header mentioned with
    `email` and `password` separated by a colon (`:`) and passed to the `btoa` method,
    which is responsible for Base64 encryption. After you get the result, you can
    do *n* number of things. The following screenshot shows it on the page using some
    bootstrap designing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到头部部分，其中提到了带有冒号（`:`）分隔的`Authorization`头，其中包含`email`和`password`，并将其传递给`btoa`方法，该方法负责Base64加密。在你得到结果后，你可以做*许多*事情。以下截图显示了使用一些bootstrap设计在页面上展示的情况：
- en: '![](img/3c735c15-2fd7-4ca7-b798-4622722d9f87.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c735c15-2fd7-4ca7-b798-4622722d9f87.png)'
- en: Now, there is an important code block that should be included with the previous
    handler code. That is another `HandleChallengeAsync` method that should be overridden.
    The purpose of this method is to handle the situation when the authentication
    fails.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个重要的代码块应该与之前的处理程序代码一起包含。那就是另一个需要重写的`HandleChallengeAsync`方法。这个方法的目的是在认证失败时处理情况。
- en: 'We will just send one header with the response, named `WWW-Authenticate`, whose
    value can be set with a `realm`. Have a look at the code first and then I will
    explain:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只发送一个带有响应的头部，名为`WWW-Authenticate`，其值可以用`realm`设置。先看看代码，然后我会解释：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If a client tries to access a restricted resource or a resource that requires
    authentication, it's the server's responsibility to inform the client about the
    authentication type and related information. The `WWW-Authenticate` HTTP response
    header is set by the server that defines the authentication method that should
    be used to gain access to the restricted resource requested.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端尝试访问受限制的资源或需要认证的资源，那么通知客户端关于认证类型和相关信息的责任在于服务器。`WWW-Authenticate` HTTP响应头由定义了应使用何种认证方法来获取请求的受限制资源的服务器设置。
- en: 'So, it''s obvious that the `WWW-Authenticate` header is sent along with a 401
    Unauthorized response. The string contains three things: *Authentication Type*,
    *Realm*, and *Charset*. The realm is the domain or area where the authentication
    will be valid.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，`WWW-Authenticate`头会与401未授权响应一起发送。该字符串包含三个东西：*认证类型*、*域*和*字符集*。域是认证有效的域名或区域。
- en: In our case, the scheme is `Basic`, Realm is `http://localhost:57571`, and Charset
    is `UTF-8`. Therefore, if the client provides the basic authentication params
    as `Username` and `Password`, those will be valid in the `localhost:57571` domain.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，方案是`Basic`，域是`http://localhost:57571`，字符集是`UTF-8`。因此，如果客户端提供了基本认证参数作为`用户名`和`密码`，那么这些在`localhost:57571`域中将是有效的。
- en: 'That is what it signifies. So, just remove the header assigning a code or comment
    it out to test this. The following is the screenshot from the Network tab of the
    developer tool in Chrome:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的含义。所以，只需移除分配代码的标题或将其注释掉以进行测试。以下是从Chrome的开发者工具网络标签页的截图：
- en: '![](img/51293f33-d7e5-4bb1-8877-8d78738f0569.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51293f33-d7e5-4bb1-8877-8d78738f0569.png)'
- en: 'Have a look at the following screenshot of an alert message, which we have
    inside the error method of the Ajax call. This happens when the API action is
    called without any credentials:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '看看以下截图中的警告消息，这是我们在Ajax调用的错误方法中包含的。当API操作在没有凭证的情况下被调用时，会发生这种情况：  '
- en: '![](img/066f2093-32e1-4cb7-a809-90ec7d3b7324.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/066f2093-32e1-4cb7-a809-90ec7d3b7324.png)'
- en: Adding OAuth 2.0 authentication to our service
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将OAuth 2.0认证添加到我们的服务中
- en: OAuth is an open standard used by APIs to control access to the resources by
    clients, such as websites, desktop applications, or even other APIs. However,
    the API implementing OAuth can provide user information without sharing the password
    with third-party apps.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一个开放标准，由API用于控制客户端（如网站、桌面应用程序甚至其他API）对资源的访问。然而，实现OAuth的API可以在不与第三方应用共享密码的情况下提供用户信息。
- en: You must have seen websites where they allow logins using different services,
    such as Facebook, Twitter, or Google, saying something such as (for Facebook)
    Login with Facebook. That means Facebook has an OAuth server that would validate
    your app by a certain identity that you have provided to Facebook earlier, and
    give you an access token that would have some validity. Using that token, you
    can read the required user's profile.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过允许使用不同服务（如Facebook、Twitter或Google）登录的网站，比如（对于Facebook）使用Facebook登录。这意味着Facebook有一个OAuth服务器，它会通过你之前提供给Facebook的某个身份验证你的应用程序，并给你一个有效的访问令牌。使用该令牌，你可以读取所需用户的个人资料。
- en: 'The following is some basic OAuth2.0 terminology:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些基本的OAuth2.0术语：
- en: '**Resource:** We have already defined this in previous chapters. Resources
    are the things that we need to protect. That may be any information related to
    our system.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源：** 我们已经在之前的章节中定义了这一点。资源是我们需要保护的东西。这可能与我们系统相关的任何信息。'
- en: '**Resource server:** This is the server that would protect the resource, mostly
    the API that we have designed to access our eCommerce database.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器：** 这是保护资源的服务器，通常是用来访问我们电子商务数据库的API。'
- en: '**Resource owner:** The person who would grant us access to a particular resource.
    Mostly the users are the owners, and as you have seen when you click on Login
    with Facebook, it will ask for your login and consent.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者：** 将授予我们访问特定资源的人。大多数情况下，用户是所有者，正如你点击使用Facebook登录时所见，它会要求你的登录和同意。'
- en: '**Client:** The app that wants our resource access. In our case, it is the
    browser that is trying to access the resources when *jQuery* codes are executed
    on the HTML pages we designed.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端：** 希望访问我们资源的应用程序。在我们的例子中，它是当在设计的HTML页面上执行*jQuery*代码时尝试访问资源的浏览器。'
- en: '**Access token:** This is actually the pillar of this architecture. The OAuth
    server that we will design should provide a token using the credentials of the
    user for subsequent access to our resources, as we know OAuth standard tells us
    not provide passwords to clients.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**：这实际上是这个架构的基石。我们将要设计的 OAuth 服务器应该使用用户的凭证来提供令牌，以便后续访问我们的资源，正如我们所知，OAuth
    标准告诉我们不要向客户端提供密码。'
- en: '**Bearer token:** This is a particular type of access token that allows anyone
    to use the token easily, meaning, in order to use the token for resource access,
    a client doesn''t need a cryptographic key or other secret keys. As this is less
    secure than other types of tokens, bearer tokens should only be used over HTTPs
    and should expire in a short amount of time.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bearer 令牌**：这是一种特定的访问令牌，允许任何人轻松地使用该令牌，这意味着，为了使用令牌进行资源访问，客户端不需要加密密钥或其他秘密密钥。由于这比其他类型的令牌安全性较低，Bearer
    令牌应仅在 HTTPS 上使用，并且应在短时间内过期。'
- en: '**Authorization server:** This is the server providing the access token to
    the client.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：这是向客户端提供访问令牌的服务器。'
- en: 'Let''s start adding OAuth to our Web API. We are going to use IdentityServer4,
    which is a free, open source OpenID Connect and OAuth 2.0 framework for ASP.NET
    Core. The project can be found here: [https://github.com/IdentityServer](https://github.com/IdentityServer).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始将 OAuth 添加到我们的 Web API 中。我们将使用 IdentityServer4，这是一个免费的、开源的 OpenID Connect
    和 OAuth 2.0 框架，适用于 ASP.NET Core。项目可以在以下位置找到：[https://github.com/IdentityServer](https://github.com/IdentityServer)。
- en: 'IdentityServer ([http://identityserver.io/](http://identityserver.io/)) is
    based on OWIN/Katana, but to our knowledge, it is distributed and available as
    a NuGet package. In order to start on IdentityServer, install the following two
    NuGet Packages:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: IdentityServer ([http://identityserver.io/](http://identityserver.io/)) 基于 OWIN/Katana，但据我们所知，它作为分布式软件包以
    NuGet 包的形式提供。为了开始使用 IdentityServer，请安装以下两个 NuGet 包：
- en: '![](img/0c04f874-1ab5-4675-a2d3-4c06a25d577a.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c04f874-1ab5-4675-a2d3-4c06a25d577a.png)'
- en: The *authorization server* in a production scenario is ideally isolated from
    the main web API. But for this book, we will directly put that in the same Web
    API project for simplicity. We are not using the default ASP.NET Core Identity.
    We will be using our own set of tables. For instance, we will use our *customer*
    table details for verification.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产场景中，理想情况下，授权服务器应与主 Web API 分离。但为了这本书的简单起见，我们将直接将其放入同一个 Web API 项目中。我们不使用默认的
    ASP.NET Core Identity。我们将使用我们自己的表格集。例如，我们将使用我们的 *客户* 表的详细信息进行验证。
- en: Step 1 – Designing the Config class
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步 – 设计 Config 类
- en: 'The `Config` class holds important details of the authorization server, such
    as *Resources*, *Clients*, and *Users*. These details are used while generating
    the token. Let''s design it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Config` 类包含了授权服务器的重要细节，例如 *资源*、*客户端* 和 *用户*。这些细节在生成令牌时会被使用。让我们来设计它：'
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`ApiResource` is used to declare different scopes and claims for the API. For
    a simple case, an API might have one simple resource structure where it would
    give access to all clients. However, in a typical scenario, clients can be restricted
    to access different parts of the API. While declaring the clients, we will use
    these resources in order to configure their scope and access rights. `ReadAccess`
    and `FullAccess` are two different resource types that can be used with clients
    to give read and full access, respectively.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiResource` 用于声明 API 的不同作用域和声明。对于简单的情况，一个 API 可能有一个简单的资源结构，它将向所有客户端提供访问权限。然而，在典型场景中，客户端可以限制访问
    API 的不同部分。在声明客户端时，我们将使用这些资源来配置它们的作用域和访问权限。`ReadAccess` 和 `FullAccess` 是两种不同的资源类型，可以与客户端一起使用，分别提供读取和完全访问权限。'
- en: Basically, the methods that we are designing now will be called on `Startup`.
    Here, `GetApiResources` is actually creating two types of resource with different
    settings. The first one is what we will be dealing with for the moment. We have
    named it `FlixOneStore.ReadAccess`. You can see a list of strings with `Id`, `Name`,
    and so on, these are the details of the customer that will be generated with the
    token and passed to the client.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们现在设计的这些方法将在 `Startup` 中被调用。在这里，`GetApiResources` 实际上是在创建两种不同设置的资源。第一种就是我们目前将要处理的。我们将其命名为
    `FlixOneStore.ReadAccess`。您可以看到一个包含 `Id`、`Name` 等字符串的列表，这些都是将与令牌一起生成并传递给客户端的客户详细信息。
- en: 'Let''s add details for a client from where we will consume the authorization
    server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个客户端的详细信息，我们将从该客户端消费授权服务器：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can add a number of clients as per your needs. You can set *client id*,
    *client secret,* and *grant types* according to OAuth standards in this method.
    Notice the secret password is set as `secretpassword`. You can set any string
    here; it can be a `Guid`. Here, `GrantType.ResourceOwnerPassword` defines the
    way we will validate the incoming request to generate tokens.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要添加多个客户端。您可以在该方法中设置*客户端ID*、*客户端密钥*和*授权类型*，根据OAuth标准。注意，密码设置为`secretpassword`。您可以在这里设置任何字符串；它可以是`Guid`。在这里，`GrantType.ResourceOwnerPassword`定义了我们验证传入请求以生成令牌的方式。
- en: It says to the *Authorization Server*, "Hey look for `username` and `password`
    inside the request body." There are other types of Grant available. You can explore
    more on the official documentation link.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉**授权服务器**，“嘿，在请求体中查找`username`和`password`。”还有其他类型的授权可用。您可以在官方文档链接中了解更多信息。
- en: You might have a question now! What are we going to do with `username` and `password`?
    Of course, we will validate them, but with what? The answer is the `Email` and
    `Password` fields from the `Customers` table. We have not done anything related
    to connecting *Authorization Server* with the *Customers* table. That is what
    we will do next. But before that, let's register these settings at `Startup`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能有一个问题！我们将如何处理`username`和`password`？当然，我们将验证它们，但用什么呢？答案是来自`Customers`表的`Email`和`Password`字段。我们还没有做任何与将**授权服务器**与**客户端**表连接相关的事情。这就是我们接下来要做的。但在那之前，让我们在`Startup`中注册这些设置。
- en: Just to make sure we are on the same page, we landed at the point where we are
    trying to generate a token from the Authorization Server in order to access our
    API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了确保我们处于同一页面上，我们已经到达了这样一个点，即我们正在尝试从授权服务器生成令牌以访问我们的API。
- en: Step 2 – Registering Config at startup
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 – 在启动时注册配置
- en: 'For registration, the following is what we have to do inside the `ConfigureServices`
    method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于注册，我们必须在`ConfigureServices`方法中做以下事情：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are loading all those config settings here, such as *Resources* and *Clients*,
    by calling the methods we designed. `AddDeveloperSigningCredential` adds a temporary
    key at the startup time, used only on the development environment when we don't
    have any certificate to apply for Authorization. You would add proper certificate
    details for actual use.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用我们设计的函数来加载所有这些配置设置，例如**资源**和**客户端**。`AddDeveloperSigningCredential`在启动时添加一个临时密钥，仅在开发环境中使用，因为我们没有证书可以申请授权。您将为实际使用添加适当的证书详细信息。
- en: Mark `ProfileService` here. This is what I was talking about in the previous
    section, which will be used to validate the user credentials against the database.
    We will look at it in a little while. First, let's test our API, assuming that
    the Authorization Server is ready with `ProfileService` set up.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里标记`ProfileService`。这正是我在上一节中提到的事情，它将被用来验证用户凭据与数据库。我们稍后会看看它。首先，让我们测试我们的API，假设授权服务器已经准备好，并且设置了`ProfileService`。
- en: 'Now coming to the API, we need to add `AuthenticationScheme` at the start of
    the API to declare what Authentication we will be using. For that, add the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到API，我们需要在API开始处添加`AuthenticationScheme`来声明我们将使用哪种身份验证。为此，添加以下代码：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`JwtBearerDefaults.AuthenticationScheme` is actually a string constant with
    the **Bearer** value. **Bearer authentication** is also known as **token authentication**.
    That means our clients need to send a token in order to access the API''s resources.
    And to get the token, they need to call our *authorization server*, available
    at `/connect/token`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`JwtBearerDefaults.AuthenticationScheme`实际上是一个包含**Bearer**值的字符串常量。**Bearer身份验证**也称为**令牌身份验证**。这意味着我们的客户端需要发送一个令牌才能访问API的资源。而要获取令牌，他们需要调用我们的**授权服务器**，该服务器位于`/connect/token`。'
- en: Notice we have `Audience` set as `FlixOneStore.ReadAccess`, which we have specified
    for the clients inside config. Simply put, we are setting up the bearer type of
    authentication.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已将`Audience`设置为`FlixOneStore.ReadAccess`，这是我们已在配置中为客户端指定的。简单来说，我们正在设置Bearer类型的身份验证。
- en: Step 3 – Adding the [Authorize] attribute
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 – 添加[Authorize]属性
- en: 'The next thing is to add the `[Authorize]` attribute to the API controller
    action. Let''s test this with the `GetCustomers(id)` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`[Authorize]`属性添加到API控制器操作中。让我们用`GetCustomers(id)`方法来测试一下：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Calling it from the *Postman* yields the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从**邮递员**（Postman）调用它将产生以下输出：
- en: '![](img/e2baca5b-b2bc-411e-8929-a8c66cf2101b.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2baca5b-b2bc-411e-8929-a8c66cf2101b.png)'
- en: So, our request is not authorized anymore. We got a reply that we need to send
    a token in order to access the resource. Let's get the token, then.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的请求不再被授权了。我们得到了一个回复，说我们需要发送一个令牌才能访问资源。那么，让我们获取令牌吧。
- en: Step 4 – Getting the token
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 – 获取令牌
- en: In order to get the token, we need to call the authorization server sitting
    at `/connect/token`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取令牌，我们需要调用位于`/connect/token`的授权服务器。
- en: 'The following is a screen captured from *Postman* where a `POST` request is
    performed on the `http://localhost:57571/connect/token` URL with a body containing
    all the required parameters in order to authenticate the client. These are the
    details that we registered inside the `GetClients()` method in *Step 1*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从*Postman*截取的屏幕截图，其中在`http://localhost:57571/connect/token` URL上执行了一个`POST`请求，请求体包含所有必要的参数，以验证客户端。这些是我们根据步骤1在`GetClients()`方法中注册的详细信息：
- en: '![](img/38096c2e-0803-4c37-a14f-963cb390af21.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38096c2e-0803-4c37-a14f-963cb390af21.png)'
- en: Oops! It's a bad request. That is because we passed the wrong secret password
    for the client. If you remember, we set it as `secretpassword`, but passed it
    as `secret`. That's why it got rejected.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这是一个错误的请求。这是因为我们传递了错误的客户端密码。如果你记得，我们将其设置为`secretpassword`，但传递的是`secret`。这就是它被拒绝的原因。
- en: 'Some important things to note here. To get the token:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的重要事项。为了获取令牌：
- en: We need to send a `POST` request to the `/connect/token` URL. As we have implemented
    the server in the same app, the domain is the same here as the API.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要向`/connect/token` URL发送一个`POST`请求。由于我们在同一个应用中实现了服务器，所以这里的域与API相同。
- en: We need to have a `Content-Type` header set as `application/x-www-form-urlencoded`
    (which is actually in a different tab on the screenshot).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要设置一个`Content-Type`头，设置为`application/x-www-form-urlencoded`（这在截图上的实际上是不同的标签页）。
- en: In the body of the request, we added all the required parameters of OAuth according
    to standards and they match exactly what we had in the configuration class.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求体中，我们根据标准添加了所有必要的OAuth参数，并且它们与我们配置类中拥有的完全匹配。
- en: 'When we send everything as required correctly, we will receive a token, as
    shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们正确发送所有必需的信息时，我们将收到一个令牌，如下面的屏幕截图所示：
- en: '![](img/2981f005-71a2-4b96-8ef9-247082327d9c.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2981f005-71a2-4b96-8ef9-247082327d9c.png)'
- en: We received the bearer token response according to OAuth specifications. They
    are `access_token`, `expires_in`, and `token_type`. The `expires_in` param is
    set to 3,600 by default for the access token, which is in seconds, meaning 1 hour.
    After 1 hour, this token won't work anymore. Therefore, before this token expires,
    let's quickly call our API with it and see whether that works.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据OAuth规范收到了携带令牌的响应。它们是`access_token`、`expires_in`和`token_type`。`expires_in`参数默认设置为3600秒，即1小时，对于访问令牌来说。1小时后，这个令牌将不再有效。因此，在令牌过期之前，让我们快速使用它调用我们的API，看看是否可行。
- en: Step 5 – Calling the API with the access token
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5步 – 使用访问令牌调用API
- en: 'Have a look at the following picture, which shows you the call to the API using
    the token we just received:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图片，它展示了使用我们刚刚收到的令牌调用API的过程：
- en: '![](img/4afb75d0-4098-4983-ba63-2e71e983633c.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4afb75d0-4098-4983-ba63-2e71e983633c.png)'
- en: Calling the API endpoint with the token in the authorization header
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在授权头中使用令牌调用API端点
- en: Voila! That worked. I just copied the token I got and added in the `Bearer [Access
    Token]` format to the authorization header and sent the request. Everything is
    perfect now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这成功了。我只是复制了我得到的令牌，并以`Bearer [访问令牌]`的格式添加到授权头中，并发送了请求。现在一切完美了。
- en: Step 6 – Adding the ProfileService class
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6步 – 添加ProfileService类
- en: 'While we explored all this, I left out one part that I want to explain now.
    If you see the body of the request while we fetch the access token, it is something
    like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索所有这些时，我遗漏了一部分，现在我想解释一下。如果你在我们获取访问令牌时看到请求体，它看起来像这样：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Focus on the `username` and `password` parameters. They are here for a reason.
    While generating the token, these are getting validated and yes, we are validating
    with the database directly. Let's see how.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 关注`username`和`password`参数。它们在这里有原因。在生成令牌时，这些参数正在被验证，是的，我们直接与数据库进行验证。让我们看看如何进行。
- en: '`IdentityServer4` provides two interfaces for this purpose, named `IProfileService`
    and `IResourceOwnerPasswordValidator`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentityServer4`为此提供了两个接口，分别命名为`IProfileService`和`IResourceOwnerPasswordValidator`。'
- en: 'The following is a `ResourceOwnerPasswordValidator` class implementing the
    interface. Remember, we set `AllowedGrantTypes = GrantTypes.ResourceOwnerPassword`
    inside the config for the client. That''s why we are doing this to validate the
    user''s credentials:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实现接口的 `ResourceOwnerPasswordValidator` 类。记住，我们在配置中为客户端设置了 `AllowedGrantTypes
    = GrantTypes.ResourceOwnerPassword`。这就是我们为什么要这样做来验证用户的凭据：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Mark the bold lines on the preceding code. `ValidateAsync` is the method that
    is giving us the details from the request, and then it is verified with the database
    value. If matched, we create a `GrantValidationResult` object with `subject`,
    `authenticationMethod`, and `claims`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中标记粗体行。`ValidateAsync` 是一个方法，它从请求中获取详细信息，然后与数据库值进行验证。如果匹配，我们创建一个包含 `subject`、`authenticationMethod`
    和 `claims` 的 `GrantValidationResult` 对象。
- en: '`GetUserClaims` helps us build all the claims. We will see the actual use of
    these claims in a moment.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetUserClaims` 帮助我们构建所有声明。我们将在稍后看到这些声明的实际用途。'
- en: We added a number of claims inside config with a list of `ApiResources`, such
    as `Id`, `Name`, `Email`, `GivenName`, and `FamilyName`. That means the server
    can return these details about the *customer*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置中添加了多个声明，包括 `ApiResources` 的列表，例如 `Id`、`Name`、`Email`、`GivenName` 和 `FamilyName`。这意味着服务器可以返回关于
    *客户* 的这些详细信息。
- en: 'Let''s jump to `ProfileService`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到 `ProfileService`：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A `ProfileDataRequestContext` object is populated with all the claims we added
    in `ApiResource`. Refer to the following screenshot of the list of claims requested
    while debugging:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProfileDataRequestContext` 对象被填充了我们添加到 `ApiResource` 中的所有声明。请参考以下调试时请求的声明列表截图：'
- en: '![](img/06d0514e-22cd-44d7-9392-f6c45c63eed5.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06d0514e-22cd-44d7-9392-f6c45c63eed5.png)'
- en: That means we need to fill all these details from the *customer* record that
    we did and add that to `IssuedClaims`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要从我们所做的 *客户* 记录中填写所有这些详细信息，并将其添加到 `IssuedClaims` 中。
- en: Hold on a second! Why are we doing this? Because our config told us to provide
    this information. But do we need to fill in all that requested information? No.
    Not necessarily. We can issue as many, or as few, claims as we wish to.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！我们为什么要这样做？因为我们的配置告诉我们需要提供这些信息。但我们是否需要填写所有请求的信息？不。不一定。我们可以发放我们想要的任意多或任意少的声明。
- en: 'The big question now! Where do we find this information? We know that after
    all these authorization setups, we get an encrypted token string. Did you guess?
    Yes, all that information actually resides inside the token itself. Don''t trust
    me, trust the following screenshot. As the token is a JWT token, you can use [https://jwt.io/](https://jwt.io/)
    to decode it and see what is inside:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的大问题！我们到哪里找到这些信息？我们知道在所有这些授权设置之后，我们得到一个加密的令牌字符串。你猜到了吗？是的，所有这些信息实际上都驻留在令牌本身中。不要相信我，相信以下截图。因为令牌是一个
    JWT 令牌，你可以使用 [https://jwt.io/](https://jwt.io/) 来解码它并查看里面有什么：
- en: '![](img/d1e5db9b-fc37-4fe5-9f32-13cecc86ce8b.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1e5db9b-fc37-4fe5-9f32-13cecc86ce8b.png)'
- en: Client-based API-consumption architecture
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于客户端的 API 消费架构
- en: We have discussed *RESTful Services, Web APIs*, as well as how to register,
    authenticate, and authorize a user. Moreover, we did focus a little on the consumption
    aspect of the service. Services are designed not only to test on *Postman* but
    actually for consumption by different types of application (desktop, web, mobile,
    smart watches, and IoT apps).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 *RESTful 服务、Web API* 以及如何注册、认证和授权用户。此外，我们还稍微关注了服务的消费方面。服务不仅设计用于在 *Postman*
    上进行测试，而且实际上是为了被不同类型的应用程序（桌面、Web、移动、智能手表和物联网应用程序）消费。
- en: While most modern apps are based on MVC-based architecture, there is a certain
    need to consume web services inside the controllers of those apps. Basically,
    I need to find a way to call the services from my controller without any hassle.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数现代应用程序基于 MVC 架构时，在那些应用程序的控制器中消费 Web 服务有一定的需求。基本上，我需要找到一种方法，从我的控制器中调用服务而没有任何麻烦。
- en: For that to happen, I can't call *Postman* or any other third-party tool. What
    I need is a client or component that can interact with the *RESTful Web API* for
    me. I just need to tell that client that I need the *Customer* details by passing
    the `id` or some identifier and the rest is taken care of by the client, from
    calling the API, passing the value to it, and getting the response. The response
    eventually comes back to the controller, which I can then operate on.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我不能调用 *Postman* 或任何其他第三方工具。我需要的是一个客户端或组件，它可以与我交互 *RESTful Web API*。我只需要告诉这个客户端我需要通过传递
    `id` 或某些标识符来获取 *客户* 的详细信息，其余的由客户端处理，包括调用 API、传递值和获取响应。响应最终返回到控制器，然后我可以对其进行操作。
- en: We will explore how to build a REST client with simple, quick, and easy steps
    in [Chapter 10](9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml), *Building a Web Client
    (Consuming Web Services)*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 10 章 [构建 Web 客户端（消费 Web 服务）](9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml)
    中探讨如何通过简单、快捷、简单的步骤构建 REST 客户端。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Registration is a very common, yet very important part of an application. We
    handled the registration of *Customers* through the API. Before that, we learned
    to bootstrap the API controller actions and model classes with EF Core. While
    we were doing all this, we landed on CORS and learned how to handle that, too.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注册是应用程序中非常常见但非常重要的一个部分。我们通过API处理了 *客户* 的注册。在此之前，我们学习了如何使用 EF Core 引导 API 控制器操作和模型类。在我们做所有这些的同时，我们还遇到了
    CORS 并学习了如何处理它。
- en: Gradually, we moved to the authentication part, where we discussed *Basic Authentication*
    in detail. It is a mechanism to validate the client by the *Customer* (who are
    users of our API) credentials (`username` and `password`), which are passed in
    with the requests.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们逐渐转向认证部分，其中我们详细讨论了 *基本认证*。这是一种通过 *客户*（即我们API的用户）的凭证（`用户名` 和 `密码`）来验证客户端的机制，这些凭证随请求一起传递。
- en: '*Bearer* or *Token-based* Authentication was the next topic we explored, and
    we implemented the OAuth paradigm using *IdentityServer4*. In this case, the client
    can''t access a resource directly by `username` and `password` as it was in the
    case of basic. What it needs is a token first, which is generated by one Authorization
    Server upon request by the client with client details such as *client id* and
    *client secret*. The token, then, can be sent to the API for subsequent requests
    for restricted resource access.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bearer* 或 *基于令牌* 认证是我们接下来探索的主题，我们使用了 *IdentityServer4* 实现了 OAuth 模式。在这种情况下，客户端不能像基本认证那样直接通过
    `用户名` 和 `密码` 访问资源。它首先需要一个令牌，这个令牌是由一个授权服务器在客户端请求时，根据客户端的详细信息（如 *客户端 ID* 和 *客户端密钥*）生成的。然后，这个令牌可以被发送到
    API，用于后续请求以访问受限制的资源。'
- en: In the next chapter, we will take all this knowledge to build other components
    of our API, such as *Cart*, *Shipment*, *Order Items*, and *Checkout*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这些知识应用到构建我们API的其他组件中，例如 *购物车*、*运输*、*订单项* 和 *结账*。
