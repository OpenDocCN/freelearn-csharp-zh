- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about trees. However, did you know that
    such data structures also belong to graphs? But what is a graph and how can you
    use one in your applications? You’ll find the answers to these and many other
    questions in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: First, basic information about graphs will be presented, including an explanation
    of **nodes** and **edges**. As graphs are data structures that are commonly used
    in practice, you will also see some of their applications, such as for storing
    data of friends on social media or for finding a road in a city. Then, the topic
    of graph **representation** will be covered, namely using an adjacency list and
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, you will learn how to implement a graph in the
    C# language. Moreover, you will learn about two modes of graph **traversal**,
    namely **depth-first search** (**DFS**) and **breadth-first search** (**BFS**).
    For both of them, the code and a detailed description will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn about the subject of **minimum spanning trees** (**MSTs**),
    as well as two algorithms for their creation, namely Kruskal’s and Prim’s. Such
    algorithms will be presented as descriptions, code snippets, and illustrations.
    Moreover, an example real-world application will be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting graph-related problem is the **coloring** of nodes, which
    will be taken into account in the following part of this chapter. Finally, the
    topic of finding the **shortest path** in a graph will be analyzed using Dijkstra’s
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the topic of graphs involves many interesting problems and only
    some of them will be mentioned in this book. However, the chosen subjects are
    suitable for presenting various graph-related aspects in the context of the C#
    language. Are you ready to dive into the topic of graphs? If so, start reading
    this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum spanning tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortest path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with the question *what is a graph?* Broadly speaking, **a graph
    is a data structure that consists of** **nodes** **(also called** **vertices****)
    and** **edges****. Each edge connects two nodes**. A graph data structure does
    not require any specific rules regarding connections between nodes, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Illustration of a graph](img/B18069_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Illustration of a graph
  prefs: []
  type: TYPE_NORMAL
- en: This concept seems very simple, doesn’t it? Let’s try to analyze the preceding
    graph to eliminate any doubts. It contains **9 nodes** with numbers between **1**
    and **9** as values. Such nodes are connected by **11 edges**, such as between
    nodes **2** and **4**. Moreover, a graph can contain **cycles** – for example,
    with nodes indicated by **2**, **3**, and **4** – as well as separate groups of
    nodes, which are not connected.
  prefs: []
  type: TYPE_NORMAL
- en: However, what about the topic of parent and child nodes, which you know from
    learning about trees? As there are no specific rules about connections in a graph,
    such concepts are not used in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a graph
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize a graph, take your eyes off this book for a
    moment and look at a map showing the most important roads in your country, such
    as highways or expressways. Each fragment of such a road connects two towns and
    has a certain length. Once you have drawn such a structure on a piece of paper,
    you will see that thanks to it, you can find a route between two towns, along
    with the total distance of the entire route. Did you know you just created a graph?
    Individual towns are nodes, and the lines connecting them are edges. The distance
    between the two towns is the edge weight. It’s so simple when you can relate theory
    to practice, isn’t it? Now, it’s high time to put the map aside and focus on learning
    about the last data structure that will be covered in this book, namely the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Some more comments are necessary for edges in a graph. In the preceding diagram,
    you can see a graph where all the nodes are connected with **undirected edges**
    – that is, **bidirectional edges**. They indicate that **it is possible to travel
    between nodes in both directions** – for example, from node **2** to **3** and
    from node **3** to **2**. Such edges are presented graphically as **straight lines**.
    When a graph contains undirected edges, it is an **undirected graph**.
  prefs: []
  type: TYPE_NORMAL
- en: However, what about a scenario when you need to indicate that **traveling between
    nodes is possible only in one direction**? In such a case, you can use **directed
    edges** – that is, **unidirectional edges** – which are presented graphically
    as **straight lines with arrows indicating the direction of an edge**. If a graph
    contains directed edges, it can be named a **directed graph**.
  prefs: []
  type: TYPE_NORMAL
- en: What about self-loops?
  prefs: []
  type: TYPE_NORMAL
- en: A graph can also contain **self-loops**. Each is an edge that connects a given
    node with itself. However, such a topic is outside the scope of this book and
    won’t be taken into account in the examples shown in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example directed graph is presented in the following diagram on the right,
    while an undirected one is shown on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The difference between undirected and directed graphs](img/B18069_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The difference between undirected and directed graphs
  prefs: []
  type: TYPE_NORMAL
- en: As a short explanation, the directed graph (shown on the right in the preceding
    diagram) contains **8 nodes** connected by **15 unidirectional edges**. For example,
    they indicate that it is possible to travel between node **1** and **2** in both
    directions, but it is allowed to travel from the node **1** to **3** only in one
    direction, so it is impossible to reach node **1** from **3** directly.
  prefs: []
  type: TYPE_NORMAL
- en: The division between undirected and directed edges is not the only one. You
    can also specify **weights** (also referred to as **costs**) for particular edges
    to indicate the cost of traveling between nodes. Of course, such weights can be
    assigned to both undirected and directed edges. If weights are provided, an edge
    is named a **weighted edge**, and the whole graph is named a **weighted graph**.
    Similarly, if no weights are provided, **unweighted edges** are used in a graph.
    This graph is then called an **unweighted graph**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some example weighted graphs with undirected (on the left) and directed (on
    the right) edges are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Difference between weighted undirected and weighted directed
    graphs](img/B18069_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Difference between weighted undirected and weighted directed graphs
  prefs: []
  type: TYPE_NORMAL
- en: This graphical presentation of a weighted edge shows the weight of an edge next
    to the line. For example, the cost of traveling from node **1** to **2**, as well
    as from node **2** to **1**, is equal to **3** in the case of the undirected graph,
    shown on the left in the preceding diagram. The situation is a bit more complicated
    in the case of the directed graph (on the right). Here, you can travel from node
    **1** to **2** with a cost equal to **9**, while traveling in the opposite direction
    (from node **2** to **1**) is much cheaper and costs only **3**.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you know some basic information about graphs, especially regarding
    nodes and various kinds of edges. However, why is the topic of graphs so important
    and why does it take up a whole chapter in this book? Could you use this data
    structure in your applications? The answer is obvious: yes! Graphs are commonly
    used while solving algorithmic problems and have numerous real-world applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let’s think about a **structure of friends available on social media**.
    Each user has many contacts, but they also have many friends, and so on. What
    data structure should you choose to store such data? A graph is the simplest answer.
    In such a scenario, the nodes represent contacts, while the edges depict relationships
    between people. As an example, let’s take a look at the following diagram of an
    undirected and unweighted graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Illustration of a graph representing a structure of friends](img/B18069_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Illustration of a graph representing a structure of friends
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, **Jimmy Gold** has five contacts, namely **John Smith**, **Andy
    Wood**, **Eric Green**, **Ashley Lopez**, and **Paula Scott**. In the meantime,
    **Paula Scott** has two other friends: **Marcin Jamro** and **Tommy Butler**.
    By using a graph as a data structure, you can easily check whether two people
    are friends or whether they have a common contact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common application of graphs involves the problem of **searching for
    the shortest path**. Let’s imagine a program that should find a path between two
    points in the city, taking into account the time necessary for driving particular
    roads. In such a case, you can use a graph to present a map of a city, where nodes
    depict intersections and edges represent roads. Of course, you should assign weights
    to edges to indicate the time that’s necessary to drive a given road. The topic
    of searching the shortest path can be understood as finding the list of edges
    from the source to the target node, with the minimum total cost. A diagram of
    a city map, based on a graph, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Illustration of a graph representing a city map](img/B18069_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Illustration of a graph representing a city map
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the directed and weighted graph was chosen. Directed edges make
    it possible to support both two-way and one-way roads, while weighted edges allow
    you to specify the time necessary to travel between two intersections.
  prefs: []
  type: TYPE_NORMAL
- en: Representations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you know what a graph is and when one can be used, but how can
    you represent one in the memory of a computer? There are two popular approaches
    to solve this problem, namely using an **adjacency list** and an **adjacency matrix**.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first approach requires you to **extend the data of a node by specifying
    a list of its neighbors**. Thus, you can easily get all the neighbors of a given
    node just by iterating through the adjacency list of a given node. Such a solution
    is space-efficient because you only store the data of adjacent edges. Let’s take
    a look at the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.6 – \uFEFFAdjacency list representing an undirected and unweighted\
    \ graph](img/B18069_08_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Adjacency list representing an undirected and unweighted graph
  prefs: []
  type: TYPE_NORMAL
- en: This example graph contains 8 nodes and 10 edges. For each node, a list of adjacent
    nodes (that is, **neighbors**) is created, as shown on the right-hand side of
    the diagram. For example, node **1** has two neighbors, namely nodes **2** and
    **3**, while node **5** has four neighbors, namely nodes **4**, **6**, **7**,
    and **8**. As you can see, the representation based on the adjacency list for
    an undirected and unweighted graph is straightforward, as well as easy to use,
    understand, and implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how does the adjacency list work in the case of a directed graph? The answer
    is obvious because the list that’s assigned to each node just shows adjacent nodes
    that can be reached from the given node. Here’s an example diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Adjacency list representing a directed and unweighted graph](img/B18069_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Adjacency list representing a directed and unweighted graph
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at node **3**. Here, the adjacency list contains only one
    element – that is, node **4**. Node **1** is not included, because it cannot be
    reached directly from node **3**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit more clarification may be useful in the case of a weighted graph. In
    such a case, it is also necessary to store weights for particular edges. You can
    achieve this by extending data stored in the adjacency list, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Adjacency list representing a directed and weighted graph](img/B18069_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Adjacency list representing a directed and weighted graph
  prefs: []
  type: TYPE_NORMAL
- en: For example, the adjacency list for node **7** contains two elements, namely
    regarding an edge to node **5** (with a weight equal to **4**) and to node **8**
    (with a weight equal to **6**).
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach to graph representation involves the adjacency matrix, which
    uses **a two-dimensional array to show which nodes are connected by edges**. The
    matrix contains the same number of rows and columns, which is equal to the number
    of nodes. The main idea is to **store information about a particular edge in an
    element at a given row and column in the matrix**. The index of the row and the
    column depends on the nodes connected with the edge. For example, if you want
    to get information about an edge between nodes with indices **1** and **5**, you
    must check the element in the row with an index set to **1** and in the column
    with an index set to **5**.
  prefs: []
  type: TYPE_NORMAL
- en: Such a solution provides you with a **quick way of checking whether two particular
    nodes are connected by an edge**. However, it may require you to store significantly
    more data than the adjacency list, especially if the graph does not contain many
    edges between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let’s analyze the basic scenario of an undirected and unweighted
    graph. In such a case, the adjacency matrix may only store Boolean values. The
    `true` value that’s placed in the element at the `i` row and the `j` column indicates
    that there is a connection between a node with an index equal to `i` and the node
    with an index set to `j`. If this sounds complicated, take a look at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph](img/B18069_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph
  prefs: []
  type: TYPE_NORMAL
- en: Here, the adjacency matrix contains 64 elements (for 8 rows and 8 columns) because
    there are 8 nodes in the graph. The values of many elements in the array are set
    to `false`, which is represented by missing indicators. The remaining are marked
    with crosses, representing `true` values. For example, such a value in the element
    at the fourth row and third column means that there is an edge between nodes **4**
    and **3**, as shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric adjacency matrix
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding graph is undirected, the adjacency matrix is symmetric. If
    there is an edge between nodes `i` and `j`, there is also an edge between nodes
    `j` and `i`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example involves a directed and unweighted graph. In such a case,
    the same rules can be used, but the adjacency matrix does not need to be symmetric.
    Let’s take a look at the illustration of the graph, presented together with the
    adjacency matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Adjacency matrix representing a directed and unweighted graph](img/B18069_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Adjacency matrix representing a directed and unweighted graph
  prefs: []
  type: TYPE_NORMAL
- en: Within the shown adjacency matrix, you can find data of 15 edges, represented
    by 15 elements with `true` values, indicated by crosses in the matrix. For example,
    the unidirectional edge from node **5** to **4** is shown as the cross at the
    fifth row and the fourth column.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both previous examples, you learned how to present an unweighted graph using
    an adjacency matrix. However, how you can store the data of the weighted graph,
    either undirected or directed? The answer is very simple – you just need to change
    the type of data stored in particular elements in the adjacency matrix from Boolean
    to numeric. Thus, you can specify the weight of edges, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Adjacency matrix representing a directed and weighted graph](img/B18069_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Adjacency matrix representing a directed and weighted graph
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate any doubt, let’s take a look at the edge between nodes **5** and
    **6** with the weight set to **2**. Such an edge is represented by the element
    at the fifth row and the sixth column. The value of the element is equal to the
    cost of traveling between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already know some basic information about graphs, including nodes, edges,
    and two methods of representation, namely using an adjacency list and matrix.
    However, how you can use such a data structure in your applications? In this section,
    you will learn how to implement a graph using the C# language. To make your understanding
    of this content easier, two examples will be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with, let’s take a look at the code of a generic class representing
    a single node in a graph. Such a class is named `Node` and its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The class contains four properties. Since all of these elements perform important
    roles in the code snippets shown in this chapter, let’s analyze them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The first property (`Index`) stores an index of a particular node in a collection
    of nodes in a graph to simplify the process of accessing a particular element.
    Thus, it is possible to easily get an instance of the `Node` class by using an
    index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next property is named `Data` and just stores some data in the node. It
    is worth mentioning that the type of such data is consistent with the type specified
    while creating an instance of the generic class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Neighbors` property represents the adjacency list for a particular node.
    Thus, it contains references to the `Node` instances representing adjacent nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last property is named `Weights` and stores weights assigned to adjacent
    edges. In the case of a weighted graph, the number of elements in the `Weights`
    list is the same as the number of neighbors (`Neighbors`). If a graph is unweighted,
    the `Weights` list is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the aforementioned properties, the class contains the overridden
    `ToString` method, which returns the textual representation of the object. Here,
    the string is returned in `"Index: [index]. Data: [data]. Neighbors: [``count]."`
    format.'
  prefs: []
  type: TYPE_NORMAL
- en: Edge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the short introduction to the topic of graphs, a graph consists
    of nodes and edges. As a node is represented by an instance of the `Node` class,
    the generic `Edge` class can be used to represent an edge. The suitable part of
    the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class contains three properties, namely representing nodes adjacent to the
    edge (`From` and `To`), as well as the weight of the edge (`Weight`). Moreover,
    the `ToString` method is overridden to present some basic information about the
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next class is named `Graph` and represents a whole graph, with either directed
    or undirected edges, as well as either weighted or unweighted edges. The implementation
    consists of various properties and methods. These are described in detail here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the basic version of the `Graph` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The class contains two properties indicating whether edges are directed (`IsDirected`)
    and weighted (`IsWeighted`). Moreover, the `Nodes` property is declared, which
    stores a list of nodes existing in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting member of the `Graph` class is the indexer, which takes
    two indices, namely indices of two nodes, to return an instance of the `Edge`
    class representing an edge between such nodes. The implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Within the indexer, you get instances of the `Node` class representing two nodes
    (`nodeFrom` and `nodeTo`) according to the indices. As you want to find an edge
    from the first node (`nodeFrom`) to the second one (`nodeTo`), you need to try
    to find the second node in the collection of neighbor nodes of the first node
    using the `IndexOf` method. If such a connection does not exist, the `IndexOf`
    method returns a negative value, and `null` is returned by the indexer. Otherwise,
    you create a new instance of the `Edge` class and set the values of its properties,
    including `From` and `To`. If the data regarding the weight of particular edges
    is provided, the value of the `Weight` property of the `Edge` class is set as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you know how to store data of nodes in the graph, but how can
    you add a new node? To do so, you can implement the `AddNode` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Within this method, you create a new instance of the `Node` class and set a
    value of the `Data` property, according to the value of the parameter. Then, the
    newly created instance is added to the `Nodes` collection, and the `UpdateIndices`
    method (described later) is called to update the indices of all the nodes stored
    in the collection. Finally, the `Node` instance, representing the newly added
    node, is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove the existing node as well. This operation is performed by the
    `RemoveNode` method, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method takes one parameter, namely an instance of the node that should
    be removed. First, you remove it from the collection of nodes. Then, you update
    the indices of the remaining nodes. Finally, you iterate through all the nodes
    in the graph to remove all edges that are connected with the node that has been
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know, a graph consists of nodes and edges. Thus, the implementation
    of the `Graph` class should provide developers with a method for adding a new
    edge. Of course, it should support various variants of edges, either directed,
    undirected, weighted, or unweighted. The proposed implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `AddEdge` method takes three parameters, namely two instances of the `Node`
    class representing nodes connected by the edge (`from` and `to`), as well as the
    weight of the connection (`w`), which is set to `0` by default.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line within the method, you add the `Node` instance representing
    the second node to the list of neighbor nodes of the first one. If the weighted
    graph is considered, a weight of the aforementioned edge is added as well.
  prefs: []
  type: TYPE_NORMAL
- en: The following part of the code is only taken into account when the graph is
    undirected. In such a case, you need to automatically add an edge in the opposite
    direction. To do so, you add the `Node` instance representing the first node to
    the list of neighbor nodes of the second one. If the edges are weighted, a weight
    of the aforementioned edge is added to the `Weights` list as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of removing an edge from the graph is supported by the `RemoveEdge`
    method. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method takes two parameters, namely two nodes (`from` and `to`), between
    which there is an edge that should be removed. To start, you try to find the second
    node in the list of neighbor nodes of the first one. If it is found, you remove
    it. You should also remove the weight data if the weighted graph is considered.
    In the case of an undirected graph, you automatically remove a node in an opposite
    direction, namely between the `to` and `from` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last public method is named `GetEdges` and makes it possible to get a collection
    of all the edges that are available in the graph. The proposed implementation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, a new list of edges is initialized. Then, you iterate through all the
    nodes in the graph using a `foreach` loop. Within it, you use a `for` loop to
    create instances of the `Edge` class. The number of instances should be equal
    to the number of neighbors of the current node (the `from` variable in the `foreach`
    loop). In the `for` loop, the newly created instance of the `Edge` class is configured
    by setting values of its properties, namely the first node (the `from` variable
    – that is, the current node from the `foreach` loop), the second node (to the
    currently-analyzed neighbor), and the weight. Then, the newly created instance
    is added to the collection of edges, represented by the `edges` variable. Finally,
    the result is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In various methods, you use the `UpdateIndices` method. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method iterates through all the nodes in the graph and updates the values
    of the `Index` property to the consecutive number, starting from `0`. It is worth
    noting that the iteration is performed using the `ForEach` method, instead of
    using a `foreach` or `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how to create a basic implementation of a graph. The next step
    is to apply it to represent some example graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Example – undirected and unweighted edges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s try to use the previous implementation to create an undirected and unweighted
    graph according to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Illustration of the undirected and unweighted edges example](img/B18069_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Illustration of the undirected and unweighted edges example
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the graph contains 8 nodes and 10 edges. The implementation
    starts with the following line, which initializes a new undirected and unweighted
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Node<int> n1 = graph.AddNode(1);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n2 = graph.AddNode(2);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n3 = graph.AddNode(3);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n4 = graph.AddNode(4);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n5 = graph.AddNode(5);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n6 = graph.AddNode(6);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n7 = graph.AddNode(7);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n8 = graph.AddNode(8);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: graph.AddEdge(n1, n2);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n1, n3);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n2, n4);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n3, n4);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n4, n5);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n5, n6);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n5, n7);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n5, n8);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n6, n7);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n7, n8);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Graph<int> graph = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{ IsDirected = true, IsWeighted = true };'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Node<int> n1 = graph.AddNode(1);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n2 = graph.AddNode(2);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n3 = graph.AddNode(3);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n4 = graph.AddNode(4);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n5 = graph.AddNode(5);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n6 = graph.AddNode(6);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n7 = graph.AddNode(7);
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n8 = graph.AddNode(8);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: graph.AddEdge(n1, n2, 9);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n1, n3, 5);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n2, n1, 3);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n2, n4, 18);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n3, n4, 12);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n4, n2, 2);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n4, n8, 8);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n5, n4, 9);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n5, n6, 2);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n5, n7, 5);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n5, n8, 3);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n6, n7, 1);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n7, n5, 4);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n7, n8, 6);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n8, n5, 3);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: public List<Node<T>> DFS()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: bool[] isVisited = new bool[Nodes.Count];
  prefs: []
  type: TYPE_NORMAL
- en: List<Node<T>> result = [];
  prefs: []
  type: TYPE_NORMAL
- en: DFS(isVisited, Nodes[0], result);
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: private void DFS(bool[] isVisited, Node<T> node,
  prefs: []
  type: TYPE_NORMAL
- en: List<Node<T>> result)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: result.Add(node);
  prefs: []
  type: TYPE_NORMAL
- en: isVisited[node.Index] = true;
  prefs: []
  type: TYPE_NORMAL
- en: foreach (Node<T> neighbor in node.Neighbors)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (!isVisited[neighbor.Index])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: DFS(isVisited, neighbor, result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Graph<int> graph = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{ IsDirected = true, IsWeighted = true };'
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n1 = graph.AddNode(1); (...)
  prefs: []
  type: TYPE_NORMAL
- en: Node<int> n8 = graph.AddNode(8);
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n1, n2, 9); (...)
  prefs: []
  type: TYPE_NORMAL
- en: graph.AddEdge(n8, n5, 3);
  prefs: []
  type: TYPE_NORMAL
- en: List<Node<int>> nodes = graph.DFS();
  prefs: []
  type: TYPE_NORMAL
- en: nodes.ForEach(Console.WriteLine);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Index: 0\. Data: 1\. Neighbors: 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index: 1\. Data: 2\. Neighbors: 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index: 3\. Data: 4\. Neighbors: 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index: 7\. Data: 8\. Neighbors: 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index: 4\. Data: 5\. Neighbors: 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index: 5\. Data: 6\. Neighbors: 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index: 6\. Data: 7\. Neighbors: 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index: 2\. Data: 3\. Neighbors: 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'public List<Node<T>> BFS public method is added to the Graph class and is used
    to start the traversal of a graph. It calls the private BFS method, passing the
    first node as the parameter. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The important part of the code is performed by the `isVisited` array, which
    stores Boolean values indicating whether particular nodes were already visited.
    The array is initialized at the beginning of the `BFS` method, and the value of
    the element related to the current node is set to `true`, which indicates that
    this node was visited.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the list for storing traversed nodes (`result`) and the queue for storing
    nodes that should be visited next (`queue`) are created. Just after the initialization
    of the queue, the current node is added to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operations are performed until the queue is empty: you get the
    first node from the queue (the `next` variable), add it to the collection of visited
    nodes, and iterate through the neighbors of the current node. For each of them,
    you check whether it has already been visited. If not, it is marked as visited
    by setting a proper value in the `isVisited` array, and the neighbor is added
    to the queue for analysis in one of the next iterations of the `while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the list of the visited nodes is returned. If you want to test this
    algorithm, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code calls the `BFS` public method to traverse the graph according
    to the BFS algorithm. The last line is responsible for iterating through the results
    to present the data of the nodes in the console, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just learned about two algorithms for traversing a graph, namely DFS
    and BFS. To make your understanding of such topics easier, this chapter contains
    detailed descriptions, illustrations, and examples. Now, let’s proceed to another
    important topic, namely the minimum spanning tree, which has many real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: There are many online resources regarding traversing a graph. You can learn
    more about DFS at [https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search),
    while you can find more information about the BFS algorithm and its implementation
    at [https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/).
  prefs: []
  type: TYPE_NORMAL
- en: Minimum spanning tree
  prefs: []
  type: TYPE_NORMAL
- en: 'While talking about graphs, it is beneficial to introduce the subject of a
    **spanning tree**. What is it? **A** **spanning tree is a subset of edges that
    connects all nodes in a graph without cycles**. Of course, it is possible to have
    many spanning trees within the same graph. For example, let’s take a look at the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Illustration of spanning trees within a graph](img/B18069_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Illustration of spanning trees within a graph
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left-hand side is a spanning tree that consists of the following edges:
    (**1**, **2**), (**1**, **3**), (**3**, **4**), (**4**, **5**), (**5**, **6**),
    (**6**, **7**), and (**5**, **8**). The total weight is equal to 40\. On the right-hand
    side, another spanning tree is shown. Here, the following edges are chosen: (**1**,
    **2**), (**1**, **3**), (**2**, **4**), (**4**, **8**), (**5**, **8**), (**5**,
    **6**), and (**6**, **7**). The total weight is equal to 31.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, neither of the preceding spanning trees is the **minimum spanning
    tree (MST)** of this graph. What does it mean that a spanning tree is *minimum*?
    The answer is really simple: it is **a spanning tree with the minimum cost from
    all spanning trees available in the graph**. You can get the MST by replacing
    the edge (**6**, **7**) with (**5**, **7**). Then, the cost is equal to 30\. It
    is also worth mentioning that the number of edges in a spanning tree is equal
    to the number of nodes minus one.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is the topic of MST so important? Let’s imagine a scenario where you need
    to connect many buildings to a telecommunication cable. Of course, there are various
    possible connections, such as from one building to another, or using a hub. What’s
    more, environmental conditions can have a serious impact on the cost of the investment
    due to the necessity of crossing a road or even a river. Your task is to successfully
    connect all buildings to the telecommunication cable at the lowest possible cost.
    How should you design the connections? To answer this question, you just need
    to create a graph, where nodes represent connectors and edges indicate possible
    connections. Then, you find the MST, and that’s all!
  prefs: []
  type: TYPE_NORMAL
- en: Do you want some examples?
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned problem of connecting many buildings to the telecommunication
    cable is presented in the example at the end of this section regarding the MST.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is how to find the MST. There are various approaches to solving
    this problem, including the application of Kruskal’s or Prim’s algorithms. These
    are presented and explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Kruskal’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: One of the algorithms for finding the MST was discovered by **Kruskal**. Its
    operation is very simple to explain. **The algorithm takes an edge with the minimum
    weight from the remaining ones and adds it to the MST, but only if adding it does
    not create a cycle**. The algorithm stops when all the nodes are connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a diagram that presents the steps of finding the MST using
    **Kruskal’s algorithm**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Illustration of Kruskal’s algorithm](img/B18069_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Illustration of Kruskal’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Step 1**, edge (**5**, **8**) is chosen because it has the minimum weight,
    namely **1**. Then, the following edges are selected: (**1**, **2**) in **Step
    2**, (**2**, **4**) in **Step 3**, (**5**, **6**) in **Step 4**, (**1**, **3**)
    in **Step 5**, as well as (**5**, **7**) and (**4**, **8**) in **Step 6**. It
    is worth noting that before taking the (**4**, **8**) edge, (**6**, **7**) is
    considered due to its lower weight (6 instead of 8). However, adding it to the
    MST will introduce a cycle formed by the (**5**, **6**), (**6**, **7**), and (**5**,
    **7**) edges. For this reason, such an edge is ignored and the algorithm chooses
    (**4**, **8**). Finally, the number of edges in the MST is 7\. The number of nodes
    is equal to 8, which means that the algorithm can stop operating and the MST has
    been found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at its implementation. It involves the `MSTKruskal` method,
    which should be added to the `Graph` class. The proposed code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method does not take any parameters. To start, a list of edges is obtained
    by calling the `GetEdges` method. Then, the edges are sorted in ascending order
    by weight. Such a step is crucial because you need to get an edge with the minimum
    cost in the following iterations of the algorithm. In the next line, a new queue
    is created and `Edge` instances are enqueued, using the constructor of the `Queue`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next block of code, an array with data of subsets is created. By default,
    each node is added to a separate subset. This is the reason why the number of
    elements in the `subsets` array is equal to the number of nodes. The subsets are
    used to check whether an addition of an edge to the MST causes the creation of
    a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the list for storing edges from the MST is created (`result`). The most
    interesting part of the code is the `while` loop, which iterates until the correct
    number of edges is found in the MST. Within this loop, you get the edge with the
    minimum weight, just by calling the `Dequeue` method on the `Queue` instance.
    Then, you can check whether no cycles were introduced by adding the found edge
    to the MST. In such a case, the edge is added to the target list, and the `Union`
    method is called to union two subsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'While analyzing the previous method, the `GetRoot` one is mentioned. It aims
    to update parents for subsets, as well as return the root node of the subset,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last private method is named `Union` and performs the *union* operation
    (by a rank) of two sets. It takes three parameters, namely an array of `Subset`
    instances and two `Node` instances, representing root nodes for subsets on which
    the *union* operation should be performed. The suitable part of the code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippets, you can see the `Subset` class, but what does
    it look like? Let’s take a look at its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The class contains properties representing the parent node (`Parent`), as well
    as the rank of the subset (`Rank`). The class also contains the overridden `ToString`
    method, which presents some basic information about the subset in textual form.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that the presented approach is representative of a **greedy algorithm**?
    The code shown here is based on the implementation available at [https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/](https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/).
    You can find there a lot of interesting information about Kruskal’s algorithm,
    as well as about many other algorithms regarding graphs, such as about a simple
    approach to coloring, which is also one of the topics waiting for you in the current
    chapter. *GeeksForGeeks* is a great resource for various algorithms with a huge
    collection of content, and it’s something I highly recommend!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the usage of the `MSTKruskal` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you initialize an undirected and weighted graph, as well as add nodes
    and edges. Then, you call the `MSTKruskal` method to find the MST using Kruskal’s
    algorithm. Finally, you use the `ForEach` method to write the data of each edge
    from the MST in the console. The exemplary output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, you will learn about two algorithms for finding the
    MST in this chapter. Now, it is high time to take a look at the second one, namely
    Prim’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Prim’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Another solution to solve the problem of finding the MST is **Prim’s algorithm**.
    **It uses two sets of nodes that are disjointed, namely the nodes located in the
    MST and the nodes that are not placed there yet**. In the following iterations,
    the algorithm **finds an edge with the minimum weight that connects a node from
    the first group with a node from the second group. The node of the edge, which
    is not already in the MST, is added to** **this set.**
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding description sounds quite simple, doesn’t it? Let’s see it in
    action by analyzing the diagram presenting the steps of finding the MST using
    Prim’s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Illustration of Prim’s algorithm](img/B18069_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – Illustration of Prim’s algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the additional indicators that have been added next to
    the nodes in the graph. They present the minimum weight necessary to reach such
    a node from any of its neighbors. By default, the starting node has such a value
    set to **0**, while all others are set to infinity, as presented in **Step 1**.
  prefs: []
  type: TYPE_NORMAL
- en: In **Step 2**, the starting node is added to the subset of nodes forming the
    MST, and the distance to its neighbors is updated, namely **5** for reaching node
    **3** and **3** for reaching node **2**. The values of the other nodes are still
    set to infinity.
  prefs: []
  type: TYPE_NORMAL
- en: In **Step 3**, the node with the minimum cost is chosen. In this case, node
    **2** is selected because the cost is equal to **3**. Its competitor (namely node
    **3**) has a cost equal to **5**. Next, you need to update the cost of reaching
    the neighbors of the current node, namely node **4** with the cost set to **4**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chosen node is node **4** because it does not exist in the MST set
    and has the lowest reaching cost (**Step 4**). In the same way, you choose the
    next edges in the following order: (**1**, **3**) in **Step 5**, (**4**, **8**)
    in **Step 6**, (**8**, **5**) in **Step 7**, (**5**, **6**) in **Step 8**, and
    (**5**, **7**) in **Step 9**. Now, all the nodes are included in the MST and the
    algorithm can stop its operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this detailed description of the steps of the algorithm, let’s proceed
    to the C#-based implementation. The majority of operations are performed in the
    `MSTPrim` method, which should be added to the `Graph` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MSTPrim` method does not take any parameters. It uses three auxiliary
    node-related arrays that assign additional data to the nodes of the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: The first, namely `previous`, stores indices of the previous node, from which
    the given node can be reached. By default, the values of all elements are equal
    to `0`, except the first one, which is set to `-1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `minWeight` array stores the minimum weight of the edge for accessing the
    given node. By default, all elements are set to the maximum value of the `int`
    type, while the value for the first element is set to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isInMST` array indicates whether the given node is already in the MST.
    To start with, the values of all the elements should be set to `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most interesting part of the code is located in the `for` loop. Within it,
    you’ll find the index of the node from the set of nodes not located in the MST,
    which can be reached with the minimum cost. Such a task is performed by the `GetMinWeightIndex`
    method. Then, another `for` loop is used. Within it, you get an edge that connects
    nodes with the `mwi` index (this stands for *minimum weight index*) and `j`. You
    check whether the node is not already located in the MST and whether the cost
    of reaching the node is smaller than the previous minimum cost. If so, values
    of node-related elements in the `previous` and `minWeight` arrays are updated.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the code just prepares the final results. Here, you create
    a new instance of the list with the data of edges that form the MST. The `for`
    loop is used to get the data of the following edges and to add them to the `result`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'While analyzing the code, the `GetMinWeightIndex` private method is mentioned.
    Its code is presented in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `GetMinWeightIndex` method just finds an index of the node, which is not
    located in the MST and can be reached with the minimum cost. To do so, you use
    a `for` loop to iterate through all the nodes. For each of them, you check whether
    the current node is not located in the MST and whether the cost of reaching it
    is smaller than the already-stored minimum value. If so, the values of the `minValue`
    and `minIndex` variables are updated. Finally, the index is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Kruskal’s algorithm, Prim’s variant is also representative of a **greedy
    algorithm**. I strongly encourage you to search for even more interesting information
    about this algorithm in books, research papers, and on the internet. It is worth
    noting that the presented code is based on the implementation shown at [https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the usage of the `MSTPrim` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The missing parts of the code are the same as in the case of the exemplary
    code regarding Kruskal’s algorithm. When you run the code, you will get the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve looked at various algorithms for finding the MST, let’s proceed
    to an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example – telecommunication cable
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the introduction to the topic of MSTs, this problem has some
    important real-world applications, such as creating a plan of connections between
    buildings to supply all of them with a telecommunication cable with the smallest
    cost. Of course, there are various possible connections, such as from one building
    to another or using a hub. What’s more, environmental conditions can have a serious
    impact on the cost of the investment due to the necessity of crossing a road or
    even a river.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s create a program that solves this problem in the context
    of a set of buildings, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Illustration of the telecommunication cable example](img/B18069_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – Illustration of the telecommunication cable example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the estate community consists of six buildings. The buildings
    are located on two sides of a small river with only one bridge. Moreover, two
    roads exist. Of course, there are different costs of connections between various
    points, depending both on the distance and the environmental conditions. For example,
    the direct connection between two buildings (**B1** and **B2**) has a cost equal
    to **2**, while using the bridge (between **R1** and **R5**) involves a cost equal
    to **75**. If you need to cross the river without a bridge (between **R3** and
    **R6**), the cost is even higher and equal to **100**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is to find the MST. Within this example, you will apply both Kruskal’s
    and Prim’s algorithms to solve this problem. To start, let’s initialize the undirected
    and weighted graph, as well as add nodes and edges, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you just need to call the `MSTKruskal` method to use Kruskal’s algorithm
    to find the MST. When the results are obtained, you can easily present them in
    the console, together with the total cost. The suitable part of the code is shown
    in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The results presented in the console are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you visualize such results on the map, you’ll find the following MST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Illustration of the result of the telecommunication cable example](img/B18069_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – Illustration of the result of the telecommunication cable example
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can apply Prim’s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just completed an example related to the real-world application of MSTs.
    Are you ready to proceed to another graph-related subject known as coloring?
  prefs: []
  type: TYPE_NORMAL
- en: Coloring
  prefs: []
  type: TYPE_NORMAL
- en: The topic of finding the MST is not the only graph-related problem. Among others,
    **node coloring** exists. It aims to **assign colors (numbers) to all nodes to
    comply with the rule that there cannot be an edge between two nodes with the same
    color**. Of course, the number of colors should be as low as possible. Such a
    problem has some real-world applications, such as for coloring a map. The implementation
    of the coloring algorithm, which is shown in this chapter, is quite simple and
    in some cases could use more colors than is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Four-color theorem
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that the nodes of each planar graph can be colored with no more
    than four colors? If you are interested in this topic, take a look at the **four-color
    theorem** ([http://mathworld.wolfram.com/Four-ColorTheorem.html](http://mathworld.wolfram.com/Four-ColorTheorem.html)).
    Since I am talking about a planar graph, you should understand that it is a graph
    whose edges do not cross each other while it is drawn on the plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Illustration of graph coloring](img/B18069_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – Illustration of graph coloring
  prefs: []
  type: TYPE_NORMAL
- en: 'The left-hand side illustration presents a graph that is colored using four
    colors: red (index equal to **0**), green (**1**), blue (**2**), and yellow (**3**).
    As you can see, there are no nodes with the same colors connected by an edge.
    The graph shown on the right depicts the graph with two additional edges, namely
    (**2**, **6**) and (**2**, **5**). In such a case, the coloring has changed, but
    the number of colors remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is, how can you find colors for nodes to comply with the aforementioned
    rule? Fortunately, the algorithm is very simple and its implementation is presented
    here. Here is the code of the `Color` method, which should be added to the `Graph`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Color` method uses two auxiliary node-related arrays. The first is named
    `colors` and stores indices of colors chosen for particular nodes. By default,
    the values of all elements are set to `-1`, except the first one, which is set
    to `0`. This means that the color of the first node is automatically set to the
    first color (for example, red). The other auxiliary array (`available`) stores
    information about the availability of particular colors.
  prefs: []
  type: TYPE_NORMAL
- en: The most crucial part of the code is the `for` loop. Within it, you reset the
    availability of colors by setting `true` as the value of all elements within the
    `available` array. Then, you iterate through the neighbor nodes of the current
    node to read their colors and mark such colors as unavailable by setting `false`
    as a value of a particular element in the `available` array. Then, you find the
    first available color for the current node and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the usage of the `Color` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you create a new undirected and unweighted graph, the same as shown in
    the preceding figure, on the left. Then, you add nodes and edges, as well as call
    the `Color` method to perform the node coloring. As a result, you receive an array
    with indices of colors for particular nodes. Then, you present the results in
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With this short introduction, you are ready to proceed to the real-world application,
    namely for coloring the voivodeship map.
  prefs: []
  type: TYPE_NORMAL
- en: Example – voivodeship map
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a program that represents the map of voivodeships in Poland as
    a graph, and color such areas so that two voivodeships with common borders aren’t
    the same color. Of course, you should try to limit the number of colors.
  prefs: []
  type: TYPE_NORMAL
- en: To start, let’s think about the graph’s representation. Here, nodes represent
    particular voivodeships, while edges represent common borders between voivodeships.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map of Poland with the graph already colored is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Illustration of the voivodeship map example](img/B18069_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – Illustration of the voivodeship map example
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is just to color nodes in the graph using the previously described
    algorithm. To do so, you create an undirected and unweighted graph, add nodes
    representing voivodeships, and add edges to indicate common borders. The code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `Color` method is called on the `Graph` instance and the color indices
    for particular nodes are returned. Finally, you present the results in the console.
    The suitable part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You just learned how to color nodes in a graph! However, this is not the end
    of the interesting topics regarding graphs that will be presented in this book.
    Next, we’ll search for the shortest path in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Shortest path
  prefs: []
  type: TYPE_NORMAL
- en: A graph is a great data structure for storing data of various maps, such as
    cities and the distances between them. For this reason, one of the obvious real-world
    applications of graphs is **searching for the** **shortest path** **between two
    nodes, which takes into account a specific cost**, such as the distance, the necessary
    time, or even the amount of fuel required.
  prefs: []
  type: TYPE_NORMAL
- en: There are several approaches to the topic of searching for the shortest path
    in a graph. However, one of the common solutions is **Dijkstra’s algorithm**,
    which makes it possible to **calculate the distance from a starting node to all
    nodes located in the graph**. Then, you can easily get not only the cost of the
    connection between two nodes but also find nodes that are between the start and
    end nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dijkstra’s algorithm uses two auxiliary node-related arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: One for storing an identifier of the previous node, which is the node from which
    the current node can be reached with the smallest overall cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One for storing the minimum distance (cost), which is necessary for accessing
    the current node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s more, it uses the queue for storing nodes that should be checked. **During
    the consecutive iterations, the algorithm updates the minimum distances to particular
    nodes in the graph**. Finally, the auxiliary arrays contain the minimum distance
    (cost) to reach all the nodes from the chosen starting node, as well as information
    on how to reach each node using the shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find a lot of content about Dijkstra’s algorithm on the internet. Just
    search for its name and you will see a huge number of results. As an example,
    you can find useful content related to the implementation presented in this chapter
    at [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following diagram, which presents two various shortest
    paths that have been found using Dijkstra’s algorithm. The left-hand side shows
    the path from node **8** to **1**, while the right-hand side shows the path from
    node **1** to **7**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – Illustration of the shortest paths in a graph](img/B18069_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.23 – Illustration of the shortest paths in a graph
  prefs: []
  type: TYPE_NORMAL
- en: 'It is high time that you see some C# code that can be used to implement Dijkstra’s
    algorithm. The main role is performed by the `GetShortestPath` method, which should
    be added to the `Graph` class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `GetShortestPath` method takes two parameters, namely `source` and `target`
    nodes. First, it creates two node-related auxiliary arrays for storing the indices
    of previous nodes, from which the given node can be reached with the smallest
    overall cost (`previous`), as well as for storing the current minimum distances
    to the given node (`distances`). By default, the values of all elements in the
    `previous` array are set to `-1`, while in the `distances` array, they are set
    to the maximum value of the `int` type. Of course, the distance to the source
    node is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you create a new priority queue and enqueue the data of all nodes. The
    priority of each element is equal to the current distance to such a node. Here,
    you use the same implementation of a priority queue, as presented in [*Chapter
    5*](B18069_05.xhtml#_idTextAnchor165), *Stacks and Queues*, namely from the `OptimizedPriorityQueue`
    NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting part of the code is the `while` loop, which is executed
    until the queue is empty. Within this `while` loop, you get the first node from
    the queue and iterate through all of its neighbors using a `for` loop. Inside
    such a loop, you calculate the distance to a neighbor by taking the sum of the
    distance to the current node and the weight of the edge. If the calculated distance
    is smaller than the currently stored value, you update the values regarding the
    minimum distance to the given neighbor, as well as the index of the previous node,
    from which you can reach the neighbor. It’s worth noting that the priority of
    the element in the queue should be updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining operations are used to resolve the path using the values stored
    in the `previous` array. To do so, you save the indices of the following nodes
    in the `indices` list. Then, you reverse it to achieve the order from the source
    node to the target one. Finally, you create the list of edges to present the result
    in a form that’s suitable for returning from the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the usage of the `GetShortestPath` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you create a new directed and weighted graph, as well as add nodes and
    edges. The missing parts of the code are the same as in the case of the *directed
    and weighted edges* example. Then, you call the `GetShortestPath` method to search
    for the shortest path between nodes `1` and `5`. As a result, you receive a list
    of edges forming the shortest path. Then, you just iterate through all the edges
    and present the results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With this short introduction, together with a simple example, let’s proceed
    to a more advanced and interesting application related to game development.
  prefs: []
  type: TYPE_NORMAL
- en: Example – path in game
  prefs: []
  type: TYPE_NORMAL
- en: The last example we’ll cover in this chapter involves the application of Dijkstra’s
    algorithm to find the shortest path in a game map. Let’s imagine that you have
    a board with various obstacles. For this reason, the player can use only part
    of the board to move. Your task is to find the shortest path between two places
    located on the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let’s represent the board as a jagged array. The suitable part of
    the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To improve the readability of code, the map is represented as an array of `string`
    values. Each row is presented as text, with the number of characters equal to
    the number of columns. The value of each character indicates the availability
    of the point. If it is equal to `0`, the position is available. Otherwise, it
    is not. The `string`-based map representation should then be converted into the
    Boolean jagged array. Such a task is performed by a few lines of code, as shown
    in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the graph, as well as add the necessary nodes and
    edges. The suitable part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, you initialize a new undirected and weighted graph. Then, you use two
    `for` loops to iterate through all the places on the board. Within such loops,
    you check whether the given place is available. If so, you create a new node (`from`).
    Then, you check whether the node placed immediately above the current one is also
    available. If so, a suitable edge is added with a weight equal to `1`. Similarly,
    you can check whether the node placed on the left of the current one is available
    and add an edge if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you just need to get the `Node` instances representing the source and
    the target nodes. You can do so by using the `Find` method and providing the textual
    representation of the node – for example, `0-0` or `16-24`. Then, you call the
    `GetShortestPath` method. In this case, the algorithm will try to find the shortest
    path between the node in the first row and column and the node in the last row
    and column. The code is presented in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the code is related to presenting the map in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To start, you set the proper encoding in the console to be able to present Unicode
    characters as well. Then, you use two `for` loops to iterate through all the places
    on the board. Inside such loops, you choose a color that should be used to represent
    a point in the console, either green (the point is available) or red (unavailable).
    If the currently-analyzed point is a part of the shortest path, the white color
    is set. Finally, you write the Unicode character representing a bullet. When the
    program’s execution exits both loops, the console’s color is reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.24 –\uFEFF \uFEFFScreenshot of the game map example](img/B18069_08_24.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – Screenshot of the game map example
  prefs: []
  type: TYPE_NORMAL
- en: Great work! Now, let’s summarize the topics that were covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter was related to one of the most important data structures available
    while developing applications: graphs. As you learned, a **graph** is a data structure
    that consists of **nodes** and **edges**. Each edge connects two nodes. What’s
    more, there are various variants of edges, such as undirected and directed, as
    well as unweighted and weighted. All of them were described and explained in detail,
    and illustrations and code examples were provided. Two methods of graph representation,
    namely using an **adjacency list** and an **adjacency matrix**, were explained
    as well. You also learned how to implement a graph in the C# language.'
  prefs: []
  type: TYPE_NORMAL
- en: While talking about graphs, it’s important to present some **real-world applications**,
    especially due to the common use of such a data structure. For example, this chapter
    explained the structure of friends that are available on social media or the problem
    of searching for the shortest path in a city.
  prefs: []
  type: TYPE_NORMAL
- en: Among the topics that were covered in this chapter, you learned how to traverse
    a graph to visit all of the nodes in some particular order. Two approaches were
    presented, namely **DFS** and **BFS**. It’s worth mentioning that the traversal
    topic can be also applied to searching for a given node in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the subject of **spanning trees**, as well as **minimum spanning trees**,
    was introduced. As a reminder, a spanning tree is a subset of edges that connects
    all nodes in a graph without cycles, while an MST is a spanning tree with the
    minimum cost from all spanning trees available in the graph. There are a few approaches
    to finding the MST, including **Kruskal’s** and **Prim’s algorithms**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned how to solve the problem of **coloring**, where you assigned
    colors (numbers) to all the nodes to comply with the rule that there cannot be
    an edge between two nodes with the same color.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem was searching for the **shortest path between two nodes**,
    which takes into account a specific cost, such as the distance, the necessary
    time, or even the amount of fuel required. There are several approaches to the
    topic of searching for the shortest path in a graph. However, one of the common
    solutions is **Dijkstra’s algorithm**, which makes it possible to calculate the
    distance from a starting node to all the nodes located in the graph. We covered
    this in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is high time to proceed to the next chapter, which focuses on **practical
    aspects of algorithms** from various groups, including recursive, greedy, back-tracking,
    and even genetic. Let’s turn the page and see them in action!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
