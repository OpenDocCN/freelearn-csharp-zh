- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: 'Captivating Visual Effects: Harnessing Particle Systems and Visual Effect Graph'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 吸引人的视觉效果：利用粒子系统和视觉效果图
- en: In this chapter, we will continue learning about visual effects for our game.
    We will be discussing particle systems, which are a way to simulate fire, waterfalls,
    smoke, and all kinds of fluids. We will see two Unity particle systems to create
    these kinds of effects, **Shuriken** and **Visual Effect (VFX) Graph**, the latter
    being more powerful than the first but requiring more hardware. These technologies
    are used widely in different games to simulate all kinds of effects, like explosions
    and gun muzzles in war games such as Battlefield or magic effects, as in Hogwarts
    Legacy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续学习我们游戏中的视觉效果。我们将讨论粒子系统，这是一种模拟火焰、瀑布、烟雾和各种流体的方法。我们将看到两个 Unity 粒子系统来创建这些效果，**Shuriken**
    和 **视觉效果（VFX）图**，后者比前者更强大，但需要更多的硬件。这些技术在不同的游戏中被广泛使用，以模拟各种效果，如战场等战争游戏中的爆炸和枪口效果，以及在霍格沃茨遗产中的魔法效果。
- en: 'In this chapter, we will cover the following particle system topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下粒子系统主题：
- en: Introduction to particle systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统简介
- en: Creating fluid simulations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流体模拟
- en: Creating complex simulations with Visual Effect Graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视觉效果图创建复杂模拟
- en: Introduction to particle systems
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统简介
- en: All graphics and effects we have created so far use static meshes—3D models
    that can’t be skewed, bent, or deformed in any way other than by using shaders.
    Fluids such as fire and smoke can’t always be represented using this kind of mesh,
    but we can simulate these effects with a combination of static meshes, and this
    is where particle systems are useful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的所有图形和效果都使用了静态网格——不能通过任何方式（除了使用着色器）扭曲、弯曲或变形的 3D 模型。例如，火焰和烟雾这类流体不能总是用这种网格来表示，但我们可以通过静态网格的组合来模拟这些效果，这就是粒子系统发挥作用的地方。
- en: '**Particle systems** are objects that emit and animate lots of **particles**
    or **billboards**, which are simple quad meshes that face the camera. Each particle
    is a static mesh, but rendering, animating, and combining lots of them can generate
    the illusion of a fluid.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子系统**是发射和动画化大量**粒子**或**标牌**的对象，这些是面向摄像机的简单四边形网格。每个粒子都是一个静态网格，但渲染、动画和组合大量粒子可以产生流体的幻觉。'
- en: 'In Figure 11.1, you can see a smoke effect using particle systems on the left,
    and on the right, the **Wireframe** view of the same particles. There, you can
    see the quads that create the illusion of smoke, which is done by applying a smoke
    texture to each of the particles and animating them, so they spawn at the bottom
    and move up in random directions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 11.1 中，你可以看到左侧使用粒子系统创建的烟雾效果，右侧是相同粒子的**线框**视图。在那里，你可以看到创建烟雾幻觉的四边形，这是通过将烟雾纹理应用到每个粒子并对其动画化来实现的，使它们从底部生成并随机向上移动：
- en: '![](img/B21361_11_01_PE.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_01_PE.png)'
- en: 'Figure 11.1: On the left side, a smoke particle system; on the right side,
    the wireframe of the same system'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：左侧是一个烟雾粒子系统；右侧是相同系统的线框
- en: 'In this section, we will cover the following topics related to particles:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与粒子相关的以下主题：
- en: Creating a basic particle system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本粒子系统
- en: Using advanced modules
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级模块
- en: Let’s start by discussing how to create our very first particle system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论如何创建我们第一个粒子系统开始。
- en: Creating a basic particle system
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本粒子系统
- en: 'To illustrate the creation of a particle system, let’s create an explosion
    effect. The idea is to spawn lots of particles at once and spread them in all
    directions. Let’s start with creating the particle system and configuring the
    basic settings it provides to change its default behavior. To do so, follow these
    steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明粒子系统的创建，让我们创建一个爆炸效果。想法是同时生成大量粒子并向所有方向扩散。让我们从创建粒子系统并配置它提供的基本设置以改变其默认行为开始。为此，请按照以下步骤操作：
- en: 'Select the **GameObject | Effects | Particle System** option:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **GameObject | Effects | Particle System** 选项：
- en: '![](img/B21361_11_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_02.png)'
- en: 'Figure 11.2: The Particle System option'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：粒子系统选项
- en: You can see the effect in the following screenshot. The default behavior is
    a column of particles going up, like the smoke effect shown previously. Let’s
    change that.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在下面的屏幕截图中看到效果。默认行为是一列向上移动的粒子，就像之前显示的烟雾效果。让我们改变一下。
- en: '![](img/B21361_11_03_PE.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_03_PE.png)'
- en: 'Figure 11.3: Default particle system appearance'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：默认粒子系统外观
- en: Click the created object in the scene and look at the Inspector.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中单击创建的对象，并查看检查器。
- en: Open the **Shape** section by clicking on the title. Here you will be able to
    specify the particle emitter shape from where the particles are going to be spawned.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击标题打开**形状**部分。在这里，您可以指定粒子发射器的形状，粒子将从该形状中产生。
- en: 'Change the **Shape** property to **Sphere**. Now the particles should move
    in all possible directions instead of following the default one:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**形状**属性更改为**球体**。现在粒子应该会向所有可能的方向移动，而不是遵循默认方向：
- en: '![](img/B21361_11_04_PE.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_04_PE.png)'
- en: 'Figure 11.4: Shape properties'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：形状属性
- en: In the **Particle System** module (usually known as **Main**), set **Start Speed**
    to **10**. This will make the particles move faster.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**粒子系统**模块（通常称为**主**）中，将**起始速度**设置为**10**。这将使粒子移动得更快。
- en: 'In the same module, set **Start Lifetime** to **0.5**. This specifies how long
    a particle will live. In this case, we have given a lifetime of half a second.
    In combination with the speed (10 meters per second), this makes the particles
    disappear after moving 5 meters:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一模块中，将**起始寿命**设置为**0.5**。这指定了粒子将存活多长时间。在这种情况下，我们给了一个半秒的寿命。结合速度（每秒10米），这意味着粒子在移动5米后会消失：
- en: '![](img/B21361_11_05_PE.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_05_PE.png)'
- en: 'Figure 11.5: Main Particle System module'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：主粒子系统模块
- en: Open the **Emission** module and set **Rate over Time** to **0**. This property
    specifies how many particles will be emitted per second, but for an explosion,
    we actually need a burst of particles, so we won’t emit particles constantly over
    time in this case.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**发射**模块，并将**随时间变化率**设置为**0**。此属性指定每秒将发射多少粒子，但对于爆炸，我们实际上需要一个粒子爆发，所以在这种情况下我们不会在随时间持续发射粒子。
- en: 'In the **Bursts** list, click the **+** button at the bottom, and in the created
    item in the list, set the **Count** column to **100**:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**爆发**列表中，点击底部的**+**按钮，并在列表中创建的项目中，将**数量**列设置为**100**：
- en: '![](img/B21361_11_06_PE.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_06_PE.png)'
- en: 'Figure 11.6: The Emission module'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：发射模块
- en: 'In the Main module (the one titled **Particle System**) set **Duration** to
    `1` and uncheck **Looping**. In our case, the explosion won’t repeat constantly;
    we just need one explosion:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主**模块（标题为**粒子系统**）中，将**持续时间**设置为`1`并取消选中**循环**。在我们的情况下，爆炸不会不断重复；我们只需要一次爆炸：
- en: '![](img/B21361_11_07_PE.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_07_PE.png)'
- en: 'Figure 11.7: The Looping checkbox'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：循环复选框
- en: Now that we already have the particle in the scene, we notice that it isn’t
    looping. In order to achieve this effect, you need to manually hit the **Play**
    button that is shown in the **Particle Effect** window in the bottom-right part
    of the **Scene** view to see the system. If you don’t see that window, remember
    to first select the GameObject with the particle system in the **Hierarchy** window.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在场景中有了粒子，我们注意到它没有循环。为了实现这种效果，您需要手动点击**场景**视图右下角的**粒子效果**窗口中显示的**播放**按钮来查看系统。如果您没有看到该窗口，请记住首先在**层次结构**窗口中选择带有粒子系统的GameObject。
- en: '![](img/B21361_11_08_PE.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_08_PE.png)'
- en: 'Figure 11.8: Particle system playback controls'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：粒子系统播放控制
- en: 'Set **Stop Action** to **Destroy**. This will destroy the object when the **Duration**
    time has passed. This will just work when you are running the game, so you can
    safely use this configuration while editing your scene:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**停止动作**设置为**销毁**。这将使对象在**持续时间**时间过后被销毁。这仅在运行游戏时才会起作用，因此您可以在编辑场景时安全地使用此配置：
- en: '![](img/B21361_11_09_PE.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_09_PE.png)'
- en: 'Figure 11.9: Stop Action set to Destroy'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：停止动作设置为销毁
- en: 'Set **Start Size** of the **Main** module to **3**. This will make the particles
    bigger so they seem denser:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**主**模块的**起始大小**设置为**3**。这将使粒子更大，看起来更密集：
- en: '![](img/B21361_11_10_PE.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_10_PE.png)'
- en: 'Figure 11.10: Particle system Start Size'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：粒子系统起始大小
- en: Click on the down-pointing arrow to the right of the **Start Rotation** property
    of the Main module and select **Random Between Two Constants**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击主模块中**起始旋转**属性右侧的向下箭头，并选择**在两个常量之间随机**。
- en: 'Set **Start Rotation** to `0` and `360` in the two input values that appeared
    after *step 14*. This allows us to give the particles a random rotation when they
    spawn to make them look slightly different from each other:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤14*之后出现的两个输入值中将**起始旋转**设置为`0`和`360`。这允许我们在粒子产生时给它们一个随机旋转，使它们看起来略有不同：
- en: '![](img/B21361_11_11_PE.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_11_PE.png)'
- en: 'Figure 11.11: Random Start Rotation'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：随机起始旋转
- en: Now the particles behave as expected, but they don’t look as expected. Let’s
    change that. Create a new material by clicking on the **+** icon in the **Project**
    view and selecting **Material**. Let’s call it `Explosion`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在粒子表现如预期，但看起来并不如预期。让我们改变一下。通过在**项目**视图中点击**+**图标并选择**材质**来创建一个新的材质。让我们称它为`Explosion`。
- en: 'Set its shader to **Universal Render Pipeline/Particles/Unlit**. This is a
    special shader that is used to apply a texture to the particle system:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其着色器设置为**通用渲染管线/粒子/无光照**。这是一个特殊的着色器，用于将纹理应用到粒子系统中：
- en: '![](img/B21361_11_12_PE.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_12_PE.png)'
- en: 'Figure 11.12: Particle system Material shader'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：粒子系统材质着色器
- en: 'Download a `smoke` particle texture from the internet or the **Asset Store**.
    In this case, it is important to download one with a black background; ignore
    the others:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网或**资源商店**下载一个`烟雾`粒子纹理。在这种情况下，下载一个黑色背景的纹理很重要；忽略其他纹理：
- en: '![](img/B21361_11_13_PE.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_13_PE.png)'
- en: 'Figure 11.13: Smoke particle texture'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：烟雾粒子纹理
- en: Set this texture as the **Base Map** of the material.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此纹理设置为材质的**基础纹理**。
- en: 'Set **Surface Type** to **Transparent** and **Blending Mode** to **Additive**.
    Doing this will make the particles blend with each other, instead of being drawn
    on each other, to simulate a big mass of smoke instead of individual smoke puffs.
    We use the **Additive** mode because our texture has a black background and we
    want to create a lighting effect (the explosion will brighten the scene):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**表面类型**设置为**透明**，并将**混合模式**设置为**添加**。这样做会使粒子相互融合，而不是相互绘制，以模拟一大团烟雾而不是单个烟雾团。我们使用**添加**模式，因为我们的纹理有黑色背景，我们想要创建一个光照效果（爆炸会使场景变亮）：
- en: '![](img/B21361_11_14_PE.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_14_PE.png)'
- en: 'Figure 11.14: Surface options for particles'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：粒子的表面选项
- en: 'Drag your material to the **Material** property of the **Renderer** module:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的材质拖到**渲染器**模块的**材质**属性中：
- en: '![](img/B21361_11_15_PE.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_15_PE.png)'
- en: 'Figure 11.15: Particle Material settings'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：粒子材质设置
- en: 'Now your system should look like the following figure:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的系统应该看起来像以下图所示：
- en: '![](img/B21361_11_16_PE.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_16_PE.png)'
- en: 'Figure 11.16: Result of the previous settings'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：前述设置的成果
- en: With those steps, we have changed how the particles or billboards will spawn
    (using the **Emission** module), in which direction they will move (using the
    **Shape** module), how fast they will move, how long they will last, how big they
    will be (using the **Main** module), and what they will look like (using the **Renderer**
    module). Creating particle systems is a simple case of properly configuring their
    different settings. Of course, doing it properly is an art on its own; it requires
    creativity and knowledge of how to use all the settings and configurations they
    provide. So, to increase our skillset, let’s discuss some advanced modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们已经改变了粒子或广告牌的生成方式（使用**发射**模块），它们将移动的方向（使用**形状**模块），它们的移动速度，它们的持续时间，它们的大小（使用**主**模块），以及它们的形状（使用**渲染器**模块）。创建粒子系统是一个简单案例，只需正确配置它们的设置。当然，正确地做这件事本身就是一门艺术；它需要创造力和了解如何使用所有提供的设置和配置。因此，为了提高我们的技能，让我们讨论一些高级模块。
- en: Using advanced modules
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高级模块
- en: 'Our system looks nice, but we can improve it a lot, so let’s enable some new
    modules to increase its quality:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统看起来不错，但我们还可以大幅改进它，所以让我们启用一些新模块来提高其质量：
- en: 'Check the checkbox to the left of **Color over Lifetime** to enable it:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**生命周期颜色**左侧的复选框中勾选以启用它：
- en: '![](img/B21361_11_17_PE.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_17_PE.png)'
- en: 'Figure 11.17: Enabling the Color over Lifetime module'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：启用生命周期颜色模块
- en: Open the module by clicking on the title and then click the white bar to the
    right of the **Color** property. This will open the Gradient Editor.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击标题打开模块，然后点击**颜色**属性右侧的白色条，这将打开渐变编辑器。
- en: 'Click slightly to the right of the top-left white marker in the bar to create
    a new marker. Also, click slightly to the left of the top-right white marker to
    create the fourth marker. These markers will allow us to specify the transparency
    of the particles during their lifetime:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条形图的最左上角白色标记的稍右位置点击以创建一个新的标记。同样，在条形图最右上角白色标记的稍左位置点击以创建第四个标记。这些标记将允许我们在粒子的生命周期中指定其透明度：
- en: '![](img/B21361_11_18.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_18.png)'
- en: 'Figure 11.18: Color over Lifetime gradient editor'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：生命周期颜色渐变编辑器
- en: If you accidentally created unwanted markers, just drag them outside the window
    to remove them. Make sure that **Mode** is set to **Blend (Classic)**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您意外创建了不需要的标记，只需将它们拖出窗口即可删除它们。确保**模式**设置为**混合（经典）**。
- en: 'Click on the top-left marker (not the one we created, the one that was already
    there) and set the **Alpha** slider at the bottom to `0`. Do the same with the
    top-right marker, as shown in the following screenshot. Now you should see the
    particles fading away instead of popping out of existence when the explosion is
    finishing:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的标记（不是我们创建的，而是已经存在的那个）并将底部的**Alpha**滑块设置为`0`。按照以下截图所示，以同样的方式对右上角的标记进行操作。现在您应该会看到粒子在爆炸结束时逐渐消失而不是突然消失：
- en: '![](img/B21361_11_19.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_19.png)'
- en: 'Figure 11.19: Fade-in and fade-out gradient'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19：淡入和淡出渐变
- en: Enable the **Limit Velocity over Lifetime** module by clicking on its checkbox.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击复选框启用**寿命内限制速度**模块。
- en: 'Set the **Dampen** setting to `0.1`. This will make the particles slowly stop
    instead of continuing to move:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**阻尼**设置设置为`0.1`。这将使粒子缓慢停止而不是继续移动：
- en: '![](img/B21361_11_20_PE.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_20_PE.png)'
- en: 'Figure 11.20: Dampen the velocity to make the particles stop'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20：阻尼速度以使粒子停止
- en: 'Enable **Rotation over Lifetime** and set **Angular Velocity** between `-90`
    and `90`. Remember that you should set the value to **Random Between Two Constants**
    by clicking on the down-pointing arrow to the right of the property. Now the particles
    should rotate during their lives to simulate more motion:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**寿命内旋转**并将**角速度**设置为`-90`到`90`之间。请记住，您应该通过点击属性右侧的向下箭头将值设置为**在两个常量之间随机**。现在粒子应该在它们的寿命期间旋转以模拟更多的运动：
- en: '![](img/B21361_11_21_PE.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_21_PE.png)'
- en: 'Figure 11.21: Random rotation velocity'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21：随机旋转速度
- en: Some of these effects will be very subtle given the short lifetime we set in
    the **Main** modulewhen we just created the particle. Feel free to increase the
    **Lifetime** value to see those effects in more detail, but consider that this
    could lead to an excessive number of particles if you spawn them frequently, reducing
    performance. Just be wary about how they impact your performance when tweaking
    those values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在创建粒子时在**主**模块中设置的寿命较短，因此一些效果将非常微妙。您可以自由地增加**寿命**值以更详细地查看这些效果，但请考虑，如果您频繁地生成粒子，这可能会导致粒子数量过多，从而降低性能。只需注意调整这些值时它们对性能的影响。
- en: 'As you can see, there are lots of extra modules that can be enabled and disabled
    to add layers of behavior on top of the existing ones, so again, use them creatively
    to create all kinds of effects. Remember that you can create Prefabs of these
    systems to replicate them all over your scene. I also recommend searching for
    and downloading particle effects from the Asset Store to see how other people
    have used the same system to create amazing effects. Seeing a variety of different
    systems is the best way to learn how to create them, and that is what we are going
    to do in the next section: create more systems!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有许多额外的模块可以启用和禁用，以在现有行为之上添加层次。因此，再次创造性地使用它们来创建各种效果。请记住，您可以为这些系统创建预制件以在场景中复制它们。我还建议在资产商店中搜索和下载粒子效果，以了解其他人如何使用相同的系统创建惊人的效果。看到各种不同的系统是学习如何创建它们的最佳方式，这就是我们在下一节将要做的：创建更多系统！
- en: Creating fluid simulations
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流体模拟
- en: As we said, the best way to learn how to create particle systems is to keep
    looking for already-created particle systems and explore how people have used
    the various system settings to create completely different simulations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，学习如何创建粒子系统的最佳方式是持续寻找已经创建的粒子系统，并探索人们如何使用各种系统设置来创建完全不同的模拟。
- en: 'In this section, we will learn how to create the following effects using particle
    systems:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用粒子系统创建以下效果：
- en: A waterfall effect
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水帘效果
- en: A bonfire effect
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 篝火效果
- en: Let’s start with the simplest one, the waterfall effect.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的一个开始，即水帘效果。
- en: Creating a waterfall effect
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建水帘效果
- en: 'In order to do this, follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤操作：
- en: Create a new particle system (**GameObject | Effects | Particle System**).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的粒子系统（**GameObject | Effects | Particle System**）。
- en: 'Set **Shape** to **Edge** and **Radius** to `5` in the **Shape** module. This
    will make the particles spawn along a line of emission:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**形状**模块中将**形状**设置为**边缘**并将**半径**设置为`5`。这将使粒子沿着发射线生成：
- en: '![](img/B21361_11_22_PE.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_22_PE.png)'
- en: 'Figure 11.22: Edge shape'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22：边缘形状
- en: Set the **Rate over Lifetime** value of the **Emission** module to `50`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Emission** 模块的 **Rate over Lifetime** 值设置为 `50`。
- en: 'Set the **Start Size** of the **Main** module to `3` and **Start Lifetime**
    to `3`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Main** 模块的 **Start Size** 设置为 `3` 和 **Start Lifetime** 设置为 `3`：
- en: '![](img/B21361_11_23_PE.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_23_PE.png)'
- en: 'Figure 11.23: Main module settings'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23：主模块设置
- en: 'Set **Gravity Modifier** of the **Main** module to `0.5`. This will make the
    particles fall down:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Main** 模块的 **Gravity Modifier** 设置为 `0.5`。这将使粒子下落：
- en: '![](img/B21361_11_24_PE.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_24_PE.png)'
- en: 'Figure 11.24: Gravity Modifier in the Main module'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24：主模块中的重力修改器
- en: 'Use the same **Explosion** material we created previously for this system:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前创建的相同 **Explosion** 材质来创建这个系统：
- en: '![](img/B21361_11_25_PE.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_25_PE.png)'
- en: 'Figure 11.25: Explosion particle material'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.25：爆炸粒子材质
- en: Enable **Color over Lifetime** and open the Gradient Editor. Make sure that
    **Mode** is set to **Blend (Classic)**, given that it’s the simplest and most
    performant one.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 **Color over Lifetime** 并打开渐变编辑器。确保 **Mode** 设置为 **Blend (Classic)**，因为它是最简单且性能最好的一个。
- en: 'Click the bottom-right marker and, this time, you should see a color picker
    instead of an alpha slider. The top markers allow you to change the transparency
    over time, while the bottom ones change the color of the particles over time.
    Set a light blue color in this marker (you can also use any other color):'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下角的标记，这次你应该看到一个颜色选择器而不是透明度滑块。顶部的标记允许你随时间改变透明度，而底部的标记则随时间改变粒子的颜色。在这个标记中设置浅蓝色颜色（你也可以使用任何其他颜色）：
- en: '![](img/B21361_11_26.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_26.png)'
- en: 'Figure 11.26: White to light blue gradient'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.26：从白色到浅蓝色的渐变
- en: 'As a challenge, I suggest you add a little particle system where this one ends
    to create some water splashes, simulating the water colliding with a lake at the
    bottom. Now we can add this particle system to one of the hills of our scene to
    decorate it, as in the following screenshot. I have adjusted the system a little
    bit to look better in this scenario. I challenge you to tweak it by yourself to
    make it look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，我建议你在这个粒子系统结束的地方添加一个小粒子系统，以创建一些水花，模拟水与底部湖泊的碰撞。现在我们可以将这个粒子系统添加到场景中的一个山丘上，以装饰它，如下面的截图所示。我已经对这个系统做了一些调整，使其在这个场景中看起来更好。我挑战你自己调整它，使其看起来像这样：
- en: '![](img/B21361_11_27_PE.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_27_PE.png)'
- en: 'Figure 11.27: The waterfall particle system being applied to our current scene'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.27：瀑布粒子系统应用于当前场景
- en: 'Now, let’s create another effect: a bonfire.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个效果：篝火。
- en: Creating a bonfire effect
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建篝火效果
- en: 'In order to create a bonfire, do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建篝火，请执行以下操作：
- en: Create a particle system as we did in the *Creating a basic particle system*
    section in **GameObject | Effects | Particle System**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **GameObject | Effects | Particle System** 中创建一个粒子系统，就像我们在 *创建基本粒子系统* 部分所做的那样。
- en: 'Look for a **Fire Particle Texture Sheet** texture on the internet or in the
    Asset Store. This kind of texture should look like a grid of different flame textures.
    The idea is to apply a flame animation to our particles, swapping all those mini
    textures:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在互联网或资产商店中寻找一个 **Fire Particle Texture Sheet** 纹理。这种纹理应该看起来像不同火焰纹理的网格。想法是将火焰动画应用到我们的粒子中，交换所有这些小纹理：
- en: '![](img/B21361_11_28_PE.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_28_PE.png)'
- en: 'Figure 11.28: Particles texture sprite sheet'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.28：粒子纹理精灵图
- en: Create a particle material that uses the **Universal Render Pipeline/Particles/Unlit**
    shader.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用 **Universal Render Pipeline/Particles/Unlit** 着色器的粒子材质。
- en: Set the flames sprite sheet texture as the Base Map.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将火焰精灵图纹理设置为基图。
- en: Set the color to the right of **Base Map** to white.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Base Map** 右侧的颜色设置为白色。
- en: 'Set this material as the particle material. Remember to set **Surface Type**
    to **Transparent** and **Blending Mode** to **Additive**:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此材质设置为粒子材质。请记住将 **Surface Type** 设置为 **Transparent** 和 **Blending Mode** 设置为
    **Additive**：
- en: '![](img/B21361_11_29.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_29.png)'
- en: 'Figure 11.29: A material with a particle sprite sheet'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.29：带有粒子精灵图的材质
- en: 'Enable the **Texture Sheet Animation** module and set the **Tiles** property
    according to your **Fire** sheet. In my case, I have a grid of 4x4 sprites, so
    I put `4` in **X** and `4` in **Y**. After this, you should see the particles
    swapping textures:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 **Texture Sheet Animation** 模块，并根据你的 **Fire** 图纸设置 **Tiles** 属性。在我的情况下，我有一个
    4x4 的精灵网格，所以我将 `4` 放在 **X** 和 `4` 放在 **Y**。之后，你应该会看到粒子在交换纹理：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_11_30_PE.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_11_30_PE.png)'
- en: 'Figure 11.30: Enabling Texture Sheet Animation'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.30：启用纹理表动画
- en: Set **Start Speed** to `0` and **Start Size** to `1.5` in the **Main** module.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主**模块中将**起始速度**设置为`0`，将**起始大小**设置为`1.5`。
- en: Set **Radius** to `0.5` in the **Shape** module.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**形状**模块中将**半径**设置为`0.5`。
- en: 'Create a second particle system and make it a child of **Fire System**:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个粒子系统并将其设置为**火系统**的子系统：
- en: '![](img/B21361_11_31_PE.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.31](img/B21361_11_31_PE.png)'
- en: 'Figure 11.31: Parenting particle systems'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.31：粒子系统的父子关系
- en: Apply the **Explosion** material from the explosion example.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用爆炸示例中的**爆炸**材质。
- en: Set **Angle** to `0` and **Radius** to `0.5` in the **Shape** module.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**形状**模块中将**角度**设置为`0`，将**半径**设置为`0.5`。
- en: 'The system should look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应该看起来像这样：
- en: '![](img/B21361_11_32_PE.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.30](img/B21361_11_32_PE.png)'
- en: 'Figure 11.32: Result of combining fire and smoke particle systems'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.32：结合火焰和烟雾粒子系统的结果
- en: As you can see, you can combine several particle systems to create a single
    effect. Take care when doing this because it’s easy to emit too many particles
    and affect the game’s performance. Particles are not cheap and may cause a reduction
    in the game’s **Frames Per Second** (**FPS**) if you are not cautious with them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以将多个粒子系统组合起来创建一个单一的效果。在做这件事时要小心，因为很容易产生过多的粒子并影响游戏性能。粒子并不便宜，如果您不小心，可能会降低游戏的**每秒帧数**（**FPS**）。
- en: 'One of the reasons why particles are expensive is called **overdraw**, or the
    scenario where you have multiple overlapping objects. Remember, particles are
    just a lot of quads rendered on top of each other to simulate a single fluid.
    This means some screen pixels get drawn several times to achieve the effect, which
    can be very heavy on the GPU. You can analyze this and other GPU problems using
    tools like RenderDoc. Learn more about it here: [https://docs.unity3d.com/Manual/RenderDocIntegration.html](https://docs.unity3d.com/Manual/RenderDocIntegration.html)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子之所以昂贵，其中一个原因被称为**过度绘制**，或者多个重叠对象的情况。记住，粒子只是许多叠加在一起的四边形渲染，以模拟单一流体。这意味着一些屏幕像素需要绘制多次才能达到效果，这可能会对
    GPU 产生很大负担。您可以使用 RenderDoc 等工具分析这个问题和其他 GPU 问题。更多关于 RenderDoc 的信息请在这里了解：[https://docs.unity3d.com/Manual/RenderDocIntegration.html](https://docs.unity3d.com/Manual/RenderDocIntegration.html)
- en: So far, we have explored one of the Unity systems that you can use to create
    these kinds of effects, and while this system is enough for most situations, Unity
    recently released a new one that can generate more complex effects, called **Visual
    Effect Graph**. Let’s see how to use it and see how both systems differ.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了您可以使用来创建这类效果的一个 Unity 系统，虽然这个系统对于大多数情况来说已经足够，但 Unity 最近发布了一个新的系统，可以生成更复杂的效果，称为**视觉效果图**。让我们看看如何使用它，并看看这两个系统有何不同。
- en: Creating complex simulations with Visual Effect Graph
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视觉效果图创建复杂模拟
- en: The particle system we have used so far handles all calculations in the CPU.
    This has both pros and cons. A pro is that it can run on all possible devices
    that Unity supports, regardless of their capabilities (all of them have CPUs),
    but a con is that we can exceed CPU capabilities easily if we are not cautious
    with the number of particles we emit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止使用的粒子系统在 CPU 上处理所有计算。这既有优点也有缺点。优点是它可以在所有可能的 Unity 支持的设备上运行，无论它们的性能如何（它们都有
    CPU），但缺点是如果我们不小心发射的粒子数量过多，我们很容易超过 CPU 的性能。
- en: 'Modern games require more complex particle systems to generate believable effects,
    and this kind of CPU-based particle system solution has started to reach its limit.
    This is where Visual Effect Graph comes in:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏需要更复杂的粒子系统来生成逼真的效果，而这种基于 CPU 的粒子系统解决方案已经开始达到其极限。这就是视觉效果图（Visual Effect Graph）的用武之地：
- en: '![](img/B21361_11_33_PE.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.33](img/B21361_11_33_PE.png)'
- en: 'Figure 11.33: On the left is a massive particle system, and on the right, an
    example of a Visual Effect Graph'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.33：左侧是一个庞大的粒子系统，右侧是一个视觉效果图的示例
- en: '**Visual Effect Graph** is a GPU-based particle system solution, meaning that
    the system is executed in the video card instead of the CPU. That’s because video
    cards are far more efficient at executing lots and lots of little simulations,
    like the ones each particle of a system needs, so we can reach far higher orders
    of magnitude in the number of particles with the GPU than we can with the CPU.
    The con here is that we need a fairly modern GPU that has **compute shader** capabilities
    to support this system, so we will exclude certain target platforms using this
    system (forget about most mobile phones), so use it if your target platform supports
    it (mid- to high-end PCs, consoles, and some high-end phones).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Effect Graph**是一个基于GPU的粒子系统解决方案，这意味着系统是在显卡上而不是CPU上执行的。这是因为显卡在执行大量的小型模拟方面效率更高，比如系统中的每个粒子都需要，所以我们使用GPU可以达到比CPU更高的粒子数量级别。这里的缺点是我们需要一个具有**计算着色器**功能的相当现代的GPU来支持这个系统，因此我们将排除使用这个系统的某些目标平台（忘掉大多数手机），所以如果你的目标平台支持它（中高端PC、游戏机和一些高端手机），请使用它。'
- en: 'In this section, we will discuss the following topics regarding Visual Effect
    Graph:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下关于Visual Effect Graph的主题：
- en: Installing Visual Effect Graph
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Visual Effect Graph
- en: Creating and analyzing a Visual Effect Graph
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和分析Visual Effect Graph
- en: Creating a rain effect
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建雨效果
- en: Let’s start by seeing how we can add support for Visual Effect Graph in our
    project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何在项目中添加对Visual Effect Graph的支持。
- en: Installing Visual Effect Graph
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Visual Effect Graph
- en: So far, we have used lots of Unity features that were already installed in our
    project, but Unity can be extended with a myriad of plugins, both official and
    third-party. Visual Effect Graph is one of those features that needs to be independently
    installed if you are using **Universal Render Pipeline** **(URP)**. We can do
    that using **Package Manager**, a Unity window dedicated to managing official
    Unity plugins.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了在我们项目中已经安装的许多Unity功能，但Unity可以通过大量的插件进行扩展，包括官方和第三方插件。Visual Effect
    Graph就是那些需要独立安装的功能之一，如果你使用的是**通用渲染管线**（**URP**）。我们可以通过**包管理器**来实现，这是一个专门用于管理官方Unity插件的Unity窗口。
- en: Something to think about when you are installing those packages is that each
    package or plugin has its own version, independent of the Unity version. That
    means that you can have Unity 2022.1 installed, but Visual Effect Graph 13.1.8
    or whatever version you want, and you can actually update the package to a newer
    version without upgrading Unity.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装这些包时，需要考虑的是，每个包或插件都有自己的版本，与Unity版本无关。这意味着你可以安装Unity 2022.1，但也可以安装Visual
    Effect Graph 13.1.8或任何你想要的版本，并且实际上可以更新包到新版本而不需要升级Unity。
- en: This is important because some versions of these packages require a minimum
    version of Unity—for example, Visual Effect Graph 13.1.8 requires Unity 2022.1
    as a minimum. Moreover, some packages depend on other packages and specific versions
    of those packages, so we need to ensure we have the correct versions of every
    package to ensure compatibility. To be clear, the dependencies of a package are
    installed automatically, but sometimes we can have them installed separately,
    so in that scenario, we need to check the required version. It sounds complicated,
    but it is simpler than it sounds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为一些这些包的版本需要Unity的最小版本——例如，Visual Effect Graph 13.1.8需要Unity 2022.1作为最小版本。此外，一些包依赖于其他包以及这些包的特定版本，因此我们需要确保我们拥有每个包的正确版本，以确保兼容性。明确来说，包的依赖项会自动安装，但有时我们可以单独安装它们，所以在那种情况下，我们需要检查所需的版本。听起来很复杂，但实际上并没有那么复杂。
- en: 'At the time of writing this book, in order to get Visual Effect Graph working
    properly, we need version 15.0.6, and we also need the same version of **Universal
    RP**. Yes, Universal RP is another feature you can install using the Package Manager,
    but as we created the project using the **Universal RP** template, it was already
    installed for us with the proper version. With that in mind, let’s install the
    Visual Effect Graph as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，为了使Visual Effect Graph正常工作，我们需要版本15.0.6，并且还需要相同版本的**通用RP**。是的，通用RP是另一个你可以使用包管理器安装的功能，但因为我们使用的是**通用RP**模板创建的项目，所以它已经为我们安装了正确的版本。考虑到这一点，让我们按照以下步骤安装Visual
    Effect Graph：
- en: 'In the top menu of Unity, go to **Window | Package Manager**:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity的顶部菜单中，转到**窗口 | 包管理器**：
- en: '![](img/B21361_11_34.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_34.png)'
- en: 'Figure 11.34: Package Manager location'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34：包管理器位置
- en: 'Remember to be sure the **Packages** dropdown is in **Unity Registry** mode,
    to see the Unity official packages list:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保**包**下拉菜单处于**Unity注册表**模式，以查看Unity官方包列表：
- en: '![](img/B21361_11_35.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_35.png)'
- en: 'Figure 11.35: Package Manager Unity Registry mode'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.35：包管理器Unity注册表模式
- en: In the left column, locate **Universal RP** and check whether it says 15.0.6
    or higher to the right. If it does, jump to *step 6*. Remember, though, that a
    higher version may look different or have different steps for use than the ones
    displayed in this chapter.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列中，找到**Universal RP**并检查右侧是否显示15.0.6或更高版本。如果是，跳转到*步骤6*。不过，请记住，更高版本可能看起来不同，或者使用步骤与本章中显示的不同。
- en: 'If you don’t have version 15.0.6 or higher, click on the **Version History**
    tab to the right of the panel to display a list of all possible versions to install.
    Locate **15.0.6** and click it. In my case, it says **installed** as I have that
    version already installed in the project, and there’s no other one available for
    Unity 2022:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有15.0.6或更高版本，点击面板右侧的**版本历史**选项卡以显示所有可能的版本列表。定位到**15.0.6**并点击它。在我的情况下，它显示为**已安装**，因为我已经在项目中安装了该版本，并且没有其他版本可用于Unity
    2022：
- en: '![](img/B21361_11_36.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_36.png)'
- en: 'Figure 11.36: Package version selector'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.36：包版本选择器
- en: Click on the **Update to 15.0.6** button in the bottom-right part of the window
    and wait for the package to update.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右下角的**更新到15.0.6**按钮，等待包更新。
- en: 'Look for the **Visual Effect Graph** package on the left side of the window.
    As you did with Universal RP, make sure you select version **15.0.6** or the closest
    higher available version:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口左侧查找**视觉效果图**包。与Universal RP一样，确保您选择版本**15.0.6**或更高版本：
- en: '![](img/B21361_11_37.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_37.png)'
- en: 'Figure 11.37: Visual Effect Graph package'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.37：视觉效果图包
- en: Click the **Install** button at the bottom right of the window and wait for
    the package to install. Sometimes it is recommended to restart Unity after installing
    packages, so save your changes and restart Unity.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右下角的**安装**按钮，等待包安装。有时建议在安装包后重启Unity，因此请保存您的更改并重启Unity。
- en: Now that we have installed Visual Effect Graph, let’s create our first particle
    system using it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了视觉效果图，让我们使用它创建第一个粒子系统。
- en: Creating and analyzing Visual Effect Graph
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和分析视觉效果图
- en: 'The method to create a particle system using Visual Effect Graph is similar
    to a regular particle system. We will chain and configure modules as parts of
    the behavior of the particles, each module adding some specific behavior. First,
    we need to create **Visual Effect Graph**, an asset that will contain all the
    modules and configurations, and then make a GameObject that will execute the graph
    asset to spawn particles. Let’s do that with the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视觉效果图创建粒子系统的方法与常规粒子系统类似。我们将链式配置模块作为粒子行为的一部分，每个模块添加一些特定的行为。首先，我们需要创建**视觉效果图**，这是一个将包含所有模块和配置的资产，然后创建一个GameObject来执行图资产以生成粒子。让我们按照以下步骤进行：
- en: 'In the **Project** window, click on the **+** button and look for **Visual
    Effects | Visual Effect Graph**:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，点击**+**按钮，查找**视觉效果 | 视觉效果图**：
- en: '![](img/B21361_11_38.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_38.png)'
- en: 'Figure 11.38: Visual Effect Graph'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.38：视觉效果图
- en: 'From the new pop up, select the option **Simple Loop** from the available templates.
    You can rename the file as Rain:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新弹出的窗口中，从可用模板中选择**简单循环**选项。您可以重命名文件为Rain：
- en: '![](img/B21361_11_39.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_39.png)'
- en: 'Figure 11.39: Simple Loop template'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.39：简单循环模板
- en: 'Create an empty GameObject using the **GameObject** | **Create Empty** option:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **Create Empty**选项创建一个空GameObject：
- en: '![](img/B21361_11_40.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_40.png)'
- en: 'Figure 11.40: Empty GameObject creation'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.40：空GameObject创建
- en: Select the created object and look at the Inspector.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建的对象，查看检查器。
- en: 'Using the **Add Component** search bar, look for the **Visual Effect** component
    and click on it to add it to the object:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加组件**搜索栏，查找**视觉效果**组件并点击它以将其添加到对象：
- en: '![](img/B21361_11_41_PE.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_41_PE.png)'
- en: 'Figure 11.41: Adding a component to the Visual Effect Graph'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.41：向视觉效果图添加组件
- en: 'Drag the **Visual Effect** asset we created to the **Asset Template** property
    of the Visual Effect component in our GameObject:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们创建的**视觉效果**资产拖动到GameObject中的视觉效果组件的**资产模板**属性：
- en: '![](img/B21361_11_42_PE.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_42_PE.png)'
- en: 'Figure 11.42: Visual Effect using the previously created Visual Effect asset'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.42：使用之前创建的视觉效果资产
- en: 'You should see the gizmo of a Magic Lamp representing our object, which is
    the default state of the new **Visual Effect** asset, meaning it’s being created
    correctly:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到一个代表我们的对象的魔法灯图示，这是新**视觉效果**资产的默认状态，意味着它被正确创建：
- en: '![](img/B21361_11_43_PE.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_43_PE.png)'
- en: Figure 11.43 Default Visual Effect asset results
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.43 默认视觉效果资产结果
- en: 'After creating the basic visual effect, and now that we have a base effect,
    let’s create something that requires a lot of particles, such as dense rain. Before
    doing so, we will explore some core concepts of Visual Effect Graph. If you double-click
    the **Visual Effect** asset, you will see the following editor:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基本视觉效果并拥有基础效果之后，现在让我们创建一些需要大量粒子的东西，比如密集的雨。在这样做之前，我们将探索视觉效果图的一些核心概念。如果你双击**视觉效果**资产，你会看到以下编辑器：
- en: '![](img/B21361_11_44_PE.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_44_PE.png)'
- en: 'Figure 11.44: Visual Effect Graph Editor window'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.44：视觉效果图编辑器窗口
- en: This window is composed of several interconnected nodes, generating a flow of
    actions to be executed. As with Shader Graph, you can navigate this window by
    keeping the *Alt* key (*Option* on Mac) pressed and dragging with the mouse the
    empty areas of the graph. At first, it seems similar to Shader Graph, but it works
    a little bit differently, so let’s study each section of the default graph.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口由几个相互连接的节点组成，生成要执行的动作流。与Shader Graph类似，你可以通过按住*Alt*键（Mac上的*Option*键）并用鼠标拖动图中的空白区域来导航这个窗口。一开始，它看起来与Shader
    Graph相似，但它的工作方式略有不同，所以让我们研究默认图的每个部分。
- en: 'The first area to explore is the dotted one that contains three nodes. This
    is what Unity calls a **system**. A System is a set of nodes that defines how
    a particle will behave, and you can have as many as you want, which is the equivalent
    of having several particle system objects. Each System is composed of **contexts**,
    the nodes inside the dotted area, and in this case, we have **Initialize Particle**,
    **Update Particle**, and **Output Particle Quad**. Each Context represents a different
    stage of the particle system logic flow, so let’s define what each Context in
    our graph does:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要探索的区域是包含三个节点的虚线区域。这是Unity所说的**系统**。系统是一组节点，它定义了粒子将如何行为，你可以拥有任意多个，这相当于拥有多个粒子系统对象。每个系统由**上下文**组成，即虚线区域内的节点，在这个例子中，我们有**初始化粒子**、**更新粒子**和**输出粒子四边形**。每个上下文代表粒子系统逻辑流程的不同阶段，因此让我们定义我们图中的每个上下文的作用：
- en: '**Initialize Particle**: This defines the initial data of each emitted particle,
    such as position, color, speed, and size. It is similar to the **Start** properties
    in the **Main** module of the particle system we saw at the beginning of this
    chapter. The logic in this node will only execute when a new particle is emitted.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化粒子**：这定义了每个发射粒子的初始数据，例如位置、颜色、速度和大小。它类似于我们在本章开头看到的粒子系统的**主**模块中的**开始**属性。这个节点中的逻辑只有在新的粒子被发射时才会执行。'
- en: '**Update Particle**: Here, we can apply modifications to the data of the living
    particles. We can change particle data such as the current velocity or particle
    size of all the frames. This is similar to the **Overtime** nodes of the particle
    systems seen at the beginning of the chapter.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新粒子**：在这里，我们可以对存活粒子的数据进行修改。我们可以改变粒子数据，如当前速度或所有帧的粒子大小。这类似于我们在本章开头看到的粒子系统的**时间流逝**节点。'
- en: '**Output Particle Quad**: This Context will be executed when the particle needs
    to be rendered. It will read the particle data to see where to render, how to
    render, which texture and color to use, and the different visual settings. This
    is similar to the **Renderer** module of the previous particle system.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出粒子四边形**：当粒子需要被渲染时，这个上下文将被执行。它将读取粒子数据以确定渲染位置、渲染方式、使用的纹理和颜色以及不同的视觉设置。这类似于之前粒子系统的**渲染器**模块。'
- en: 'Inside each Context, apart from some base configurations, we can add **blocks**.
    Each block is an action that will be executed in the Context. We have actions
    that can be executed in any Context and then some specific Context actions. As
    an example, we can use an **Add Position** block in the **Initialize Particle**
    Context to move the initial particle position, but if we use the same block in
    the **Update Particle** Context, it will move the particle constantly. So basically,
    Contexts are different situations that happen in the life of the particle, and
    blocks are actions that are executed in those situations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个上下文中，除了一些基本配置外，我们还可以添加**块**。每个块都是一个将在上下文中执行的操作。我们有可以在任何上下文中执行的操作，以及一些特定上下文操作。例如，我们可以在**初始化粒子**上下文中使用**添加位置**块来移动初始粒子位置，但如果我们在**更新粒子**上下文中使用相同的块，它将使粒子持续移动。所以基本上，上下文是粒子生命周期中发生的情况，而块是在这些情况下执行的操作：
- en: '![](img/B21361_11_45_PE.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_45_PE.png)'
- en: 'Figure 11.45: A Set Velocity Random block inside the Initialize Particle Context.
    This sets the initial velocity of a particle'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.45：初始化粒子上下文中的“设置速度随机”块。这设置了粒子的初始速度
- en: Also, we can have **standalone contexts**, Contexts outside Systems, such as
    **Spawn**. This Context is responsible for telling the System that a new particle
    needs to be created. We can add blocks to specify when the context will tell the
    system to create the particle, such as at a fixed rate over time, bursts, and
    so on. The idea is that **Spawn** will create particles according to its blocks,
    while a System is responsible for initializing, updating, and rendering each of
    them, again, according to the blocks we set up inside each one of those Contexts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以有**独立上下文**，即系统之外的上下文，例如**生成**。这个上下文负责告诉系统需要创建一个新的粒子。我们可以添加块来指定上下文何时告诉系统创建粒子，例如在固定的时间间隔内，爆发等。想法是**生成**将根据其块创建粒子，而系统则负责根据我们在每个上下文中设置的块初始化、更新和渲染每个粒子。
- en: So, we can see that there are lots of similarities with regular particle systems,
    but the way to create a system here is quite different. Let’s reinforce this by
    creating a rain effect, which will require lots of particles—a nice use case for
    Visual Effect Graph.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到它与常规粒子系统有很多相似之处，但在这里创建系统的方式相当不同。让我们通过创建一个雨效来加强这一点，这将需要大量的粒子——这是Visual
    Effect Graph的一个很好的用例。
- en: Creating a rain effect
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建雨效
- en: 'In order to create this effect, do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个效果，请执行以下操作：
- en: 'Set the **Capacity** property of the **Initialize Particle** Context to `10000`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“初始化粒子”上下文的**容量**属性设置为`10000`：
- en: '![](img/B21361_11_46_PE.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_46_PE.png)'
- en: Figure 11.46 Initialize Particle Context
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.46 初始化粒子上下文
- en: 'Set the **Constant SPawn Rate** at the beginning of the graph to `10000`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表的开始处设置**常量出生率**为`10000`：
- en: '![](img/B21361_11_47_PE.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_47_PE.png)'
- en: 'Figure 11.47: Constant Spawn Rate block'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.47：常量出生率块
- en: Before adding new nodes on the graph, we will delete the ones we won’t need
    to create our rain effect.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在图上添加新节点之前，我们将删除我们不需要创建雨效的节点。
- en: 'Right click over the node **Set Position (Shape: Arc Sphere)** inside the **Initialize
    Particle Block** and select **Delete** to remove this node:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“初始化粒子块”中的节点**设置位置（形状：圆弧球体）”上右键单击并选择**删除**以删除此节点：
- en: '![](img/B21361_11_48.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_48.png)'
- en: 'Figure 11.48: Deleting the Set Position block'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.48：删除“设置位置”块
- en: Repeat the process with the node Set Velocity from Direction & Speed (New Direction)
    to remove it as well
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用节点“从方向和速度（新方向）设置速度”重复此过程以删除它
- en: '![](img/B21361_11_49.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_49.png)'
- en: 'Figure 11.49: Deleting the Set Velocity block'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.49：删除“设置速度”块
- en: Right-click the Initialize Particle title, and select Create Block
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“初始化粒子”标题，并选择创建块
- en: 'Search for the Set Velocity Random (Per-component) block and click on it to
    add it:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索“设置速度随机（按组件）”块并点击它以添加：
- en: '![](img/B21361_11_50.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_50.png)'
- en: 'Figure 11.50: Adding the Set Velocity Random block'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.50：添加“设置速度随机”块
- en: 'Set the A and B properties to (0, -50, 0) and (0, -75, 0), respectively, in
    the Set Velocity Random block in the Initialize Particle Context. This will set
    a random velocity pointing downward for our particles:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“初始化粒子”上下文中的“设置速度随机”块中，将A和B属性分别设置为（0, -50, 0）和（0, -75, 0）。这将为我们设置一个指向下方的随机速度：
- en: '![](img/B21361_11_51.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_51.png)'
- en: 'Figure 11.51: Set Velocity Random block'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.51：设置速度随机块
- en: 'Right click over the node Gravity inside the Update Particles Block and select
    Delete to remove this node:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击更新粒子方块内的重力节点，并选择删除以移除此节点：
- en: '![](img/B21361_11_52.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_52.png)'
- en: 'Figure 11.52: Deleting the Gravity block'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.52：删除重力方块
- en: 'Repeat the process with the Linear Drag Block:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用线性阻力方块重复此过程：
- en: '![](img/B21361_11_53.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_53.png)'
- en: 'Figure 11.53: Deleting the Linear Drag block'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.53：删除线性阻力方块
- en: 'After this two deletions, the Update Particle Block will be empty:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这两次删除操作后，更新粒子方块将变为空：
- en: '![](img/B21361_11_54.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_54.png)'
- en: 'Figure 11.54: Empty Update Particles block'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.54：空的更新粒子方块
- en: Right-click the **Initialize Particle** title, and select **Create Block**.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **初始化粒子** 标题，并选择 **创建方块**。
- en: 'Search for the **Set Position Random (Per-component)** block and click on it:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络上搜索 **Set Position Random (Per-component)** 方块，并点击它：
- en: '![](img/B21361_11_55.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_55.png)'
- en: 'Figure 11.55: Adding blocks'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.55：添加方块
- en: Set the **A** and **B** properties of the **Set Position Random** block to (`-50`,
    `0`, `-50`) and (`50`, `0`, `50`), respectively. This will define an initial area
    in which to randomly spawn the particle.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Set Position Random** 方块的 **A** 和 **B** 属性分别设置为 (`-50`, `0`, `-50`) 和 (`50`,
    `0`, `50`)。这将定义一个初始区域，用于随机生成粒子。
- en: Click the arrow at the left of the **Bounds** property of the **Initialize Particle**
    block to display its properties, and set **Center** and **Size** to (`0`, `-12.5`,
    `0`) and (`100`, `25`, `100`), respectively. This will define the area where the
    particles should be visible. Particles can actually move outside this area, but
    it is important to render the particles only in the areas we are interested in
    them being visible.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Initialize Particle** 方块的 **Bounds** 属性左侧的箭头以显示其属性，并将 **Center** 和 **Size**
    分别设置为 (`0`, `-12.5`, `0`) 和 (`100`, `25`, `100`)。这将定义粒子应可见的区域。粒子实际上可以移动到这个区域之外，但仅在我们感兴趣的区域中渲染粒子是很重要的。
- en: Search for `Frustum culling` on the internet for more information about bounds.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上搜索 `Frustum culling` 以获取有关边界的更多信息。
- en: '![](img/B21361_11_56_PE.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_56_PE.png)'
- en: 'Figure 11.56: Configuring blocks'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.56：配置方块
- en: 'Select the GameObject that is executing the system, and in the bottom-right
    window in the **Scene** view, check the **Show Bounds** checkbox to see the previously
    defined bounds:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择执行系统的 GameObject，在 **场景** 视图的右下角窗口中，勾选 **显示边界** 复选框以查看之前定义的边界：
- en: '![](img/B21361_11_57_PE.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_57_PE.png)'
- en: 'Figure 11.57: Visual Effect playback controls'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.57：视觉效果播放控制
- en: 'If you don’t see the window at the bottom right, click the **VE** (Visual Effect)
    button at the top left of the screen to display it. This button will be shown
    only if you have selected the **Rain** visual effect GameObject in the **Hierarchy**:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有看到右下角的窗口，请点击屏幕左上角的 **VE**（视觉效果）按钮来显示它。此按钮仅在你在 **层次结构** 中选择了 **雨** 视觉效果
    GameObject 时才会显示：
- en: '![](img/B21361_11_58_PE.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_58_PE.png)'
- en: 'Figure 11.58: Another way to display the Visual Effect playback controls'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.58：另一种显示视觉效果播放控制的方式
- en: 'If you can’t see the changes being applied, click the **Compile** button at
    the top left of the window, the one that looks like a paper bin beneath a downward-pointing
    arrow. Also, you can save your changes using *Ctrl* + *S* (*Command* + *S* on
    a Mac):'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看不到应用的变化，请点击窗口左上角的 **编译** 按钮，它看起来像箭头下方的纸篓。你也可以使用 *Ctrl* + *S*（在 Mac 上为 *Command*
    + *S*）保存你的更改：
- en: '![](img/B21361_11_59_PE.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_59_PE.png)'
- en: 'Figure 11.59: VFX asset saving controls'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.59：VFX 资产保存控制
- en: 'Set the object position to cover the whole base area. In my case, **Position**
    is `100`, `37`, and `100`. Remember that you need to change **Position** of the
    **Transform** component for this:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象位置设置为覆盖整个基础区域。在我的情况下，**位置** 是 `100`，`37`，和 `100`。请记住，你需要更改 **Transform**
    组件的 **位置**：
- en: '![](img/B21361_11_60.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_60.png)'
- en: 'Figure 11.60: Setting a Transform position'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.60：设置变换位置
- en: 'Set the **A** and **B** properties of the **Set Lifetime Random** block in
    **Initialize Particle** to `0.5`. This will make the particles have a shorter
    life, ensuring that they are always inside the bounds:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Initialize Particle** 中将 **Set Lifetime Random** 方块的 **A** 和 **B** 属性设置为
    `0.5`。这将使粒子的寿命更短，确保它们始终在边界内：
- en: '![](img/B21361_11_61_PE.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_61_PE.png)'
- en: 'Figure 11.61: Set Lifetime Random block'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.61：设置寿命随机方块
- en: 'Change the **Main Texture** property of the **Output Particle Quad** Context
    to another texture. In this case, the previously downloaded smoke texture can
    work here, even though it’s not water, because we will modify its appearance in
    a moment. Also, you can try to download a water droplet texture if you want to:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**输出粒子四边形**上下文的**主纹理**属性更改为另一个纹理。在这种情况下，之前下载的烟雾纹理可以在这里使用，即使它不是水，因为我们将在稍后修改其外观。此外，如果您想的话，还可以尝试下载水滴纹理：
- en: '![](img/B21361_11_62.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_62.png)'
- en: 'Figure 11.62: VFX Graph Main Texture'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.62：VFX图主纹理
- en: 'Set **Blend Mode** of the **Output Particle Quad** Context to **Additive**:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**输出粒子四边形**上下文的**混合模式**设置为**添加**：
- en: '![A picture containing text, screenshot, font, black  Description automatically
    generated](img/B21361_11_63.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、黑色描述的图片，自动生成](img/B21361_11_63.png)'
- en: 'Figure 11.63: Additive mode of VFX graph'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.63：VFX图的添加模式
- en: 'We need to stretch our particles a little bit to look like actual raindrops
    instead of falling balls. Before accomplishing that, first, we need to change
    the orientation of our particles so they don’t point at the camera all the time.
    In order to do this, right-click on the **Orient** block in the **Output Particle
    Quad** Context and select **Delete** (or press *Delete* on a PC or *Command* +
    *Backspace* on a Mac):'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要稍微拉伸我们的粒子，使其看起来像真正的雨滴而不是下落的球体。在完成这一目标之前，首先，我们需要改变粒子的方向，使它们不会总是指向摄像机。为了做到这一点，在**输出粒子四边形**上下文中的**定位**块上右键单击并选择**删除**（或在PC上按*Delete*或在Mac上按*Command*
    + *Backspace*）：
- en: '![](img/B21361_11_64.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_64.png)'
- en: 'Figure 11.64: Deleting a block'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.64：删除块
- en: We want to stretch our particles according to their velocity direction. Another
    preparation step before actually doing that is to select the title of the **Output
    Particle Quad** context and hit the spacebar to look for a block to add. In this
    case, we need to search and add the **Orient Along Velocity** block.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望根据粒子的速度方向拉伸粒子。在实际上进行这一操作之前，另一个准备步骤是选择**输出粒子四边形**上下文的标题并按空格键查找要添加的块。在这种情况下，我们需要搜索并添加**沿速度方向定位**块。
- en: 'Add a **Set Scale** block to the **Initialize Particle** Context and set the
    **Scale** property to `0.25`, `1.5`, and `0.25`. This will stretch the particles
    to look like falling drops:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**初始化粒子**上下文中添加一个**设置缩放**块，并将**缩放**属性设置为`0.25`、`1.5`和`0.25`。这将使粒子看起来像下落的雨滴：
- en: '![](img/B21361_11_65.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_65.png)'
- en: 'Figure 11.65: Set Scale block'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.65：设置缩放块
- en: 'Click the **Compile** button in the top-left window again to see the changes.
    Your system should look like this:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击左上角的**编译**按钮以查看更改。您的系统应该看起来像这样：
- en: '![](img/B21361_11_66.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_11_66.png)'
- en: 'Figure 11.66: Rain results'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.66：雨效果
- en: You can adjust the rest of the node values to change size and color of the particles
    over lifetime using both nodes inside Output Particle Quad Block.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过Output Particle Quad Block中的两个节点调整其余的节点值，以在粒子的整个生命周期内改变粒子的大小和颜色。
- en: We have just modified lots of different properties of Visual Effect Graph, but
    if you want to have two instances of the same Visual Effect Graph, but with slight
    differences, I recommend you look at the **Blackboard** feature, which will allow
    you to expose properties in the **Inspector**. For example, you can make less
    dense rain in another scene, make the spawn rate lower, or change the particle
    color to make acid rain, all using the same graph, but let’s keep things simple
    for now.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚修改了视觉效果图的许多不同属性，但如果您想要两个具有轻微差异的相同视觉效果图实例，我建议您查看**黑板**功能，这将允许您在**检查器**中公开属性。例如，您可以在另一个场景中制作密度较低的雨，降低生成率，或将粒子颜色改为酸雨，所有这些都可以使用相同的图，但现在让我们保持简单。
- en: The **Blackboard** feature is also present in **Shader Graph**.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑板**功能也存在于**着色器图**中。'
- en: From here, you can experiment by adding and removing blocks from the Contexts
    as you wish, and again, I recommend you look for an already-created Visual Effect
    Graph to find ideas for other systems. Actually, you can get ideas for Visual
    Effect Graph by looking at effects made in regular particle systems and using
    the analogous blocks.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以按照自己的意愿添加和删除上下文中的块进行实验，并且再次，我建议您查找已创建的视觉效果图以获取其他系统的想法。实际上，您可以通过查看常规粒子系统中的效果并使用类似块来获取视觉效果图的灵感。
- en: 'Also, I recommend you search for the Visual Effect Graph documentation online
    or at: [https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@15.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@15.0/manual/index.html)
    to learn more about this system. You can also access the documentation of any
    Unity package by clicking the **Documentation** button in the **Package Manager**
    while the package is selected.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我建议你在网上或以下链接中搜索视觉效果图文档：[https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@15.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@15.0/manual/index.html)，以了解更多关于这个系统。你还可以通过在**包管理器**中选择包时点击**文档**按钮来访问任何
    Unity 包的文档。
- en: '![](img/B21361_11_67.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21361_11_67.png]'
- en: 'Figure 11.67: Package Manager documentation link'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.67：包管理器文档链接
- en: Now that we have learned how to create different visual effects, let’s see how
    to use them via scripting to achieve effects that react to what’s happening in
    the game.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建不同的视觉效果，让我们看看如何通过脚本使用它们来实现对游戏中发生的事情做出反应的效果。
- en: Scripting Visual Effects
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本化视觉效果
- en: Visual feedback is the concept of using different VFX, such as particles and
    VFX Graph, to reinforce what is happening. For example, say right now we are shooting
    our weapon; we know that this is happening because we can see the bullets. However,
    it doesn’t feel like a real shooting effect because a proper shooting effect should
    have a muzzle effect on the tip of our gun. Another example would be the enemy
    dying—it just disappears with no animation! That doesn’t feel as satisfying as
    it could be. We can instead add a little explosion (considering they are robots).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉反馈是使用不同的视觉效果（如粒子效果和 VFX 图），以强化正在发生的事情的概念。例如，假设我们现在正在开枪；我们知道这是在发生，因为我们能看到子弹。然而，这并不像真实的射击效果，因为一个合适的射击效果应该在枪口处产生枪口效果。另一个例子是敌人死亡——它只是没有动画地消失！这并不像它本可以那样令人满意。我们可以添加一个小爆炸（考虑到它们是机器人）。
- en: 'Let’s start making our enemies spawn an explosion when they are destroyed by
    doing the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下步骤开始，让我们的敌人被摧毁时产生爆炸：
- en: Create an explosion effect or download one from the Asset Store. It shouldn’t
    loop, and it needs to be destroyed automatically when the explosion is over (ensure
    **Looping** is unchecked and **Stop Action** is set to **Destroy** in the **Main**
    module). Feel free to use the same one we did previously in this chapter.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个爆炸效果，或者从资产商店下载一个。它不应该循环，并且在爆炸结束后需要自动销毁（确保在 **Main** 模块中**循环**未被勾选，并将**停止动作**设置为**销毁**）。你可以自由使用我们在本章中之前使用过的同一个效果。
- en: 'Some explosions in the Asset Store might use non-URP-compatible shaders. The
    **Asset Store** page of the package specifies if the package supports URP. You
    can also fix them by using **Window | Rendering | Render Pipeline Converter**,
    as we saw in *Chapter 4*, *Seamless Integration: Importing and Integrating Assets*.'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资产商店中的一些爆炸效果可能使用与 URP 不兼容的着色器。该包的 **Asset Store** 页面指定了该包是否支持 URP。你还可以通过使用 **Window
    | Rendering | Render Pipeline Converter** 来修复它们，正如我们在 *第 4 章* 中所看到的，*无缝集成：导入和集成资产*。
- en: Manually upgrade the materials that didn’t upgrade automatically.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动升级那些没有自动升级的材料。
- en: Add a script to the `Enemy` Prefab called `ExplosionOnDeath`. This will be responsible
    for spawning the particles Prefab when the enemy dies.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Enemy` 预制体上添加一个名为 `ExplosionOnDeath` 的脚本。这将负责在敌人死亡时生成粒子预制体。
- en: Add a field of the **GameObject** type called `particlePrefab` and drag the
    `explosion` Prefab to it.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `particlePrefab` 的 **GameObject** 类型的字段，并将 `explosion` 预制体拖放到它上面。
- en: You may be expecting to add the explosion spawning to the **Life** component.
    In that case, you are assuming that anything to do with life will spawn a particle
    when dying, but consider scenarios where characters die with a falling animation
    instead, or maybe an object that just despawns with no effect whatsoever. If a
    certain behavior is not used in most scenarios, it is better to code it in a separate
    optional script to allow us to mix and match different components and get the
    exact behavior we want.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能期望将爆炸生成添加到 **Life** 组件中。在这种情况下，你假设与生命有关的所有内容在死亡时都会生成粒子，但考虑一下这样的场景：角色死亡时带有下落动画，或者可能是一个没有任何效果就消失的对象。如果某种行为在大多数场景中都没有使用，那么最好将其编码在单独的可选脚本中，这样我们可以混合和匹配不同的组件，以获得我们想要的确切行为。
- en: 'Make the script access the `Life` component we created in *Chapter 8*, *Victory
    or Defeat: Win and Lose Conditions*, of this book and subscribe to its `OnDeath`
    event.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让脚本访问我们在第 8 章，*胜利或失败：胜利和失败条件* 中创建的 `Life` 组件，并订阅其 `OnDeath` 事件。
- en: 'In the `listener` function, let’s instantiate the particle system in the same
    location:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `listener` 函数中，让我们在相同的位置实例化粒子系统：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_11_68_PE.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成的描述](img/B21361_11_68_PE.png)'
- en: 'Figure 11.68: The explosion spawner script'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.68：爆炸生成器脚本
- en: 'The visual scripting version would look like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 可视脚本版本看起来是这样的：
- en: '![](img/B21361_11_69_PE.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_69_PE.png)'
- en: 'Figure 11.69: The explosion spawner visual script'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.69：爆炸生成器可视脚本
- en: As you can see, we are just using the same concepts we learned about in previous
    chapters but combining them in new ways. This is what programming is all about.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是在之前章节中学到的相同概念，但以新的方式组合它们。这就是编程的全部内容。
- en: 'Let’s continue with the muzzle effect, which makes our gun feel more realistic
    and provides feedback about the player’s avatar shooting. It could also be a particle
    system, but we will take another approach this time:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论枪口效果，这使我们的枪感觉更真实，并为玩家的角色射击提供反馈。它也可以是一个粒子系统，但这次我们将采取另一种方法：
- en: If you don’t have one already, download a weapon model from the Asset Store.
    The character in the package we used in the book already comes with one, so we
    will use that one.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有，从 Asset Store 下载一个武器模型。我们在这本书中使用的包中的角色已经包含了一个，所以我们将使用那个。
- en: If it’s not already on your character, instantiate the weapon so that it is
    the parent of the hand of the player. Remember that our character is rigged and
    has a hand bone, so you should put the weapon there.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的角色上还没有，实例化武器，使其成为玩家手的父对象。记住，我们的角色是绑定的，有一个手骨，所以你应该把它放在那里。
- en: 'The weapon that comes with the character we downloaded in this book is a special
    scenario where the weapon has a **SkinnedMeshRenderer** component. This component
    uses the **Skinning Animation** system that we will learn to use in *Chapter 17*,
    *Animated Realities: Creating Animations with Animator, Cinemachine, and Timeline*.
    In this case, the movement of the weapon will be affected by the animations we
    will use in that chapter, so for now, let’s keep the weapon where it is located
    now, even if it looks odd.'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本书中下载的角色所带的武器是一个特殊场景，其中武器具有 **SkinnedMeshRenderer** 组件。该组件使用我们将在第 17 章，*动画现实：使用
    Animator、Cinemachine 和 Timeline 创建动画* 中学习的 **Skinning Animation** 系统。在这种情况下，武器的运动将受到我们将在该章中使用的动画的影响，因此现在让我们保持武器现在的位置，即使它看起来有点奇怪。
- en: Create or get a muzzle particle system. In this case, my muzzle particle system
    was created as a short particle system that has a burst of particles and then
    automatically stops. Try to get one with that behavior because there are others
    out there that will loop instead, and the script to handle that scenario would
    be different.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或获取一个枪口粒子系统。在这种情况下，我的枪口粒子系统被创建为一个短粒子系统，它会爆发粒子然后自动停止。尝试获取具有该行为的粒子系统，因为还有其他一些会循环，而处理这种情况的脚本将不同。
- en: 'Create an instance of the particle system Prefab in the Editor and parent it
    inside the weapon, locating it in front of the weapon, aligned with the cannon
    of the gun. Make sure the **Play On Awake** property of the **Main** module of
    the particle system is unchecked; we don’t want the muzzle to fire until we press
    the **Fire** key:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建粒子系统的 Prefab 实例，并将其作为武器的子对象放置其中，使其位于武器前方，与枪的炮管对齐。确保粒子系统 **Main** 模块的
    **Play On Awake** 属性未被勾选；我们不希望在按下 **Fire** 键之前发射枪口：
- en: '![](img/B21361_11_70_PE.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_70_PE.png)'
- en: 'Figure 11.70: The muzzle parented to the weapon'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.70：与武器关联的枪口
- en: Create a field of the `ParticleSystem` type called `muzzleEffect` in `PlayerShooting`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerShooting` 中创建一个名为 `muzzleEffect` 的 `ParticleSystem` 类型的字段。
- en: Drag the muzzle effect GameObject that is parented in the gun to it in the Inspector.
    Now, we have a reference to the **ParticleSystem** component of the muzzle to
    manage it.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在枪中关联的枪口效果 GameObject 拖到检查器中。现在，我们有了对枪口 **ParticleSystem** 组件的引用来管理它。
- en: 'Inside the `if` statement that checks whether we are shooting, execute `muzzleEffect.Play();`
    to play the particle system. It will automatically stop and is short enough to
    finish between key presses:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查我们是否在射击的`if`语句中执行`muzzleEffect.Play();`以播放粒子系统。它将自动停止，并且足够短，可以在按键之间完成：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_11_71_PE.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序  自动生成的描述](img/B21361_11_71_PE.png)'
- en: 'Figure 11.71: The muzzle parented to the weapon'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.71：枪口附加到武器上
- en: 'The visual scripting version’s additional nodes and variables would be the
    following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化脚本版本的附加节点和变量如下所示：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_11_72_PE.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、应用程序  自动生成的描述](img/B21361_11_72_PE.png)'
- en: 'Figure 11.72: The muzzle playing visual script'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.72：枪口播放可视化脚本
- en: 'Finally, we also need to play the muzzle effect on the AI while shooting by
    doing the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要在射击时通过以下方式在AI上播放枪口效果：
- en: As we did with `PlayerShooting`, create a field of the `ParticleSystem` type
    called `muzzleEffect` in `EnemyFSM`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同`PlayerShooting`一样，在`EnemyFSM`中创建一个名为`muzzleEffect`的`ParticleSystem`类型的字段。
- en: 'Inside the `Shoot` method, add the line `muzzleEffect.Play();` at the end of
    the method to play the particle system:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Shoot`方法中，在方法末尾添加`muzzleEffect.Play();`行以播放粒子系统：
- en: '![](img/B21361_11_73_PE.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_11_73_PE.png)'
- en: 'Figure 11.73: The muzzle playing C# script'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.73：发射时播放C#脚本
- en: 'The visual scripting version’s additional nodes for **Attack State** and **Attack**
    `Base` will be as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化脚本版本的**攻击状态**和**攻击**`Base`的附加节点将如下所示：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_11_74_PE.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成的描述](img/B21361_11_74_PE.png)'
- en: 'Figure 11.74: The muzzle playing script for Attack State'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.74：播放攻击状态脚本的枪口
- en: Remember to add those nodes to both attack states and to add the **muzzleEffect**
    variable to the AI Variables component.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将那些节点添加到攻击状态中，并将**muzzleEffect**变量添加到AI变量组件中。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed two different ways to create particle systems:
    using regular particle systems and VFX Graph. We used them to simulate different
    fluid phenomena, such as fire, a waterfall, smoke, and rain. The idea is to combine
    particle systems with meshes to generate all the possible props needed for your
    scene. Also, as you can imagine, creating these kinds of effects professionally
    requires you to go deeper.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了创建粒子系统的两种不同方法：使用常规粒子系统和VFX图。我们使用它们来模拟不同的流体现象，如火焰、瀑布、烟雾和雨。想法是将粒子系统与网格结合以生成场景所需的全部可能道具。此外，正如你可以想象的那样，创建这类效果需要你深入了解。
- en: If you want to dedicate yourself to this (another part of the job of a technical
    artist), you will need to learn how to create your own particle textures to get
    the exact look and feel you want, code scripts that control certain aspects of
    the systems, and several other aspects of particle creation. However, that is
    outside the scope of the book.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要致力于这个（技术艺术家工作的另一个部分），你需要学习如何创建自己的粒子纹理以获得你想要的精确外观和感觉，编写控制系统某些方面的脚本，以及粒子创建的几个其他方面。然而，这超出了本书的范围。
- en: Now that we have some rain in our scene, we can see that the sky and the lighting
    in the scene don’t really reflect a rainy day, so let’s fix that in the next chapter!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们场景中有了一些雨，我们可以看到天空和场景中的光照并不真正反映雨天，所以让我们在下一章中修复这个问题！
- en: Learn more on Discord
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家和作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过Ask Me Anything会议与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1498477041053909218.png)'
