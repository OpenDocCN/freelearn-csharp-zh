- en: Chapter 5. Scripting and Custom Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。脚本和自定义动作
- en: 'In previous chapters, you learned how to make a game using Playmaker''s in-built
    actions. Unfortunately, their capabilities are limited, and sooner or later you
    will find yourself in need of something that Playmaker does not know how to do
    out-of-the-box. In this case, you can try and find a ready-made solution on the
    Internet, but to make sure that there is an answer to every one of your questions,
    you will certainly have to learn how to write scripts. These are the topics that
    we will discuss in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用 Playmaker 的内置动作制作游戏。不幸的是，它们的性能有限，迟早你会发现自己需要 Playmaker 无法直接解决的问题。在这种情况下，你可以尝试在互联网上寻找现成的解决方案，但为了确保你的每一个问题都有答案，你肯定需要学习如何编写脚本。我们将讨论以下主题：
- en: Programming in Unity JavaScript (sometimes also called UnityScript) and C#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unity JavaScript（有时也称为 UnityScript）和 C# 中进行编程
- en: Common Unity classes, variables, and functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的 Unity 类、变量和函数
- en: Writing a script and using it as component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写脚本并将其用作组件
- en: Transforming a script into a Playmaker action
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将脚本转换为 Playmaker 动作
- en: Writing a Unity Script
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Unity 脚本
- en: Explaining how programming works in general is beyond the scope of this book,
    so I am going to assume that you already know what variables, functions, classes,
    and operators are. If, however, you do not know these things, it should not take
    you too long to pick up the basics using either Code Academy ([http://www.codecademy.com/tracks/javascript](http://www.codecademy.com/tracks/javascript))
    or Unity's own starting level tutorials ([http://unity3d.com/learn/tutorials/modules/beginner/scripting](http://unity3d.com/learn/tutorials/modules/beginner/scripting)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 解释编程的一般工作原理超出了本书的范围，因此我将假设你已经知道变量、函数、类和运算符是什么。如果你不知道这些，使用 Code Academy（[http://www.codecademy.com/tracks/javascript](http://www.codecademy.com/tracks/javascript)）或
    Unity 自身的入门级教程（[http://unity3d.com/learn/tutorials/modules/beginner/scripting](http://unity3d.com/learn/tutorials/modules/beginner/scripting)）来掌握基础知识不会花费你太多时间。
- en: We are going to start with **JavaScript** (**JS**) in this section, because
    it is much simpler to use and does not require any understanding of object-oriented
    programming beyond the component-based approach to development that we already
    discussed in [Chapter 3](ch03.html "Chapter 3. Components and State Machines"),
    *Components and State Machines*. Besides, you will end up writing significantly
    less code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从 **JavaScript**（**JS**）开始，因为它使用起来更简单，并且不需要对面向对象编程有超出我们在第 3 章（[组件和状态机](ch03.html
    "第 3 章。组件和状态机")）中讨论的基于组件的开发方法的理解。此外，你最终将编写更少的代码。
- en: Both JS and C# use the same Unity classes and functions, and the difference
    in syntax is not very significant at all. However, for more complex things it
    is generally a good idea to use C# (for one thing, it is currently impossible
    to write a Playmaker action in JavaScript). We will start with a JS script and
    then translate it into C#, explaining the differences. You can later choose whichever
    language works better for you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JS 和 C# 都使用相同的 Unity 类和函数，语法上的差异并不很大。然而，对于更复杂的事情，通常使用 C# 是一个好主意（例如，目前无法在 JavaScript
    中编写 Playmaker 动作）。我们将从一个 JS 脚本开始，然后将其翻译成 C#，并解释差异。你可以稍后选择对你来说更好的语言。
- en: We are going to create a script that replaces all the Playmaker actions in the
    **Push Puck** state of both mallets' FSMs. When you see that you have to make
    a chain of five or more actions, it is generally easier to combine them in a single
    custom action, especially if you are planning to use this compound action on multiple
    objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，用于替换两个球拍的状态机中的 **Push Puck** 状态的所有 Playmaker 动作。当你看到你需要执行五个或更多动作的链时，通常将它们组合成一个自定义动作会更简单，尤其是如果你计划在多个对象上使用这个组合动作。
- en: 'Let us start by creating a new script. First of all, create a new folder named
    `Scripts` using the **Project** panel. Then, right-click on the newly created
    folder and navigate to **Create** | **Javascript**. Name the file `PushPuck`.
    Double-click on the file. The standard Unity programming environment, MonoDevelop,
    should open. Select everything there is in that script and replace it with the
    following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的脚本开始。首先，使用 **项目** 面板创建一个名为 `Scripts` 的新文件夹。然后，右键单击新创建的文件夹，导航到 **创建**
    | **Javascript**。将文件命名为 `PushPuck`。双击文件。标准的 Unity 编程环境，MonoDevelop，应该会打开。选择该脚本中的所有内容，并将其替换为以下代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can download the example code files for all Packt Publishing books you have
    purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt Publishing 书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给你。
- en: Press *command* + *S* (*Ctrl* + *S* in Windows) in MonoDevelop to save the changes
    to the script.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中按 *command* + *S* (*Ctrl* + *S* 在 Windows 上) 保存脚本更改。
- en: Let us examine this code line-by-line. The first line is `#pragma strict`. This
    is a preprocessor directive. If you have some previous programming experience,
    you have probably seen something similar before. It does not participate in script
    logic; what it does is make JavaScript more explicit by imposing more strict error
    handling in the compiler. What it means for you is that you have to explicitly
    define the types of your variables, which is something you would not normally
    do in standard JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行检查这段代码。第一行是 `#pragma strict`。这是一个预处理器指令。如果你有一些之前的编程经验，你可能之前见过类似的东西。它不参与脚本逻辑；它所做的就是通过在编译器中强制更严格的错误处理来使
    JavaScript 更加明确。对你来说，这意味着你必须显式地定义变量的类型，这在标准 JavaScript 中通常不会这样做。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Another common preprocessor directive for JS is `#pragma downcast`, which lets
    you get rid of warnings of implicit downcast if you do not care about them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JS 来说，另一个常见的预处理器指令是 `#pragma downcast`，它允许你忽略不关心的不明确向下转换警告。
- en: 'After that there are two lines of variable declaration: `pushMag` and `collisionTag`
    are declared as `float` and `String`. Once you attach this script to an object,
    these variables will be displayed in the Inspector, because they are both public
    and serialized. Since a script in Unity is treated as a component, variables appear
    as parameters in the Inspector once you attach the script to a game object.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之后有两行变量声明：`pushMag` 和 `collisionTag` 被声明为 `float` 和 `String`。一旦你将此脚本附加到对象上，这些变量将在检查器中显示，因为它们都是公共的并且已序列化。由于在
    Unity 中脚本被视为组件，一旦将脚本附加到游戏对象，变量就会作为参数出现在检查器中。
- en: If you want to declare a variable that does not appear in the Inspector, but
    want other scripts to still have access to it, you should put `[System.NonSerialized]`
    before it. If you want to both hide it and close all access to it, you just need
    to put `private` before the `var` keyword. Finally, if you want to expose a private
    variable in Inspector, you should put `[System.SerializableAttribute]` before
    its declaration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要声明一个不在检查器中显示的变量，但希望其他脚本仍然可以访问它，你应该在它前面加上 `[System.NonSerialized]`。如果你想隐藏它并关闭所有访问，只需在
    `var` 关键字前面加上 `private` 即可。最后，如果你想将私有变量暴露在检查器中，你应该在其声明前加上 `[System.SerializableAttribute]`。
- en: 'Next goes the function declaration: `function` `OnControllerColliderHit` `(hit
    : ControllerColliderHit)`. `OnControllerColliderHit` is one of the standard Unity
    functions that are responsible for detecting collisions. Other such functions
    are `OnCollisionEnter`, `OnCollisionStay`, `OnCollisionExit`, `OnTriggerEnter`,
    `OnTriggerStay`, and `OnTriggerExit`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来是函数声明：`function` `OnControllerColliderHit` `(hit : ControllerColliderHit)`。`OnControllerColliderHit`
    是负责检测碰撞的标准 Unity 函数之一。其他此类函数包括 `OnCollisionEnter`、`OnCollisionStay`、`OnCollisionExit`、`OnTriggerEnter`、`OnTriggerStay`
    和 `OnTriggerExit`。'
- en: The `OnControllerColliderHit` function gets called automatically if the object
    that the script is attached to has a Character Controller component and that Character
    Controller collides with a collider. The `hit` variable of type `ControllerColliderHit`
    gets assigned and can be used inside the function. By typing `hit` and a dot,
    one can access all kinds of information about the collision.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本附加的对象具有角色控制器组件并且该角色控制器与碰撞器发生碰撞，则会自动调用 `OnControllerColliderHit` 函数。类型为 `ControllerColliderHit`
    的 `hit` 变量被分配，并可以在函数内部使用。通过键入 `hit` 和一个点，可以访问有关碰撞的所有类型的信息。
- en: 'For instance, inside the function there is an `if` condition: `if (hit.gameObject.tag
    == collisionTag)`. We access the `gameObject` that our Character Controller has
    collided with, using the dot operator, and then we use it again to access that
    tag in `gameObject`. Then we compare that tag with the `collisionTag` string variable
    that is assigned in the Inspector. If the tag matches the string we specified,
    the code inside the curly brackets is executed.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在函数内部有一个 `if` 条件：`if (hit.gameObject.tag == collisionTag)`。我们使用点操作符访问我们的Character
    Controller所碰撞的 `gameObject`，然后再次使用它来访问 `gameObject` 中的该标签。然后我们将该标签与在检查器中分配的 `collisionTag`
    字符串变量进行比较。如果标签与指定的字符串匹配，则执行花括号内的代码。
- en: In this script, we reproduced the exact sequence of actions in the **Push Puck**
    state of the mallets' FSMs. You can consult it for reference. First, we get the
    position of the puck and store it in a `Vector3` variable called `hitObjectPos`.
    Then we get the point of the hit and store it in another `Vector3` variable called
    `hitPointPos`. We then calculate the force of the push in one step instead of
    three that we used in Playmaker. Finally, the force is applied to the puck's rigidbody.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们重现了mallets' FSMs的**推杆**状态中精确的动作序列。你可以参考它。首先，我们获取滑块的位置并将其存储在名为 `hitObjectPos`
    的 `Vector3` 变量中。然后我们获取击中的点并将其存储在另一个名为 `hitPointPos` 的 `Vector3` 变量中。然后我们计算一次推力，而不是像在Playmaker中使用的那样分三步。最后，将力应用到滑块的刚体上。
- en: After that there is a line with `Debug.Log` that prints information about every
    hit in the Console. You can comment this line out by typing `//` in front of it.
    Keep it uncommented for now to make sure that the script works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，有一行包含 `Debug.Log` 的代码，它会将关于每次击中的信息打印到控制台。你可以通过在其前面输入 `//` 来注释掉这一行。现在先不要注释它，以确保脚本能够正常工作。
- en: The very last line of the script is `@script RequireComponent (CharacterController)`.
    It is there to make sure that there is a Character Controller component attached
    to the game object that this script is attached to. If you attach this script
    to a game object that does not have a Character Controller, it will be attached
    automatically. If you try to remove the Character Controller without removing
    `PushPuck` first, Unity will display a warning dialog window and not allow you
    to do it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一行是 `@script RequireComponent (CharacterController)`。它在那里是为了确保附加到该脚本的游戏对象上有一个Character
    Controller组件。如果你将此脚本附加到一个没有Character Controller的游戏对象上，它将自动附加。如果你尝试在不先删除 `PushPuck`
    的情况下删除Character Controller，Unity将显示警告对话框窗口，并阻止你这样做。
- en: Now it is time to see if our newly created script works. Go back to Unity and
    open the **Console** panel. If there are no red errors, this means that the script
    was compiled correctly and is ready to be used. If there is some kind of error
    in a script, double-clicking on it in the Console will open the script in MonoDevelop
    and direct you to the line where the error has occurred.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们新创建的脚本是否能够正常工作了。回到Unity，打开**控制台**面板。如果没有出现红色错误，这意味着脚本已正确编译并准备好使用。如果脚本中存在某种错误，双击控制台中的错误，它将在MonoDevelop中打开脚本并直接跳转到错误发生的行。
- en: 'If everything is okay, select **MalletLeft**, open the **playMaker** panel
    and in the **Move** state disable the **Collision** **Event** action by unchecking
    the box next to its name. If you start the game now, colliding with the puck will
    not push it. Now it is time to use our brand-new `PushPuck` script. Drag and drop
    the `PushPuck` file from the **Project** panel to the **Inspector** panel while
    having **MalletLeft** selected. It will attach to it as a component. Set its parameters
    as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，选择 **MalletLeft**，打开 **playMaker** 面板，并在 **Move** 状态中通过取消选中其名称旁边的框来禁用
    **Collision** **Event** 动作。如果你现在开始游戏，与滑块碰撞将不会推动它。现在是我们使用全新的 `PushPuck` 脚本的时候了。在选中
    **MalletLeft** 的同时，从 **项目** 面板拖放 `PushPuck` 文件到 **检查器** 面板。它将作为组件附加到上。按照以下截图设置其参数：
- en: '![Writing a Unity Script](img/8108OT_05_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![编写Unity脚本](img/8108OT_05_01.jpg)'
- en: Open the **Console** panel and launch the game. Note how messages appear in
    the Console every time you hit the puck with your mallet. If you stop the game
    and double-click on one of the `Debug.Logs`, MonoDevelop will open and point you
    to the `Debug.Log` line of the `PushPuck` script. Now that you know the script
    works, you can comment that line out in order to prevent it from spamming the
    console.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**控制台**面板并启动游戏。注意每次你用球槌击打冰球时，消息如何在控制台中显示。如果你停止游戏并双击一个`Debug.Logs`，MonoDevelop将打开并指向`PushPuck`脚本的`Debug.Log`行。现在你知道脚本工作正常后，你可以取消注释该行以防止它向控制台发送垃圾信息。
- en: Also, now you can apply it to the AI opponent as well. Remember to deactivate
    the **Collision Event** action first.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在你也可以将其应用于AI对手。记得首先禁用**碰撞事件**动作。
- en: Overview of standard Unity classes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准Unity类概述
- en: While I am not going to copy the whole Unity Script Reference into this chapter
    of the book, I would like to list a few important classes and functions that you
    are going to use quite often.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不会将整个Unity脚本参考复制到本书的这一章节，但我希望列出一些你将非常频繁使用的几个重要类和函数。
- en: 'The most obvious and frequently used standard functions are `Awake`, `Start`,
    `OnEnable`, `OnDisable`, `Update`, and `FixedUpdate`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显且最常用的标准函数是`Awake`、`Start`、`OnEnable`、`OnDisable`、`Update`和`FixedUpdate`：
- en: '`Awake` is the first function that is called when a scene is loaded. The `Awake`
    function can happen only once per scene load. It is generally a good idea to put
    all initialization code into the `Awake` function.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Awake`是当场景加载时首先被调用的函数。`Awake`函数在每个场景加载中只能发生一次。通常将所有初始化代码放入`Awake`函数是一个好主意。'
- en: '`Start` happens after `Awake` and also runs once. Sometimes it is a good idea
    to put some code into `Awake` and some other code into `Start` in order to make
    sure that one is executed after the other. When you have an `Awake` function in
    one script and another `Awake` function in another script, you cannot be sure
    which one will be executed first. If the order matters, put one of the pieces
    of code into the `Start` function.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start`在`Awake`之后发生，也只运行一次。有时将一些代码放入`Awake`，其他代码放入`Start`是一个好主意，以确保一个在另一个之后执行。当你在一个脚本中有`Awake`函数，而在另一个脚本中又有另一个`Awake`函数时，你不能确定哪个会先执行。如果顺序很重要，将其中一段代码放入`Start`函数。'
- en: Tip
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'There''s another way to ensure a correct script execution order. You can decide
    which script is executed before or after by navigating to **Edit** | **Project
    Settings** | **Script Execution Order** from the main menu and then pressing the
    plus button in the Inspector, selecting the script whose execution order you would
    like to define, and then dragging it up or down in the interface. You will notice
    that the number on the right changes as you drag the script: this number is the
    script''s execution order. You give the script its default execution order by
    removing it from this list. You can do this by pressing the minus button on the
    right from its name in the list.'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保正确的脚本执行顺序的另一种方法是，你可以通过从主菜单导航到**编辑** | **项目设置** | **脚本执行顺序**来决定哪个脚本先执行或后执行，然后在检查器中按下加号按钮，选择你想要定义执行顺序的脚本，然后在界面中上下拖动它。你会注意到当你拖动脚本时，右边的数字会改变：这个数字是脚本的执行顺序。你可以通过从列表中移除脚本为其赋予默认执行顺序。你可以通过在列表中按其名称旁边的减号按钮来实现。
- en: The `OnEnable` function is a lot like `Start`, except it is called every time
    the object to which the script is attached is activated, as well as every time
    the component itself is enabled.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEnable`函数与`Start`函数非常相似，除了它会在附加脚本的物体被激活以及组件本身被启用时被调用。'
- en: '`OnDisable` is the opposite of `OnEnable`. It is called when the object or
    the component gets disabled.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDisable`是`OnEnable`的反义词。当对象或组件被禁用时被调用。'
- en: '`Update` is called every frame. Most of the games'' logic usually happens here.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`每帧被调用。大多数游戏逻辑通常在这里发生。'
- en: '`FixedUpdate` is called on physics update, which is generally significantly
    more frequent than `Update`. All the code that cannot be frame rate dependent
    (such as, for instance, movement) should be in the `FixedUpdate` function.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate`在物理更新时被调用，这通常比`Update`频繁得多。所有不能依赖于帧率的代码（例如，例如，移动）都应该放在`FixedUpdate`函数中。'
- en: 'Apart from the functions, there are whole classes with their methods and variables
    that you should absolutely know about when programming in Unity. It is hard to
    emphasize something in particular, and you really should just go through all the
    major classes listed in the Scripting Reference ([http://docs.unity3d.com/Documentation/ScriptReference/](http://docs.unity3d.com/Documentation/ScriptReference/)).
    There are really a lot of classes, and there is hardly anyone who knows what all
    of them do, but we are going to go through a few that you should look at first
    thing: `Mathf`, `Vector3`, `Color`, `Input`, `GameObject`, `Transform`, `Renderer`,
    `Material`, `Collision`, `Collider`, and of course `Object`, `Behaviour`, `Component`,
    and `MonoBehaviour`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能之外，还有许多类及其方法和变量，在 Unity 编程时你绝对应该了解。很难强调某一点，你真的应该浏览一下 Scripting Reference
    中列出的所有主要类([http://docs.unity3d.com/Documentation/ScriptReference/](http://docs.unity3d.com/Documentation/ScriptReference/))。类真的很多，几乎没有人知道它们全部的功能，但我们将首先查看几个你应该关注的类：`Mathf`、`Vector3`、`Color`、`Input`、`GameObject`、`Transform`、`Renderer`、`Material`、`Collision`、`Collider`，当然还有
    `Object`、`Behaviour`、`Component` 和 `MonoBehaviour`。
- en: The last four classes are especially important, since they include things that
    you are going to use every time you write a script in Unity, including functions
    like `Update`, `Destroy`, `GetComponent`, and `Start`, as well as variables such
    as `enabled`, `name`, `layer`, and `tag`. Try to read descriptions of these classes
    and their functions and variables very carefully, and look at the basic examples
    the documentation offers with them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后四个类尤为重要，因为它们包含了你在 Unity 中编写脚本时每次都会使用的内容，包括 `Update`、`Destroy`、`GetComponent`
    和 `Start` 等函数，以及 `enabled`、`name`、`layer` 和 `tag` 等变量。仔细阅读这些类及其函数和变量的描述，并查看文档提供的与它们相关的示例。
- en: Creating a Playmaker action
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Playmaker 动作
- en: It is time to translate our script to C#. Create a new C# script the same way
    you created the JS one. Call it `PushPuckAction`. Open the script and find the
    line starting with the `public class` keywords. Make sure that the name of the
    class is the same as the name of the script, then press *command* + *S* (*Ctrl*
    + *S* in Windows) to save your changes if you made any.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们的脚本翻译成 C# 了。以创建 JS 脚本相同的方式创建一个新的 C# 脚本。命名为 `PushPuckAction`。打开脚本，找到以 `public
    class` 关键字开始的行。确保类的名称与脚本名称相同，然后按 *command* + *S* (*Ctrl* + *S* 在 Windows 上) 保存你的更改（如果你做了任何更改）。
- en: As you can see, the default template for a C# script looks different from that
    of JS. This is because more things are shown to you. For instance, in JS it is
    implied that everything inside a script is, in fact, in a class with the same
    name, but you do not see the class declaration anywhere. Component classes in
    Unity have to inherit from MonoBehaviour, and it is shown in C#, while JS hides
    it from you. Then you have the two lines with the `using` keyword. All JS scripts
    use these namespaces, but JS hides it from you as well. The following script is
    the same one that we had before, but this time translated to C#. Replace the template
    with it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，C# 脚本的默认模板与 JS 的模板看起来不同。这是因为它向你展示了更多内容。例如，在 JS 中，默认认为脚本内部的所有内容实际上都在一个同名的类中，但你却看不到类的声明。Unity
    中的组件类必须继承自 `MonoBehaviour`，这在 C# 中是可见的，而 JS 则将其隐藏起来。然后你有两条带有 `using` 关键字的行。所有
    JS 脚本都使用这些命名空间，但 JS 也将其隐藏起来。下面的脚本是我们之前拥有的同一个脚本，但这次翻译成了 C#。用这个模板替换它。
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Press *command* + *S* (*Ctrl* + *S* in Windows), and let us look at what has
    changed apart from the things already mentioned. The syntax of the component requirement
    is different in C#. On top of that, the `RequireComponent` attribute has to be
    placed before the class declaration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *command* + *S* (*Ctrl* + *S* 在 Windows 上)，让我们看看除了已经提到的内容之外还发生了什么变化。C# 中的组件要求语法与
    JS 不同。除此之外，`RequireComponent` 属性必须放在类声明之前。
- en: The `#pragma strict` directive is gone. C# is explicit by nature and requires
    that you specify types of everything, so it is not needed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pragma strict` 指令已经不再使用。C# 本身是显式的，需要你指定所有内容的数据类型，因此它不再需要。'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In C#, the following are quite useful: `#region [Name]`/`#endregion`, which
    is a good way of dividing your code into regions that you can fold. For example,
    writing `#region Variables` will create a region called `Variables`. Then you
    will be able to press a minus in a rectangle on the left of the MonoDevelop window
    to fold the code region, the end of which you have to mark with `#endregion`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，以下内容非常有用：`#region [Name]`/`#endregion`，这是一种将代码划分为可以折叠的区域的好方法。例如，编写 `#region
    Variables` 将创建一个名为 `Variables` 的区域。然后你将能够按下 MonoDevelop 窗口左侧的减号来折叠代码区域，其结束必须用
    `#endregion` 标记。
- en: 'The `function` keyword is not used. Instead, function declarations are preceded
    by return types. You can specify a return type in JS as well, but this is done
    with the `:` operator after the brackets, for example, `function Update() : void`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '不使用 `function` 关键字。相反，函数声明由返回类型 precedes。你同样可以在 JS 中指定返回类型，但这需要在括号后的 `:` 运算符后完成，例如，`function
    Update() : void`。'
- en: Finally, all variable declarations are preceded with types of variables instead
    of the `var` keyword. There are more differences in syntax that we cannot see
    in this example because of the relative simplicity of our script, but these are
    the main ones.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有变量声明都由变量类型 precedes，而不是 `var` 关键字。由于我们脚本的相对简单性，我们无法在这个示例中看到更多的语法差异，但这些是主要的。
- en: 'Now, if you replace your JS script with the C# one on the Mallets, they will
    act exactly the same way as before. Try doing this, then remove the **Push Puck
    Action** component from the mallets. It is time to modify the script and transform
    `PushPuckAction.cs` into an actual Playmaker action. Replace the contents of `PushPuckAction.cs`
    with the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在 Mallets 上将你的 JS 脚本替换为 C# 脚本，它们将表现得和之前完全一样。尝试这样做，然后从 mallets 中移除 **Push
    Puck Action** 组件。是时候修改脚本，将 `PushPuckAction.cs` 转换为实际的 Playmaker 动作。用以下代码替换 `PushPuckAction.cs`
    的内容：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Press *command* + *S* (*Ctrl* + *S* in Windows) to save the script. As you can
    see, this time more things have changed, although you can still see the same structure.
    Let us go through the code line-by-line and examine it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *command* + *S* (*Ctrl* + *S* 在 Windows 上) 保存脚本。正如你所见，这次有更多东西发生了变化，尽管你仍然可以看到相同的结构。让我们逐行检查代码。
- en: The `using` directives are the same, but the difference begins right after them.
    The line `namespace` `HutongGames.PlayMaker.Actions` is obligatory for all Playmaker
    actions. Without it Playmaker will not know that the script that you are writing
    is, in fact, an action.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 指令相同，但差异从它们之后开始。`namespace HutongGames.PlayMaker.Actions` 这一行对于所有 Playmaker
    动作是必需的。没有它，Playmaker 将不知道你正在编写的脚本实际上是一个动作。'
- en: The `[ActionCategory(ActionCategory.Character)]` line puts your new action into
    a category. In this case, we are putting it into the `Character` category, because
    the action is about things colliding with the Character Controller. It could also
    go into the `Physics` category. To move it there, the line would have to be `[ActionCategory(ActionCategory.Physics)]`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ActionCategory(ActionCategory.Character)]` 行将你的新动作放入一个类别。在这种情况下，我们将其放入 `Character`
    类别，因为动作是关于与 Character Controller 发生碰撞的事物。它也可以放入 `Physics` 类别。要将它移动到那里，该行必须是 `[ActionCategory(ActionCategory.Physics)]`。'
- en: After that there is `[Tooltip("...")]`, which is quite self-explanatory. It
    shows a short description when you select the action from the list in the **Actions**
    panel.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是 `[Tooltip("...")]`，这相当直观。当你从 **Actions** 面板中选择动作时，它会显示一个简短的描述。
- en: The `PushPuckAction` class now inherits from `FsmStateAction` instead of `MonoBehavior`.
    You still have access to all the standard Unity classes, but Playmaker-specific
    ones are added now.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`PushPuckAction` 类现在从 `FsmStateAction` 继承，而不是 `MonoBehavior`。你仍然可以访问所有标准 Unity
    类，但现在还添加了 Playmaker 特定的类。'
- en: Then there is another `Tooltip`, this time for a variable rather that a whole
    action. The text within this tooltip will appear when you hover your mouse pointer
    over the variable in the **State** tab of the **playMaker** panel or in the **Actions**
    panel.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有另一个 `Tooltip`，这次是为一个变量而不是整个动作。当你在 **playMaker** 面板的 **State** 选项卡或 **Actions**
    面板中将鼠标指针悬停在变量上时，此提示文本将显示。
- en: Note that the type of the `pushMag` variable has changed from `float` to `FsmFloat`,
    and the same goes for the `string` variable `collisionTag`—it is `FsmString` now.
    These are Playmaker types of variables. The same operations can be performed on
    them as before, but to access their value you now have to use the dot operator
    with the word `Value`, so, for example, `pushMag.Value` will return a float, the
    value of the Playmaker variable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`pushMag` 变量的类型已从 `float` 更改为 `FsmFloat`，同样，字符串变量 `collisionTag` 也已从 `string`
    更改为 `FsmString`。这些都是 Playmaker 的变量类型。可以对它们执行与之前相同的操作，但为了访问它们的值，您现在必须使用点操作符和单词
    `Value`，例如，`pushMag.Value` 将返回一个浮点数，即 Playmaker 变量的值。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you do not want to be able to assign a value directly in the **State** tab
    of the **playMaker** panel and force choosing from existing variables, you can
    write `[UIHint(UIHint.Variable)]` in the line before the variable declaration,
    the same way we did for the tooltips.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想能够在 **playMaker** 面板的 **State** 选项卡中直接分配值，并强制从现有变量中选择，您可以在变量声明之前的行中写入 `[UIHint(UIHint.Variable)]`，就像我们为工具提示所做的那样。
- en: A `Reset` function was added. This is what happens when a new action is added
    to a state or when you right-click on the header of the action and press **Reset**.
    In it, we reinitialize the variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个 `Reset` 函数。当向状态添加新动作或您在动作标题上右键单击并按 **Reset** 时，就会发生这种情况。在其中，我们重新初始化变量。
- en: Then there is the `DoControllerColliderHit` function. Its name has changed from
    the standard Unity `OnControllerColliderHit`. Inside the function everything has
    stayed more or less the same with the only difference that types of `Vector3`
    variables have changed to `FsmVector3`, so to access their values `.Value` is
    used. Also, instead of `Vector3.Normalize`, we used `.nomalized`, which does exactly
    the same thing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `DoControllerColliderHit` 函数。它的名称已从标准的 Unity `OnControllerColliderHit` 更改。在函数内部，一切保持大致相同，唯一的区别是
    `Vector3` 变量的类型已更改为 `FsmVector3`，因此要访问它们的值，使用 `.Value`。此外，我们使用了 `.nomalized` 而不是
    `Vector3.Normalize`，它确实做了完全相同的事情。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While it is clear that in order to find examples and standard Unity classes'
    API one has to go to Unity Script Reference, it may be less clear about Playmaker-specific
    things. The easiest way to find examples is opening the script files of existing
    Playmaker actions that are located under the `PlayMaker/Actions` path, in your
    project. For example, if you are not quite sure how to detect mouse input and
    you want to do it via a Playmaker custom action, you can open `PlayMaker/Actions/MousePick.cs`
    and look at how the creators of Playmaker solved this problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很明显，为了找到示例和标准 Unity 类的 API，必须去 Unity 脚本参考，但对于 Playmaker 特定的事情可能就不那么明确了。找到示例的最简单方法是打开位于项目
    `PlayMaker/Actions` 路径下现有 Playmaker 动作的脚本文件。例如，如果您不确定如何检测鼠标输入，并且想通过 Playmaker
    自定义动作来实现，您可以打开 `PlayMaker/Actions/MousePick.cs` 并查看 Playmaker 的创建者是如何解决这个问题。
- en: Note that both `Reset` and `DoControllerColliderHit` have `override` preceding
    their types. This means that we are replacing a base function defined in the Playmaker
    with our own function. As a general rule, you will need to override all of the
    Playmaker standard functions using this keyword.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Reset` 和 `DoControllerColliderHit` 的类型前都有 `override` 关键字。这意味着我们正在用我们自己的函数替换
    Playmaker 中定义的基函数。一般来说，您需要使用此关键字覆盖所有 Playmaker 标准函数。
- en: Now that we are done writing a custom Playmaker action, we can try using it.
    Remove the **Push Puck** and/or **Push** **Puck** **Action** components from **MalletLeft**
    and **MalletRight**. In their **Move** state, remove the **Collision Event** action.
    Then locate the newly created **Push Puck Action** in the **Actions** panel and
    add it to the state. Set the properties as shown in the following screenshot.
    Finally, delete the **Push Puck** state from the FSM as well as the **Push** event
    and transition. To delete a transition, you just need to right-click on the event
    in the FSM view and press **Delete Transition**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了一个自定义的 Playmaker 动作，我们可以尝试使用它。从 **MalletLeft** 和 **MalletRight** 中移除
    **Push Puck** 和/或 **Push Puck Action** 组件。在它们的 **Move** 状态中，移除 **Collision Event**
    动作。然后在 **Actions** 面板中找到新创建的 **Push Puck Action** 并将其添加到状态中。设置属性如以下截图所示。最后，从 FSM
    中删除 **Push Puck** 状态以及 **Push** 事件和转换。要删除转换，只需在 FSM 视图中右键单击事件并按 **Delete Transition**
    即可。
- en: '![Creating a Playmaker action](img/8108OT_05_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Playmaker 动作](img/8108OT_05_02.jpg)'
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to scripting in Unity, both JavaScript
    and C#, and learned how to create custom Playmaker actions. You should try repeating
    the process described in this chapter with another set of actions on your own.
    Set yourself a gameplay goal, for instance, you could take one of the exercises
    offered at the end of [Chapter 4](ch04.html "Chapter 4. Creating Your First Game"),
    *Creating Your First Game*, write a JS or C# script that accomplishes the goal;
    and then translate it into a Playmaker action. You will feel much more comfortable
    with scripting by the time you are done, as it is all about practice, and no amount
    of reading and theory can replace a hands-on experience with a text editor and
    a search engine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在 Unity 中进行脚本编写，包括 JavaScript 和 C#，以及如何创建自定义的 Playmaker 动作。你应该尝试重复本章中描述的过程，使用另一组动作进行实践。为自己设定一个游戏目标，例如，你可以选择[第
    4 章](ch04.html "第 4 章。创建你的第一个游戏")末尾提供的练习之一，*创建你的第一个游戏*，编写一个 JS 或 C# 脚本来实现目标；然后将其转换为
    Playmaker 动作。完成这些后，你对脚本编写会感到更加得心应手，因为这一切都关乎实践，而阅读和理论无法替代使用文本编辑器和搜索引擎的实际操作经验。
- en: The next chapters continue talking about advanced subjects, such as networking
    and external APIs, and we are going to do some more scripting in [Chapter 7](ch07.html
    "Chapter 7. Working with External APIs"), *Working with External APIs*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续讨论高级主题，例如网络和外部 API，我们将在[第 7 章](ch07.html "第 7 章。与外部 API 一起工作")*与外部 API
    一起工作*中进行更多的脚本编写。
