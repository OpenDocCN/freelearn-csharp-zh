- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Optimizing Game Performance in Unity – Profiling and Analysis Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中优化游戏性能 – 剖析和分析技术
- en: This chapter delves into optimizing game performance in Unity, a critical facet
    of game development that combines technical prowess with efficiency. This chapter
    equips you with the skills to proficiently use Unity’s profiling tools, enabling
    thorough analyses of game performance issues such as bottlenecks and inefficient
    code paths. You’ll learn how to manage memory usage effectively, understand the
    nuances of garbage collection, and optimize graphical assets and rendering processes
    to maintain high-quality visuals without sacrificing performance. Additionally,
    this chapter provides guidance on writing efficient code, employing best practices
    such as implementing LOD systems, and balancing visual fidelity with performance.
    These techniques and insights will lay the groundwork for building high-performance
    games that are well-optimized for various platforms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了在Unity中优化游戏性能，这是游戏开发中一个关键方面，它结合了技术实力和效率。本章为您提供了熟练使用Unity剖析工具的技能，使您能够彻底分析游戏性能问题，如瓶颈和低效的代码路径。您将学习如何有效地管理内存使用，理解垃圾回收的细微差别，并优化图形资产和渲染过程，以保持高质量的视觉效果而不牺牲性能。此外，本章还提供了编写高效代码的指导，采用最佳实践，如实现LOD系统，并在视觉保真度和性能之间取得平衡。这些技术和见解将为构建高性能游戏奠定基础，这些游戏在各种平台上都进行了良好的优化。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Utilizing profiling tools to analyze game performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用剖析工具分析游戏性能
- en: Managing memory usage and garbage collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内存使用和垃圾回收
- en: Optimizing graphical assets and rendering processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化图形资产和渲染过程
- en: Writing efficient and optimized code for better performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写高效和优化的代码以获得更好的性能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter12](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter12)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到与本章相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter12](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter12)
- en: Profiling and identifying bottlenecks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剖析和识别瓶颈
- en: Profiling is the cornerstone of effective game optimization, providing essential
    insights into performance issues that could hinder a game’s smooth operation.
    This section introduces the power of Unity’s profiling tools, guiding you through
    the process of profiling a game to pinpoint bottlenecks across critical areas
    such as CPU, GPU, and memory usage. You will learn how to navigate the profiling
    landscape to not only identify where issues occur but also understand the implications
    of profiling data. Through case studies and real-world examples, this segment
    illustrates common performance pitfalls and the strategic use of profiling to
    resolve these challenges, ensuring your game performs optimally under a variety
    of conditions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 剖析是有效游戏优化的基石，提供了对可能阻碍游戏顺畅运行的性能问题的基本见解。本节介绍了Unity剖析工具的力量，引导您通过剖析游戏来定位CPU、GPU和内存使用等关键领域的瓶颈。您将学习如何导航剖析领域，不仅识别问题发生的地方，而且理解剖析数据的影响。通过案例研究和现实世界的例子，本部分说明了常见的性能陷阱和剖析在解决这些挑战中的战略应用，确保您的游戏在各种条件下都能表现最佳。
- en: Introduction to Unity’s profiling tools
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity的剖析工具简介
- en: Unity’s Profiler is a pivotal tool in game development, offering comprehensive
    insights into game performance. This introduction outlines its capabilities for
    monitoring metrics such as CPU, GPU, and memory usage, providing a solid foundation
    for identifying and analyzing performance bottlenecks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的Profiler是游戏开发中的一个关键工具，它提供了对游戏性能的全面见解。本介绍概述了其监控CPU、GPU和内存使用等指标的能 力，为识别和分析性能瓶颈提供了坚实的基础。
- en: The Profiler provides real-time insights into various subsystems, helping developers
    pinpoint resource-demanding areas. Its intuitive interface displays data in views
    such as **Hierarchy**, **Timeline**, and **Raw Hierarchy**, each offering unique
    analysis perspectives. For example, the **Timeline** view shows processes over
    time, aiding in the identification of sporadic resource usage spikes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Profiler提供了对各种子系统的实时洞察，帮助开发者定位资源密集区域。其直观的界面以层次结构、时间线和原始层次结构等视图显示数据，每个视图都提供独特的分析视角。例如，时间线视图显示了随时间推移的过程，有助于识别偶发的资源使用峰值。
- en: Beyond general metrics, the Profiler includes tools for analyzing network performance,
    audio playback, and rendering statistics. This granularity is invaluable for fine-tuning
    every aspect of game performance. Detailed reports enable informed optimization
    decisions, ensuring games run smoothly and provide the best player experience.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通用指标之外，Profiler还包括分析网络性能、音频播放和渲染统计的工具。这种粒度对于微调游戏性能的每个方面都非常有价值。详细的报告使优化决策更加明智，确保游戏运行顺畅并提供最佳玩家体验。
- en: This section has introduced Unity’s Profiler and its essential role in monitoring
    and optimizing game performance. By understanding its main features, you are prepared
    to understand advanced profiling techniques so that you can identify and address
    performance bottlenecks, ensuring high performance across platforms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了Unity的Profiler及其在监控和优化游戏性能中的基本作用。通过了解其主要功能，你将准备好理解高级分析技术，以便你可以识别和解决性能瓶颈，确保跨平台的高性能。
- en: Exploring profiling techniques and identifying bottlenecks
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索分析技术并识别瓶颈
- en: Building on the fundamentals introduced earlier, this section delves deeper
    into employing Unity’s Profiler to effectively identify and resolve performance
    issues within your game. We will explore how to properly set up and conduct profiling
    sessions, capturing and analyzing key performance data to pinpoint common development
    bottlenecks such as rendering inefficiencies, script execution delays, asset loading
    times, and network latency. Through detailed step-by-step examples and real-world
    case studies, you’ll learn about the specific methods that can be used to detect
    these issues using Unity’s Profiler, providing you with practical skills to enhance
    the performance and smoothness of your game projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍基本概念的基础上，本节深入探讨了如何使用Unity的Profiler有效地识别和解决游戏中的性能问题。我们将探讨如何正确设置和进行分析会话，捕获和分析关键性能数据，以确定常见的开发瓶颈，如渲染效率低下、脚本执行延迟、资源加载时间和网络延迟。通过详细的分步示例和实际案例研究，你将了解可以使用Unity的Profiler检测这些问题的具体方法，为你提供提高游戏项目性能和流畅度的实用技能。
- en: To effectively utilize Unity’s Profiler for identifying and resolving performance
    bottlenecks, it is crucial to understand how to set up and run profiling sessions.
    Start by configuring the Profiler settings to capture the specific areas you are
    concerned with, such as CPU usage, GPU load, memory usage, or network activity.
    This targeted approach helps focus your efforts on potential problem areas and
    streamlines the analysis process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用Unity的Profiler来识别和解决性能瓶颈，了解如何设置和运行分析会话至关重要。首先，配置Profiler设置以捕获你关心的特定区域，例如CPU使用率、GPU负载、内存使用或网络活动。这种有针对性的方法有助于将你的精力集中在潜在的问题区域，并简化分析过程。
- en: 'The following figure is a snapshot of the **Profiler** window while the game
    is playing. The activity graph will scroll to the left, with the latest information
    appearing on the far right. Generally speaking, the large spikes are areas of
    concern that need to be addressed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是游戏进行时Profiler窗口的快照。活动图将向左滚动，最新信息出现在最右侧。一般来说，大的峰值是需要解决的关注区域：
- en: '![Figure 12.1 – The Profiler window displaying real-time data on game performance](img/B22128_12_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 显示游戏性能实时数据的Profiler窗口](img/B22128_12_01.jpg)'
- en: Figure 12.1 – The Profiler window displaying real-time data on game performance
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 显示游戏性能实时数据的Profiler窗口
- en: Once the profiling session is running, monitor the game as it performs typical
    tasks or those known to cause performance issues. Capture enough data to identify
    patterns or anomalies, and use the Profiler’s views, such as the **Timeline**
    view, to pinpoint bottlenecks such as excessive asset loading times or script
    execution delays. Analyzing performance data often reveals common issues such
    as rendering inefficiencies due to excessive draw calls or poorly optimized scripts
    causing frame rate drops. Unity’s Profiler allows you to drill down into these
    specifics and prioritize optimizations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分析会话开始运行，监控游戏执行典型任务或已知会导致性能问题的任务。捕获足够的数据以识别模式或异常，并使用分析器的视图，如**时间线**视图，以确定瓶颈，例如过度的资源加载时间或脚本执行延迟。分析性能数据通常揭示常见问题，如由于过多的绘制调用或未优化脚本导致的帧率下降。Unity的分析器允许您深入这些具体细节并优先优化。
- en: Once you have familiarized yourself with the basics of Unity’s Profiler, it’s
    crucial to understand how to effectively navigate and utilize this tool to optimize
    your game’s performance. The following section provides practical tips and techniques
    for profiling navigation, helping you pinpoint and resolve performance bottlenecks
    more efficiently.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您熟悉了Unity分析器的基础知识，了解如何有效地导航和利用此工具来优化游戏性能至关重要。以下部分提供了关于分析导航的实用技巧和技术，帮助您更有效地定位和解决性能瓶颈。
- en: Profile navigation tips
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析导航提示
- en: 'Navigating the Unity Profiler can be streamlined with the following guidelines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下指南简化Unity分析器的导航：
- en: '**Using filters**:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用过滤器**：'
- en: Utilize filters in the **Profiler** window to focus on specific areas, such
    as CPU, GPU, or memory usage.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用**分析器**窗口中的过滤器专注于特定区域，例如CPU、GPU或内存使用。
- en: Filters can be toggled on the left panel to isolate performance metrics that
    are most relevant to your analysis.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器可以在左侧面板上切换，以隔离与您的分析最相关的性能指标。
- en: '**Switching views**:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换视图**：'
- en: The Profiler offers multiple views, such as **Hierarchy**, **Timeline**, and
    **Raw Hierarchy**.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分析器提供多个视图，例如**层次结构**、**时间线**和**原始层次结构**。
- en: '**Hierarchy**: Displays performance data in a hierarchical format, useful for
    drilling down into specific processes.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**：以层次结构格式显示性能数据，有助于深入特定过程。'
- en: '**Timeline**: Shows processes over time, highlighting sporadic resource usage
    spikes.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间线**：显示随时间推移的过程，突出显示间歇性资源使用峰值。'
- en: '**Raw Hierarchy**: Provides a raw data format for detailed analysis.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始层次结构**：提供详细分析的原数据格式。'
- en: '**Enabling** **deep profiling**:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用深度分析**：'
- en: Deep profiling captures detailed performance data at the method level.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度分析在方法级别捕获详细的性能数据。
- en: To enable deep profiling, select the **Deep Profile** option in the **Profiler**
    window before running your game.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要启用深度分析，请在运行游戏之前在**分析器**窗口中选择**深度分析**选项。
- en: Be cautious as deep profiling can significantly slow down the game, so use it
    selectively.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请谨慎使用，因为深度分析可能会显著减慢游戏速度，因此请选择性使用。
- en: '**Recording and** **analyzing data**:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录和分析数据**：'
- en: Start and stop profiling sessions using the record button in the **Profiler**
    window.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**分析器**窗口中的记录按钮开始和停止分析会话。
- en: Capture data during typical gameplay scenarios to identify performance bottlenecks.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在典型的游戏玩法场景中捕获数据，以识别性能瓶颈。
- en: Analyze the captured data to understand the impact of different processes on
    overall performance.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析捕获的数据以了解不同过程对整体性能的影响。
- en: Deep profiling allows developers to capture detailed performance data down to
    the method level, helping to identify specific code segments causing performance
    issues. To enable deep profiling, go to the **Profiler** window and select the
    **Deep Profile** option before running your game. This mode captures comprehensive
    data but can significantly slow down the game, so it’s best used selectively.
    Once enabled, you can examine the deep profiling data in the **Timeline** view
    to identify performance bottlenecks in specific methods and optimize them accordingly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 深度分析允许开发者捕获到方法级别的详细性能数据，有助于识别导致性能问题的特定代码段。要启用深度分析，请在运行游戏之前进入**分析器**窗口并选择**深度分析**选项。此模式捕获全面的数据，但可能会显著减慢游戏速度，因此最好选择性使用。一旦启用，您可以在**时间线**视图中检查深度分析数据，以识别特定方法中的性能瓶颈并相应地进行优化。
- en: For example, a developer noticed irregular frame time spikes and used the Profiler
    to trace the issue to sporadic network data bursts and improper asset loading.
    By moving asset loading to background threads and improving network data handling,
    they resolved the issue. Using Unity’s Profiler helps identify bottlenecks and
    guides efficient solutions, enhancing game performance and user experience.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一位开发者注意到了不规则的帧时间峰值，并使用Profiler追踪问题到间歇性的网络数据爆发和不恰当的资产加载。通过将资产加载移至后台线程并改进网络数据处理，他们解决了这个问题。使用Unity的Profiler有助于识别瓶颈并指导有效的解决方案，从而提升游戏性能和用户体验。
- en: In this section, we covered using Unity’s Profiler to diagnose performance bottlenecks
    by capturing and analyzing performance data. Next, we will dive into interpreting
    profiling data and taking actions to optimize game performance further.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使用Unity的Profiler通过捕获和分析性能数据来诊断性能瓶颈。接下来，我们将深入探讨解读Profiler数据并采取进一步优化游戏性能的措施。
- en: Interpreting profiling data and taking action
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解读Profiler数据和采取行动
- en: After gathering extensive data through Unity’s Profiler, the next critical step
    is interpreting this information to drive effective game optimization. This section
    focuses on how to analyze profiling data, enabling you to understand and prioritize
    performance issues based on their impact on gameplay and player experience. We’ll
    discuss methodologies to translate complex data into actionable insights and introduce
    strategies to address and resolve identified bottlenecks. This approach empowers
    developers not only to recognize areas needing improvement but also to devise
    and implement practical solutions, ensuring that optimizations enhance the game’s
    overall performance and maintain or improve the user experience.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Unity的Profiler收集大量数据后，下一步关键步骤是解读这些信息以驱动有效的游戏优化。本节重点介绍如何分析Profiler数据，使您能够根据对游戏玩法和玩家体验的影响来理解和优先处理性能问题。我们将讨论将复杂数据转化为可操作见解的方法，并介绍解决和解决已识别瓶颈的策略。这种方法使开发者不仅能够识别需要改进的领域，还能够设计和实施实际解决方案，确保优化提升游戏的整体性能并保持或改善用户体验。
- en: Interpreting the wealth of data collected from Unity’s Profiler involves a methodical
    approach to ensure that each piece of information is used effectively to enhance
    game performance. Initially, developers must learn to differentiate between data
    that signals critical performance issues and data that indicates minor inefficiencies.
    This prioritization is essential because it allows developers to focus on modifications
    that will have the most significant impact on player experience and overall game
    fluidity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 解读从Unity的Profiler收集的大量数据需要一种系统性的方法来确保每条信息都得到有效利用，以增强游戏性能。最初，开发者必须学会区分表示关键性能问题的数据和表示轻微低效的数据。这种优先级排序至关重要，因为它允许开发者专注于对玩家体验和整体游戏流畅性影响最大的修改。
- en: For instance, if the Profiler indicates high CPU usage during certain game events,
    developers should examine the corresponding scripts and processes to identify
    inefficient code. By refactoring or optimizing these areas, developers can reduce
    CPU load, resulting in smoother gameplay. Similarly, if memory usage spikes are
    detected, it might be necessary to look into asset management strategies, such
    as adjusting how and when assets are loaded or unloaded during the game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果Profiler在特定游戏事件期间指示高CPU使用率，开发者应该检查相应的脚本和进程以识别低效的代码。通过重构或优化这些区域，开发者可以减少CPU负载，从而实现更流畅的游戏体验。同样，如果检测到内存使用率峰值，可能需要检查资产管理策略，例如调整游戏过程中资产加载或卸载的方式和时间。
- en: 'To facilitate ongoing monitoring and immediate recognition of performance issues,
    integrating a simple frame rate indicator into the game’s UI can be highly beneficial.
    The following is an example of how to create a basic frame rate display in Unity
    using C#. This requires creating a **Text** field in the UI to show the frame
    rate data:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于持续监控和立即识别性能问题，将简单的帧率指示器集成到游戏的UI中可以非常有用。以下是在Unity中使用C#创建基本帧率显示的示例。这需要在UI中创建一个**Text**字段来显示帧率数据：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this script, `frameRateText` is a UI text element that needs to be linked
    in the Unity Editor, which will display the current frames per second. The `FrameRateCounter`
    script works by updating the frame rate in real time within the `Update` method.
    The `deltaTime` variable, which tracks the time between frames, is updated using
    an exponential moving average to smooth out the calculation. The frame rate (FPS)
    is then calculated as the reciprocal of `deltaTime`, providing an accurate measure
    of frames per second. Finally, the `frameRateText.text` property is updated with
    the calculated FPS value, rounded up to the nearest whole number using `Mathf.Ceil`.
    This real-time data helps developers and testers to visually verify the impact
    of their optimizations immediately, allowing for quick adjustments and improvements
    to the game’s performance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，`frameRateText`是一个UI文本元素，需要在Unity编辑器中链接，用于显示当前每秒帧数。`FrameRateCounter`脚本通过在`Update`方法中实时更新帧率来工作。`deltaTime`变量，它跟踪帧之间的时间，使用指数移动平均来平滑计算。然后，帧率（FPS）通过`deltaTime`的倒数来计算，提供了一个每秒帧数的准确度量。最后，使用`Mathf.Ceil`将计算出的FPS值四舍五入到最接近的整数，并更新`frameRateText.text`属性。这些实时数据有助于开发人员和测试人员立即直观地验证他们优化的影响，从而允许快速调整和改进游戏性能。
- en: By using these strategies, developers can not only identify and prioritize issues
    based on profiling data but also begin formulating effective solutions. This process
    of continual assessment and adjustment ensures that the game not only runs efficiently
    but also provides an engaging experience for players.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些策略，开发者不仅可以根据性能数据识别和优先处理问题，还可以开始制定有效的解决方案。这种持续评估和调整的过程确保游戏不仅运行高效，而且为玩家提供引人入胜的体验。
- en: This section has equipped you with the skills to interpret profiling data from
    Unity’s Profiler and take actionable steps to optimize your game. Next, we will
    focus on memory management to further enhance game performance by addressing identified
    bottlenecks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已为您提供了解读Unity Profiler中性能数据并采取实际步骤优化游戏的技能。接下来，我们将重点关注内存管理，通过解决已识别的瓶颈来进一步提高游戏性能。
- en: Memory management in Unity
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的内存管理
- en: Effective memory management is essential in Unity game development, particularly
    for ensuring smooth performance and preventing issues such as stuttering or crashes,
    especially on resource-constrained platforms. This section delves into various
    strategies you can use to optimize memory usage within Unity, including an in-depth
    look at garbage collection, which is the process of automatically freeing unused
    memory. We will also discuss why minimizing the impact of garbage collection is
    important, as excessive garbage collection can cause performance issues such as
    frame rate drops and stuttering. We will explore practical techniques such as
    object pooling and the careful management of memory allocations in frequently
    called methods such as `Update()`. Along with these strategies, practical tips
    and real-world examples will illustrate how memory optimization can be implemented
    effectively, helping you to maintain efficient and stable game performance across
    different devices. But first, let’s get a better idea of memory usage in Unity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏开发中，有效的内存管理至关重要，尤其是确保流畅性能和防止诸如卡顿或崩溃等问题，尤其是在资源受限的平台。本节深入探讨了您可以在Unity中使用的各种优化内存使用的策略，包括对垃圾回收的深入了解，这是自动释放未使用内存的过程。我们还将讨论为什么最小化垃圾回收的影响很重要，因为过多的垃圾回收可能导致性能问题，如帧率下降和卡顿。我们将探讨诸如对象池和谨慎管理`Update()`等频繁调用的方法中的内存分配等实际技术。此外，实用的技巧和真实世界的案例将说明如何有效地实施内存优化，帮助您在不同设备上保持高效和稳定的游戏性能。但在开始之前，让我们更好地了解Unity中的内存使用情况。
- en: Understanding memory usage in Unity
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Unity中的内存使用
- en: As a refresher from earlier discussions (see [*Chapter 3*](B22128_03.xhtml#_idTextAnchor057)),
    understanding memory usage in Unity is vital for optimizing game performance and
    stability. This brief overview revisits the different types of memory – heap,
    stack, managed, and unmanaged – that are used in Unity and the role of .NET’s
    garbage collection. Effective management of these memory types and garbage collection
    is crucial to prevent performance degradation and ensure smooth gameplay experiences.
    This recap underscores the importance of mindful memory management practices during
    game development.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为之前讨论的复习（参见[*第3章*](B22128_03.xhtml#_idTextAnchor057)），理解Unity中的内存使用对于优化游戏性能和稳定性至关重要。本简要概述回顾了Unity中使用的不同类型的内存——堆、栈、托管和非托管——以及.NET垃圾回收的作用。有效管理这些内存类型和垃圾回收对于防止性能下降和确保流畅的游戏体验至关重要。本复习强调了在游戏开发过程中进行谨慎的内存管理实践的重要性。
- en: 'The following figure shows the memory module of Unity’s Profiler. Tracking
    this data while testing your game will show how efficiently your game uses memory
    resources:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了Unity Profiler的内存模块。在测试游戏时跟踪这些数据将显示您的游戏如何有效地使用内存资源：
- en: '![Figure 12.2 – Unity’s Profiler memory module](img/B22128_12_2.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – Unity的Profiler内存模块](img/B22128_12_2.jpg)'
- en: Figure 12.2 – Unity’s Profiler memory module
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – Unity的Profiler内存模块
- en: Understanding memory usage is critical as it directly impacts game performance
    and is fundamental to the efficient management of resources within Unity. As we
    transition from this foundational knowledge, the next focus will be on specific
    strategies to minimize the impact of garbage collection on your game’s performance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 理解内存使用至关重要，因为它直接影响游戏性能，并且对于在Unity中有效管理资源是基本的。随着我们从基础知识过渡到下一步，下一个重点将是具体策略，以最小化垃圾回收对游戏性能的影响。
- en: Minimizing the impact of garbage collection
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化垃圾回收的影响
- en: Reducing the impact of garbage collection is a critical optimization strategy
    for enhancing performance in Unity games. Although necessary for managing memory,
    excessive garbage collection can lead to significant performance issues, such
    as frame rate drops and stuttering. These issues occur because garbage collection
    temporarily halts the execution of your game to reclaim unused memory, which can
    disrupt the smooth flow of gameplay. Frequent interruptions by the garbage collector
    can cause noticeable pauses, leading to a less responsive and more frustrating
    experience for players.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 减少垃圾回收的影响是提高Unity游戏中性能的关键优化策略。尽管垃圾回收对于管理内存是必要的，但过度的垃圾回收可能导致严重的性能问题，例如帧率下降和卡顿。这些问题发生的原因是垃圾回收会暂时停止游戏的执行以回收未使用的内存，这可能会打断游戏流畅的流程。垃圾回收器的频繁中断会导致明显的暂停，从而让玩家体验到响应速度慢且令人沮丧的游戏体验。
- en: This section explores various techniques to minimize the frequency and effects
    of garbage collection, starting with identifying common sources of memory waste.
    Unnecessary allocations within frequently executed methods such as `Update()`
    are often culprits of performance issues. We’ll delve into best practices for
    avoiding these unwanted allocations and highlight the role of object pooling.
    Object pooling is especially effective for managing objects that are created and
    destroyed frequently, such as projectiles in a game or dynamic UI elements. By
    reusing objects instead of constantly generating new ones, developers can significantly
    reduce the load on garbage collection, leading to smoother gameplay and improved
    resource management.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了各种技术以最小化垃圾回收的频率和影响，从识别常见的内存浪费来源开始。在频繁执行的方法，如`Update()`中进行的非必要分配往往是性能问题的罪魁祸首。我们将深入研究避免这些不想要的分配的最佳实践，并强调对象池的作用。对象池对于管理频繁创建和销毁的对象特别有效，例如游戏中的子弹或动态UI元素。通过重用对象而不是不断生成新的对象，开发者可以显著减少垃圾回收的负担，从而实现更流畅的游戏体验和改进的资源管理。
- en: Garbage collection in Unity is an automatic process that frees up memory by
    removing objects that are no longer in use. However, frequent garbage collection
    can lead to performance hiccups. To minimize its impact, avoid creating temporary
    objects in frequently called methods such as `Update()`. Instead, reuse objects
    through techniques such as object pooling. For instance, instead of instantiating
    new projectiles, create a pool of reusable projectiles at the start and activate
    them as needed, reducing the overhead on the garbage collector and improving performance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的垃圾回收是一个自动过程，通过移除不再使用的对象来释放内存。然而，频繁的垃圾回收可能会导致性能问题。为了最小化其影响，避免在频繁调用的方法，如`Update()`中创建临时对象。相反，可以通过对象池等技术重用对象。例如，而不是实例化新的弹射物，可以在游戏开始阶段创建一个可重用的弹射物池，并在需要时激活它们，从而减少垃圾回收器的开销并提高性能。
- en: In Unity, managing garbage collection effectively is important for maintaining
    smooth game performance, especially in projects where real-time interactions and
    fluid dynamics are key. One common source of performance degradation is the excessive
    creation of temporary objects in methods that are called frequently, such as `Update()`.
    Every time a new object is created in these methods, it adds to the heap, increasing
    the workload for the garbage collector, which can lead to frame rate issues and
    gameplay stutter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，有效地管理垃圾回收对于保持流畅的游戏性能至关重要，尤其是在实时交互和流体动力学是关键的项目中。性能退化的一个常见原因是频繁在频繁调用的方法中创建临时对象，如`Update()`。在这些方法中每次创建新对象时，都会添加到堆中，增加垃圾回收器的工作量，这可能导致帧率问题和游戏卡顿。
- en: To address this, developers should first identify these hotspots by profiling
    their games to see where the most allocations are occurring. Unity’s Profiler
    tool is invaluable here, allowing you to monitor memory allocations frame by frame.
    For example, you might notice that creating a new vector or string within each
    frame in the `Update()` method is causing significant garbage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，开发者首先应该通过分析他们的游戏来识别这些热点区域，看看最多分配发生在哪里。Unity的Profiler工具在这里非常有价值，它允许你逐帧监控内存分配。例如，你可能会注意到在`Update()`方法中的每一帧创建新的向量或字符串会导致显著的垃圾回收。
- en: 'Here are some steps to minimize allocations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些最小化分配的步骤：
- en: '**Profile your game**: Use Unity’s Profiler to track down methods that frequently
    allocate memory.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析你的游戏**：使用Unity的Profiler追踪频繁分配内存的方法。'
- en: '**Optimize code**: Modify the code to reduce or eliminate these allocations.
    For instance, instead of creating a new Vector3 object every frame to adjust an
    object’s position, modify the existing position or use a temporary static variable
    that gets reused.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优化代码**：修改代码以减少或消除这些分配。例如，而不是每帧创建一个新的Vector3对象来调整对象的位置，修改现有的位置或使用一个可重用的临时静态变量。'
- en: '**Implement caching**: Store frequently used objects, such as temporary data
    for calculations, in a private field that gets reused instead of re-instantiated.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现缓存**：将频繁使用的对象，如计算中的临时数据，存储在私有字段中，以便重用而不是重新实例化。'
- en: Furthermore, object pooling is another effective technique that can drastically
    reduce the need for frequent allocations and deallocations. This is particularly
    useful for games where objects such are projectiles or UI elements are created
    and destroyed often.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对象池是另一种可以显著减少频繁分配和释放需求的有效技术。这对于经常创建和销毁对象的游戏特别有用，例如弹射物或UI元素。
- en: 'Here are the steps for object pooling implementation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对象池实现的步骤：
- en: '**Create a pool manager**: Develop a script that manages a pool of objects
    or use Unity’s built-in solution. This pool pre-instantiates a set number of each
    object type during the game’s start-up phase.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建池管理器**：开发一个管理对象池的脚本或使用Unity内置的解决方案。这个池在游戏启动阶段预先实例化了一定数量的每种对象类型。'
- en: '**Reuse objects**: When an object is needed, instead of instantiating a new
    one, the pool manager checks if there is an inactive object in the pool and reactivates
    it; if the pool is empty, a new object is created.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重用对象**：当需要对象时，而不是实例化一个新的对象，池管理器会检查池中是否有不活动的对象，并重新激活它；如果池为空，则创建一个新的对象。'
- en: '**Recycle objects**: When the object is no longer needed, instead of destroying
    it, deactivate it and return it to the pool.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回收对象**：当对象不再需要时，而不是销毁它，将其停用并返回到池中。'
- en: By implementing these strategies, you can significantly reduce the number of
    allocations, thereby decreasing the frequency and impact of garbage collection,
    and ensuring smoother gameplay. Object pooling not only optimizes memory usage
    but also reduces CPU overhead, as activating and deactivating objects is generally
    less costly than creating and destroying them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些策略，你可以显著减少分配的数量，从而降低垃圾回收的频率和影响，并确保游戏体验更加流畅。对象池化不仅优化了内存使用，还减少了CPU开销，因为激活和停用对象通常比创建和销毁它们成本低。
- en: This section has explored strategies to minimize garbage collection in Unity,
    focusing on reducing memory allocations in frequently called methods and using
    object pooling. Next, we will provide practical tips and tools for more effective
    memory management, building on the foundational knowledge established here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了在Unity中减少垃圾回收的策略，重点关注减少频繁调用的方法中的内存分配和使用对象池化。接下来，我们将提供基于这里建立的基础知识的实用技巧和工具，以实现更有效的内存管理。
- en: Practical memory management tips and tools
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用的内存管理技巧和工具
- en: This sub-section builds directly on the insights provided by Unity’s Profiler,
    offering practical tips to enhance memory management in your Unity projects. We’ll
    focus on applying what you’ve learned from profiling sessions to effectively identify
    and resolve memory issues.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节直接基于Unity的Profiler提供的洞察，提供了实用的技巧来增强Unity项目中内存管理的效率。我们将专注于将你在分析会话中学到的知识应用于有效地识别和解决内存问题。
- en: Topics will include using the Memory Profiler package for deeper analysis, using
    statements to manage `IDisposable` objects efficiently, optimizing asset sizes,
    and wisely managing asset bundles and scene transitions. By the end of this discussion,
    you’ll be equipped with actionable strategies to ensure your projects are not
    only optimized for performance but also robust in handling memory efficiently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的主题将包括使用内存分析器包进行深入分析、使用语句高效管理`IDisposable`对象、优化资产大小以及明智地管理资产包和场景转换。到这次讨论结束时，你将具备可操作的策略，确保你的项目不仅性能优化，而且在高效处理内存方面也很稳健。
- en: 'Once you’ve gathered data using Unity’s Profiler, turning those insights into
    actionable improvements is the next critical step. This involves implementing
    strategies that effectively manage and optimize memory usage, thereby enhancing
    game performance and reducing issues such as lag and crashes. Let’s look at some
    of these strategies:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用Unity的Profiler收集了数据，将那些洞察转化为可操作的提升就是下一步的关键步骤。这涉及到实施有效管理和优化内存使用的策略，从而提高游戏性能并减少如卡顿和崩溃等问题。让我们来看看一些这些策略：
- en: '**Identifying and managing memory leaks and excessive allocations**: A common
    issue that’s identified by the Profiler is memory leaks, where objects are not
    released properly, which results in them continually consuming memory. The Memory
    Profiler package is instrumental in pinpointing these leaks. Once identified,
    you can tackle these leaks by ensuring all objects are correctly disposed of and
    references are cleared when they’re no longer needed. For excessive allocations,
    scrutinize the allocation patterns identified by the Profiler and streamline the
    instantiation processes. For example, if a method called in every frame is creating
    new objects, consider revising this approach.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别和管理内存泄漏和过度分配**：Profiler识别的一个常见问题是内存泄漏，即对象没有被正确释放，导致它们持续消耗内存。内存分析器包在定位这些泄漏方面至关重要。一旦识别出泄漏，你可以通过确保所有对象都正确释放，并在不再需要时清除引用来处理这些泄漏。对于过度分配，仔细审查Profiler确定的分配模式，并简化实例化过程。例如，如果一个在每一帧调用的方法正在创建新对象，考虑修改这种方法。'
- en: '`IDisposable` objects are used in .NET to manage memory for objects that hold
    unmanaged resources, such as file handles or database connections. These objects
    aren’t managed by the garbage collector and must be manually disposed of to free
    their resources. The `using` statement in C# is a robust tool for handling `IDisposable`
    objects because it ensures that the `Dispose` method is called automatically,
    which is crucial for freeing up resources:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET中，`IDisposable`对象用于管理持有非托管资源（如文件句柄或数据库连接）的对象的内存。这些对象不由垃圾回收器管理，必须手动释放以释放其资源。C#中的`using`语句是处理`IDisposable`对象的强大工具，因为它确保了`Dispose`方法会自动调用，这对于释放资源至关重要：
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Optimizing asset sizes and using asset bundles**: To optimize asset sizes,
    reduce the resolution of large textures or compress them without significantly
    impacting visual quality. Utilizing asset bundles wisely can also drastically
    reduce memory usage. Load only the necessary assets for the current scene and
    unload them when they’re no longer needed, especially during scene transitions.
    This keeps your runtime memory footprint low and avoids loading unnecessary assets.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源大小和使用资源包**：为了优化资源大小，可以降低大纹理的分辨率或在不显著影响视觉效果的情况下压缩它们。明智地使用资源包也可以大幅减少内存使用。仅加载当前场景所需的资源，并在不再需要时卸载它们，尤其是在场景转换期间。这有助于保持运行时内存占用低，避免加载不必要的资源。'
- en: '`LoadSceneAsync`) to smooth out loading times and manage memory more effectively
    during transitions. Ensure that assets from previous scenes are unloaded from
    memory to prevent buildup that can lead to crashes.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LoadSceneAsync` 平滑加载时间并更有效地在转换期间管理内存。确保从先前场景卸载资源，以防止积累导致崩溃。
- en: By applying these strategies, developers can translate the raw data from Unity’s
    Profiler into tangible improvements in their projects. This approach not only
    enhances performance but also improves the overall stability and user experience
    of the game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用这些策略，开发者可以将 Unity 的 Profiler 中的原始数据转换为项目中的实际改进。这种方法不仅提升了性能，还改善了游戏的整体稳定性和用户体验。
- en: Effective memory management ensures your game runs smoothly without crashes
    or stuttering. Utilize Unity’s Memory Profiler to identify memory leaks and excessive
    allocations. When dealing with `IDisposable` objects, use the `using` statement
    to ensure resources are released promptly. Additionally, optimize asset sizes
    by using appropriate compression and only load necessary assets during scene transitions.
    Finally, implement asynchronous loading with `LoadSceneAsync` to manage memory
    more efficiently, preventing large memory spikes and ensuring a stable gameplay
    experience.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的内存管理确保游戏运行顺畅，不会出现崩溃或卡顿。利用 Unity 的内存分析器来识别内存泄漏和过度分配。在处理 `IDisposable` 对象时，使用
    `using` 语句确保资源能够及时释放。此外，通过使用适当的压缩和仅在场景转换期间加载必要的资源来优化资源大小。最后，通过使用 `LoadSceneAsync`
    实现异步加载，更有效地管理内存，防止内存峰值，确保稳定的游戏体验。
- en: This section has provided you with practical strategies and tools for effective
    memory management in Unity projects, focusing on optimizing memory usage through
    techniques such as identifying memory leaks with the Memory Profiler package and
    managing `IDisposable` objects efficiently using statements. We also explored
    how optimizing asset sizes, using asset bundles strategically, and effectively
    managing scene transitions can significantly reduce memory load and enhance game
    performance. As we transition to focus on further optimization, the next section
    will build upon these foundations, extending into optimizing graphics and rendering
    processes. This will involve fine-tuning visual elements without compromising
    performance, ensuring that your game not only runs efficiently but also maintains
    aesthetic appeal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您提供了 Unity 项目中有效内存管理的实用策略和工具，重点关注通过使用内存分析器包识别内存泄漏以及通过使用语句高效管理 `IDisposable`
    对象等技术来优化内存使用。我们还探讨了优化资源大小、战略性地使用资源包以及有效管理场景转换如何显著减少内存负载并提升游戏性能。随着我们转向进一步优化的重点，下一节将在此基础上扩展，涉及优化图形和渲染过程。这将涉及在不影响性能的情况下微调视觉元素，确保游戏不仅运行高效，而且保持美学吸引力。
- en: Optimizing graphics and rendering
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化图形和渲染
- en: Graphics often consume a significant portion of a game’s performance budget.
    This section covers optimizing graphical assets and the rendering pipeline in
    Unity, discussing techniques such as **level of detail** (**LOD**), culling, batching,
    and the use of performance-optimized shaders and materials. Real-world examples,
    such as implementing a LOD system, provide valuable insights.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图形通常占游戏性能预算的很大一部分。本节涵盖了在 Unity 中优化图形资源和渲染管道的方法，讨论了诸如 **细节级别**（**LOD**）、剔除、批处理以及使用性能优化的着色器和材质等技术。例如，实现
    LOD 系统的实例提供了宝贵的见解。
- en: LOD and asset optimization
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LOD 和资源优化
- en: LOD is a technique that’s used to reduce the complexity of 3D models when they
    are far from the camera, thereby conserving resources while maintaining visual
    fidelity up close. This method is essential for optimizing performance in games,
    especially in large, open-world environments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: LOD是一种技术，用于在3D模型远离相机时减少其复杂性，从而在近距离保持视觉保真度的同时节省资源。这种方法对于优化游戏中的性能至关重要，尤其是在大型、开放世界环境中。
- en: 'The following figure shows three versions (LOD0, LOD1 and LOD2) of the same
    bottle made up of differing numbers of triangles:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了由不同数量三角形组成的同一瓶子的三个版本（LOD0、LOD1和LOD2）：
- en: '![Figure 12.3 – Each progressive LOD model has fewer triangles](img/B22128_12_3.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 每个逐步LOD模型都有更少的三角形](img/B22128_12_3.jpg)'
- en: Figure 12.3 – Each progressive LOD model has fewer triangles
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 每个逐步LOD模型都有更少的三角形
- en: In the preceding figure, the bottle on the left (**LOD0**) has the most triangles
    and represents the highest level of detail. As you move to the right, the bottles
    have fewer triangles, with the middle bottle being **LOD1** and the bottle on
    the right (**LOD2**) having the least detail. This approach helps maintain smooth
    performance by reducing the computational load for distant objects while preserving
    visual quality for closer objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，左边的瓶子（**LOD0**）具有最多的三角形，代表了最高的细节级别。当你向右移动时，瓶子具有更少的三角形，中间的瓶子是**LOD1**，而右边的瓶子（**LOD2**）具有最少的细节。这种方法通过减少远离对象的计算负载，同时保持近距离对象的视觉质量，有助于保持平滑的性能。
- en: Several steps are needed to add LOD to a model in Unity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中向模型添加LOD需要几个步骤。
- en: 'Here’s how you can set up LOD Groups in Unity:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在Unity中设置LOD组：
- en: '**Create** **LOD models**:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建** **LOD模型**：'
- en: Start by opening your 3D model in a program such as Blender. Use the **Decimate**
    tool to reduce the number of triangles in the model. Save the simplified model
    as LOD1\. Repeat the decimation process to create an even lower detail version
    and save this as LOD2\. Continue this process as needed, ensuring that each subsequent
    version has progressively fewer triangles, making it suitable for rendering at
    greater distances.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先在一个程序如Blender中打开你的3D模型。使用**减少**工具减少模型中的三角形数量。将简化的模型保存为LOD1。重复减少过程以创建一个更低细节的版本，并将其保存为LOD2。根据需要继续此过程，确保每个后续版本都有更少的三角形，使其适合在更远的距离上渲染。
- en: '`Character_LOD0`, `Character_LOD1`, and `Character_LOD2`.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Character_LOD0`、`Character_LOD1`和`Character_LOD2`。'
- en: '**Create a LOD** **Group component**:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个LOD组** **组件**：'
- en: Select your high-detail model in Unity and add a LOD group component by navigating
    to the **Inspector** window and clicking on **Add Component** | **Rendering**
    | **LOD Group**.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Unity中选择你的高细节模型，通过导航到**检查器**窗口并点击**添加组件** | **渲染** | **LOD组**来添加LOD组组件。
- en: '**Assign** **LOD models**:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分配** **LOD模型**：'
- en: In the LOD Group component, define different LOD levels and assign the corresponding
    models to each level. For example, the highest detail model is assigned to LOD0,
    a slightly simplified version to LOD1, and so on.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在LOD组组件中，定义不同的LOD级别并将相应的模型分配给每个级别。例如，最高细节模型分配给LOD0，稍微简化的版本分配给LOD1，依此类推。
- en: '**Adjust** **LOD settings**:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整** **LOD设置**：'
- en: Configure the screen relative transition distances to determine at which distances
    each LOD model becomes active. Adjust these settings to balance visual detail
    and performance, ensuring smooth transitions between LOD levels to avoid visual
    popping.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置屏幕相对过渡距离以确定每个LOD模型在哪个距离变得活跃。调整这些设置以平衡视觉细节和性能，确保LOD级别之间的平滑过渡，避免视觉跳跃。
- en: '**Optimize textures** **and materials**:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优化纹理** **和材质**：'
- en: Use appropriate textures and materials for each LOD level. Lower-detail models
    can use lower-resolution textures to further reduce resource usage.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为每个LOD级别使用适当的纹理和材质。低细节模型可以使用低分辨率纹理以进一步减少资源使用。
- en: 'Now, let’s talk about the best practices for LOD models:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈LOD模型的最佳实践：
- en: Simplify geometry progressively for distant LOD levels to maintain performance
    without noticeable quality loss.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步简化几何形状以适应远距离LOD级别，以保持性能而不会出现明显的质量损失。
- en: Ensure smooth transitions between LOD levels by carefully adjusting transition
    thresholds and maintaining consistent materials.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仔细调整过渡阈值并保持材质的一致性，确保LOD级别之间的平滑过渡。
- en: Regularly test the LOD system in the game environment to ensure it meets performance
    and visual quality standards.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期在游戏环境中测试LOD系统，以确保其满足性能和视觉质量标准。
- en: Implementing LOD and optimizing graphical assets are vital for achieving a balance
    between visual quality and performance. By adjusting model complexity and optimizing
    textures and animations, developers can create visually appealing games that run
    smoothly. Having discussed LOD and asset optimization, the next section will focus
    on culling techniques to further enhance rendering performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实现LOD和优化图形资产对于在视觉质量和性能之间取得平衡至关重要。通过调整模型复杂度、优化纹理和动画，开发者可以创建视觉上吸引人的游戏，同时运行流畅。在讨论了LOD和资产优化之后，下一节将专注于剔除技术，以进一步优化渲染性能。
- en: Culling techniques
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剔除技术
- en: Culling is a crucial optimization technique in Unity that improves rendering
    efficiency by limiting the rendering process to only what is visible to the camera.
    This reduces the number of objects and polygons that need to be processed, enhancing
    overall performance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 剔除是Unity中一个关键的优化技术，通过限制渲染过程只渲染相机可见的内容来提高渲染效率。这减少了需要处理的对象和多边形数量，从而提高了整体性能。
- en: 'Let’s take a look at the different culling techniques:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的剔除技术：
- en: '**Frustum culling**: Frustum culling automatically removes objects outside
    the camera’s view frustum from the rendering pipeline. It is enabled by default
    in Unity, ensuring that only objects within the visible area are processed.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视锥体剔除**：视锥体剔除自动从渲染管线中移除相机视锥体外的对象。在Unity中默认启用，确保只有可见区域内的对象被处理。'
- en: '**Occlusion culling**: Occlusion culling goes a step further by excluding objects
    hidden behind other objects from rendering. To enable occlusion culling, navigate
    to **Window** | **Rendering** | **Occlusion Culling** and bake the occlusion data.
    This is especially useful in complex scenes with many overlapping objects.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡剔除**：遮挡剔除通过排除被其他对象遮挡的对象，将其从渲染中排除，从而更进一步。要启用遮挡剔除，请导航到 **窗口** | **渲染** |
    **遮挡剔除** 并烘焙遮挡数据。这在具有许多重叠对象的复杂场景中特别有用。'
- en: '**Backface culling**: Backface culling skips rendering the back faces of polygons
    as they are not visible to the camera. This is typically enabled by default in
    shaders and significantly reduces the rendering load for models with many polygons.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背面剔除**：背面剔除跳过渲染多边形的背面，因为背面对于相机是不可见的。这通常在着色器中默认启用，可以显著减少具有许多多边形的模型的渲染负载。'
- en: Culling techniques are essential for optimizing rendering performance by focusing
    on visible objects and reducing unnecessary processing. By effectively using frustum,
    occlusion, and backface culling, you can significantly enhance your game’s performance.
    Now that we understand culling techniques, we’ll explore batching methods, which
    further enhance rendering efficiency.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 剔除技术对于通过关注可见对象和减少不必要的处理来优化渲染性能至关重要。通过有效地使用视锥体、遮挡和背面剔除，可以显著提高游戏性能。现在我们了解了剔除技术，我们将探讨批处理方法，这些方法可以进一步提高渲染效率。
- en: Batching techniques
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批处理技术
- en: Batching is an optimization technique in Unity that reduces the number of draw
    calls by combining multiple objects into a single draw call. This can significantly
    improve rendering performance, especially in scenes with many small objects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理是Unity中的一种优化技术，通过将多个对象合并到一个绘制调用中，减少了绘制调用次数。这可以显著提高渲染性能，尤其是在具有许多小对象的场景中。
- en: 'Let’s take a look at the different batching techniques:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的批处理技术：
- en: '**Static batching**: This combines static (non-moving) objects into one draw
    call. To enable static batching, mark objects as static in the **Inspector** window.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态批处理**：这通过将静态（非移动）对象合并到一个绘制调用中来实现。要启用静态批处理，请在 **检查器** 窗口中将对象标记为静态。'
- en: '**Dynamic batching**: This combines dynamic (moving) objects into one draw
    call. This is automatically handled by Unity but requires objects to meet specific
    criteria, such as having fewer than 900 vertex attributes.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态批处理**：这通过将动态（移动）对象合并到一个绘制调用中来实现。这由Unity自动处理，但需要对象满足特定标准，例如具有少于900个顶点属性。'
- en: Batching is beneficial because reducing the number of draw calls decreases the
    overhead on the CPU, leading to smoother performance and higher frame rates. Batching
    is particularly beneficial in complex scenes with numerous objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理是有益的，因为减少绘制调用可以降低CPU的负载，从而实现更平滑的性能和更高的帧率。批处理在具有许多对象的复杂场景中尤其有益。
- en: Setup and common pitfalls of batching
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理设置和常见陷阱
- en: To set up batching, ensure objects share the same material so that they can
    be batched together.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置批处理，确保对象共享相同的材质，以便它们可以一起批处理。
- en: There are some common pitfalls of batching. Be cautious with static batching,
    as excessive use can lead to increased memory usage, and ensure that dynamic objects
    meet the criteria for batching.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理有一些常见的陷阱。在使用静态批处理时要小心，过度使用可能导致内存使用增加，并确保动态对象满足批处理的条件。
- en: By effectively using static and dynamic batching, you can reduce draw calls
    and significantly boost rendering performance. Having discussed batching techniques,
    we’ll move on to shaders and materials optimization so that you can further enhance
    the visual performance of your game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效地使用静态和动态批处理，您可以减少绘制调用次数并显著提高渲染性能。在讨论了批处理技术之后，我们将继续探讨着色器和材质优化，以便您进一步提高游戏的可视性能。
- en: Shaders and materials optimization
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器和材质优化
- en: Optimizing shaders and materials is crucial for enhancing rendering performance
    in Unity. Efficient shader and material usage can significantly impact the overall
    performance and visual quality of a game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中优化着色器和材质对于提高渲染性能至关重要。高效的着色器和材质使用可以显著影响游戏的整体性能和视觉效果。
- en: To begin our dive into enhancing rendering performance, let’s explore shader
    optimizations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始深入了解提高渲染性能，让我们探索着色器优化。
- en: Shader optimization
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器优化
- en: 'Here are some key tips for optimizing shaders in Unity:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些优化Unity中着色器的关键提示：
- en: '**Use Shader Graph**: Utilize Unity’s Shader Graph to create performant custom
    shaders. This visual tool allows you to build shaders efficiently without writing
    complex code.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Shader Graph**：利用Unity的Shader Graph创建高效的定制着色器。这个可视化工具允许您高效地构建着色器，而无需编写复杂的代码。'
- en: '**Avoid overly complex shaders**: Simplify shaders to avoid unnecessary computations,
    which can slow down rendering. Focus on essential visual effects to maintain performance.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免过于复杂的着色器**：简化着色器以避免不必要的计算，这可能会减慢渲染速度。关注基本视觉效果以保持性能。'
- en: Next, we need to know how the choice of rendering pipeline impacts overall game
    performance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要了解渲染管线选择如何影响整体游戏性能。
- en: Rendering pipelines
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染管线
- en: 'Unity offers several graphical systems:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了几个图形系统：
- en: '**Universal Render Pipeline (URP)**: Implement URP for better performance across
    various devices. URP optimizes rendering processes, making it ideal for projects
    targeting multiple platforms, from mobile devices to high-end PCs. It provides
    a good balance between visual quality and performance.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用渲染管线（URP）**：实施URP以在各种设备上获得更好的性能。URP优化渲染过程，使其非常适合针对从移动设备到高端PC的多个平台的项目。它提供了视觉质量和性能之间的良好平衡。'
- en: '**High-Definition Render Pipeline (HDRP)**: HDRP is ideal for projects requiring
    high-end graphics and targeting powerful hardware such as gaming PCs and consoles.
    It offers advanced lighting, shadows, and post-processing effects for stunning
    visuals but demands higher performance, making it less suitable for lower-end
    devices or high frame rates projects.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高清晰度渲染管线（HDRP）**：HDRP非常适合需要高端图形并针对游戏PC和游戏机等强大硬件的项目。它提供了先进的照明、阴影和后期处理效果，以实现惊人的视觉效果，但需要更高的性能，因此对于低端设备或高帧率项目不太适合。'
- en: '**Built-in render pipeline**: Unity’s default built-in render pipeline is flexible
    and widely used. While offering many features, it lacks the performance optimization
    of URP. It is suitable for projects that require support for various custom shaders
    and assets not compatible with URP or HDRP.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置渲染管线**：Unity的默认内置渲染管线灵活且广泛使用。虽然提供了许多功能，但它缺乏URP的性能优化。它适用于需要支持与URP或HDRP不兼容的各种自定义着色器和资产的项目。'
- en: URP is recommended for most projects due to its broad device compatibility and
    performance. As Unity’s most efficient render pipeline, URP offers optimal rendering
    without sacrificing much visual quality. It suits developers optimizing games
    across platforms while using modern rendering features. Select your rendering
    pipeline based on your project’s specific needs and target devices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其广泛的设备兼容性和性能，URP被推荐用于大多数项目。作为Unity最有效的渲染管线，URP提供了最优的渲染效果，同时牺牲很少的视觉效果。它适合跨平台优化游戏的开发者，同时使用现代渲染功能。根据您项目的具体需求和目标设备选择您的渲染管线。
- en: Material optimization
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 材质优化
- en: 'Finally, here are key optimizations for enhancing rendering performance:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是提高渲染性能的关键优化：
- en: '**Minimize material count**: Reduce the number of unique materials to lower
    draw calls and improve performance.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化材质数量**：减少独特材质的数量以降低绘制调用次数并提高性能。'
- en: '**Use texture atlases**: Combine multiple textures into a single atlas to reduce
    the number of texture lookups and enhance rendering speed.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用纹理图集**：将多个纹理合并到一个图集中，以减少纹理查找次数并提高渲染速度。'
- en: Optimizing shaders and materials through tools such as Shader Graph, using lightweight
    rendering pipelines, and efficient material management is essential for improving
    game performance. With shaders and materials optimization covered, we’ll turn
    our attention to efficient scripting and code optimization techniques to further
    enhance game performance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用如Shader Graph等工具优化着色器和材质，使用轻量级渲染管线和高效材质管理，对于提高游戏性能至关重要。在着色器和材质优化完成后，我们将关注高效的脚本和代码优化技术，以进一步增强游戏性能。
- en: Efficient scripting and code optimization
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的脚本和代码优化
- en: As you approach the final stages of optimizing your Unity projects, embracing
    Unity’s DOTS and **Burst Compiler** is essential for pushing the boundaries of
    game performance. Unity’s **Data-Oriented Technology Stack** (**DOTS**) is a framework
    for writing high-performance code by optimizing memory layout and parallel processing.
    The **Burst Compiler** translates C# jobs into highly optimized machine code,
    significantly boosting execution speed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你接近优化Unity项目最终阶段时，采用Unity的DOTS和**Burst编译器**对于推动游戏性能的边界至关重要。Unity的**面向数据的技术堆栈**（**DOTS**）是一个通过优化内存布局和并行处理来编写高性能代码的框架。**Burst编译器**将C#作业转换为高度优化的机器代码，显著提高执行速度。
- en: This section delves deep into the best practices and advanced techniques that
    harness the power of these tools, transforming your approach to coding within
    Unity. We will explore how DOTS enables you to write highly efficient, multithreaded
    code and how the Burst Compiler complements this by turning your C# code into
    highly optimized native code. From restructuring data to maximize parallel execution
    to leveraging sophisticated compilation techniques, this guide aims to provide
    you with the knowledge to significantly enhance both the performance and scalability
    of your games.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了利用这些工具的最佳实践和高级技术，改变你在Unity中的编码方法。我们将探讨DOTS如何使你能够编写高度高效的、多线程的代码，以及Burst编译器如何通过将你的C#代码转换为高度优化的原生代码来补充这一点。从重新结构化数据以最大化并行执行到利用复杂的编译技术，本指南旨在为你提供知识，以显著提高游戏性能和可扩展性。
- en: 'The following is an example of how DOTS coding might appear:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个DOTS编码可能出现的示例：
- en: '[PRE2]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example demonstrates using Unity’s DOTS for performance optimization. The
    `MoveSpeed` component stores the entity’s speed, and `MoveForwardSystem` schedules
    a `MoveForwardJob` component to move entities forward each frame. The job updates
    the `Translation` component’s *Z* value using the entity’s speed and the delta
    time. The `[BurstCompile]` attribute optimizes the job, making it highly efficient.
    This approach allows for parallel processing of multiple entities, significantly
    improving performance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示了使用Unity的DOTS进行性能优化。`MoveSpeed`组件存储实体的速度，`MoveForwardSystem`在每个帧调度一个`MoveForwardJob`组件以使实体前进。作业使用实体的速度和delta时间更新`Translation`组件的*Z*值。`[BurstCompile]`属性优化了作业，使其非常高效。这种方法允许并行处理多个实体，显著提高性能。
- en: Best practices in script optimization with DOTS
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DOTS进行脚本优化的最佳实践
- en: Optimizing scripts is essential for maintaining performance in Unity games.
    DOTS offers advanced tools for writing efficient, multi-threaded code. DOTS recently
    left Beta, and Unity continues to refine it based on developer feedback. Be cautious
    when using DOTS for long-term production, as future changes may affect compatibility.
    However, the performance boost can be substantial. It’s beneficial to stay current
    with DOTS developments to leverage these advancements effectively.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 优化脚本对于在Unity游戏中保持性能至关重要。DOTS提供了编写高效、多线程代码的高级工具。DOTS最近已退出测试版，Unity根据开发者反馈持续对其进行优化。在使用DOTS进行长期生产时请谨慎，因为未来的更改可能会影响兼容性。然而，性能提升可能是显著的。保持对DOTS发展的了解，以有效地利用这些进步是有益的。
- en: 'Here are the general best practices:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些一般最佳实践：
- en: '`Update()`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`。'
- en: '**Utilize DOTS**: Architect solutions with DOTS to reduce garbage collection
    and improve data management.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用DOTS**：使用DOTS构建解决方案以减少垃圾回收并提高数据管理。'
- en: '**Leverage DOT’s multi-threaded capabilities**: Structure data and operations
    to leverage DOTS’s multi-threading for better performance.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用DOTS的多线程能力**：结构化数据和操作以利用DOTS的多线程功能，提高性能。'
- en: '**Implement profiling**: Use Unity’s Profiler to identify and resolve bottlenecks
    through data-oriented design.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现性能分析**：使用Unity的Profiler通过面向数据的设计来识别和解决瓶颈。'
- en: By following best practices and utilizing DOTS, developers can write efficient
    scripts that enhance game performance. Next, we will explore advanced data management
    and access patterns so that you can further optimize your Unity projects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循最佳实践和利用DOTS，开发者可以编写高效的脚本，从而提升游戏性能。接下来，我们将探讨高级数据管理和访问模式，以便您进一步优化您的Unity项目。
- en: Advanced data management and access patterns
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级数据管理和访问模式
- en: Optimizing data structures and algorithms is crucial for achieving high performance
    in Unity games. This section delves into techniques for making data cache-friendly
    and minimizing access times, leveraging DOTS for handling large datasets efficiently.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 优化数据结构和算法对于在Unity游戏中实现高性能至关重要。本节深入探讨了使数据缓存友好和最小化访问时间的技巧，利用DOTS高效处理大数据集。
- en: 'Let’s learn how to optimize data structures:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何优化数据结构：
- en: '**Ensure cache-friendly data**: Organize data to ensure it is contiguous in
    memory, reducing cache misses and speeding up access times. Use structures such
    as arrays or NativeArrays provided by DOTS, which store data sequentially, making
    it more efficient for the CPU to fetch and process.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保缓存友好的数据**：组织数据以确保其在内存中连续，减少缓存未命中并加快访问时间。使用DOTS提供的结构，如数组或NativeArrays，这些结构按顺序存储数据，使CPU获取和处理数据更加高效。'
- en: '**Use efficient algorithms**: Use algorithms optimized for performance by focusing
    on reducing computational complexity and improving data locality. Prefer algorithms
    that minimize memory access and maximize data reuse within the CPU cache to avoid
    unnecessary data fetching.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用高效的算法**：使用针对性能优化的算法，通过关注降低计算复杂度和提高数据局部性。优先选择最小化内存访问并最大化CPU缓存内数据重用的算法，以避免不必要的数据处理。'
- en: Next, we will delve into advanced data management techniques with DOTS to enhance
    performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨使用DOTS的高级数据管理技术以提高性能。
- en: Leveraging DOTS’ advanced data management for increased performance
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用DOTS的高级数据管理提高性能
- en: 'Let’s dive into optimizing performance using DOTS, including data-oriented
    approaches, efficient loop iterations, and parallel operations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨使用DOTS优化性能的方法，包括面向数据的方法、高效的循环迭代和并行操作：
- en: '**Data-oriented approach**: DOTS promotes handling data in ways that maximize
    performance, especially for processing large datasets quickly. It emphasizes the
    separation of data and behavior, allowing for more efficient data processing and
    better utilization of modern CPU architectures.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向数据的方法**：DOTS促进以最大化性能的方式处理数据，尤其是在快速处理大数据集时。它强调数据和行为分离，从而实现更高效的数据处理和更好地利用现代CPU架构。'
- en: '`IJob` and `IJobParallelFor` interfaces to parallelize loops, distributing
    the workload efficiently across multiple cores.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IJob`和`IJobParallelFor`接口用于并行化循环，将工作负载高效地分配到多个核心。'
- en: '**Parallel operations**: Utilize DOTS to handle parallel operations efficiently,
    distributing tasks across multiple threads. Use the Job System to break down tasks
    into smaller jobs that can run concurrently and leverage the **Entity Component
    System** (**ECS**) to manage data in a way that supports parallel processing naturally.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行操作**：利用DOTS高效处理并行操作，将任务分配到多个线程。使用作业系统将任务分解为更小的作业，以便并行运行，并利用**实体组件系统（ECS**）以支持并行处理的方式管理数据。'
- en: By optimizing data management and access patterns, developers can significantly
    enhance game performance, especially when dealing with extensive data processing
    tasks. Next, we will explore leveraging the Burst Compiler to maximize performance,
    further enhancing the efficiency of your Unity projects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过优化数据管理和访问模式，开发者可以显著提升游戏性能，尤其是在处理大量数据处理任务时。接下来，我们将探讨利用爆发编译器来最大化性能，进一步提高您Unity项目的效率。
- en: Leveraging the Burst Compiler to maximize performance
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用爆发编译器最大化性能
- en: The Burst Compiler transforms C# code into highly optimized machine code, significantly
    enhancing performance. It integrates seamlessly with DOTS and Unity’s Jobs System
    to optimize multithreaded code, making it one of the most stable and reliable
    tools within Unity’s DOTS framework.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 爆发编译器将C#代码转换为高度优化的机器代码，显著提升性能。它与DOTS和Unity的作业系统无缝集成，以优化多线程代码，使其成为Unity DOTS框架中最稳定和可靠的工具之一。
- en: Using the Burst Compiler
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用爆发编译器
- en: To use the Burst Compiler, your code must be compatible with the Job System
    and adhere to specific restrictions. This includes avoiding managed objects, such
    as classes that use garbage collection, and using blittable types, which are simple
    data types that can be directly copied in memory without conversion. These requirements
    ensure that the code can be efficiently transformed into low-level machine code.
    Integrated with DOTS, the Burst Compiler optimizes the execution of jobs by breaking
    down tasks into smaller units of work that can run concurrently. This approach
    takes full advantage of modern CPU architectures, utilizing multiple cores to
    enhance performance and significantly reduce execution time for complex computations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Burst 编译器，您的代码必须与作业系统兼容并遵守特定限制。这包括避免使用托管对象，例如使用垃圾回收的类，并使用可拷贝类型，这些是可以在内存中直接复制而无需转换的简单数据类型。这些要求确保代码可以有效地转换为低级机器代码。与
    DOTS 集成后，Burst 编译器通过将任务分解为可以并发运行的小单元来优化作业的执行。这种方法充分利用了现代 CPU 架构，利用多个核心来提高性能，并显著减少复杂计算的执行时间。
- en: Practical implementation
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践实施
- en: Using the Burst Compiler in a Unity game project can significantly enhance performance
    by converting high-level C# code into highly optimized machine code. This is particularly
    beneficial for compute-heavy tasks such as physics calculations, AI pathfinding,
    and procedural generation. By ensuring your code adheres to Burst’s requirements
    – such as using blittable types and avoiding managed objects – you can take full
    advantage of modern CPU architectures. This results in improvements in frame rates
    and game responsiveness.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 游戏项目中使用 Burst 编译器可以通过将高级 C# 代码转换为高度优化的机器代码来显著提高性能。这对于计算密集型任务，如物理计算、AI
    路径查找和过程生成特别有益。通过确保您的代码符合 Burst 的要求——例如使用可拷贝类型并避免使用托管对象——您可以充分利用现代 CPU 架构。这导致帧率和游戏响应性的提升。
- en: Utilizing the Burst Compiler is a powerful way to optimize your game’s performance,
    making it a reasonable choice for most projects. Its stability within the DOTS
    ecosystem ensures reliable enhancements in execution speed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Burst 编译器是优化游戏性能的强大方式，对于大多数项目来说是一个合理的选择。它在 DOTS 生态系统中的稳定性确保了执行速度的可靠提升。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered crucial aspects of optimizing game performance in Unity.
    You learned how to use profiling tools to analyze game performance, manage memory
    usage, and handle garbage collection for smooth gameplay. Then, we explored optimizing
    graphical assets, rendering processes, and implementing LOD systems to balance
    visual fidelity and performance. Best practices for writing efficient code were
    also provided. These skills will help you streamline and optimize games for various
    platforms. In the next chapter, you will apply these techniques to build a complete
    game that runs smoothly across multiple platforms.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在 Unity 中优化游戏性能的关键方面。您学习了如何使用分析工具来分析游戏性能、管理内存使用和处理垃圾回收以实现流畅的游戏体验。然后，我们探讨了优化图形资源、渲染过程和实现
    LOD 系统以平衡视觉保真度和性能。还提供了编写高效代码的最佳实践。这些技能将帮助您为各种平台优化和简化游戏。在下一章中，您将应用这些技术来构建一个在多个平台上运行流畅的完整游戏。
- en: Join our community on Discord
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: [https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)
- en: '![](img/Disclaimer_QR1.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![免责声明二维码](img/Disclaimer_QR1.jpg)'
- en: 'Part 4: Real World Applications and Case Studies'
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 部分：现实世界应用和案例研究
- en: In this part, you will apply your Unity and C# skills to real-world applications
    and case studies. You will learn to conceptualize and plan a game project, design
    and implement core game mechanics, and manage and integrate various game assets
    to ensure a smooth player experience. Additionally, you will explore **Virtual
    Reality** (**VR**) and **Augmented Reality** (**AR**) principles, implement functionalities,
    design interactive elements, and optimize applications for different devices.
    You will address cross-platform development challenges, optimize games for mobile
    performance, design adaptive user interfaces, and conduct effective testing. Finally,
    you will navigate game publishing platforms, employ marketing techniques, implement
    monetization models, and build and maintain a player community, preparing you
    to bring your games to market successfully.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将应用你的Unity和C#技能到实际应用和案例研究中。你将学习如何构思和规划游戏项目，设计和实现核心游戏机制，以及管理和整合各种游戏资源，以确保玩家体验流畅。此外，你将探索**虚拟现实**（**VR**）和**增强现实**（**AR**）原理，实现功能，设计交互元素，并针对不同设备优化应用程序。你将解决跨平台开发挑战，优化游戏以适应移动性能，设计自适应用户界面，并进行有效测试。最后，你将了解游戏发布平台，采用营销技巧，实施货币化模式，并建立和维护玩家社区，为你成功将游戏推向市场做好准备。
- en: 'This part includes the following chapters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 13*](B22128_13.xhtml#_idTextAnchor300), *Building a Complete Game
    in Unity* *–* *Core Mechanics, Testing, and Enhancing* *the* *Player Experience*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B22128_13.xhtml#_idTextAnchor300), *在Unity中构建完整游戏* *–* *核心机制、测试和提升玩家体验*'
- en: '[*Chapter 14*](B22128_14.xhtml#_idTextAnchor324), *Exploring XR in Unity* *–*
    *Developing Virtual and Augmented Reality Experiences*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B22128_14.xhtml#_idTextAnchor324), *探索Unity中的XR* *–* *开发虚拟和增强现实体验*'
- en: '[*Chapter 15*](B22128_15.xhtml#_idTextAnchor344), *Cross-Platform Game Development
    in Unity* *–* *Mobile, Desktop, and Console*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B22128_15.xhtml#_idTextAnchor344), *Unity中的跨平台游戏开发* *–* *移动、桌面和游戏机*'
- en: '[*Chapter 16*](B22128_16.xhtml#_idTextAnchor366), *Publishing, Monetizing,
    and Marketing Your Game in Unity* *–* *Strategies for Advertising and Community
    Building*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B22128_16.xhtml#_idTextAnchor366), *在Unity中发布、货币化和营销你的游戏* *–* *广告和社区建设策略*'
