<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>7. Patterns in the .NET Base Class Library</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;7.&#160;Patterns in the .NET Base Class Library">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07"></a>Chapter&#160;7.&#160;Patterns in the .NET Base Class Library</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will focus on areas where the creators of the .NET Framework library have leveraged GoF design patterns for creating <span class="strong"><strong>Application Programming Interfaces</strong></span> (<span class="strong"><strong>APIs</strong></span>). This will give you an enormous insight into the usage of design patterns as a mechanism to expose well-defined software interfaces. Most developers consume design pattern-based software interfaces without knowing much about their underpinnings. This chapter will demystify API design based on patterns. As a reader, you will find real-world application of the following GoF patterns in the .NET Framework library:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Adapter pattern</li>
            <li class="listitem" style="list-style-type: disc">Strategy pattern</li>
            <li class="listitem" style="list-style-type: disc">Builder pattern</li>
            <li class="listitem" style="list-style-type: disc">Decorator pattern</li>
            <li class="listitem" style="list-style-type: disc">Chain of responsibility pattern</li>
            <li class="listitem" style="list-style-type: disc">Bridge pattern</li>
            <li class="listitem" style="list-style-type: disc">Factory pattern</li>
            <li class="listitem" style="list-style-type: disc">Observer pattern</li>
            <li class="listitem" style="list-style-type: disc">Composite pattern</li>
            <li class="listitem" style="list-style-type: disc">Facade pattern</li>
            <li class="listitem" style="list-style-type: disc">Iterator pattern</li>
          </ul>
        </div>
        <div class="section" title="Adapter pattern in the .NET BCL">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch07lvl1sec48"></a>Adapter pattern in the .NET BCL</h1>
              </div>
            </div>
          </div>
          <p>The adapter pattern (aka wrapper) translates one interface for a class into a compatible interface expected by the client. This allows objects to work together, which normally wouldn't because of incompatible interfaces.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note28"></a>Note</h3>
              <p>This is achieved by providing its cooperating interface to clients while using the original interface to invoke the core functionality provided by the object.</p>
            </div>
          </div>
          <p>The amount of code necessary to do this is most often small. The adapter is also responsible for transforming data into appropriate forms expected by the library that implements the actual logic. The adapter can be a class adapter or an object adapter. The <code class="literal">SQLDataAdapter</code> class in .NET Framework represents a set of data commands (<code class="literal">select</code>, <code class="literal">update</code>, and <code class="literal">delete</code>) and a database connection that is used to fill the <code class="literal">DataSet</code> (in the case of select), or update the data source:</p>
          <pre class="programlisting">    private static RetrieveRows( 
      string connectionString,string queryString)  
      { 
        using (SqlConnection connection =  
        new SqlConnection(connectionString)) 
        { 
          //--- Adapter class here creates a DataSet  
          //--- without bothering the developer about 
          //--- opening the connections, fetching data 
          //--- from the Data Reader and Filling the Data 
          //--- to a DataSet  
          SqlDataAdapter adapter = new SqlDataAdapter(); 
          adapter.SelectCommand = new SqlCommand( 
          queryString, connection); 
          adapter.Fill(dataset); 
          return dataset; 
        } 
      } 
</pre>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Strategy pattern in the .NET BCL">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec49"></a>Strategy pattern in the .NET BCL</h1>
            </div>
          </div>
        </div>
        <p>The strategy pattern (aka policy pattern) is a design pattern where we can choose algorithms depending upon the context. The pattern is intended to provide a means to define a family of algorithms encapsulated as an object to make them interchangeable. The strategy pattern lets the algorithms vary independently from the clients that use them.</p>
        <p>The <code class="literal">Array</code> and the <code class="literal">ArrayList</code> classes provide the capability to sort objects contained in them through the <code class="literal">Sort</code> method. One can use different strategies to sort by leveraging the strategy design pattern-based API provided by the .NET BCL. The designers of .NET Framework have given us the <code class="literal">IComparer&lt;T&gt;</code> interface to provide a sorting strategy. <code class="literal">Array</code> and <code class="literal">ArrayList</code> provide the capability to sort the objects contained in the collection via the <code class="literal">Sort</code> method. Strategy design pattern is used with <code class="literal">Array</code> and <code class="literal">Arraylist</code> to enable sorting using different strategies, without changing any client code, via an <code class="literal">IComparable</code> interface:</p>
        <pre class="programlisting">    class Employee  
    { 
      public String name {get;set;} 
      public int age {get;set;} 
      public double salary { get; set; }  
    } 
</pre>
        <p>To sort an <code class="literal">Employee</code> list, we need to create a class that implements the <code class="literal">IComparer&lt;T&gt;</code> interface. An instance of this class needs to be passed to the <code class="literal">Sort</code> routine of the <code class="literal">List&lt;T&gt;</code> instance. The <code class="literal">Compare</code> method of <code class="literal">IComparer&lt;T&gt;</code> should implement a <code class="literal">SIGNUM</code> function that returns <code class="literal">1</code>, <code class="literal">0</code>, or <code class="literal">-1</code>:</p>
        <pre class="programlisting">    
class SortByAge : IComparer&lt;Employee&gt; 
    { 
      public int Compare(Employee a, Employee b) 
      { 
        return a.age &gt; b.age ? 1 : -1; 
      } 
    } 
</pre>
        <p>The following code snippets show how we can change sorting criteria depending on the context:</p>
        <pre class="programlisting">    List&lt;Employee&gt; ls = new List&lt;Employee&gt;(); 
    ls.Add(
       new Employee { name = "A", age = 40, salary =  10000 });
    ls.Add(
       new Employee { name = "C", age = 20, salary = 6000 });
    ls.Add(
       new Employee { name = "B", age = 30, salary = 4000  }); 
    ls.Sort(new SortByAge()); 
    foreach(Employee e in ls) 
    { 
      Console.WriteLine(e.name + " " +  
      e.age + " " + e.salary); 
    } 
</pre>
        <p>To sort by name, we need to create another object implementing the same interface:</p>
        <pre class="programlisting">    class SortByName : IComparer&lt;Employee&gt; 
    { 
      public int Compare(Employee a, Employee b) 
      { 
        return a.name.CompareTo(b.name); 
      } 
    } 
</pre>
        <p>We will leverage the <code class="literal">SortByName</code> class to sort the object based on the lexicographical order. We will also use the <code class="literal">StringBuilder</code> class to create a string object to be printed on the console. The <code class="literal">StringBuilder</code> class is an instance where the builder pattern is leveraged by the designers of .NET Framework:</p>
        <pre class="programlisting">    ls.Sort(new SortByName()); 
    foreach(Employee e in ls) 
    { 
      StringBuilder strbuilder = new StringBuilder(); 
      strbuilder.Append(e.name); 
      strbuilder.Append(" "); 
      strbuilder.Append(e.age); 
      strbuilder.Append(" "); 
      strbuilder.Append(e.salary); 
      Console.WriteLine(strbuilder.ToString()); 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Builder pattern in the .NET BCL">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec50"></a>Builder pattern in the .NET BCL</h1>
            </div>
          </div>
        </div>
        <p>The builder pattern is a creational pattern, which separates the construction of a complex object from its representation. Usually, it parses a complex representation to create one or more target objects. Most often, builders create composites. In the <code class="literal">System.Data.SqlClient</code> namespace, <code class="literal">SqlConnectionStringBuilder</code> helps one build connection strings for the purpose of connecting to an RDBMS engine:</p>
        <pre class="programlisting">    SqlConnectionStringBuilder builder = new   
    SqlConnectionStringBuilder(); 
    builder["Data Source"] = "(local)"; 
    builder["integrated Security"] = true; 
    builder["Initial Catalog"] = "AdventureWorks;NewValue=Bad"; 
    Console.WriteLine(builder.ConnectionString); 
</pre>
        <p>The .NET BCL also contains a class that will help us create a URI by assembling its constituents. The following code snippet creates a secured HTTP (<code class="literal">https</code>) URL, which sends data to port <code class="literal">3333</code>:</p>
        <pre class="programlisting">    var builder = new UriBuilder(url); 
    builder.Port = 3333 
    builder.Scheme = "https"; 
    var result = builder.Uri; 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Decorator pattern in the .NET BCL">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec51"></a>Decorator pattern in the .NET BCL</h1>
            </div>
          </div>
        </div>
        <p>The decorator pattern attaches additional responsibilities to an object dynamically. The inheritance is always not feasible, because it is static and applies to an entire class. Decorators provide a flexible alternative to sub-classing for extending functionality. The pattern helps add behavior or state to individual objects at runtime. The .NET Framework uses decorators in the case of stream processing classes. The hierarchy of stream processing classes are as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">
              <code class="literal">System.IO.Stream</code>
              <div class="itemizedlist">
                <ul class="itemizedlist">
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">System.IO.BufferedStream</code>
                  </li>
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">System.IO.FileStream</code>
                  </li>
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">System.IO.MemoryStream</code>
                  </li>
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">System.Net.Sockets.NetworkStream</code>
                  </li>
                  <li class="listitem" style="list-style-type: disc">
                    <code class="literal">System.Security.Cryptography.CryptoStream</code>
                  </li>
                </ul>
              </div>
            </li>
          </ul>
        </div>
        <p>The following code snippets show how one can use <code class="literal">FileStream</code> to read contents from an operating system disk file:</p>
        <pre class="programlisting">    using (FileStream fs = new FileStream(path, FileMode.Open))  
    { 
      using (StreamReader sr = new StreamReader(fs))  
      { 
        while (sr.Peek() &gt;= 0)  
        { 
          Console.WriteLine(sr.ReadLine()); 
        } 
      } 
    } 
</pre>
        <p>The <code class="literal">StreamReader</code> is a decorator object, which uses the additional functionality of buffering the avoid disk access to speed up operation.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Chain of responsibility pattern in ASP.net">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec52"></a>Chain of responsibility pattern in ASP.net</h1>
            </div>
          </div>
        </div>
        <p>The chain of responsibility pattern is a design pattern consisting of a series of processing objects through which we pass a data stream for filtration or modification. Ultimately, the process terminates when the data stream passes the last processing object at the end of the chain. The ASP.NET pipeline is a wonderful example where the chain of responsibility pattern is leveraged to provide an extensible programming model. The ASP.NET infrastructure implements WebForms API, ASMX Web services, WCF, ASP.NET Web API, and ASP.NET MVC using HTTP modules and handlers. Every request in the pipeline passes through a series of modules (a class that implements <code class="literal">IHttpModule</code>) before it reaches its target handler (a class that implements <code class="literal">IHttpHandler</code>). Once a module in the pipeline has done its duty, it passes the responsibility of the request processing to the next module in the chain. Finally, it reaches the handler. The following code snippet shows how one can write an object that leverages the chain of responsibility pattern to create a module that filters an incoming request. These filters are configured as chains and will pass the request content to the next filter in the chain by the ASP.net runtime:</p>
        <pre class="programlisting">    public class SimpleHttpModule : IHttpModule 
    { 
      public SimpleHttpModule(){} 
      public String ModuleName 
      { 
        get { return "SimpleHttpModule"; } 
      } 
      public void Init(HttpApplication application) 
      { 
        application.BeginRequest +=  
        (new EventHandler(this.Application_BeginRequest)); 
        application.EndRequest +=  
        (new EventHandler(this.Application_EndRequest)); 
      } 
      private void Application_BeginRequest(Object source,  
      EventArgs e) 
      { 
        HttpApplication application = (HttpApplication)source; 
        HttpContext context = application.Context; 
        context.Response.Write(SomeHtmlString); 
      } 
      private void Application_EndRequest(Object source, EventArgs e) 
      { 
        HttpApplication application =      (HttpApplication)source; 
        HttpContext context = application.Context; 
        context.Response.Write(SomeHtmlString); 
      } 
      public void Dispose(){} 
    } 
</pre>
        <p>We can configure the preceding HTTP module in the <code class="literal">Web.config</code> file as follows:</p>
        <pre class="programlisting">    &lt;configuration&gt; 
      &lt;system.web&gt; 
        &lt;httpModules&gt; 
          &lt;add name=" SimpleHttpModule " type=" SimpleHttpModule "/&gt; 
        &lt;/httpModules&gt; 
      &lt;/system.web&gt; 
    &lt;/configuration&gt; 
</pre>
        <p>In the ASP.NET pipeline, a request passes through a series of HTTP modules before it hits a handler. A simple HTTP handler routine is given as follows:</p>
        <pre class="programlisting">    public class SimpleHttpHandler: IHttpHandler 
    { 
      public void ProcessRequest(System.Web.HttpContext context){ 
        context.Response.Write("The page request -&gt;" +          
        context.Request.RawUrl.ToString()); 
      } 
      public bool IsReusable 
      { 
        get{ return true; } 
      } 
    } 
</pre>
        <p>We can configure the handler as given next. Whenever we create an ASP.NET resource with the <code class="literal">.smp</code> extension, the handler will be <code class="literal">SimpleHttpHandler</code>:</p>
        <pre class="programlisting">    &lt;system.web&gt; 
      &lt;httpHandlers&gt; 
        &lt;add verb="*" path="*.smp" type="SimpleHttpHandler"/&gt; 
      &lt;/httpHandlers&gt; 
    &lt;/system.web&gt; 
</pre>
        <p>The preceding technique of leveraging the chain of responsibility pattern is available in other web technologies such as Java Servlets (called Servlet filters) and also available in IIS as ISAPI filters.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Bridge pattern in the .NET RCW">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec53"></a>Bridge pattern in the .NET RCW</h1>
            </div>
          </div>
        </div>
        <p>The <span class="strong"><strong>Component Object Model</strong></span> (<span class="strong"><strong>COM</strong></span>) technology solutions packaged as libraries can be consumed through <span class="strong"><strong>Runtime Callable Wrapper</strong></span> (<span class="strong"><strong>RCW</strong></span>), available in the .NET platform. By allowing managed classes and COM components to interact, despite their interface disparity, RCWs are an example of bridge pattern (implemented as an adapter!). Please consult the documentation on <span class="strong"><strong>Com Callable Wrapper</strong></span> (<span class="strong"><strong>CCW</strong></span>) and RCW to understand how the bridge pattern is implemented to interoperate with components written in other languages (mostly C++/ATL). Technically speaking, even ADO.NET API also leverages the bridge pattern, to interact with ODBC and other native drivers implemented by respective database vendors.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Factory pattern in the .NET BCL">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec54"></a>Factory pattern in the .NET BCL</h1>
            </div>
          </div>
        </div>
        <p>The factory design pattern has been used by <code class="literal">System.Data.Common</code> to create an instance of the provider, connection, command, or adapter objects in order to fetch data from a relational database. The following code snippets demonstrates the idea:</p>
        <pre class="programlisting">    DbProviderFactory factory = 
    DbProviderFactories.GetFactory(providerName); 
    DbConnection connection = factory.CreateConnection(); 
    connection.ConnectionString = connectionString; 
    string queryString = "SELECT CategoryName FROM Categories"; 
    DbCommand command = factory.CreateCommand(); 
    command.CommandText = queryString; 
    command.Connection = connection; 
    DbDataAdapter adapter = factory.CreateDataAdapter(); 
    adapter.SelectCommand = command; 
    DataTable table = new DataTable(); 
    adapter.Fill(table); 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Observer pattern in the WPF">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec55"></a>Observer pattern in the WPF</h1>
            </div>
          </div>
        </div>
        <p>The <code class="literal">ObservableCollection</code> can be considered as a data structure,&#160;which leverages the observer pattern to provide notifications when items get added or removed, or when the whole list is refreshed:</p>
        <pre class="programlisting">    class ObservableDataSource  
    { 
      public ObservableCollection&lt;string&gt; data  
      { get; set; } 
 
      public ObservableDataSource() 
      { 
        data = new ObservableCollection&lt;string&gt;(); 
        data.CollectionChanged += OnCollectionChanged; 
      } 
      void OnCollectionChanged(object sender,  
      NotifyCollectionChangedEventArgs args)  
      { 
        Console.WriteLine("The Data got changed -&gt;" +  
        args.NewItems[0]); 
      } 
      public void TearDown() 
      { 
        data.CollectionChanged -= OnCollectionChanged; 
      } 
    } 
</pre>
        <p>The following code snippet creates an instance of an&#160;<code class="literal">Observableconnection</code>&#160;based <code class="literal">ObservableDataSource</code> class. When we add items to the class, we get a notification in the <code class="literal">OnCollectionDataChanged</code> method of the <code class="literal">ObservableDataSource</code> class:</p>
        <pre class="programlisting">    ObservableDataSource obs = new ObservableDataSource(); 
    obs.data.Add("Hello"); 
    obs.data.Add("World"); 
    obs.data.Add("Save"); 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Composite pattern in the .NET Framework">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec56"></a>Composite pattern in the .NET Framework</h1>
            </div>
          </div>
        </div>
        <p>To create complex UI screens, the .NET Framework leverages composite patterns extensively. The WPF, ASP.NET Web Forms, and Winforms are some of the key examples in this regard. In a UI scenario, one can have a frame class, which acts as a container for all the child controls. Typically, developers place panels to divide the physical screen to some kind of logical grouping and child controls are placed inside these panels. The controls like list, grid can embed other controls. Thus, these are wonderful examples of the composite pattern.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Facade pattern in the .NET BCL">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec57"></a>Facade pattern in the .NET BCL</h1>
            </div>
          </div>
        </div>
        <p>The GoF facade pattern is used in scenarios where a lot of work happens in the background and the interfaces to those classes are exposed using a simple API. The <code class="literal">XMLSeralizer</code> class in the .NET BCL does quite a bit of its work behind the scenes and access to those routines are given using a very simple interface. The following code snippets create a <code class="literal">DataSet</code> to store a multiplication table for the number <code class="literal">42</code> (remember Douglas Adams!) and the <code class="literal">XMLSeralizer</code> class persists the table to a text file:</p>
        <pre class="programlisting">    class Program 
    { 
      private static DataSet CreateMultTable() 
      { 
        DataSet ds = new DataSet("CustomDataSet"); 
        DataTable tbl = new DataTable("Multiplicationtable"); 
        DataColumn column_1 = new DataColumn("Multiplicand"); 
        DataColumn column_2 = new DataColumn("Multiplier"); 
        DataColumn column_3 = new DataColumn("REsult"); 
        tbl.Columns.Add(column_1); 
        tbl.Columns.Add(column_2); 
        tbl.Columns.Add(column_3); 
 
        ds.Tables.Add(tbl); 
        int Multiplicand = 42; 
        DataRow r; 
        for (int i = 0; i &lt; 10; i++) 
        { 
          r = tbl.NewRow(); 
          r[0] = Multiplicand; 
          r[1] = i; 
          r[2] = Multiplicand * i; 
          tbl.Rows.Add(r); 
        } 
        return ds; 
      } 
      // The Entrypoint for execution 
      // using Serialize method, we can traverse the tree  
      // and persist the content to a XML file. Behind the scenes 
      // the code to traverse the DataSet structure is getting  
      // executed. Using FAÇADE pattern, the .NET framekwork 
      // designers have managed to hide the complexity  
 
      static void Main(string[] args) 
      { 
        XmlSerializer ser = new XmlSerializer(typeof(DataSet)); 
        DataSet ds = CreateMultTable(); 
        TextWriter writer = new StreamWriter("mult.xml"); 
        ser.Serialize(writer, ds); 
        writer.Close(); 
        Console.ReadKey(); 
      } 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Iterator pattern in the .NET BCL">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec58"></a>Iterator pattern in the .NET BCL</h1>
            </div>
          </div>
        </div>
        <p>The iterator pattern is so common that most platforms and frameworks provide a mechanism to support it. The .NET BCL has got <code class="literal">IEnumerable</code> and its generic variant , that is, <code class="literal">IEnumerable&lt;T&gt;</code> to implement custom iterators. To iterate, we have got the <code class="literal">foreach</code> loop construct in C#. Similar constructs are available in Java as well. The following program creates a custom list by leveraging the .NET fixed length array facility:</p>
        <pre class="programlisting">    public class CustomList&lt;T&gt; : IEnumerable&lt;T&gt; 
    { 
      //------ A Fixed Length array to  
      //------ Example very simple 
      T[] _Items = new T[100]; 
      int next_Index = 0; 
 
      public CustomList(){} 
 
      public void Add(T val) 
      { 
        // We are adding value without robust 
        // error checking 
        _Items[next_Index++] = val; 
      } 
 
      public IEnumerator&lt;T&gt; GetEnumerator() 
      { 
        foreach (T t in _Items) 
        { 
          //---only reference objects can be populated  
          //-- and checked for null 
          if (t == null) { break; } 
          yield return t; 
        } 
      } 
 
      System.Collections.IEnumerator  
      System.Collections.IEnumerable.GetEnumerator() 
      { 
        return this.GetEnumerator(); 
      }   
    } 
    // The Entry point function  
    // creates a Custom List instance and adds entry to the list 
    // and uses foreach loop to access the iterator implemented 
    class Program 
    { 
      static void Main(string[] args) 
      { 
        CustomList&lt;string&gt; lst = new CustomList&lt;string&gt;(); 
        lst.Add("first"); 
        lst.Add("second"); 
        lst.Add("third"); 
        lst.Add("fourth"); 
 
        foreach (string s in lst) 
        { 
          Console.WriteLine(s); 
        } 
        Console.ReadKey(); 
      } 
    } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch07lvl1sec59"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we learned how the designers of the .NET BCL leverage design patterns to expose a well-defined programming model and a flexible API for the same. You learned about how some important patterns are put to use by the designers of the .NET Framework. In the next chapter, you will learn about concurrent and parallel programming in the .NET platform.</p>
      </div>
    </div>
</body>
</html>