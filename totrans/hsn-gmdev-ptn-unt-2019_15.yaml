- en: Visitor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者
- en: I have to admit that I find the Visitor pattern confusing and strange. I wrestled
    with the concepts behind this pattern for a while before grasping its design,
    mostly because I seldom use it, and I mostly read about it from academic sources.
    But I began to appreciate this pattern when I started to visualize objects not
    just as chunks of data stored in the heap, but as a structure that can be visited
    and acted upon by another object. So, this means that it's possible to perform
    specific operations on elements of an object's structure without modifying it.
    This approach can be useful when you need to implement a system that needs to
    traverse a hierarchical structure and execute specific operations on individual
    nodes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，我发现访问者模式很令人困惑，也很奇怪。我在理解这个模式背后的概念上挣扎了一段时间，主要是因为我很少使用它，而且我主要从学术来源阅读关于它的内容。但是，当我开始将对象不仅视为存储在堆中的数据块，而且视为可以被另一个对象访问和操作的结构时，我开始欣赏这个模式。这意味着可以在不修改对象结构的情况下对对象结构的元素执行特定操作。这种方法在需要实现需要遍历层次结构并对单个节点执行特定操作的系统时非常有用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basic principles behind the Visitor pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式背后的基本原理
- en: Implementing a simulation of a one-armed factory robot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个单臂工厂机器人的模拟
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands-on. You will need to have a basic understanding of Unity
    and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的。你需要对Unity和C#有基本的了解。
- en: 'We will be using the following Unity engine and C# language concept:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Unity引擎和C#语言概念：
- en: Interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: If you are unfamiliar with this concept, please review it before starting this
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个概念不熟悉，请在开始本章之前复习它。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2OsR6d6](http://bit.ly/2OsR6d6)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2OsR6d6](http://bit.ly/2OsR6d6)'
- en: An overview of the Visitor pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者模式概述
- en: The primary purpose of the Visitor pattern is simple once you grasp it; a *Visitable*
    object permits a Visitor object to operate on a specific element of its structure.
    This allows the visited object to receive new functionality from visitors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了它，访问者模式的主要目的就很简单；一个**可访问**对象允许访问者对象对其结构中的特定元素进行操作。这允许被访问的对象从访问者那里接收新的功能。
- en: This description might seem very abstract at first, but it's easier to visualize
    if you imagine an object as a data structure, instead of a closed-off container
    of data and logic. With this in mind, you can see that there's a broader array
    of possibilities in the way of manipulation objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种描述一开始可能看起来非常抽象，但如果你想象一个对象是一个数据结构，而不是一个封闭的数据和逻辑容器，那么它就更容易可视化。有了这个想法，你可以看到在操作对象的方式上有更广泛的可能性。
- en: 'In the following diagram, we can visualize those principals:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以可视化这些原则：
- en: '![](img/5b278a21-5e74-4ca7-8fe9-66f68e73b167.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b278a21-5e74-4ca7-8fe9-66f68e73b167.png)'
- en: 'There are two key participants in this pattern:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式中有两个关键参与者：
- en: The **Visitor** is the interface for concrete visitors
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者**是具体访问者的接口'
- en: The **Visitable** is the interface for objects that are accepting visitors
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问**是接受访问者的对象的接口'
- en: Benefits and drawbacks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'The Visitor pattern is not as popular as the singleton pattern or the dependency
    injection pattern, so there''s less controversy surrounding its benefits and drawbacks,
    which are listed as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式不像单例模式或依赖注入模式那样流行，因此围绕其优点和缺点的争议较少，如下列所示：
- en: 'The following are the benefits:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些优点：
- en: '**Separation of data and logic**: The Visitor pattern offers a way to decouple
    an object''s data structures from its behaviors. This approach makes it easier
    to extend object capabilities by just adding more visitors.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据与逻辑分离**：访问者模式提供了一种将对象的数据结构与其行为解耦的方法。这种方法通过仅添加更多访问者来扩展对象功能变得更容易。'
- en: '**Double dispatch**: The Visitor pattern offers the ability to choose which
    method to use at runtime, depending on a given argument''s type, thereby making
    the code more dynamic.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双重分派**：访问者模式提供了在运行时根据给定参数的类型选择使用哪个方法的能力，从而使代码更加动态。'
- en: 'The following are the drawbacks:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些缺点：
- en: '**Code complexity**: The most obvious drawback of the Visitor pattern is that
    it makes code more obscure. A programmer that''s not versed in the intricacies
    of the Visitor pattern might easily get lost.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码复杂性**：访问者模式最明显的缺点是它使代码更加晦涩。一个不熟悉访问者模式复杂性的程序员可能会很容易迷失方向。'
- en: '**Inflexibility**: The Visitor pattern is not an easy pattern to use, and demands
    consistency in its implementation. It can also be hard to remove once integrated
    into a code base, so it can be a long-term commitment.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不灵活性**：访问者模式不是一个容易使用的模式，并且在其实现中需要一致性。一旦集成到代码库中，它也可能很难移除，因此这可能是一个长期承诺。'
- en: Use case example
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: We will make our use case simple, so we don't get lost in layers of abstraction
    while we try to grasp the intricacies of the Visitor pattern. Imagine that we
    are working on a project in which we need to design an interactive simulation
    of a robot with a mechanical arm.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使我们的用例简单，这样我们在尝试掌握访问者模式的复杂性时不会迷失在抽象层中。想象一下，我们正在做一个项目，需要设计一个机械臂的交互式机器人模拟。
- en: The robot is very modular, and primarily built out of various components. So,
    we want our code to reflect this by making it possible for us to attach individual
    components to our skeleton robot object dynamically. To achieve this, we are going
    to use the Visitor pattern, because it offers us a way to dynamically add elements
    to an object's structure without modifying it directly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人非常模块化，主要由各种组件组成。因此，我们希望我们的代码能够反映这一点，使我们能够动态地将单个组件附加到我们的骨架机器人对象上。为了实现这一点，我们将使用访问者模式，因为它为我们提供了一种在不直接修改对象结构的情况下动态向对象结构添加元素的方法。
- en: Code example
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Now, it''s time to implement our one-armed robot, by attaching to it all the
    components it needs to operate while not modifying its basic structure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现我们的单臂机器人了，通过附加它操作所需的所有组件，而不修改其基本结构：
- en: 'Let''s start by implementing the Visitor interface, in which we declare those
    robot parts we are going to operate on with our Visitors:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先实现访问者接口，在其中我们声明我们将要操作的那些机器人部件：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To help us out with our understanding of this pattern, let''s implement two
    concrete Visitor patterns as follows; the first visits all our robot parts and
    turns them on, while the other one shuts them off:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助我们理解这个模式，让我们实现两个具体的访问者模式，如下所示；第一个访问所有我们的机器人部件并将它们打开，而另一个则关闭它们：
- en: '`RobotPartActivateVisitor`:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RobotPartActivateVisitor`：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`RobotPartShutdownVisitor`:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RobotPartShutdownVisitor`：'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, it's quite straightforward at this point; we have a `Visit()`
    function for each robot part. This approach permits us to operate on them individually.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，到目前为止这相当直接；我们为每个机器人部件都有一个`Visit()`函数。这种方法允许我们单独操作它们。
- en: 'Now that we have our Visitors ready, it''s time for us to implement our Visitables.
    Let''s start by writing our `Visitable` interface:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了访问者，是时候实现我们的可访问者了。让我们先编写我们的`Visitable`接口：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now implement our concrete Visitables:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现我们的具体可访问者：
- en: '`Battery`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Battery`：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ThermalImager`:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThermalImager`：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`MechanicalArm`:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MechanicalArm`：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how we are referencing the Visitor interface inside the `Accept()` function.
    This piece of code is what makes it possible for our Visitors to operate on our
    Visitables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在`Accept()`函数中如何引用访问者接口。这段代码使得我们的访问者能够操作我们的可访问者。
- en: 'It''s time for us to build our `Robot`, attaching all its core parts by referencing
    them in its constructor:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候构建我们的`Robot`了，通过在其构造函数中引用它们来附加所有核心部件：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we have our `Client` class, which acts as a proof of concept by actually
    triggering our Visitors to operate on our robot''s parts:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有我们的`Client`类，它通过实际触发访问者操作我们的机器人部件来充当一个概念验证：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, we have implemented a simple, but flexible, use case of the Visitor pattern.
    The point to bear in mind is that any Visitor can operate on a Visitable object
    if it has implemented the `Accept()` function. This mechanism allows various operations
    to be performed on a Visitable object without directly modifying it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经实现了一个简单但灵活的访问者模式用例。需要注意的是，任何实现了`Accept()`函数的访问者都可以操作可访问对象。这种机制允许在不对对象直接修改的情况下对可访问对象执行各种操作。
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we reviewed the Visitor, probably one of the most advanced
    patterns in this book, because it demands that we approach object-oriented programming
    from a different perspective and start viewing objects as structures instead of
    abstract entities that exist on the heap. We can now use what we have learned
    and extend the Visitor pattern to implement systems that need to operate on complex
    hierarchical data structures, such as XML files or directory trees.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了访问者模式，这可能是本书中最高级的模式之一，因为它要求我们从不同的角度来处理面向对象编程，并开始将对象视为结构，而不是存在于堆上的抽象实体。现在我们可以运用所学知识，扩展访问者模式以实现需要操作复杂层次数据结构的系统，例如XML文件或目录树。
- en: In the next chapter, we are going to review a handy, but straightforward, pattern
    that's often over-used in Unity, the Façade pattern.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾一个实用但简单的模式，这个模式在Unity中经常被过度使用，即外观模式（Façade pattern）。
- en: Practical exercise
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践练习
- en: As a practical exercise, I would recommend studying an advanced use of the Visitor
    pattern. A perfect example of this is the application of the Visitor pattern to
    navigate and process an **Abstract Syntax Tree** (**AST**). These types of implementations
    can showcase the architectural possibilities that the Visitor pattern offers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项实际练习，我建议研究一下访问者模式（Visitor pattern）的高级用法。一个完美的例子是将访问者模式应用于导航和处理**抽象语法树**（Abstract
    Syntax Tree，**AST**）。这类实现可以展示访问者模式提供的架构可能性。
- en: For information on ASTs, please review the *Further reading* section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于AST的信息，请参阅*进一步阅读*部分。
- en: Further reading
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Dive Into Design Patterns,* by Alexander Shvets'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《深入设计模式》，作者：亚历山大·舒韦茨（Alexander Shvets）*'
- en: '[https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://refactoring.guru/design-patterns/book](https://refactoring.guru/design-patterns/book)'
- en: '*Abstract syntax tree*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象语法树*'
- en: '[https://en.wikipedia.org/wiki/Abstract_syntax_tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Abstract_syntax_tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)'
