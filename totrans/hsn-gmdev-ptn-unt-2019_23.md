# 依赖注入

当我作为一名网页开发者工作时，我第一次接触到了 **依赖注入**（**DI**）模式，并且我已经使用了多年。然而，我注意到 DI 在游戏行业中并不为人所知。我怀疑这是因为这是一个为了解决面向业务应用程序的设计问题而开发的模式，而不是用于高性能软件，如视频游戏。

正如其名称所暗示的，DI 是关于注入依赖项的；一开始可能听起来有些抽象，但它是一个相当简单的概念。类通常需要其他类的实例来完成特定的功能。因此，而不是让类自己初始化其依赖项，我们通过其构造函数或其函数中的一个参数来注入它们。这种方法解耦了类之间的显式关系，并使得测试我们的代码变得更容易，因为我们可以轻松地注入模拟对象来执行单元测试。

正如你在本书中将会看到的，DI 有其局限性，并且它不一定与 Unity 的编程环境兼容。当你开始引入更高级的 DI 版本，即 **控制反转**（**IoC**）容器时，这一点将变得特别明显。

本章将涵盖以下主题：

+   我们将回顾 DI 模式的 fundamentals

+   我们将探讨 IoC 容器背后的核心概念以及它们与 DI 的关系

+   我们将解决由允许自定义赛车游戏中的超级摩托车初始配置的功能实现引起的依赖项问题

# 技术要求

下一章是实践性的；你需要对 Unity 和 C# 有基本的了解。

我们将使用以下特定的 Unity 引擎和 C# 语言概念：

+   接口

+   构造函数

如果你对这些概念不熟悉，请在继续之前先复习它们。

本章的代码文件可以在 GitHub 上找到：

[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)

查看以下视频以查看代码的实际应用：

[http://bit.ly/2Oww7WM](http://bit.ly/2Oww7WM)

# 依赖注入概述

正如其名称所暗示的，DI 模式的核心目的是将依赖项注入需要它们的类中。使用 DI 实现这一点有三种方法，如下所示：

+   **构造函数注入**：我们通过类的构造函数注入依赖项。

+   **设置器注入**：我们通过类的函数参数注入依赖项。

+   **接口注入**：依赖项的接口提供了一个注入方法，将依赖项传递给客户端。

在本章中，我们只将回顾构造函数和设置器技术，因为它们是最常见的。

依赖通常是提供特定服务的类，其他类可以利用这些服务来完成特定功能。一个经典的例子是负责建立数据库连接以执行查询的管理器类。为了履行这一职责，数据库管理器依赖于特定数据库类型的接口类。

为了避免数据库管理器每次需要连接到特定类型的数据库时都检索和初始化特定的依赖项，我们可以在需要时提供它们。换句话说，我们正在解耦依赖与其依赖项之间的关系。

UML 图并不是描述 DI 模式目的的最佳工具，但让我们回顾一个简化的图，概述我们将要实现作为用例的内容：

![图片](img/a8371126-f7a1-436c-a544-971e5cbe2c5a.png)

上一个图中展示的案例与我们所讨论的数据库管理器示例类似。我们有一个名为 `Bike` 的类，它需要一个引擎才能正常运行。我们不是让 `Bike` 类根据特定条件初始化特定类型的引擎，而是在其构造函数中接受 `IEngine` 类型的参数。采用这种方法，`Bike` 可以接收任何实现了 `IEngine` 的具体类，例如在这个例子中，是 `JetEngine` 和 `NitroEngine`。

这种安排为我们提供了大量的可扩展性；我们可以编写几十种不同类型的引擎，每种都有其特定的功能，而 `Bike` 能够接受它们，而无需对其当前结构进行任何修改。

当然，DI 并非没有缺点，你将在下一节中看到。

DI 遵循 IoC 的核心原则，即反转系统的控制流。在 DI 的情况下，这是关于反转依赖管理的过程。遵循 IoC 原则的另一个模式是服务定位器，你可以在第 16 章[服务定位器](56a2aeed-924d-4d95-b44b-b10ac7595d4a.xhtml)中查阅。

# 优点和缺点

与单例模式一样，DI 模式也有些争议，其实际的优缺点经常受到争议。我怀疑这是因为其设计简单，程序员往往对看起来过于简单的东西持谨慎态度，因为通常太好了而不可能是真的。

优点如下：

+   **松散耦合**：让类接收依赖实例而不是显式初始化它们，可以减少代码库中的紧密耦合。

+   **可测试的代码**：DI 通过允许注入模拟对象来运行特定场景，使得运行测试变得更加容易。

+   **并发开发**：DI 提供了一种解耦对象并强制通过接口进行通信的方法。这种方法使得程序员团队编写相互利用的类变得更加容易。

缺点如下：

+   **争议**：DI是一种在团队中引起很多争论的模式，因为最佳方法并不总是清晰的，尤其是在考虑更高级的DI形式，如IoC注入容器时。

+   **框架依赖**：DI的基本形式非常有限；一旦达到一定程度的复杂性，就必需实现第三方IoC框架以可配置的方式管理依赖注入。因此，代码库通常变得依赖于框架，并且难以轻易移除。

+   **意大利面代码**：过度使用依赖注入（DI）和相关最佳实践可能导致代码库过度封装，并拆分成过多的单个类，这使得理解起来变得困难。

为了测试应聘者对技术主题的辩论能力，面试官通常会要求应聘者对一个有争议的模式，如DI和Singleton，提出自己的看法。作为一个面试者，展示对任何问题的平衡观点，考虑到其优点和缺点，是一种良好的做法。

# 用例示例

假设我们正在开发一个设定在未来的赛车游戏，其中有超级摩托车。我们必须快速实现一个功能，玩家可以在比赛开始前从可用选项中选择引擎和驾驶员来自定义他们的自行车。换句话说，我们的自行车对象有两个特定的依赖项：一个引擎和一个驾驶员。使用DI模式，我们将管理这些依赖项，而不会给我们的代码库增加不必要的复杂性。

首先，我们将查看在类中管理依赖关系的错误方法，以便您能够理解与相反方法相比DI的优点。

# 没有DI的错误方法

在进入我们用例的实现阶段之前，让我们首先回顾一个使用考虑不周的初始化和管理依赖关系的类的示例：

[PRE0]

初看，这似乎是一种合理的做法，但让我们想象一下，我们正在一个游戏程序员团队中工作，每个人都在实现新的引擎行为类型。如果我们想让`Bike`类支持这些行为，我们需要修改`EngineType`枚举，并更新`SetEngine()`方法体内的`switch`案例。如果多个程序员同时在这个类上工作，这种方法可能会随着时间的推移变得非常麻烦。

我们在`SetDriver()`函数上也遇到了同样的问题；在这种安排下，添加新的驾驶员类型将变得很麻烦，并且可能会容易出错。所以，让我们通过逐步使用DI作为基础来实现相同的类。

# 使用DI的正确方法

DI的实现相当直接，这也是它的主要优点。因此，本节应该不会令人痛苦：

1.  让我们从编写我们的 `Bike` 类开始；我们可以说它是这个依赖注入（DI）模式示例中的实际客户端，主要是因为它是那个在注入过程中依赖接收依赖项的类：

[PRE1]

正如你所见，`SetEngine()` 和 `SetDriver()` 函数并不知道它们接收到的具体是哪种引擎或驱动器——它们只知道它们期望的是它们的通用类型。换句话说，`Bike` 类不再负责其依赖项的初始化过程。这种方法非常灵活；我们可以编写无限数量的引擎类，每个类都有其特定的行为，如果我们保持与 `IEngine` 接口实现合同的兼容性，我们就不需要直接修改 `Bike` 类以使其适合使用新的引擎。

你还会注意到这种方法同样适用于 `driver` 依赖项。`Bike` 不需要知道是谁在驾驶；它只需要知道控制该实体的实体实现了 `IDriver` 接口，这样它们就可以相互通信。

为了测试目的，这种灵活性很有帮助；我们可以在运行时轻松注入模拟的 `engine` 或 `driver` 对象，并在 `Bike` 实现上运行一些自动化的单元测试。

1.  现在，让我们编写我们两种主要依赖类型的接口：引擎和驱动器：

+   `IEngine` 接口如下所示：

[PRE2]

+   `IDriver` 接口如下所示：

[PRE3]

1.  在接下来的步骤中，我们将为我们的自行车需要正确运行的每种主要类型的组件编写所有具体的类：

+   `JetEngine` 类如下所示：

[PRE4]

+   `NitroEngine` 类如下所示：

[PRE5]

需要注意的是，每个引擎都封装了其内部机制，同时保持与 `IEngine` 接口实现的兼容性。正是这种一致的方法允许了依赖注入（DI）。

+   `HumanDriver` 类如下所示：

[PRE6]

+   `AndroidDriver` 类如下所示：

[PRE7]

`HumanDriver` 类旨在将 `Bike` 的控制权交给玩家，我们将在即将到来的 `Client` 类中实现这一点。`AndroidDriver` 类旨在支持一个能够驾驶 `Bike` 并在比赛中作为玩家对手的 AI 实体。

1.  最后，我们的 `Client` 类，我们将用它来测试我们的系统，如下所示：

[PRE8]

我们的 `Client` 类相当简单；在 `Awake()` 函数中，我们将依赖项注入到两个 `Bike` 类的实例中：`m_PlayerBike` 和 `m_AndroidBike`。在 `Update()` 函数中，我们监听玩家的输入，允许他们控制 `m_PlayerBike` 实例。

这可能看起来非常直接且过于简单，但如果我们适度使用，这种模式提供了很多可扩展性和灵活性，同时复杂性很小。在下一节中，我们将回顾依赖注入（DI）的更高级形式，它使用 IoC 容器。

你可能已经注意到，我们没有在我们的代码示例中使用构造函数注入；这是因为我们正在使用一个 `MonoBehaviour` 类，我们没有访问其构造函数的权限。一些 Unity 开发者确实使用 `Awake()` 函数在初始化过程中注入依赖项。

# 使用 IoC 容器进行 DI

IoC 容器通常以框架的形式出现；它们的主要职责是自动化 DI 流程和管理依赖项的生命周期。在我们开始之前，重要的是要注意，大多数 IoC 容器并不是为了与 Unity 的编码模型兼容而设计的，我不建议使用它们。另一方面，了解它们的存在也很重要。

如我们本章开头所述，依赖注入（DI）是一种便捷且直接的模式，但它有其局限性。在我们刚刚实现的代码示例中，我们同时管理了两个依赖项的注入，但想象一下，如果我们有数十个依赖项分布在多个类中会怎样。在这种类型的背景下，DI 可能会成为你架构中的瓶颈。这时，IoC 容器就变得很有用，因为它们可以自动化管理所有这些注入的过程。

以下是对大多数 IoC 容器提供的功能的简要总结：

+   **注册**：容器提供了一种注册依赖项并将它们正确映射到依赖项的方法。

+   **解析**：容器负责通过初始化和注入来解析依赖项。

+   **释放资源**：容器将管理对象的生命周期，包括在它们不再需要时释放它们。

这份对 IoC 容器的快速回顾的目的不是争论它们是否必要，而是让我们意识到简单的 DI 模式有其局限性。一旦我们在注入的依赖项的复杂性和密度达到一定程度，我们就需要考虑实现或集成一个 IoC 容器框架来管理这个过程。

总是小心不要让你的代码库依赖于第三方框架；你可能会发现自己陷入了供应商锁定反模式，我将在本书的最后一章中更详细地描述它。

# 概述

在本章中，我们回顾了 DI 模式，这是一个随着时间的推移而越来越受欢迎的简单模式。它的名声可以通过这样一个事实来解释，即它解决了每个程序员每天都会面临的常见挑战，即管理类之间的依赖关系。换句话说，只要你不过度使用，它就是你的工具箱中的一个强大工具。

在下一章中，我们将探讨对象池模式，这是移动游戏程序员非常喜欢的另一个实用工具。

# 实践练习

作为一项实际练习，我建议使用一个流行的IoC容器框架编写一个C#应用程序。因为大多数框架与Unity引擎不兼容，我建议使用原生方式，在Visual Studio中编写一个简单的Windows应用程序。

在 *进一步阅读* 部分，我添加了一个流行的IoC容器框架列表。

# 进一步阅读

以下是一些可能用作参考的书籍：

+   *《.NET中的依赖注入》* by Mark Seemann: [https://www.manning.com/books/dependency-injection-in-dot-net](https://www.manning.com/books/dependency-injection-in-dot-net)

+   *《依赖注入原理、实践和模式》* by Steven van Deursen 和 Mark Seemann: [https://www.manning.com/books/dependency-injection-principles-practices-patterns](https://www.manning.com/books/dependency-injection-principles-practices-patterns)

以下是一些可以考虑的IoC框架：

+   Ninject:[http://www.ninject.org](http://www.ninject.org)

+   Castle Windsor:[https://github.com/castleproject/Windsor](https://github.com/castleproject/Windsor)
