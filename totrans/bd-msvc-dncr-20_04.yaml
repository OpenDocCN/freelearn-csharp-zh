- en: Testing Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quality assurance, or testing, is a great way to assess a system, program,
    or an application with different aspects. Sometimes, a system requires testing
    to identify erroneous code, on other occasions we may need it to assess our system''s
    business compliance. Testing can vary from system to system and can be considerably
    different depending on the architectural style of the application. Everything
    depends on how we are strategizing our testing approach or plan. For example,
    testing a monolith .NET application is different to testing SOA or microservices.
    In this chapter, we will cover these topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: How to test microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling challenges
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing pyramid
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of microservice tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test microservices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing microservices can be a challenging job, as it is different from how
    we test applications built using the traditional architectural style. Testing
    a .NET monolithic application is a bit easier than testing a microservice, which
    provides implementation independence and short delivery cycles.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand it in the context of our .NET monolithic application, where
    we did not utilize continuous integration and deployment. It becomes more complex
    when testing is combined with continuous integration and deployment. For microservices,
    we are required to understand the tests for every service and how these tests
    differ from each other. Also, note that automated testing does not mean that we
    will not perform any manual testing at all.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things that make microservice testing a complex and challenging
    task:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Microservices might have multiple services that work together or individually
    for an enterprise system, so they can be complex.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices are meant to target multiple clients; hence, they involve more
    complex use cases.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component/service of the microservice architectural style is isolated and
    independent, so it is a bit complex to test them as they need to be tested individually
    and as a complete system.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be independent teams working on separate components/services that
    might be required to interact with each other. Therefore, tests should cover not
    only internal services but also external services. This makes the job of testing
    microservices more challenging and complex.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component/service in a microservice is designed to work independently,
    but they might have to access common/shared data where each service is responsible
    for modifying its own database. So, testing microservices is going to be more
    complex as services need to access data using API calls to other services, which
    further adds dependencies to other services. This type of testing will have to
    be handled using mock tests.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling challenges
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed how testing a microservice is a complex
    and challenging job. In this section, we will discuss some points that will indicate
    how conducting various tests could help us overcome these challenges:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A unit test framework, such as Microsoft Unit Testing Framework, provides a
    facility to test individual operations of independent components. To ensure that
    all the tests pass and that a new functionality or change does not break anything
    (if any functionality breaks down, then the related unit test would fail), these
    tests can be run on every compilation of code.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试框架，如Microsoft单元测试框架，提供了一种测试独立组件单个操作的功能。为了确保所有测试都通过，并且新的功能或更改不会破坏任何东西（如果任何功能出现故障，相关的单元测试将失败），这些测试可以在每次代码编译时运行。
- en: To make sure that responses are consistent with the expectations of the clients
    or consumers, consumer-driven contract testing can be used.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保响应与客户端或消费者的期望一致，可以使用消费者驱动的合同测试。
- en: Services use data from an external party or from other services, and they can
    be tested by setting up the endpoint of the services that are responsible for
    handling the data. Then we can use a mocking framework or library such as `moq` to
    mock these endpoints during the integration process.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务使用来自外部方或其他服务的数据，并且可以通过设置负责处理数据的服务的端点来对这些服务进行测试。然后我们可以使用模拟框架或库，如`moq`，在集成过程中模拟这些端点。
- en: Testing strategies (testing approach)
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试策略（测试方法）
- en: As mentioned in the *Prerequisites* section of *Chapter 1, An Introduction to
    Microservices*, deployment and QA requirements can become more demanding. The
    only way to effectively handle this scenario would be through preemptive planning.
    I have always favored the inclusion of the QA team during the early requirement
    gathering and design phase. In the case of microservices, it becomes a necessity
    to have a close collaboration between the architecture group and the QA group.
    Not only will the QA team's input be helpful, but they will be able to draw up
    a strategy to test the microservices effectively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章“微服务简介”的“先决条件”部分所述，部署和QA要求可能会变得更加严格。有效处理这种情况的唯一方法是通过预先规划。我一直倾向于在早期需求收集和设计阶段就包括QA团队。在微服务的情况下，架构组和QA组之间的紧密合作变得必要。不仅QA团队的输入会有所帮助，他们还能够制定出一种有效测试微服务的策略。
- en: Test strategies are merely a map or outlined plan that describes the complete
    approach of testing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试策略仅仅是描述测试完整方法的地图或概述计划。
- en: Different systems require different testing approaches. It is not possible to
    implement a pure testing approach to a system that is developed using a newer
    approach rather than the earlier developed system. Testing strategies should be
    clear to everyone so that the created tests can help non-technical members of
    the team (such as stakeholders) understand how the system is working. Such tests
    can be automated, simply testing the business flow, or they could be manual tests,
    which can be simply performed by a user working on the User Acceptance Testing system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的系统需要不同的测试方法。对于使用较新方法而非早期开发系统开发的系统，无法实施纯测试方法。测试策略应该对每个人都很清晰，以便创建的测试可以帮助团队的非技术成员（如利益相关者）了解系统是如何工作的。这些测试可以是自动化的，简单地测试业务流程，或者它们可以是手动测试，由在用户验收测试系统上工作的用户简单地执行。
- en: 'Testing strategies or approaches have the following techniques:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试策略或方法具有以下技术：
- en: 'Proactive: This is a kind of early approach and tries to fix defects before
    the build is created from the initial test designs'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积极的：这是一种早期方法，试图在从初始测试设计创建构建之前修复缺陷
- en: 'Reactive: In this approach, testing is started once coding is completed'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应的：在这种方法中，一旦编码完成，就开始测试
- en: Testing pyramid
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: 'The testing pyramid is a strategy or a way to define what you should test in
    microservices. In other words, we can say it helps us define the testing scope
    of microservices. The concept of the testing pyramid was originated by Mike Cohn ([http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid](http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid))
    in 2009\. There are various flavors of the testing pyramid; different authors
    have described this by indicating how they had placed or prioritized their testing
    scope. The following image depicts the same concept that was defined by Mike Cohn:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7179b98-8b5e-4876-b699-9b7481169763.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: The** Testing pyramid** showcases how a well-designed test strategy is structured.
    When we look closely at it, we can easily see how we should follow the testing
    approach for microservices (note that the testing pyramid is not specific to microservices).
    Let's start from the bottom of this pyramid. We can see that the testing scope
    is limited to the use of **Unit tests**. As soon as we move to the top, our testing
    scope is expanded into a broader scope where we can perform complete system testing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s talk about these layers in detail (bottom-to-top approach):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These are tests that test small functionalities of an application
    based on the microservice architectural style'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service tests**: These are tests that test an independent service or a service
    that communicates with another/external service'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System tests**: These are tests that help in testing an entire system with
    an aspect of the user interface. These are end-to-end tests'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One interesting point in this concept is that the top-layered tests, that is,
    system tests, are slow and expensive to write and maintain. On the other hand,
    the bottom-layered tests, that is, unit tests, are comparatively fast and less
    expensive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will discuss these tests in detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Types of microservice tests
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed test approaches or testing strategies.
    These strategies decide how we will proceed with the testing of the system. In
    this section, we will discuss various types of microservice testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit tests are tests that typically test a single function call to ensure that
    the smallest piece of the program is tested. So these tests are meant to verify
    specific functionality without considering other components:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Testing will be more complex when components are broken down into small, independent
    pieces that are supposed to be tested independently. Here, testing strategies
    come in handy and ensure that the best quality assurance of a system will be performed.
    It adds more power when it comes with the **Test-Driven Development** (**TDD**)
    approach. We will discuss this with the help of an example in *Unit tests* which
    is a sub-section of *Tests in Action*.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn and practice TDD with the help of Katas at [https://github.com/garora/TDD-Katas](https://github.com/garora/TDD-Katas)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests can be of any size; there is no definite size for a unit test. Generally,
    these tests are written at the class level.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller unit tests are good for testing every possible functionality of a complex
    system.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component (service) testing
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Component or service testing is a method where we bypass the UI and directly
    test the API (in our case, the ASP.NET Core Web API). Using this test, we confirm
    that an individual service does not have any code bugs and that it is working
    fine functionality-wise.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing a service does not mean it is an independent service. This service
    might be interacting with an external service. In such a scenario, we should not
    call the actual service but use the mock and stub approach. The reason for this
    is our motto: to test code and make sure it is bug-free. In our case, we will
    use the `moq` framework for mocking our services.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things worth noting for component or service testing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: As we need to verify the functionality of the services, these kinds of tests
    should be small and fast
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of mocking, we don't need to deal with the actual database; therefore,
    test execution time is less or nominally higher
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of these tests is broader than unit tests
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In unit testing, we test a single unit of code. In component or service testing,
    we test mock services depending on an external or third-party component. But integration
    testing in microservices can be a bit challenging, as in this type of testing
    we test components that work together. Service calls here should be made that
    integrate with external services. In this test strategy, we make sure that the
    system is working together correctly and the behavior of services is as expected.
    In our case, we have various microservices and some of them depend upon external
    services.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: For example, StockService depends upon OrderService in a way that a particular
    number of items is reduced from the stock as soon as the customer successfully
    orders that specific item. In this scenario, when we test StockService, we should
    mock OrderService. Our motto should be to test StockService and not communicate
    with OrderService. We do not test the database of any service directly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Contract testing
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contract testing is an approach where each service call independently verifies
    the response. If any service is dependent then dependencies are stubbed. This
    way, the service functions without interacting with any other service. This is
    an integration test that allows us to check the contract of external services.
    Here we come to a concept called the consumer-driven contract (we will discuss
    this in detail in the following section).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: For example, CustomerService allows new customers to register with the FlixOne
    Store. We do not store new customers' data in our database. We verify customer
    data before this to check for blacklisting or fraud user listing and so on. This
    process calls an external service that is maintained by another team or entirely
    by a third-party. Out tests will still pass if someone changes the contract of
    this external service because this change would not affect our test, as we stubbed
    the contract of this external service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Consumer-driven contracts
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservices, we have several services that are independent or services
    that require communication with each other. Apart from this, from a user's (here,
    the user is a developer, who is consuming the API being referred to) point of
    view, they know about the service and whether it has, or doesn't have, several
    clients/consumers/users. These clients can have the same or different needs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Consumer-driven contracts refer to a pattern that specifies and verifies all
    the interactions between clients/consumers and the API owner (application). So
    here, consumer-driven means that the client/consumer specifies what kind of interactions
    it is asking for with the defined format. On the other hand, the API owner (application
    services) must then agree to these contracts and ensure that they are not breaking
    them:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfe6dbe5-454f-4ff7-ac5c-f5157537d6b9.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'These are the contracts:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Provider contract: This is merely a complete description of the service provided
    by the API owner (application). Swagger's documentation can be used for our REST
    API (web API).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumer contract: This is a description of how consumers/clients are going
    to utilize the provider contract.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumer-driven contract: This is a description of how the API owner satisfies
    consumer/client contracts.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a consumer-driven test
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of microservices, it's a bit more challenging to implement a consumer-driven
    test than for a .NET monolithic application. This is because, in monolithic applications,
    we can directly use any unit test framework, such as MS tests or NUnit, but we
    can't do this directly in the microservice architecture. In microservices, we
    would need to mock not only method calls but also the services themselves, which
    get called via either HTTP or HTTPs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: To implement a consumer-driven test, there are tools available that will help.
    One famous open source tool for a .NET framework is *PactNe*t ([https://github.com/SEEK-Jobs/pact-net](https://github.com/SEEK-Jobs/pact-net))
    and another for .NET Core is *Pact.Net Core* ([https://github.com/garora/pact-net-core](https://github.com/garora/pact-net-core)).
    These are based on *Pact* ([https://docs.pact.io/](https://docs.pact.io/)) standards.
    We will see consumer-driven contract testing in action at the end of this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: How Pact-net-core helps us achieve our goal
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a consumer-driven test, our goal is to make sure that we are able to test
    all the services, internal components, and services that depend on or communicate
    with other/external services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者驱动的测试中，我们的目标是确保我们能够测试所有服务、内部组件以及依赖于或与其它/外部服务通信的服务。
- en: 'Pact-net-core is written in a way that guarantees the contracts would be met.
    Here are a few points on how it helps us to achieve our goal:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Pact-net-core是以一种保证合约能够得到满足的方式编写的。以下是一些关于它是如何帮助我们实现目标的要点：
- en: The execution is very fast
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行速度非常快
- en: It helps identify failure causes
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于识别故障原因
- en: The main thing is that Pact does not require a separate environment to manage
    automation test integration
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，Pact不需要单独的环境来管理自动化测试集成
- en: 'There are two steps for working with Pact:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pact有两个步骤：
- en: 'Defining expectations: In the very first step, the consumer team has to define
    the contract. In the preceding image, Pact helps record the consumer contract,
    which will be verified when replayed:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义预期：在第一步中，消费者团队必须定义合约。在前面的图像中，Pact帮助记录消费者合约，该合约将在回放时进行验证：
- en: '![](img/d0486369-1395-43de-9f84-335f3c705236.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0486369-1395-43de-9f84-335f3c705236.png)'
- en: 'Verifying expectations: As part of the next step, the contract is provided
    to the provider team and then the provider service is implemented to fulfill the
    same. In the following image, we are showing the replaying of a contract on the
    provider side to fulfill the defined contract:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证预期：作为下一步的一部分，合约被提供给提供者团队，然后提供者服务被实现以满足相同的需求。在以下图像中，我们展示了在提供者端回放合约以履行定义的合约：
- en: '![](img/59651ba9-f277-4e4d-8e13-efbbe81d90aa.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59651ba9-f277-4e4d-8e13-efbbe81d90aa.png)'
- en: We have gone through consumer-driven contracts; they mitigate the challenges
    of microservice architectures with the help of an open source tool called Pact-net.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经经历了消费者驱动的合约；它们通过开源工具Pact-net的帮助，缓解了微服务架构的挑战。
- en: Performance testing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: This is non-functional testing, and its main motto is not to verify the code
    or test the code's health. This is meant to ensure that the system is performing
    well, based on the various measures, namely scalability, reliability, and so on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非功能性测试，其主要宗旨不是验证代码或测试代码的健康状况。这是为了确保系统根据各种度量标准，如可伸缩性、可靠性等，表现良好。
- en: 'The following are the different techniques or types of performance testing:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些不同的性能测试技术或类型：
- en: 'Load testing: This is a process where we test the behavior of the system under
    various circumstances of a specific load. It also covers critical transactions,
    database load, application servers, and so on.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试：这是一个测试系统在特定负载的各种情况下的行为的过程。它还包括关键交易、数据库负载、应用服务器等。
- en: 'Stress testing: This is an approach where the system goes under regress testing
    and finds the upper limit capacity of the system. It also determines how a system
    behaves in this critical situation, when the current load goes above the expected
    maximum load.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试：这是一种方法，系统在回归测试下运行，并找到系统的上限容量。它还确定当当前负载超过预期最大负载时，系统的行为。
- en: 'Soak testing: This is also called *endurance testing*. In this test, the main
    purpose is to monitor memory utilization, memory leaks, or various factors that
    affect the system performance.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沉浸测试：这也被称为*耐久测试*。在这个测试中，主要目的是监控内存利用率、内存泄漏或影响系统性能的各种因素。
- en: 'Spike testing: This is an approach where we make sure that the system is able
    to sustain the workload. One of the best tasks to determine performance is by
    suddenly increasing the user load.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 峰值测试：这是一种确保系统能够承受工作负载的方法。确定性能的最佳任务之一是通过突然增加用户负载。
- en: End-to-end (UI/functional) testing
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端（UI/功能）测试
- en: End-to-end, UI, or functional tests are those that are performed for the entire
    system, including the entire service and database. These tests increase the scope
    of testing. It is the highest level of testing, includes frontend integration,
    and tests the system as an end user would use it. This testing is similar to how
    an end user would work on the system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端、UI或功能测试是针对整个系统进行的测试，包括整个服务和数据库。这些测试增加了测试范围。这是测试的最高级别，包括前端集成，并测试系统作为最终用户会使用的方式。这种测试类似于最终用户在系统上的操作方式。
- en: Sociable versus isolated unit tests
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交型与隔离型单元测试
- en: 'Sociable unit tests are those that contain concrete collaborators and cross
    boundaries. They are not solitary tests. Solitary tests are those that ensure
    that the methods of a class are tested. Sociable testing is not new. This word
    is explained in detail by Martin Fowler as a unit test ([https://martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html)):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Sociable tests: This is a test that lets us know the application is working
    as expected. This is the environment where other applications behave correctly,
    run smoothly, and produce the expected results. It also, somehow, tests the functioning
    of new functions/methods, including other software for the same environment. Sociable
    tests resemble system testing because these tests behave like system tests.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Isolated unit tests: As the name suggests, you can use these tests to perform
    unit testing in an isolated way by performing stubbing and mocking. We can perform
    unit testing with a concrete class using stubs.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubs and mocks
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stubs are returned, canned responses to calls made during the test; mocks are
    meant to set expectations:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Stubs: In a stubs object, we always get a valid stubbed response. The response
    doesn’t care what input you provide. In any circumstance, the output will be the
    same.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mocks: In a mock object, we can test or validate methods that can be called
    on mocked objects. This is a fake object that validates whether a unit test has
    failed or passed. In other words, we can say that mock objects are just a replica
    of our actual object. In the following code, we use the `moq` framework to implement
    a mocked object:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code example, we mocked our `IProductRepository` repository
    and verified the mocked result.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will understand these terms in more detail, using
    more code examples from our FlixOne bookstore application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Tests in action
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have discussed test strategies and various types of microservice
    tests. We''ve also discussed how to test and what to test. In this section, we
    will see tests in action; we will implement tests with the use of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 Update 3 or later
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 2.0
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# 7.0
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit and MS tests
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moq framework
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready for the test project
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will test our microservice application: FlixOne bookstore. With the help
    of code examples, we will see how to perform unit tests, stubbing, and mocking.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We created the FlixOne bookstore application in *Chapter 2, Implementing Microservices.*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing tests, we should set up a test project in our existing
    application. There are a few simple steps we can take with this test project setup:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'From Solution Explorer within Using Visual Studio, right-click on Solution
    and click New Project—refer to the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c808f29-36e5-4506-87c3-163b0c2a098b.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'From the Add New Project template select .NET Core and xUnit Test Project (.NET
    Core), and provide a meaningful name, for example, `FlixOne.BookStore.ProductService.UnitTests`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c418de5d-1b85-4093-b12b-255078d23952.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Go to project Properties, by right-clicking on the project name from Solution
    Explorer. Open the Build tab from the Properties page and click on Advance and
    select C# 7.0 as Language version:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75e04409-c014-4cf6-8c00-3e262122578e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Our project structure should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29a503f2-4471-43c0-861c-740ffbff730d.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Unit tests
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `ProductService`, let''s make sure our service returns product data without
    failure by testing it. Here we will use fake objects to do so, follow these steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Add a new folder and name it `Fake` in the `FlixOne.BookStore.ProductService.UnitTests`
    project.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `Fake` folder add the `ProductData.cs` class and add the following
    code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code snippet, we are creating fake data by creating two lists
    of `ProductViewModel` and `Product`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Services` folder in the `FlixOne.BookStore.ProductService.UnitTests` project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `Services` folder add the `ProductTests.cs` class.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open NuGet Manager and then search for and add `moq`, refer to the following
    screenshot:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad0eb9e9-68f1-4b04-95e1-0d6e1e177710.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to the `ProductTests.cs` class:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code example, which is a unit test example, we are mocking
    our repository and testing the output of our WebAPI controller. This test is based
    on the *AAA* technique; it will be passed if you meet the mocked data during setup.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `ProductService`, let''s make sure that our service returns the product
    data without failure. Before we proceed, we have to add a new project and subsequent
    test classes, follow these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Right click on Solution and then Add Project.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Add New Project window, select XUnit Test Project (.NET Core) and
    provide a meaningful name, for example, `FlixOne.BookStore.ProductService.IntegrationTests`.
    Refer to the following screenshot:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eca9d769-bb9e-4baa-94b5-f18794704e74.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Add the `appsettings.json` file and add the following to it:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open the `Startup.cs` file of the  `FlixOne.BookStore.ProductService` project.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now make the `ConfigureServices` and `Configure` methods void. This is so we
    can override these methods in our `TestStartup.cs` class. These methods would
    look as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add a new folder called `Services`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `TestStartup.cs` class.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open NuGet Manager. Search and add the Microsoft.AspNetCore.TestHost package.
    Refer to the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ed19dbd-6924-405e-b1db-d9e816767b36.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to `TestStartup.cs`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Under the `Services` folder, add a new `ProductTest.cs` class and add the following
    code to this class:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code example, we are checking a simple test. We are trying
    to verify the response of a service by setting up a client with the use of `HttpClient`.
    The test will fail if the response goes empty.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们正在检查一个简单的测试。我们通过使用 `HttpClient` 设置客户端来验证服务的响应。如果响应为空，测试将失败。
- en: Consumer-driven contract tests
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费者驱动的合同测试
- en: In the previous section, *Contract testing*, we discussed things in detail.
    In this section, we will see how we can implement consumer-driven contract tests
    with the help of pact-net-core.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节，*合同测试*中，我们详细讨论了相关内容。在本节中，我们将了解如何借助 pact-net-core 实现消费者驱动的合同测试。
- en: We will use our existing  `FlixOne.BookStore.ProductService` project, which
    contains all our APIs. Our `FlixOne.BookStore.ProductService` project contains
    provider tests that let you create a provider scenario, and our client project
    that actually consumes the services, makes a call, and tests the contract.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用现有的 `FlixOne.BookStore.ProductService` 项目，它包含我们所有的 API。我们的 `FlixOne.BookStore.ProductService`
    项目包含提供者测试，允许你创建提供者场景，以及我们的客户端项目，它实际消费服务，发起调用并测试合同。
- en: To get started you should install the NuGet package. Execute `Install-Package
    PactNet.Windows` using the package console.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你应该安装 NuGet 包。使用包控制台执行 `Install-Package PactNet.Windows`。
- en: 'As per Pact specification (already discussed in a previous section, *Contract
    testing*), the client will create a contract called *consumer contract* (a `.json`
    file). We have written the following code to generate our contract:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Pact 规范（已在之前的章节 *合同测试* 中讨论过），客户端将创建一个名为 *消费者合同* 的合同（一个 `.json` 文件）。我们编写了以下代码来生成我们的合同：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we are building a contract. In addition to that, we
    mocked our client tests. See the following code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在构建一个合同。除此之外，我们还模拟了客户端测试。请看以下代码片段：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our code will create the consumer contract as shown in the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将创建如下所示的消费者合同：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the consumer-driven contract is created, it should adhere to a provider,
    so we need to write the APIs accordingly (we are using our existing product API).
    The following is the code snippet for a provider:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了消费者驱动的合同，它应该遵守提供者，因此我们需要相应地编写 API（我们正在使用现有的产品 API）。以下是一个提供者的代码片段：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have created a web API and a test to verify consumer-driven contracts and
    finally testing it from a client's perspective.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 Web API 和一个测试来验证消费者驱动的合同，并最终从客户端的角度进行测试。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing microservices is a bit different from applications built on the traditional
    architectural style. In a .NET monolithic application, testing is a bit easier
    compared to microservices, and it provides implementation independence and short
    delivery cycles. Microservices face challenges while performing the testing. With
    the help of the testing pyramid concept, we can strategize our testing procedures.
    Referring to the testing pyramid, we can easily see that unit tests provide the
    facility to test a small function of a class and are less time-consuming. On the
    other hand, the top layer of the testing pyramid enters a large scope with system
    or end-to-end testing, and these tests are time-consuming and very expensive.
    Consumer-driven contracts are a very useful way to test microservices. Pact-net
    is an open source tool meant for this. Finally, we went through the actual test
    implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 测试微服务与基于传统架构风格构建的应用程序略有不同。在 .NET 单体应用程序中，与微服务相比，测试要容易一些，并且它提供了实现独立性和短交付周期。微服务在测试过程中面临挑战。借助测试金字塔概念，我们可以制定我们的测试流程。根据测试金字塔，我们可以轻松地看到单元测试提供了测试类中一个小函数的便利，并且耗时较少。另一方面，测试金字塔的顶层涉及一个较大的范围，包括系统或端到端测试，这些测试耗时且成本高昂。消费者驱动的合同是测试微服务的一种非常有用的方式。Pact-net
    是为此目的而设计的开源工具。最后，我们了解了实际的测试实现。
- en: In the next chapter, we will see how to deploy a microservice application. We
    will discuss continuation integration and continuation deployment in detail.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何部署微服务应用程序。我们将详细讨论持续集成和持续部署。
