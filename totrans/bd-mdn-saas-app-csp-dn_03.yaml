- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Is Multi-Tenancy, and Why Is It Important in SaaS Applications?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-tenancy has become a critical architectural pattern in modern **Software
    as a Service** (**SaaS**) applications, enabling providers to serve multiple customers
    (tenants) from a single instance of their software.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will delve into this very important part of building SaaS applications
    –termed *multi-tenancy* – whereby multiple tenants can use the *same instance*
    of a deployed application and still keep their data private and segregated.
  prefs: []
  type: TYPE_NORMAL
- en: Under a multi-tenancy system, multiple customers of the SaaS application can
    use the same instance of the application and also optionally use the same database,
    but their data is segregated, such that no other tenant can see the data – unless
    it is explicitly shared. This obviously raises a number of concerns about security
    and data privacy. For a company building a multi-tenant SaaS application, it is
    extremely important to ensure that any given customer is only ever able to see
    their own data and never anyone else’s!
  prefs: []
  type: TYPE_NORMAL
- en: Many strategies, patterns, utilities, and technologies can be leveraged to ensure
    that an individual tenant’s data remains segregated, but the first line of defense
    is – as always –a sound technical understanding of the underlying concepts. It
    is particularly important that the development team appreciates this when the
    application is being crafted. Multi-tenancy is essential for any SaaS application
    that will scale, which almost all of them will aim to do!
  prefs: []
  type: TYPE_NORMAL
- en: The privacy and security of data in a SaaS multi-tenant application are paramount.
    It’s hard to think of any instance where a multi-tenant SaaS application is built
    that did not require at least some of the tenants’ and users’ data to remain private.
    Robust data security and segregation of data are, therefore, key considerations
    when setting out to build a SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: When starting out on the development cycle for a new application, it is considerably
    easier to build robust security into the application at the very start of the
    project than it is to retrospectively add it in later! It is also much less risky
    to get the security and segregation working correctly from the start – once the
    inevitable application sprawl and feature creep start, it is considerably harder
    to convince yourself that everything really is locked down as tightly as it should
    be.
  prefs: []
  type: TYPE_NORMAL
- en: We are covering this topic early in this book so that, as we build out our demo
    application, you will have a solid understanding of multi-tenancy and how it impacts
    future design choices. I strongly encourage you to take the same approach when
    building a SaaS application, taking the time at the start of the project to plan
    a strategy for multi-tenancy and the security considerations that will arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'During this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gaining an understanding of what multi-tenancy is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the options for data storage with multi-tenant applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the design considerations through the application layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing security considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have a good understanding of multi-tenancy,
    multi-tenant applications, and the specific security considerations that will
    arise when working on SaaS and, specifically, multi-tenant software applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-3](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-3).
  prefs: []
  type: TYPE_NORMAL
- en: What is multi-tenancy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-tenancy is a software architecture pattern commonly used in SaaS applications,
    wherein a single application instance serves multiple customer groups or organizations,
    known as tenants. Each tenant shares the same underlying infrastructure and resources,
    such as servers, databases, and application logic, but maintains its own isolated
    data and configurations. This approach allows for optimized resource usage, streamlined
    maintenance, and reduced operational costs. The primary challenge in a multi-tenant
    architecture is to ensure data isolation, security, and performance for each tenant,
    while also offering customization and scalability. In essence, multi-tenancy enables
    SaaS providers to deliver a cost-effective, secure, and customizable solution
    to a diverse range of customers, using a shared application instance.
  prefs: []
  type: TYPE_NORMAL
- en: Disambiguating customers, tenants, and users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When talking about multi-tenancy, is it important to disambiguate the related
    but distinct concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Customers**: Customers refer to the organizations or individuals who purchase
    or subscribe to a software product or service. In the context of SaaS applications,
    customers may be represented as one or more tenants, with each customer group
    having access to its own isolated environment within the shared application instance.
    The term “customer” generally emphasizes the business relationship and financial
    aspect of using a software product or service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tenants**: Tenants represent separate organizations, companies, or groups
    that use a shared instance of a SaaS application in a multi-tenant architecture.
    Each tenant has its own isolated data, configurations, and customizations while
    sharing the same software infrastructure and resources with other tenants. A key
    aspect of a multi-tenant system is that each tenant can have multiple users associated
    with it, enabling individual access and personalized experiences within the shared
    application instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Users**: Users are the individual people who interact with a software system
    or application, often with unique login credentials and personalized settings.
    Users belong to a specific tenant, organization, or group, and their actions and
    access within the system can be managed with role-based permissions or access
    control. Users represent the actual individuals using the software, carrying out
    various tasks and activities within the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s consider an example where two large companies use a SaaS application.
    The companies are customers, and to keep this example simple, each will have a
    single tenant in the application. Each company could have hundreds or thousands
    of employees who use the system. It would be typical for both companies to want
    to customize the app in some way for their own employees. For example, they may
    want to display their logo when a user logs in. This would be achieved by having
    two *tenants* in the application, each configured to show the correct logo to
    the users who belong to that company.
  prefs: []
  type: TYPE_NORMAL
- en: There will be two levels of data segregation. The individual tenant configuration
    (the logo, for example) will be separate, and any user operating within that tenant
    must always see the correct logo. There will be a further level of segregation,
    keeping each individual user’s data private.
  prefs: []
  type: TYPE_NORMAL
- en: Users with elevated permissions within a tenant (admin users) may be able to
    modify details for other users within that same tenant, but never for any other
    tenants.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very important to keep this in mind as we progress through this chapter
    – make sure that you understand the difference between users and tenants before
    moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: A customer can have one or more tenants in an application, often one, meaning
    that the terms *customer* and *tenant* can be used interchangeably
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tenant can have one or more users under it, most often more than one, meaning
    that the terms should not be used interchangeably
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the alternatives to multi-tenancy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While SaaS applications are largely synonymous with multi-tenant applications,
    it is technically possible to deliver a SaaS application as a single-tenant application.
  prefs: []
  type: TYPE_NORMAL
- en: If a single-tenant approach is followed, then every time a new tenant is onboarded,
    there is an entirely new application stack and a new database deployed for that
    specific tenant. There *could* be some very specific and limited shared services,
    such as a shared login page that redirects the customer to their own instance
    of the application, but in general, this will be a completely unique and isolated
    deployment of the software on a per-customer basis.
  prefs: []
  type: TYPE_NORMAL
- en: A single-tenant application is generally considered to be the most secure method
    and could be considered the most reliable method to deliver an application to
    a single customer. However, it is significantly most expensive to do this for
    each and every customer, and the costs to scale such an architecture quickly become
    unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: The resources required to maintain, support, upgrade, and customize such an
    application are very high, meaning that the price to the end user is also high,
    and would typically restrict your customer base to the enterprise. If your end
    goal is to attract non-enterprise customers, this single-tenant approach is very
    unlikely to be successful.
  prefs: []
  type: TYPE_NORMAL
- en: It is also somewhat stretching the definition of SaaS. If each customer simply
    gets a unique installation of the software, albeit in the cloud, then it is much
    closer to the traditional method of delivering software – on a CD with a unique
    key printed on it!
  prefs: []
  type: TYPE_NORMAL
- en: Single tenancy in a SaaS application would really only be done for a very small
    subset of use cases. For this book, we will not consider this any further, other
    than to mention that it is technically possible to build a SaaS application without
    making use of a multi-tenant architecture!
  prefs: []
  type: TYPE_NORMAL
- en: The advantages and disadvantages of multi-tenancy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the advantages of using a multi-tenant architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost**: Multi-tenancy is typically a very cost-efficient way to deliver an
    application from the point of view of provisioning resources (app servers, databases,
    and so on). Multi-tenancy also tends to be very cost-efficient when considering
    ongoing support and maintenance costs. The marginal cost for every additional
    tenant, and each additional user within that tenant, will typically not add much
    to the overall cost once the application has gone live.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiered pricing**: Customers can be offered a range of pricing options to
    suit them and their organization specifically. The pricing can scale linearly
    as new tenants are added and users are introduced from the new tenant’s organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to update**: With only one instance of the application being accessed
    by many tenants, a single update can be performed that will get every user across
    all tenants on the latest and greatest version. Note that it is also possible,
    if more complex, to configure this using **Continuous Deployment** (**CD**) **pipelines**
    under a single-tenant model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: A SaaS application using a multi-tenant architecture will
    typically scale up very easily as the number of tenants and users increases. Assuming
    that a cloud provider is used, this can happen literally effortlessly on the part
    of the development team. A cloud service can be configured so that as additional
    demand is placed on the system by the growing user base, additional resources
    are deployed automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s not all good, though – there are a few disadvantages that should also
    be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased complexity**: From a software architecture point of view, a multi-tenant
    application is almost by definition more challenging to build. There are additional
    complexities throughout the application stack, starting with the database requiring
    some form of segmentation by tenant all the way up the stack to the user interface,
    where each user must be securely authenticated and authorized to access only certain
    parts of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased security requirements**: The fact that multiple tenants share a
    single application instance necessitates a much more thorough approach to user
    security. It is typically an absolute disaster scenario for a business if one
    of their user’s private data is leaked to another user through their application,
    and doubly so if that user belonged to a different tenant organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Downtime is a disaster**: If a multi-tenant SaaS system goes down for any
    reason, then typically, every single customer will have no access to the application.
    This obviously makes reducing downtime absolutely critical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noisy neighbors**: Given that each tenant shares an application, they are,
    therefore, also sharing resources, such as the compute time of the cluster or
    the servers on which the application is deployed. One particularly compute-hungry
    user could have a knock-on effect on every other user of a system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An observation from the preceding lists is that the advantages provided are
    significant and cannot really be worked around if using a single-tenant architecture.
    However, the disadvantages of a multi-tenant system can usually be mitigated by
    simply taking more time upfront to design the system well. Of course, there is
    a cost in doing so, which must be balanced carefully when choosing the application
    architecture and making decisions about system design.
  prefs: []
  type: TYPE_NORMAL
- en: In general, though, the higher upfront cost will be returned many times over
    as the number of tenants and the user base starts to grow and the power of the
    SaaS/multi-tenant application is realized!
  prefs: []
  type: TYPE_NORMAL
- en: I hope that with the preceding discussion, I have convinced you of the benefits
    of multi-tenant architecture and encouraged you to consider this at the very start
    of your project. We can now move on to discuss the specifics of designing for
    multi-tenancy, starting with the most important – data storage!
  prefs: []
  type: TYPE_NORMAL
- en: Options for data storage with multi-tenant applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database in any application is typically the foundation upon which the rest
    of the application is built. The decisions that are taken when selecting and designing
    the database will have significant knock-on effects on the data access/API layer
    and probably some impact on the user interface as well.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the data stored in an application will represent your customers’
    business information. Often, this information will be incredibly valuable to them,
    and by entrusting it to you – as a developer working on a SaaS application – they
    are showing significant trust that you can keep this valuable asset safe. The
    database underpinning a SaaS application should be like a bank vault where your
    customers are happy to deposit their data!
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, making the correct choices in database design is extremely important
    for the rest of the application development, and also for the tenants and individual
    users of the application.
  prefs: []
  type: TYPE_NORMAL
- en: While this section is focused on the database, its role as the foundation for
    the rest of the application will necessitate some discussion about how the choices
    made will impact other layers and parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Key considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach taken for data storage is very important, with a few key areas
    to consider before you start building.
  prefs: []
  type: TYPE_NORMAL
- en: Design complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, when starting to build a new application, it is a good idea to focus
    on simplicity in design, and only add complexity when it is required. Building
    in multi-tenancy does add significant complexity to the application, so it is
    very important that the level of complexity is considered and the solution is
    sized accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Consider how many tenants you expect to have, and pick a solution that matches
    that. Consider also how important data isolation is, and pick a solution that
    matches that.
  prefs: []
  type: TYPE_NORMAL
- en: You should also keep in mind that some customers – particularly large corporate
    customers – may expect some degree of customization. Allowing per-customer customizations
    can start to exponentially increase the complexity of a design. While it is generally
    preferred to avoid any kind of customization, this may not be possible. If it
    is felt that this will be a requirement, then some consideration for this eventuality
    should be taken into account at the design stage.
  prefs: []
  type: TYPE_NORMAL
- en: Support complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the process of developing the application is, of course, costly for the
    company that is funding the undertaking, it is important to consider the ongoing
    cost of actually running the application. This is the period in the application
    life cycle where it is expected to generate revenue, and that will not be possible
    if there are huge ongoing support and maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: One very important aspect of ongoing maintenance is monitoring your tenants’
    usage. The “80–20” principle will most likely apply, and you need to know which
    of your tenants are the most profitable… and which are the most problematic!
  prefs: []
  type: TYPE_NORMAL
- en: You need to consider that some of your tenants will have higher availability
    requirements than others. Will you be able to support a tenant with a 99.99% uptime
    requirement? And do you understand the additional costs and technical trade-offs
    in offering this level of service?
  prefs: []
  type: TYPE_NORMAL
- en: Support and maintenance can quickly become a technical and financial nightmare
    if they are not considered early on in the project life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No application ever launched with a billion users – they all started with one!
  prefs: []
  type: TYPE_NORMAL
- en: When planning a SaaS application, you need to have at least some idea of the
    scale that you expect to operate at over the short, medium, and long term. With
    this understanding, you can make smart decisions that suit the individual users
    and the tenants from launch day through to platform maturity.
  prefs: []
  type: TYPE_NORMAL
- en: There is no point in wasting effort and resources to build for a billion users
    on day one. Similarly, there is no way to get to a billion users if there is no
    plan in place to adequately service that number of users.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under a multi-tenant system, many users will be sharing – and, therefore, competing
    for access to – resources. This includes users under separate tenants, who would
    typically work for different organizations.
  prefs: []
  type: TYPE_NORMAL
- en: You need to consider how a typical tenant and a typical user will use the system.
    For example, if you are building an enterprise system and focusing on a single
    time zone, you should expect to see almost all the usage during business hours.
    You will need to size your resources to meet this demand, even though they will
    be idle out of business hours.
  prefs: []
  type: TYPE_NORMAL
- en: You may face a similar problem with – for example – a streaming service that
    will spike in usage in the evening.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this scenario would offer a considerable advantage to a company offering
    its services across multiple time zones, where the usage spikes could be flattened
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users in a multi-tenant system competing for shared resources is known as the
    “noisy neighbor” problem. This phenomenon is where one tenant or user is exhibiting
    particularly heavy resource usage and, by doing so, degrades the system performance
    for its other users. This problem is inevitable to a certain extent when building
    a multi-tenant system, but there are ways it can be mitigated, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing throttling to prevent a single tenant or user from consuming a
    disproportionate amount of resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring how the tenants and users interact with the system and working around
    the more resource-intensive examples. For example, they could be moved to a separate
    cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purchasing additional cloud resources. This is something of a blunt instrument,
    but it is effective.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we h discussed previously, it is of the utmost importance that data that
    relates to one tenant is invisible to another tenant, and each of the users within
    those tenants. An individual tenant’s data must be isolated. There are a few ways
    this can be achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers can be used on a one-container-per-tenant basis. This can be a very
    effective method to compartmentalize tenants of a system, but there would be scaling
    concerns should the application turn into the next Facebook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate tables can be used per tenant in the same database. This provides a
    good degree of assurance that data cannot “leak,” but again, this would not scale
    efficiently to hundreds of tenants and millions of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tenant ID-based isolation, where data in the database is all in one table, with
    a `tenant_id` column. This scales very well but could be considered to be less
    secure than the previous options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no “one-size-fits-all” approach to this problem. The level of isolation
    required will depend on the type of customers and the type of data being stored.
    This should be carefully considered at the start of a project, as changing the
    approach to data isolation later in the project life cycle can be extremely challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we would like the most secure, performant, and easy-to-maintain application
    possible, but as application developers, we must always operate within the confines
    of the economic realities that are faced by the company building the application.
  prefs: []
  type: TYPE_NORMAL
- en: Even with matters as important as data security, there is always a cost trade-off
    to be made.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely helpful if these are understood at the start of a project so
    that there are no nasty surprises later!
  prefs: []
  type: TYPE_NORMAL
- en: A database is foundational to the rest of an application, and making the correct
    choices regarding the aforementioned considerations is extremely important. The
    choices that are made at this stage will significantly impact the rest of the
    application. We will consider this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations through the application layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The approach that will be taken to solve a multi-tenancy problem is probably
    one of the most important decisions to take in the early stages of a project.
    It can be one of the most expensive and technically challenging aspects to make
    a change to later in the project life cycle. The planning and the design of a
    solution for the multi-tenant problem must start in the very early phases and
    will influence all of the various layers in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The core reason for multi-tenancy is to segregate data that one customer stores
    such that it is not visible to a user under a different tenant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key decision to make is where the data will be segregated, and this primarily
    affects the design of the database. The decision driver for this will have to
    be related to the users of a system. To make this decision, it is vital to understand
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Who your tenants will be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How your users will use a system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the consequences of a data breach are to your customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the customers’ tolerance for risk versus cost is. Would they prefer a more
    costly but more secure solution or a cheaper solution?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the consequences of a data leak are to a business
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users of social media sites do not seem overly concerned for their privacy,
    and so will likely tolerate a less security-conscious approach to data segregation.
    Also, users of social media are often not prepared to pay anything for the system,
    so they are very price-conscious and not at all data privacy-conscious. Indeed,
    the business model of a social network is often to sell users’ data to the highest
    bidder!
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise customers will almost never tolerate a social media-esque approach
    to data and will always prefer a more secure regime. Some enterprise customers
    will not accept a multi-tenant system at all. Military or government customers,
    for example, would almost certainly consider the risks too high and would insist
    on a single-tenant solution.
  prefs: []
  type: TYPE_NORMAL
- en: If the customers of an application are likely to be primarily motivated by security,
    and in particular, rigorous data segregation and an absolute guarantee that there
    will be no slip-ups, then the best solution is to not design a multi-tenant application
    and, therefore, not build a SaaS application! Given that this book is about developing
    SaaS applications, we will discount this customer class entirely. However, it
    is important to be aware of the limitation of the technique. A customer base that
    is primarily motivated by absolute data security over all other considerations
    is very unlikely to accept an app that is delivered via SaaS. These users will
    most likely require on-premises solutions hosted inside their own network, with
    full control over the data retained by the users’ organization.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we are building for customers that we feel will buy a SaaS application,
    let’s consider those!
  prefs: []
  type: TYPE_NORMAL
- en: One database per tenant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most secure way to segregate one tenant’s data from another is to store
    the data in completely separate databases. This has a considerable overhead in
    terms of maintaining and updating the multiple databases (one per customer) that
    are required under this scheme. This approach all but guarantees there will be
    no data leaks, but the additional overheads are considerable. An application that
    uses this scheme will also present challenges in scaling, and it may lead to spiraling
    costs if there is a per-instance license for the database platform that is selected.
  prefs: []
  type: TYPE_NORMAL
- en: The issue of scaling does present a hard cap on the number of tenants that a
    system could be designed for. There is no way that Microsoft could make their
    DevOps platform work if every tenant organization had a unique and segregated
    database – there are simply too many customers for that to be feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from security, one other benefit of this scheme is that the number of
    rows of data stored in the individual database will be lower than in a shared
    database, so there may be a slight performance boost possible in the database
    layer. Note that this may be offset in the application layers.
  prefs: []
  type: TYPE_NORMAL
- en: This type of scheme would be used only if the number of customers was quite
    small and were hugely security-conscious. There would be an argument in these
    cases to build single-tenant, on-premises systems.
  prefs: []
  type: TYPE_NORMAL
- en: Shared schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the most common solution that is used for the vast majority of commonly
    used SaaS applications that you may encounter in day-to-day use. Even some potentially
    sensitive applications, such as a system that hosts financial and taxation information,
    may make use of a shared schema.
  prefs: []
  type: TYPE_NORMAL
- en: Under this regime, a single database is used, with tables containing data from
    multiple tenants. The data is protected from being shared using some form of identification
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Using this scheme significantly boosts the benefits that are derived from using
    the SaaS paradigm in the first place. These days, there are plenty of well-understood
    and well-used ways of keeping data secure under such a scheme. There may also
    be an argument to be made that having only one database and one schema to keep
    on top of actually makes it easy to secure a system.
  prefs: []
  type: TYPE_NORMAL
- en: One schema per tenant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the halfway house between the two aforementioned options. Under this
    method, a single database is used, but the same schema is deployed to the database
    multiple times, once per customer. Each schema is isolated, and there are no connections
    or relations between the individual customers’ schema.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, this is the best of both worlds, and in other ways, it’s the worst.
  prefs: []
  type: TYPE_NORMAL
- en: There is still a significant additional overhead in managing the many schemas,
    and there is still a hard cap on the number of individual tenants that this could
    be scaled up to. Particularly security-conscious customers may still be turned
    off by this, considering it too much of a risk to even share a database.
  prefs: []
  type: TYPE_NORMAL
- en: One table per tenant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is very closely related to the aforementioned *one schema per tenant* method.
    Under this paradigm, every tenant in the system has a table added to the database
    that pertains only to them.
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of the previous method also apply here.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate these points, I’ll build an example that demonstrates the two
    preceding segregations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will imagine there are four tenant organizations of the `GoodHabits` app.
    These tenants are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AscendTech, who is very security-conscious and wants a private database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluewave, who is also security-minded and also wants a private database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudSphere, who is a price-conscious customer and takes the cheaper option
    to have a shared database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataStream, who will also use the shared database and share it with CloudSphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these four example organizations, we can demonstrate how a multi-tenant
    database can work. This example will not be exhaustive but will provide a solid
    foundational understanding.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will build on the `GoodHabits` database and API project
    that we created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the required packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We only need to add one nuget package to the `HabitService` project for this
    chapter. Navigate to the project folder in a terminal, and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many of the tables in the database will require a column that identifies the
    owner of the data – the tenant! To facilitate this, we can start by creating an
    interface called `I``H``asTenant`. Create the file with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy the following code into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will recall that we previously created an entity class called `Habit` that
    defined the data structure for the database. This entity will need to have a `TenantName`
    value, so it should implement the `IHasTenant` interface. Modify the class that
    we created in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056) such that it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating the tenant configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The configuration for the tenants in a live system would typically be stored
    in a separate database somewhere – a client portal application or similar. However,
    for the purposes of this demo, we will just use the `appsettings.json` file. Add
    the following to the `appsettings.json` file in the `Goodhabits.HabitService`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration has defined four tenants:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two, AscendTech and Bluewave, want fully segregated databases and
    have had connection strings specified that are unique to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second two, CloudSphere and Datastream, do not have a unique connection
    string, so they are considered to be happy to use the shared database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `GoodHabits.Database` project, add a class that matches the structure
    of the config that we added into `appsettings.json` previously. The config will
    be loaded into this at startup. Call the class `TenantSettings`, and then paste
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating a tenant service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we will create a service that can provide details about the tenants to
    other parts of the application that may be interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start in the `GoodHabits.Database` project by adding an interface called `ITenantService`,
    and then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement this service. This is done in the HabitService project
    and should look like this. Double-check that you are adding this to the HabitService
    project and not the Database project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The primary function of the preceding code block is to intercept incoming HTTP
    requests, check that there is a tenant named in the header, and match that name
    with a known tenant.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the SeedData and AppDbContext classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will remember that in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056),
    we added some seed data. As we now require a tenant name to be present in the
    database, we will have to update the seed data. Copy in the following, or just
    add the `TenantName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `GoodHabitsDbContext` class that was created previously had a single hardcoded
    database connection string. We will replace this and make use of the multiple
    database connections that we defined in the preceding config.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `GoodHabitsDbContext` class entirely with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The main change in the preceding code is that the connection string is now read
    from the `TenantService` class that we created previously. This is far more dynamic
    and allows us to create new databases for new tenants on the fly as we build the
    app. This is also far more secure than having a connection string hardcoded in
    the source code and checked into the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Another important change to note is that we add a query filter at the context
    level. This ensures that only the correct tenant can read their data, which is
    a very important security consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have overridden the `SaveChangesAsync` method. This allows us to
    set the tenant name here and not have to consider it in any of our other implementation
    code. This cleans up the rest of our code considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a service layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have now configured the `Habit` service and the database to work in a multi-tenant
    way, enforcing the presence of a tenant ID in every request. This is a good start
    to provide good security and separation between tenants.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll demonstrate what we did by hooking up the database and the service
    and placing some test calls to the Habit service, showing how the tenancy is enforced.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by writing a service layer. Open a terminal in the `HabitService`
    folder and run the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the interface with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, populate the class with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This service is just a simple wrapper around some of the calls to the database.
    We could add a lot more functionality, but this will serve to demonstrate how
    multi-tenancy works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the service created, we’ll now add a controller that makes the data from
    the service available over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script in the `HabitService` folder to set up the required
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the code for the controller, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This controller simply gives us two endpoints to create and read a habit from
    the database, via the service layer that we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following code to the `CreateHabitDto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Adding a service extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we are potentially dealing with many instances of the database, we
    need to add the ability to create and update all of the databases when the application
    starts up. We will create an extension to the service collection to facilitate
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a class to the HabitService project called `ServiceCollectionExtensions`,
    and then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The key point to understand from the preceding code is that the database connection
    string is set on a per-tenant basis, and that the tenants’ database is updated
    per the latest migrations when that tenant logs in to the app.
  prefs: []
  type: TYPE_NORMAL
- en: This system takes much of the overhead of maintaining many databases away from
    the administrators. It is all handled automatically!
  prefs: []
  type: TYPE_NORMAL
- en: Application plumbing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we need to wire up all these new services. This is done in the `Program.cs`
    file in the `GoodHabits.HabitService` project. In this file, paste the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this code, you can see that we add the two new services that we created.
    We also make use of the service extension created previously and configure the
    Swagger endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the previous configurations in place, we can now run the application and
    see how the changes we made have affected the operation of the controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we have made some changes to the database (by adding the `TenantName`
    column to the `Habit` table), we will need to create a new migration with Entity
    Framework. Create the migration by navigating to the database project and running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Start the application with `dotnet run` and check that the API runs correctly.
  prefs: []
  type: TYPE_NORMAL
- en: You can look at the API in Swagger, but if you try to hit one of the endpoints,
    you will see an invalid tenant exception. This is expected, as we now have to
    add a header to every request to identify which tenant the request is for.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The Swagger error](img/B19343_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The Swagger error
  prefs: []
  type: TYPE_NORMAL
- en: If all has gone well, the API will start, and you can view it in Swagger to
    see the preceding available endpoints!
  prefs: []
  type: TYPE_NORMAL
- en: In order to test `HabitService`, we will use the `ThunderClient` extension that
    we installed in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056).
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ThunderClient` extension, click on `CloudSphere`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The ThunderClient request](img/B19343_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The ThunderClient request
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding is a properly configured request with the tenant added. Hitting
    **Send** will issue the response, and if everything has worked, you should see
    the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The ThunderClient response](img/B19343_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The ThunderClient response
  prefs: []
  type: TYPE_NORMAL
- en: The preceding shows that we have successfully returned the data for the `CloudSphere`
    tenant.
  prefs: []
  type: TYPE_NORMAL
- en: You should take some time now to do some more investigations with this and convince
    yourself that we have correctly limited access to data on a per-tenant basis!
  prefs: []
  type: TYPE_NORMAL
- en: That is the end of the practical part of this chapter. We’ll now move on to
    consider the security implications of what we have done.
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think that it should go without saying that multi-tenancy significantly affects
    the security landscape of a SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: There are many aspects to security, ranging from simple (or at least standard)
    considerations, such as authenticating users to the ability of the application,
    to withstanding very rare events, such as a natural disaster taking out a crucial
    data center or a vital internet backbone.
  prefs: []
  type: TYPE_NORMAL
- en: The word “security” in this context refers to the overall ability of an application
    to withstand anything that the world may throw at it – and continue to keep the
    tenants’ and users’ data correct, accessible, and private! This can include hacks,
    attacks, natural disasters, coding errors leaking data, or even regulatory issues,
    such as the **General Data Protection** **Regulation** (**GDPR**).
  prefs: []
  type: TYPE_NORMAL
- en: Potential security pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers of every type of application will face a broad range of potential
    security issues. It is an unfortunate reality of SaaS applications and, particularly,
    multi-tenant applications that the developers of such will have to consider nearly
    all possible security threats!
  prefs: []
  type: TYPE_NORMAL
- en: SaaS applications are typically layered, with at least a database, an API, and
    a user interface. Each of these layers presents an attack vector. SaaS applications
    are also often hosted on a cloud service. Hosting in the cloud is generally more
    secure than hosting on-premises, but there are a number of additional attack vectors
    that must be considered. Most importantly, the user accounts of the administrators
    can be compromised and the admin pages accessed remotely. This is generally less
    of a concern with on-prem solutions, which may have no remote access at all.
  prefs: []
  type: TYPE_NORMAL
- en: This section will list some of the security considerations that you will have
    to take into account as a developer of SaaS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Resource access management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, and most obviously, access to the resources in a system must be limited
    to only those with permission to see those resources.
  prefs: []
  type: TYPE_NORMAL
- en: For example, and rather obviously, data pertaining to one tenant should never
    be visible to a user on another tenant, unless there is a case where data is deliberately
    shared. When developing a SaaS application, it’s important to understand that
    an attacker will target the user interface, the API, and also the database in
    an effort to gain access to the data.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker will also attempt to intercept data when it is “in flight.” When
    data moves from the database to the API, or from the API to the user interface,
    it is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: As well as individual user data, it is likely that there will be sections of
    an application that are only accessible by users in a certain *role*, such as
    administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Any SaaS system that fails to control resource access will very quickly be compromised,
    and an application with a reputation for losing customers’ data will quickly cease
    to attract customers. Failures in this area can be catastrophic to an application
    and, indeed, a company’s reputation.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important consideration in a SaaS application, particularly a
    multi-tenant application where tenants will share access to certain resources
    (such as the database), and access to these resources must be managed very carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Data leaks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the aforementioned, data leaks can prove very costly in terms of
    reputation, and they can also have hugely significant financial implications for
    the business that owns the application!
  prefs: []
  type: TYPE_NORMAL
- en: 'While a data leak is, in some ways, a failure of resource access, it is normally
    a more general problem. Some examples to consider are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user interface that transmits credit card details from the client to the server
    in plain text, allowing a **man-in-the-middle** (**MitM**) attack that gathers
    the credit card information from all users. As stated previously, data “in flight”
    tends to be vulnerable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API endpoint that misses the authentication attribute, thus rendering it
    accessible by anyone, whether they are authenticated or not. Similarly, an API
    endpoint may have an incorrect authentication attribute. This is extremely important,
    and measures should be put in place to automatically test that the API is appropriately
    secured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database with poor security that allows an attacker to access, download, or
    delete the data in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server or a VM that has been improperly configured and can be accessed remotely
    by a malicious user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poor password hygiene that allows attackers to *guess* the passwords of users,
    either by brute force, rainbow tables, or similar *blunt-force* attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very often these days, data breaches can come with a very large financial penalty
    for a company that has operated an insecure application. In 2018, the **British
    Airways** (**BA**) website leaked the credit card data of 380,000 customers –
    one of whom would go on to write this book! The financial cost to BA was £183
    million ($244 million at the time of writing the book). It would have been considerably
    cheaper for BA to hire a team of developers and security specialists to secure
    its website in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: There is an additional consideration when building a SaaS application, in particular
    an application with a multi-tenant database. A large risk vector for these types
    of applications in terms of data leaks is that one tenant’s data will accidentally
    be revealed to a user belonging to a different tenant when those two tenants share
    a storage resource, an app server, a database, or similar. As discussed in this
    chapter, a rigorous approach to designing a multi-tenant solution when the app
    is in the concept stage is needed!
  prefs: []
  type: TYPE_NORMAL
- en: Data corruptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The various users and tenants in a multi-tenant application are separated from
    each other in one of the ways described previously, but the reality is that they
    are often sharing some (or many) of the same resources. They may be sharing a
    database, an app server, a user authentication system, and so on. Should one of
    these systems be corrupted by one user, there may be some contagion, and the corruption
    may spread and subsequently impact another user. This is rare in the modern era
    where cloud resources are typically used, and the big cloud providers should have
    a handle on these types of issues.
  prefs: []
  type: TYPE_NORMAL
- en: The primary mitigation for this is to be very careful when segregating individual
    tenant’s concerns and to use a reputable cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying that you should back up your data regularly and also
    check that an application can be recovered from said backups!
  prefs: []
  type: TYPE_NORMAL
- en: Hacks and attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While some of the aforementioned data leaks could be classed as hacks or attacks,
    a data leak is typically more *passive* – like a pipe that is leaking water. A
    hack is more active – like a pipe that someone has hit with an axe!
  prefs: []
  type: TYPE_NORMAL
- en: There is a huge range of attacks that the operators of SaaS applications may
    face, but deep-diving security concerns are out of the scope of this chapter and,
    indeed, this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is worth considering the possibility of a co-tenant attack, as they
    are specific to a multi-tenant application. While an external attacker will typically
    have some access to the application, assuming that, as a minimum, the login page
    is available over the public internet, a fully paid-up user will by definition
    have more access to more parts of the system; therefore, they will be in a better
    position to mount an attack. This attack could be against the infrastructure or
    other users.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SaaS applications add a degree of complexity, and with this complexity will
    come a certain amount of configuration overhead.
  prefs: []
  type: TYPE_NORMAL
- en: A configuration error could, for example, accidentally leak a production password
    or access to a database or other resource.
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy to overlook configuration parameters, but this can be a costly
    mistake. Everything should be stored in as secure a way as possible, making use
    of key vaults and secret managers as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Care should also be taken when it comes to checking configuration files in the
    source code repository, as this is unfortunately a common way to leak passwords
    and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every SaaS application will have some form of data stored, and that data presents
    an attack vector that can be utilized to compromise the application.
  prefs: []
  type: TYPE_NORMAL
- en: Data retention and deletion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the aforementioned, a SaaS application will retain sensitive data.
    It is vitally important that this is secured. Another key consideration with data
    retention is that in many jurisdictions, individuals have the “right to be forgotten,”
    where all of the data relating to that individual must be anonymized.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be very challenging in the context of a SaaS application for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The database will typically be multi-tenant. How easy is it to completely wipe
    out all of the information relating to one tenant without orphaning other records?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging will most likely be performed across all layers – user interface, API,
    and database. How sure can you be that there is no sensitive customer data in
    those logs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backups are obviously a very important part of the security of a system, but
    should you have to do a restoration at any point, how can you be sure that previously
    deleted data has not now been restored?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the aforementioned require a meticulous approach to data retention and
    deletion in order to guarantee your customers that their data is secure.
  prefs: []
  type: TYPE_NORMAL
- en: Regulations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A huge part of data security when building a modern SaaS application is to understand
    the regulatory frameworks that you must comply with. The internet offers a truly
    global reach for your application, but that global reach means that you may have
    to consider a huge array of regulatory frameworks, of which the consequences for
    breaching are often astronomically high fines and penalties.
  prefs: []
  type: TYPE_NORMAL
- en: The European Union’s GDPR law stipulates rules for how organizations must use
    personal data, and the penalties for breaching these regulations can be incredibly
    harsh – 10 million euros, or 2% of a firm’s entire annual global turnover. These
    kinds of laws are becoming increasingly common in many jurisdictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key questions to ask yourself in this regard are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What jurisdictions govern the data that will be stored in this application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do your applications adhere to these requirements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the partners and third parties that you are working with adhere to these
    regulations?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good security practices for multi-tenant applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I hope that the preceding set of potential horror stories hasn’t put you off!
    In this section, I’ll list some of the mitigations that should be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Governance, risk, and compliance (GRC) protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GRC is a set of processes and procedures that a business will put in place
    for many reasons, such as for meeting objectives, maintaining regulatory compliance,
    or adequately securing a SaaS application! These could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Procedures that detail how an application upgrade should be performed and a
    list of pre-release checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedures that manage and control access to your customers’ private data or
    IPs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrictions on which members of staff have access to production databases.
    Note that, ideally, no one should!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation of assets and resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As much as is practically possible, resources should be isolated from each other.
    Obviously, the app layer will need some access to the database; otherwise, how
    will it access data? However, it is good practice to run the database and the
    application on different servers or VMs. Note that isolation can bring in performance
    issues if not done correctly – this is a delicate balance!
  prefs: []
  type: TYPE_NORMAL
- en: With multi-tenant applications, individual users’ and tenants’ data should also
    be isolated as much as possible from other users and tenants. Ideally, all user
    data should be encrypted such that only the owner of the data can make sense of
    it. In this way, even if a data leak does occur, it’s not possible to infer anything
    of value from the data leak.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is good practice for all applications, not just SaaS/multi-tenant. Independent
    third parties should be consulted to audit the security and compliance of all
    IT systems and also your tenants’ data.
  prefs: []
  type: TYPE_NORMAL
- en: As well as checking that data is physically secure, auditors should also confirm
    that industry standards are being followed and that any regulatory frameworks
    are adhered to.
  prefs: []
  type: TYPE_NORMAL
- en: Using Data Loss Prevention (DLP) software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many commercial DLP solutions available. It is worth considering delegating
    this complex and extremely important to a specialist provider.
  prefs: []
  type: TYPE_NORMAL
- en: Managing access carefully
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A SaaS/multi-tenant application is particularly susceptible to security issues
    arising from improperly allocated access to a resource. This is true from a company
    point of view – developers should not have access to production databases. This
    is also true from a user point of view.
  prefs: []
  type: TYPE_NORMAL
- en: User access should be managed based on identities (who are the individual users?)
    and also through roles (what types of user classes do the individuals fall into?).
  prefs: []
  type: TYPE_NORMAL
- en: Being very careful with collaborative tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, a SaaS application will allow users to choose to share certain resources
    with other selected users within the same tenant, and less commonly with users
    in a different tenant. This can be an incredibly effective addition to a SaaS
    app and is indeed a massive advantage to using a multi-tenant solution. However,
    this introduces a security risk whereby the application itself can programmatically
    leak data. Significant additional care should be taken when building collaborative
    elements in a SaaS app, as these will be the first place a bad actor will look
    to exploit access to another user’s data.
  prefs: []
  type: TYPE_NORMAL
- en: Good security is hard in any application, and doubly so when dealing with multi-tenant
    applications. As ever, it is much easier to start a project with good practices
    in place than it is to add them later!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can see, multi-tenancy is a large and complex topic but one that is absolutely
    core to understanding when building a SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: The decisions that are made on how a database is segregated will have the largest
    impact on the rest of an application, but it is very important to consider how
    the presence of multiple tenants will affect the API and the user interface layers
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-tenancy introduces considerable additional security considerations. These
    should be thought of upfront and kept in mind throughout the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Having said this, the additional challenges of implementing a multi-tenant solution
    provide *massive* potential upsides! The reach of an application can be truly
    global, and the scalability is unmatched by any other paradigm. Consider the biggest
    tech companies in the world – Google, Meta, Netflix, and so on. Every one of these
    companies has embraced the idea of SaaS and multi-tenancy, and they have done
    so for a good reason!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build on what we have learned about multi-tenancy
    and learn about how to build databases and plan for data-rich applications.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Single Tenant vs Multi Tenant: SaaS Architecture:[https://www.clickittech.com/aws/single-tenant-multi-tenant/](https://www.clickittech.com/aws/single-tenant-multi-tenant/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multi-tenancy strategies: [https://www.linkedin.com/pulse/effective-multi-tenancy-strategies-saas-applications-kulkarni/](https://www.linkedin.com/pulse/effective-multi-tenancy-strategies-saas-applications-kulkarni/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strategies to build a scalable multi-tenant SaaS solution: [https://aws.amazon.com/blogs/apn/in-depth-strategies-for-building-a-scalable-multi-tenant-saas-solution-with-amazon-redshift/](https://aws.amazon.com/blogs/apn/in-depth-strategies-for-building-a-scalable-multi-tenant-saas-solution-with-amazon-redshift/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing multi-tenancy SaaS apps: [https://developers.redhat.com/articles/2022/05/09/approaches-implementing-multi-tenancy-saas-applications](https://developers.redhat.com/articles/2022/05/09/approaches-implementing-multi-tenancy-saas-applications)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A definition of multi-tenancy: [https://www.techtarget.com/whatis/definition/multi-tenancy](https://www.techtarget.com/whatis/definition/multi-tenancy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How multi-tenancy affects embedded analysis: [https://yurbi.com/blog/what-is-multi-tenancy-security-and-how-does-it-impact-embedded-analytics/](https://yurbi.com/blog/what-is-multi-tenancy-security-and-how-does-it-impact-embedded-analytics/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DLP definition: [https://digitalguardian.com/blog/what-data-loss-prevention-dlp-definition-data-loss-prevention](https://digitalguardian.com/blog/what-data-loss-prevention-dlp-definition-data-loss-prevention)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
