- en: Securing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is one of the most important cross-cutting concerns for web applications.
    Unfortunately, data breaches of well-known sites seem commonplace these days.
    Taking this into account, information and application security has become critical
    to web applications. For the same reason, secure applications should no longer
    be an afterthought. Security is everyone's responsibility in an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic applications have less surface area when compared to microservices,
    however, microservices are distributed systems by nature. Also, in principle,
    microservices are isolated from each other; hence, well-implemented microservices
    are more secure as compared to monolithic applications. A monolith has different
    attack vectors compared to microservices. The microservice architecture style
    forces us to think differently in the context of security. However, let me tell
    you upfront, microservice security is a complex domain to understand and implement.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive deep into microservice security, let's understand our approach
    toward it. We will be focusing more on how authentication and authorization (collectively
    referred to as **auth** in the chapter henceforth) work and the options available
    within the .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore Azure API management and its suitability as an API gateway
    for .NET-based microservice environments; we''ll also see how Azure API management
    can help us protect microservices through its security features. Then, we''ll
    briefly touch base with different, peripheral aspects that have *defense in depth* mechanisms
    for microservice security. We will also discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why are form authentication and older techniques not sufficient?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and the available options, including OpenID and Azure Active
    Directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing OAuth 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Azure API management as an API gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure API management for security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interservice communication security approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container security and other peripheral security aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security in monolithic applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand microservice security, let's step back and recall how we used
    to secure .NET monolithic applications. This will help us better grasp why a microservice's
    auth mechanism needs to be different.
  prefs: []
  type: TYPE_NORMAL
- en: The critical mechanism to secure applications has always been auth. Authentication
    verifies the *identity* of a user. Authorization manages what a user can or cannot
    access, also known as *permissions*. Encryption, well, that's the mechanism that
    helps you protect data as it passes between the client and server. We're not going
    to discuss encryption too much though, just ensure the data that goes over the
    wire is encrypted everywhere. This can be achieved through the use of the HTTPS
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the flow of a typical auth mechanism in .NET
    monoliths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32f49f3e-6ee8-46b2-bab1-522df1864c8b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see that the user enters his or her username
    and password typically through a web browser. Then, this request hits some thin
    layer in a web application that is responsible for auth. This layer or component
    connects to the user credential store, typically an SQL server in the case of
    a .NET application. The auth layer verifies user-supplied credentials against
    the username and password stored in the credential store.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user credentials are verified for the session, a session cookie gets
    created in the browser. Unless the user has a valid session cookie, he cannot
    access the app. Typically, a session cookie is sent with every request. Within
    these kinds of monolithic applications, modules can freely interact with each
    other since they are in the same process and have in-memory access. This means trust
    is implicit within those application modules so they do not need separate validation
    and verification of requests while talking to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Security in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at the case of microservices. By nature, microservices are distributed
    systems. There is not a single instance of an application; rather, there are several
    distinct applications that coordinate with each other in harmony to produce the
    desired output.
  prefs: []
  type: TYPE_NORMAL
- en: Why won't a traditional .NET auth mechanism work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the possible approaches for microservice security might be this: we
    mimic the same behavior as that of the auth layer in a monolith. This could be
    depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9605f3e4-dac1-41d9-ac5a-f72ffbd955ae.png)'
  prefs: []
  type: TYPE_IMG
- en: In this approach, we distributed the auth layer and provided it to all the microservices.
    Since each one is a different application, it will need its own auth mechanism.
    This inherently means that the user credential store is also different for every
    microservice. This raises so many questions, such as how do we keep the auth in
    sync across all services? How can we validate inter-service communication, or
    do we skip it? We do not have satisfactory answers to these questions. Hence,
    this approach does not make sense and just increases complexity. With this approach,
    we cannot even be sure whether it will work in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more factor we need to take into account for modern applications.
    In the microservice world, we need to support native mobile apps and other non-standard
    form factor devices as well as IoT applications. With the significant proliferation
    of native mobile applications, the microservice architecture also needs to support
    secure communication between those clients and microservices. This is different
    from the traditional web browser-based user interface. On mobile platforms, a web
    browser is not part of any native mobile app. This means cookie-based or session-based
    authentication is not possible. So microservices need to support this kind of
    interoperability between client applications. This was never a concern for .NET
    monolithic applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of traditional authentication, the browser is responsible for sending
    the cookie upon each request. But we're not using the browser for a native mobile
    app. In fact, we're neither using ASPX pages, nor the form's authentication module.
    For an iOS client or Android, it's something different altogether. What's more,
    we are also trying to restrict unauthorized access to our API. In the preceding
    example, we'd be securing the client, be it an MVC app or a Windows phone app,
    and not the microservice. Moreover, all these mobile client devices are not part
    of the trust subsystem. For every request, we cannot trust that the mobile user
    is indeed the owner; the communication channel is not secured either. So any request
    coming from them cannot be trusted at all.
  prefs: []
  type: TYPE_NORMAL
- en: But apart from these problems, there's another more conceptual problem we have.
    Why should the application be responsible for authenticating users and authorization?
    Shouldn't this be separated out?
  prefs: []
  type: TYPE_NORMAL
- en: One more solution to this is using the SAML protocol, but again, this is based
    on SOAP and XML, so not really a good fit for microservices. The complexity of
    the implementation of SAML is also high.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is evident from the preceding discussion that we need a token-based
    solution. The solution for microservices' auth comes in the form of OpenID Connect
    and OAuth 2.0\. OpenID Connect is the standard for authentication and OAuth 2.0
    is the specification for the authorization. However, this authorization is delegated
    by nature.
  prefs: []
  type: TYPE_NORMAL
- en: We will see this in detail in further sections. But before that, let's take
    a detour and look at JSON Web Tokens and see why they are significant with respect
    to microservice security.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON Web Tokens** (**JWT**) is pronounced *JOT*. It is a well-defined JSON
    schema or format to describe the tokens involved in a data exchange process. JWTs
    are described in *RFC 7519*.'
  prefs: []
  type: TYPE_NORMAL
- en: JWTs are not tied to either OpenID Connect or OAuth 2.0\. This means they can
    be used independently, irrespective of OAuth 2.0 or OpenID Connect. OpenID Connect
    mandates the use of a JWT for all the tokens that are exchanged in the process.
    In OAuth 2.0, the use of JWTs isn't mandated, more a kind of implementation format.
    Moreover, the .NET framework has built-in support for JWT.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a JWT-based security token is to produce a data structure that
    contains information about the issuer and the recipient along with a description
    of the sender's identity. Therefore, tokens should be protected over the wire
    so they cannot be tampered with. To do so, tokens are signed with symmetric or
    asymmetric keys. This means when a receiver trusts the issuer of the token, it
    can also trust the information inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the encoded form of a JWT. If we see the same token in decoded form,
    it has three components: header, payload, and signature; they are all separated
    by a period (.). The preceding example token can be decoded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'NET v.4.5.1 and onward has built-in support for generating and consuming JWTs.
    You can install JWT support in any .NET application using the package manager
    console with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Visit [https://jwt.io/](https://jwt.io/), where you can view and decode JWTs
    very easily. Moreover, you can add it as part of the Chrome debugger as well,
    which is quite handy.
  prefs: []
  type: TYPE_NORMAL
- en: What is OAuth 2.0?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, you might not know what OAuth 2.0 is, but you will have surely used it
    for several websites. Nowadays, many websites allow you to log in with your username
    and password for Facebook, Twitter, or Google accounts. Go to your favorite website,
    for example, the [www.stackoverflow.com](http://www.stackoverflow.com) login page.
    There is a login button that says you can sign in with your Google account, for
    example. When you click on the Google button, it takes you to Google's login page
    along with some of the permissions mentioned. Here you provide your Google username
    and password and click on the Allow button to grant permissions to your favorite
    site. Then, Google redirects you to Stack Overflow and you are logged in with
    appropriate permissions in Stack Overflow. This is merely the end user experience
    for OAuth 2.0 and OpenID Connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth 2.0 can be best described as a series of specification-turned-authorization
    frameworks. *RFC 6749* defines OAuth as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The OAuth 2.0 authorization framework enables a third-party application to
    obtain limited access to an HTTP service, either on behalf of a resource owner
    by orchestrating an approval interaction between the resource owner and the HTTP
    service, or by allowing the third-party application to obtain access on its own
    behalf."'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 handles authorization on the web, in native mobile applications, and
    all headless server applications (these are nothing more than microservice instances
    in our context). You must be wondering why we are discussing authorization first
    instead of authentication. The reason is that OAuth 2.0 is a delegated authorization
    framework. This means, to complete the authorization flow, it relies on an authentication
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see some terminology associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth 2.0 roles describe the involved parties in the authorization process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource: The entity that is getting protected from unintended access and usage.
    This is nothing more than a microservice in our case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource owner: Resource owner is a person or entity who owns the specified
    resource. When a person owns a resource, he or she is an end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client: Client is the term used to refer to all kinds of client applications.
    This refers to any application trying to access the protected resource. In a microservices''
    context, the applications involved are single page applications, web user interface
    clients, and native mobile applications, or even a microservice that is trying
    to access another microservice downstream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authorization server: This is the server that hosts the secure token service
    and issues tokens to the client after successfully authenticating the resource
    owner and obtaining permissions from the resource owner or on their behalf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that OAuth does differentiate between end users and applications
    used by an end user. This is a bit odd but makes perfect sense since it is also
    generally viewed as saying, *I am authorizing this app to perform these actions
    on my behalf*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts how these roles interact with each other in the
    general flow of authorization in the OAuth framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58404a3-3107-4236-ba49-b9e8dda72c70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In *step 6*, illustrated in the preceding diagram, the client passes the authorization
    grant to the authorization server. This step is not as simple as it looks. Authorization
    grants are of different types. The grant types represent four, different possible
    use cases for getting access tokens in OAuth 2.0\. If you choose the wrong grant
    type, you might be compromising security:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authorization code: This is the typical OAuth grant used by server-side web
    applications, the one you would use in your ASP.NET apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implicit: Authenticating with a server returns an access token to the browser,
    which can then be used to access resources. This is useful for single page applications
    where communication cannot be private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource owner password credentials: This requires the user to directly enter
    their username and password in the application. It is useful when you are developing
    a first-party application to authenticate with your own servers. For example,
    a mobile app might use a resource owner grant to authenticate with your own servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client credentials: This is typically used when the client is acting on its
    own behalf (the client is also the resource owner) or is requesting access to
    protected resources based on an authorization previously arranged with the authorization
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is OpenID Connect?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. OpenID
    Connect is all about authentication. It allows clients to verify end users based
    on the authentication performed by an authorization server. It is also used to
    obtain basic profile information about the end user in an interoperable and REST-like
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: So OpenID Connect allows clients of all types—web-based, mobile, and JavaScript—to
    request and receive information about authenticated sessions and end users. We
    know that OAuth 2.0 defines access tokens. Well, OpenID Connect defines a standardized
    identity token (commonly referred to as **ID token**). The identity token is sent
    to the application so the application can validate who the user is. It defines
    an endpoint to get identity information for that user, such as their name or email
    address. That's the user info endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: It's built on top of OAuth 2.0, so the flows are the same. It can be used with
    the authorization code grant and implicit grant. It's not possible with the client
    credentials grant, as the client credentials grant is for server-to-server communication.
  prefs: []
  type: TYPE_NORMAL
- en: There's no end user involved in the process so there's no end user identity
    either. Likewise, it doesn't make sense for the resource owner path of usage or
    process. Now how does that work? Well, instead of only requesting an access token,
    we'll request an additional ID token from the **security token service** (**STS**) that
    implements the OpenID Connect specification. The client receives an ID token,
    and usually, also an access token. To get more information for the authenticated
    user, the client can then send a request to the user info endpoint with the access
    token; this user info endpoint will then return the claims about the new user.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID supports authorization code flow and implicit flow. It also adds some
    more additional protocols, which are discovery and dynamic registration.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Active Directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple providers for OAuth 2.0 and OpenID Connect 1.0 specifications.
    **Azure Active Directory** (**Azure AD**) is one of them. Azure AD provides organizations
    with enterprise-grade identity management for cloud applications. Azure AD integration
    will give your users a streamlined sign-in experience, and it will help your application
    conform to the IT policy. Azure AD provides advanced security features, such as
    multifactor authentication, and scales really well with application growth. It
    is used in all Microsoft Azure Cloud products, including Office 365, and processes
    more than a billion sign-ins per day.
  prefs: []
  type: TYPE_NORMAL
- en: One more interesting aspect of traditional .NET environments is that they can
    integrate their organizational Windows Server Active Directory with Azure AD really
    well. This can be done with the Azure AD sync tool or the new capability of pass-through
    authentication. So, organizational IT compliances will still be managed.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice Auth example with OpenID Connect, OAuth 2.0, and Azure AD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are well-equipped with all the prerequisite knowledge to start coding.
    Let's try and build a `ToDoList` application. We are going to secure `TodoListService`,
    which represents one of our microservices. In the solution, the `ToDoList` microservice
    is represented by the `TodoListService` project and `ToDoListWebApp` represents
    the server-side web application. It will be easier to follow if you open up the
    Visual Studio solution named `OpenIdOAuthAzureAD.sln` provided with this chapter.
    This example uses the client credentials grant.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, due to the ever-changing nature of Azure portal and the corresponding
    Azure services UI, it is advisable that you use the Azure Service management API
    and automate some of the registration tasks about to follow. However, for learning
    purposes and largely for encouraging developers who are new to Azure or might
    be trying Azure AD for the first time, we are going to follow the Azure portal
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 Update 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure subscription (if you don't have this, you can use the free trial account
    for this demo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure AD tenant (single-tenant): You can also work with your Azure account''s
    own default directory, which should be different from that of the Microsoft organization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registration of TodoListService and TodoListWebApp with Azure AD tenant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at how to register `TodoListService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will add `TodoListService` with Azure AD tenant. To achieve
    this, log in to the Azure management portal, then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on App registrations. Click on the Add button. It will open the Create
    pane, as depicted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64a8579c-88d4-4915-ba87-4fa8380a541c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide all the mandatory details as displayed in the preceding screenshot
    and click on the Create button at the bottom of the Create pane. While we are
    providing a sign-on URL, make sure that you are providing it for your app. In
    our case, `TodoListService` is a microservice, so we won''t have a special sign-in
    URL. Hence, we have to provide the default URL or just the hostname of our microservice.
    Here we are going to run the service from our machine, so the localhost URL will
    be sufficient. You can find the sign-in URL once you right-click on project URL
    under `TodoListService` project and navigate to Web, as shown in the following
    diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c17fcbdb-a832-45a4-a51a-0be9d55c28c7.png)'
  prefs: []
  type: TYPE_IMG
- en: A sign-in URL in Azure portal should have the trailing `/`; otherwise, you may
    face an error, even if you execute all the steps correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If you deploy your service with the Microsoft Azure App Service plan, you will
    get a URL that is similar to `https://todolistservice-xyz.azurewebsites.net/`.
    You can later change the sign-on URL if you deploy the service on Azure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click on the Create button, Azure will add the application to your
    Azure AD Tenant. However, there are still a few more details that need to be completed
    for finishing the registration of TodoListService. So navigate to App Registration
    | TodoListService | Properties. You will notice that there are a few more additional
    properties, such as App ID URL, which has been provided now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the App ID URL, enter [`https://[Your_Tenant_Name]/TodoListService`](https://%5BYour_Tenant_Name%5D/TodoListService),
    replacing `[Your_Tenant_Name]` with the name of your Azure AD tenant. Click on
    OK to complete the registration. The final configuration should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/084b7590-c707-4eb9-a75c-898ae12cf8b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we move on to the registration of TodoListWebApp:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we register TodoListWebApp. This is necessary since we are going to use
    OpenID Connect to connect to this browser-based web application. So we need to
    establish the trust between the end user, that is, us and TodoListWebApp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on App registrations. Click on the Add button. It will open up the Create
    pane, as depicted in the following screenshot. Fill in the sign-in URL as `https://localhost:44322/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once again, as in the TodoListService  registration, we will be able to view
    most of the additional properties once we create the web app. So, the final properties
    configuration will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a21493b-5c13-4e8c-b04b-cb687e1f607b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A setting to note here is the logout URL: we set it as `https://localhost:44322/Account/EndSession`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is because after ending the session, Azure AD will redirect the user to
    this URL. For the App ID URL, enter `https://[Your_AD_Tenant_Name]/TodoListWebApp`,
    replacing [`Your_AD_Tenant_Name`] with the name of your Azure AD tenant. Click
    on OK to complete the registration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to set up permissions between TodoListWebApp so that it can call
    our microservice: TodoListService. So, navigate to App Registration | TodoListWebApp | Required
    Permissions again and click on Add. Now click on 1 Select an API. This navigation
    is displayed in the following screenshot. You need to key in ToDoListService for
    it to show up in the API pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/46044531-310c-4a25-aa0d-29b222d2bf12.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you will be able to view the Enable Access pane, where you have to tick
    for Access TodoListService Permissions under the Delegated Permissions, and Done
    under the Add API access pane. This will save the permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generation of AppKey for TodoListWebApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important step for registration is adding `client_secret`, which is
    necessary to establish trust between Azure AD and TodoListWebApp. This `client_secret`
    is generated only once and configured in the web application. To generate this
    key, navigate to App Registrations | TodoListWebApp | Keys. Then, add the description
    as `AppKey` and click on Save. Once the key is saved, the value of the key is
    autogenerated by Azure and will be displayed next to the description. This key
    is displayed only once, so you have to immediately copy it and save it for later
    use. We will be keeping this key in the `web.config` file of TodoListWebApp in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key stored will be displayed on the Azure portal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a983ea10-4845-4d3d-809f-d39af7965390.png)'
  prefs: []
  type: TYPE_IMG
- en: For production-grade applications, it is a bad idea to keep `client_Secret`
    and all such critical key values in `web.config`. It is good practice to keep
    them encrypted and isolated from applications. For such purposes, in production-grade
    applications, you can use Azure key-vault ([https://azure.microsoft.com/en-us/services/key-vault/](https://azure.microsoft.com/en-us/services/key-vault/))
    to keep all your keys protected. Another advantage of a key vault is that you
    can manage the keys according to the environment, such as dev-test-staging and
    production.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Visual Studio solution projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we look at how to configure this with the `TodoListService` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `web.config` file and replace the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the `ida:Tenant` key. Replace its value with your AD tenant name,
    for example, `contoso.onmicrosoft.com`. This will also be part of any of the application's
    APP ID URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `ida:Audience ` key. Replace its value with `https://[Your_AD_Tenant_Name]/TodoListService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `[Your_AD_Tenant_Name]` with the name of your Azure AD tenant.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now let's see how to configure this with the `TodoListWebApp` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `web.config` file and find and replace the following keys with the
    provided values:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace `todo:TodoListResourceid` with `https://[Your_Tenant_Name]/TodoListService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `todo:TodoListBaseAddress` with `https://localhost:44321/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `ida:ClientId` with the application ID of ToDoListWebApp. You can get
    it by navigating to App Registration | TodoListWebApp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `ida:AppKey` with `client_secret` that we generated in step 2 of the
    process of registering TodoListWebApp. If you missed noting this key, you need
    to delete the previous key and generate a new key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `ida:Tenant` with your AD tenant name, for example, `contoso.onmicrosoft.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `ida:RedirectUri` with the URL you want the application to redirect
    to when the user signs out of TodoListWebApp. In our case, the default is `https://localhost:44322/` since
    we want the user to navigate to the home page of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate client certificates on IIS Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now `TodoListService` and `TodoListWebApp` will talk over a secure channel.
    To establish a secure channel, `ToDoListWebApp` needs to trust the client certificate.
    Both services are hosted on the same machine and run on IIS Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure your computer to trust the IIS Express SSL certificate, open the
    PowerShell command window as an administrator. Query your personal certificate
    store to find the thumbprint of the certificate for `CN=localhost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the certificate to the trusted root store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding set of instructions will add a client certificate to the local
    machine's certificate store.
  prefs: []
  type: TYPE_NORMAL
- en: Running both the applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are done with all those tedious configuration screens and replacing of keys.
    Excited? But before you hit *F5*, set `ToDoListService` and `ToDoListWebApp` as
    startup projects. Once this is done, we can safely run our application and be
    greeted with the landing page of our application. If you click on the Sign-in
    button, you will be redirected to [login.microsoftonline.com](http://login.microsoftonline.com); this represents
    the Azure AD login. Once you are able to log in, you will see the landing page
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e29198da-d86b-4acc-a219-c9565624f490.png)'
  prefs: []
  type: TYPE_IMG
- en: You can observe network traffic and URL redirection when you log in to the application
    to study a detailed exchange of ID tokens and get an access token. If you explore
    the application through the ToDoList menu, you will be able to access the ToDoList
    screen as well as add items to ToDoList. This is where our `TodoListService` microservice
    is getting called, as well as getting authorization permissions from the `TodoWebApp`
    web application. If you explore the profile menu, you will see the ID token return
    along with your first name, last name, and email ID, which shows OpenID Connect
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to explore the code in detail, `TodoListController.cs` in the TodoListService
    project, `Startup.Auth.cs`, and `TodoListController.cs` contain interesting bits
    of code along with explanatory comments.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used OAuth and OpenID Connect to secure a browser-based
    user interface, a web application, and a microservice. Things might be different if
    we have an API gateway between the user interface web app and microservice. In
    this case, we need to establish trust between the web app and API gateway. Also,
    we have to pass the ID token and access token from the web app to the API gateway.
    This, in turn, passes the tokens to the microservice. However, it is not feasible
    to cover the discussion and implementation in this chapter's scope.
  prefs: []
  type: TYPE_NORMAL
- en: Azure API management as an API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important pattern in microservices' implementation is **Backends For
    Frontends** (**BFF**). This pattern was introduced and made popular by Sam Newman.
    The actual implementation of the BFF pattern is done by introducing the API gateway
    between various types of clients and microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d10acc55-d9a0-4d01-806d-95039ad04cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure API Management (henceforth referred to as **Azure APIM** or just **APIM**
    ) is just the right fit, and it can act as an API gateway in .NET-based microservice
    implementation. Since Azure APIM is one of the cloud services, it is ultra-scalable
    and can be integrated well within the Azure ecosystem. In the current chapter,
    we will focus on the following features of Azure APIM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure APIM is logically divided into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'API gateway: API gateway is merely a proxy between client applications and
    services. It is responsible for the following functionalities; these are mainly
    used by various applications to talk to microservices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepts API calls and routes them to your backends
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifies API keys, JWTs, and certificates
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports auth through Azure AD and OAuth 2.0 access token
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforces usage quotas and rate limits
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforms your API on the fly without code modifications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Caches backend responses where set up
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs call metadata for analytics purposes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Publisher portal: This is the administrative interface to organize and publish
    an API program. It is mainly used by microservice developers to make microservices/APIs
    available to API consumers or client applications. Through this, API developers
    can:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define or import API schema
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Package APIs into products
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up policies such as quotas or transformations on the APIs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get insights from analytics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Developer portal: This serves as the main web presence for API consumers where
    they can do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the API documentation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Try out an API via the interactive console
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an account and subscribe to it to get the API keys
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Access analytics on their own usage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure APIM comes with an easy-to-follow user interface and good documentation.
    Azure API management also comes with its REST API, hence all the capabilities
    of the Azure APIM portal, which you see can see, can be programmatically achieved
    by Azure REST API endpoint available for Azure APIM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s quickly look at some security-related concepts in Azure APIM and
    how they can be used in microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Products: Products are merely a collection of APIs. They also contain usage
    quota and terms of use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Policies: Policies are dynamic security features of API management. They allow
    the publisher to change the behavior of the API through configuration. Policies
    are a collection of statements that are executed sequentially upon the request
    or response of an API. API management is fundamentally a proxy that is sitting
    between our microservices hosted in Azure and client applications. By virtue of
    the fact that it is an intermediate layer, it is able to provide additional services.
    These additional services are defined in a declarative XML-based syntax called
    **policies**. Azure APIM allows various policies. In fact, you can compose your
    own custom policies by combining the existing ones. A few of the important policies
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access restriction policies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check the HTTP header: This policy checks whether a specific HTTP header or
    its value exists in every request received by Azure APIM.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limit call rate by subscription: This policy provides allow or deny access
    to the microservice based on the number of times the specific service has been
    called on a per subscription basis.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restrict caller IPs: This policy refers to white-boxing of IP addresses so
    only known IPs can access the services.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set usage quota by subscription: This policy allows a number of calls. It allows
    you to enforce a renewable or lifetime call volume and/or bandwidth quota on a
    per subscription basis.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Validate JWT: This policy validates the JWT token parameter that is used for
    auth in applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authentication policies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate with basic : This policy helps apply basic authentication over
    the incoming request.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authenticate with client certificate: This policy helps carry out authentication
    of a service that is behind the API gateway, using client certificates.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cross domain policies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allow cross-domain calls: This policy enables us to make CORS requests through
    Azure APIM.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CORS : This adds CORS support to an endpoint or a microservice to allow cross-domain
    calls from browser-based web applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSONP: The JSONP policy adds **JSON padding** (**JSONP**) support to an endpoint
    or entire microservice to allow cross-domain calls from Java Script web applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transformation policies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mask URLs in content: This policy masks URLs in response; it does so via Azure
    APIM.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set backend service: This policy alters the behavior of the backend service
    of an incoming request.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another great thing about policies is they can be applied for inbound and outbound
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limit and quota policy example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we saw what is meant by a policy. Now let''s see
    an example. The following is one of the quota policies applied for an endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are limiting incoming requests (inbound) from a single user.
    So, an API user can only make `100` calls within `60` seconds. If they try to
    make more calls within that duration, the user will get an error with status code
    `429`, which basically states *Rate limit is exceeded*. Also, we are assigning
    the quota limit of `200` calls in a year for the same user. This kind of throttling
    behavior is a great way to protect microservices from unwanted requests and even
    DOS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Azure APIM also supports Auth with OAuth 2.0 and OpenID Connect. Inside the
    publisher portal, you can easily see OAuth and OpenID Connect tabs to configure
    the providers.
  prefs: []
  type: TYPE_NORMAL
- en: Container security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a big part of the containerization of applications used in the industry.
    With the widespread usage of containers, it is evident that we need to have effective
    security measures around containers. If we take a look at the internal architecture
    of containers, they are quite close to the host operating system kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker applies the principle of least privilege to provide isolation and reduce
    the attack surface. Despite the advances, the following points will help you understand
    the security measures you can take for containers:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure all the container images used for microservices are signed and originate
    from a trusted registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harden the host environment, the daemon process, and images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the principle of least privilege and do not elevate access to access
    devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use control groups in Linux to keep tabs on resources, such as memory, I/O,
    and CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though containers live for a very short duration, logging all of the container
    activity is advisable and important to understand for post analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If possible, integrate the container scanning process with tools, such as Aqua
    ([http://www.aquasec.com](http://www.aquasec.com)) or Twistlock ([https://www.twistlock.com](https://www.twistlock.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other security best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The microservice architectural style is new, although some of the security
    practices around the infrastructure and writing secure code are still applicable.
    In this section, let''s discuss some of these practices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Standardization of libraries and frameworks: There should be a process to introduce
    new libraries and frameworks or tools in the development process. This will ease
    out patching in case any vulnerability is found; it will also minimize the risks
    introduced by ad hoc implementation of libraries or tools around development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular vulnerability identification and mitigation: Using the industry standard
    vulnerability scanner to scan the source code and binaries should be a regular
    part of development. The findings and observations should be addressed as equally
    as functional defects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Third-party audits and pen testing: External audits and penetration testing
    exercises are immensely valuable. There should be a regular practice of conducting
    such exercises. This is quite essential in applications where mission critical
    or sensitive data is handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logging and monitoring: Logging is quite a useful technique for detecting and
    recovering from attacks. Having the capability of aggregating logs from different
    systems is essential in the case of microservices. Tools such as Riverbed, AppDynamics,
    and Splunk are quite useful in this space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firewalls: Having one or more firewall at network boundaries is always beneficial.
    Firewall rules should be properly configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network segregation: Network partitioning is constrained and limited in the
    case of monoliths. However, with microservices, we need to logically create different
    network segments and subnets. Segmentation based on microservices'' interaction
    patterns can be very effective to keep and develop additional security measures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservice architectural style, being distributed by design, gives us
    better options to protect valuable business-critical systems. Traditional .NET-based
    authentication and authorization techniques are not sufficient and cannot be applied
    to the microservice world. We also saw why secure token-based approaches, such
    as OAuth 2.0 and OpenID Connect 1.0, are becoming concrete standards for microservice
    authorization and authentication. If you want to have more general information
    related to security, do visit **Open Web Application Security Project** (**OWASP**)
    at [http://www.owasp.org](http://www.owasp.org) and Microsoft Security development
    life cycle at [https://www.microsoft.com/en-us/sdl/](https://www.microsoft.com/en-us/sdl/).
    Azure AD can support OAuth 2.0 and OpenID Connect 1.0 very well. Azure API Management
    can also act as an API gateway in microservices' implementation and also provide
    nifty security features, such as policies.
  prefs: []
  type: TYPE_NORMAL
- en: Azure AD and Azure API management provide quite a few powerful features to monitor
    and log the requests received. This will be quite useful, not only for security
    but also for tracing and troubleshooting scenarios. We will see logging, monitoring,
    and the overall instrumentation around troubleshooting of microservices in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
