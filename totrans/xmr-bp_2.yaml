- en: Chapter 2. Building a SpeechTalk Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 构建语音对话应用程序
- en: In this chapter, we introduce development with `Xamarin.Forms`. We will build
    a cross-platform application for iOS, Android, and Windows Phone that integrates
    native platform speech services to speak text typed from a text field.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍使用 `Xamarin.Forms` 进行开发。我们将构建一个跨平台的应用程序，适用于 iOS、Android 和 Windows Phone，该应用程序集成了原生平台的语音服务，可以朗读从文本字段中输入的文本。
- en: 'Expected knowledge:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 预期知识：
- en: Microsoft Visual Studio.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 Visual Studio。
- en: 'In this chapter, you will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Cross-platform development with `Xamarin.Forms`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Xamarin.Forms` 进行跨平台开发
- en: Setting up platform projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置平台项目
- en: Setting up a `SpeechTalk.iOS` project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `SpeechTalk.iOS` 项目
- en: Setting up a `SpeechTalk.Droid` project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `SpeechTalk.Droid` 项目
- en: '`Xamarin.Forms`, Windows Phone, and Visual Studio'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms`、Windows Phone 和 Visual Studio'
- en: Inversion of Control (IoC) with `Xamarin.Forms`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Xamarin.Forms` 的控制反转（IoC）
- en: AutoFac
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AutoFac
- en: iOS text-to-speech implementation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 文本到语音实现
- en: Bindings
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定
- en: Android text-to-speech implementation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 文本到语音实现
- en: Setting up IoC with Android
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 中设置 IoC
- en: WinPhone text-to-speech implementation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinPhone 文本到语音实现
- en: IoC with Windows Phone
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Phone 的 IoC
- en: Platform-independent styling
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台无关样式
- en: Cross-platform development with Xamarin.Forms
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Xamarin.Forms` 进行跨平台开发
- en: The key ingredient in cross-platform development with Xamarin is code sharing.
    Sharing native code is great, but we still have the issue of writing separate
    user interface code for each platform. The **Windows Presentation Framework**
    (**WPF**) is a presentation system which uses an XML-based language known as **Extensible
    Application Markup Language** (**XAML**). Xamarin.Forms uses WPF and the **Model-View-View-Model**
    (**MVVM**) paradigm to build native user interfaces from a single C# shared code
    base, whilst maintaining access to all native APIs on each platform.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Xamarin 进行跨平台开发的关键要素是代码共享。共享原生代码很好，但我们仍然面临为每个平台编写单独的用户界面代码的问题。**Windows 表现框架（WPF**）是一个使用基于
    XML 的语言**可扩展应用程序标记语言（XAML**）的演示系统。Xamarin.Forms 使用 WPF 和 **模型-视图-视图模型（MVVM**）范式从单个
    C# 共享代码库构建原生用户界面，同时保持对每个平台所有原生 API 的访问。
- en: '![Cross-platform development with Xamarin.Forms](img/B05293_02_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![使用 `Xamarin.Forms` 进行跨平台开发](img/B05293_02_01.jpg)'
- en: The preceding diagram represents a native architecture. We keep all the sharable
    code Inside the **Shared C# App Logic** block (normally a shared project) for
    each platform project to access, i.e. the `GalleryItem` class would be kept here
    since it is shared between both projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表示的是原生架构。我们将所有可共享的代码放在每个平台项目的 **Shared C# App Logic** 块内（通常是一个共享项目），以便每个平台项目可以访问，即
    `GalleryItem` 类将保存在这里，因为它在两个项目中都是共享的。
- en: So how would this look in Xamarin.Forms?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，在 Xamarin.Forms 中这会是什么样子呢？
- en: 'Using `Xamarin.Forms`, since we have the ability to share the user interface
    screens, we can share the entire view and view model code between all platforms:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有能力共享用户界面屏幕，因此我们可以共享所有平台之间的整个视图和视图模型代码：
- en: '![So how would this look in Xamarin.Forms?](img/B05293_02_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xamarin.Forms 中这会是什么样子？](img/B05293_02_02.jpg)'
- en: In the preceding diagram, the code contained in the **Shared C# App Logic** block
    is contained in a **Portable Class Library** (**PCL**), which each native project
    will import. `Xamarin.Forms` makes it possible to share up to 85% of code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图中，**Shared C# App Logic** 块中的代码包含在一个 **可移植类库（PCL**）中，每个原生项目都会导入。`Xamarin.Forms`
    使得共享高达 85% 的代码成为可能。
- en: Let's now delve into development and setup our first `Xamarin.Forms` project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在深入开发并设置我们的第一个 `Xamarin.Forms` 项目。
- en: Setting up platform projects
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置平台项目
- en: 'In Xamarin Studio, let''s start by setting up the platform projects. Go to
    **File** | **New Solution** and select a **Xamarin.Forms** app from the cross-platform
    menu on the left:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中，让我们首先设置平台项目。转到 **文件** | **新建解决方案**，然后从左侧的跨平台菜单中选择一个 **Xamarin.Forms**
    应用程序：
- en: '![Setting up platform projects](img/B05293_02_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![设置平台项目](img/B05293_02_03.jpg)'
- en: Once the project is created, you will see both an iOS and Android project created
    along with a PCL.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，你将看到同时创建了一个 iOS 项目和一个 Android 项目，以及一个 PCL。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, we can't develop our Windows Phone applications through Xamarin
    Studio; we will be touching on this after the iOS and Android projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法通过 Xamarin Studio 开发我们的 Windows Phone 应用程序；我们将在 iOS 和 Android 项目之后讨论这个问题。
- en: 'Let''s create our first `ContentPage` in XAML, right-click on the PCL, create
    a new XAML `ContentPage,` and call it `MainPage`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 XAML 中创建我们的第一个 `ContentPage`，在 PCL 上右键单击，创建一个新的 XAML `ContentPage`，并将其命名为
    `MainPage`：
- en: '![Setting up platform projects](img/B05293_02_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![设置平台项目](img/B05293_02_04.jpg)'
- en: '`Xamarin.Forms` provides the option to build user interfaces entirely in C#,
    but it is recommended you stick with XAML because it is a very powerful markup
    language. The code required for a XAML sheet is much smaller than a user interface
    in C#.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms` 提供了完全使用 C# 构建用户界面的选项，但建议您坚持使用 XAML，因为它是一种非常强大的标记语言。XAML 表格所需的代码比
    C# 中的用户界面要小得多。'
- en: We also want to create a new folder called `Pages` and add `MainPage` to this
    folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要创建一个名为 `Pages` 的新文件夹，并将 `MainPage` 添加到这个文件夹中。
- en: 'Our first element on the page is a `Grid.` A Grid separates a layout by rows
    and columns based upon the entire size of the screen. Rows work from top to bottom
    and columns work from left to right; copy the following into the `MainPage.xaml`
    sheet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上的第一个元素是一个 `网格`。网格根据整个屏幕的大小通过行和列来分隔布局。行从上到下工作，列从左到右工作；将以下内容复制到 `MainPage.xaml`
    表格中：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At the top we have an XML description tag exactly like Android, which specifies
    an encoding and a version. We have the declaration of a `ContentPage` with the
    XML namespace specification attribute `xmlns`. We then specify the class name
    and add the `ContentPage.Content` tags, where we will create the page layout.
    All these XML tags are generated automatically; the only change we made was the
    namespace of the class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们有一个与 Android 完全相同的 XML 描述标签，它指定了编码和版本。我们有 `ContentPage` 的声明，带有 XML 命名空间指定属性
    `xmlns`。然后我们指定类名，并添加 `ContentPage.Content` 标签，我们将在这里创建页面布局。所有这些 XML 标签都是自动生成的；我们唯一做的更改是类的命名空间：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Grid inserted between the `ContentPage.Content` tags has three rows and
    three columns. Each row definition is assigned `Auto`, meaning the height of the
    row is based on the element assigned to it. Since we have three rows assigned
    with `Auto`, the Grid will only fill the height of the contained elements (similar
    to the `wrap_content` flag in android). The Grid will take up the entire width
    of the page as its one column definition is set to "*", meaning it will stretch
    one column to the entire width of the page. We have our basic page layout, so
    let's leave it there and move back into the project structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 插入到 `ContentPage.Content` 标签之间的网格有三个行和三个列。每个行定义都分配了 `Auto`，这意味着行的高度基于分配给它的元素。由于我们有三个分配了
    `Auto` 的行，网格将只填充包含元素的高度（类似于 android 中的 `wrap_content` 标志）。网格将占据页面的整个宽度，因为它的一个列定义设置为
    `"*"`，这意味着它将拉伸一列到页面的整个宽度。我们有了基本的页面布局，所以让我们在这里停下来，然后回到项目结构中。
- en: 'In `SpeechTalk.PCL`, we have a file called `SpeechTalk.cs`; we should rename
    this `App.cs` to match the class name. In the `App.cs`, this is the application
    starting point. In the constructor of the application class, you will see a `MainPage`
    property automatically set like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SpeechTalk.PCL` 中，我们有一个名为 `SpeechTalk.cs` 的文件；我们应该将其重命名为 `App.cs` 以匹配类名。在
    `App.cs` 中，这是应用程序的起始点。在应用程序类的构造函数中，您将看到自动设置为这样的 `MainPage` 属性：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So what is happening here?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？
- en: 'When the project is created, we automatically receive an `App` class with the `MainPage`
    property set to a new `ContentPage`. The preceding code block is an example of
    an interface built entirely via c-sharp. We want to replace this with an instantiation
    of our `MainPage`, and set this new object to the `MainPage` property of the `App`
    class. Here is the updated constructor:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目创建时，我们会自动接收到一个带有 `MainPage` 属性设置为新的 `ContentPage` 的 `App` 类。前面的代码块是一个完全通过
    c-sharp 构建的接口示例。我们想要用我们自己的 `MainPage` 实例来替换它，并将这个新对象设置为 `App` 类的 `MainPage` 属性。以下是更新后的构造函数：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's much cleaner, you can already see how messy the code would look like if
    we were to build complex user interfaces in **C#**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它更干净，您已经可以看到如果我们用 **C#** 构建复杂用户界面，代码会多么混乱。
- en: Setting up the SpeechTalk.iOS project
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SpeechTalk.iOS 项目
- en: 'Let''s also have a look at the project setup on the native side for iOS and
    Android. Open the `AppDelegate.cs` file; it should look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看 iOS 和 Android 的原生项目设置。打开 `AppDelegate.cs` 文件；它应该看起来像这样：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Have a look at the super class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看看超类：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since `Xamarin.Forms` 1.3.1 and the updated unified API, all our app delegate
    should be inheriting is `Xamarin.Forms.Platform.iOS.FormsApplicationDelegate`.
    We also have the standard `FinishedLaunching` function; in here we must call `Forms.Init`
    which will initialize `Xamarin.Forms`, and then call `LoadApplication` with a
    new instantiation of the `App` class. We then return the base class `FinishedLaunching` function,
    passing in the app and options objects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Xamarin.Forms` 1.3.1 及更新的统一 API，我们所有的应用程序代理都应该继承 `Xamarin.Forms.Platform.iOS.FormsApplicationDelegate`。我们还有一个标准的
    `FinishedLaunching` 函数；在这里，我们必须调用 `Forms.Init` 来初始化 `Xamarin.Forms`，然后使用 `App`
    类的新实例调用 `LoadApplication`。然后我们返回基类的 `FinishedLaunching` 函数，传递 app 和选项对象。
- en: You can see that this `FinishedLaunching` function is an override of the standard
    app delegate function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个 `FinishedLaunching` 函数是标准应用程序代理函数的覆盖。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must initialize forms before anything else occurs in this function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在函数中的任何其他操作之前初始化 forms。
- en: 'Let''s run the iOS application and see what happens:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 iOS 应用程序并看看会发生什么：
- en: '![Setting up the SpeechTalk.iOS project](img/B05293_02_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![设置 SpeechTalk.iOS 项目](img/B05293_02_05.jpg)'
- en: Fantastic, a blank application. That means we have now successfully run our
    first iOS `Xamarin.Forms` project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，一个空白的应用程序。这意味着我们现在已经成功运行了我们的第一个 iOS `Xamarin.Forms` 项目。
- en: Setting up the SpeechTalk.Droid project
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SpeechTalk.Droid 项目
- en: 'Let''s do the same for Android and set up `Xamarin.Forms` accordingly. Inside
    our Android project, open the `MainActivity.cs` class and look at the `OnCreate`
    function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 Android 也做同样的事情，并相应地设置 `Xamarin.Forms`。在我们的 Android 项目中，打开 `MainActivity.cs`
    类并查看 `OnCreate` 函数：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `MainActivity` class must inherit `Xamarin.Forms.Platform.Android.FormsApplicationActivity`;
    we must call the super class `OnCreate` method before we initialize `Xamarin.Forms`
    and load in our new instantiated app class. That's all, we can now run the Android
    application and see the exact same results, a blank page. Congratulations, you
    have just shared your first `Xamarin.Forms` interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity` 类必须继承 `Xamarin.Forms.Platform.Android.FormsApplicationActivity`；在初始化
    `Xamarin.Forms` 并加载我们新的实例化的应用程序类之前，我们必须调用超类 `OnCreate` 方法。就这样，我们现在可以运行 Android
    应用程序并看到完全相同的结果，一个空白页面。恭喜您，您刚刚共享了您的第一个 `Xamarin.Forms` 接口。'
- en: Xamarin.Forms, Windows Phone, and Visual Studio
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Forms、Windows Phone 和 Visual Studio
- en: Now let's look at sharing our `MainPage` interface with Windows Phone.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将我们的 `MainPage` 接口与 Windows Phone 共享。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not everyone will extend an app onto Windows Phone, so if you are not interested
    in creating a Windows Phone example you can skip this part.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个人都会将应用程序扩展到 Windows Phone，所以如果您不感兴趣创建 Windows Phone 示例，您可以跳过这部分。
- en: We are going to be using Microsoft Visual Studio, so open it up and open the
    `SpeechTalk` solution file (`SpeechTalk.sln`) we created in Xamarin Studio. Portability
    between the two IDEs is very good; watch the solution port directly into Visual
    Studio and open your PCL file without any issues.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Microsoft Visual Studio，所以打开它并打开我们在 Xamarin Studio 中创建的 `SpeechTalk` 解决方案文件（`SpeechTalk.sln`）。这两个
    IDE 之间的可移植性非常好；观察解决方案直接导入 Visual Studio 并打开您的 PCL 文件没有任何问题。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Create a `GIT` repository to help control the continuous change between Xamarin
    Studio and Visual Studio, we recommend creating a GIT repository for every chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `GIT` 仓库以帮助控制 Xamarin Studio 和 Visual Studio 之间的持续变化，我们建议为每个章节创建一个 GIT
    仓库。
- en: The iOS and Android projects may not be compatible as we created these in Xamarin
    Studio.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 和 Android 项目可能不兼容，因为我们是在 Xamarin Studio 中创建这些项目的。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can build iOS and Android applications directly in Visual Studio, but running
    iOS applications will require a mac build host.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在 Visual Studio 中构建 iOS 和 Android 应用程序，但运行 iOS 应用程序将需要一个 mac 构建宿主。
- en: 'Now it''s time to create a new Windows Phone project:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一个新的 Windows Phone 项目了：
- en: '![Xamarin.Forms, Windows Phone, and Visual Studio](img/B05293_02_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.Forms、Windows Phone 和 Visual Studio](img/B05293_02_06.jpg)'
- en: Unfortunately, the automated setup done with iOS and Android will not be done
    with the Windows Phone project. All the setup will be done manually, but this
    is good for walking you through the manual setup.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，iOS 和 Android 自动设置将不会在 Windows Phone 项目中完成。所有设置都将手动完成，但这对于指导您完成手动设置是有益的。
- en: 'We import the **Xamarin.Forms** nuget package:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 **Xamarin.Forms** nuget 包：
- en: '![Xamarin.Forms, Windows Phone, and Visual Studio](img/B05293_02_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.Forms、Windows Phone 和 Visual Studio](img/B05293_02_07.jpg)'
- en: Now its time to look at the `MainPage.xaml` and `MainPage.xaml.cs` files in
    the **Windows Phone** project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候查看 **Windows Phone** 项目的 `MainPage.xaml` 和 `MainPage.xaml.cs` 文件了。
- en: Wait a minute, haven't we already made one of these?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，我们不是已经做过这样一个了吗？
- en: Now that you are preparing a Windows Phone project, we can see the original
    WPF structure used in Xamarin.Forms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在准备一个Windows Phone项目，我们可以看到Xamarin.Forms中使用的原始WPF结构。
- en: 'Open up `MainPage.xaml` and paste in the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MainPage.xaml`并粘贴以下内容：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If any lines get underlined, just ignore them; this is an issue in Visual Studio.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何行被下划线标注，请忽略它们；这是Visual Studio中的一个问题。
- en: What can we see here?
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们在这里能看到什么？
- en: 'Yes, this is XAML. Windows apps are all built using the WPF framework. We create
    the `Xamarin.Forms` element `forms:WindowsPhonePage`. Open the `MainPage.xaml.cs`
    in the Windows Phone project and update the constructor:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是XAML。Windows应用都是使用WPF框架构建的。我们创建`Xamarin.Forms`元素`forms:WindowsPhonePage`。在Windows
    Phone项目中打开`MainPage.xaml.cs`并更新构造函数：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Project setup is quite simple, but we are not calling `Forms.Init` anywhere.
    Open up the `App.xaml.cs` file in the **Windows Phone** project and look for this
    block of code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置相当简单，但我们没有在任何地方调用`Forms.Init`。在**Windows Phone**项目中打开`App.xaml.cs`文件并查找以下代码块：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We must manually add this line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须手动添加以下这一行：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set the cache size to `1`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将缓存大小设置为`1`：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we now need to reference the **SpeechTalk** PCL project we created
    in Xamarin Studio earlier:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在需要引用我们在Xamarin Studio中之前创建的**SpeechTalk** PCL项目：
- en: '![What can we see here?](img/B05293_02_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![我们在这里能看到什么？](img/B05293_02_08.jpg)'
- en: 'You may run into issues with referencing this project to the targets set by
    the PCL by default:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到将此项目引用到PCL默认设置的目标时的问题：
- en: '![What can we see here?](img/B05293_02_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![我们在这里能看到什么？](img/B05293_02_09.jpg)'
- en: 'To fix this issue, open the **SpeechTalk** PCL project and update the target
    configurations in **Properties**:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，打开**SpeechTalk** PCL项目并在**属性**中更新目标配置：
- en: '![What can we see here?](img/B05293_02_10.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![我们在这里能看到什么？](img/B05293_02_10.jpg)'
- en: Click on the **Change** button where it says **Targets** and make sure the preceding
    checkboxes are selected. That's everything; try building and running the application.
    We should see a blank page like the Android and iOS projects. Gerat we have now
    made a cross-platform application for all platforms.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**更改**按钮，确保选中**目标**前的复选框。这就完成了；尝试构建并运行应用程序。我们应该看到一个空白页面，就像Android和iOS项目一样。现在我们已经为所有平台制作了一个跨平台应用程序。
- en: Now let's get into the fun stuff with IoC.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈IoC的乐趣。
- en: Inversion of Control (IoC) with Xamarin.Forms
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Forms的依赖注入（IoC）
- en: The **Inversion of Control** (**IoC**) principle is very a useful technique
    when writing cross-platform applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**（**IoC**）原则在编写跨平台应用程序时是一个非常实用的技术。'
- en: So why should we use it?
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么为什么我们应该使用它？
- en: Sharing 100% of the code would be great, but it is not entirely possible; we
    still require some implementation from platform-specific features (for example
    different platform services, hardware, cameras). A way to tackle this problem
    is via an **IoC container**. Using the IoC principle, we use an abstraction for
    the functionality in our shared code and pass an implementation of the abstraction
    into our shared code. Our IoC containers handle the instantiation of an object's
    dependency tree. We can register objects to their inherited interfaces and allow
    containers to pass registered objects as their abstracted interfaces all the way
    down the dependency tree (all the way to PCL).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分享100%的代码会很棒，但这并不完全可能；我们仍然需要一些来自特定平台功能的实现（例如不同的平台服务、硬件、摄像头）。解决这个问题的方法是通过**IoC容器**。使用IoC原则，我们在共享代码中使用功能抽象，并将抽象的实现传递到共享代码中。我们的IoC容器处理对象的依赖树实例化。我们可以将对象注册到它们继承的接口中，并允许容器将注册的对象作为它们的抽象接口传递到依赖树的底部（一直到底层的PCL）。
- en: So how do we benefit from this?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，我们如何从中受益？
- en: What if I needed view models to call methods to a native Bluetooth service in
    a PCL project?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在一个PCL项目中需要视图模型调用原生蓝牙服务的方法，该怎么办？
- en: 'To put it simply, we can''t. Our PCL projects know nothing about Bluetooth
    services on the native side. We create an interface that sits in the PCL project,
    create a class that inherits this interface, and define the methods and access
    all the native features required. We then register this class to the inherited
    interface through our IoC container, and finally resolve this abstracted interface
    in our PCL project. When we call functions from this interface down in the PCL,
    it will be calling the registered class function definitions described on the
    native side:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们不能。我们的PCL项目对原生侧的蓝牙服务一无所知。我们创建了一个位于PCL项目中的接口，创建了一个继承此接口的类，并定义了方法和访问所有所需的原生功能。然后我们通过IoC容器将此类注册到继承的接口中，最后在PCL项目中解析这个抽象接口。当我们从这个接口在PCL中调用函数时，它将调用在原生侧描述的已注册类函数定义：
- en: '![So how do we benefit from this?](img/B05293_02_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![我们如何从中受益？](img/B05293_02_11.jpg)'
- en: 'Now back to our `SpeechTalk` application. Because the PCL project cannot share
    code from the native side text-to-speech services, we will have to use IoC to
    access the native-side features from our PCL. Let''s start by declaring an interface
    for our text to speech service, creating a new folder called `Services`, and adding
    a new `ITextToSpeech.cs` file for the interface:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的`SpeechTalk`应用程序。由于PCL项目无法从原生侧的文本到语音服务共享代码，我们将不得不使用IoC来从我们的PCL访问原生侧功能。让我们首先声明一个用于文本到语音服务的接口，创建一个名为`Services`的新文件夹，并添加一个名为`ITextToSpeech.cs`的新文件用于接口：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Autofac
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Autofac
- en: 'Before we begin implementing the different native sides to this interface,
    let''s first add in our IoC container to handle the abstraction. There are a few
    IoC containers that are free online; for this example we are going to use **Autofac**.
    Let''s add the NuGet packages for the PCL, iOS, and Android projects:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现此接口的不同原生方面之前，让我们首先添加我们的IoC容器来处理抽象。有一些IoC容器是免费在线的；对于这个例子，我们将使用**Autofac**。让我们为PCL、iOS和Android项目添加NuGet包：
- en: '![Autofac](img/B05293_02_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Autofac](img/B05293_02_12.jpg)'
- en: 'Now that we have our IoC container, let''s build the iOS implementation. For
    each platform, we want to create objects called **Modules** for registering abstracted
    interfaces. Let''s add a new folder called IoC to the PCL project and add a new
    file called `IoC.cs`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的IoC容器，让我们构建iOS实现。对于每个平台，我们想要创建名为**Modules**的对象来注册抽象接口。让我们在PCL项目中添加一个名为IoC的新文件夹，并添加一个名为`IoC.cs`的新文件：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Looking at this closer, we use this static class for registering modules, registering
    types, resolving registered types, creating the container, and building the container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们使用这个静态类来注册模块、注册类型、解析已注册的类型、创建容器和构建容器。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ContainerBuilder` must be built after all types have been registered.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册所有类型之后，必须构建`ContainerBuilder`。
- en: 'We must register and start this container before we initialize the application.
    Open up your `AppDelegate.cs` file and update the `FinishedLaunching` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化应用程序之前，我们必须注册并启动此容器。打开您的`AppDelegate.cs`文件并更新`FinishedLaunching`函数：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `InitIoC` function will first create the container, register the modules,
    and build the IoC container.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitIoC`函数将首先创建容器，注册模块，并构建IoC容器。'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our container must be created before we can start registering, and our container
    builder must be built before we can start resolving.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始注册之前，我们的容器必须被创建，并且我们的容器构建器必须在我们可以开始解析之前被构建。
- en: Each module has register functions that will use the created `ContainerBuilder`
    to register types.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有注册函数，这些函数将使用创建的`ContainerBuilder`来注册类型。
- en: iOS text-to-speech implementation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS文本到语音实现
- en: Each module will retrieve the current container used throughout the entire lifetime
    of your application. Inside the register function is where we register the class
    implementation of the text to speech interface. This will be done at the very
    start of the application before we load anything else.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块将检索在整个应用程序生命周期中使用的当前容器。在注册函数内部，我们将注册文本到语音接口的类实现。这将在我们加载其他任何内容之前的应用程序开始时完成。
- en: 'Let''s start first with adding the iOS module. Add a new folder in the iOS
    project called **Modules**, create a new file called `iOSModule.cs`, and paste
    in the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从添加iOS模块开始。在iOS项目中添加一个名为**Modules**的新文件夹，创建一个名为`iOSModule.cs`的新文件，并粘贴以下内容：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next step is to add the iOS text to speech service. Add a new folder called
    `Services` and add a new file called `TextToSpeech.cs`. In this file, we are going
    to access the iOS `AVSpeechSynthesizer`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加 iOS 文本到语音服务。添加一个名为 `Services` 的新文件夹，并添加一个名为 `TextToSpeech.cs` 的新文件。在这个文件中，我们将访问
    iOS 的 `AVSpeechSynthesizer`：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Looking closely at this class, we are going to use the speech synthesizer to
    produce a `SpeechUtterrance` object, which contains the text to speak. We also
    set the language, volume, and speech rate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察这个类，我们将使用语音合成器来生成一个 `SpeechUtterance` 对象，它包含要说的文本。我们还设置了语言、音量和语速。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Notice how we inherit the interface we are going to register through the
    IoC container?**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意我们是如何通过 IoC 容器继承将要注册的接口的吗？**'
- en: As we are coding this class on the native side, we are able to access all native
    iOS features, so back in the PCL when we call the function `Speak` in the interface,
    the preceding code will execute.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个类上编写的是原生代码，因此我们可以访问所有原生 iOS 功能，所以当我们回到 PCL 并在接口中调用 `Speak` 函数时，前面的代码将执行。
- en: 'Our next step is to implement the view model principles for our pages. Create
    a new folder called `ViewModels` and add two new files, `ViewModelBase.cs` and
    `MainPageViewModel.cs`. The `ViewModelBase` class will be the base call for all
    view models for handling property change events with any view model''s properties:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是实现页面视图模型的原则。创建一个名为 `ViewModels` 的新文件夹，并添加两个新文件，`ViewModelBase.cs` 和 `MainPageViewModel.cs`。`ViewModelBase`
    类将是所有视图模型的基础调用，用于处理任何视图模型属性的属性更改事件：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's look a bit closer. The first property defined is `PropertyChanged EventHandler`,
    which will fire on any property data change. Notice the use of the `#` define
    statements; these are useful for breaking up blocks of coding and navigating through
    your code sheets.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看。首先定义的属性是 `PropertyChanged EventHandler`，它将在任何属性数据更改时触发。注意 `#` 定义语句的使用；这些对于分割代码块和导航代码表很有用。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These are particularly useful when we have big code sheets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在处理大型代码表时特别有用。
- en: The class inherits the `INotifyPropertyChanged` interface, meaning we have to
    define the `OnPropertyChanged` function. This function is used to fire the `PropertyChanged`
    event to signal that a property within this class has changed data. Now let's
    implement the `MainPageViewModel`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承了 `INotifyPropertyChanged` 接口，这意味着我们必须定义 `OnPropertyChanged` 函数。这个函数用于触发
    `PropertyChanged` 事件，以通知类内的某个属性已更改数据。现在让我们实现 `MainPageViewModel`。
- en: How do we use the `OnPropertyChanged` principle with our `MainPageViewModel`?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用 `OnPropertyChanged` 原则与我们的 `MainPageViewModel` 结合使用？
- en: 'With each property in the `MainPageViewModel`, we have to call the `OnPropertyChanged`
    function to fire the `EventHandler`, thus notifying of a data change for a particular
    property. Let''s begin by creating the `MainPageViewModel` with its private properties
    and constructor:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainPageViewModel` 的每个属性中，我们必须调用 `OnPropertyChanged` 函数来触发 `EventHandler`，从而通知特定属性的数据更改。让我们从创建具有私有属性和构造函数的
    `MainPageViewModel` 开始：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the first time we are going to access the `Systems.Windows.Input` library.
    **Commands** are used for our `Button` object on the `ContentPage`; we will set
    up a binding on the button so whenever a press event occurs, this command will
    execute, running the action it is assigned in the constructor. Notice how we are
    passing the `TextToSpeech` interface; this is where things will get trickier with
    the IoC container.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次访问 `Systems.Windows.Input` 库。**命令**用于 `ContentPage` 上的 `Button` 对象；我们将在按钮上设置绑定，以便每当发生点击事件时，这个命令就会执行，运行在构造函数中分配的动作。注意我们是如何传递
    `TextToSpeech` 接口的；这就是 IoC 容器会变得复杂的地方。
- en: 'Now we add the public properties of the view model, which call the `OnPropertyChanged`
    function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加视图模型的公共属性，这些属性调用 `OnPropertyChanged` 函数：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's it! We have our first view model. Notice the `get` and `set` methods
    for each property; they are exactly the same as functions, just with a nicer presentation.
    Every time we retrieve the data inside a `public` property, it will pull the data
    contained in the `private` property, and every time we set the `public` property,
    if the value is different to the current value, we will set the `private` variable
    contained and call the `OnPropertyChanged` function to fire the `EventHandler`
    in the base class. When this event fires, it will update whatever view is bound
    to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们得到了第一个视图模型。注意每个属性的`get`和`set`方法；它们与函数完全相同，只是呈现方式更优雅。每次我们在`public`属性内部检索数据时，它都会拉取`private`属性中的数据，每次我们设置`public`属性时，如果值与当前值不同，我们将设置包含在`private`变量中的值，并调用`OnPropertyChanged`函数来触发基类中的`EventHandler`。当此事件触发时，它将更新绑定到它的任何视图。
- en: Bindings
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: Back in the PCL project, we are going to run through the concept of binding
    view models to views, displaying view model data, and propagating data changes
    through the `INotifyPropertyChanged` interface.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在PCL项目中，我们将运行将视图模型绑定到视图、显示视图模型数据以及通过`INotifyPropertyChanged`接口传播数据更改的概念。
- en: 'Let''s begin with our `MainPage.cs` and complete the rest of the user interface
    for this page:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`MainPage.cs`开始，并完成此页面的其余用户界面：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now have a `Label`, `Entry`, and `Button`; each has the `x:Name`, `Grid.Row`,
    and `Grid.Column` properties assigned.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个`Label`、`Entry`和`Button`；每个都分配了`x:Name`、`Grid.Row`和`Grid.Column`属性。
- en: Notice how we relate the rows and columns to the definitions section previously?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将行和列与之前的定义部分相关联的？
- en: We have also set, on the bounding Grid, padding values for left, up, right,
    and down; set the vertical options to `Center`; and set a row spacing of `10`.
    The `Padding` will place gaps around the entire bounds of the Grid and the `ContentPage`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在边界Grid上设置了左、上、右和下的填充值；将垂直选项设置为`Center`；并设置行间距为`10`。`Padding`将在Grid和`ContentPage`的整个边界周围放置间隔。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Padding works exactly like margins in HTML.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Padding（填充）在HTML中与边距（margins）的工作方式完全相同。
- en: The `RowSpacing` property will set the gaps between each row; as each element
    is placed in a new row, they will be stacked vertically with a pixel spacing of
    `10` between each. Since we only have 1 column, this column width will take up
    the entire width of the **Grid**, so each element will be at the full width of
    the `Grid`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowSpacing`属性将设置每行之间的间隔；由于每个元素都放置在新的一行中，它们将以`10`像素的间隔垂直堆叠。由于我们只有1列，因此此列宽度将占据整个**Grid**的宽度，因此每个元素都将占据`Grid`的全宽。'
- en: Finally, setting the `VerticalOptions` of the `Grid` to `Center` will position
    all elements to the center of the Grid. Now let's set up the binding between the
    `MainPage` and `MainPageViewModel`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`Grid`的`VerticalOptions`设置为`Center`将使所有元素都定位在Grid的中心。现在让我们设置`MainPage`和`MainPageViewModel`之间的绑定。
- en: 'Create a new file, add it to the modules folder called `PCLModule.cs`, and
    paste in the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，将其添加到模块文件夹中，命名为`PCLModule.cs`，并粘贴以下内容：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hold on... why are we registering our pages and view models in the container?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下...为什么我们要在容器中注册我们的页面和视图模型？
- en: We don't need to abstract these.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要对这些内容进行抽象。
- en: 'Registering both views and view models in the container allows us to add our
    related view models in the constructor; as we only ever need one instance of both
    the view and view model throughout the entire lifetime of the application, we
    can set up the `MainPage.xaml.cs` file like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中注册视图和视图模型允许我们在构造函数中添加我们的相关视图模型；由于在整个应用程序的生命周期中我们只需要一个视图和视图模型的实例，我们可以将`MainPage.xaml.cs`文件设置如下：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The instance of the `MainPageViewModel` that was created in the container when
    registered will be pulled out of the `MainPage` constructor on creation. This
    is the same technique used with the instance of the `MainPageViewModel`, where
    we place the `ITextToSpeech` abstraction in the constructor; it will pull out
    the instance registered on the native side, and in turn we can now use this object
    to start calling the functions that will run the `native-side` code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中注册时创建的`MainPageViewModel`的实例将在创建`MainPage`时从构造函数中提取出来。这与我们在构造函数中放置`ITextToSpeech`抽象的实例所使用的相同技术；它将提取在本地端注册的实例，从而我们可以现在使用此对象来调用将运行`native-side`代码的函数。
- en: 'Now back to the `MainPage.xaml` sheet, let''s set up the property bindings;
    update the label, entry, and button to the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`MainPage.xaml`表单，让我们设置属性绑定；更新标签、输入和按钮如下：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have set up bindings for the text on the label and entry properties; notice
    the two-way binding mode set on the entry text property?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为标签和输入属性上的文本设置了绑定；注意输入文本属性上设置的双向绑定模式？
- en: What this means is if we change the data from the user interface (as it is a
    text box, will we will be changing the data on the UI front) or the view model,
    both endpoints will receive the data change accordingly. We have also set up a
    binding with the command on the button; now, whenever we press this button on
    the page, it will run the action assigned to it in the view model.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们从用户界面（因为它是一个文本框，我们将更改 UI 前的数据）或视图模型更改数据，两个端点都会相应地接收到数据更改。我们还设置了按钮上的命令绑定；现在，每次我们在页面上按下此按钮时，它都会运行视图模型中分配给它的操作。
- en: 'Now that all the coding is done, let''s run the application; try typing in
    text and pressing the **Speak** button and have a listen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的编码都完成了，让我们运行应用程序；尝试输入文本并按下 **Speak** 按钮，听听效果：
- en: '![Bindings](img/B05293_02_13.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![绑定](img/B05293_02_13.jpg)'
- en: Well done! You have just completed your first iOS `Xamarin.Forms` application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你刚刚完成了你的第一个 iOS `Xamarin.Forms` 应用程序。
- en: For some extra exercises, try changing the properties of volume and speech on
    the `SpeechUtterance` object for iOS.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行一些额外的练习，尝试更改 iOS 中 `SpeechUtterance` 对象的音量和语音属性。
- en: Android text-to-speech implementation
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 文本到语音实现
- en: Now let's implement the IoC container and text to speech for Android. Start
    by creating a folder for the both the Android Modules and Services, add in two
    files to it, `TextToSpeechDroid.cs` and `DroidModule.cs`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为 Android 实现 IoC 容器和文本到语音。首先创建一个文件夹用于 Android 模块和服务，向其中添加两个文件，`TextToSpeechDroid.cs`
    和 `DroidModule.cs`。
- en: 'Let''s start with the text to speech service; for `TextToSpeechDroid.cs`. And
    add the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从文本到语音服务开始；对于 `TextToSpeechDroid.cs`。添加以下内容：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `IOnInitListener` interface requires the `OnInit` function to be implemented.
    The `OnInit` function is called to signal the completion of the `TextToSpeech`
    engine initialization. We then implement the interface's function `Speak` to speak
    the text passed in. At the start of the function, we check to see that a new `TextToSpeech`
    object has been initialized; if we have then speak the message.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `IOnInitListener` 接口要求实现 `OnInit` 函数。`OnInit` 函数被调用以指示 `TextToSpeech` 引擎初始化完成。然后我们实现接口的
    `Speak` 函数来朗读传入的文本。在函数开始时，我们检查是否已初始化一个新的 `TextToSpeech` 对象；如果是，则朗读消息。
- en: Setting up IoC with Android
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Android 设置 IoC
- en: 'Now for the IoC implementation. It works exactly the same as iOS; let''s add
    the Android module:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 IoC 实现的时候了。它与 iOS 完全一样；让我们添加 Android 模块：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Easy, right?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？
- en: 'Now we have to set up the IoC container in our `MainActivity.cs` class; simply
    copy the iOS function in the `AppDelegate` file called `initIoC` and paste this
    into the `MainActivity` class, replace the instantiation of the `iOSModule` with
    your `DroidModule`, then simply add the function call after the initialization
    of `Xamarin.Forms`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在 `MainActivity.cs` 类中设置 IoC 容器；简单地将 `AppDelegate` 文件中名为 `initIoC` 的 iOS
    函数复制并粘贴到 `MainActivity` 类中，然后将 `iOSModule` 的实例化替换为你的 `DroidModule`，然后只需在 `Xamarin.Forms`
    初始化之后添加函数调用即可：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have issues trying to get the speech to work on Android. One thing you
    may need to set up first is within **Settings** | **Controls** | **Text-to-Speech**
    options. Here is where you will have to install voice data if the default has
    not already been installed. If you run the app and no speech occurs, you will
    have to configure the voice data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在 Android 上遇到让语音工作的问题。你可能需要首先设置的是在 **设置** | **控制** | **文本到语音** 选项中。如果你还没有安装默认的语音数据，你将在这里安装语音数据。如果你运行了应用程序但没有语音发生，你将需要配置语音数据。
- en: That's all for Android, now try running the app and hear some speech.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android 就这些了，现在尝试运行应用程序并听听语音。
- en: WinPhone text-to-speech implementation
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinPhone 文本到语音实现
- en: Now we go back to Windows Phone for the last implementation. See how tricky
    it can be when you have to switch between multiple platforms. Imagine if we had
    to change languages and re-write IoC containers; the amount of work would be much
    greater. Not only that, there would be no point in using IoC, because we cannot
    share any code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到 Windows Phone 进行最后的实现。看看当你需要在多个平台之间切换时会有多复杂。想象一下，如果我们不得不更改语言并重新编写 IoC
    容器，工作量将会更大。不仅如此，使用 IoC 将毫无意义，因为我们无法共享任何代码。
- en: 'So firstly, don''t forget to import the nuget package for **Autofac**:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，别忘了导入 **Autofac** 的 nuget 包：
- en: '![WinPhone text-to-speech implementation](img/B05293_02_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![WinPhone 文本到语音实现](img/B05293_02_14.jpg)'
- en: 'Now that we have access to the **Autofac** framework, let''s continue implementing
    the text to speech service. Start with adding a new folder called **Services**,
    then add the `TextToSpeechWinPhone.cs` file and implement it:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问 **Autofac** 框架了，让我们继续实现文本到语音服务。首先添加一个名为 **Services** 的新文件夹，然后添加 `TextToSpeechWinPhone.cs`
    文件并实现它：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Looking at this more closely, you can see the instantiation of `MediaElement`;
    this is used to play an audio source. Our source in this case is `SpeechSynthesisStream`;
    this stream is built via a speech synthesizer. When we call the function `SynthesizeTextToStreamAsync`,
    it will be an audio stream based on the text inserted into this function. We then
    set the `MediaElement` source to the stream and call the `Play` function to begin
    speaking. One addition to configuring Windows Phone is checking the capability
    in the app manifest file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你可以看到 `MediaElement` 的实例化；这是用来播放音频源的。在这个例子中，我们的源是 `SpeechSynthesisStream`；这个流是通过语音合成器构建的。当我们调用
    `SynthesizeTextToStreamAsync` 函数时，它将基于插入到该函数中的文本生成一个音频流。然后我们将 `MediaElement` 的源设置为流并调用
    `Play` 函数开始说话。在配置 Windows Phone 时，还有一个额外的配置需要检查，那就是在应用清单文件中检查功能。
- en: IoC with Windows Phone
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows Phone 上的 IoC
- en: 'Implementing IoC with Windows Phone is very much the same as iOS and Android.
    We simply add the same function, `InitIoC`, at our application''s starting point;
    in this case, it is the `MainPage` constructor of the Windows Phone project (try
    not to get the two confused), and we call it right before the `LoadApplication`
    function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Phone 上实现 IoC 与 iOS 和 Android 非常相似。我们只需在应用程序的起始点添加相同的函数，`InitIoC`；在这种情况下，是
    Windows Phone 项目的 `MainPage` 构造函数（尽量别弄混），然后我们在 `LoadApplication` 函数之前调用它：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Simple! Now we can run the Windows application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！现在我们可以运行 Windows 应用程序了。
- en: Platform independent styling
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台无关样式
- en: Hold on! What has happened with the `MainPage`—no button, no text?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！`MainPage` 发生了什么——没有按钮，没有文本？
- en: 'What is happening here is we have not specified colors for these elements,
    so the default color of the text has come up as white. Open up `MainPage.xaml`
    and change the text colors accordingly:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在这里的情况是我们没有指定这些元素的颜色，所以文本的默认颜色显示为白色。打开 `MainPage.xaml` 并相应地更改文本颜色：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It might be a good idea to color the background of the `Entry` object as well,
    so we can see the text definition:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可能给 `Entry` 对象的背景也上色是个好主意，这样我们就能看到文本定义：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now run it again and see the text, button, and entry background display.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行它，看看文本、按钮和输入背景是否显示。
- en: But wait! What if we don't want these colors to change for iOS and Android,
    or we want to set these colors differently based on the platform?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！如果我们不希望这些颜色为 iOS 和 Android 改变，或者我们希望根据平台设置不同的颜色呢？
- en: 'Here is another trick to try: in the `MainPage.xaml` sheet, we are going to
    change the background color of the entry based upon whether it is iOS, Android,
    or Windows Phone:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个技巧可以尝试：在 `MainPage.xaml` 表格中，我们将根据是否是 iOS、Android 还是 Windows Phone 来更改输入的背景颜色：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We start by specifying the property tag we are changing, and then a tag for
    `OnPlatform` in which we specify the argument type, which is `Color`. Let''s take
    it a step further and change the text colors for the `Button` and `Label` as well:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指定我们正在更改的属性标记，然后是一个 `OnPlatform` 标记，在其中我们指定了参数类型，即 `Color`。让我们更进一步，更改 `Button`
    和 `Label` 的文本颜色：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a nice little variation between styles for the first page. As you build
    more complex XAML sheets, you may find some areas where you will have to change
    pixel items, change color, and perform other styling to give it that extra edge.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在第一页样式之间一个很好的小变化。随着你构建更复杂的 XAML 表格，你可能会发现一些需要改变像素项、改变颜色和执行其他样式以提供额外优势的区域。
- en: Let's call it a day and end this project here; it's now time to build our GPS
    locator.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们到此为止，结束这个项目；现在是时候构建我们的 GPS 定位器了。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create a text to speech service using `Xamarin.Forms`.
    We have learned about native speech service libraries for each platform. In the next
    chapter, we will learn how to handle background location update events and using
    latitude and longitude to calculate positions. You will also learn how to implement
    location services on each platform by using `Xamarin.Forms` and `Xamarin.Forms.Maps`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 `Xamarin.Forms` 创建文本到语音服务。我们了解了每个平台的原生语音服务库。在下一章中，我们将学习如何处理后台位置更新事件，并使用经纬度来计算位置。你还将学习如何通过使用
    `Xamarin.Forms` 和 `Xamarin.Forms.Maps` 在每个平台上实现位置服务。
