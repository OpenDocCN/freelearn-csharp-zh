<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>Developing the Let&amp;#x27;s Chat Web Application</title>
    <link href="css/style.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing the Let's Chat Web Application</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we got the requirements and high level design of the <span>Let's Chat web application. We</span> got started with the Let's Chat web application by setting up project. We learned about the fundamental concepts of ASP.NET Core in the process. In this chapter, we will develop the Let's Chat web application and learn about a few more concepts of ASP.NET Core. We will cover the following topics in this chapter:</p>
<ul>
<li>ASP.NET Core 2.0 fundamentals</li>
<li>Implementing authentication through Facebook</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">ASP.NET Core 2.0 fundamentals</h1>
                </header>
            
            <article>
                
<p>This section is a continuation of our journey of learning ASP.NET Core 2.0 fundamentals that we started in the previous chapter. We will (re)visit the fundamentals, so that we can use them correctly while coding the app. <span>In this section,</span> we will take a quick lap around MVC and we will further discuss routing, filters, error handling, and so on. Let's start with MVC.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Quick lap around MVC</h1>
                </header>
            
            <article>
                
<p><strong>MVC</strong> stands for <strong>Model</strong>-<strong>View</strong>-<strong>Controller</strong>. The intent of this pattern is to achieve separation of concerns. In general terms, we can draw an analogy of MVC with "<em><strong>Division of labour</strong>"</em>. In this architectural pattern, the application is divided into three distinct components: the Model, the View, and the Controller. When a user requests a resource in the server, it is routed to a Controller which works with the Model to perform user actions and/or CRUD (<strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong>, <strong>Delete</strong>) operations. The Controller then chooses the View to display the user interface to the user, and provides it with the required Model data. The following diagram dis<span>plays the three main components:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="268" width="371" src="assets/a6550793-3861-4a57-bb96-ce5695c89cd8.png"/></div>
<p>We see that in the diagram, both the View and the Controller depend on the Model. However, the Model depends on neither of them. This is one of the key benefits of the pattern and also the golden rule for correct implementation of MVC. Using this separation, we can build and test the Model independently of the visual presentation. The <strong>S</strong> of the <strong>SOLID</strong> design principle, <strong>single responsibility principle</strong> (<strong>SRP</strong>), is at the heart of MVC. It also reiterates the <strong>don't repeat yourself</strong> (<strong>DRY</strong>) principle. MVC is all about the separation of concerns to have better test-ability and maintainability. The responsibility of each of the components is clearly laid out:</p>
<ul>
<li><span><span><strong>Model</strong> is the central component of this architectural pattern and represents the data. It maintains the data of the application.</span></span></li>
<li><strong>View</strong> is the visual component and is the user interface for the model; that is, it displays the data of the model to the end user and also enables them to edit the data.</li>
<li><strong>Controller</strong> is the controller of the request; that is, the request handler. Typically, users interact with the View for displaying, editing, adding, and deleting the data. This raises a corresponding <span>URL request. This request is handled by a Controller. The Controller renders the appropriate View with the Model data as a response:</span></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="202" width="353" src="assets/1a244219-e9fb-4ed4-be81-87f1db484713.jpg"/></div>
<p>The preceding diagram sums up the general working of the MVC pattern:</p>
<ol>
<li>The client sends a request, which is routed to a <strong>CONTROLLER</strong></li>
<li>The <strong>CONTROLLER</strong> uses the <strong>MODEL</strong> to perform some <em>business</em> operations</li>
<li>The <strong>MODEL</strong> returns the result of the operations back to the <strong>CONTROLLER</strong></li>
<li>The <strong>CONTROLLER</strong> decides which <strong>VIEW</strong> is to be rendered and sends it the model (data) that must be rendered</li>
<li>The <strong>VIEW</strong> renders the output and sends the response back to the client</li>
</ol>
<p>Let's see an analogy of MVC in the real world, so that the new users of MVC find it link-able. Let's think about a magazine. <span>If I were to</span> <em>loosely</em> <span>fit a magazine cover in the MVC pattern, it would be as follows: the user sees the magazine. What we see as the cover of the magazine is the</span> <strong>View</strong> <span>(user interface). We see some text and an image; for example, a fashion model or a sports star in the View. This is the</span> <strong>Model</strong> <span>(data), and the photographer/editor would be the</span> <strong>Controller</strong> <span>as they have manipulated the data and displayed it in the cover. This hopefully demonstrates the gist of MVC.</span></p>
<div class="packt_infobox">A couple of trivia questions. When was MVC invented? The answer roughly would be 1979 (December 10). Who invented it? A Smalltalk programmer, named Trygve Reenskaug (read about him at: <a href="https://en.wikipedia.org/wiki/Trygve_Reenskaug">https://en.wikipedia.org/wiki/Trygve_Reenskaug</a>), who maintains a web page to explain the history of MVC in his own words at: <a href="http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html">http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html</a>. It's worth a read!</div>
<p>So far, we have discussed MVC as an architectural pattern. Since we are learning ASP.NET Core, let's talk about the ASP.NET Core MVC framework. The ASP.NET Core MVC is a lightweight, open source, and highly testable presentation framework, that has been tailor-made for use with ASP.NET Core. It gives full control over the generated HTML markup and follows the latest web standards. To use it is pretty simple as well. We just need to add MVC in a services container, by writing <kbd>AddMVC</kbd> in the <kbd>ConfigureServices</kbd> method of <kbd>Startup.cs</kbd>, and then configure the pipeline to start using it by writing <kbd>UseMVC</kbd>, as shown in the following code snippets:</p>
<pre>   public void ConfigureServices(IServiceCollection services)<br/>   {<br/>       <strong>services.AddMvc();</strong> <br/>   }<br/><br/>   public void Configure(IApplicationBuilder app, IHostingEnvironment <br/>   env)<br/>   {<br/>       if (env.IsDevelopment())<br/>       {<br/>           app.UseDeveloperExceptionPage();<br/>           app.UseBrowserLink();<br/>       }<br/>       else<br/>       {<br/>           app.UseExceptionHandler("/Home/Error");<br/>       }<br/>       app.UseStaticFiles();<br/>       <strong>app.UseMvc(routes =&gt;</strong><br/><strong>       {</strong><br/><strong>           routes.MapRoute(</strong><br/><strong>               name: "default",</strong><br/><strong>               template: "{controller=Home}/{action=Index}/{id?}");</strong><br/><strong>       });</strong><br/>   }</pre>
<p><kbd>UseMvc</kbd> has two overloads:</p>
<ul>
<li><kbd>UseMvc()</kbd>: This works only with attribute-based routes, which we will visit in a while.</li>
<li><kbd>UseMvc(Action&lt;IRouteBuilder&gt; configureRoutes)</kbd>: This works with both conventional and attribute- based routes. It has a <kbd>callback</kbd> method to configure the routes. We have used this overload in the preceding sample.</li>
</ul>
<p>This can be seen from the documentation of the API, which defines the <kbd>UseMvc</kbd> extension methods. The code can be seen at GitHub at: <a href="https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs">https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs</a>.<a href="https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs"></a></p>
<p>There is one more extension method, <kbd>UseMvcWithDefaultRoute</kbd>, which can be used to configure MVC to work with a default route named <kbd>default</kbd> and <kbd>template</kbd> as <kbd>'{controller=Home}/{action=Index}/{id?}'</kbd>.</p>
<p>By using any of the preceding extension methods to use MVC middleware, we can start leveraging the goodness of ASP.NET Core MVC. Recall that by doing so, we are entering the last middleware/section of the request pipeline, as shown in the following diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="280" width="478" src="assets/d3e9e282-a282-4411-95e7-87434e492097.png"/></div>
<p>We saw this diagram in the previous chapter as well. However, the clarification of this section, other middleware in the pipeline blurred out to indicate we are focusing on MVC middleware. Let's have a look at this in detail.</p>
<p>The middleware resides in the <kbd>Microsoft.AspNetCore.Builder</kbd> namespace in the <span><kbd>Microsoft.AspNetCore.Mvc.Core</kbd> assembly.</span> Let's look at the code map diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="203" width="754" src="assets/dcd3c9f8-028b-4b7d-a684-49ccb07e4861.png"/></div>
<p>As we can see, there is so much that we can't even see the association and inheritance relationships between the different components. Don't worry about this complexity; it's already baked in the framework and we just need to learn and use things of interest. ASP.NET Core MVC is rich in features and includes the following:</p>
<ul>
<li>Routing</li>
<li>Model binding</li>
<li>Validation</li>
<li>Filters</li>
<li>Controller</li>
<li>Error handling</li>
</ul>
<p>We will discuss them in the following sections.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Routing</h1>
                </header>
            
            <article>
                
<p class="lf-text-block lf-block x-hidden-focus"><span>ASP.NET Core MVC is a powerful URL-mapping software component as it stands on</span> top of ASP.NET Core routing. As a result, we can build apps that have easily understandable and searchable URLs. This way, we can define our app's URL naming patterns that work well for <strong>search engine optimization</strong> (<strong>SEO</strong>) and link generation, without having to worry about how the files are physically organized in the server. In the ASP.NET Core MVC framework, routing is defined in the <kbd>Microsoft.AspNetCore.Mvc.Routing</kbd> namespace.</p>
<p class="lf-text-block lf-block x-hidden-focus">Let's look at the code map diagram for routing:</p>
<div class="CDPAlignCenter CDPAlign"><img height="422" width="479" src="assets/459bbd68-f5a2-4208-8134-ae8d20685d16.png"/></div>
<p>We see <kbd>HttpMethodAtribute</kbd>, which has the properties <kbd>Name</kbd>, <kbd>Template</kbd>, <kbd>HttpMethods,</kbd>and <kbd>Order</kbd> apart from the constructor. We see <kbd>UrlHelperFactory</kbd>, <kbd>UrlHelper</kbd>, <kbd>RouteValueAttribute</kbd>, and <kbd>KnownRouteValueConstraint</kbd> with their properties, constructors, and methods. <span>Routing is the mechanism through which incoming requests are mapped to controllers and actions, that is, the controller and action can be deduced from the request URL.</span></p>
<p>For example, consider the request URL as <kbd>http://localhost:9596/packt/Books/Index</kbd>.</p>
<p>This maps to the books controller and index action. This mapping of controller and action from the request URL is the job of routing.</p>
<p><span>We already discussed that MVC is itself injected as a middleware in the request pipeline. The routing middleware makes use of routing templates to do the mapping. An example of a simple routing template is shown in the following code: <kbd>packt/{controller=Home}/{action=Index}/{id?}</kbd>.</span> Routing templates use literals and tokens. Literals are matched exactly to the text in URL, whereas tokens are replaced when matching a route. Tokens are enclosed in <kbd>{}</kbd>. In the preceding example, we have three tokens:</p>
<ul>
<li><strong>Controller token:</strong> <kbd><span>{controller=Home}</span></kbd></li>
<li><strong>Action token:</strong> <kbd><span>{action=Index}</span></kbd></li>
<li><strong>ID token:</strong> <kbd><span>{id?}</span></kbd></li>
</ul>
<p>And <kbd>packt</kbd> is the literal which would be matched with the requested URL.</p>
<p>Matching a template requires a controller token and action token, as this is the key information routing middleware needs to locate the controller and action. Other tokens in the URL are mapped to the parameters of action methods using model binding, which we will see later. When adding a route mapping, default values can be provided for tokens. In the preceding example, <kbd>Home</kbd> is the default value of the controller token and <kbd>Index</kbd> is the value of the action token. Templates can also provide optional tokens for action parameters, such as <kbd>{id?}</kbd>. <kbd>?</kbd>, which here indicates that it is optional.</p>
<p>Now suppose a client requests the following URL:</p>
<pre>http://localhost:9596/packt/Books/Index/2</pre>
<p>This URL would match the preceding template and would invoke the <kbd>Index</kbd> action with the <kbd>id</kbd> value as <kbd>2</kbd> on the <kbd>Books</kbd> controller. So, the code of <kbd>BooksController</kbd> would be roughly like:</p>
<pre>public class BooksController: Controller<br/>{<br/>    public IActionResult Index(int id)<br/>    {<br/>         return this.View();<br/>    }<br/>}</pre>
<p>The following client requests would also be served:</p>
<ul>
<li><kbd>http://localhost:9596/packt/Books/Index</kbd>: The <kbd>id</kbd> parameter is optional</li>
<li><kbd>http://localhost:9596/packt/Books</kbd>: The default value of the <kbd>Index</kbd> would be used for the action</li>
<li><kbd>http://localhost:9596/packt</kbd>: The default value of the <kbd>Home</kbd> would be used for the controller and the <kbd>Index</kbd> for the action</li>
</ul>
<p>These were all happy path scenarios, but what if the URL is <kbd>http://localhost:9596/packt/Books/Index/.NETCore2.0ByExample?</kbd></p>
<p>In this case, the controller would resolve to <kbd>BooksController</kbd>, and the action would resolve to <kbd>Index</kbd>. However, the last parameter is defined as <kbd>int</kbd>, which is not what we want. To ensure that <kbd>id</kbd> is always an integer for the mapping, we can use route constraint, as shown here:</p>
<pre>packt/{controller=Home}/{action=Index}/{id:int?}</pre>
<p>This ensures that the route maps to action only if <kbd>id</kbd> is specified as an optional <kbd>int</kbd>; otherwise, the URL would not map to this route. There are lots of constraints that can be used, such as:</p>
<ul>
<li><kbd>:bool</kbd></li>
<li><kbd>:datetime</kbd></li>
<li><kbd>:decimal</kbd></li>
<li><kbd>:guid</kbd></li>
<li><kbd>:int</kbd></li>
<li><kbd>:length(min,max)</kbd></li>
</ul>
<p>The comprehensive list of constraints can be seen in Microsoft route constraint reference at:&#160;<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference</a>.<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference"></a></p>
<div class="packt_infobox">The URL strings are case-insensitive, so <kbd>packt</kbd> and <kbd>Packt</kbd> are treated the same.</div>
<p><span>The following is the code map diagram of</span> <kbd>RouterMiddleware</kbd> <span>and the extensions to use for this middleware:</span></p>
<div class="lf-text-block lf-block CDPAlignCenter CDPAlign"><img height="271" width="435" src="assets/18685ea8-8c87-4c17-ba3d-66ed2b10e534.png"/></div>
<p>Now that we know about routing middleware and how the routing template works, let's look at the types of routing. Broadly speaking, there are the following types of routing:</p>
<ul>
<li>Convention-based routing</li>
<li>Attribute routing</li>
<li>Mixed routing;&#160;that is, a combination of the preceding two types</li>
</ul>
<div>
<p class="lf-text-block lf-block x-hidden-focus"><strong>Convention-based routing</strong>&#160;enables us to define the URL formats, which are understood by the application. Convention-based routing also lets us define how each of the URL formats maps to a specific action method on a controller. Once a request is received, the routing engine parses the URL and matches it to one of the defined URL formats. Based on the url format, the controller and action method is mapped and invoked by the routing engine. The code example that can be used in the&#160;<kbd>UseMvc</kbd> method that takes the&#160;<kbd>routeBuilder</kbd> action as a parameter in the&#160;<kbd>Configure</kbd> method of Startup.cs is as follows:</p>
<pre> routes.MapRoute(<br/>                   name: "default",<br/>                   template:   <br/>                   "packt/{controller=Home}/{action=Index}/{id?}"<br/>                );</pre>
</div>
<p>The preceding method adds a route named <kbd>"default"</kbd>. We can specify multiple named routes and templates, and these would be executed in the order in which they are defined.</p>
<p><span>The <kbd>MapRoute</kbd>&#160;method has several overloads. These can be seen in the following documentation:</span></p>
<pre>//<br/>// Summary:<br/>// Provides extension methods for Microsoft.AspNetCore.Routing.IRouteBuilder to<br/>// add routes.<br/>public static class MapRouteRouteBuilderExtensions<br/>{<br/>    //<br/>    // Summary: Adds a route to the  <br/>       Microsoft.AspNetCore.Routing.IRouteBuilder with the specified<br/>    // name and template.<br/>    //<br/>    // Parameters:<br/>    // routeBuilder: The Microsoft.AspNetCore.Routing.IRouteBuilder to <br/>       add the route to.<br/>    // name: The name of the route.<br/>    // template: The URL pattern of the route.<br/>    // Returns: A reference to this instance after the operation has <br/>       completed.<br/>    public static IRouteBuilder MapRoute(this IRouteBuilder <br/>    routeBuilder, string name, string template);<br/>    //<br/>    // Summary: Adds a route to the <br/>       Microsoft.AspNetCore.Routing.IRouteBuilder with the specified<br/>    // name, template, and default values.<br/>    //<br/>    // Parameters:<br/>    // routeBuilder: The Microsoft.AspNetCore.Routing.IRouteBuilder to <br/>       add the route to<br/>    // name: The name of the route<br/>    // template: The URL pattern of the route<br/>    // defaults: An object that contains default values for route <br/>       parameters. The object's properties<br/>    // represent the names and values of the default values.<br/>    // Returns: A reference to this instance after the operation has <br/>       completed.<br/>    public static IRouteBuilder MapRoute(this IRouteBuilder <br/>    routeBuilder, string name, string template, object defaults);<br/>    //<br/>    // Summary: Adds a route to the <br/>       Microsoft.AspNetCore.Routing.IRouteBuilder with the specified<br/>    // name, template, default values, and constraints.<br/>    //<br/>    // Parameters:<br/>    // routeBuilder: The Microsoft.AspNetCore.Routing.IRouteBuilder to <br/>       add the route to.<br/>    // name: The name of the route.<br/>    // template: The URL pattern of the route.<br/>    //<br/>    // defaults:<br/>    // An object that contains default values for route parameters. The <br/>       object's properties<br/>    // represent the names and values of the default values.<br/>    //<br/>    // constraints:<br/>    // An object that contains constraints for the route. The object's <br/>       properties represent<br/>    // the names and values of the constraints.<br/>    //<br/>    // Returns:<br/>    // A reference to this instance after the operation has completed.<br/>    public static IRouteBuilder MapRoute(this IRouteBuilder <br/>    routeBuilder, string name, string template, object defaults, object <br/>    constraints);<br/>    //<br/>    // Summary:<br/>    // Adds a route to the Microsoft.AspNetCore.Routing.IRouteBuilder <br/>       with the specified<br/>    // name, template, default values, and data tokens.<br/>    //<br/>    // Parameters:<br/>    // routeBuilder:<br/>    // The Microsoft.AspNetCore.Routing.IRouteBuilder to add the route <br/>       to.<br/>    //<br/>    // name:<br/>    // The name of the route.<br/>    //<br/>    // template:<br/>    // The URL pattern of the route.<br/>    //<br/>    // defaults:<br/>    // An object that contains default values for route parameters. The <br/>       object's properties<br/>    // represent the names and values of the default values.<br/>    //<br/>    // constraints:<br/>    // An object that contains constraints for the route. The object's <br/>       properties represent<br/>    // the names and values of the constraints.<br/>    //<br/>    // dataTokens:<br/>    // An object that contains data tokens for the route. The object's <br/>       properties represent<br/>    // the names and values of the data tokens.<br/>    //<br/>    // Returns:<br/>    // A reference to this instance after the operation has completed.<br/>    public static IRouteBuilder MapRoute(this IRouteBuilder <br/>    routeBuilder, string name, string template, object defaults, object <br/>    constraints, object dataTokens);<br/>}</pre>
<p><strong>Attribute routing</strong> can be used to describe routing information by decorating the attributes on the controller and actions.<span>&#160;This means that the route definitions of the controller are placed adjacent to the controller and action tokens with which they're associated. This is done by using the <kbd>Route</kbd> attribute, which contains the route of the <kbd>controller</kbd>, as shown in the following code:</span></p>
<pre><strong>[Route("packt/[controller]")]</strong><br/>public class BooksController : Controller<br/>{<br/>  [HttpGet("{id}")]<br/>  public IActionResult GetBook(int id)<br/>  {<br/>    //// Code hidden for brevity.<br/>  }<br/>}</pre>
<p>We can also use any of the <kbd>Http</kbd> verbs, such as <kbd>HttpGet</kbd>, <kbd>HttpPut</kbd>, <kbd>HttpPost</kbd>, <kbd>HttpDelete</kbd>, and so on, to specify the attribute-based routes. The following code snippet illustrates the route specified for the <kbd>Index</kbd> action. Also note that we have multiple <kbd>HttpGet</kbd> attributes applied to the action, showing that multiple routes can map to a single action:</p>
<div>
<pre><strong>[Route("packt/[controller]")]</strong><br/>public class BooksController : Controller<br/>{<br/>  <strong>[HttpGet("index")]</strong><br/><strong>  [HttpGet("~/")]</strong><br/><strong>  [HttpGet("")]</strong></pre>
<pre>  public IActionResult Index()<br/>  {<br/>    //// Code hidden for brevity.<br/>  }<br/>}</pre>
<p>These <kbd>HttpGet</kbd> attributes with routes are referring to the following URL path. For example, if we are passing a blank inside <kbd>HttpGet</kbd>, it is taking us to the&#160;<kbd>http://localhost:9596/packt/Books</kbd> path and if we are passing <kbd>HttpGet("index")</kbd>, it will refer until the index page:</p>
</div>
<ul>
<li><kbd>[HttpGet("index")]</kbd> matches <kbd>http://localhost:9596/packt/Books/index</kbd></li>
<li><span><kbd>[HttpGet("")]</kbd> matches <kbd>http://localhost:9596/packt/Books</kbd>; that is, the default <kbd>action</kbd> of <kbd>controller</kbd></span></li>
<li><span><kbd>[HttpGet("~/")]</kbd> matches <kbd>http://localhost:9596/packt/Books</kbd>; that is, the default <kbd>action</kbd> of <kbd>controller</kbd></span></li>
</ul>
<p>Since we can have multiple routes, ordering can be applied to the route attributes to execute a general route or specific route as needed. The framework would look at the <kbd>Order</kbd> property and execute the routes in ascending order. The default <kbd>Order</kbd> of <kbd>0</kbd> would execute, followed by the route that is immediately higher than it, and so on.</p>
<p><strong>Mixed routing</strong> is a perfectly valid scenario as based on the requirements; we may have convention-based routing in some controllers and actions and attribute routing for others. However, we cannot have both for the same action. If an action uses attribute routing, no convention-based routes can map to that action.&#160;<span>Placing a route attribute on the controller or the action makes it attribute routed. Actions that define attribute routes cannot be reached through the conventional routes and vice-versa.</span></p>
<p>Next in the pipeline, after the request is routed, it maps to a controller action. We will close our discussion on routing here. The next hop on the request pipeline diagram is the authorization filter. We will skip it for now and discuss it when we discuss filters later in the chapter. Let's discuss model binding now, which comes into the picture after the authorization filter.</p>
<p>The request may be a <kbd>PUT</kbd>, <kbd>POST</kbd>, <kbd>DELETE</kbd>, or <kbd>GET</kbd> operation and, based on the operation it is meant to handle, the action may have parameters, which need to be populated by the framework from the client request data. The component that does this conversion is called the model binder. Let's have a look at it.&#160;</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Model binding</h1>
                </header>
            
            <article>
                
<p>As discussed, model binding maps the data from HTTP requests to action method parameters. These parameters, like any other C# method, can be simple types, such as <kbd>int</kbd>, <kbd>long</kbd>, <kbd>decimal</kbd>, <kbd>string</kbd>, or the complex classes. ASP.NET Core MVC has abstracted this logic away from the developers so that they need not worry about this request data to parameter conversion. This conversion is done by the framework in a predefined order. Let's look at how the framework does this. The following is the code map diagram of the model binding subsystem:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/57145395-eb03-4383-b1bc-91726772f010.png"/></div>
<p>Important things to notice in the diagram are:</p>
<ul>
<li><kbd>ParameterBinder</kbd></li>
<li><kbd>ValueProvider</kbd> factories</li>
<li>Value providers</li>
<li>Attributes</li>
<li>Extensions</li>
</ul>
<p>The framework tries to bind the request data to the action parameters by name. To do so, it looks at the values for each parameter using the parameter name and the names of its public settable properties. In the preceding <kbd>GetBook</kbd> request URL example, the only action parameter was named <kbd>id</kbd>, which the framework binds to the value with the same name in the route values. The ASP.NET Core MVC framework&#160;<span>uses three primary value providers or data sources to map HTTP request data to action parameters, in the following order:</span></p>
<ol>
<li><strong>Form values</strong> <strong>(using</strong> <kbd>FormValueProvider</kbd><strong>)</strong>: The values in the form that came in the HTTP request body. These would generally be in <kbd>HttpPost</kbd> or <kbd>HttpPut</kbd></li>
</ol>
<ol start="2">
<li><strong>Route values (using</strong> <kbd>RouteValueProvider</kbd><strong>)</strong>: The values provided by the routing subsystem, which executes just before model binding is used</li>
<li><strong>Query string (using</strong> <kbd>QueryStringValueProvider</kbd><strong>)</strong>: The values found in the request URL query string are used</li>
</ol>
<p>All the preceding data is stored in name value pairs in corresponding dictionaries. If, after performing this exercise, the model binding fails for some reason, it does not throw an exception; it just sets the <kbd>IsValid</kbd> property of <kbd>ModelState</kbd> to <kbd>false</kbd>. It's up to the action method to handle such scenarios.</p>
<p>Apart from the default model binding, the framework also provides a customized way to accomplish model binding by using attributes that we noted in the preceding code map diagram. We can use these attributes to alter the binding behavior of the property of a complex object, which is used as an action parameter, or to the parameter itself directly. Let's look at these attributes:</p>
<ul>
<li><kbd>[BindNever]</kbd>: This tells the model binder to ignore this parameter from binding</li>
<li><kbd>[BindRequired]</kbd>: This attribute adds a model state error if the binding fails</li>
<li><kbd>[FromBody]</kbd>: This tells the model binder to bind the data from the request body</li>
<li><kbd>[FromForm]</kbd>: This tells the model binder that the value should be fetched through the form data</li>
<li><kbd>[FromHeader]</kbd>: This tells the model binder that value should be fetched through a header</li>
<li><kbd>[FromQuery]</kbd>: This tells the model binder that the value should be fetched through a query string</li>
<li><kbd>[FromRoute]</kbd>: This tells the model binder that the value should be fetched through the route data</li>
<li><kbd>[FromServices]</kbd>: This tells the model binder that dependency injection should be used to bind the parameter</li>
<li><kbd>[ModelBinder]</kbd>: This attribute is used to override the default model binder, binding the source and name</li>
</ul>
<p>The next hop of the request is validation, so let's have a look at validation.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Validation</h1>
                </header>
            
            <article>
                
<p>Validation is one of the key operations for any app working with data. Before we persist the data to the persistent store (database/filesystem), we should ensure the sanctity of the data, its format, type, size, and check if it complies to our rules and doesn't pose any potential security threat. This is ensured through validation. This can be done at both the client and server side. I am a firm believer that validation should be performed at both the client and server side. The validation has been abstracted from the developers into validation attributes, which reduces the amount of code needed to perform the validation. Validation attributes are C# attributes that derive from <kbd>ValidationAttribute</kbd>. Most of the commonly used validation attributes can be found in the <kbd>System.ComponentModel.DataAnnotations</kbd> namespace. In case the already provided attribute does not suffice our needs, we can do either of the following:</p>
<ul>
<li>Create a new custom validation attribute that derives from <kbd>ValidationAttribute</kbd></li>
<li>Implement the interface <kbd>IValidatableObject</kbd> in our model class</li>
</ul>
<p>The following code map diagram illustrates both the <kbd>ValidationAttribute</kbd> as well as the&#160;<kbd>IValidatableObject</kbd> interface:</p>
<div class="CDPAlignCenter CDPAlign"><img height="437" width="664" src="assets/b24d3896-f861-4c5c-96cb-ee1ac49a9333.png"/></div>
<p><kbd>IValidatableObject</kbd> is a simple interface with just the<kbd>Validate</kbd>&#160;method, while <kbd>ValidationAttribute</kbd> has a lot more to offer for customization and has <kbd>IsValid</kbd>, <kbd>Validate</kbd>, and&#160;<kbd>GetValidationResult</kbd> methods along with properties to meet the validation needs. We also see that there are numerous attributes already defined and derived from <kbd>ValidationAttribute</kbd>. Some of the most important ones are:</p>
<ul>
<li><kbd>UrlAttribute</kbd>: Validates that the property has a valid URL.</li>
<li><kbd>PhoneAttribute</kbd>: Validates that the property has a telephone format.</li>
<li><kbd>FileExtensionsAttribute</kbd>: Validates that the file extensions are valid as per the predefined set of file extensions.</li>
<li><kbd>EmailAddressAttribute</kbd>: Validates that the property has a valid email format.</li>
<li><kbd>CreditCardAttribute</kbd>: Validates that the property has a credit card format.</li>
<li><kbd>DataTypeAttribute</kbd>: Validates that the property has a valid data type, as specified by passing the <kbd>DataType</kbd> enumeration value. The <kbd>DataType</kbd> enumeration value can be seen at the top part of the preceding image.</li>
<li><kbd>RangeAttribute</kbd>: Validates that the property value falls within the specified range.</li>
<li><kbd>RegularExpressionAttribute</kbd>: Validates that the property value matches the given regular expression.</li>
<li><kbd>RequiredAttribute</kbd>: Makes a property mandatory and hence the user would always have to provide its value.</li>
<li><kbd>CompareAttribute</kbd>: Validates two properties in a model match.</li>
<li><kbd>StringLengthAttribute</kbd>: Validates that the string property value length does not exceed the maximum length.</li>
</ul>
<p>Applying only validation attributes to the model properties is not sufficient to perform the validation; we should ensure that on the server side in our action method, we also perform the <kbd>ModelState.IsValid</kbd> check to ensure that the input data validation passed or failed and act accordingly for pass and failed cases. The ASP.NET MVC Core framework sets the <kbd>ModelState</kbd> dictionary with errors after it performs the model binding from the HTTP request; if the validation does not pass,&#160;<kbd>ModelState.IsValid</kbd><span>&#160;would be false even if there is one validation error.</span> This happens before the action execution starts, so we have the validation result available as soon as we enter the action method code. The framework, by default, continues validating properties until it reaches a maximum count of <kbd>200</kbd>. This number is configurable though by writing the following code in the&#160;<kbd>ConfigureServices</kbd> method of the <kbd>Startup.cs</kbd> method, which sets the maximum count to <kbd>20</kbd>:</p>
<pre><span>services.AddMvc(options =&gt; options.MaxModelValidationErrors = 2</span><span class="hljs-number">0</span><span>);</span></pre>
<p>In case we wish to perform some validations after the model binding and validations are completed, we can do so by manually invoking the validation using:&#160;<kbd>TryValidateModel(&lt;&lt;model to validate&gt;&gt;)</kbd>.</p>
<p>All this time, what we saw was the server-side validation, which involves a round trip to the server and hence takes time, so to do an additional validation in the client side makes sense so that if the validation fails, we do not even send the request to the server. We will have a quick discussion about client-side validation when we look at the Views, later in the chapter. Now that we have the concept and theory in mind, let's do a quick implementation of the validation. Suppose we want to validate the book information, such as name, author, description, <span>publisher,&#160;</span>pages, release date, price, and so on, before saving the book information to the database. To do so, let's create a model and controller. The model would look like this:</p>
<pre>public class Book<br/>{<br/>    public int Id {get;set;}<br/>    <br/>    [Required]<br/>    [StringLength(100)]<br/>    public string Name {get;set;}<br/><br/>    [Required]<br/>    [StringLength(50)]<br/>    public string Author {get;set;}<br/><br/>    [Required]<br/>    [StringLength(1000)]<br/>    public string Description {get;set;}<br/><br/>    [Required]<br/>    [StringLength(50)]<br/>    public string Publisher {get;set;}<br/>    <br/>    //// No point of having required attribute here as its a value type <br/>         and has a default value.<br/>    public int Pages {get;set;}<br/><br/>    [DataType(DataType.Date)]<br/>    public DateTime ReleaseDate {get;set;}<br/>    <br/>    [Range(0, 499.99)]<br/>    public decimal Price {get;set;}<br/>}</pre>
<p>And the controller would look like this:</p>
<pre>public class BooksController: Controller<br/>{<br/>    [HttpPost]<br/>    public IActionResult SaveBookInfo(Book model)<br/>    {<br/>         if(this.ModelState.IsValid)<br/>         {<br/>            /// Code for successful validation.<br/>         }<br/>         else<br/>         {<br/>            //// Code for failed validation.<br/>            return this.View(model);<br/>         }<br/>    }<br/>}</pre>
<p>As we can see, there are two paths in the <kbd>SaveBookInfo</kbd> method. If <kbd>ModelState.IsValid</kbd>&#160;is true, the data is valid and the data can be saved to the persistent storage; otherwise, we return to the same <kbd>View</kbd>. Generally, the <kbd>View</kbd> would have a validation summary that would display the validation errors.</p>
<p>That's it! It is this easy to implement server-side validation. This concludes our discussion on validation. Let's move on to filters.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Filters</h1>
                </header>
            
            <article>
                
<p>Filters in ASP.NET Core MVC are the places where we can run the code before or after the action execution in the request processing pipeline. Filters run within the MVC action invocation pipeline, also known as&#160;<strong>filter pipeline</strong>. This pipeline comes into View after the framework chooses the action to be executed.</p>
<p>The following list view code map diagram illustrates the actors involved in filters:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7710e46c-b1fc-406b-9794-93343b071a91.png"/></div>
<p>On the right, we have attributes defined, which are abstract classes. On the left, there are abstractions and context classes. The filters execute at different stages in the action execution pipeline, based on the type of filter, which can be:</p>
<ul>
<li><strong>Authorization filters</strong>: These are the implementation of <kbd>IAuthorizationFilter</kbd>/<kbd>IAsyncAuthorizationFilter</kbd> and are run first to determine if the current user is authorized or not. They can short circuit the pipeline if the user in unauthorized.</li>
<li><strong>Resource filters</strong>: These are the implementation of <kbd>IResourceFilter</kbd>/<kbd>IAsyncResourceFilter</kbd> and are run immediately after the authorization filters. When these filters execute, model binding has not taken place in the pipeline so they&#160;can be used to alter the model binding. The most common use of these filters is that of caching.</li>
<li><strong>Action filters</strong>: These filters are the implementation of <kbd>IActionFilter</kbd>&#160;/&#160;<kbd>IAsyncActionFilter</kbd> or <kbd>ActionFilterAttribute</kbd> and are run immediately before and after an action execution. Due to their location in the pipeline, they are well-suited for any manipulation to action method parameters as well as to returned results from the action.</li>
<li><strong>Exception filters</strong>: These filters are the implementation of <kbd>IExceptionFilter</kbd> / <kbd>IAsyncExceptionFilter</kbd> or <kbd>ExceptionFilterAttribute</kbd> and are used to apply exception handling to the code before the response is written.</li>
<li><strong>Result filters</strong>: These are the implementation of <kbd>IResultFilter</kbd>&#160;/&#160;<kbd>IAsyncResultFilter</kbd> or <kbd>ResultFilterAttribute</kbd> and are run immediately before and after the execution of individual action results. They are run only if the action method successfully executes.</li>
</ul>
<p>If we look closely, we can notice that there are multiple ways to implement the filter. There is filter interface, then there is async filter interface, and we have abstract attribute classes that we can implement. The framework first checks if the filter implements an async interface. If it does, it calls the async methods of the filter. If not, it calls the non-async methods, so either an async or synchronous interface should be implemented. If we implement both, only the async implementation would be called. This is also the case when we implement the abstract class. To summarize, the following is what the filter pipeline looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img height="341" width="226" src="assets/070d624a-8144-444e-b977-1debf8274afb.png"/></div>
<p>We should write our custom filters based on the preceding flow, so that the desired operation code can be written at the right place in the filter pipeline. Next, we will see an implementation of the sample filter and different ways to implement a filter.</p>
<ol>
<li>&#160;Derive from <kbd>Attribute</kbd> and implement <kbd>IActionFilter</kbd>—filters are implemented as attributes and hence we need to derive from <kbd>Attribute</kbd> and implement <kbd>IActionFilter</kbd> for the class to be treated as a filter:</li>
</ol>
<pre><span class="hljs-keyword">using</span><span> Microsoft.AspNetCore.Mvc.Filters; //// required namespace</span><br/><br/>public class BookPublishingFilter: Attribute, IActionFilter<br/>{<br/>     public void OnActionexecuting(ActionExecutingContext context)<br/>     {<br/>        //// Write code to be executed, before the action method is <br/>             called.<br/>     }<br/><br/>     public void OnActionexecuted(ActionExecutedContext context)<br/>     {<br/>        //// Code to be executed, after the action method is called.<br/>     }     <br/>}</pre>
<ol start="2">
<li>Derive from <kbd>ActionFilterAttribute</kbd>—the <kbd>ActionFilterAttribute</kbd> class already derives from the&#160;<kbd>Attribute</kbd> class and implements <kbd>IActionFilter</kbd> and hence we can directly derive from <kbd>ActionFilterAttribute</kbd> and create a filter attribute. So, the preceding code would remain the same apart from the base class and interface with which we need to derive:</li>
</ol>
<pre><span class="hljs-keyword">using</span><span> Microsoft.AspNetCore.Mvc.Filters; //// required namespace</span><br/><br/>public class BookPublishingFilter: ActionFilterAttribute <br/>{<br/>     public void OnActionexecuting(ActionExecutingContext context)<br/>     {<br/>        //// Write code to be executed, before the action method is <br/>             called.<br/>     }<br/><br/>     public void OnActionexecuted(ActionExecutedContext context)<br/>     {<br/>        //// Code to be executed, after the action method is called.<br/>     }     <br/>}</pre>
<p>There are few other ways to define the action filters, but we will not discuss them here. They can be seen from the reference link shared towards the end of the section. Likewise, Exception filters can be created by deriving from <kbd>ExceptionFilterAttribute</kbd>, <kbd>ResultFilter</kbd> by deriving from <kbd>ResultFilterAttribute</kbd>, and so on.</p>
<p>For consuming the filters, they can be registered globally in the&#160;<kbd>ConfigureServices</kbd> method in the <kbd>Startup.cs</kbd> or by decorating the filter attribute in the controller or action, which is shown as follows:</p>
<pre>//// Register the filter globally. This would be invoked for all <br/>     controller actions.<br/>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddMvc(options =&gt;<br/>    {        <br/>        options.Filters.Add(typeof(BookPublishingFilter)); // by type<br/>         //// Use either above line or below line, not both. Here both <br/>              are shown to demonstrate ways in which it can be done.<br/>        options.Filters.Add(new BookPublishingFilter()); // an instance<br/>    });<br/>}<br/><br/>//// Register the filter only at action where it is needed. If it is <br/>     applied in controller, it applies to all actions.<br/>[BookPublishingFilter]<br/>public IActionResult GetUnpublishedBooks()<br/>{<br/>}</pre>
<p>Since the filters can be registered both globally and at action level also, a definite question comes to mind, which is: in what order do they execute? The answer is simple:</p>
<ul>
<li>The action executing method of global filters runs first, then of action executing methods of filters registered at controller runs, and finally action executing methods of filters registered at action level.</li>
<li>While returning from action, the order is the other way round. The action executed method of filter registered at action level runs first, then action executed method of filter registered at controller level, and finally the action executed method of filter registered globally.</li>
<li>This is also referred to as Nesting Doll or Russian Doll model.</li>
<li>This is the default behaviour. ASP.NET Core provides a way to override the default order of execution by implementing <kbd>IOrderedFilter</kbd>, which exposes an <kbd>Order</kbd> property, specifying which can override the default order of execution.&#160;</li>
</ul>
<p>For a detailed and thorough discussion on filters, please read the documentation of filter at:&#160;<a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters</a>.</p>
<p>With this note, we will move on to our next topic: Controllers.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controllers</h1>
                </header>
            
            <article>
                
<p>Broadly speaking, a controller is a class with a group of methods called actions. An action, also known as an action method, is a method that handles the request. As per the convention used by the ASP.NET Core MVC framework, a controller is a class that:</p>
<ul>
<li>Is instantiable; that is, an instance of that class can be created</li>
<li>Resides in the project's root-level folder, named <kbd>Controllers</kbd></li>
<li>Inherits from an abstract class,&#160;<kbd>Microsoft.AspNetCore.Mvc.Controller</kbd></li>
</ul>
<p>The framework is flexible and would also treat an instantiable class as a controller if any one or more of the following holds good:</p>
<ul>
<li>The class is decorated with the&#160;<kbd>[Controller]</kbd> attribute</li>
<li>The class name is suffixed with <kbd>Controller</kbd>, such as <kbd>HomeController</kbd></li>
<li>The class derives from a class, whose name ends with <kbd>Controller</kbd></li>
</ul>
<p>An important thing to note here is that we have a controller defined, even if we do not derive our controller from the&#160;<kbd>Controller</kbd> class.&#160;As discussed earlier, the role of a controller is to validate the request data and return the result in the form of a View or data. In the ASP.NET Core MVC project structure, we can see a <kbd>Controllers</kbd> folder at the project root level, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="197" width="270" src="assets/1351f77d-3710-4989-ad96-98ae345c4d60.png"/></div>
<p>Let's have a look at the code map diagram of the&#160;<kbd>Controller</kbd> class to understand it better:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/23bfd90e-9b99-4e1c-8433-d7b3d455d99e.png"/></div>
<p>The diagram reveals that the <kbd>Controller</kbd> class itself derives from the&#160;<kbd>ControllerBase</kbd> class, by which it gets access to <kbd>HttpContext</kbd> and <kbd>ControllerContext</kbd> properties. It has properties for <kbd>TempData</kbd>, <kbd>ViewData</kbd>, and <kbd>ViewBag</kbd>, which we will discuss when we discuss the Views in the next chapter. The class contains a bunch of methods, mostly for returning action results and executing action filters. Let's have a look at them:</p>
<ul>
<li><kbd>PartialView</kbd>:&#160;Creates a <kbd>Microsoft.AspNetCore.Mvc.PartialViewResult</kbd> object that renders a partial View to the response</li>
<li><kbd>View</kbd>:&#160;Creates a <kbd>Microsoft.AspNetCore.Mvc.ViewResult</kbd> object that renders a View to the response</li>
<li><kbd>Json</kbd>: Creates a <kbd>Microsoft.AspNetCore.Mvc.JsonResult</kbd> object that serializes the data to JSON</li>
<li><kbd>ViewComponent</kbd>:&#160;Creates a <kbd>Microsoft.AspNetCore.Mvc.ViewComponentResult</kbd> by specifying the name of a View component to render</li>
<li><kbd>OnActionExecuting</kbd>: Called before the action method is invoked</li>
<li><kbd>OnActionExecuted</kbd>: Called after the action method is invoked</li>
<li><kbd>OnActionExecutionAsync</kbd>: Called before the action method is invoked in an async implementation</li>
</ul>
<p>Not all methods defined in the&#160;<kbd>Controller</kbd> class are actions. Only <kbd>public</kbd> methods which are not decorated with the&#160;<kbd>[NonAction]</kbd> attribute are actions. An action method can return anything, but generally, we will see them return an instance of <kbd>IActionResult</kbd> (or <kbd>Task&lt;IActionResult&gt;</kbd> for <kbd>async</kbd> methods). An action method decides the kind of response it would return; it may be a View or formatted response data, such as JSON, or anything else.</p>
<p>With the intent of separation of concerns and loose coupling, the <kbd>Controller</kbd> class should always have the dependencies injected to it, rather than creating the instance of it. If a type or service is required for only one action method, we can use the injection of a service directly in the action by using the <kbd>[FromServices]</kbd> attribute that we saw earlier; otherwise, the construction injection should be used.</p>
<p>We will end our lap around MVC with an overview of error handling.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Error handling</h1>
                </header>
            
            <article>
                
<p>Error handling is a particularly important piece in any reliable and stable software application, and ASP.NET Core applications are no different. The error handling strategy differs while the app is under development and when it is deployed. While developing, the developer wants to see highly detailed error messages so that he/she can go to the crux of the issue and fix it.</p>
<p>However, such a level of detailing would not be great in production as the end user would not understand any of that and it would give hackers too much information, which they could utilize to compromise your app. Also, the end user would rather appreciate a user-friendly message than some stack trace, which would be Greek to them.</p>
<p>So, we display a developer exception page in the development environment and a more user-friendly error screen in the production environment. The old school ASP.NET programmers may be able to link this to the custom errors flag in the ancient versions of ASP.NET. Let's see how we can configure these pages.</p>
<p>To configure an app to display an error page to display the detailed exception, we need to have the&#160;<kbd>Microsoft.AspNetCore.Diagnostics</kbd> namespace. We need to add the following code in our <kbd>Configure</kbd> method of <kbd>Startup.cs</kbd>. Notice that this should be added before adding any other middleware, so that all the exceptions from the subsequently executed middleware are caught:</p>
<pre>if (env.IsDevelopment())<br/>{<br/>    app.UseDeveloperExceptionPage();<br/>}<br/>else<br/>{<br/>    app.UseExceptionHandler("/error");<br/>}</pre>
<p>In case of an exception in the development environment, the developer exception page would be displayed, as shown in the following screenshot.&#160;I used the classical and easiest code to simulate the exception here—<kbd>divide by zero</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="605" width="542" src="assets/c58bfc06-3678-4b93-992f-3bc29c8a79b3.jpg"/></div>
<p>Notice that it has four tabs:</p>
<ul>
<li><span class="packt_screen">Stack</span>: Displays the stack trace of the error</li>
<li><span class="packt_screen">Query</span>: Displays the query string of the request</li>
<li><span class="packt_screen">Cookies</span>: Displays the cookies associated with a request, if any</li>
<li><span class="packt_screen">Headers</span>: Displays the header of the request, as shown in the following screenshot:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="161" width="618" src="assets/0d46657e-c83a-44bb-9b13-d0b64c59e32a.jpg"/></div>
<p>In a non-development environment, we will see a generic error page, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="139" width="566" src="assets/4d8afb44-70f1-431a-98be-b1c8693d1359.jpg"/></div>
<p>Please note, an error in an error page can also throw an exception, which, if not properly handled, can crash your app. So, we should try and keep the error page content static.</p>
<p>If any exceptions occur during the app startup, they can only be handled in the hosting layer. When the error occurs after the host address / port binding, hosting can only show an error page for such captured startup errors. If any port/address binding fails for any reason, such as the address/port is already in use, the hosting layer logs a critical exception, the dotnet process crashes, and no error page is displayed.</p>
<p>MVC error handling continues to work as it does, by using exception filters for exceptions and Model validations for validation failures. We have already seen these in our quick lap around MVC. We have one more important component of MVC, the visual element, Views, to discuss. We will discuss this when we do the implementation of our chat UI and Chat hub in the next chapter.</p>
<p><span>This wraps up our quick lap around MVC.&#160;</span>With all the fundamentals in place, we are now ready to dive into coding. We will begin by implementing authentication in our application, which we will do in the following section.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing authentication through Facebook</h1>
                </header>
            
            <article>
                
<p>Enough of the theory and samples. Time for us to convert the requirements into reality. We will start with the authentication module first. Recall that based on our discussion in the last chapter, this module needs to support a secure login, a forgotten password, as well as register user functionality. Once we are done with it, we will have completed a substantial part of our app, as per the following flowchart:</p>
<div class="CDPAlignCenter CDPAlign"><img height="320" width="343" src="assets/b1bb9f70-958e-48a4-8d49-ac00b2986611.jpg"/></div>
<p>We are going to leverage Facebook authentication to implement this module of our system. We could have used any of the other providers as well, such as Twitter, Google, Microsoft, and so on, but since it's a fun chat app, Facebook is most appropriate. In&#160;<a href="ch07.html">Chapter 7</a>, <em>To the Cloud</em>, we will see how we can support multiple authentication providers and let the user decide which provider they wish to use for authentication. To code this module, we will perform the following steps:</p>
<ol>
<li>&#160;To integrate Facebook with our app, we first need to create a Facebook App ID. So, go to <a href="https://developers.facebook.com/apps/">https://developers.facebook.com/apps/</a> and click on <span class="packt_screen">Add a New App</span>&#160;button. Please note, this requires us to sign in to our Facebook account, so you need to have a Facebook account to do this activity. If you don't have a Facebook account, please create one. On clicking the button, the following screen will display:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f5797887-6ce3-4378-9f47-cd93290de721.png"/></div>
<ol start="2">
<li>Enter <span class="packt_screen">Display Name</span> and&#160;<span class="packt_screen">Contact Email</span>, and click on the <span class="packt_screen">Create App ID</span> button. It will display a <strong>Completely&#160;Automated&#160;Public&#160;Turing Test to tell&#160;Computers and&#160;Humans A</strong><span><strong>part</strong> (</span><strong>CAPTCHA</strong>)&#160;verification page. On successful verification, the App ID will get created and a products page will be displayed, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="676" width="550" src="assets/94a8758d-0f66-4af1-b495-ce8420df401d.png"/></div>
<ol start="3">
<li>We need to choose <span class="packt_screen">Facebook Login</span>, so click on the <span class="packt_screen">Setup</span> button, which will display when we hover over <span class="packt_screen">Facebook Login</span>. On clicking <span class="packt_screen">Setup</span>, Facebook will display a select platform page, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="154" width="520" src="assets/32ddd279-1c18-4a19-b3d6-6fde3fad3225.png"/></div>
<ol start="4">
<li>Choose <span class="packt_screen">Web</span> and then enter the website URL in the next screen. This is the URL of your web app. Once we run our app using Visual Studio or <kbd>dotnet run</kbd>, we can see the URL (or we will directly see <kbd>launchSettings.json</kbd> or project properties). Copy the URL and paste it in the Site URL field, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="266" width="562" src="assets/1e84a9ec-d148-4705-907d-5c90748a1590.png"/></div>
<ol start="5">
<li>Click the <span class="packt_screen">Save</span> button. Now, click on the <span class="packt_screen">Facebook Login</span> on the left navigation panel in the <span class="packt_screen">PRODUCTS</span>&#160;section and make the following selections:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="237" width="472" src="assets/47716981-1afa-46c3-b5dd-5f725ed1763f.png"/></div>
<p style="padding-left: 60px">OAuth redirect URIs should be correct; otherwise, the flow will not work. There is no point in putting the lock on the door and keeping the key alongside, similarly, there is no point in using authentication and using an HTTP protocol for OAuth. The URI should be using an HTTPS protocol. This is a demo app, so I have used the HTTP protocol. However, for any non-demo app, we should always use HTTPS. We can provide multiple URLs in the OAuth redirect URIs, so once we publish the app to Azure, we would need to add one more URL here. With this, our Facebook app is set up. We need an App ID and App Secret, which we will copy by navigating to the <span class="packt_screen">Dashboard</span> of the app we just created. This can be done by clicking on the <span class="packt_screen">Dashboard</span> in the left-hand side navigation. Copy the <span class="packt_screen">App ID</span> and <span class="packt_screen">App Secret</span> in a notepad for our use:</p>
<div class="CDPAlignCenter CDPAlign"><img height="145" width="526" src="assets/bd67a454-4d6b-4556-ad14-06feff1934cd.png"/></div>
<p style="padding-left: 60px">With this, we are done with the app setup in Facebook. We will come back to the portal again when we make our app public and publish it to Azure. For now, we will start coding. As discussed earlier, we will make use of middleware to perform authentication. The pattern to use middleware is also very simple. First, add the middleware in the&#160;<kbd>ConfigureServices</kbd> method and then use it in the&#160;<kbd>Configure</kbd> method of <kbd>Startup.cs</kbd>. The framework takes care of most of the heavy lifting, so the coding part is quite simple as well, as we will see.</p>
<ol start="6">
<li><span>We will use Facebook and cookie authentication. To use them, we</span>&#160;add the following using directives in <kbd>Startup.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using Microsoft.AspNetCore.Authentication.Facebook;<br/>using Microsoft.AspNetCore.Authentication.Cookies;</pre>
<ol start="7">
<li>We need to use the App ID and App Secret to integrate Facebook authentication with our web app. To do so, we need to read the values of the App ID and App Secret. This can be done through reading from the <kbd>appsettings.json</kbd> or from the User Secret Manager tool in development. Essentially, these secrets should be kept way from the application code and real apps deployed on Azure should be fetched from the Azure Key-vault. We will use the User Secret Manager tool as well as Key-vault in <a href="ch07.html">Chapter 7</a>, <em>To the Cloud</em>. For the sake of simplicity, in this demo, we will make use of <kbd>asppsettings.json</kbd> to read these values (though its not recommended for actual systems), as shown here:</li>
</ol>
<pre style="padding-left: 60px"> "FacebookAuthenticationAppId": "148203862468266",<br/> "FacebookAuthenticationAppSecret": "&lt;&lt;App Secret&gt;&gt;"  //// Your App  <br/>  Secret goes here.</pre>
<ol start="8">
<li>In the <kbd>ConfigureServices</kbd> method of <kbd>Startup.cs</kbd>, we will write the following lines of code to add the authentication middleware and read the App ID and App Secret from configuration, by using the following code:</li>
</ol>
<pre style="padding-left: 60px">//// Configure Authentication, we will challenge the user, via Facebook and sign in via Cookie ////authentication, so setting the appropriate values.<br/>services.AddAuthentication(options =&gt;<br/>{<br/>  options.DefaultChallengeScheme = <br/>  FacebookDefaults.AuthenticationScheme;<br/>  options.DefaultSignInScheme = <br/>  CookieAuthenticationDefaults.AuthenticationScheme;<br/>  options.DefaultAuthenticateScheme =  <br/>  CookieAuthenticationDefaults.AuthenticationScheme;<br/>}).AddFacebook(options =&gt;<br/>  {<br/>     options.AppId = <br/>     this.Configuration["FacebookAuthenticationAppId"]; //// AppId<br/>     options.AppSecret =  <br/>     this.Configuration["FacebookAuthenticationAppSecret"]; // App <br/>     Secret<br/>   }).AddCookie();</pre>
<p style="padding-left: 60px" class="mce-root">The comments make it very clear that we would challenge the user through Facebook and sign in using cookie authentication. We have configured Facebook to use the App ID and App Secret from the <kbd>appsettings</kbd> and also added cookie authentication. Also, to keep the application secure, it's highly recommended that we always enforce SSL; that is, use HTTPS. We can do so with the following line of code, while adding MVC:</p>
<pre style="padding-left: 60px"> //// Since HTTPS is secure, lets make it mandatory, by using the RequireHttpsAttribute Filter<br/> services.AddMvc(options =&gt;<br/> {<br/>     options.Filters.Add(new RequireHttpsAttribute());<br/> });</pre>
<ol start="9">
<li>In the <kbd>Configure</kbd> method of <kbd>Startup.cs</kbd>, write the following code between <kbd>app.UseStaticFiles</kbd> and <kbd>app.UseMvc</kbd>:</li>
</ol>
<pre style="padding-left: 60px"> app.UseAuthentication();</pre>
<p style="padding-left: 60px">This ordering is important and will ensure that static resources, such as <kbd>js</kbd>, <kbd>css</kbd>, and <kbd>image</kbd> files, will not have to go through authentication. They would be served without authentication, while before any other page access request or authentication can kick in. If we run the app now, the authentication would still not kick in. We need to decorate the controller/controller action(s) with the&#160;<kbd>[Authorize]</kbd> attribute, which we only want the authenticated user to access. We can also configure this at the global level. We saw the sample for this in the last chapter.</p>
<ol start="10">
<li>We will decorate the <kbd>Index</kbd> action of <kbd>HomeController</kbd> with the&#160;<kbd>[Authorize]</kbd> attribute, so that we can challenge the user if he/she is not logged in, as shown here:</li>
</ol>
<pre style="padding-left: 60px"> public class HomeController : Controller<br/> {<br/>     <strong>[Authorize]</strong><br/>     public IActionResult Index()<br/>     {<br/>         return this.View();<br/>     }<br/>}</pre>
<p>Now, if we run the app and we have followed all the steps correctly so far, we will see the Facebook login page, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/941efabe-d5a8-4496-95d9-01bd8da0e2ab.png"/></div>
<p>It will also ask for permission to use the user profile, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="309" width="380" src="assets/548325e0-2d3b-4a35-8756-75389b3231ac.png"/></div>
<p>Click on <span class="packt_screen">Continue as</span> <kbd>&lt;your name&gt;</kbd> and we will be navigated to the <kbd>Index</kbd> page.</p>
<p>It's not a scaleable model to put <kbd>[Authorize]</kbd> on every controller as it is susceptible to mistakes. New developers adding a new controller may forget to do so and it may not be caught unless someone browses the URL for that controller, so it is recommended that we configure authentication in the <kbd>ConfigureServices</kbd> method of <kbd>Startup.cs</kbd>, as shown here:</p>
<pre>services.AddMvc(config =&gt;<br/>{<br/>    var policy = new AuthorizationPolicyBuilder()<br/>                     .RequireAuthenticatedUser()<br/>                     .Build();<br/>    config.Filters.Add(new AuthorizeFilter(policy));<br/>});</pre>
<p>After applying this policy, wherever we need non-authenticated access, we can insert the&#160;<kbd>[AllowAnonymous]</kbd> attribute. This is safer from a security perspective.</p>
<p>Now, we have a working login, with the option to register a user as well the provision to reset the password, if the user forgot it, without doing any custom coding. We can safely rely on Facebook to take care of this stuff. We will wrap up this module by seeing how we can do an explicit sign in and sign out, so that if we wish to sign out or sign in explicitly by clicking on a link or button, we can handle it. To do so, we will add a new controller called <kbd>AuthenticationController</kbd> with two actions,&#160;<kbd>SignIn</kbd> and <kbd>SignOut</kbd>, as shown here:</p>
<pre> [Route("authentication")]<br/> public class AuthenticationController : Controller<br/> {<br/>     private readonly ILogger&lt;AuthenticationController&gt; logger;<br/><br/>     public AuthenticationController(ILogger&lt;AuthenticationController&gt; <br/>     logger)<br/>     {<br/>         this.logger = logger;<br/>     }<br/><br/>     [Route("signin")]<br/>     public IActionResult SignIn()<br/>     {<br/>         logger.LogInformation($"Calling {nameof(this.SignIn)}");<br/>         return Challenge(new AuthenticationProperties { RedirectUri = <br/>         "/" });<br/>     }<br/><br/>     [Route("signout")]<br/>     [HttpPost]<br/>     public async Task&lt;IActionResult&gt; SignOut()<br/>     {<br/>         await <br/>         HttpContext.SignOutAsync(CookieAuthenticationDefaults<br/>         .AuthenticationScheme);<br/>         return RedirectToAction("Index", "Home");<br/>     }<br/>  }</pre>
<p class="mce-root">The code is simple but an explanation is important, as we have used a lot of things here:</p>
<ul>
<li>We have used attribute routing at the controller level, by using the <kbd>[Route("authentication")]</kbd> attribute. This may seem unnecessary as its name is the same as that of the controller, but the intent is to demonstrate how the&#160;<kbd>Route</kbd> attribute is used at a controller level. Had we used <kbd>[Route("auth")]</kbd>, all requests to <kbd>/auth/</kbd> would redirect to this controller.</li>
<li>Next, we see that the <kbd>AuthenticationController</kbd> derives from the <kbd>Controller</kbd> class. This is mandatory when we create any controller; it should derive from the&#160;<kbd>Controller</kbd> class. We can have it derive from some other class, say <kbd>BaseController</kbd>, but then <kbd>BaseController</kbd> should derive from the&#160;<kbd>Controller</kbd> class.</li>
<li>Next, we see we have a field of type <kbd>ILogger&lt;AuthenticationController&gt;</kbd> called <kbd>logger</kbd>, which would be used to do the logging with the <kbd>AuthenticationController</kbd> as the category.</li>
<li>Then, we have the constructor for the <kbd>AuthenticationController</kbd>. This takes in a dependency of <kbd>ILogger&lt;AuthenticationController&gt;</kbd>, which is injected by default by the framework. This demonstrates DI.</li>
<li>There is an action created with the name <kbd>SignIn</kbd>. Note that it also uses attribute routing, as it's decorated with <kbd>[Route("signin")]</kbd>. The return type of this action is <kbd>IActionResult</kbd>. As is evident, the first line of action is for logging the information. The important thing in this action is that its returns a <kbd>ChallengeResult</kbd>, taking in the <kbd>AuthenticationProperties</kbd> as the parameter. It's important to set the <kbd>RedirectUri</kbd> as it is responsible for redirecting the page to the appropriate page after authentication. <kbd>ChallengeResult</kbd> would use the configured challenge scheme, Facebook, in this case.</li>
<li>The last action is <kbd>SignOut</kbd>. Again, it uses attributebased routing. It would be served when a <kbd>POST</kbd> request comes as it is decorated with the&#160;<kbd>[HttpPost]</kbd> attribute. We also note the&#160;<kbd>async</kbd> keyword to demonstrate that we can have <kbd>async</kbd> controller actions. It uses the <kbd>SignOutAsync</kbd> method of <kbd>HttpContext</kbd> and signs out using the cookie authentication scheme. Post sign out, it redirects the user to the&#160;<kbd>Index</kbd> action of the&#160;<kbd>Home</kbd> controller. If the&#160;<kbd>Index</kbd> action of the&#160;<kbd>Home</kbd> controller has the&#160;<kbd>[Authorize]</kbd> attribute applied, it may take the user to the login screen and if cookies are not cleared from the browser, you may have the user logged back in.</li>
</ul>
<p>In the View, we will do the following. If the user is not signed in, show him the <kbd>Sign In</kbd> button, or show him the <kbd>Sign Out</kbd> button. This can be done easily in the <kbd>_Layout.cshtml</kbd> by the writing the following code:</p>
<pre>  @if (User.Identity.IsAuthenticated) /// If user is authenticated<br/>  {<br/>     &lt;li&gt;<br/>       &lt;br/&gt;<br/>           &lt;form method="post" asp-controller="Authentication" asp-<br/>           action="SignOut"&gt;<br/>             &lt;button type="submit" class="btn btn-primary"&gt;Sign <br/>             Out&lt;/button&gt;<br/>           &lt;/form&gt;<br/>     &lt;/li&gt;<br/>   }<br/>   else<br/>   {<br/>     &lt;li&gt;&lt;a asp-area="" class="btn btn-primary" asp-<br/>     controller="Authentication" asp-action="SignIn"&gt;Sign In&lt;/a&gt;&lt;/li&gt;<br/>    }</pre>
<p class="mce-root">By doing this in <kbd>_Layout.cshtml</kbd>, we ensure this functionality is common across all the pages. The <kbd>@prefix</kbd> on Razor tells the RazorEngine that it is C# code. We first check if the user is authenticated; if yes, <kbd>User.Identity.IsAuthenticated</kbd> would be <kbd>true</kbd>. Inside this condition, we display the <kbd>Sign Out</kbd> button inside a <kbd>form</kbd> tag. The <kbd>form</kbd> tag is important, as we are doing a submit action on the <kbd>Sign Out</kbd> button, so on clicking it, the form would be posted to the server. This call should never ever be <kbd>HttpGet</kbd>. The <kbd>form</kbd> tag uses the <kbd>post</kbd> method and uses tag helpers to specify the controller and action as <kbd>Authentication</kbd> and <kbd>SignOut</kbd>, respectively.</p>
<div class="mce-root packt_infobox">HTTP method definitions (<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</a>) recommend the usage of <kbd>HttpPost</kbd> methods over <kbd>HttpGet</kbd> methods for security reasons (<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3">https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3</a>), when the data is being submitted to the server, as per the following excerpt:<br/>
If your <span>of services use the HTTP protocol, then you <strong>SHOULD NOT</strong> use <kbd>GET</kbd>-based forms for the submission of sensitive data. Otherwise, this will cause the data to be encoded in the Request-URI.&#160;The request URI will be logged somewhere by existing servers, proxies, and user agents, and it might be accessible to third parties. Servers can use <kbd>POST</kbd>-based form submission instead.</span></div>
<p class="mce-root">This completes our authentication module, and we are ready to develop the SignalR Chat hub module.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we brushed up on the fundamentals of MVC and looked at the features of ASP.NET Core MVC. Post learning the fundamentals, we developed the authentication module for our Let's Chat app using Facebook. We checked that we can log in, sign out, register a new user, as well as reset the password, using the work already done by Facebook, with minimal lines of code in our ASP.NET Core 2.0 app. In the next chapter, we will develop the SignalR Chat hub module and complete the Let's Chat web app. We will also learn about unit testing and deployment for the ASP.NET Core 2.0 app.</p>


            </article>

            
        </section>
    </div>
</body>
</html>