- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing the FPS Game with Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B18347_11.xhtml#_idTextAnchor212), we transformed a gray-boxed
    prototype environment by replacing modular Prefabs with high-quality 3D models,
    preserved Prefabs with extra behavior in Prefab Mode, and applied new materials.
    We also added objects to the environment by painting Prefabs, telling surface
    stories by placing wear-and-tear decals, and implementing lighting and shadow
    setups for real-time and baked lighting.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the player experience, we have to work on the sound design aspect
    of our game. Until now, we haven’t given much attention to audio and **sound effects**
    (**SFX**). Let’s change that now by developing an audio manager and reusable audio
    player components system. This will allow us to easily add audio and SFX to our
    game, even for designers and artists who may not have much experience with coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding audio using the Audio Mixer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an immersive soundscape with music, SFX, and ambiance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the audio experience with footsteps and reverb zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deeper SOLID refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to code an audio manager and its
    components to play game music and SFX through an Audio Mixer. You will also gain
    an understanding of the differences between playing 2D and 3D sound and how to
    reuse audio playing components to create new sound behavior, such as footstep
    sounds. Additionally, you will learn how to add effects zones to your game’s level.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Adding audio using the Audio Mixer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any interactive experience, sound is pivotal in enveloping the player in
    the game world. This section will introduce different ways to play audio using
    Unity’s audio tooling. You’ll learn how to elevate your game’s audio experience
    by effectively utilizing music, both 2D and 3D SFX, ambient noise, and reverb
    zones.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by defining what sound design is.
  prefs: []
  type: TYPE_NORMAL
- en: Sound design 101 for games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good sound design can significantly enhance the player’s experience and immersion
    in the game. Play your favorite game but turn off the sound, and you’ll see quite
    quickly that the experience is not the same!
  prefs: []
  type: TYPE_NORMAL
- en: Several audio concepts come together to form the foundation of sound design
    in creating the atmosphere for an immersive world. While I’ll be introducing sound
    design components, just know it’s more art than technical in bringing all the
    concepts together – this is the job of a sound designer!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be implementing audio scripts that will enable us to add the following
    elements of sound design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Music/background music**: Set the mood with music! Also, changes in music
    at the right moments of gameplay can be impactful to the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SFX**: Every time the player swings their sword, picks up a coin, bumps into
    a crate, or defeats an enemy, SFX is crucial for player immersion and enhancing
    the gameplay experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ambience or atmosphere**: The environmental sounds, or background noise,
    you hear that sets the scene and lets you know you are in a real living place.
    Generally, 3D audio changes based on the player’s position and orientation to
    an audio source in the environment, which can greatly enhance immersion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character dialogue**: Yes, dialogue is sound design too. The style of their
    voice can further define a character. Voice can also be used to drive a story-driven
    narrative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI feedback**: *Clicks*, *boops*, and *beeps* on button presses and changes
    in the UI when the player is interacting provide a satisfying feedback experience
    that you don’t want to omit from your overall sound design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering all of the preceding sound design elements together into a cohesive
    audio soundscape for a game experience is another job performed by the sound designer,
    and it is called audio mixing. **Audio mixing** allows for further engineering
    of the audio experience and can include additional audio tooling such as filters,
    effects, and reverb zones.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to audio, there are many factors to consider, such as formats,
    file size, compression quality, looping capabilities, and runtime performance
    – for starters. While a deep dive into the technical aspects of varying audio
    formats is not within the scope of this chapter, rest assured that I won’t shy
    away from pointing out crucial format details wherever necessary in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about audio here: [https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand sound design, we’ll put on our *audio developer hat*
    and add audio to our 3D FPS game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding audio to the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start by adding an Audio Mixer. Even though I mentioned audio mixing last
    in the previous section, we’ll add the capability to mix our game audio first
    and patch every audio component through it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Audio Mixer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Audio Mixer** asset will allow us to set levels for each sound element
    we define independently – tailoring our game’s soundscape. It will also allow
    us to change levels when required in gameplay and provides a convenient way for
    the player to adjust levels to their taste via UI controls.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about the Audio Mixer here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: To add an Audio Mixer, we’ll first have to ensure we have our project open in
    Unity and have our habitat interior level design scene from [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187),
    open (e.g., `Habitat` `Interior 1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a new `AudioMixer 1` in a new `Assets/Audio` folder (using
    the **Create** | **Audio Mixer** menu). Once you’ve created **AudioMixer 1**,
    double-clicking on it (in the **Project** window) will open the **Audio Mixer**
    window, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Audio Mixer setup](img/B18347_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Audio Mixer setup
  prefs: []
  type: TYPE_NORMAL
- en: With the **Audio Mixer** window open, we can now add groups for the channels
    of audio we’ll want to mix the levels for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following groups (see *Figure 12**.1* for reference) by clicking the
    big plus sign (**+**) to the right of the **Groups** heading. Note that when the
    group first appears, the field is highlighted so that you can give it a name right
    away:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Music**: The level at which the game’s music will be played is set with this
    group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SFX**: The game’s SFX level will be set with this group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ambient** [sound]: All of the environmental ambiance and noise will be set
    with this group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In **Play Mode**, there is a toggle button called **Edit in Play Mode** in the
    **Audio Mixer** window. This toggle, when enabled, allows us to adjust or mix
    audio levels while playtesting.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 12**.1*, you can see I left all the levels at zero except for the
    `-16` to see how loud that sounds during gameplay – it should be lower so as not
    to drown out the SFX.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that was easy! We’ll continue coding our way through creating the audio
    system with components for playing the different sound elements in the following
    sections. It all starts with an audio manager class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple audio manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Following what should be a recognizable code architecture at this point in the
    book, introduced in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), section *SOLID
    principles and design patterns*, we’ll create an audio manager class by following
    SOLID principles. Specifically, we’ll rely on the SOLID **open-closed principle**
    (**OCP**) and polymorphism, and also introduce an interface for our different
    types of audio player components responsible for playing the different kinds of
    sounds in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us create a C# script in a new `Assets/Scripts/Audio` folder named
    `AudioManager`. We’ll start by adding the necessary variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the groundwork for implementing the Audio Mixer groups we configured
    in the previous section. We’ve also declared some `AudioSource` variables for
    sound playback – these will be explained as we add to the code while implementing
    the play audio functionality in the following *Building an immersive soundscape
    with music, SFX, and* *ambiance* subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I’m just going to assume by now that you know that if we have a class inheriting
    from **MonoBehaviour**, we need a **using UnityEngine;** statement at the top
    of the C# script. As you should also know, this **using** statement is already
    there from the default script template. :)
  prefs: []
  type: TYPE_NORMAL
- en: Again, one of the key functions the `AudioManager` class will handle for us
    is setting the Audio Mixer group for the type of audio we want to play. This will
    ensure sound designers can use the Audio Mixer to set the initial audio playback
    levels of the game (i.e., designing the soundscape).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `AudioManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: switch expression (C#)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about pattern-matching expressions using the **switch** keyword
    here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression).'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve created an `AudioType` enum that we’ll use to map an audio player
    component to an Audio Mixer group. We’ve added the `GetAudioMixerGroup()` method
    to get the appropriate Audio Mixer group by using a `switch` expression and passing
    in an `AudioType` enum. This will all become clearer in the next section when
    we create our first audio player component.
  prefs: []
  type: TYPE_NORMAL
- en: Discards (C#)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the compiler will generate a warning if the switch expression in
    the preceding code doesn’t handle all possible input values. In that case, we
    could use the following discard pattern so all possible input values are handled
    – avoiding a console warning: _ => throw new ArgumentOutOfRangeException(nameof(AudioType),
        $"Not expected audioType value: {audioType}"),'
  prefs: []
  type: TYPE_NORMAL
- en: The underscore (**_**) is a placeholder variable that won’t hold a value and
    is not intended to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about discards here: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards).'
  prefs: []
  type: TYPE_NORMAL
- en: With the `AudioManager` class we have coded up until now, we are ready to start
    making the audio player components! But before we do that, we’ll need to have
    a way to access `AudioManager` to call on its methods. So, we’ll continue to use
    the Singleton pattern for our managers – go ahead and add the required code for
    it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To add the `AudioManager` script, a class derived from `MonoBehaviour`, to our
    project, create a new GameObject named `AudioManager` in the `AudioManager` script
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: We can now assign the `AudioMixerGroup` fields by clicking and dragging the
    group from the **Audio Mixer** window or using the field’s **Object Picker** window
    (the small circle icon at the right side of the field), using *Figure 12**.2*
    as a guide.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – AudioManager mixer groups assignment](img/B18347_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – AudioManager mixer groups assignment
  prefs: []
  type: TYPE_NORMAL
- en: Done! Well, we don’t actually have any methods to play sound in our audio manager…
    yet…
  prefs: []
  type: TYPE_NORMAL
- en: The audio manager foundation for the game is in place, so we can now begin writing
    the individual components to play the different types of audio needed in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Building an immersive soundscape with music, SFX, and ambiance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll cover writing audio player components for what I consider the most common
    scenarios for the type of game audio we’ll need. We’ll have components for playing
    music, SFX, and ambient sounds. We’ll also cover playing the sound in 2D or 3D
    space, as required or desired, for each type of audio player component.
  prefs: []
  type: TYPE_NORMAL
- en: Everything that plays sound in Unity requires an `AudioSource` component (think
    of it as a speaker, and you can have many), and the scene requires a single `AudioListener`
    (think of it as the microphone). By default, our main camera in the scene comes
    with the `AudioListener` component already added – so we’re good; there is nothing
    further to do there.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about the Audio Listener here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the `AudioManager` implementation, it’s important to note that we
    are ensuring all audio player components direct audio playback through `AudioManager`
    so that the correct Audio Mixer group is used. This design is intentional, so
    anyone adding an audio player component (developer, designer, artist, etc.) won’t
    have to remember to set the correct mixer group for the specific component type.
    This will be super simple to accomplish because – you guessed it – we’ll use an
    interface (as we’ll soon see when coding our audio player components).
  prefs: []
  type: TYPE_NORMAL
- en: Project audio files
  prefs: []
  type: TYPE_NORMAL
- en: The audio files that will be used in the following sections are all either public
    domain or **Creative Commons Zero** (**CC0**) ([https://creativecommons.org/publicdomain/zero/1.0/deed.en](https://creativecommons.org/publicdomain/zero/1.0/deed.en))
    and are available from the **Audio-Assets** folder in the GitHub repo, from the
    individual Unity project assets folders, or from the original download links provided
    in the corresponding sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub repo audio assets for this chapter can be found here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets).'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, on to our first audio player component. Time to play some sweet music!
  prefs: []
  type: TYPE_NORMAL
- en: Playing music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll delve into the technical aspects of incorporating music into your games.
    A music composer is responsible for creating impactful soundtracks that resonate
    with your audience and become synonymous with your game’s identity. Therefore,
    I highly recommend partnering with a composer for your projects to achieve this
    level of quality.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are looking for a more budget-friendly option, you can use sourced
    music, where composers create pre-made soundtracks in different genres that can
    be purchased and used in your project (sometimes, as in our case here, even for
    free).
  prefs: []
  type: TYPE_NORMAL
- en: But, before we can assign any music clips to an audio player component, we first
    have to create one.
  prefs: []
  type: TYPE_NORMAL
- en: Warning!
  prefs: []
  type: TYPE_NORMAL
- en: The **AudioPlayerMusic** class introduced next will not follow the SOLID OCP.
    This is intentional. We will instead use this initially coded approach as an example
    to be refactored for the remainder of the audio player components. Hopefully,
    it will serve as a reinforcement learning opportunity to solidify knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re starting with playing music, so create a new C# script named `AudioPlayerMusic`
    in a new `Assets/Scripts/Audio` folder with the following fields and methods declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s have a look at what we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_musicClip`: An audio clip holds the audio data representing the sound to
    be played, which supports many popular audio file formats (`.wav`, `.mp3`, and
    `.ogg` being the most used). In the **Inspector** window, this variable will be
    assigned a reference to an audio file asset from the **Project** window folder
    for our game’s music to be played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about audio clips here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '`_playOnStart`: This variable is a simple Boolean flag we’ll set in the **Inspector**
    to tell this audio player component to start playing when the game begins or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start()`: We evaluate the value of `_playOnStart` in the `Start()` Unity message
    event method and call `Play()` if `true`. Simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Play()`: This is where the magic happens, where we tell `AudioManager` to
    start playing our lovely music’s audio clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, we call a `PlayMusic()` method in the `AudioManager` Singleton
    instance. However, the method doesn’t yet exist. Let’s fix this now to complete
    the playing music functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the PlayMusic() method to AudioManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, add the `PlayMusic()` method to the `AudioManager` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`AudioManager` will play the music directly by adding `AudioSource` to the
    GameObject it resides with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, following the architecture we established, set the appropriate mixer group,
    the music clip passed in as a parameter to the `_audioSourceMusic` audio source,
    and the remaining properties set the music to play in 2D space and on an infinite
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_audioSourceMusic` properties for playing music are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spatialBlend = 0f`: Based on the player’s position in the environment, we
    don’t want the music to be heard differently, so setting the spatial blend property
    to `0f` makes it a full 2D sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When adding 2D audio sources to the scene, note that their transform position
    in world space won’t matter; the audio listener always hears them.
  prefs: []
  type: TYPE_NORMAL
- en: '`loop = true`: This one is pretty clear – does `loop` equal `true`? Yup. Then
    play the audio clip in a loop forever! Otherwise, play it once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining properties for an `AudioSource` component will be set to their
    default values, which will all be just fine for background music.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about **AudioSource** here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the music is played using the `Play()` method on `_audioSourceMusic`.
    All that remains to get the music playing in our game is to add `AudioPlayerMusic`
    to our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AudioPlayerMusic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementing our music audio player component means adding the `AudioPlayerMusic`
    script to our scene (no surprise here).
  prefs: []
  type: TYPE_NORMAL
- en: In the `AudioPlayerMusic` as a sibling component to the `AudioManager` component
    on the `AudioManager` object in the **Hierarchy**. *Figure 12**.3* shows our final
    music audio player component setup.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Adding AudioPlayerMusic to the AudioManager object](img/B18347_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Adding AudioPlayerMusic to the AudioManager object
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding figure that the audio clip for the music is already
    assigned to the `Arpent` audio file to our project now and make that assignment.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t yet imported the audio assets from the project GitHub repo, refer
    back to the *Building an immersive soundscape with music, SFX, and ambiance* section
    and do that now. We’ll need the audio files for the next step and the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The music file we’ll be using for our game is `Arpent.mp3` and comes from FreePD
    ([https://freepd.com/music/Arpent.mp3](https://freepd.com/music/Arpent.mp3)).
    The music is licensed CC0, meaning we can use it for free.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `Arpent.mp3` file is imported to the `Assets/Audio/Music` folder.
    Then, with the file selected in the **Project** window, let’s adjust the import
    settings in the **Inspector** window to something appropriate for what is generally
    a longer music clip – you can see in the **Inspector** window in the following
    figure that the music file is nearly three minutes long (**2:42.064** to be exact).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Audio clip import Inspector settings](img/B18347_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Audio clip import Inspector settings
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll have noticed by now that when we select assets in the **Project** window,
    the **Inspector** will adjust to the type of asset chosen, so the import settings
    will look different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Settings to note that we’ve changed here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load In Background**: Enabling loading the audio file in the background for
    lengthy or high-quality music files ensures the game runs smoothly since asynchronous
    loading (i.e., not blocking the main thread) eliminates frame drops and the possibility
    of stuttering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Type**: For longer music files, it’s advised to set this to **Streaming**
    so all of the audio data is not loaded into memory all at once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`70`% is generally a good balance for music – file size versus quality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio Clip Import Settings | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about audio clip **Inspector** options here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve made these changes, clicking the `AudioPlayerMusic` component by
    selecting the `AudioManager` object in the `Arpent` music file to the **Music
    Clip** field, and we’re done!
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your scene and enter Play Mode to hear music play when the game starts.
    If you don’t hear anything, you may need to toggle the *mute audio* icon in the
    **Game** view, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Game mute audio toggle](img/B18347_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Game mute audio toggle
  prefs: []
  type: TYPE_NORMAL
- en: We’ve started on our journey of audio immersion and exploration in Unity! Hearing
    music playing is a nice way of establishing the mood and setting the stage for
    our gameplay. Game sound designers carefully choose music tracks to create the
    desired emotional and thematic tone, evoking wonder, mystery, or the unknown to
    establish an expansive and intriguing atmosphere. Upon hearing the *Arpent* music
    track, I realized it would be a perfect fit for the sci-fi environment and the
    player’s exploration of the habitat station for this level.
  prefs: []
  type: TYPE_NORMAL
- en: But as great as playing music is, I’m sure you already know that a game is nothing
    without sound effects!
  prefs: []
  type: TYPE_NORMAL
- en: Playing SFX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tell me, would a particular series of sci-fi movies (set in a galaxy far away)
    be complete without its iconic sound of laser swords humming then cutting through
    the air and clashing? The answer is no… no, it wouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: SFX are the unsung heroes of game development – only 50% of the game is complete
    without them (no, you cannot argue this). So, what are we waiting for… these SFX
    aren’t going to play themselves!
  prefs: []
  type: TYPE_NORMAL
- en: SOLID refactoring with the IPlaySound interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re going to refactor for SOLID principles now. Specifically, `AudioManager`
    will be closed for modification, adhering to the OCP. For the *open* part, we’ll
    pass in the type of audio player object – this is also the polymorphism part –
    each with its own implementation (i.e., modification) to play sound, and the audio
    player types implement an interface: `IPlaySound`. The interface ensures we have
    a consistent public method to call on each different audio player object type
    we implement.'
  prefs: []
  type: TYPE_NORMAL
- en: We are making an exception to the *closed-for-modification* principle by allowing
    the use of the `AudioType` enum. This decision is based on making it easier for
    developers and designers to add audio player components. By simplifying the process
    and preventing potential mistakes, we aim to save time and eliminate the need
    for manual assignment of audio groups. The trade-off is that we’ll need to modify
    `AudioManager` whenever a new mixer group is added, which I’m okay with.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that explanation out of the way, let’s look at the `IPlaySound` interface.
    Create a new C# script named `IPlaySound` in the `Assets/Scripts/Audio` folder
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the breakdown of the interface declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`using AudioType`: Sometimes, we must distinguish a type name shared across
    namespaces. We defined that `AudioManger.AudioType` and `AudioType` exist in `UnityEngine`.
    So, we need to tell the script which one we want. To do that, we use an alias:
    `using AudioType =` `AudioManager.AudioType;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The using alias (C#)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the **using** alias here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias)'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayAudioType`: This property will get the default value we assign from our
    `AudioType` enum. We will set `AudioMixerGroup` based on this value for the specific
    type of audio player component we’re making – and avoid any assignment mistakes
    in the **Inspector**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlaySound()`: Exactly as its name states, the implementing class will use
    this method to play the audio clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that’s all we need for our interface. Our audio manager class can now implement
    multiple audio players without modification, following the SOLID OCP, by passing
    each different audio player class by the interface type. The audio player classes
    that implement the interface will provide unique play functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see our first example by writing the play SFX component. Create a new
    script named `AudioPlayerSFX` in the `Assets/Scripts/Audio` folder with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we added the `IPlaySound` interface to the `AudioPlayerSFX` class declaration
    to conform to our audio player component design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have these core variables and methods that will be common to all the
    audio player components since they are all considered required for playing sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_audioClip`: Every audio player component needs a clip to play. This variable
    refers to the audio clip asset assigned via the **Inspector** and then played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_volume`: Not every audio file will have the same levels for its playback,
    or, for some sounds in the game, they may satisfy the sound design by playing
    at a lower volume; set with this variable in the **Inspector**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Play()`: The public method we’ll call to start playing the assigned audio
    clip using the `AudioManager` Singleton instance’s `PlayAudio()` method (which
    we’ll be adding in the next section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calling the audio manager’s `PlayAudio()` method, note that we’re passing
    in `this` as the parameter. The `this` keyword refers to the current class instance
    – in this case, `AudioPlayerSFX`, but the parameter type we will use for declaring
    `PlayAudio()` will be `IPlaySound`. This is the magic of polymorphism. We’ll pass
    in `this` as the type parameter, representing any number of different classes
    for unique audio player functionality, but all accessible as `IPlaySound`.
  prefs: []
  type: TYPE_NORMAL
- en: this (C#)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about the **this** keyword for class instances here: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, implement the `IPlaySound` interface’s public properties and methods (remember,
    interface declarations must be `public`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Without repeating the interface details again here, let’s delve into the assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayAudioType`: Here is where we pre-assign the `AudioType` value for the
    Audio Mixer group we want this audio player component to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlaySound()`: Here is where we actually play the sound with the audio-playing
    code specific to this type of audio player component, using the referenced audio
    source. In the case of SFX, we’ll use the `PlayOneShot()` method because it allows
    playing multiple sounds on a single `AudioSource` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `AudioSource` component being passed in here will be added to
    the `AudioManager` object for the 2D SFX. So, there is no need to add an `AudioSource`
    component to the objects with this audio player component added. You’ll see how
    this works in the next section when we add to `AudioManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about **PlayOneShot()** here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide some additional clarity to this architecture, now that you’ve seen
    the code and how the method calls are set, let’s look at a `AudioPlayerSFX` and
    `AudioManager` relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Audio architecture UML class diagram](img/B18347_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Audio architecture UML class diagram
  prefs: []
  type: TYPE_NORMAL
- en: The code calls on the audio manager – `AudioManager.PlayAudio()` – to assign
    the correct Audio Mixer group. It then uses the interface to call back to its
    specific play sound function (with the audio source responsible for playing the
    sound) – `IPlaySound.PlaySound()`. It’ll become even clearer as we implement additional
    audio player components in the subsequent sections, each with a unique play sound
    function for playing 3D SFX and ambient sounds.
  prefs: []
  type: TYPE_NORMAL
- en: This finishes up our audio player component for playing SFX, but it’s not done
    yet because it won’t play anything with the audio manager’s `PlayAudio()` method
    not existing. Let’s solve this problem now by updating our audio manager.
  prefs: []
  type: TYPE_NORMAL
- en: Updating AudioManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bringing it all together now, we’re adding in the `AudioManager.PlayAudio()`
    method to set the assigned mixer group and call back to the passed-in component’s
    specific `PlaySound()` functionality to play the audio – in this case, an SFX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `AudioManager` script and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`PlayAudio()` will be closed for modification so its structure is suitable
    for any number of audio player components that implement the `IPlaySound` interface.
    As such, we’ve made the second argument in the method signature, `source`, have
    a default value of `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: For playing 2D sounds, we’re not going to require every object in the scene
    that will play a sound to have `AudioSource` attached to it. Having too many `AudioSource`
    components in the scene can potentially lead to performance issues related to
    memory usage, processing overhead, and audio clipping if too many of those audio
    sources are playing simultaneously (see the *Optimization note* information that
    follows because Unity limits the number of audio sources that can play simultaneously).
  prefs: []
  type: TYPE_NORMAL
- en: For an audio source with a `null` value, we’re first going to assume it’s a
    2D sound that will be played – 3D sounds will have their own audio source passed
    in. We’ll use a `private` property to get an instance of `AudioSource` for playing
    the audio clip (using a property getter) instead of using a `private` method to
    return (i.e., `get`) the `AudioSource` reference in the class requiring it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and add the `AudioSourcePlaySFX` property to `AudioManager`
    now so we have a valid audio source component added to the scene for playing our
    2D sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For this property, you can see we have a getter defined. It evaluates the `private`
    member `_audioSource2D` (previously added) to see whether it already has an `AudioSource`
    component assigned to it, and if not, uses the `AddComponent()` method to add
    one to the scene (as a sibling on the same GameObject as `AudioManager`).
  prefs: []
  type: TYPE_NORMAL
- en: It then sets the `spatialBlend` value to ensure 2D playback of the sound and
    returns the new `AudioSource` to have its mixer group assigned and then passed
    back to the audio player component for playing the sound. Whew!
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the **AudioSource** component that plays the SFX sounds, we have
    a limit to the number of audio clips that can be played simultaneously. **AudioSource**
    supports 32 voices, and each audio clip consumes 2 voices to play. Using the **PlayOneShot()**
    method, we can play several audio clips up to this limit, at which point it will
    start clipping. You may have already guessed that we can support additional audio
    clips by object pooling the **AudioSource** object via the **AudioManager** component.
    Refer back to [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116).
  prefs: []
  type: TYPE_NORMAL
- en: Great, all our audio playback needs should be satisfied per our architecture
    at this point. Let’s see how to implement playing SFX in our scene now before
    moving on to making additional audio player components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AudioPlaySFX – Unity event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add our first SFX to the game, let’s revisit something you’re already familiar
    with: our health pickup. Having followed along in the previous chapters – such
    as [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187), section *Recharging aka healing*
    – you should have one in your scene already. Find and select it. Now, let’s add
    the `AudioPlayerSFX` component to the root GameObject. As seen in the following
    figure, it’s added just below the `Destroyer (``Script)` component.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Health pickup SFX](img/B18347_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Health pickup SFX
  prefs: []
  type: TYPE_NORMAL
- en: Assign `AudioPlayerSFX` to play a sound when `OnHealEvent` is triggered from
    the preceding `PickupHeal` component.
  prefs: []
  type: TYPE_NORMAL
- en: On the `PickupHeal (Script)` component, click the plus (`UnityEvent` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the `AudioPlayerSFX` component (by its title bar) to the new
    entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function selector dropdown, select **AudioPlayerSFX** | **Play()**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, it’s all wired up, but we’re missing something… what sound will we play?!
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the audio clip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sound file we’ll be using for our health pickup is `item-pickup-v1.wav`.
    It comes from the Freesound website (https://freesound.org/people/DeltaCode/sounds/678384/)
    and is licensed CC0, which means we can use it for free.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `item-pickup-v1.wav` file is imported to the `Assets/Audio/SFX` folder.
    Unlike with the music audio file, we’ll use the default import settings values
    for this sound file. Return to the `AudioPlayerSFX` component on the healing pickup,
    then click and drag the `item-pickup-v1` file to the **Audio Clip** field. At
    the top of the **Inspector**, click **Apply All** in the **Prefab** | **Overrides**
    dropdown to ensure all the health pickup instances in the level are updated to
    include playing the SFX.
  prefs: []
  type: TYPE_NORMAL
- en: Playtest the level, adjust the `AudioPlayerSFX` component as needed, and take
    notice of the 2D sound playback. Next, we’ll play SFX in 3D space so you can hear
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Playing SFX for UI feedback
  prefs: []
  type: TYPE_NORMAL
- en: Adding SFX to button clicks is also an essential aspect of game sound design.
    It significantly enhances the game’s overall polish and improves player satisfaction.
    It may seem like a small detail, but it can substantially affect how players perceive
    and interact with your game UI. For a UI button, use the **AudioPlayerSFX** component
    and wire up the **Play()** method to the button’s **On Click()** event in the
    **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created an audio player component with our refactored approach,
    the remainder will follow the same setup, so we’ll just bang the rest of these
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Playing SFX 3D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike with the `AudioPlayerSFX` component, where we did not add an `AudioSource`
    component to the GameObject for playing the 2D sound, we will add one here because
    we want a “speaker in 3D space” to emanate the sound. The player, via the `AudioListener`
    component on the `Player` object, will hear the sound as you naturally would in
    a real-world environment – whichever “ear” is turned toward the source of the
    sound will hear it. Hearing sounds in 3D space further builds on the player’s
    immersion in your game world, so we definitely want to take advantage of 3D audio!
  prefs: []
  type: TYPE_NORMAL
- en: Noting the preceding information concerning `AudioSource`, we’ll ensure the
    developer/designer adding a “play 3D sound effect” component to an object configures
    an audio source for this sound by requiring the `AudioSource` component to be
    added as a sibling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new script named `AudioPlayerSFX3D` in the `Assets/Scripts/Audio`
    folder, and start with the following code for the audio source requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[RequireComponent]`: By decorating the class with this attribute, we require
    that a sibling component exist on this GameObject. Specifically, we need an `AudioSource`
    component because this will be a 3D sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnValidate()`: We can use this Unity message event to pre-assign the `_audioSource`
    variable with the `AudioSource` instance added by the `RequireComponent` attribute.
    `OnValidate()` only runs in the Editor and is called when the script is loaded
    or a value changes in the **Inspector**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPlaySound`: Don’t forget to add the interface! We’re required to implement
    the interface for all our audio player components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about **OnValidate()** here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by borrowing from the `AudioPlayerSFX` class; we’ll also have
    `_audioClip` and `_volume` serialized private member variables. To those, we’ll
    add an additional field for assigning the 2D to 3D sound ratio with a `_blend2Dto3D`
    variable (which we’ll use to assign to the `AudioSource.spatialBlend` property).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Play()` method here is only slightly different from the previous `AudioPlayerSFX`
    implementation of `Play()` in that we’re now passing the audio source reference
    to `AudioManager`. As a reminder, we need to do this because we want to assign
    playback to the correct Audio Mixer group before playing the sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of playing the sound, now, implement the `IPlaySound` interface public
    properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’ve set `PlayAudioType` to play the sound using the SFX mixer group while
    the `PlaySound()` method remains largely the same – except we’re setting the `source.spatialBlend`
    value before using `PlayOneShot()` to play the audio clip at the transform position
    of this object (in 3D space) and at the set volume level.
  prefs: []
  type: TYPE_NORMAL
- en: PlayClipAtPoint() | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: Those of you familiar with the Unity scripting API may wonder why I didn’t just
    use the **AudioSource.PlayClipAtPoint(_audioClip, transform.position, _volume)**
    static method.
  prefs: []
  type: TYPE_NORMAL
- en: Well, the reason falls back to the primary goal of implementing the **AudioManager**
    class the way we did – and that is to ensure the Audio Mixer groups are being
    utilized for all the distinct audio player components. While **PlayClipAtPoint()**
    does play an audio clip at a position in 3D world space, it does not work with
    the Audio Mixer, which ruled it out as an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about **AudioSource.PlayClipAtPoint()** here: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '`AudioPlayerSFX3D.Play()` now calls `AudioManager.Instance.PlayAudio()` with
    the added `_audioSource` parameter. The passed-in audio source is modified in
    `AudioManager` and passed back to the interface implemented `PlaySound()` method
    to use the audio player component’s specific functionality to play the sound.'
  prefs: []
  type: TYPE_NORMAL
- en: Note on code architecture
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between **AudioManager** and the **AudioPlayerSFX3D** class
    may seem cyclical since we’ve implemented playing the sound with the interface
    and not within **AudioManager**. This is an okay trade-off in the architecture
    for me here because I’ve prioritized composition, ease of use, and eliminating
    errors for **Inspector** assignments in Unity. Doing things in Unity sometimes
    means developing novel approaches and compromises to otherwise “standard approaches”
    to C# OOP software development. I came to terms with that long ago. :)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now follow through with the new 3D audio player component by looking at
    an implementation again.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AudioPlaySFX3D – Animation event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much like how we revisited an object we previously created for playing SFX (the
    health pickup), we’ll do the same here and add a 3D SFX to the door-opening animation
    we created in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187). The following
    figure shows the sliding door Prefab – we’ll add the 3D sound effect when it slides
    open.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Sliding door 3D SFX](img/B18347_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Sliding door 3D SFX
  prefs: []
  type: TYPE_NORMAL
- en: Because the door does not have a component with an exposed `UnityEvent` being
    invoked, as with the health pickup, we have to trigger the sound playing differently.
    We’ll still use an event, but this event is one we’ll add to the door-opening
    animation directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add the 3D SFX to the sliding door animation:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Door_Triggered` Prefab for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `AudioPlayerSFX3D` component to the same object as the `Animator` component.
    As seen in *Figure 12**.8*, it’s added just below the `Animator` component on
    the `Sliding_Door_01` child object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, while `Sliding_Door_01` is still selected in the **Hierarchy** window,
    open the **Animation** window by going to **Window** | **Animation** | **Animation**
    (or press *Ctrl*/*Cmd* + *6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the following **Animation** window figure as a reference, scrub the timeline
    a frame or two ahead, then click the **Add Event** button. This will add an **Animation
    Event** check mark to the timeline and select it (it will be blue when selected
    and white when not).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Adding an animation event](img/B18347_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Adding an animation event
  prefs: []
  type: TYPE_NORMAL
- en: When **Animation Event** is selected, the **Inspector** window will show a **Function**
    drop-down menu so that we can choose a method to invoke for the event.
  prefs: []
  type: TYPE_NORMAL
- en: Select **AudioPlayerSFX3D** | **Methods** | **Play()** in the **Function** drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animation event | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: The **AudioPlaySFX3D** component must be on the same object as the **Animator**
    component to select **Play()** in the **Function** drop-down from the **Animation**
    timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional reading | *Using Animation Events*: [https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Save the Prefab (or apply overrides) because we’re done wiring up the sliding
    door for playing the 3D SFX!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold on a second, don’t jump the gun and start entering Play Mode to test it
    out just yet… we still need to assign the sound the door will play when sliding
    open!
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the audio clip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I was somehow tempted to grab the sound of the *Star Trek: The Next Generation*
    Enterprise NCC-1701-D’s sliding door opening sound, but yeah, copyright laws and
    all. ;)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not to worry, Freesound is to the rescue again! The sound file we’ll be using
    for our sliding doors is `cua-ien-tu-mo.wav` (in Vietnamese, *của điện tử mở*
    or “open electronics”), which you can download here: https://freesound.org/people/SieuAmThanh/sounds/511540/.
    It is also licensed CC0.'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `cua-ien-tu-mo.wav` file is imported to the `Assets/Audio/SFX` folder
    and go back to the `AudioPlayerSFX3D` component by opening the `Door_Triggered`
    Prefab again. Click and drag the `cua-ien-tu-mo` file to the **Audio Clip** field,
    then click **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: Playtest the level, adjust the `AudioPlayerSFX3D` component as needed, and take
    notice of the 3D sound playback.
  prefs: []
  type: TYPE_NORMAL
- en: 3D Sound Settings | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: Use the **3D Sound Settings** section of the **AudioSource** component to adjust
    the sound as desired for the spatial effect you’re looking for. The parameters
    in this section are applied proportionally to the **Spatial** **Blend** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about audio source properties here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: The next audio player component we’ll tackle is also for 3D sound – in the next
    section, let’s make an audio player for ambient sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Playing ambient sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding ambient 3D sounds to a game’s environment is essential for defining the
    setting, bringing it to life, and enhancing the player’s sensory experience. While
    adding ambient sound to our environment, let’s keep in mind that it’s crucial
    to match the sounds to the setting, layer different sound elements to create the
    soundscape, and change or vary the sound – interactively or not.
  prefs: []
  type: TYPE_NORMAL
- en: We first need our ambient audio player component to get started adding ambient
    sounds to our level. Because ambient sound is 3D in nature, we’ll again take the
    same approach as our 3D SFX and rely on an audio source added to our object to
    produce its sound.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use `Play()` on the `AudioSource` component directly this time because
    other methods, such as `PlayOneShot()`, cannot trigger looping sounds. However,
    there are some limitations to using `AudioSource.Play()`. It only allows one audio
    clip to be played simultaneously with an audio source. Calling `Play()` on an
    audio source that is already playing will stop the audio source and start the
    clip again. But we only care about the ability to loop the audio for playing ambient
    sounds in the environment so these limitations are not an issue here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take care of setting up the `AudioSource` component right away. Create
    a new script named `AudioPlayerAmbient` in the `Assets/Scripts/Audio` folder and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll need the **Inspector** field to assign the audio clip for the ambient
    sound to play on this object and the required play methods. Add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The specifics related to the methods added to play ambient sounds are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Start()`: Ambient sounds always play! (That’s a rule I just came up with.)
    So, we’ll start playing the ambient sound when the level begins. Note that because
    this is a 3D sound and configured with its specific audio source attached to the
    3D object in the environment, the player will only hear it when they are within
    range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Play()`: Similar to what we did before, we’re calling the audio manager `PlayAudio()`
    method and passing in the ambient sound’s `AudioSource` component to modify it
    and assign the correct Audio Mixer group for playback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, implement the `IPlaySound` interface’s public properties and methods
    so the audio manager knows which Audio Mixer group to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an ambient sound, so we must set `PlayAudioType` to `Ambient` and then
    play the audio clip indefinitely for this audio player component’s specific `PlaySound()`
    method functionality, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `source.clip` to the `_audioClip` value (set in the **Inspector**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `spatialBlend = 1f` much like how we enforced music to play in 2D (`0f`)
    within the `AudioPlayerMusic` component. Here, we’ll enforce the audio to play
    as a fully 3D sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `source.loop` to `true`. This is because ambient sounds continuously loop
    indefinitely!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the sound using `source.Play()` because we cannot use `PlayOneShot()` for
    a looping sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, these various audio-playing components have really come together! In the
    next section, let’s continue providing example implementations for each with an
    ambient sound.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing PlayAmbientSound
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First things first, we need to identify something in our environment to use
    as an example ambient sound implementation. Let’s look at the models provided
    by Polypix Studios for an answer… I see we have a 3D model Prefab asset imported
    to the `Assets/Polypix 3D Assets/Prefabs` folder called **Ventilation 1**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use this as a ventilation shaft inlet somewhere on our level. These types
    of things generally have something running – making noise – that pulls and circulates
    the air. A perfect environmental audio addition!
  prefs: []
  type: TYPE_NORMAL
- en: Art assets
  prefs: []
  type: TYPE_NORMAL
- en: 'The art assets used in this section are available from the GitHub project files
    repo. The **Ventilation 1** Prefab, in particular, is available from the **Art-Assets**
    folder included in the **3DArtwork.zip** file (or from the Unity project files
    directly): [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets).'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Ventilation 1` Prefab from the `Assets/Polypix 3D Assets/Prefabs` folder
    to the level somewhere – by dragging it in from the **Project** window – to give
    a lovely ambiance to one of the habitation station’s rooms. In *Figure 12**.10*,
    I’ve added it to a rather sparse-looking room that needs some interest.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Ventilation ambient sound](img/B18347_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Ventilation ambient sound
  prefs: []
  type: TYPE_NORMAL
- en: With the ventilation shaft inlet added to the scene, let’s add the ambient 3D
    sound audio player component.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Ventilation 1` Prefab in Prefab Edit Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your preferred method to add the `AudioPlayerAmbient` component to the root
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `AudioSource` component will automatically be added when we add the audio
    player component (due to the `RequireComponent` attribute).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike the previous audio player components, where we provided fields for `AudioSource`
    component to tailor the sound to the proper environmental audio effect for its
    location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we continue configuring the audio source, it would help to have a sound
    to play so we can make the proper adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: The sound file we’ll use for our ventilation shaft inlet is `metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac`
    (no, I didn’t name it!). It comes from Freesound ([https://freesound.org/people/kyles/sounds/455811/](https://freesound.org/people/kyles/sounds/455811/))
    and is licensed CC0 (still free to use).
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac`
    file is imported to the `Assets/Audio/Ambient` folder. We’ll make a few changes
    to the import settings values for this sound file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring back to *Figure 12**.4* for an import settings reference, set the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Force To Mono** = true, **Normalize** = true: Disregard the L/R stereo channels
    of the sound file (combine them) and set the audio levels to a normalized value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load In Background** = true: Loads the larger-sized audio file without causing
    the main thread to lag. Sound will start playing once the file is loaded (which
    may not be at the start of the scene being loaded).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Type** = **Streaming**: Decode audio with minimal memory use from disk
    and using a separate CPU thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`30`: Balance playback quality and file size by adjusting the compression slider
    for a compressed clip. Keep the file small for distribution while maintaining
    playback quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return to the `AudioPlayerAmbient` component on the ventilation shaft inlet,
    then click and drag the `metro-subway-hallway-corner-noise-heavy-ventilation-rumble`
    file to the `Ventilation 1` Prefab (by clicking **Save** in Prefab Edit Mode,
    or at the top of the **Inspector**, click **Apply All** in the **Prefab** | **Overrides**
    dropdown).
  prefs: []
  type: TYPE_NORMAL
- en: Before we playtest the level with the ambient sound playing, let’s review the
    3D sound settings that affect how ambient sound can be heard in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 3D ambient sound settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to put our sound designer hat on! When we added the audio player component
    to the ventilation shaft inlet Prefab, I mentioned we’d tailor the sound directly
    using the audio source properties.
  prefs: []
  type: TYPE_NORMAL
- en: Referring to the `270` to influence how the sound is distributed in 3D space.
    Lower values create more directional sound (heard only in front of the source),
    whereas higher values produce more omnidirectional sound (can be heard from wider
    angles). A value of `360` would make it seem like the sound is coming from everywhere
    around the listener.
  prefs: []
  type: TYPE_NORMAL
- en: Tip | Open the Properties window
  prefs: []
  type: TYPE_NORMAL
- en: In the **Inspector**, right-clicking on the **AudioSource** component title,
    then clicking **Properties…** will open it in a floating **Properties** window.
    You can do this for objects, components, and file assets from most windows in
    the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Playtest the level, adjust the **Spread** value of the audio source as desired,
    and take notice of the ambient sound’s playback.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create components to play audio for different
    auditory experiences and implement them on objects in our environment. In the
    next section, we’ll add to immersion in the environment by adding footstep sounds
    to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the audio experience with footsteps and reverb zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an immersive and enjoyable gaming experience requires paying close
    attention to sound design. Even seemingly simple elements, such as footstep sounds,
    play a significant role in grounding characters in their environment and conveying
    a sense of physicality and presence.
  prefs: []
  type: TYPE_NORMAL
- en: With footsteps in particular, it’s crucial to have a variety of footstep sounds
    to randomize them and adjust tempo or cadence based on the player’s speed to prevent
    auditory fatigue and repetition (you could even take it so far as to have different
    sounds for each surface type the player walks on).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing how continuously randomized audio clips are played back is also essential
    to ensure the process doesn’t negatively impact the game’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: With our footstep sounds implementation, we will address all these factors.
    Considering the audio player components and manager code we’ve already written,
    the implementation is more straightforward than you may think.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing audio player code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nothing could be simpler than starting with one of our existing audio player
    components to play the footstep sounds! So, we’ll rely on `AudioPlayerSFX` for
    the footsteps and not create footstep sounds with a new direct implementation
    of the `IPlaySound` interface. I mean, we could, but we’d just be duplicating
    the functionality that `AudioPlayerSFX` already provides. For those of you keeping
    track, the cards in play here are code reuse, **don’t repeat yourself** (**DRY**),
    **keep it simple, silly** (**KISS**), and let’s also claim the single responsibility
    card.
  prefs: []
  type: TYPE_NORMAL
- en: This time, instead of requiring a built-in component provided by the Unity game
    engine, we’ll require our own `AudioPlayerSFX` component to be added to the GameObject
    that we’re adding a new play footstep sounds component to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this implementation by creating a new `AudioPlayerFootsteps` script
    in the `Assets/Scripts/Audio` folder with the following initial code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the `RequireComponent` attribute forces a composition pattern by combining
    components to implement the desired functionality. So, as mentioned previously,
    we’ve required the `AudioPlayerSFX` component and pre-assigned the reference to
    the `_playerSFX` variable in the `OnValidate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also declare these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_walkInterval`: This variable value should match the cadence, or speed, of
    the player walking – in other words, the time between the footstep sound playing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_timerStep`: This variable will hold the current interval for footstep sounds
    to play (spoiler alert: we’ll have different values assigned based on whether
    the player is walking or sprinting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, we have the base boilerplate code in place. Let’s add our footstep audio
    clips list variable and an update loop to play a random footstep sound from the
    list at the assigned time interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, we’ve done precisely what’s needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_footstepSounds`: Here, we have our `AudioClip[]` array of footstep sound
    file assets that will be randomly selected and played at the set time interval.
    Refer to *Figure 12**.11* for a sneak peek at this **Inspector** assignment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update()`: The update loop will keep our `_timeStep` variable current with
    its new time. Then, we’ll evaluate to see whether `_timeStep` has expired to play
    the following randomly selected clip. We finish up by resetting `_timeStep` to
    delay the next play at intervals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking good! Optionally, we can do a bit better for code readability, and
    that would be with a quick refactor extracting the code that gets a random footstep
    sound into a local function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The line of code for playing the SFX would now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It’s, again, a quick, optional refactor that doesn’t change the functionality.
    Still, one that makes for better code readability – and anything that helps code
    readability is worth the little bit of extra work for clarity (for someone else
    looking at your code or yourself in six months), and if it requires a bit more,
    add a code comment!
  prefs: []
  type: TYPE_NORMAL
- en: Complete code for the audio player components
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget, at any time, if you need to see the completed code for these
    sections, you can find it at the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio)'
  prefs: []
  type: TYPE_NORMAL
- en: The `AudioPlayerFootsteps` component doesn’t play sound itself. As we know,
    it uses `PlaySoundSFX.Play()` and passes an audio clip as the parameter. The only
    problem is that `Play()` doesn’t currently accept a parameter! Let’s fix that
    now by adding a method overload.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a method overload to AudioPlayerSFX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, now, we’ll overload the `Play()` method in `AudioPlayerSFX` to add the required
    `AudioClip` parameter for the current audio clip for the footstep we want to play
    (well, that was randomly selected for us to play).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `AudioPlayerSFX`, add the following method with its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We already have a `Play()` method without a parameter, so we’re overloading
    the `Play()` method now by declaring another with the same method name but with
    a different method signature (because we’ve added the `AudioClip` parameter).
    Now, when `Play()` is called, the one that matches the method signature will be
    the specific method executed – either with the passed-in audio clip or without.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid frequent clip changes: It’s important to remember that repeatedly changing
    an **AudioSource** clip can be less efficient than using multiple audio sources
    or the **AudioSource.PlayOneShot()** method. In such cases, it’s recommended to
    use the **PlayOneShot()** method, as it allows you to play a clip without changing
    the audio source’s main clip.'
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to adding the footstep sounds to our player character in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AudioPlayerFootsteps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, this will be our fifth implementation of an audio player component, so
    there’s no reason to delay. Let’s go right ahead and add to `PlayerCapsule`. Since
    we’ll be requiring some of the other components already on the `PlayerCapsule`
    object in the next section (such as `CharacterController` and `PlayerInput`),
    we’ll want to add `AudioPlayerFootsteps` right to the root of this object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve added `AudioPlayerFootsteps`, you should have seen `AudioPLayerSFX`
    added, thanks to the `RequireComponent` attribute, so that takes care of the ability
    to play sound through the SFX Audio Mixer channel. All that’s left to do to get
    something playing is to add the sound files to the `_footstepSounds` array in
    the **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: The sound files we’ll use this time come from the Unity Asset Store. We’ll use
    `Classic Footstep SFX (Free)` by Matthew Anett ([https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668](https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668)).
    From its name, you can see that we can use it freely in our projects. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `Classic Footstep SFX (Free)` package is imported to your project.
    By default, this will be the `Assets/Classic Footstep SFX` folder. Unlike with
    the other audio files, since this is a package, the import settings are already
    set for us by the author, so we’re all set to start using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to assign the provided footstep sound files to the `AudioPlayerFootsteps`
    component’s `_footstepSounds` array field:'
  prefs: []
  type: TYPE_NORMAL
- en: Return to the `AudioPlayerFootsteps` component on `PlayerCapsule` and lock the
    **Inspector** window (using the little *lock* icon at the top-right of the **Inspector**
    tab). By locking the window, no matter what we select, the **Inspector** will
    stay on this window, which is essential for selecting multiple objects in the
    **Project** window to be assigned to a component field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Assets/Classic Footstep SFX/Floor` folder in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While within the `Floor_step0`), then hold *Shift* and click on the last sound
    file, or any range of files to select them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the sound files selected, click and drag (from anywhere in the selection)
    to the **Footstep Sounds** field label, and you’ll see the mouse cursor change
    from an arrow to an arrow with a box and a plus sign. Releasing the mouse button
    while hovering over the field name will populate the array with all the sound
    files in the selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can unlock the **Inspector** window now and check the assignment of the
    sound files by expanding the array (with the arrow to the left of the **Footstep
    Sounds** field label) as seen in *Figure 12**.11*. Note that I’ve only shown five
    assigned for brevity in the figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – AudioPlayerFootsteps component assignments](img/B18347_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – AudioPlayerFootsteps component assignments
  prefs: []
  type: TYPE_NORMAL
- en: If you try to use the `AudioPlayerFootsteps` code as it sits now, you’re going
    to be hearing footsteps all the darn time because there are no conditional statements
    to tell us when we should not play footsteps! That just won’t do, so let’s modify
    `AudioPlayerFootsteps` with a conditional check.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a reference to the player character controller… so add a new
    field to `AudioPlayerFootsteps` to hold the reference (you’ll have to set the
    reference in the **Inspector** for this field manually, so don’t forget to – you
    inevitably will fail, I know I do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now evaluate “Is the player grounded or moving?” by adding the following
    `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using `return`, we short-circuit the `Update()` method so it doesn’t continue
    and, therefore, doesn’t play any footstep sounds. Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, playtesting will give us our footstep sounds only while walking.
    However, we can also have the player sprint by holding the *Shift* key while moving
    forward. The problem we currently face is that the interval for the footstep sounds
    is consistent, resulting in sprinting sounding identical to walking. We can quickly
    solve this problem by adding a condition for a second interval, specifically for
    sprinting.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sprinting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, that setup made it sound like this would be difficult. It is not. It’s
    barely inconvenient because we’ll tap directly into the **Player** **Input** functionality.
  prefs: []
  type: TYPE_NORMAL
- en: When we provide input – by pressing keys or using a gamepad – the Input System
    processes those keys through the **Player Input** component, which, in turn, sends
    out message events. So, all we have to do is add a method handler (i.e., listener)
    for the one sent when the player wants to start sprinting. In *Figure 12**.12*,
    that’s **OnSprint**, and we can see it listed right on the **Player Input** component
    in the box just under **Behavior**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Player Input SendMessage() to GameObject list](img/B18347_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Player Input SendMessage() to GameObject list
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the ability to respond to the player sprinting is now just a matter
    of updating the `AudioPlayerFootsteps` class with the required code. Add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We add a new variable to assign the time interval for sprinting in the `_sprintInterval`
    and a related Boolean variable to evaluate whether the player is currently sprinting
    or not, with `_isSprinting`. Then, `OnSprint()` will set `_isSprinting` to `true`
    or `false` depending on `value.isPressed` passed in from the Input System.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do now is assign the proper step interval to the `_currentStepInterval`
    variable that will be used along with the `_timerStep` variable for playing footsteps
    at the correct time interval. Do so by making the following changes to the `Update()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And that wraps up footstep sounds! Playtesting now should produce footsteps
    matching the player while walking or sprinting. This is precisely the attention
    to detail that sets your games apart from the field – players notice and appreciate
    an indie developer’s efforts with things like this.
  prefs: []
  type: TYPE_NORMAL
- en: One additional attention to immersive sound details in your level that you can
    quickly add to the production value of your game soundscape is reverb zones, and
    the next section will show the simple steps to add one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding reverb zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reverb zones simulate the acoustics of sound in different spaces, whether echoing
    in a large warehouse or dampening in a small storage room, adding depth to the
    soundscape and enhancing the game’s atmosphere as the player moves between different
    areas in a level.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, simulating the acoustic properties can assist in storytelling
    and subtly guide player emotions and expectations, which is just another tool
    game designers can use to build more immersive and believable gaming experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find some key areas in your level where you feel the acoustics would be affected
    by the scale of the space. Using *Figure 12**.13*, we’ll use the following example
    to add a reverb zone to one of the larger rooms of the level:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an empty GameObject to the scene and position it in the center of a large
    room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the GameObject `Reverb Zone` (optionally, parent it to an object to organize
    all zones in the **Hierarchy**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `AudioReverbZone` component to the `Reverb` `Zone` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about reverb zones here: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an appropriate **ReverbPreset** option. Or, select **User** and customize
    the property sliders underneath to your desired effect. In the following figure,
    you can see I chose the **Hangar** preset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Reverb zone placement and settings](img/B18347_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Reverb zone placement and settings
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all that’s required to add the reverb zone to our level – playtest
    and adjust the zone properties to your liking. However, we’ll want to ensure that
    the music playback isn’t affected by the reverb zone (that wouldn’t make sense
    for the music to be affected by the environmental changes, would it?).
  prefs: []
  type: TYPE_NORMAL
- en: We can do this very easily in our code – we *have to* because we don’t have
    a resident `AudioSource` sitting on a GameObject in our scene for playing music;
    we’re adding it via code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our `AudioManager` script, in the `PlayMusic()` method, simply add this
    line to the list of audio source music settings we assign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Our music playback will no longer be affected by the reverb zone,
    while the remainder of the playing sounds, especially the footstep sounds, will
    be.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of adding audio to our game. In this section, we learned
    how to create varying audio playback components that route through an audio manager
    class to establish the rules for how sound is played with this system.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an audio toolset at our disposal to handle most use cases for the
    different types of audio playback a game requires. You can now revisit the earlier
    projects in the book to add your own sound design and level up the gameplay experience
    for the player. Have fun while wearing your sound designer hat!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll have a quick look at how we can refactor our audio player components
    to better adhere to the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Deeper SOLID refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can take the OCP of the SOLID principles further by using an abstract base
    class that all audio player classes derive from. This can add further required
    implementations and default behavior and would then be a classic **object-oriented
    programming** (**OOP**) inheritance example.
  prefs: []
  type: TYPE_NORMAL
- en: OOP SOLID principles reminder
  prefs: []
  type: TYPE_NORMAL
- en: In OOP, the derived class inherits all base class members and can also add its
    members. However, it’s essential to keep the *Liskov substitution* principle of
    the SOLID principles in mind when using derived classes. The *L* principle states
    that objects of a base class should be replaceable with objects of a derived class
    without changing the correctness of the program. In simpler terms, any program
    that uses a base class reference should be able to use any derived classes without
    knowing it. For OOP, this is polymorphism, which allows us to write more general
    code that works with any audio-playing class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we might write an abstract base class that the audio-playing
    classes in our project could inherit from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_audioClip`: The field is marked protected, which means inherited classes
    can access it. Makes things pretty easy, eh?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract PlayAudioType` (property): This abstract property ensures that each
    derived class will define its own `AudioType` value. This is a good use of an
    abstract property because it enforces each audio-playing class to specify its
    own `AudioType` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlaySound()`: The method provides a default implementation for playing a sound
    that all inheriting classes can share. Because we included the `virtual` keyword
    in the method signature, if a derived class needs a different behavior, it can
    override this method. We must also define `PlaySound()` – and `PlayAudioType`
    – because we must implement the `IPlaySound` interface!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Play()`: The method provides a way to play the specified `AudioClip`. Here,
    we’re delegating the play functionality to the `AudioManager` instance, adhering
    to our pattern and assigning the `AudioMixerGroup` group accordingly for the `AudioType`
    value. Note it’s also `virtual`, so it can be overridden by inheriting classes
    if a different behavior is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AudioPlayerBase` abstract base class provides a good foundation for creating
    specific audio-playing classes – as many different kinds as needed. We’ve enforced
    a consistent interface for our classes to provide default implementations for
    behavior while allowing for customization by the inheriting classes. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how we can approach an abstract base class that all our
    audio-playing classes can derive from, go ahead and try the refactor yourself!
    The project code on the GitHub link for the chapter has already provided an example
    of a refactored `AudioPlayerSFX3D_Derived` component that inherits from the `AudioPlayerBase`
    abstract base class, so you can use that as a reference (give it an honest try,
    no peeking).
  prefs: []
  type: TYPE_NORMAL
- en: AudioPlayerBase completed code
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the completed code for the **AudioPlayerBase** class and an example
    of an inherited class, visit the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to refactor our code to be more aligned with
    the SOLID programming principles. While our code is pretty complete already (I’m
    sure someone could always think of more types of audio player components to extend),
    this refactor makes it even easier to extend upon the code to add additional audio
    player component types without having to modify the manager class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this “audio chapter,” we extensively covered adding audio to our game by
    introducing an audio manager and individual reusable audio player components.
    We used the audio manager as a fool-proof implementation for designers and developers
    alike to target the appropriate mixer group for setting playback levels for the
    game’s soundscape.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by coding individual audio components for sound playback of the
    different types of audio common in most games – music, SFX, and ambient sound.
    We created these reusable audio player components following SOLID programming
    principles so we can extend additional types of audio components without modifying
    the manager class. We finished with a footsteps sound example showing how we can
    compose components for a simple implementation and also quickly add an environmental
    audio effect with reverb zones.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll continue to flesh out the game by adding an intelligent
    non-player character (NPC). We’ll accomplish this by, again, refactoring our previous
    2D code for 3D usage as well as introducing cutting-edge technology for dynamic
    enemies utilizing sensors, a behavior tree, and machine learning (AI) techniques.
  prefs: []
  type: TYPE_NORMAL
