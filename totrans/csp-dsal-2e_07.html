<html><head></head><body>
<div id="_idContainer088">
<h1 class="chapter-number" id="_idParaDest-122"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-123"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.2.1">Variants of Trees</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, you learned about many data structures, starting with simple ones such as arrays. </span><span class="koboSpan" id="kobo.3.2">Now, it is time for you to get to know a significantly more complex group of data structures, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">namely </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.5.1">trees</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">At the beginning of this chapter, a </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">basic tree</span></strong><span class="koboSpan" id="kobo.9.1"> will be</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.10.1"> presented, together with its implementation in the C# language, and with some examples showing it in action. </span><span class="koboSpan" id="kobo.10.2">Then, a </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">binary tree</span></strong><span class="koboSpan" id="kobo.12.1"> will be</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.13.1"> introduced, with a detailed description of its implementation and an example of its application. </span><span class="koboSpan" id="kobo.13.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">binary search tree</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">BST</span></strong><span class="koboSpan" id="kobo.17.1">) is another tree variant and is </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.18.1">one of the most popular types of trees, used in many algorithms. </span><span class="koboSpan" id="kobo.18.2">You will also</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.19.1"> cover </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">self-balancing trees</span></strong><span class="koboSpan" id="kobo.21.1">, namely </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">AVL</span></strong><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.23.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">red-black trees</span></strong><span class="koboSpan" id="kobo.25.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.26.1">RBTs</span></strong><span class="koboSpan" id="kobo.27.1">). </span><span class="koboSpan" id="kobo.27.2">Then, you will see a </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">trie</span></strong><span class="koboSpan" id="kobo.29.1"> as a specialized data structure for performing </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.30.1">operations on strings. </span><span class="koboSpan" id="kobo.30.2">The remaining part of the chapter is dedicated to a short introduction to the topic </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">of </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.32.1">heaps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Arrays, lists, stacks, queues, dictionaries, sets, and now trees. </span><span class="koboSpan" id="kobo.34.2">Are you ready to increase the level of difficulty and learn the next data structures? </span><span class="koboSpan" id="kobo.34.3">If so, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">start reading!</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">In this chapter, the following topics will </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">be covered:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Basic trees</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Binary trees</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Binary </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">search trees</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.42.1">Self-balancing trees</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Tries</span></span></li>
<li><a id="_idTextAnchor235"/><a id="_idTextAnchor236"/><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Heaps</span></span></li>
</ul>
<h1 id="_idParaDest-124"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.45.1">Basic trees</span></h1>
<p><span class="koboSpan" id="kobo.46.1">Let’s start with introducing trees. </span><span class="koboSpan" id="kobo.46.2">What </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.47.1">are they? </span><span class="koboSpan" id="kobo.47.2">Do you have any ideas about how such a data structure should look? </span><span class="koboSpan" id="kobo.47.3">If not, let’s take a look at the following diagram, which depicts a tree with captions regarding its </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">particular elements:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.49.1"><img alt="Figure 7.1 – ﻿Illustration of a tree" src="image/B18069_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.50.1">Figure 7.1 – Illustration of a tree</span></p>
<p><span class="koboSpan" id="kobo.51.1">A tree consists of multiple </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">nodes</span></strong><span class="koboSpan" id="kobo.53.1">, including</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.54.1"> one </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">root</span></strong><span class="koboSpan" id="kobo.56.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.57.1">100</span></strong><span class="koboSpan" id="kobo.58.1"> in the diagram). </span><span class="koboSpan" id="kobo.58.2">The root</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.59.1"> does not </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.60.1">contain a </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">parent</span></strong><span class="koboSpan" id="kobo.62.1"> node, while all other nodes do. </span><span class="koboSpan" id="kobo.62.2">For example, the parent element of node </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">1</span></strong><span class="koboSpan" id="kobo.64.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">100</span></strong><span class="koboSpan" id="kobo.66.1">, while node </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">96</span></strong><span class="koboSpan" id="kobo.68.1"> has node </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">30</span></strong><span class="koboSpan" id="kobo.70.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">the parent.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Moreover, each node can have any number </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.73.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">child</span></strong><span class="koboSpan" id="kobo.75.1"> nodes, such as three </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">children</span></strong><span class="koboSpan" id="kobo.77.1"> (that is, </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">50</span></strong><span class="koboSpan" id="kobo.79.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">1</span></strong><span class="koboSpan" id="kobo.81.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">150</span></strong><span class="koboSpan" id="kobo.83.1">) in the case of the </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">root</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">The child nodes of the same node can be named </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">siblings</span></strong><span class="koboSpan" id="kobo.87.1">, as in the case of nodes </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">70</span></strong><span class="koboSpan" id="kobo.89.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">61</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">A node without children is named a </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">leaf</span></strong><span class="koboSpan" id="kobo.93.1">, such </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.94.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">45</span></strong><span class="koboSpan" id="kobo.96.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">6</span></strong><span class="koboSpan" id="kobo.98.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the diagram.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Let’s take a look at the rectangle with three nodes (that is, </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">30</span></strong><span class="koboSpan" id="kobo.102.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">96</span></strong><span class="koboSpan" id="kobo.104.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">9</span></strong><span class="koboSpan" id="kobo.106.1">). </span><span class="koboSpan" id="kobo.106.2">Such a part of the tree can be called a </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">subtree</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">Of course, you </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.109.1">can find many subtrees in </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">the tree.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.111.1">Imagine a tree</span></p>
<p class="callout"><span class="koboSpan" id="kobo.112.1">If you want to better imagine a tree, look at the structure of a slightly larger company, where at the very top of the hierarchy there</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.113.1"> is the </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">chief executive officer</span></strong><span class="koboSpan" id="kobo.115.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.116.1">CEO</span></strong><span class="koboSpan" id="kobo.117.1">), to whom the </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">chief operating officer</span></strong><span class="koboSpan" id="kobo.119.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.120.1">COO</span></strong><span class="koboSpan" id="kobo.121.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">chief marketing officer</span></strong><span class="koboSpan" id="kobo.123.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.124.1">CMO</span></strong><span class="koboSpan" id="kobo.125.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">chief financial officer</span></strong><span class="koboSpan" id="kobo.127.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.128.1">CFO</span></strong><span class="koboSpan" id="kobo.129.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">chief technology officer</span></strong><span class="koboSpan" id="kobo.131.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.132.1">CTO</span></strong><span class="koboSpan" id="kobo.133.1">) are assigned. </span><span class="koboSpan" id="kobo.133.2">As</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.134.1"> sales is one</span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.135.1"> of the key topics in the </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.136.1">company’s operations, regional </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.137.1">directors report to the COO, and for each of them, between three and five sales specialists are assigned. </span><span class="koboSpan" id="kobo.137.2">Look for yourself – you have a tree in your mind right now! </span><span class="koboSpan" id="kobo.137.3">Its root is the CEO, which has four children (COO, CMO, CFO, and CTO), which can have further child nodes to create subsequent levels of the hierarchy. </span><span class="koboSpan" id="kobo.137.4">Sales specialists who no longer have any subordinates are </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">named leaves.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Let’s briefly talk about the minimum and maximum numbers of children of a node. </span><span class="koboSpan" id="kobo.139.2">In general, such numbers are not limited, and each node can contain zero, one, two, three, or even more children. </span><span class="koboSpan" id="kobo.139.3">However, in practical applications, the number of children is often limited to two, as y</span><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.140.1">o</span><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.141.1">u will </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">see soon.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.143.1">Implementation</span></h2>
<p><span class="koboSpan" id="kobo.144.1">The C#-based implementation of a</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.145.1"> basic tree seems to be quite obvious and not complicated. </span><span class="koboSpan" id="kobo.145.2">To do so, you declare two classes, representing a single node and a whole tree, as describe</span><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.146.1">d</span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.147.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">this section.</span></span></p>
<h3><span class="koboSpan" id="kobo.149.1">Node</span></h3>
<p><span class="koboSpan" id="kobo.150.1">The first class is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">TreeNode</span></strong><span class="koboSpan" id="kobo.152.1"> and is declared as a generic class to provide a developer with the ability to specify a type of data stored in each node. </span><span class="koboSpan" id="kobo.152.2">Thus, you can create a strongly typed solution, which</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.153.1"> eliminates the necessity of casting objects to target types. </span><span class="koboSpan" id="kobo.153.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">TreeNode&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.157.1">
{
    public T? </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">Data</span></strong><span class="koboSpan" id="kobo.159.1"> { get; set; }
    public TreeNode&lt;T&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">Parent</span></strong><span class="koboSpan" id="kobo.161.1"> { get; set; }
    public List&lt;TreeNode&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Children</span></strong><span class="koboSpan" id="kobo.163.1"> { get; set; } = [];
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">GetHeight</span></strong><span class="koboSpan" id="kobo.165.1">()
    {
        int height = 1;
        TreeNode&lt;T&gt; current = this;
        while (current.Parent != null)
        {
            height++;
            current = current.Parent;
        }
        return height;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.166.1">The class contains </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">three properties:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.168.1">The data stored in the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">node (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.172.1">A reference to the parent </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">node (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Parent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.176.1">A collection of references to child </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">nodes (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Children</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.180.1">Apart from th</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.181.1">e properties, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">TreeNode</span></strong><span class="koboSpan" id="kobo.183.1"> class contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">GetHeight</span></strong><span class="koboSpan" id="kobo.185.1"> method, which returns the height of the node – that is, the distance from this node to the root node. </span><span class="koboSpan" id="kobo.185.2">The implementation of this method is very simple because it just uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">while</span></strong><span class="koboSpan" id="kobo.187.1"> loop to go up from the node until there is no parent element, which means that </span><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.188.1">t</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.189.1">he root </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">is reached.</span></span></p>
<h3><span class="koboSpan" id="kobo.191.1">Tree</span></h3>
<p><span class="koboSpan" id="kobo.192.1">The next necessary class</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.193.1"> is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Tree</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">It represents the whole tree, </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">Tree&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.199.1">
{
    public TreeNode&lt;T&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">Root</span></strong><span class="koboSpan" id="kobo.201.1"> { get; set; }
}</span></pre> <p><span class="koboSpan" id="kobo.202.1">The class contains only one property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">Root</span></strong><span class="koboSpan" id="kobo.204.1">. </span><span class="koboSpan" id="kobo.204.2">You can use this property to get access to the root node, and then you can use its </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">Children</span></strong><span class="koboSpan" id="kobo.206.1"> property to obtain data of its child nodes. </span><span class="koboSpan" id="kobo.206.2">Then, you can take a look at each of them and get data of their child nodes, as well. </span><span class="koboSpan" id="kobo.206.3">By repeating such operations, you can get data from all nodes located in </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">the tree.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">It is worth noting that</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.209.1"> both </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">TreeNode</span></strong><span class="koboSpan" id="kobo.211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Tree</span></strong><span class="koboSpan" id="kobo.213.1"> classes are generic, and the same type is used in the case of these classes. </span><span class="koboSpan" id="kobo.213.2">For instance, if tree nodes should store </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">string</span></strong><span class="koboSpan" id="kobo.215.1"> values, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">string</span></strong><span class="koboSpan" id="kobo.217.1"> type should be used for instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Tree</span><a id="_idTextAnchor245"/></strong> <a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.219.1">and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">TreeNode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1"> classes.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.222.1">Example – hierarchy of identifiers</span></h2>
<p><span class="koboSpan" id="kobo.223.1">Do you want to see how</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.224.1"> to use a tree in a C#-based application? </span><span class="koboSpan" id="kobo.224.2">Let’s take a look at our first example. </span><span class="koboSpan" id="kobo.224.3">The aim is to construct a tree with a few nodes, as shown in the following diagram. </span><span class="koboSpan" id="kobo.224.4">Only the group of nodes with a bolder border will be presented in the code. </span><span class="koboSpan" id="kobo.224.5">However, it is a good idea to adjust the code to construct the whole tree </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">by yourself:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.226.1"><img alt="Figure 7.2 – ﻿Illustration of the hierarchy of identifiers example" src="image/B18069_07_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.227.1">Figure 7.2 – Illustration of the hierarchy of identifiers example</span></p>
<p><span class="koboSpan" id="kobo.228.1">Here, each node stores an integer value, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">int</span></strong><span class="koboSpan" id="kobo.230.1"> is the type used for both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Tree</span></strong><span class="koboSpan" id="kobo.232.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">TreeNode</span></strong><span class="koboSpan" id="kobo.234.1"> classes. </span><span class="koboSpan" id="kobo.234.2">The</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.235.1"> following code should be placed in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
Tree&lt;int&gt; tree = new() { Root = new() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.239.1">100</span></strong><span class="koboSpan" id="kobo.240.1"> } };
tree.Root.Children =
[
    new() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.241.1">50</span></strong><span class="koboSpan" id="kobo.242.1">, Parent = tree.Root },
    new() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">1</span></strong><span class="koboSpan" id="kobo.244.1">, Parent = tree.Root },
    new() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">150</span></strong><span class="koboSpan" id="kobo.246.1">, Parent = tree.Root }
];
tree.Root.Children[2].Children =
[
    new() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">30</span></strong><span class="koboSpan" id="kobo.248.1">, Parent = tree.Root.Children[2] }
];</span></pre> <p><span class="koboSpan" id="kobo.249.1">The code looks quite simple, doesn’t it? </span><span class="koboSpan" id="kobo.249.2">At the beginning, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Tree</span></strong><span class="koboSpan" id="kobo.251.1"> class is created and the root node is configured by creating a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">TreeNode</span></strong><span class="koboSpan" id="kobo.253.1"> class and setting a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Data</span></strong><span class="koboSpan" id="kobo.255.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">100</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">In the following lines, the child nodes of the root node are specified, namely the nodes with values equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">50</span></strong><span class="koboSpan" id="kobo.261.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">1</span></strong><span class="koboSpan" id="kobo.263.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">150</span></strong><span class="koboSpan" id="kobo.265.1">. </span><span class="koboSpan" id="kobo.265.2">For each of them, a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">Parent</span></strong><span class="koboSpan" id="kobo.267.1"> property is set to a reference to the previously added </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">root node.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">The remaining part of the code shows how to add a child node for a given node, namely for the third child of the root node – that is, the node with a value equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">150</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">Here, only one node is added: the one with the value set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">30</span></strong><span class="koboSpan" id="kobo.273.1">. </span><span class="koboSpan" id="kobo.273.2">Of course, you need to specify a reference to the parent node, </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">That’s all! </span><span class="koboSpan" id="kobo.275.2">You created the first program that uses trees. </span><span class="koboSpan" id="kobo.275.3">Now, you can run it, but you will not see any output in the console. </span><span class="koboSpan" id="kobo.275.4">If you want to see how the data of nodes is organized, you can debug the program and see the values of vari</span><a id="_idTextAnchor248"/><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.276.1">ables </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">while debugging.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.278.1">Example – company structure</span></h2>
<p><span class="koboSpan" id="kobo.279.1">In the previous example, you saw</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.280.1"> how to use integer values as data stored in each node in a tree. </span><span class="koboSpan" id="kobo.280.2">However, it is also possible to store instances of user-defined classes in nodes. </span><span class="koboSpan" id="kobo.280.3">In this example, you will see how to create a tree presenting the structure of a company, divided into three main departments: development, research, </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">and sales.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">Within each department, there can be another structure, such as in the case of the development team. </span><span class="koboSpan" id="kobo.282.2">Here, </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">John Smith</span></strong><span class="koboSpan" id="kobo.284.1"> is head of development. </span><span class="koboSpan" id="kobo.284.2">He is a boss for </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">Chris Morris</span></strong><span class="koboSpan" id="kobo.286.1">, who is a manager for two junior developers, </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">Eric Green</span></strong><span class="koboSpan" id="kobo.288.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">Ashley Lopez</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">The latter is also a supervisor of </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">Emily Young</span></strong><span class="koboSpan" id="kobo.292.1">, who is a </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">developer intern.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">An example tree is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.296.1"><img alt="Figure 7.3 – ﻿Illustration of the company structure example" src="image/B18069_07_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.297.1">Figure 7.3 – Illustration of the company structure example</span></p>
<p><span class="koboSpan" id="kobo.298.1">As you can see, each node should store more information than just an integer value. </span><span class="koboSpan" id="kobo.298.2">There should be a name and a role. </span><span class="koboSpan" id="kobo.298.3">Such data is stored as values of properties in an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Person</span></strong><span class="koboSpan" id="kobo.300.1"> record, which</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.301.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
public record </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">Person</span></strong><span class="koboSpan" id="kobo.305.1">(string Name, string Role);</span></pre> <p><span class="koboSpan" id="kobo.306.1">Apart from creating a new record, it is also necessary to add </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">some code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
Tree&lt;Person&gt; company = new()
{
    Root = new()
    {
        Data = new Person("</span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Marcin Jamro</span></strong><span class="koboSpan" id="kobo.310.1">",
            "Chief Executive Officer"),
        Parent = null
    }
};
company.Root.Children =
[
    new() { Data = new Person("</span><strong class="bold"><span class="koboSpan" id="kobo.311.1">John Smith</span></strong><span class="koboSpan" id="kobo.312.1">",
        "Head of Development"), Parent = company.Root },
    new() { Data = new Person("</span><strong class="bold"><span class="koboSpan" id="kobo.313.1">Alice Batman</span></strong><span class="koboSpan" id="kobo.314.1">",
        "Head of Research"), Parent = company.Root },
    new() { Data = new Person("</span><strong class="bold"><span class="koboSpan" id="kobo.315.1">Lily Smith</span></strong><span class="koboSpan" id="kobo.316.1">",
        "Head of Sales"), Parent = company.Root }
];
company.Root.Children[2].Children =
[
    new() { Data = new Person("</span><strong class="bold"><span class="koboSpan" id="kobo.317.1">Anthony Black</span></strong><span class="koboSpan" id="kobo.318.1">",
        "Senior Sales Specialist"),
        Parent = company.Root.Children[2] }
];</span></pre> <p><span class="koboSpan" id="kobo.319.1">In the first line, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Tree</span></strong><span class="koboSpan" id="kobo.321.1"> class is created. </span><span class="koboSpan" id="kobo.321.2">It is worth mentioning that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Person</span></strong><span class="koboSpan" id="kobo.323.1"> record is used as a type specified while creating new instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Tree</span></strong><span class="koboSpan" id="kobo.325.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">TreeNode</span></strong><span class="koboSpan" id="kobo.327.1"> classes. </span><span class="koboSpan" id="kobo.327.2">Thus, you can easily store more than one simple data type for each node. </span><span class="koboSpan" id="kobo.327.3">The remaining lines of code look similar to the first example for basic trees. </span><span class="koboSpan" id="kobo.327.4">Here, you also specify the root node (for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Chief Executive Officer</span></strong><span class="koboSpan" id="kobo.329.1"> role), then configure its child elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">John Smith</span></strong><span class="koboSpan" id="kobo.331.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Alice Batman</span></strong><span class="koboSpan" id="kobo.333.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">Lily Smith</span></strong><span class="koboSpan" id="kobo.335.1">), and set a child node for one of the existing nodes, namely the node for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Head of </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Sales</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1"> role.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Does it look simple and </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.340.1">straightforward? </span><span class="koboSpan" id="kobo.340.2">In the next section, you will see a more restricted, but very important and well-known variant</span><a id="_idTextAnchor251"/> <a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.341.1">of trees: a </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">binary tree.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.343.1">Binary trees</span></h1>
<p><span class="koboSpan" id="kobo.344.1">Generally speaking, each node in a basic tree can </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.345.1">contain any number of children. </span><span class="koboSpan" id="kobo.345.2">However, in the case of </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">binary trees</span></strong><span class="koboSpan" id="kobo.347.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">a node cannot contain more than two children</span></strong><span class="koboSpan" id="kobo.349.1">. </span><span class="koboSpan" id="kobo.349.2">It means that </span><strong class="bold"><span class="koboSpan" id="kobo.350.1">it can contain zero,</span></strong><em class="italic"> </em><strong class="bold"><span class="koboSpan" id="kobo.351.1">one, or two child nodes</span></strong><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">Such a requirement has an important impact on the shape of a binary tree, as shown in the following two diagrams presenting </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">binary trees:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.354.1"><img alt="Figure 7.4 – ﻿Illustration of binary trees" src="image/B18069_07_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.355.1">Figure 7.4 – Illustration of binary trees</span></p>
<p><span class="koboSpan" id="kobo.356.1">As already mentioned, a node in</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.357.1"> a binary tree can contain at most two children. </span><span class="koboSpan" id="kobo.357.2">For this </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.358.1">reason, they are referred to as the </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">left child</span></strong><span class="koboSpan" id="kobo.360.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.361.1">right child</span></strong><span class="koboSpan" id="kobo.362.1">. </span><span class="koboSpan" id="kobo.362.2">In the case of the binary</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.363.1"> tree shown on the left-hand side of the preceding diagram, node </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">21</span></strong><span class="koboSpan" id="kobo.365.1"> has two children, namely </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">68</span></strong><span class="koboSpan" id="kobo.367.1"> as the left child and </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">12</span></strong><span class="koboSpan" id="kobo.369.1"> as the right child, while node </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">100</span></strong><span class="koboSpan" id="kobo.371.1"> has only a </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">left child.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.373.1">Traversal</span></h2>
<p><span class="koboSpan" id="kobo.374.1">Have you thought about </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.375.1">how you can iterate through all the nodes in a tree? </span><span class="koboSpan" id="kobo.375.2">How can you specify an order of nodes during </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">traversal</span></strong><span class="koboSpan" id="kobo.377.1"> of a tree? </span><span class="koboSpan" id="kobo.377.2">There are three common approaches, namely </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">pre-order</span></strong><span class="koboSpan" id="kobo.379.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">in-order</span></strong><span class="koboSpan" id="kobo.381.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.382.1">post-order</span></strong><span class="koboSpan" id="kobo.383.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">shown next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.385.1"><img alt="Figure 7.5 – Pre-order, in-order, and post-order traversal" src="image/B18069_07_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.386.1">Figure 7.5 – Pre-order, in-order, and post-order traversal</span></p>
<p><span class="koboSpan" id="kobo.387.1">As you can see in the diagram, there are visible differences between the approaches. </span><span class="koboSpan" id="kobo.387.2">However, do you have </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.388.1">any idea how you can apply pre-order, in-order, or post-order traversals for binary trees? </span><span class="koboSpan" id="kobo.388.2">Let’s explain all of these approaches </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">in detail.</span></span></p>
<h3><span class="koboSpan" id="kobo.390.1">Pre-order</span></h3>
<p><span class="koboSpan" id="kobo.391.1">If you want to</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.392.1"> traverse a binary tree with the </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">pre-order</span></strong><span class="koboSpan" id="kobo.394.1"> approach, you first visit the root node. </span><span class="koboSpan" id="kobo.394.2">Then, you visit the left child. </span><span class="koboSpan" id="kobo.394.3">Finally, the right child is visited. </span><span class="koboSpan" id="kobo.394.4">Of course, such a rule does not apply only to the root node, but to any node in a tree. </span><span class="koboSpan" id="kobo.394.5">For this reason, you can understand the order of pre-order traversal as </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">first visiting the current node, then its left child (the whole left subtree using the pre-order approach recursively), and finally its right child (the right subtree in a </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.396.1">similar way)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">The explanation can sound a bit complicated, so let’s take a look at a simple example regarding the tree shown on the left of the preceding diagram. </span><span class="koboSpan" id="kobo.398.2">First, the root node (that is, </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">1</span></strong><span class="koboSpan" id="kobo.400.1">) is visited. </span><span class="koboSpan" id="kobo.400.2">Then, you analyze its left child node. </span><span class="koboSpan" id="kobo.400.3">For this reason, the next visited node is the current node, </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">9</span></strong><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">The next step is the pre-order traversal of its left child. </span><span class="koboSpan" id="kobo.402.3">Thus, </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">5</span></strong><span class="koboSpan" id="kobo.404.1"> is visited. </span><span class="koboSpan" id="kobo.404.2">As this node does not contain any children, you can return to the stage of traversing when </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">9</span></strong><span class="koboSpan" id="kobo.406.1"> is the current node. </span><span class="koboSpan" id="kobo.406.2">It has already been visited, as has its left child node, so it is time to proceed to its right child. </span><span class="koboSpan" id="kobo.406.3">Here, you first visit the current node, </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">6</span></strong><span class="koboSpan" id="kobo.408.1">, and follow to its left child, </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">3</span></strong><span class="koboSpan" id="kobo.410.1">. </span><span class="koboSpan" id="kobo.410.2">You can apply the same rules to continue traversing the tree. </span><span class="koboSpan" id="kobo.410.3">The final order is </span><strong class="bold"><span class="koboSpan" id="kobo.411.1">1</span></strong><span class="koboSpan" id="kobo.412.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">9</span></strong><span class="koboSpan" id="kobo.414.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">5</span></strong><span class="koboSpan" id="kobo.416.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">6</span></strong><span class="koboSpan" id="kobo.418.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">3</span></strong><span class="koboSpan" id="kobo.420.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.421.1">4</span></strong><span class="koboSpan" id="kobo.422.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">2</span></strong><span class="koboSpan" id="kobo.424.1">, </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.425.1">7</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.427.1">8</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">If it still sounds a bit confusing, the</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.430.1"> following diagram should remove </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">any doubts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.432.1"><img alt="Figure 7.6 – Detailed diagram of pre-order traversal" src="image/B18069_07_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.433.1">Figure 7.6 – Detailed diagram of pre-order traversal</span></p>
<p><span class="koboSpan" id="kobo.434.1">The diagram presents</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.435.1"> the following steps of the pre-order traversal with additional indicators: </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">C</span></strong><span class="koboSpan" id="kobo.437.1"> for the </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">current node</span></strong><span class="koboSpan" id="kobo.439.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">L</span></strong><span class="koboSpan" id="kobo.441.1"> for the </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">left child</span></strong><span class="koboSpan" id="kobo.443.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">R</span></strong><span class="koboSpan" id="kobo.445.1"> for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.446.1">right child</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.448.1">In-order</span></h3>
<p><span class="koboSpan" id="kobo.449.1">The second traversal mode is called </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">in-order</span></strong><span class="koboSpan" id="kobo.451.1">. </span><span class="koboSpan" id="kobo.451.2">It differs from the pre-order approach in the order that nodes are </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.452.1">visited: </span><strong class="bold"><span class="koboSpan" id="kobo.453.1">the left child, the current node, and then the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">right child</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">If you take a look at the</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.457.1"> example shown in the diagram with all three traversal modes, you can see that the first visited node is </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">5</span></strong><span class="koboSpan" id="kobo.459.1">. </span><span class="koboSpan" id="kobo.459.2">Why? </span><span class="koboSpan" id="kobo.459.3">At the beginning, the root node is analyzed, but it is not visited because the in-order traversal starts with the left child node. </span><span class="koboSpan" id="kobo.459.4">Thus, it analyzes node </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">9</span></strong><span class="koboSpan" id="kobo.461.1">, but it also has a left child, </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">5</span></strong><span class="koboSpan" id="kobo.463.1">, so you proceed to this node. </span><span class="koboSpan" id="kobo.463.2">As this node does not have any children, the current node (</span><strong class="bold"><span class="koboSpan" id="kobo.464.1">5</span></strong><span class="koboSpan" id="kobo.465.1">) is visited. </span><span class="koboSpan" id="kobo.465.2">Then, you return to the step when the current node is </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">9</span></strong><span class="koboSpan" id="kobo.467.1">, and, as its left child was already visited, you also visit the current node. </span><span class="koboSpan" id="kobo.467.2">Next, you follow to the right child, but it has a left child, </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">3</span></strong><span class="koboSpan" id="kobo.469.1">, which should be visited first. </span><span class="koboSpan" id="kobo.469.2">According to the same rules, you visit the remaining nodes in the binary tree. </span><span class="koboSpan" id="kobo.469.3">The final order is </span><strong class="bold"><span class="koboSpan" id="kobo.470.1">5</span></strong><span class="koboSpan" id="kobo.471.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">9</span></strong><span class="koboSpan" id="kobo.473.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">3</span></strong><span class="koboSpan" id="kobo.475.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">6</span></strong><span class="koboSpan" id="kobo.477.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">1</span></strong><span class="koboSpan" id="kobo.479.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.480.1">4</span></strong><span class="koboSpan" id="kobo.481.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.482.1">7</span></strong><span class="koboSpan" id="kobo.483.1">, </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.484.1">8</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.486.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.488.1">Post-order</span></h3>
<p><span class="koboSpan" id="kobo.489.1">The last traversal mode is named </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">post-order</span></strong><span class="koboSpan" id="kobo.491.1"> and supports the following order of node traversal: </span><strong class="bold"><span class="koboSpan" id="kobo.492.1">the left child, the right child, and then the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.493.1">current node</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">Let’s analyze the post-order</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.496.1"> example shown on the right-hand side of the diagram. </span><span class="koboSpan" id="kobo.496.2">At the beginning, the root node is analyzed but it is not visited because the post-order traversal starts with the left child node. </span><span class="koboSpan" id="kobo.496.3">Thus, you proceed to node </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">9</span></strong><span class="koboSpan" id="kobo.498.1">, then </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">5</span></strong><span class="koboSpan" id="kobo.500.1">, which you visit first. </span><span class="koboSpan" id="kobo.500.2">Next, you need to analyze the right child of node </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">9</span></strong><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">However, node </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">6</span></strong><span class="koboSpan" id="kobo.504.1"> has the left child (</span><strong class="bold"><span class="koboSpan" id="kobo.505.1">3</span></strong><span class="koboSpan" id="kobo.506.1">), which should be visited earlier. </span><span class="koboSpan" id="kobo.506.2">For this reason, after </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">5</span></strong><span class="koboSpan" id="kobo.508.1">, you visit </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">3</span></strong><span class="koboSpan" id="kobo.510.1">, and then </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">6</span></strong><span class="koboSpan" id="kobo.512.1">, followed by </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">9</span></strong><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">What is interesting is that the root node of the binary tree is visited at the end. </span><span class="koboSpan" id="kobo.514.3">The final order is </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">5</span></strong><span class="koboSpan" id="kobo.516.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">3</span></strong><span class="koboSpan" id="kobo.518.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.519.1">6</span></strong><span class="koboSpan" id="kobo.520.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.521.1">9</span></strong><span class="koboSpan" id="kobo.522.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.523.1">8</span></strong><span class="koboSpan" id="kobo.524.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">7</span></strong><span class="koboSpan" id="kobo.526.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">2</span></strong><span class="koboSpan" id="kobo.528.1">, </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.529.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.531.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.533.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.534.1">If you want to check whether a binary tree contains a given value, you need to check each node, traversing the tree using one of three available modes: pre-order, in-order, or post-order. </span><span class="koboSpan" id="kobo.534.2">This means that the lookup time is linear, </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">namely </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.536.1">O(n)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">After this short introduction, let’s proce</span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.539.1">e</span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.540.1">d to the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">C#-based implementation.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.542.1">Implementation</span></h2>
<p><span class="koboSpan" id="kobo.543.1">The implementation of a binary tree is simple, especially if you use the already d</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.544.1">escribed code for the </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.545.1">basic tree. </span><span class="koboSpan" id="kobo.545.2">Let’s start</span><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.546.1"> with a class representing </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">a node.</span></span></p>
<h3><span class="koboSpan" id="kobo.548.1">Node</span></h3>
<p><span class="koboSpan" id="kobo.549.1">A node in a binary tree is represented by an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">BinaryTreeNode</span></strong><span class="koboSpan" id="kobo.551.1">, which inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">TreeNode</span></strong><span class="koboSpan" id="kobo.553.1"> generic class. </span><span class="koboSpan" id="kobo.553.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">BinaryTreeNode</span></strong><span class="koboSpan" id="kobo.555.1"> class, it is necessary to hide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">Children</span></strong><span class="koboSpan" id="kobo.557.1"> definition</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.558.1"> from the base class, as well as declare two properties, </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">Left</span></strong><span class="koboSpan" id="kobo.560.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Right</span></strong><span class="koboSpan" id="kobo.562.1">, which represent both possible children of a node. </span><span class="koboSpan" id="kobo.562.2">The relevant part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">BinaryTreeNode&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.566.1">
    : TreeNode&lt;T&gt;
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.567.1">public new BinaryTreeNode&lt;T&gt;?[] Children { get; set; }</span></strong><span class="koboSpan" id="kobo.568.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.569.1">= [null, null];</span></strong><span class="koboSpan" id="kobo.570.1">
    public BinaryTreeNode&lt;T&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.571.1">Left</span></strong><span class="koboSpan" id="kobo.572.1">
    {
        get { return Children[0]; }
        set { Children[0] = value; }
    }
    public BinaryTreeNode&lt;T&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">Right</span></strong><span class="koboSpan" id="kobo.574.1">
    {
        get { return Children[1]; }
        set { Children[1] = value; }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.575.1">Moreover, you need to ensure that the array with child nodes contains exactly two items, initially set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">null</span></strong><span class="koboSpan" id="kobo.577.1">. </span><span class="koboSpan" id="kobo.577.2">Thus, if you want to add a child node, a reference to it should be placed as the first or the second element of the array from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Children</span></strong><span class="koboSpan" id="kobo.579.1"> property. </span><span class="koboSpan" id="kobo.579.2">Therefore, such an </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.580.1">array always has exactly two elements, and </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.581.1">you can access the first or the second one without any exception. </span><span class="koboSpan" id="kobo.581.2">If such an element is set to any node, a reference to it is </span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.582.1">r</span><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.583.1">eturned. </span><span class="koboSpan" id="kobo.583.2">Otherwise, </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">null</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.585.1">is returned.</span></span></p>
<h3><span class="koboSpan" id="kobo.586.1">Tree</span></h3>
<p><span class="koboSpan" id="kobo.587.1">The next necessary class is </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.588.1">named </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">BinaryTree</span></strong><span class="koboSpan" id="kobo.590.1">. </span><span class="koboSpan" id="kobo.590.2">It represents the whole binary tree. </span><span class="koboSpan" id="kobo.590.3">By using the generic class, you can easily specify the type of data stored in each node. </span><span class="koboSpan" id="kobo.590.4">The first part of the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">BinaryTree</span></strong><span class="koboSpan" id="kobo.592.1"> class is </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.595.1">BinaryTree&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.596.1">
{
    public BinaryTreeNode&lt;T&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">Root</span></strong><span class="koboSpan" id="kobo.598.1"> { get; set; }
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.599.1">Count</span></strong><span class="koboSpan" id="kobo.600.1"> { get; set; }
}</span></pre> <p><span class="koboSpan" id="kobo.601.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">BinaryTree</span></strong><span class="koboSpan" id="kobo.603.1"> class contains </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">two properties:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">Root</span></strong><span class="koboSpan" id="kobo.606.1"> indicates the root node (instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">BinaryTreeNode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1"> class)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">Count</span></strong><span class="koboSpan" id="kobo.610.1"> stores the total number of nodes placed in </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">the tree</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.612.1">Of course, these are not the only members of the class because it is also equipped with a set of methods regarding traversing the tree. </span><span class="koboSpan" id="kobo.612.2">The first traversal method is </span><strong class="bold"><span class="koboSpan" id="kobo.613.1">pre-order</span></strong><span class="koboSpan" id="kobo.614.1">. </span><span class="koboSpan" id="kobo.614.2">As a reminder, it first visits the current node, then its left child, followed by the right child. </span><span class="koboSpan" id="kobo.614.3">The code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">TraversePreOrder</span></strong><span class="koboSpan" id="kobo.616.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.618.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.619.1">TraversePreOrder</span></strong><span class="koboSpan" id="kobo.620.1">(BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.620.2">node,
    List&lt;BinaryTreeNode&lt;T&gt;&gt; result)
{
    if (node == null) { return; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">result.Add(node);</span></strong><span class="koboSpan" id="kobo.622.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">TraversePreOrder(node.Left, result);</span></strong><span class="koboSpan" id="kobo.624.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">TraversePreOrder(node.Right, result);</span></strong><span class="koboSpan" id="kobo.626.1">
}</span></pre> <p><span class="koboSpan" id="kobo.627.1">The method takes two parameters: the current node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">node</span></strong><span class="koboSpan" id="kobo.629.1">) and the list of already visited nodes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">result</span></strong><span class="koboSpan" id="kobo.631.1">). </span><span class="koboSpan" id="kobo.631.2">The recursive implementation is very simple. </span><span class="koboSpan" id="kobo.631.3">First, you check whether the node exists by ensuring that the parameter is not equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">null</span></strong><span class="koboSpan" id="kobo.633.1">. </span><span class="koboSpan" id="kobo.633.2">Then, you add the current node to the collection </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.634.1">of visited nodes, start the same traversal method for the left child, and then start it for the </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">right child.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">Similar implementation is possible for the </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">in-order</span></strong><span class="koboSpan" id="kobo.638.1"> and post-order traversal modes. </span><span class="koboSpan" id="kobo.638.2">Let’s start with the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">TraverseInOrder</span></strong><span class="koboSpan" id="kobo.640.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">TraverseInOrder</span></strong><span class="koboSpan" id="kobo.644.1">(BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.644.2">node,
    List&lt;BinaryTreeNode&lt;T&gt;&gt; result)
{
    if (node == null) { return; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">TraverseInOrder(node.Left, result);</span></strong><span class="koboSpan" id="kobo.646.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.647.1">result.Add(node);</span></strong><span class="koboSpan" id="kobo.648.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.649.1">TraverseInOrder(node.Right, result);</span></strong><span class="koboSpan" id="kobo.650.1">
}</span></pre> <p><span class="koboSpan" id="kobo.651.1">Here, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">TraverseInOrder</span></strong><span class="koboSpan" id="kobo.653.1"> method for the left child, add the current node to the list of visited nodes, and start the in-order traversal for the </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">right child.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">The next method is related to the </span><strong class="bold"><span class="koboSpan" id="kobo.656.1">post-order</span></strong><span class="koboSpan" id="kobo.657.1"> traversal mode, </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.659.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.660.1">TraversePostOrder</span></strong><span class="koboSpan" id="kobo.661.1">(BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.661.2">node,
    List&lt;BinaryTreeNode&lt;T&gt;&gt; result)
{
    if (node == null) { return; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.662.1">TraversePostOrder(node.Left, result);</span></strong><span class="koboSpan" id="kobo.663.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">TraversePostOrder(node.Right, result);</span></strong><span class="koboSpan" id="kobo.665.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">result.Add(node);</span></strong><span class="koboSpan" id="kobo.667.1">
}</span></pre> <p><span class="koboSpan" id="kobo.668.1">The code is similar to the already described methods, but, of course, another order of visiting nodes is applied. </span><span class="koboSpan" id="kobo.668.2">Here, you start with the left child, then you visit the right child, followed by adding the current </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.669.1">node to the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">visited nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">Finally, let’s add a public method for traversing the tree in various modes, which calls the private methods presented earlier. </span><span class="koboSpan" id="kobo.671.2">The relevant code is </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
public List&lt;BinaryTreeNode&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">Traverse</span></strong><span class="koboSpan" id="kobo.675.1">(TraversalEnum mode)
{
    List&lt;BinaryTreeNode&lt;T&gt;&gt; nodes = [];
    if (Root == null) { return nodes; }
    switch (mode)
    {
        case TraversalEnum.PreOrder:
            </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">TraversePreOrder</span></strong><span class="koboSpan" id="kobo.677.1">(Root, nodes);
            break;
        case TraversalEnum.InOrder:
            </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">TraverseInOrder</span></strong><span class="koboSpan" id="kobo.679.1">(Root, nodes);
            break;
        case TraversalEnum.PostOrder:
            </span><strong class="bold"><span class="koboSpan" id="kobo.680.1">TraversePostOrder</span></strong><span class="koboSpan" id="kobo.681.1">(Root, nodes);
            break;
    }
    return nodes;
}</span></pre> <p><span class="koboSpan" id="kobo.682.1">The method takes only one parameter, namely a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">TraversalEnum</span></strong><span class="koboSpan" id="kobo.684.1"> enumeration, which chooses the proper mode from pre-order, in-order, and post-order. </span><span class="koboSpan" id="kobo.684.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">Traverse</span></strong><span class="koboSpan" id="kobo.686.1"> method uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">switch</span></strong><span class="koboSpan" id="kobo.688.1"> statement to call a suitable private method, depending on the value of the parameter. </span><span class="koboSpan" id="kobo.688.2">The </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.689.1">mentioned enumeration is </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.691.1">
public enum </span><strong class="bold"><span class="koboSpan" id="kobo.692.1">TraversalEnum</span></strong><span class="koboSpan" id="kobo.693.1"> { PreOrder, InOrder, PostOrder }</span></pre> <p><span class="koboSpan" id="kobo.694.1">The last method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">BinaryTree</span></strong><span class="koboSpan" id="kobo.696.1"> class is </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">GetHeight</span></strong><span class="koboSpan" id="kobo.698.1">. </span><span class="koboSpan" id="kobo.698.2">It returns the height of the tree, which can be understood as the maximum number of steps to travel from any leaf node to the root. </span><span class="koboSpan" id="kobo.698.3">The implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
public int </span><strong class="bold"><span class="koboSpan" id="kobo.701.1">GetHeight</span></strong><span class="koboSpan" id="kobo.702.1">() =&gt; Root != null
    ? </span><span class="koboSpan" id="kobo.702.2">Traverse(TraversalEnum.PreOrder)
        .Max(n =&gt; n.GetHeight())
    : 0;</span></pre> <p><span class="koboSpan" id="kobo.703.1">After the introduction to the topic of binary trees, let’s see an example where this data structure is used for stori</span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.704.1">n</span><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.705.1">g questions and answers in a </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">simple quiz.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.707.1">Example – simple quiz</span></h2>
<p><span class="koboSpan" id="kobo.708.1">As an example of a binary tree, a simple quiz application will be prepared. </span><span class="koboSpan" id="kobo.708.2">The quiz consists of a few questions and </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.709.1">answers, shown depending on previously taken decisions. </span><span class="koboSpan" id="kobo.709.2">The application presents the question, waits until the user presses </span><em class="italic"><span class="koboSpan" id="kobo.710.1">Y</span></em><span class="koboSpan" id="kobo.711.1"> (yes) or </span><em class="italic"><span class="koboSpan" id="kobo.712.1">N</span></em><span class="koboSpan" id="kobo.713.1"> (no), and proceeds to the next question or shows </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">the answer.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">The structure of the quiz is created in the form of a binary tree, </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.717.1"><img alt="Figure 7.7 – ﻿Illustration of the simple quiz example" src="image/B18069_07_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.718.1">Figure 7.7 – Illustration of the simple quiz example</span></p>
<p><span class="koboSpan" id="kobo.719.1">At the beginning, the user is asked whether they have any experience in application development. </span><span class="koboSpan" id="kobo.719.2">If so, the program asks whether they have worked as a developer for more than 5 years. </span><span class="koboSpan" id="kobo.719.3">In the case of a positive answer, the result regarding applying to work as a senior developer is </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.720.1">presented. </span><span class="koboSpan" id="kobo.720.2">Of course, other answers and questions are shown in the case of different decisions taken by </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">The implementation of the simple quiz requires the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">BinaryTree</span></strong><span class="koboSpan" id="kobo.724.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">BinaryTreeNode</span></strong><span class="koboSpan" id="kobo.726.1"> classes, which were presented and explained earlier. </span><span class="koboSpan" id="kobo.726.2">Each node stores only a </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">string</span></strong><span class="koboSpan" id="kobo.728.1"> value as data, representing either a question or </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">an answer.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">Let’s take a look at the main part of </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
BinaryTree&lt;string&gt; tree = GetTree();
BinaryTreeNode&lt;string&gt;? </span><span class="koboSpan" id="kobo.732.2">node = tree.Root;
while (</span><strong class="bold"><span class="koboSpan" id="kobo.733.1">node != null</span></strong><span class="koboSpan" id="kobo.734.1">)
{
    if (</span><strong class="bold"><span class="koboSpan" id="kobo.735.1">node.Left != null &amp;&amp; node.Right != null</span></strong><span class="koboSpan" id="kobo.736.1">)
    {
        Console.WriteLine(</span><strong class="bold"><span class="koboSpan" id="kobo.737.1">node.Data</span></strong><span class="koboSpan" id="kobo.738.1">);
        node = Console.ReadKey(true).Key switch
        {
            ConsoleKey.Y =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.739.1">node.Left</span></strong><span class="koboSpan" id="kobo.740.1">,
            ConsoleKey.N =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.741.1">node.Right</span></strong><span class="koboSpan" id="kobo.742.1">,
            _ =&gt; node
        };
    }
    else
    {
        Console.WriteLine(</span><strong class="bold"><span class="koboSpan" id="kobo.743.1">node.Data</span></strong><span class="koboSpan" id="kobo.744.1">);
        node = null;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.745.1">In the first line, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">GetTree</span></strong><span class="koboSpan" id="kobo.747.1"> method is called to construct a tree with questions and answers. </span><span class="koboSpan" id="kobo.747.2">Such a method will be shown next. </span><span class="koboSpan" id="kobo.747.3">Then, the root node is taken as the current node, for which the following operations are taken until an answer </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">is reached.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">At the beginning, you check whether</span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.750.1"> the left and right child nodes exist – that is, whether it is a question and not an answer. </span><span class="koboSpan" id="kobo.750.2">Then, the textual content is written in the console, and the program waits until the user presses a key. </span><span class="koboSpan" id="kobo.750.3">If it is equal to </span><em class="italic"><span class="koboSpan" id="kobo.751.1">Y</span></em><span class="koboSpan" id="kobo.752.1">, the current node’s left child is used as the current node. </span><span class="koboSpan" id="kobo.752.2">In the case of pressing </span><em class="italic"><span class="koboSpan" id="kobo.753.1">N</span></em><span class="koboSpan" id="kobo.754.1">, the current node’s right child is </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">used instead.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">When decisions taken by the user cause an answer to be shown, it is presented in the console, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">null</span></strong><span class="koboSpan" id="kobo.758.1"> is assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">node</span></strong><span class="koboSpan" id="kobo.760.1"> variable. </span><span class="koboSpan" id="kobo.760.2">Therefore, you break out of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">while</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.762.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.763.1">As mentioned, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">GetTree</span></strong><span class="koboSpan" id="kobo.765.1"> method is used to construct a binary tree with questions and answers. </span><span class="koboSpan" id="kobo.765.2">Its code is presented </span><a id="_idIndexMarker649"/><span class="No-Break"><span class="koboSpan" id="kobo.766.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
BinaryTree&lt;string&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.768.1">GetTree</span></strong><span class="koboSpan" id="kobo.769.1">()
{
    BinaryTree&lt;string&gt; tree = new();
    tree.Root = new BinaryTreeNode&lt;string&gt;()
    {
        Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.770.1">Do you have an experience</span></strong><span class="koboSpan" id="kobo.771.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.772.1">in app development?</span></strong><span class="koboSpan" id="kobo.773.1">",
        Children =
        [
            new BinaryTreeNode&lt;string&gt;()
            {
                Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.774.1">Have you worked as a developer</span></strong><span class="koboSpan" id="kobo.775.1">
                    </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">for 5+ years?</span></strong><span class="koboSpan" id="kobo.777.1">",
                Children =
                [
                    new() { Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.778.1">Apply as</span></strong><span class="koboSpan" id="kobo.779.1">
                        </span><strong class="bold"><span class="koboSpan" id="kobo.780.1">a senior developer</span></strong><span class="koboSpan" id="kobo.781.1">" },
                    new() { Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.782.1">Apply as</span></strong><span class="koboSpan" id="kobo.783.1">
                        </span><strong class="bold"><span class="koboSpan" id="kobo.784.1">a middle developer</span></strong><span class="koboSpan" id="kobo.785.1">" }
                ]
            },
            new BinaryTreeNode&lt;string&gt;()
            {
                Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.786.1">Have you completed a university?</span></strong><span class="koboSpan" id="kobo.787.1">",
                Children =
                [
                    new() { Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.788.1">Apply as</span></strong><span class="koboSpan" id="kobo.789.1">
                        </span><strong class="bold"><span class="koboSpan" id="kobo.790.1">a junior developer</span></strong><span class="koboSpan" id="kobo.791.1">" },
                    new BinaryTreeNode&lt;string&gt;()
                    {
                        Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.792.1">Will you find some time</span></strong><span class="koboSpan" id="kobo.793.1">
                            </span><strong class="bold"><span class="koboSpan" id="kobo.794.1">during the semester?</span></strong><span class="koboSpan" id="kobo.795.1">",
                        Children =
                        [
                            new() { Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.796.1">Apply for</span></strong><span class="koboSpan" id="kobo.797.1">
                                </span><strong class="bold"><span class="koboSpan" id="kobo.798.1">long-time internship</span></strong><span class="koboSpan" id="kobo.799.1">" },
                            new() { Data = "</span><strong class="bold"><span class="koboSpan" id="kobo.800.1">Apply for</span></strong><span class="koboSpan" id="kobo.801.1">
                                </span><strong class="bold"><span class="koboSpan" id="kobo.802.1">summer internship</span></strong><span class="koboSpan" id="kobo.803.1">" }
                        ]
                    }
                ]
            }
        ]
    };
    tree.Count = 9;
    return tree;
}</span></pre> <p><span class="koboSpan" id="kobo.804.1">At the beginning, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">BinaryTree</span></strong><span class="koboSpan" id="kobo.806.1"> generic class is created, and you assign a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">BinaryTreeNode</span></strong><span class="koboSpan" id="kobo.808.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">Root</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.810.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">What is interesting is that even while creating questions and answers programmatically, you create some kind of a tree-like structure because you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">Children</span></strong><span class="koboSpan" id="kobo.813.1"> property and specify items directly within such constructions. </span><span class="koboSpan" id="kobo.813.2">Therefore, you do not need to create many local variables for all questions and answers. </span><span class="koboSpan" id="kobo.813.3">It is worth noting that a question-related node is an</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.814.1"> instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">BinaryTreeNode</span></strong><span class="koboSpan" id="kobo.816.1"> class with two child nodes (for </span><em class="italic"><span class="koboSpan" id="kobo.817.1">yes</span></em><span class="koboSpan" id="kobo.818.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.819.1">no</span></em><span class="koboSpan" id="kobo.820.1"> decisions), while an answer-related node is a leaf, so it does not contain any </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">child nodes.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.822.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.823.1">In the presented solution, the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">Parent</span></strong><span class="koboSpan" id="kobo.825.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">BinaryTreeNode</span></strong><span class="koboSpan" id="kobo.827.1"> instances are not set. </span><span class="koboSpan" id="kobo.827.2">If you want to use them or get the height of a node or a tree, you should set them on </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">your own.</span></span></p>
<p><span class="koboSpan" id="kobo.829.1">The simple quiz application is ready! </span><span class="koboSpan" id="kobo.829.2">You can build the project, launch it, and answer a few questions to see the results. </span><span class="koboSpan" id="kobo.829.3">Then, let’s close the program and proceed to the next section, where a variant o</span><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.830.1">f</span><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.831.1"> the binary tree data structure </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">is presented.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.833.1">Binary search trees</span></h1>
<p><span class="koboSpan" id="kobo.834.1">A binary tree is an interesting data structure that allows the creation of a hierarchy of elements, with the restriction that each node can contain at most two children, but without any rules about relationships </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.835.1">between the nodes. </span><span class="koboSpan" id="kobo.835.2">For this reason, if you want to check whether a binary tree contains a given value, you need to check each node, traversing the tree using one of three available modes: pre-order, in-order, or post-order. </span><span class="koboSpan" id="kobo.835.3">This means that the lookup time is linear, </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">namely </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.837.1">O(n)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.839.1">What about a situation where there are some precise rules regarding relations between nodes in a tree? </span><span class="koboSpan" id="kobo.839.2">Let’s imagine a scenario where you know that the left subtree contains nodes with values smaller than the root’s value, while the right subtree contains nodes with values greater than the root’s value. </span><span class="koboSpan" id="kobo.839.3">Then, you can compare the searched value with the current node and decide whether you should continue searching in the left or right subtree. </span><span class="koboSpan" id="kobo.839.4">Such an approach can significantly limit the number of operations necessary to check whether the tree contains a given value. </span><span class="koboSpan" id="kobo.839.5">It seems quite interesting, </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">doesn’t it?</span></span></p>
<p><span class="koboSpan" id="kobo.841.1">This approach is applied in the </span><strong class="bold"><span class="koboSpan" id="kobo.842.1">binary search tree (BST)</span></strong><span class="koboSpan" id="kobo.843.1"> data structure. </span><span class="koboSpan" id="kobo.843.2">It is a kind of binary tree that introduces two strict rules regarding</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.844.1"> relations between nodes in the tree. </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">The rules state that for any node, the values of all nodes in its left subtree must be smaller than its value, and the values of all nodes in its right subtree must be greater than </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.846.1">its value.</span></strong></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.847.1">Can you add duplicates to BSTs?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.848.1">In general, a BST can contain two or</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.849.1"> more elements with the same value. </span><span class="koboSpan" id="kobo.849.2">However, within this book, a simplified version is given, which does not accept more than one element with the </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">same value.</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">How does it look in practice? </span><span class="koboSpan" id="kobo.851.2">Let’s take a look at the following diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">of BSTs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.853.1"><img alt="Figure 7.8 – ﻿Illustration of binary search trees." src="image/B18069_07_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.854.1">Figure 7.8 – Illustration of binary search trees.</span></p>
<p><span class="koboSpan" id="kobo.855.1">The tree shown on the left-hand side contains 12 nodes. </span><span class="koboSpan" id="kobo.855.2">Let’s check whether it complies with the BST rule. </span><span class="koboSpan" id="kobo.855.3">You can do so by analyzing each node in the tree, except leaf nodes. </span><span class="koboSpan" id="kobo.855.4">Let’s start with the root node (with value </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">50</span></strong><span class="koboSpan" id="kobo.857.1">), which contains four descendant nodes in the left subtree (</span><strong class="bold"><span class="koboSpan" id="kobo.858.1">40</span></strong><span class="koboSpan" id="kobo.859.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">30</span></strong><span class="koboSpan" id="kobo.861.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">45</span></strong><span class="koboSpan" id="kobo.863.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">43</span></strong><span class="koboSpan" id="kobo.865.1">), all smaller than </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">50</span></strong><span class="koboSpan" id="kobo.867.1">. </span><span class="koboSpan" id="kobo.867.2">The root node contains seven descendant nodes in the right subtree (</span><strong class="bold"><span class="koboSpan" id="kobo.868.1">60</span></strong><span class="koboSpan" id="kobo.869.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.870.1">80</span></strong><span class="koboSpan" id="kobo.871.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.872.1">70</span></strong><span class="koboSpan" id="kobo.873.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.874.1">65</span></strong><span class="koboSpan" id="kobo.875.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.876.1">75</span></strong><span class="koboSpan" id="kobo.877.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.878.1">90</span></strong><span class="koboSpan" id="kobo.879.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.880.1">100</span></strong><span class="koboSpan" id="kobo.881.1">), all greater than </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">50</span></strong><span class="koboSpan" id="kobo.883.1">. </span><span class="koboSpan" id="kobo.883.2">That means that the BST rule is satisfied for the root node. </span><span class="koboSpan" id="kobo.883.3">While checking the BST rule for node </span><strong class="bold"><span class="koboSpan" id="kobo.884.1">80</span></strong><span class="koboSpan" id="kobo.885.1">, you see that the values of all descendant nodes in the left subtree (</span><strong class="bold"><span class="koboSpan" id="kobo.886.1">70</span></strong><span class="koboSpan" id="kobo.887.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.888.1">65</span></strong><span class="koboSpan" id="kobo.889.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.890.1">75</span></strong><span class="koboSpan" id="kobo.891.1">) are smaller than </span><strong class="bold"><span class="koboSpan" id="kobo.892.1">80</span></strong><span class="koboSpan" id="kobo.893.1">, while the values in the right subtree (</span><strong class="bold"><span class="koboSpan" id="kobo.894.1">90</span></strong><span class="koboSpan" id="kobo.895.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.896.1">100</span></strong><span class="koboSpan" id="kobo.897.1">) are greater than </span><strong class="bold"><span class="koboSpan" id="kobo.898.1">80</span></strong><span class="koboSpan" id="kobo.899.1">. </span><span class="koboSpan" id="kobo.899.2">You should perform the same verification for all other nodes. </span><span class="koboSpan" id="kobo.899.3">Similarly, you can confirm that the BST from the right-hand side of the diagram adheres to </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">the rules.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">However, two such BSTs</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.902.1"> significantly differ in their </span><strong class="bold"><span class="koboSpan" id="kobo.903.1">topology</span></strong><span class="koboSpan" id="kobo.904.1">. </span><span class="koboSpan" id="kobo.904.2">Both have the same height, but the number of nodes is different, namely 12 and 7. </span><span class="koboSpan" id="kobo.904.3">The one on the left seems to be </span><strong class="bold"><span class="koboSpan" id="kobo.905.1">fat</span></strong><span class="koboSpan" id="kobo.906.1">, while the other is rather </span><strong class="bold"><span class="koboSpan" id="kobo.907.1">skinny</span></strong><span class="koboSpan" id="kobo.908.1">. </span><span class="koboSpan" id="kobo.908.2">Which one is better? </span><span class="koboSpan" id="kobo.908.3">To answer this question, let’s think about the algorithm for searching a value in the tree. </span><span class="koboSpan" id="kobo.908.4">As an example, the process of searching for the value </span><strong class="bold"><span class="koboSpan" id="kobo.909.1">43</span></strong><span class="koboSpan" id="kobo.910.1"> is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.912.1"><img alt="Figure 7.9 – Searching for a given value in a BST" src="image/B18069_07_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.913.1">Figure 7.9 – Searching for a given value in a BST</span></p>
<p><span class="koboSpan" id="kobo.914.1">At the beginning (</span><strong class="bold"><span class="koboSpan" id="kobo.915.1">Step 1</span></strong><span class="koboSpan" id="kobo.916.1">), you take a value of the root node (that is, </span><strong class="bold"><span class="koboSpan" id="kobo.917.1">50</span></strong><span class="koboSpan" id="kobo.918.1">) and check whether the given value (</span><strong class="bold"><span class="koboSpan" id="kobo.919.1">43</span></strong><span class="koboSpan" id="kobo.920.1">) is smaller </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.921.1">or greater. </span><span class="koboSpan" id="kobo.921.2">It is smaller, so you proceed to search in the left subtree (</span><strong class="bold"><span class="koboSpan" id="kobo.922.1">Step 2</span></strong><span class="koboSpan" id="kobo.923.1">). </span><span class="koboSpan" id="kobo.923.2">Thus, you compare </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">43</span></strong><span class="koboSpan" id="kobo.925.1"> with </span><strong class="bold"><span class="koboSpan" id="kobo.926.1">40</span></strong><span class="koboSpan" id="kobo.927.1">. </span><span class="koboSpan" id="kobo.927.2">This time, the right subtree is chosen because </span><strong class="bold"><span class="koboSpan" id="kobo.928.1">43</span></strong><span class="koboSpan" id="kobo.929.1"> is greater than </span><strong class="bold"><span class="koboSpan" id="kobo.930.1">40</span></strong><span class="koboSpan" id="kobo.931.1">. </span><span class="koboSpan" id="kobo.931.2">Next, </span><strong class="bold"><span class="koboSpan" id="kobo.932.1">43</span></strong><span class="koboSpan" id="kobo.933.1"> is compared with </span><strong class="bold"><span class="koboSpan" id="kobo.934.1">45</span></strong><span class="koboSpan" id="kobo.935.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.936.1">Step 3</span></strong><span class="koboSpan" id="kobo.937.1">), and the left subtree is chosen. </span><span class="koboSpan" id="kobo.937.2">Here, you compare </span><strong class="bold"><span class="koboSpan" id="kobo.938.1">43</span></strong><span class="koboSpan" id="kobo.939.1"> with </span><strong class="bold"><span class="koboSpan" id="kobo.940.1">43</span></strong><span class="koboSpan" id="kobo.941.1">, and the given value is found (</span><strong class="bold"><span class="koboSpan" id="kobo.942.1">Step 4</span></strong><span class="koboSpan" id="kobo.943.1">). </span><span class="koboSpan" id="kobo.943.2">If you take a look at the tree, you will see that only four comparisons </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">are necessary.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.945.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.946.1">The shape of a tree has a great impact on the lookup performance. </span><span class="koboSpan" id="kobo.946.2">Of course, </span><strong class="bold"><span class="koboSpan" id="kobo.947.1">it is much better to have a fat tree with limited height than a skinny tree with a bigger height</span></strong><span class="koboSpan" id="kobo.948.1">. </span><span class="koboSpan" id="kobo.948.2">The performance boost is caused by making decisions as to whether searching should be continued in the left or right subtree, without the necessity of analyzing the values of all nodes. </span><span class="koboSpan" id="kobo.948.3">If nodes do not have both subtrees, the positive impact on the performance will be limited. </span><span class="koboSpan" id="kobo.948.4">In the worst case, when </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.949.1">each node contains only one child, the search time is even linear. </span><span class="koboSpan" id="kobo.949.2">However, in the ideal BST, the lookup time is an </span><em class="italic"><span class="koboSpan" id="kobo.950.1">O(log </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.951.1">n)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.952.1"> operation.</span></span></p>
<p><span class="koboSpan" id="kobo.953.1">After this short introduction, let’s proceed to the implementation in the C# language. </span><span class="koboSpan" id="kobo.953.2">At the end, you will see an example that</span><a id="_idTextAnchor268"/> <a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.954.1">shows how to use this data structure </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">in practice.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.956.1">Implementation</span></h2>
<p><span class="koboSpan" id="kobo.957.1">The implementation of a BST is a bit more difficult than the previously described variants of trees. </span><span class="koboSpan" id="kobo.957.2">For example, it requires </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.958.1">you to prepare operations of insertion and removal of nodes from a tree, which do not break the rule</span><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.959.1"> regarding the arrangement of ele</span><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.960.1">ments in the BST. </span><span class="koboSpan" id="kobo.960.2">You will see a </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">solution shortly.</span></span></p>
<h3><span class="koboSpan" id="kobo.962.1">Tree</span></h3>
<p><span class="koboSpan" id="kobo.963.1">The whole tree is represented by an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">BinarySearchTree</span></strong><span class="koboSpan" id="kobo.965.1"> class, which inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">BinaryTree</span></strong><span class="koboSpan" id="kobo.967.1"> generic class, as in</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.968.1"> the following </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.970.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">BinarySearchTree&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.972.1">
    : </span><strong class="bold"><span class="koboSpan" id="kobo.973.1">BinaryTree&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.974.1">
    where T : </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">IComparable</span></strong><span class="koboSpan" id="kobo.976.1">
{
}</span></pre> <p><span class="koboSpan" id="kobo.977.1">It is worth mentioning that the type of data, stored in each node, should be comparable. </span><span class="koboSpan" id="kobo.977.2">For this reason, it has to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">IComparable</span></strong><span class="koboSpan" id="kobo.979.1"> interface. </span><span class="koboSpan" id="kobo.979.2">Such a requirement is necessary because the algorithm needs to know the relationships </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">between values.</span></span></p>
<p><span class="koboSpan" id="kobo.981.1">Of course, it is not the final version of the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">BinarySearchTree</span></strong><span class="koboSpan" id="kobo.983.1"> class. </span><span class="koboSpan" id="kobo.983.2">You will very soon learn how to add new featu</span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.984.1">re</span><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.985.1">s, such as lookup, insertion, and </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.986.1">removal </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">of nodes.</span></span></p>
<h3><span class="koboSpan" id="kobo.988.1">Lookup</span></h3>
<p><span class="koboSpan" id="kobo.989.1">Now, let’s take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">Contains</span></strong><span class="koboSpan" id="kobo.991.1"> method, which checks whether the tree contains a node with a given value. </span><span class="koboSpan" id="kobo.991.2">Of course, this method takes into account the BST rule regarding the arrangement of </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.992.1">nodes to limit the number of comparisons. </span><span class="koboSpan" id="kobo.992.2">The code is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">following block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.994.1">
public bool </span><strong class="bold"><span class="koboSpan" id="kobo.995.1">Contains</span></strong><span class="koboSpan" id="kobo.996.1">(T data)
{
    BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.996.2">node = Root;
    while (</span><strong class="bold"><span class="koboSpan" id="kobo.997.1">node != null</span></strong><span class="koboSpan" id="kobo.998.1">)
    {
        int result = data.CompareTo(node.Data);
        if (result == 0) { </span><strong class="bold"><span class="koboSpan" id="kobo.999.1">return true;</span></strong><span class="koboSpan" id="kobo.1000.1"> }
        else if (result &lt; 0) { </span><strong class="bold"><span class="koboSpan" id="kobo.1001.1">node = node.Left;</span></strong><span class="koboSpan" id="kobo.1002.1"> }
        else { </span><strong class="bold"><span class="koboSpan" id="kobo.1003.1">node = node.Right;</span></strong><span class="koboSpan" id="kobo.1004.1"> }
    }
    return false;
}</span></pre> <p><span class="koboSpan" id="kobo.1005.1">The method takes only one parameter, namely the value to find in the tree. </span><span class="koboSpan" id="kobo.1005.2">Inside the method, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">while</span></strong><span class="koboSpan" id="kobo.1007.1"> loop exists. </span><span class="koboSpan" id="kobo.1007.2">Within it, the searched value is compared with the value of the current node. </span><span class="koboSpan" id="kobo.1007.3">If they are equal (the comparison returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">0</span></strong><span class="koboSpan" id="kobo.1009.1">), the value is found, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">true</span></strong><span class="koboSpan" id="kobo.1011.1"> is returned to inform that the search is completed successfully. </span><span class="koboSpan" id="kobo.1011.2">If the searched value is smaller than the value of the current node, the algorithm continues searching in the left subtree. </span><span class="koboSpan" id="kobo.1011.3">Otherwise, the right subtree is </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">used instead.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1013.1">How to compare objects?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1014.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">CompareTo</span></strong><span class="koboSpan" id="kobo.1016.1"> method is provided by the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">IComparable</span></strong><span class="koboSpan" id="kobo.1018.1"> interface from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">System</span></strong><span class="koboSpan" id="kobo.1020.1"> namespace. </span><span class="koboSpan" id="kobo.1020.2">Such a method makes it possible to compare two values. </span><span class="koboSpan" id="kobo.1020.3">If they are equal, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">0</span></strong><span class="koboSpan" id="kobo.1022.1"> is returned. </span><span class="koboSpan" id="kobo.1022.2">If the object on which the method is called is bigger than the parameter, a value higher than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">0</span></strong><span class="koboSpan" id="kobo.1024.1"> is returned. </span><span class="koboSpan" id="kobo.1024.2">Otherwise, a value lower than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1026.1">is returned.</span></span></p>
<p><span class="koboSpan" id="kobo.1027.1">The loop is executed</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.1028.1"> until the node</span><a id="_idTextAnchor275"/> <a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.1029.1">is found or there is no suitable child node </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">to follow.</span></span></p>
<h3><span class="koboSpan" id="kobo.1031.1">Insertion</span></h3>
<p><span class="koboSpan" id="kobo.1032.1">The next necessary operation is the insertion of a node into a BST. </span><span class="koboSpan" id="kobo.1032.2">Such a task is a bit more complicated because you </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.1033.1">need to find a place for adding a new element that will not violate BST rules. </span><span class="koboSpan" id="kobo.1033.2">Let’s take a look at the code of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">Add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1036.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.1037.1">Add</span></strong><span class="koboSpan" id="kobo.1038.1">(T data)
{
    BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.1038.2">parent = GetParentForNewNode(data);
    BinaryTreeNode&lt;T&gt; node = new()
    {
        Data = data,
        Parent = parent
    };
    if (parent == null)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1039.1">Root = node;</span></strong><span class="koboSpan" id="kobo.1040.1">
    }
    else if (data.CompareTo(parent.Data) &lt; 0)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1041.1">parent.Left = node;</span></strong><span class="koboSpan" id="kobo.1042.1">
    }
    else
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1043.1">parent.Right = node;</span></strong><span class="koboSpan" id="kobo.1044.1">
    }
    Count++;
}</span></pre> <p><span class="koboSpan" id="kobo.1045.1">The method takes one parameter, namely a value that should be added to the tree. </span><span class="koboSpan" id="kobo.1045.2">Within the method, you find a parent element (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">GetParentForNewNode</span></strong><span class="koboSpan" id="kobo.1047.1"> auxiliary method, shown a bit later), where </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.1048.1">a new node should be added as a child. </span><span class="koboSpan" id="kobo.1048.2">Then, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">BinaryTreeNode</span></strong><span class="koboSpan" id="kobo.1050.1"> class is created, and the values of its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">Data</span></strong><span class="koboSpan" id="kobo.1052.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">Parent</span></strong><span class="koboSpan" id="kobo.1054.1"> properties </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">are set.</span></span></p>
<p><span class="koboSpan" id="kobo.1056.1">In the following part of the method, you check whether the found parent element is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">null</span></strong><span class="koboSpan" id="kobo.1058.1">. </span><span class="koboSpan" id="kobo.1058.2">It means that there are no nodes in the tree, and a new node should be added as the root, which is well visible in the line, where a reference to the node is assigned to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">Root</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.1061.1">The next comparison checks whether the value for addition is smaller than the value of the parent node. </span><span class="koboSpan" id="kobo.1061.2">In such a case, a new node should be added as the left child of the parent node. </span><span class="koboSpan" id="kobo.1061.3">Otherwise, the new node is placed as the right child of the parent node. </span><span class="koboSpan" id="kobo.1061.4">At the end, the number of elements stored in the tree </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">is incremented.</span></span></p>
<p><span class="koboSpan" id="kobo.1063.1">Let’s take a look at the auxiliary method for finding the parent element for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">new node:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
private BinaryTreeNode&lt;T&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.1066.1">GetParentForNewNode</span></strong><span class="koboSpan" id="kobo.1067.1">(T data)
{
    BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.1067.2">current = Root;
    BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.1067.3">parent = null;
    while (</span><strong class="bold"><span class="koboSpan" id="kobo.1068.1">current != null</span></strong><span class="koboSpan" id="kobo.1069.1">)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1070.1">parent = current;</span></strong><span class="koboSpan" id="kobo.1071.1">
        int result = data.CompareTo(current.Data);
        if (result == 0) { throw new ArgumentException(
            $"The node {data} already exists."); }
        else if (result &lt; 0) { </span><strong class="bold"><span class="koboSpan" id="kobo.1072.1">current = current.Left;</span></strong><span class="koboSpan" id="kobo.1073.1"> }
        else { current = </span><strong class="bold"><span class="koboSpan" id="kobo.1074.1">current.Right;</span></strong><span class="koboSpan" id="kobo.1075.1"> }
    }
    return </span><strong class="bold"><span class="koboSpan" id="kobo.1076.1">parent</span></strong><span class="koboSpan" id="kobo.1077.1">;
}</span></pre> <p><span class="koboSpan" id="kobo.1078.1">This method takes one parameter, namely a value of the new node. </span><span class="koboSpan" id="kobo.1078.2">Within this method, you declare two variables representing the currently analyzed node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">current</span></strong><span class="koboSpan" id="kobo.1080.1">) and the parent node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">parent</span></strong><span class="koboSpan" id="kobo.1082.1">). </span><span class="koboSpan" id="kobo.1082.2">Such values </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.1083.1">are modified in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">while</span></strong><span class="koboSpan" id="kobo.1085.1"> loop until the algorithm finds a proper place for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">new node.</span></span></p>
<p><span class="koboSpan" id="kobo.1087.1">In the loop, you store a reference to the current node as the potential parent node. </span><span class="koboSpan" id="kobo.1087.2">Then, you check whether the value for addition is equal to the value of the current node. </span><span class="koboSpan" id="kobo.1087.3">If so, an exception is thrown because it is not allowed to add more than one element with the same value to the analyzed version of the BST. </span><span class="koboSpan" id="kobo.1087.4">If the value for addition is smaller than the value of the current node, the algorithm continues searching for a place for the new node in the left subtree. </span><span class="koboSpan" id="kobo.1087.5">Otherwise, the right subtree of the current node is used. </span><span class="koboSpan" id="kobo.1087.6">At the end, the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">parent</span></strong><span class="koboSpan" id="kobo.1089.1"> variable is</span><a id="_idTextAnchor277"/> <a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.1090.1">returned to indicate the found location for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">new node.</span></span></p>
<h3><span class="koboSpan" id="kobo.1092.1">Removal</span></h3>
<p><span class="koboSpan" id="kobo.1093.1">You now know how to create a new BST, add some nodes to it, as well as check whether a given value already exists in the tree. </span><span class="koboSpan" id="kobo.1093.2">However, can you also remove an item from a tree? </span><span class="koboSpan" id="kobo.1093.3">Of course! </span><span class="koboSpan" id="kobo.1093.4">The main method</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.1094.1"> regarding the removal of a node from the tree is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">Remove</span></strong><span class="koboSpan" id="kobo.1096.1"> and takes only one parameter, namely the value of the node that should be removed. </span><span class="koboSpan" id="kobo.1096.2">The implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">Remove</span></strong><span class="koboSpan" id="kobo.1098.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1100.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.1101.1">Remove</span></strong><span class="koboSpan" id="kobo.1102.1">(T data) =&gt; Remove(Root, data);</span></pre> <p><span class="koboSpan" id="kobo.1103.1">As you can see, the method just calls another method, also named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">Remove</span></strong><span class="koboSpan" id="kobo.1105.1">. </span><span class="koboSpan" id="kobo.1105.2">The implementation of this private</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.1106.1"> method is more complicated and is </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1108.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.1109.1">Remove</span></strong><span class="koboSpan" id="kobo.1110.1">(BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.1110.2">node, T data)
{
    if (node == null)
    {
        return;
    }
    else if (data.CompareTo(node.Data) &lt; 0)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">Remove(node.Left, data);</span></strong><span class="koboSpan" id="kobo.1112.1">
    }
    else if (data.CompareTo(node.Data) &gt; 0)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1113.1">Remove(node.Right, data);</span></strong><span class="koboSpan" id="kobo.1114.1">
    }
    else
    {
        if (node.Left == null || node.Right == null)
        {
            BinaryTreeNode&lt;T&gt;? </span><span class="koboSpan" id="kobo.1114.2">newNode =
                node.Left == null &amp;&amp; node.Right == null
                    ? </span><span class="koboSpan" id="kobo.1114.3">null
                    : node.Left ?? </span><span class="koboSpan" id="kobo.1114.4">node.Right;
            </span><strong class="bold"><span class="koboSpan" id="kobo.1115.1">ReplaceInParent(node, newNode!);</span></strong><span class="koboSpan" id="kobo.1116.1">
            Count--;
        }
        else
        {
            BinaryTreeNode&lt;T&gt; successor =
                </span><strong class="bold"><span class="koboSpan" id="kobo.1117.1">FindMinimumInSubtree(node.Right);</span></strong><span class="koboSpan" id="kobo.1118.1">
            node.Data = successor.Data;
            </span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">Remove(successor, successor.Data!);</span></strong><span class="koboSpan" id="kobo.1120.1">
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1121.1">At the beginning, the method checks whether the current node (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">node</span></strong><span class="koboSpan" id="kobo.1123.1"> parameter) exists. </span><span class="koboSpan" id="kobo.1123.2">If not, you exit from </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">the</span></span><span class="No-Break"><a id="_idIndexMarker667"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1126.1">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">Remove</span></strong><span class="koboSpan" id="kobo.1128.1"> method tries to find the node to remove. </span><span class="koboSpan" id="kobo.1128.2">That is achieved by comparing the value of the current node with the value for removal and calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">Remove</span></strong><span class="koboSpan" id="kobo.1130.1"> method recursively for either the left or right subtree of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">current node.</span></span></p>
<p><span class="koboSpan" id="kobo.1132.1">The most interesting operations are performed in the following part of the method. </span><span class="koboSpan" id="kobo.1132.2">Here, you need to handle four scenarios of node removal, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1134.1">Removing a </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">leaf node</span></span></li>
<li><span class="koboSpan" id="kobo.1136.1">Removing a node with only a </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">left child</span></span></li>
<li><span class="koboSpan" id="kobo.1138.1">Removing a node with only a </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">right child</span></span></li>
<li><span class="koboSpan" id="kobo.1140.1">Removing a node with both left and </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">right children</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1142.1">In the case of </span><strong class="bold"><span class="koboSpan" id="kobo.1143.1">removing a leaf node</span></strong><span class="koboSpan" id="kobo.1144.1">, you just update a reference to the deleted node in the parent element. </span><span class="koboSpan" id="kobo.1144.2">Therefore, there will be no reference from the parent node to the deleted node, and it cannot be reached while traversing </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">the tree.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1146.1">Removing a node with only a left child</span></strong><span class="koboSpan" id="kobo.1147.1"> is also simple because you only need to replace a reference to the deleted node (in the parent element) with the node that is a left child of the deleted node. </span><span class="koboSpan" id="kobo.1147.2">This scenario is shown in the following diagram, which presents how to remove node </span><strong class="bold"><span class="koboSpan" id="kobo.1148.1">80</span></strong><span class="koboSpan" id="kobo.1149.1"> with only the </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">left child:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.1151.1"><img alt="Figure 7.10 – Removing a node with only a left child from a BST" src="image/B18069_07_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1152.1">Figure 7.10 – Removing a node with only a left child from a BST</span></p>
<p><span class="koboSpan" id="kobo.1153.1">The case of </span><strong class="bold"><span class="koboSpan" id="kobo.1154.1">removing a node with only a right child </span></strong><span class="koboSpan" id="kobo.1155.1">is very similar to the second case. </span><span class="koboSpan" id="kobo.1155.2">Thus, you just replace a reference to the deleted node (in the parent element) with the node that is a right child of the </span><a id="_idIndexMarker668"/><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">deleted node.</span></span></p>
<p><span class="koboSpan" id="kobo.1157.1">All those three cases are handled in the code in a similar way, by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">ReplaceInParent</span></strong><span class="koboSpan" id="kobo.1159.1"> auxiliary method, the code of which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1161.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.1162.1">ReplaceInParent</span></strong><span class="koboSpan" id="kobo.1163.1">(BinaryTreeNode&lt;T&gt; node,
    BinaryTreeNode&lt;T&gt; newNode)
{
    if (node.Parent != null)
    {
        BinaryTreeNode&lt;T&gt; parent =
            (BinaryTreeNode&lt;T&gt;)node.Parent;
        if (parent.Left == node) { </span><strong class="bold"><span class="koboSpan" id="kobo.1164.1">parent.Left = newNode;</span></strong><span class="koboSpan" id="kobo.1165.1"> }
        else { </span><strong class="bold"><span class="koboSpan" id="kobo.1166.1">parent.Right = newNode;</span></strong><span class="koboSpan" id="kobo.1167.1"> }
    }
    else { </span><strong class="bold"><span class="koboSpan" id="kobo.1168.1">Root = newNode;</span></strong><span class="koboSpan" id="kobo.1169.1"> }
    if (newNode != null) { </span><strong class="bold"><span class="koboSpan" id="kobo.1170.1">newNode.Parent = node.Parent;</span></strong><span class="koboSpan" id="kobo.1171.1"> }
}</span></pre> <p><span class="koboSpan" id="kobo.1172.1">The method takes two parameters: the node for removal (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">node</span></strong><span class="koboSpan" id="kobo.1174.1">) and the node that should replace it in the parent </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.1175.1">node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">newNode</span></strong><span class="koboSpan" id="kobo.1177.1">). </span><span class="koboSpan" id="kobo.1177.2">For this reason, if you want to remove a leaf node, you just pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">null</span></strong><span class="koboSpan" id="kobo.1179.1"> as the second parameter because you do not want to replace the removed node with anything else. </span><span class="koboSpan" id="kobo.1179.2">In the case of removing a node with only one child, you pass a reference to the left or </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">right child.</span></span></p>
<p><span class="koboSpan" id="kobo.1181.1">If the node for removal is not the root, you check whether it is the left child of the parent. </span><span class="koboSpan" id="kobo.1181.2">If so, a proper reference is updated. </span><span class="koboSpan" id="kobo.1181.3">It means that the new node is set as the left child of the parent node of the node for removal. </span><span class="koboSpan" id="kobo.1181.4">In a similar way, the method handles the scenario when the node for removal is the right child of the parent. </span><span class="koboSpan" id="kobo.1181.5">If the node for removal is the root, the node for replacing is set as the root. </span><span class="koboSpan" id="kobo.1181.6">At the end, you check whether the new node is not equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">null</span></strong><span class="koboSpan" id="kobo.1183.1">. </span><span class="koboSpan" id="kobo.1183.2">It means that you are not removing a leaf node. </span><span class="koboSpan" id="kobo.1183.3">In such a case, you set a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">Parent</span></strong><span class="koboSpan" id="kobo.1185.1"> property to indicate that the new node should have the same parent as the node </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">for removal.</span></span></p>
<p><span class="koboSpan" id="kobo.1187.1">A bit more complicated scenario is </span><strong class="bold"><span class="koboSpan" id="kobo.1188.1">the removal of a node with both child nodes</span></strong><span class="koboSpan" id="kobo.1189.1">. </span><span class="koboSpan" id="kobo.1189.2">In such a case, you find a node with the minimum value in the right subtree of the node for removal. </span><span class="koboSpan" id="kobo.1189.3">Then, you swap the value of the node for removal with the value of the found node. </span><span class="koboSpan" id="kobo.1189.4">Finally, you just need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">Remove</span></strong><span class="koboSpan" id="kobo.1191.1"> method recursively for the found node. </span><span class="koboSpan" id="kobo.1191.2">The relevant part of the code is shown in the following code snippet, copied here from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">Remove</span></strong><span class="koboSpan" id="kobo.1193.1"> private method for </span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">your convenience:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1195.1">
BinaryTreeNode&lt;T&gt; successor =
    FindMinimumInSubtree(node.Right);
node.Data = successor.Data;
Remove(successor, successor.Data!);</span></pre> <p><span class="koboSpan" id="kobo.1196.1">The last auxiliary method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">FindMinimumInSubtree</span></strong><span class="koboSpan" id="kobo.1198.1"> and is </span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1200.1">
private BinaryTreeNode&lt;T&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1201.1">FindMinimumInSubtree</span></strong><span class="koboSpan" id="kobo.1202.1">(
    BinaryTreeNode&lt;T&gt; node)
{
    while (</span><strong class="bold"><span class="koboSpan" id="kobo.1203.1">node.Left != null</span></strong><span class="koboSpan" id="kobo.1204.1">) { </span><strong class="bold"><span class="koboSpan" id="kobo.1205.1">node = node.Left;</span></strong><span class="koboSpan" id="kobo.1206.1"> }
    return node;
}</span></pre> <p><span class="koboSpan" id="kobo.1207.1">The method takes the root of </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.1208.1">the subtree, where the minimum value should be found, as the parameter. </span><span class="koboSpan" id="kobo.1208.2">Within the method, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">while</span></strong><span class="koboSpan" id="kobo.1210.1"> loop is used to get the leftmost element. </span><span class="koboSpan" id="kobo.1210.2">When there is no left child, the current value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">node</span></strong><span class="koboSpan" id="kobo.1212.1"> variable </span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">is returned.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1214.1">Where you can find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1215.1">There is a lot of information about BSTs in books, research papers, as well as over the internet. </span><span class="koboSpan" id="kobo.1215.2">Howe</span><a href="https://en.wikipedia.org/wiki/Binary_search_tree"><span class="koboSpan" id="kobo.1216.1">ver, the presented implementation of a BST is ba</span></a><span class="koboSpan" id="kobo.1217.1">sed on the code shown at https://en.wikipedia.org/wiki/Binary_search_tree, where you can also find more information about this data structure. </span><span class="koboSpan" id="kobo.1217.2">I strongly </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.1218.1">encourage you to be curious about various data structures and algorithms and to broaden </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">your knowledge.</span></span></p>
<p><span class="koboSpan" id="kobo.1220.1">The preceding code does not look very difficult, does it? </span><span class="koboSpan" id="kobo.1220.2">However, how does it work in practice? </span><span class="koboSpan" id="kobo.1220.3">Let’s take a look at a diagram depicting the removal of a node with </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">two children:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.1222.1"><img alt="Figure 7.11 – Removing a node with two children in a BST" src="image/B18069_07_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1223.1">Figure 7.11 – Removing a node with two children in a BST</span></p>
<p><span class="koboSpan" id="kobo.1224.1">The diagram shows how to remove the node with </span><strong class="bold"><span class="koboSpan" id="kobo.1225.1">40</span></strong><span class="koboSpan" id="kobo.1226.1"> as the value. </span><span class="koboSpan" id="kobo.1226.2">To do so, you need to find the successor. </span><span class="koboSpan" id="kobo.1226.3">It is the node with the minimum value in the right subtree of the node</span><a id="_idTextAnchor279"/> <a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.1227.1">for removal. </span><span class="koboSpan" id="kobo.1227.2">The successor is </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.1228.1">node </span><strong class="bold"><span class="koboSpan" id="kobo.1229.1">42</span></strong><span class="koboSpan" id="kobo.1230.1">, which replaces </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">node </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1232.1">40</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.1234.1">Example – BST visualization</span></h2>
<p><span class="koboSpan" id="kobo.1235.1">While reading the section </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.1236.1">regarding BSTs, you learned a lot about this data structure. </span><span class="koboSpan" id="kobo.1236.2">So, it is high time to create an example program to see this variant of trees in action. </span><span class="koboSpan" id="kobo.1236.3">The application will show you how to create a BST, add some nodes (both manually and using the previously presented method for insertion), remove nodes, traverse the tree, as well as visualize the tree in </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.1238.1">At the beginning, a new tree (with nodes storing integer values) is prepared by creating a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">BinarySearchTree</span></strong><span class="koboSpan" id="kobo.1240.1"> class. </span><span class="koboSpan" id="kobo.1240.2">It is configured manually by adding three nodes, together with indicating proper references for children and parent elements. </span><span class="koboSpan" id="kobo.1240.3">The relevant part of the </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.1241.1">code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1243.1">
BinarySearchTree&lt;int&gt; tree = new();
tree.Root = new BinaryTreeNode&lt;int&gt;() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.1244.1">100</span></strong><span class="koboSpan" id="kobo.1245.1"> };
tree.Root.Left = new() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.1246.1">50</span></strong><span class="koboSpan" id="kobo.1247.1">, Parent = tree.Root };
tree.Root.Right = new() { Data = </span><strong class="bold"><span class="koboSpan" id="kobo.1248.1">150</span></strong><span class="koboSpan" id="kobo.1249.1">, Parent = tree.Root };
tree.Count = 3;
Visualize(tree, "BST with 3 nodes (50, 100, 150):");</span></pre> <p><span class="koboSpan" id="kobo.1250.1">Then, you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">Add</span></strong><span class="koboSpan" id="kobo.1252.1"> method to add some nodes to the tree and visualize the current state of the tree using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">Visualize</span></strong><span class="koboSpan" id="kobo.1254.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1256.1">
tree.Add(</span><strong class="bold"><span class="koboSpan" id="kobo.1257.1">75</span></strong><span class="koboSpan" id="kobo.1258.1">);
tree.Add(</span><strong class="bold"><span class="koboSpan" id="kobo.1259.1">125</span></strong><span class="koboSpan" id="kobo.1260.1">);
Visualize(tree, "BST after adding 2 nodes (75, 125):");</span></pre> <p><span class="koboSpan" id="kobo.1261.1">Let’s add five more nodes with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1263.1">
tree.Add(</span><strong class="bold"><span class="koboSpan" id="kobo.1264.1">25</span></strong><span class="koboSpan" id="kobo.1265.1">);
tree.Add(</span><strong class="bold"><span class="koboSpan" id="kobo.1266.1">175</span></strong><span class="koboSpan" id="kobo.1267.1">);
tree.Add(</span><strong class="bold"><span class="koboSpan" id="kobo.1268.1">90</span></strong><span class="koboSpan" id="kobo.1269.1">);
tree.Add(</span><strong class="bold"><span class="koboSpan" id="kobo.1270.1">110</span></strong><span class="koboSpan" id="kobo.1271.1">);
tree.Add(</span><strong class="bold"><span class="koboSpan" id="kobo.1272.1">135</span></strong><span class="koboSpan" id="kobo.1273.1">);
Visualize(tree, "BST after adding 5 nodes
    (25, 175, 90, 110, 135):");</span></pre> <p><span class="koboSpan" id="kobo.1274.1">The next set of operations is related to the removal of various nodes from the tree, together with visualization of particular changes. </span><span class="koboSpan" id="kobo.1274.2">The part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1276.1">
tree.Remove(</span><strong class="bold"><span class="koboSpan" id="kobo.1277.1">25</span></strong><span class="koboSpan" id="kobo.1278.1">);
Visualize(tree, "BST after removing the node 25:");
tree.Remove(</span><strong class="bold"><span class="koboSpan" id="kobo.1279.1">50</span></strong><span class="koboSpan" id="kobo.1280.1">);
Visualize(tree, "BST after removing the node 50:");
tree.Remove(</span><strong class="bold"><span class="koboSpan" id="kobo.1281.1">100</span></strong><span class="koboSpan" id="kobo.1282.1">);
Visualize(tree, "BST after removing the node 100:");</span></pre> <p><span class="koboSpan" id="kobo.1283.1">At the end, all three traversal</span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.1284.1"> modes are presented. </span><span class="koboSpan" id="kobo.1284.2">The suitable code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1286.1">
foreach (TraversalEnum mode
    in Enum.GetValues&lt;TraversalEnum&gt;())
{
    Console.Write($"\n{mode} traversal:\t");
    Console.Write(string.Join(", ",
        tree.Traverse(mode).Select(n =&gt; n.Data)));
}</span></pre> <p><span class="koboSpan" id="kobo.1287.1">Another interesting task is the development of a tree visualization in the console. </span><span class="koboSpan" id="kobo.1287.2">Such a feature is really useful because it allows a comfortable and fast way of observing the tree without the necessity of debugging the application in the IDE and expanding the following elements in the tooltip with the current values of variables. </span><span class="koboSpan" id="kobo.1287.3">However, presenting a tree in the console is not a trivial task. </span><span class="koboSpan" id="kobo.1287.4">Fortunately, you do not need to worry about it because you will learn how to implement such a feature in </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.1289.1">First, let’s take a look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">Visualize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1292.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1293.1">Visualize</span></strong><span class="koboSpan" id="kobo.1294.1">(BinarySearchTree&lt;int&gt; tree, string caption)
{
    char[,] console = Initialize(tree, out int width);
    VisualizeNode(tree.Root, 0, width / 2,
        console, width);
    Console.WriteLine(caption);
    Draw(console);
}</span></pre> <p><span class="koboSpan" id="kobo.1295.1">The method takes two parameters, namely an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">BinarySearchTree</span></strong><span class="koboSpan" id="kobo.1297.1"> class representing the whole tree, and a caption that should be shown above the visualization. </span><span class="koboSpan" id="kobo.1297.2">Within the method, an</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.1298.1"> array with characters that should be presented in the console is initialized using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">Initialize</span></strong><span class="koboSpan" id="kobo.1300.1"> auxiliary method, shown a bit later. </span><span class="koboSpan" id="kobo.1300.2">Then, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">VisualizeNode</span></strong><span class="koboSpan" id="kobo.1302.1"> recursive method to fill various parts of the array with data regarding particular nodes existing in the tree. </span><span class="koboSpan" id="kobo.1302.2">At the end, the caption and the board (represented by the array) are written in </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.1304.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">Initialize</span></strong><span class="koboSpan" id="kobo.1306.1"> method creates the aforementioned array, as presented in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1307.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1308.1">
const int </span><strong class="bold"><span class="koboSpan" id="kobo.1309.1">ColumnWidth</span></strong><span class="koboSpan" id="kobo.1310.1"> = 5;
char[,] </span><strong class="bold"><span class="koboSpan" id="kobo.1311.1">Initialize</span></strong><span class="koboSpan" id="kobo.1312.1">(BinarySearchTree&lt;int&gt; tree,
    out int width)
{
    int height = tree.GetHeight();
    width = (int)Math.Pow(2, height) - 1;
    char[,] console =
        new char[height * 2, ColumnWidth * width];
    for (int y = 0; y &lt; console.GetLength(0); y++)
    {
        for (int x = 0; x &lt; console.GetLength(1); x++)
        {
            console[y, x] = ' ';
        }
    }
    return console;
}</span></pre> <p><span class="koboSpan" id="kobo.1313.1">The two-dimensional array contains the number of rows equal to the height of the tree multiplied by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">2</span></strong><span class="koboSpan" id="kobo.1315.1"> to have space also for lines connecting nodes with parents. </span><span class="koboSpan" id="kobo.1315.2">The number of columns is calculated according to</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.1316.1"> the formula </span><em class="italic"><span class="koboSpan" id="kobo.1317.1">columnwidth</span></em><span class="koboSpan" id="kobo.1318.1"> * 2</span><span class="superscript"><span class="koboSpan" id="kobo.1319.1">height</span></span><span class="koboSpan" id="kobo.1320.1"> - 1, where </span><em class="italic"><span class="koboSpan" id="kobo.1321.1">columnwidth</span></em><span class="koboSpan" id="kobo.1322.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">ColumnWidth</span></strong><span class="koboSpan" id="kobo.1324.1"> constant value and </span><em class="italic"><span class="koboSpan" id="kobo.1325.1">height</span></em><span class="koboSpan" id="kobo.1326.1"> is the height of </span><span class="No-Break"><span class="koboSpan" id="kobo.1327.1">the tree.</span></span></p>
<p><span class="koboSpan" id="kobo.1328.1">These values can be simpler to understand if you take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">the result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.1330.1"><img alt="Figure 7.12 – ﻿Screenshot of the BST visualization example" src="image/B18069_07_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1331.1">Figure 7.12 – Screenshot of the BST visualization example</span></p>
<p><span class="koboSpan" id="kobo.1332.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">Visualize</span></strong><span class="koboSpan" id="kobo.1334.1"> method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">VisualizeNode</span></strong><span class="koboSpan" id="kobo.1336.1"> is called. </span><span class="koboSpan" id="kobo.1336.2">Are you interested to learn about how it works and how you can present not only the values of nodes but also lines? </span><span class="koboSpan" id="kobo.1336.3">If so, let’s take a look at its code, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1338.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1339.1">VisualizeNode</span></strong><span class="koboSpan" id="kobo.1340.1">(BinaryTreeNode&lt;int&gt;? </span><span class="koboSpan" id="kobo.1340.2">node, int row,
    int column, char[,] console, int width)
{
    if (node == null) { return; }
    char[] chars = node.Data.ToString().ToCharArray();
    int margin = (ColumnWidth - chars.Length) / 2;
    for (int i = 0; i &lt; chars.Length; i++)
    {
        int col = ColumnWidth * column + i + margin;
        console[row, col] = chars[i];
    }
    int columnDelta = (width + 1) /
        (int)Math.Pow(2, node.GetHeight() + 1);
    </span><strong class="bold"><span class="koboSpan" id="kobo.1341.1">VisualizeNode(node.Left, row + 2,</span></strong><span class="koboSpan" id="kobo.1342.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1343.1">column - columnDelta, console, width);</span></strong><span class="koboSpan" id="kobo.1344.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.1345.1">VisualizeNode(node.Right, row + 2,</span></strong><span class="koboSpan" id="kobo.1346.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1347.1">column + columnDelta, console, width);</span></strong><span class="koboSpan" id="kobo.1348.1">
    DrawLineLeft(node, row, column, console, columnDelta);
    DrawLineRight(node, row, column, console, columnDelta);
}</span></pre> <p><span class="koboSpan" id="kobo.1349.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">VisualizeNode</span></strong><span class="koboSpan" id="kobo.1351.1"> method takes five parameters, including the current node for visualization (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">node</span></strong><span class="koboSpan" id="kobo.1353.1">), the index of a row (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">row</span></strong><span class="koboSpan" id="kobo.1355.1">), and the index of a column (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">column</span></strong><span class="koboSpan" id="kobo.1357.1">). </span><span class="koboSpan" id="kobo.1357.2">Within the method, there is a</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.1358.1"> check for whether the current node exists. </span><span class="koboSpan" id="kobo.1358.2">If it does, the value of the node is obtained as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">char</span></strong><span class="koboSpan" id="kobo.1360.1"> array, the margin is calculated, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">char</span></strong><span class="koboSpan" id="kobo.1362.1"> array (with a character-based representation of the value) is written in the buffer (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">console</span></strong><span class="koboSpan" id="kobo.1364.1"> variable) within a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.1367.1">In the following lines of code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">VisualizeNode</span></strong><span class="koboSpan" id="kobo.1369.1"> method is called for the left and right child nodes of the current node. </span><span class="koboSpan" id="kobo.1369.2">Of course, you need to adjust the index of the row (by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">2</span></strong><span class="koboSpan" id="kobo.1371.1">) and the index of the column (by adding or subtracting the </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">calculated value).</span></span></p>
<p><span class="koboSpan" id="kobo.1373.1">At the end, lines are drawn by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">DrawLineLeft</span></strong><span class="koboSpan" id="kobo.1375.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">DrawLineRight</span></strong><span class="koboSpan" id="kobo.1377.1"> methods. </span><span class="koboSpan" id="kobo.1377.2">The first is presented in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1379.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1380.1">DrawLineLeft</span></strong><span class="koboSpan" id="kobo.1381.1">(BinaryTreeNode&lt;int&gt; node, int row,
    int column, char[,] console, int columnDelta)
{
    if (node.Left == null) { return; }
    int sci = ColumnWidth * (column - columnDelta) + 2;
    int eci = ColumnWidth * column + 2;
    for (int x = sci + 1; x &lt; eci; x++)
    {
        console[row + 1, x] = '-';
    }
    console[row + 1, sci] = '+';
    console[row + 1, eci] = '+';
}</span></pre> <p><span class="koboSpan" id="kobo.1382.1">The method also takes </span><span class="No-Break"><span class="koboSpan" id="kobo.1383.1">five parameters:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1384.1">The current node for which the line should be </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">drawn (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">node</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1388.1">The index of a </span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">row (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">row</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1392.1">The index of a </span><span class="No-Break"><span class="koboSpan" id="kobo.1393.1">column (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">column</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1395.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1396.1">An array as a screen </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">buffer (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">console</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1400.1">A delta value calculated in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">VisualizeNode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1"> method</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1403.1">At the beginning, you check whether the current node contains a left child because only then is it necessary to draw the left part of the line. </span><span class="koboSpan" id="kobo.1403.2">If so, you calculate the start (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">sci</span></strong><span class="koboSpan" id="kobo.1405.1">, which stands for </span><em class="italic"><span class="koboSpan" id="kobo.1406.1">start column index</span></em><span class="koboSpan" id="kobo.1407.1">) and end (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">eci</span></strong><span class="koboSpan" id="kobo.1409.1"> as </span><em class="italic"><span class="koboSpan" id="kobo.1410.1">end column index</span></em><span class="koboSpan" id="kobo.1411.1">) indices of columns and fill the proper elements of the array with dashes. </span><span class="koboSpan" id="kobo.1411.2">At the end, a plus sign is added to the array in the place</span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.1412.1"> where the drawn line will be connected with the right line of another element and on the other side of </span><span class="No-Break"><span class="koboSpan" id="kobo.1413.1">the line.</span></span></p>
<p><span class="koboSpan" id="kobo.1414.1">In almost the same way, you draw the right line for the current node. </span><span class="koboSpan" id="kobo.1414.2">Of course, you need to adjust the code regarding calculating column start and end indices. </span><span class="koboSpan" id="kobo.1414.3">The final version of the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">DrawLineRight</span></strong><span class="koboSpan" id="kobo.1416.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1418.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1419.1">DrawLineRight</span></strong><span class="koboSpan" id="kobo.1420.1">(BinaryTreeNode&lt;int&gt; node, int row,
    int column, char[,] console, int columnDelta)
{
    if (node.Right == null) { return; }
    int sci = ColumnWidth * column + 2;
    int eci = ColumnWidth * (column + columnDelta) + 2;
    for (int x = sci + 1; x &lt; eci; x++)
    {
        console[row + 1, x] = '-';
    }
    console[row + 1, sci] = '+';
    console[row + 1, eci] = '+';
}</span></pre> <p><span class="koboSpan" id="kobo.1421.1">At the end, let’s see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">Draw</span></strong><span class="koboSpan" id="kobo.1423.1"> method that shows the board in the console. </span><span class="koboSpan" id="kobo.1423.2">It just iterates through all elements </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.1424.1">of the array and writes them in the console, </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1426.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1427.1">Draw</span></strong><span class="koboSpan" id="kobo.1428.1">(char[,] console)
{
    for (int y = 0; y &lt; console.GetLength(0); y++)
    {
        for (int x = 0; x &lt; console.GetLength(1); x++)
        {
            Console.Write(console[y, x]);
        }
        Console.WriteLine();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1429.1">That’s all! </span><span class="koboSpan" id="kobo.1429.2">You wrote the whole code necessary to build the project, launch the program, and see it in action. </span><span class="koboSpan" id="kobo.1429.3">Just after launching, you will see the first BST, </span><span class="No-Break"><span class="koboSpan" id="kobo.1430.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.1431.1"><img alt="Figure 7.13 – ﻿Screenshot of the ﻿BST visualization example, step 1" src="image/B18069_07_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1432.1">Figure 7.13 – Screenshot of the BST visualization example, step 1</span></p>
<p><span class="koboSpan" id="kobo.1433.1">After adding the next two</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.1434.1"> nodes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">75</span></strong><span class="koboSpan" id="kobo.1436.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">125</span></strong><span class="koboSpan" id="kobo.1438.1">, the BST looks a </span><span class="No-Break"><span class="koboSpan" id="kobo.1439.1">bit different:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.1440.1"><img alt="Figure 7.14 – ﻿Screenshot of the BST visualization example, step 2" src="image/B18069_07_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1441.1">Figure 7.14 – Screenshot of the BST visualization example, step 2</span></p>
<p><span class="koboSpan" id="kobo.1442.1">Then, you perform an insertion operation for the next five elements. </span><span class="koboSpan" id="kobo.1442.2">These operations have a very visible impact on the tree shape, as presented in </span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1">the console:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.1444.1"><img alt="Figure 7.15 – ﻿Screenshot of the BST visualization example, step 3" src="image/B18069_07_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1445.1">Figure 7.15 – Screenshot of the BST visualization example, step 3</span></p>
<p><span class="koboSpan" id="kobo.1446.1">After adding 10 elements, the program shows the impact of removing a particular node on the shape of the tree. </span><span class="koboSpan" id="kobo.1446.2">To start, let’s </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.1447.1">remove the leaf node with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">25</span></strong><span class="koboSpan" id="kobo.1449.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">the value:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.1451.1"><img alt="Figure 7.16 – ﻿Screenshot of the BST visualization example, step 4" src="image/B18069_07_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1452.1">Figure 7.16 – Screenshot of the BST visualization example, step 4</span></p>
<p><span class="koboSpan" id="kobo.1453.1">Then, the program removes a node with only one child node, namely the right one. </span><span class="koboSpan" id="kobo.1453.2">What is interesting is that the right child also has a right child. </span><span class="koboSpan" id="kobo.1453.3">However, the presented algorithm works properly in such conditions, and you receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">following result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.1455.1"><img alt="Figure 7.17 – ﻿Screenshot of the BST visualization example, step 5" src="image/B18069_07_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1456.1">Figure 7.17 – Screenshot of the BST visualization example, step 5</span></p>
<p><span class="koboSpan" id="kobo.1457.1">The last removal operation is the most complicated one because it requires you to remove the node with both children, and it also performs the role of the root. </span><span class="koboSpan" id="kobo.1457.2">In such a case, the leftmost element from the right subtree of the root is found and replaces the node for removal, as shown in the final view of </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">the tree:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.1459.1"><img alt="Figure 7.18 – ﻿Screenshot of the BST visualization example, step 6" src="image/B18069_07_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1460.1">Figure 7.18 – Screenshot of the BST visualization example, step 6</span></p>
<p><span class="koboSpan" id="kobo.1461.1">One more set of operations is left, namely traversal of the tree in pre-order, in-order, and post-order. </span><span class="koboSpan" id="kobo.1461.2">The application</span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.1462.1"> presents the </span><span class="No-Break"><span class="koboSpan" id="kobo.1463.1">following results:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1464.1">
Pre-order traversal:    110, 75, 90, 150, 125, 135, 175
In-order traversal:     75, 90, 110, 125, 135, 150, 175
Post-order traversal:   90, 75, 135, 125, 175, 150, 110</span></pre> <p><span class="koboSpan" id="kobo.1465.1">The created application looks quite impressive, doesn’t it? </span><span class="koboSpan" id="kobo.1465.2">You created not only the implementation of a BST from scratch but also prepared the platform for its visualization in the console. </span><span class="No-Break"><span class="koboSpan" id="kobo.1466.1">Great job!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1467.1">Is it already sorted?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1468.1">Let’s take one more look at the results of the in-order approach. </span><span class="koboSpan" id="kobo.1468.2">As you can see, it gives you the nodes sorted in ascending order in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.1469.1">a BST.</span></span></p>
<p><span class="koboSpan" id="kobo.1470.1">However, can you see a potential problem with the created solution? </span><span class="koboSpan" id="kobo.1470.2">What about a scenario where you remove nodes only from the given area of a tree or when you insert already sorted values? </span><span class="koboSpan" id="kobo.1470.3">It could mean that a fat tree, with a</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.1471.1"> proper </span><strong class="bold"><span class="koboSpan" id="kobo.1472.1">breadth-depth ratio</span></strong><span class="koboSpan" id="kobo.1473.1">, could become a skinny one. </span><span class="koboSpan" id="kobo.1473.2">In the worst case, it could even be depicted as a list, where all nodes have only one child. </span><span class="koboSpan" id="kobo.1473.3">Do you have any idea how to solve the problem of unbalanced trees and keep them balanced all the time? </span><span class="koboSpan" id="kobo.1473.4">If no</span><a id="_idTextAnchor282"/><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.1474.1">t, next, you will find some information on how to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.1475.1">this goal.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.1476.1">Self-balancing trees</span></h1>
<p><span class="koboSpan" id="kobo.1477.1">In this section, you will get to know two variants of a </span><strong class="bold"><span class="koboSpan" id="kobo.1478.1">self-balancing tree</span></strong><span class="koboSpan" id="kobo.1479.1">, which </span><strong class="bold"><span class="koboSpan" id="kobo.1480.1">keeps the tree balanced all the time while adding and removing nodes.</span></strong><span class="koboSpan" id="kobo.1481.1"> However, why is it so important? </span><span class="koboSpan" id="kobo.1481.2">As already</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.1482.1"> mentioned, the lookup performance depends on the shape of the tree. </span><span class="koboSpan" id="kobo.1482.2">In the case of improper organization of nodes, forming a list, the process of searching for a given value can be an </span><em class="italic"><span class="koboSpan" id="kobo.1483.1">O(n)</span></em><span class="koboSpan" id="kobo.1484.1"> operation. </span><span class="koboSpan" id="kobo.1484.2">With a correctly arranged tree, the performance can be significantly improved with </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1485.1">O(log n)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1486.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1487.1">Do you know that a BST can very easily become an </span><strong class="bold"><span class="koboSpan" id="kobo.1488.1">unbalanced tree</span></strong><span class="koboSpan" id="kobo.1489.1">? </span><span class="koboSpan" id="kobo.1489.2">Let’s make a simple test of adding the following nine </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.1490.1">numbers to the tree, from </span><strong class="bold"><span class="koboSpan" id="kobo.1491.1">1</span></strong><span class="koboSpan" id="kobo.1492.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1493.1">9</span></strong><span class="koboSpan" id="kobo.1494.1">. </span><span class="koboSpan" id="kobo.1494.2">Then, you will receive a tree with the shape shown in the following diagram on the left. </span><span class="koboSpan" id="kobo.1494.3">However, the same values can be arranged in another way, as a </span><strong class="bold"><span class="koboSpan" id="kobo.1495.1">balanced tree</span></strong><span class="koboSpan" id="kobo.1496.1">, with a significantly better</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.1497.1"> breadth-depth ratio, which is shown on </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">the right:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.1499.1"><img alt="Figure 7.19 – Difference between an unbalanced and a balanced tree" src="image/B18069_07_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1500.1">Figure 7.19 – Difference between an unbalanced and a balanced tree</span></p>
<p><span class="koboSpan" id="kobo.1501.1">You now know what unbalanced and balanced trees are, as well as what is the aim of self-balancing trees. </span><span class="koboSpan" id="kobo.1501.2">However, what is </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.1502.1">an AVL tree or a red-black tree? </span><span class="koboSpan" id="kobo.1502.2">How do they work? </span><span class="koboSpan" id="kobo.1502.3">What rules should be taken into account while using these data structures? </span><span class="koboSpan" id="kobo.1502.4">You will find answers to these </span><span class="No-Break"><span class="koboSpan" id="kobo.1503.1">questions next.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.1504.1">AVL trees</span></h2>
<p><span class="koboSpan" id="kobo.1505.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.1506.1">AVL tree</span></strong><span class="koboSpan" id="kobo.1507.1"> is named after its inventors, namely Adelson-Velsky and Landis. </span><span class="koboSpan" id="kobo.1507.2">It is </span><strong class="bold"><span class="koboSpan" id="kobo.1508.1">a binary search tree with the additional requirement that, for each node, the height of its left and right subtrees cannot differ by more than one</span></strong><span class="koboSpan" id="kobo.1509.1">. </span><span class="koboSpan" id="kobo.1509.2">Of course, that rule must be maintained after adding and removing nodes </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.1510.1">from a tree. </span><span class="koboSpan" id="kobo.1510.2">The important role is</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.1511.1"> performed by </span><strong class="bold"><span class="koboSpan" id="kobo.1512.1">rotations</span></strong><span class="koboSpan" id="kobo.1513.1">, used to fix incorrect arrangements </span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1">of nodes.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1515.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1516.1">While talking about AVL trees, it is crucial to indicate the performance of this data structure. </span><span class="koboSpan" id="kobo.1516.2">In this case, both average and worst-case scenarios of insertion, removal, and lookup are </span><em class="italic"><span class="koboSpan" id="kobo.1517.1">O(log n)</span></em><span class="koboSpan" id="kobo.1518.1">, so there is significant improvement in the worst-case scenarios in comparison with </span><span class="No-Break"><span class="koboSpan" id="kobo.1519.1">a BST.</span></span></p>
<p><span class="koboSpan" id="kobo.1520.1">The implementation of AVL trees, including various rotations necessary to keep the balanced state of a tree, is not trivial and will require quite a long explanation. </span><span class="koboSpan" id="kobo.1520.2">Due to the limited number of pages in the book, its implementation is not presented here. </span><span class="koboSpan" id="kobo.1520.3">Fortunately, you can use one of the available NuGet packages that support such t</span><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.1521.1">ree-based data structures to benefit from AVL trees in </span><span class="No-Break"><span class="koboSpan" id="kobo.1522.1">your applications.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.1523.1">Red-black trees</span></h2>
<p><span class="koboSpan" id="kobo.1524.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.1525.1">red-black tree</span></strong><span class="koboSpan" id="kobo.1526.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1527.1">RBT</span></strong><span class="koboSpan" id="kobo.1528.1">) is the next variant of self-balancing </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.1529.1">binary search trees. </span><span class="koboSpan" id="kobo.1529.2">As a variant of BSTs, this data structure requires that standard BST rules are maintained. </span><span class="koboSpan" id="kobo.1529.3">Moreover, the following rules must be</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.1530.1"> taken </span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1">into account:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1532.1">Each node must be colored either red or black</span></strong><span class="koboSpan" id="kobo.1533.1">. </span><span class="koboSpan" id="kobo.1533.2">Thus, you need to add additional data for a node that stores </span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1">a color.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1535.1">All nodes with values cannot be leaf nodes</span></strong><span class="koboSpan" id="kobo.1536.1">. </span><span class="koboSpan" id="kobo.1536.2">For this reason, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">NIL</span></strong><span class="koboSpan" id="kobo.1538.1"> pseudo-nodes should be used as leaves in the tree, while all other nodes are internal ones. </span><span class="koboSpan" id="kobo.1538.2">Moreover, all </span><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">NIL</span></strong><span class="koboSpan" id="kobo.1540.1"> pseudo-nodes must </span><span class="No-Break"><span class="koboSpan" id="kobo.1541.1">be black.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1542.1">If a node is red, both its children must </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1543.1">be black</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1544.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1545.1">For any node, </span><strong class="bold"><span class="koboSpan" id="kobo.1546.1">the number of black nodes on the route to a descendant leaf </span></strong><span class="koboSpan" id="kobo.1547.1">(that is, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1548.1">NIL</span></strong><span class="koboSpan" id="kobo.1549.1"> pseudo-node) </span><strong class="bold"><span class="koboSpan" id="kobo.1550.1">must be </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1551.1">the same</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1552.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1553.1">A proper RBT is presented in the</span><a id="_idIndexMarker693"/> <span class="No-Break"><span class="koboSpan" id="kobo.1554.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.1555.1"><img alt="Figure 7.20 – ﻿Illustration of a red-black tree" src="image/B18069_07_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1556.1">Figure 7.20 – Illustration of a red-black tree</span></p>
<p><span class="koboSpan" id="kobo.1557.1">The tree consists of nine nodes, each colored red or black. </span><span class="koboSpan" id="kobo.1557.2">It is worth mentioning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">NIL</span></strong><span class="koboSpan" id="kobo.1559.1"> pseudo-nodes, which are added as leaf nodes. </span><span class="koboSpan" id="kobo.1559.2">If you again take a look at the set of rules listed previously, you can confirm that all such rules are maintained in </span><span class="No-Break"><span class="koboSpan" id="kobo.1560.1">this case.</span></span></p>
<p><span class="koboSpan" id="kobo.1561.1">Similarly to AVL trees, RBTs also must maintain rules after adding or removing a node. </span><span class="koboSpan" id="kobo.1561.2">In this case, the process of restoring the RBT properties is even more complicated because it involves both </span><strong class="bold"><span class="koboSpan" id="kobo.1562.1">recoloring</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1563.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1564.1">rotations</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1565.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1566.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1567.1">While talking about this variant of self-balancing BSTs, it is also worth noting the performance. </span><span class="koboSpan" id="kobo.1567.2">In both average and worst-case scenarios, insertion, removal, and lookup are </span><em class="italic"><span class="koboSpan" id="kobo.1568.1">O(log n)</span></em><span class="koboSpan" id="kobo.1569.1"> operations, so they are the same as in the case of AVL trees and much better in worst-case scenarios in comparison </span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">with BSTs.</span></span></p>
<p><span class="koboSpan" id="kobo.1571.1">Fortunately, you do not need to know and understand the internal details, which are quite complex, to benefit from this data structure and apply it to your projects. </span><span class="koboSpan" id="kobo.1571.2">As already mentioned in the case of AVL trees, you can also use one of the available NuGet packages </span><span class="No-Break"><span class="koboSpan" id="kobo.1572.1">for RBTs.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1573.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1574.1">The topic of trees is much broader than shown in this chapter. </span><span class="koboSpan" id="kobo.1574.2">For this reason, if you are interested in such a subject, I strongly encourage you to search for more information on your own. </span><span class="koboSpan" id="kobo.1574.3">You can also find some content on </span><em class="italic"><span class="koboSpan" id="kobo.1575.1">Wikipedia</span></em><span class="koboSpan" id="kobo.1576.1">, such as at </span><a href="https://en.wikipedia.org/wiki/Binary_tree"><span class="koboSpan" id="kobo.1577.1">https://en.wikipedia.org/wiki/Binary_tree</span></a><span class="koboSpan" id="kobo.1578.1"> and </span><a href="https://en.wikipedia.org/wiki/Binary_search_tree"><span class="koboSpan" id="kobo.1579.1">https://en.wikipedia.org/wiki/Binary_search_tree</span></a><span class="koboSpan" id="kobo.1580.1">. </span><span class="koboSpan" id="kobo.1580.2">Self-balancing trees are covered at </span><a href="https://en.wikipedia.org/wiki/AVL_tree"><span class="koboSpan" id="kobo.1581.1">https://en.wikipedia.org/wiki/AVL_tree</span></a><span class="koboSpan" id="kobo.1582.1"> and </span><a href="https://en.wikipedia.org/wiki/Red-black_tree"><span class="koboSpan" id="kobo.1583.1">https://en.wikipedia.org/wiki/Red-black_tree</span></a><span class="koboSpan" id="kobo.1584.1">. </span><span class="koboSpan" id="kobo.1584.2">The topic of tries and binary heaps (mentioned later in this chapter) is presented as well at </span><a href="https://en.wikipedia.org/wiki/Trie"><span class="koboSpan" id="kobo.1585.1">https://en.wikipedia.org/wiki/Trie</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.1586.1">and </span></span><a href="https://en.wikipedia.org/wiki/Binary_heap"><span class="No-Break"><span class="koboSpan" id="kobo.1587.1">https://en.wikipedia.org/wiki/Binary_heap</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1588.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1589.1">You already learned some </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.1590.1">basic information about self-balancing trees, namely AVL trees and RBTs. </span><span class="koboSpan" id="kobo.1590.2">So, let’s take a look at another tree-based structure, namely a trie, which is a great solution for </span><span class="No-Break"><span class="koboSpan" id="kobo.1591.1">string-related operations.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.1592.1">Tries</span></h1>
<p><span class="koboSpan" id="kobo.1593.1">A tree is a powerful data structure that is used in various scenarios. </span><span class="koboSpan" id="kobo.1593.2">One of them is related to processing strings, such as for </span><strong class="bold"><span class="koboSpan" id="kobo.1594.1">autocomplete </span></strong><span class="koboSpan" id="kobo.1595.1">and</span><strong class="bold"><span class="koboSpan" id="kobo.1596.1"> spellchecker</span></strong><span class="koboSpan" id="kobo.1597.1"> features that you certainly know from many systems. </span><span class="koboSpan" id="kobo.1597.2">If you want to implement it in your application, you can benefit from another </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.1598.1">tree-based data structure, namely a </span><strong class="bold"><span class="koboSpan" id="kobo.1599.1">trie</span></strong><span class="koboSpan" id="kobo.1600.1">. </span><span class="koboSpan" id="kobo.1600.2">It is used to store strings and to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.1601.1">prefix-based searching.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1602.1">A trie is a tree with one root node, where each node represents a string and each edge indicates a character. </span><span class="koboSpan" id="kobo.1602.2">A trie node contains references to the next nodes as an array with 26 elements, representing 26 chars from the alphabet (from </span></strong><strong class="p-bold-italics"><span class="koboSpan" id="kobo.1603.1">a</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1604.1"> to </span></strong><strong class="p-bold-italics"><span class="koboSpan" id="kobo.1605.1">z</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1606.1">). </span><span class="koboSpan" id="kobo.1606.2">When you go from the root to each node, you receive a string, which is either a saved word or </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1607.1">its substring</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1608.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1609.1">Why exactly 26 elements?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1610.1">Here, we use 26 elements representing 26 chars because it is the exact number of basic characters between </span><strong class="source-inline"><span class="koboSpan" id="kobo.1611.1">a</span></strong><span class="koboSpan" id="kobo.1612.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1613.1">z</span></strong><span class="koboSpan" id="kobo.1614.1"> in the alphabet, without any special characters existing in various languages. </span><span class="koboSpan" id="kobo.1614.2">Of course, in your implementation, you can expand this set with other characters, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1615.1">ą</span></strong><span class="koboSpan" id="kobo.1616.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">ę</span></strong><span class="koboSpan" id="kobo.1618.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">ś</span></strong><span class="koboSpan" id="kobo.1620.1"> from Polish, as well as with even digits or some special characters, such as a dash. </span><span class="koboSpan" id="kobo.1620.2">Choosing a proper set of characters depends on the scenario in which this data structure will </span><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">be used.</span></span></p>
<p><span class="koboSpan" id="kobo.1622.1">Does it sound</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.1623.1"> complicated? </span><span class="koboSpan" id="kobo.1623.2">It could, so let’s take a look at the following diagram, which should remove </span><span class="No-Break"><span class="koboSpan" id="kobo.1624.1">any doubts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.1625.1"><img alt="Figure 7.21 – ﻿Illustration of a trie" src="image/B18069_07_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1626.1">Figure 7.21 – Illustration of a trie</span></p>
<p><span class="koboSpan" id="kobo.1627.1">The diagram depicts a trie that stores the following words: </span><strong class="bold"><span class="koboSpan" id="kobo.1628.1">ai</span></strong><span class="koboSpan" id="kobo.1629.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1630.1">aid</span></strong><span class="koboSpan" id="kobo.1631.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1632.1">aim</span></strong><span class="koboSpan" id="kobo.1633.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1634.1">air</span></strong><span class="koboSpan" id="kobo.1635.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1636.1">airplane</span></strong><span class="koboSpan" id="kobo.1637.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1638.1">airport</span></strong><span class="koboSpan" id="kobo.1639.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1640.1">algorithm</span></strong><span class="koboSpan" id="kobo.1641.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1642.1">all</span></strong><span class="koboSpan" id="kobo.1643.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1644.1">allergy</span></strong><span class="koboSpan" id="kobo.1645.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1646.1">allow</span></strong><span class="koboSpan" id="kobo.1647.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1648.1">allowance</span></strong><span class="koboSpan" id="kobo.1649.1">. </span><span class="koboSpan" id="kobo.1649.2">As you can see, there is a root node (marked with </span><strong class="bold"><span class="koboSpan" id="kobo.1650.1">-</span></strong><span class="koboSpan" id="kobo.1651.1">) that contains only one child, namely for the </span><strong class="bold"><span class="koboSpan" id="kobo.1652.1">a</span></strong><span class="koboSpan" id="kobo.1653.1"> substring. </span><span class="koboSpan" id="kobo.1653.2">This node contains two child nodes, regarding the </span><strong class="bold"><span class="koboSpan" id="kobo.1654.1">ai</span></strong><span class="koboSpan" id="kobo.1655.1"> word and the </span><strong class="bold"><span class="koboSpan" id="kobo.1656.1">al</span></strong><span class="koboSpan" id="kobo.1657.1"> substring. </span><span class="koboSpan" id="kobo.1657.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.1658.1">ai</span></strong><span class="koboSpan" id="kobo.1659.1"> node has three children, namely representing </span><strong class="bold"><span class="koboSpan" id="kobo.1660.1">aid</span></strong><span class="koboSpan" id="kobo.1661.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1662.1">aim</span></strong><span class="koboSpan" id="kobo.1663.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.1664.1">air</span></strong><span class="koboSpan" id="kobo.1665.1"> words. </span><span class="koboSpan" id="kobo.1665.2">In a similar way, you can analyze the whole trie. </span><span class="koboSpan" id="kobo.1665.3">Please keep in mind that words are marked with bolder lines while substrings are</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.1666.1"> shown with </span><span class="No-Break"><span class="koboSpan" id="kobo.1667.1">lighter ones.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1668.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1669.1">The searching and insertion in the case of a trie are </span><em class="italic"><span class="koboSpan" id="kobo.1670.1">O(n)</span></em><span class="koboSpan" id="kobo.1671.1"> operations, where </span><em class="italic"><span class="koboSpan" id="kobo.1672.1">n</span></em><span class="koboSpan" id="kobo.1673.1"> indicates a word length. </span><span class="koboSpan" id="kobo.1673.2">So, a trie is an efficient data structure for </span><span class="No-Break"><span class="koboSpan" id="kobo.1674.1">string-based operations.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.1675.1">Implementation</span></h2>
<p><span class="koboSpan" id="kobo.1676.1">After this short introduction, let’s</span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.1677.1"> move to something more exciting – </span><span class="No-Break"><span class="koboSpan" id="kobo.1678.1">coding!</span></span></p>
<h3><span class="koboSpan" id="kobo.1679.1">Node</span></h3>
<p><span class="koboSpan" id="kobo.1680.1">Please take a look at the</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.1681.1"> following implementation of a class representing </span><span class="No-Break"><span class="koboSpan" id="kobo.1682.1">a node:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1683.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.1684.1">TrieNode</span></strong><span class="koboSpan" id="kobo.1685.1">
{
    public TrieNode[] </span><strong class="bold"><span class="koboSpan" id="kobo.1686.1">Children</span></strong><span class="koboSpan" id="kobo.1687.1"> { get; set; }
        = new TrieNode[26];
    public bool </span><strong class="bold"><span class="koboSpan" id="kobo.1688.1">IsWord</span></strong><span class="koboSpan" id="kobo.1689.1"> { get; set; } = false;
}</span></pre> <p><span class="koboSpan" id="kobo.1690.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">TrieNode</span></strong><span class="koboSpan" id="kobo.1692.1"> class contains two properties. </span><span class="koboSpan" id="kobo.1692.2">The first is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1693.1">Children</span></strong><span class="koboSpan" id="kobo.1694.1"> and is an array with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1695.1">26</span></strong><span class="koboSpan" id="kobo.1696.1"> elements. </span><span class="koboSpan" id="kobo.1696.2">Each of them represents a particular letter from an alphabet, starting from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1697.1">a</span></strong><span class="koboSpan" id="kobo.1698.1"> (index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1699.1">0</span></strong><span class="koboSpan" id="kobo.1700.1">) and ending with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1701.1">z</span></strong><span class="koboSpan" id="kobo.1702.1"> (index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1703.1">25</span></strong><span class="koboSpan" id="kobo.1704.1">). </span><span class="koboSpan" id="kobo.1704.2">If there is another word with the same prefix, a reference to the next node is located in a suitable element of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1705.1">Children</span></strong><span class="koboSpan" id="kobo.1706.1"> array. </span><span class="koboSpan" id="kobo.1706.2">The second property is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1707.1">IsWord</span></strong><span class="koboSpan" id="kobo.1708.1"> and indicates whether the current node is the last char from a word. </span><span class="koboSpan" id="kobo.1708.2">It means that you can get this word by moving from the root </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.1709.1">element to </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">this node.</span></span></p>
<h3><span class="koboSpan" id="kobo.1711.1">Trie</span></h3>
<p><span class="koboSpan" id="kobo.1712.1">The next part of the code shows the implementation of a class representing </span><span class="No-Break"><span class="koboSpan" id="kobo.1713.1">a trie:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1714.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.1715.1">Trie</span></strong><span class="koboSpan" id="kobo.1716.1">
{
    private readonly TrieNode </span><strong class="bold"><span class="koboSpan" id="kobo.1717.1">_root</span></strong><span class="koboSpan" id="kobo.1718.1"> = new();
}</span></pre> <p><span class="koboSpan" id="kobo.1719.1">Here, there is a private </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.1720.1">field representing the root element. </span><span class="koboSpan" id="kobo.1720.2">Of course, you need to add some methods to make it operational. </span><span class="koboSpan" id="kobo.1720.3">First, let’s implement a method that checks whether a given word exists in the trie. </span><span class="koboSpan" id="kobo.1720.4">Its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1721.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1722.1">
public bool </span><strong class="bold"><span class="koboSpan" id="kobo.1723.1">DoesExist</span></strong><span class="koboSpan" id="kobo.1724.1">(string word)
{
    TrieNode current = _root;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1725.1">foreach (char c in word)</span></strong><span class="koboSpan" id="kobo.1726.1">
    {
        TrieNode child = </span><strong class="bold"><span class="koboSpan" id="kobo.1727.1">current.Children[c - 'a'];</span></strong><span class="koboSpan" id="kobo.1728.1">
        if (child == null) { return false; }
        current = child;
    }
    return </span><strong class="bold"><span class="koboSpan" id="kobo.1729.1">current.IsWord</span></strong><span class="koboSpan" id="kobo.1730.1">;
}</span></pre> <p><span class="koboSpan" id="kobo.1731.1">At the beginning, you save a reference to the root element as the current node. </span><span class="koboSpan" id="kobo.1731.2">Then, you iterate through the following characters that form the word. </span><span class="koboSpan" id="kobo.1731.3">For each character (represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1732.1">c</span></strong><span class="koboSpan" id="kobo.1733.1"> variable), you get a proper node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">child</span></strong><span class="koboSpan" id="kobo.1735.1">). </span><span class="koboSpan" id="kobo.1735.2">If it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1736.1">null</span></strong><span class="koboSpan" id="kobo.1737.1">, it means that the word does not exist in the trie. </span><span class="koboSpan" id="kobo.1737.2">Otherwise, you save the child element as the current one. </span><span class="koboSpan" id="kobo.1737.3">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1738.1">foreach</span></strong><span class="koboSpan" id="kobo.1739.1"> loop ends, the current node represents a node of the last character, so you just need to return the value of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1740.1">IsWord</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1741.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.1742.1">The next method allows you to insert a word into a trie, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1743.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1744.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.1745.1">Insert</span></strong><span class="koboSpan" id="kobo.1746.1">(string word)
{
    TrieNode current = _root;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1747.1">foreach (char c in word)</span></strong><span class="koboSpan" id="kobo.1748.1">
    {
        int i = c - 'a';
        </span><strong class="bold"><span class="koboSpan" id="kobo.1749.1">current.Children[i] = current.Children[i] ?? </span><span class="koboSpan" id="kobo.1749.2">new();</span></strong><span class="koboSpan" id="kobo.1750.1">
        current = current.Children[i];
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.1751.1">current.IsWord = true;</span></strong><span class="koboSpan" id="kobo.1752.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1753.1">The preceding code is a</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.1754.1"> bit similar to that already described. </span><span class="koboSpan" id="kobo.1754.2">However, there is one important difference in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1755.1">foreach</span></strong><span class="koboSpan" id="kobo.1756.1"> loop. </span><span class="koboSpan" id="kobo.1756.2">Here, you create a new child node if it does not exist for any of the chars forming the word. </span><span class="koboSpan" id="kobo.1756.3">At the end, you indicate that the node represents the word by setting the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1757.1">IsWord</span></strong><span class="koboSpan" id="kobo.1758.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.1759.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1760.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1761.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1762.1">As already mentioned, a trie is a data structure that allows you to perform </span><strong class="bold"><span class="koboSpan" id="kobo.1763.1">prefix-based searching</span></strong><span class="koboSpan" id="kobo.1764.1"> in an</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.1765.1"> efficient way. </span><span class="koboSpan" id="kobo.1765.2">So, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1766.1">implement it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1767.1">
public List&lt;string&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1768.1">SearchByPrefix</span></strong><span class="koboSpan" id="kobo.1769.1">(string prefix)
{
    TrieNode current = _root;
    foreach (char c in prefix)
    {
        TrieNode child = current.Children[c - 'a'];
        if (child == null) { return []; }
        current = child;
    }
    List&lt;string&gt; results = [];
    </span><strong class="bold"><span class="koboSpan" id="kobo.1770.1">GetAllWithPrefix(current, prefix, results);</span></strong><span class="koboSpan" id="kobo.1771.1">
    return results;
}</span></pre> <p><span class="koboSpan" id="kobo.1772.1">The method takes one parameter, namely the prefix of the searched words. </span><span class="koboSpan" id="kobo.1772.2">At the beginning, you iterate through all </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.1773.1">characters of the prefix to get a reference to the last character forming the prefix. </span><span class="koboSpan" id="kobo.1773.2">If a child node is not found at any phase, you return an empty list, which means that there are </span><span class="No-Break"><span class="koboSpan" id="kobo.1774.1">no results.</span></span></p>
<p><span class="koboSpan" id="kobo.1775.1">Otherwise, you create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1776.1">List&lt;string&gt;</span></strong><span class="koboSpan" id="kobo.1777.1"> instance to store the result, and then you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1778.1">GetAllWithPrefix</span></strong><span class="koboSpan" id="kobo.1779.1"> method, the code of which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1780.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1781.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.1782.1">GetAllWithPrefix</span></strong><span class="koboSpan" id="kobo.1783.1">(TrieNode node,
    string prefix, List&lt;string&gt; results)
{
    if (node == null) { return; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.1784.1">if (node.IsWord) { results.Add(prefix); }</span></strong><span class="koboSpan" id="kobo.1785.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.1786.1">for (char c = 'a'; c &lt;= 'z'; c++)</span></strong><span class="koboSpan" id="kobo.1787.1">
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1788.1">GetAllWithPrefix(node.Children[c - 'a'],</span></strong><span class="koboSpan" id="kobo.1789.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.1790.1">prefix + c, results);</span></strong><span class="koboSpan" id="kobo.1791.1">
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1792.1">You check whether the current node is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1793.1">null</span></strong><span class="koboSpan" id="kobo.1794.1">. </span><span class="koboSpan" id="kobo.1794.2">If so, you return from the method. </span><span class="koboSpan" id="kobo.1794.3">Otherwise, you verify whether the current node forms a word. </span><span class="koboSpan" id="kobo.1794.4">If so, you add it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1795.1">results</span></strong><span class="koboSpan" id="kobo.1796.1">. </span><span class="koboSpan" id="kobo.1796.2">Next, you iterate through all alphabet characters, namely from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1797.1">a</span></strong><span class="koboSpan" id="kobo.1798.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1799.1">z</span></strong><span class="koboSpan" id="kobo.1800.1">, and call the same method recursively to find the next words and add them to the list </span><span class="No-Break"><span class="koboSpan" id="kobo.1801.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1802.1">results</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1803.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1804.1">As you can see, the basic</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.1805.1"> implementation of a trie is not a complicated task and can be done with clear and short code. </span><span class="koboSpan" id="kobo.1805.2">However, how can you test a trie in action? </span><span class="No-Break"><span class="koboSpan" id="kobo.1806.1">Let’s see:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1807.1">Trie trie = new();</span></strong><span class="koboSpan" id="kobo.1808.1">
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1809.1">Insert</span></strong><span class="koboSpan" id="kobo.1810.1">("algorithm");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1811.1">Insert</span></strong><span class="koboSpan" id="kobo.1812.1">("aid");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1813.1">Insert</span></strong><span class="koboSpan" id="kobo.1814.1">("aim");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1815.1">Insert</span></strong><span class="koboSpan" id="kobo.1816.1">("air");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1817.1">Insert</span></strong><span class="koboSpan" id="kobo.1818.1">("ai");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1819.1">Insert</span></strong><span class="koboSpan" id="kobo.1820.1">("airport");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1821.1">Insert</span></strong><span class="koboSpan" id="kobo.1822.1">("airplane");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1823.1">Insert</span></strong><span class="koboSpan" id="kobo.1824.1">("allergy");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1825.1">Insert</span></strong><span class="koboSpan" id="kobo.1826.1">("allowance");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1827.1">Insert</span></strong><span class="koboSpan" id="kobo.1828.1">("all");
trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1829.1">Insert</span></strong><span class="koboSpan" id="kobo.1830.1">("allow");
bool isAir = trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1831.1">DoesExist</span></strong><span class="koboSpan" id="kobo.1832.1">("air");
List&lt;string&gt; words = trie.</span><strong class="bold"><span class="koboSpan" id="kobo.1833.1">SearchByPrefix</span></strong><span class="koboSpan" id="kobo.1834.1">("ai");
foreach (string word in words)
{
    Console.WriteLine(word);
}</span></pre> <p><span class="koboSpan" id="kobo.1835.1">The preceding code forms a trie, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1836.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1837.1">.21</span></em><span class="koboSpan" id="kobo.1838.1">, with 11 words starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1839.1">a</span></strong><span class="koboSpan" id="kobo.1840.1">, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1841.1">algorithm</span></strong><span class="koboSpan" id="kobo.1842.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1843.1">allow</span></strong><span class="koboSpan" id="kobo.1844.1">. </span><span class="koboSpan" id="kobo.1844.2">You add such words with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1845.1">Insert</span></strong><span class="koboSpan" id="kobo.1846.1"> method. </span><span class="koboSpan" id="kobo.1846.2">Then, you check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1847.1">air</span></strong><span class="koboSpan" id="kobo.1848.1"> word exists with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1849.1">DoesExist</span></strong><span class="koboSpan" id="kobo.1850.1"> method. </span><span class="koboSpan" id="kobo.1850.2">Next, you get all words that start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1851.1">ai</span></strong><span class="koboSpan" id="kobo.1852.1"> prefix and write them in </span><span class="No-Break"><span class="koboSpan" id="kobo.1853.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1854.1">
ai
aid
aim
air
airplane
airport</span></pre> <p><span class="koboSpan" id="kobo.1855.1">At the end of the section regarding tries, let’s talk about the space complexity of this data structure. </span><span class="koboSpan" id="kobo.1855.2">As you can see, you need to store 26 references to child nodes for each trie node, and there can be </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.1856.1">a lot of situations where only one or two references are set. </span><span class="koboSpan" id="kobo.1856.2">For instance, you can take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1857.1">algorithm</span></strong><span class="koboSpan" id="kobo.1858.1"> word, where a lot of space is wasted. </span><span class="koboSpan" id="kobo.1858.2">It would be much better to optimize it in some way to make the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.1859.1">tree smaller.</span></span></p>
<p><span class="koboSpan" id="kobo.1860.1">Fortunately, it is possible to use another </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.1861.1">data structure that is named a </span><strong class="bold"><span class="koboSpan" id="kobo.1862.1">radix tree</span></strong><span class="koboSpan" id="kobo.1863.1"> or a </span><strong class="bold"><span class="koboSpan" id="kobo.1864.1">compressed trie</span></strong><span class="koboSpan" id="kobo.1865.1">, which</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.1866.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.1867.1">a space-optimized version of a trie</span></strong><span class="koboSpan" id="kobo.1868.1">. </span><span class="koboSpan" id="kobo.1868.2">The difference is quite simple: namely, </span><strong class="bold"><span class="koboSpan" id="kobo.1869.1">you merge with the parent each node that is the only child of this parent</span></strong><span class="koboSpan" id="kobo.1870.1">. </span><span class="koboSpan" id="kobo.1870.2">Of course, </span><strong class="bold"><span class="koboSpan" id="kobo.1871.1">edges can represent a substring</span></strong><span class="koboSpan" id="kobo.1872.1"> in such </span><span class="No-Break"><span class="koboSpan" id="kobo.1873.1">a case.</span></span></p>
<p><span class="koboSpan" id="kobo.1874.1">If you want to see what a radix tree looks like for the same input data as in the diagram of a trie, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1875.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.1876.1"><img alt="Figure 7.22 – ﻿Illustration of a radix tree" src="image/B18069_07_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1877.1">Figure 7.22 – Illustration of a radix tree</span></p>
<p><span class="koboSpan" id="kobo.1878.1">Looks much simpler, doesn’t it? </span><span class="koboSpan" id="kobo.1878.2">For example, let’s analyze the path from the root node to </span><strong class="bold"><span class="koboSpan" id="kobo.1879.1">algorithm</span></strong><span class="koboSpan" id="kobo.1880.1">. </span><span class="koboSpan" id="kobo.1880.2">Here, you use </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.1881.1">only three edges, namely </span><strong class="bold"><span class="koboSpan" id="kobo.1882.1">a</span></strong><span class="koboSpan" id="kobo.1883.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1884.1">l</span></strong><span class="koboSpan" id="kobo.1885.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1886.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1887.1">gorithm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1888.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1889.1">Try to implement it on your own</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1890.1">Based on the preceding diagram and the implementation of a trie, I encourage you to try to implement a radix tree on your own. </span><span class="koboSpan" id="kobo.1890.2">You should also prepare a method for searching a word in such a data structure. </span><span class="No-Break"><span class="koboSpan" id="kobo.1891.1">Good luck!</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.1892.1">Example – autocomplete</span></h2>
<p><span class="koboSpan" id="kobo.1893.1">As an example of a trie application, you will create an </span><strong class="bold"><span class="koboSpan" id="kobo.1894.1">autocomplete</span></strong><span class="koboSpan" id="kobo.1895.1"> feature that suggests names of countries based on the prefix entered by a user. </span><span class="koboSpan" id="kobo.1895.2">To do so, you first need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1896.1">Countries.txt</span></strong><span class="koboSpan" id="kobo.1897.1"> file with</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.1898.1"> names of countries, as well as add it to the project as content that will be automatically copied to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1899.1">output directory.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1900.1">How to add a file to the project?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1901.1">You should right-click on the project node in the </span><strong class="bold"><span class="koboSpan" id="kobo.1902.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.1903.1"> window and choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1904.1">Add</span></strong><span class="koboSpan" id="kobo.1905.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.1906.1">New Item</span></strong><span class="koboSpan" id="kobo.1907.1"> option. </span><span class="koboSpan" id="kobo.1907.2">Then, type the name of the file, followed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1908.1">.txt</span></strong><span class="koboSpan" id="kobo.1909.1"> extension. </span><span class="koboSpan" id="kobo.1909.2">After confirmation, the file is created. </span><span class="koboSpan" id="kobo.1909.3">If you want to mark this file as a content file and automatically copy it to the output directory, you should click on the file and change two properties in the </span><strong class="bold"><span class="koboSpan" id="kobo.1910.1">Properties</span></strong><span class="koboSpan" id="kobo.1911.1"> window. </span><span class="koboSpan" id="kobo.1911.2">First, change </span><strong class="bold"><span class="koboSpan" id="kobo.1912.1">Build Action</span></strong><span class="koboSpan" id="kobo.1913.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1914.1">Content</span></strong><span class="koboSpan" id="kobo.1915.1">. </span><span class="koboSpan" id="kobo.1915.2">Then, set </span><strong class="bold"><span class="koboSpan" id="kobo.1916.1">Copy to Output Directory</span></strong><span class="koboSpan" id="kobo.1917.1"> to </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1918.1">Copy always</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1919.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1920.1">A part of the file with </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.1921.1">country names is </span><span class="No-Break"><span class="koboSpan" id="kobo.1922.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1923.1">
Afghanistan
Albania
Algeria (...)
Pakistan
Palau
Panama
Papua New Guinea
Paraguay
Peru
Philippines
Poland
Portugal (...)
Zambia
Zimbabwe</span></pre> <p><span class="koboSpan" id="kobo.1924.1">Of course, a lot of country names are omitted in the preceding code snippet. </span><span class="koboSpan" id="kobo.1924.2">However, when the file with country names is ready, you need to read its content and form a trie, as presented in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1925.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1926.1">
using System.Text.RegularExpressions;
</span><strong class="bold"><span class="koboSpan" id="kobo.1927.1">Trie trie = new();</span></strong><span class="koboSpan" id="kobo.1928.1">
string[] countries =
    await File.ReadAllLinesAsync("Countries.txt");
foreach (string country in countries)
{
    Regex regex = new("[^a-z]");
    string name = country.ToLower();
    name = regex.Replace(name, string.Empty);
    </span><strong class="bold"><span class="koboSpan" id="kobo.1929.1">trie.Insert(name);</span></strong><span class="koboSpan" id="kobo.1930.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1931.1">At the beginning, you create a </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.1932.1">new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1933.1">Trie</span></strong><span class="koboSpan" id="kobo.1934.1"> class. </span><span class="koboSpan" id="kobo.1934.2">Then, you read all lines from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1935.1">Countries.txt</span></strong><span class="koboSpan" id="kobo.1936.1"> file and store them in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1937.1">countries</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1938.1"> array.</span></span></p>
<p><span class="koboSpan" id="kobo.1939.1">The remaining part of the code consists of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1940.1">foreach</span></strong><span class="koboSpan" id="kobo.1941.1"> loop that iterates through all country names. </span><span class="koboSpan" id="kobo.1941.2">For each of them, you make it lowercase and remove all chars other than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1942.1">a</span></strong><span class="koboSpan" id="kobo.1943.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1944.1">z</span></strong><span class="koboSpan" id="kobo.1945.1">. </span><span class="koboSpan" id="kobo.1945.2">Such a task is performed with a regular expression and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1946.1">Regex</span></strong><span class="koboSpan" id="kobo.1947.1"> class from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1948.1">System.Text.RegularExpressions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1949.1"> namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.1950.1">When the trie is ready, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">while</span></strong><span class="koboSpan" id="kobo.1952.1"> loop, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1953.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1954.1">
string text = string.Empty;
while (true)
{
    Console.Write("Enter next character: ");
    ConsoleKeyInfo key = Console.ReadKey();
    if (key.KeyChar &lt; 'a' || key.KeyChar &gt; 'z') { return; }
    text = (text + key.KeyChar).ToLower();
    </span><strong class="bold"><span class="koboSpan" id="kobo.1955.1">List&lt;string&gt; results = trie.SearchByPrefix(text);</span></strong><span class="koboSpan" id="kobo.1956.1">
    if (results.Count == 0) { return; }
    Console.WriteLine(
        $"\nSuggestions for {text.ToUpper()}:");
    results.ForEach(r =&gt; Console.WriteLine(r.ToUpper()));
    Console.WriteLine();
}</span></pre> <p><span class="koboSpan" id="kobo.1957.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1958.1">while</span></strong><span class="koboSpan" id="kobo.1959.1"> loop, you wait until the user presses any key. </span><span class="koboSpan" id="kobo.1959.2">If this key is other than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1960.1">a</span></strong><span class="koboSpan" id="kobo.1961.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1962.1">z</span></strong><span class="koboSpan" id="kobo.1963.1">, the program ends its operation. </span><span class="koboSpan" id="kobo.1963.2">Otherwise, you append the entered char to the prefix that is used for searching all country names that start with this prefix. </span><span class="koboSpan" id="kobo.1963.3">If the number of results is equal to zero, the</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.1964.1"> application ends its operation. </span><span class="koboSpan" id="kobo.1964.2">Otherwise, you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1965.1">ForEach</span></strong><span class="koboSpan" id="kobo.1966.1"> extension method to write each suggestion on a </span><span class="No-Break"><span class="koboSpan" id="kobo.1967.1">separate line.</span></span></p>
<p><span class="koboSpan" id="kobo.1968.1">As you can see, a trie provides you with a powerful and efficient mechanism for implementing an autocomplete feature. </span><span class="koboSpan" id="kobo.1968.2">But what does it look like in practice? </span><span class="koboSpan" id="kobo.1968.3">Let’s take a look at the following output regarding searching </span><span class="No-Break"><span class="koboSpan" id="kobo.1969.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1970.1">POLAND</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1971.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1972.1">
Enter next character: p
Suggestions for P:
PAKISTAN
PALAU
PANAMA
PAPUANEWGUINEA
PARAGUAY
PERU
PHILIPPINES
POLAND
PORTUGAL
Enter next character: o
Suggestions for PO:
POLAND
PORTUGAL
Enter next character: l
Suggestions for POL:
POLAND
Enter next character: e</span></pre> <p><span class="koboSpan" id="kobo.1973.1">At the beginning, you can see names of countries that start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1974.1">P</span></strong><span class="koboSpan" id="kobo.1975.1">. </span><span class="koboSpan" id="kobo.1975.2">After typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1976.1">O</span></strong><span class="koboSpan" id="kobo.1977.1">, you limit the results to countries</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.1978.1"> whose names start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1979.1">PO</span></strong><span class="koboSpan" id="kobo.1980.1">. </span><span class="koboSpan" id="kobo.1980.2">In the same way, you further increase the prefix and get fewer and </span><span class="No-Break"><span class="koboSpan" id="kobo.1981.1">fewer results.</span></span></p>
<p><span class="koboSpan" id="kobo.1982.1">Let’s proceed to the last part of this chapter,</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.1983.1"> which is related to heaps. </span><span class="koboSpan" id="kobo.1983.2">What are they, and why are they featured in a chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.1984.1">about trees?</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.1985.1">Heaps</span></h1>
<p><span class="koboSpan" id="kobo.1986.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.1987.1">heap</span></strong><span class="koboSpan" id="kobo.1988.1"> is another variant of a tree, which you already got to know in </span><a href="B18069_03.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1989.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.1990.1">,</span><em class="italic"><span class="koboSpan" id="kobo.1991.1"> Arrays and Sorting</span></em><span class="koboSpan" id="kobo.1992.1">. </span><span class="koboSpan" id="kobo.1992.2">There, you used a heap in the heap sort algorithm for sorting an array. </span><span class="koboSpan" id="kobo.1992.3">For this reason, in the current </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.1993.1">chapter, you will see only a brief summary of this data structure. </span><span class="koboSpan" id="kobo.1993.2">However, I strongly encourage you not to leave this topic and learn much more about heaps on your own, as they are powerful and popular </span><span class="No-Break"><span class="koboSpan" id="kobo.1994.1">data structures.</span></span></p>
<p><span class="koboSpan" id="kobo.1995.1">As you already know, a binary heap exists in two versions: </span><strong class="bold"><span class="koboSpan" id="kobo.1996.1">min-heap</span></strong><span class="koboSpan" id="kobo.1997.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1998.1">max-heap</span></strong><span class="koboSpan" id="kobo.1999.1">. </span><span class="koboSpan" id="kobo.1999.2">For each of them, an additional property must </span><span class="No-Break"><span class="koboSpan" id="kobo.2000.1">be satisfied:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.2001.1">For min-heap</span></strong><span class="koboSpan" id="kobo.2002.1">: The value of each</span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.2003.1"> node must be greater than or equal to the value of its </span><span class="No-Break"><span class="koboSpan" id="kobo.2004.1">parent node</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.2005.1">For max-heap</span></strong><span class="koboSpan" id="kobo.2006.1">: The value of</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.2007.1"> each node must be less than or equal to the value of its </span><span class="No-Break"><span class="koboSpan" id="kobo.2008.1">parent node</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2009.1">These rules perform a very important role because they dictate that </span><strong class="bold"><span class="koboSpan" id="kobo.2010.1">the root node always contains the smallest value (in the min-heap) or the largest value (in the max-heap)</span></strong><span class="koboSpan" id="kobo.2011.1">. </span><span class="koboSpan" id="kobo.2011.2">You benefited from this assumption while sorting. </span><span class="koboSpan" id="kobo.2011.3">Do </span><span class="No-Break"><span class="koboSpan" id="kobo.2012.1">you remember?</span></span></p>
<p><span class="koboSpan" id="kobo.2013.1">A binary heap must also adhere to the </span><strong class="bold"><span class="koboSpan" id="kobo.2014.1">complete binary tree</span></strong><span class="koboSpan" id="kobo.2015.1"> rule, which requires that </span><strong class="bold"><span class="koboSpan" id="kobo.2016.1">each node cannot contain more than two children and all levels of a tree must be fully filled, except the last one, which must be filled from left to right</span></strong><span class="koboSpan" id="kobo.2017.1"> and can have some space on </span><span class="No-Break"><span class="koboSpan" id="kobo.2018.1">the right.</span></span></p>
<p><span class="koboSpan" id="kobo.2019.1">Let’s take a look at the following two </span><span class="No-Break"><span class="koboSpan" id="kobo.2020.1">binary heaps:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.2021.1"><img alt="Figure 7.23 – ﻿Illustration of a min-heap and a max-heap" src="image/B18069_07_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2022.1">Figure 7.23 – Illustration of a min-heap and a max-heap</span></p>
<p><span class="koboSpan" id="kobo.2023.1">You can easily check whether both heaps adhere to all the rules. </span><span class="koboSpan" id="kobo.2023.2">As an example, let’s verify the heap property for the node with a value equal to </span><strong class="bold"><span class="koboSpan" id="kobo.2024.1">20</span></strong><span class="koboSpan" id="kobo.2025.1"> from the min-heap variant (shown on the left). </span><span class="koboSpan" id="kobo.2025.2">The node has two children with values of </span><strong class="bold"><span class="koboSpan" id="kobo.2026.1">35</span></strong><span class="koboSpan" id="kobo.2027.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.2028.1">50</span></strong><span class="koboSpan" id="kobo.2029.1">, which are both greater than </span><strong class="bold"><span class="koboSpan" id="kobo.2030.1">20</span></strong><span class="koboSpan" id="kobo.2031.1">. </span><span class="koboSpan" id="kobo.2031.2">In the same way, you can check the remaining nodes in </span><span class="No-Break"><span class="koboSpan" id="kobo.2032.1">the heap.</span></span></p>
<p><span class="koboSpan" id="kobo.2033.1">The binary tree rule is also maintained, as each node contains at most two children. </span><span class="koboSpan" id="kobo.2033.2">The last requirement is that each level of the tree is fully filled except the last one, which does not need to be fully filled, but must contain nodes from left to right. </span><span class="koboSpan" id="kobo.2033.3">In the min-heap example, three levels are fully filled (with one, two, and four nodes), while the last level contains two nodes (</span><strong class="bold"><span class="koboSpan" id="kobo.2034.1">25</span></strong><span class="koboSpan" id="kobo.2035.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.2036.1">70</span></strong><span class="koboSpan" id="kobo.2037.1">), placed on the two leftmost positions. </span><span class="koboSpan" id="kobo.2037.2">In the same way, you can confirm that the max-heap (shown on the right) is </span><span class="No-Break"><span class="koboSpan" id="kobo.2038.1">configured properly.</span></span></p>
<p><span class="koboSpan" id="kobo.2039.1">At the end of this short introduction to the topic of heaps, and especially to binary heaps, it is worth mentioning the broad range of applications. </span><span class="koboSpan" id="kobo.2039.2">First of all, this data structure is a convenient way of implementing a </span><strong class="bold"><span class="koboSpan" id="kobo.2040.1">priority queue</span></strong><span class="koboSpan" id="kobo.2041.1"> with the operation of inserting a new value and removing the </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.2042.1">smallest value (in the min-heap) or the largest value (in the max-heap). </span><span class="koboSpan" id="kobo.2042.2">Moreover, a heap is used in the </span><strong class="bold"><span class="koboSpan" id="kobo.2043.1">heap sort algorithm</span></strong><span class="koboSpan" id="kobo.2044.1">, as well as in </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2045.1">graph algorithms</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2046.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2047.1">A binary heap can either be implemented from scratch or you can use some of the already available implementations as NuGet packages. </span><span class="koboSpan" id="kobo.2047.2">One of the solutions is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2048.1">PommaLabs.Hippie</span></strong><span class="koboSpan" id="kobo.2049.1"> and can be easily installed on the project using the </span><strong class="bold"><span class="koboSpan" id="kobo.2050.1">NuGet Package Manager</span></strong><span class="koboSpan" id="kobo.2051.1">. </span><span class="koboSpan" id="kobo.2051.2">The mentioned library contains an implem</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.2052.1">entation of a few variants of heaps, including binary heaps, </span><strong class="bold"><span class="koboSpan" id="kobo.2053.1">binomial heaps</span></strong><span class="koboSpan" id="kobo.2054.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2055.1">Fibonacci heaps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2056.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2057.1">Trees were everywhere in this chapter, and heaps are also representatives of thi</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.2058.1">s data structure! </span><span class="koboSpan" id="kobo.2058.2">As you already learned a lot about trees, let’s proceed to the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2059.1">Summary</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2060.1"> section.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.2061.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2062.1">The current chapter was the longest so far in the book. </span><span class="koboSpan" id="kobo.2062.2">However, it contained a lot of information about variants of trees. </span><span class="koboSpan" id="kobo.2062.3">Such data structures perform a very important role in many algorithms, and it is good to learn more about them, as well as to know how to use them in your applications. </span><span class="koboSpan" id="kobo.2062.4">For this reason, this chapter contained not only short theoretical introductions but also diagrams, explanations, and </span><span class="No-Break"><span class="koboSpan" id="kobo.2063.1">code samples.</span></span></p>
<p><span class="koboSpan" id="kobo.2064.1">At the beginning, </span><strong class="bold"><span class="koboSpan" id="kobo.2065.1">the concept of a tree</span></strong><span class="koboSpan" id="kobo.2066.1"> was described. </span><span class="koboSpan" id="kobo.2066.2">As a reminder, a tree consists of </span><strong class="bold"><span class="koboSpan" id="kobo.2067.1">nodes</span></strong><span class="koboSpan" id="kobo.2068.1">, including one </span><strong class="bold"><span class="koboSpan" id="kobo.2069.1">root</span></strong><span class="koboSpan" id="kobo.2070.1">. </span><span class="koboSpan" id="kobo.2070.2">The root does not contain a parent node, while all other nodes do. </span><span class="koboSpan" id="kobo.2070.3">Each node can have any number of </span><strong class="bold"><span class="koboSpan" id="kobo.2071.1">child nodes</span></strong><span class="koboSpan" id="kobo.2072.1">. </span><span class="koboSpan" id="kobo.2072.2">The child nodes of the same node can be named </span><strong class="bold"><span class="koboSpan" id="kobo.2073.1">siblings</span></strong><span class="koboSpan" id="kobo.2074.1">, while a node without children is named </span><span class="No-Break"><span class="koboSpan" id="kobo.2075.1">a </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2076.1">leaf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2077.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2078.1">Various variants of trees follow this structure. </span><span class="koboSpan" id="kobo.2078.2">The first one described in the chapter is a </span><strong class="bold"><span class="koboSpan" id="kobo.2079.1">binary tree</span></strong><span class="koboSpan" id="kobo.2080.1">. </span><span class="koboSpan" id="kobo.2080.2">In this case, a node can contain at most two children. </span><span class="koboSpan" id="kobo.2080.3">However, the rules for </span><strong class="bold"><span class="koboSpan" id="kobo.2081.1">binary search trees</span></strong><span class="koboSpan" id="kobo.2082.1"> are even more strict. </span><span class="koboSpan" id="kobo.2082.2">For any node in such trees, the values of all nodes in its left subtree must be smaller than the value of the node, while the values of all nodes in its right subtree must be greater than the value of the node. </span><span class="koboSpan" id="kobo.2082.3">BSTs have a broad range of applications and provide developers with significant improvements in the lookup performance. </span><span class="koboSpan" id="kobo.2082.4">However, it is possible to easily make a tree unbalanced while adding sorted values to the tree. </span><span class="koboSpan" id="kobo.2082.5">Thus, the positive impact on the performance can </span><span class="No-Break"><span class="koboSpan" id="kobo.2083.1">be limited.</span></span></p>
<p><span class="koboSpan" id="kobo.2084.1">Fortunately, </span><strong class="bold"><span class="koboSpan" id="kobo.2085.1">self-balancing trees</span></strong><span class="koboSpan" id="kobo.2086.1"> exist and remain balanced all the time while adding or removing nodes. </span><span class="koboSpan" id="kobo.2086.2">Two variants were presented: AVL trees and red-black trees. </span><span class="koboSpan" id="kobo.2086.3">An </span><strong class="bold"><span class="koboSpan" id="kobo.2087.1">AVL tree</span></strong><span class="koboSpan" id="kobo.2088.1"> has an additional requirement that, for each node, the height of its left and right subtrees cannot differ by more than one. </span><span class="koboSpan" id="kobo.2088.2">An </span><strong class="bold"><span class="koboSpan" id="kobo.2089.1">RBT</span></strong><span class="koboSpan" id="kobo.2090.1"> introduces the concept of coloring nodes, either red or black, as well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2091.1">NIL</span></strong><span class="koboSpan" id="kobo.2092.1"> pseudo-nodes. </span><span class="koboSpan" id="kobo.2092.2">Moreover, it is required that if a node is red, both its children must be black, and for any node, the number of black nodes on the route to a descendant leaf must be </span><span class="No-Break"><span class="koboSpan" id="kobo.2093.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.2094.1">Then, you learned a lot about </span><strong class="bold"><span class="koboSpan" id="kobo.2095.1">tries</span></strong><span class="koboSpan" id="kobo.2096.1"> and saw their great performance regarding processing strings, such as for autocomplete or spellchecker features. </span><span class="koboSpan" id="kobo.2096.2">Each trie is a tree with one root node, where each node represents a string and each edge indicates a character. </span><span class="koboSpan" id="kobo.2096.3">A trie node contains references to the next nodes as an array with elements representing possible characters. </span><span class="koboSpan" id="kobo.2096.4">When you go from the root to each node, you receive a string, which is either a saved word or its substring. </span><span class="koboSpan" id="kobo.2096.5">Within this part, a </span><strong class="bold"><span class="koboSpan" id="kobo.2097.1">radix tree</span></strong><span class="koboSpan" id="kobo.2098.1"> was mentioned as well, which is a space-optimized version of </span><span class="No-Break"><span class="koboSpan" id="kobo.2099.1">a trie.</span></span></p>
<p><span class="koboSpan" id="kobo.2100.1">The remaining part of the chapter was related to </span><strong class="bold"><span class="koboSpan" id="kobo.2101.1">binary heaps</span></strong><span class="koboSpan" id="kobo.2102.1">. </span><span class="koboSpan" id="kobo.2102.2">As a reminder, a heap is another variant of a tree, which exists in two versions, </span><strong class="bold"><span class="koboSpan" id="kobo.2103.1">min-heap</span></strong><span class="koboSpan" id="kobo.2104.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.2105.1">max-heap</span></strong><span class="koboSpan" id="kobo.2106.1">. </span><span class="koboSpan" id="kobo.2106.2">It is worth noting that the value of each node must be greater than or equal to (for min-heaps) or less than or equal to (for max-heaps) the value of its </span><span class="No-Break"><span class="koboSpan" id="kobo.2107.1">parent node.</span></span></p>
<p><span class="koboSpan" id="kobo.2108.1">Let’s proceed to </span><strong class="bold"><span class="koboSpan" id="kobo.2109.1">graphs</span></strong><span class="koboSpan" id="kobo.2110.1">, which are the subject of the </span><span class="No-Break"><span class="koboSpan" id="kobo.2111.1">next chapter!</span></span></p>
</div>
</body></html>