- en: State
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: In video games, objects continually transition from one state to another depending
    on events that might be triggered by the player or the game's mechanics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，对象会根据可能由玩家或游戏机制触发的事件不断从一个状态转换到另一个状态。
- en: So, one of the primary responsibilities of a game programmer is to implement
    a list of finite states and behaviors for entities, ranging from **non-player
    characters** (**NPCs**) to weapons. These tasks must be accomplished in a way
    that's maintainable and configurable so that a team of designers can tweak each
    stateful behavior individually until the game feels balanced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，游戏程序员的主要职责之一是实现一系列有限状态和行为，这些状态和行为从**非玩家角色**（NPC）到武器不等。这些任务必须以可维护和可配置的方式进行，以便设计团队能够单独调整每个状态行为，直到游戏感觉平衡。
- en: The State pattern was designed precisely to accomplish this by offering a simple
    way to encapsulate behaviors into individual classes that represent the specific
    states of an object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式正是为了通过提供一种简单的方式来封装行为到代表对象特定状态的独立类中，从而精确地设计来达成这一目标。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of the State pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式的基本原理
- en: Implementing a collection of finite states for a game involving a spaceship
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为涉及太空船的游戏实现有限状态集合
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涉及实践操作，因此你需要对 Unity 和 C# 有一个基本的了解。
- en: 'We will be using the following Unity-specific engine and C# language concept:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下 Unity 特定引擎和 C# 语言概念：
- en: Interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: If you are unfamiliar with this concept, please review it before moving forward
    with this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个概念不熟悉，请在继续本章之前进行复习。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2UfzpTD](http://bit.ly/2UfzpTD)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2UfzpTD](http://bit.ly/2UfzpTD)'
- en: The basics of the State pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式的基本原理
- en: The State pattern is very similar to the Strategy pattern in the sense that
    it permits us to apply behaviors at runtime to a specific object. The core difference
    is that the State pattern is used when we need to manage an object's internal
    states, while the Strategy pattern focuses on choosing the right algorithm to
    execute, depending on the runtime context.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，状态模式与策略模式非常相似，因为它允许我们在运行时将行为应用到特定的对象上。核心区别在于，当我们需要管理对象的内部状态时使用状态模式，而策略模式则侧重于根据运行时上下文选择正确的算法来执行。
- en: 'In the context of a class structure for a spaceship project, the following
    diagram shows how state classes (`NormalShipState`, `AlertShipState`, and `DisabledShipState`)
    have a standard interface that permits the `Ship` class to invoke the behavior
    of a specific state:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在太空船项目类结构中，以下图表显示了状态类（`NormalShipState`、`AlertShipState` 和 `DisabledShipState`）具有标准接口，允许
    `Ship` 类调用特定状态的行为：
- en: '![](img/23d448b1-a72a-4f10-8443-02abb2a98e78.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23d448b1-a72a-4f10-8443-02abb2a98e78.png)'
- en: As we will see in the code example, the concept behind the State pattern is
    as simple as its actual implementation, because it offers us a way to encapsulate
    behaviors and apply them, without resorting to long conditional statements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在代码示例中看到的，状态模式背后的概念与其实际实现一样简单，因为它为我们提供了一种封装行为并应用它们的方法，而不必依赖于长条件语句。
- en: Benefits and drawbacks
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: It can be challenging to pinpoint the common drawbacks of the State pattern,
    because managing states are fundamental to game development, so we could say that
    this pattern is essential and cannot be disregarded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确定状态模式的共同缺点可能具有挑战性，因为状态管理是游戏开发的基础，因此我们可以认为这个模式是基本的，不能被忽视。
- en: 'The following are the benefits of using the State pattern:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态模式的以下是一些优点：
- en: '**Encapsulated behaviors**: The State pattern allows us to implement an entity''s
    behaviors as a collection of self-contained components that can be attached dynamically
    to an object when it changes states.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装的行为**：状态模式允许我们将一个实体的行为实现为一个自包含的组件集合，当对象状态改变时，这些组件可以动态地附加到对象上。'
- en: '**Reduction of condition blocks**: Using the State pattern reduces the need
    for huge chunks of `if-else` conditions or switching cases, because behaviors
    can be dynamically assigned depending on an object''s internal or global state
    change.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件块减少**：使用状态模式可以减少对大量`if-else`条件或切换情况的需求，因为行为可以根据对象的内部或全局状态变化动态分配。'
- en: 'There is only one drawback:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个缺点：
- en: '**Code complexity**: Implementing patterns sometimes results in verbose code
    bases with a higher number of classes because of encapsulation and highly defined
    structures'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码复杂性**：实现模式有时会导致代码库冗长，并且由于封装和高度定义的结构，类数量增加'
- en: Use case example
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用案例示例
- en: 'Imagine we are working on a game in which the player controls a spaceship.
    Our lead designer is still brainstorming ideas on what exactly the spaceship will
    be able to do in our game. But they ask us to implement at least three core states
    that our spaceship could be in depending on the result of a space battle against
    an enemy ship:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在制作一个游戏，玩家控制一艘飞船。我们的首席设计师仍在头脑风暴关于飞船在游戏中具体能做什么的想法。但他们要求我们实现至少三个核心状态，我们的飞船可以根据与敌舰太空战的战果处于这些状态之一：
- en: '**Normal**: The player''s spaceship is running as normal'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常**：玩家的飞船正常运行'
- en: '**Alert**: An enemy spaceship is approaching and is ready to attack'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：一艘敌舰正在接近并准备攻击'
- en: '**Disabled**: The player''s spaceship has been defeated in battle and currently
    cannot move or fight back'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用**：玩家的飞船在战斗中被击败，目前无法移动或反击'
- en: 'In each state, there''s a specific set of behaviors and actions for the crew
    members to perform:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个状态下，都有特定的一组行为和行动供船员执行：
- en: '**Normal**: The crew members go into their default positions and perform their
    assigned duties'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常**：船员回到他们的默认位置并执行分配的任务'
- en: '**Alert**: The crew members run to their assigned combat positions'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：船员跑向他们的指定战斗位置'
- en: '**Disabled**: The crew members run to the escape pods and abandon the ship'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用**：船员跑向逃生舱并放弃船只'
- en: The most important thing about this list is that it's very generic, which means
    that we could write those states and behaviors so, we can attach them to any type
    of ship in our game, including enemy ships. As we will see in the following code
    example, the State pattern permits us to decouple behaviors from entities, and
    this is why we can easily have an entity switch between states.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个列表最重要的一点是它非常通用，这意味着我们可以编写这些状态和行为，以便将它们附加到我们游戏中任何类型的飞船上，包括敌舰。正如我们将在下面的代码示例中看到的，状态模式允许我们将行为与实体解耦，这也是为什么实体可以轻松地在状态之间切换的原因。
- en: Code example
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'As described in the use case example, we are going to implement a finite series
    of states for our spaceship:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如使用案例示例中所述，我们将为我们的飞船实现一系列有限的状态：
- en: 'Let''s start by implementing the interface that will be used to define our
    states:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先实现一个接口，用于定义我们的状态：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the `Execute` function receives an entity of the `Ship` type. This
    declaration means that we will able to attach and execute our state on any ship,
    making our code very modular and extendable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Execute`函数接收一个`Ship`类型的实体。这个声明意味着我们将能够将我们的状态附加到任何飞船上并执行，这使得我们的代码非常模块化和可扩展。
- en: 'Now we are going to define each state and add some contextual code to the `Execute()`
    method:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义每个状态并添加一些上下文代码到`Execute()`方法中：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Normal` state is our default one, which executes the behaviors of a normally
    operating ship.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`正常`状态是我们的默认状态，它执行正常运行的飞船的行为。'
- en: 'Next is the `Alert` state. In this context, the crew of the ship and its system
    are alerted:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`警报`状态。在这种情况下，飞船的船员和系统都会发出警报：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, there is the `Disabled` state. This means that the ship is unable
    to move and the crew is fleeing:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是`禁用`状态。这意味着飞船无法移动，船员正在逃离：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For our code example, we are making things straightforward by merely implementing
    some console outputs to indicate the current state, but in a real project, we
    could easily trigger sound cues, particles, and animations for every state change.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的代码示例，我们通过仅实现一些控制台输出以指示当前状态来简化事情，但在实际项目中，我们可以轻松触发每个状态变化的声音提示、粒子效果和动画。
- en: 'Now that we have a collection of states that we can attach to a ship. For the
    next step, let''s write a concrete implementation of the `Ship` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经收集了一组可以附加到飞船上的状态。下一步，让我们编写`Ship`类的具体实现：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s review a short list of what we have accomplished with this pattern:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们使用此模式所取得的成果：
- en: We have eliminated the need for switch cases or `if-elses` to manage the transition
    between the ship's stateful behaviors.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们消除了管理飞船状态行为之间转换所需的switch cases或`if-elses`。
- en: We have decoupled the ship's behaviors into self-contained components that we
    can attach dynamically to any type of ship.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将飞船的行为解耦成可以动态附加到任何类型飞船的自包含组件。
- en: These small benefits have given us a considerable amount of flexibility, and
    we can now write behaviors as individual components. This means we could have
    one colleague working on the `Alert` state while another refactors the `Disabled`
    state, without interfering with each other's work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小的好处给了我们相当大的灵活性，现在我们可以将行为作为单独的组件来编写。这意味着我们可以让一位同事专注于`Alert`状态，而另一位重构`Disabled`状态，而不会相互干扰。
- en: 'And the final part of our code example is our `Client`, a class that we will
    use to test each state by triggering them with the user''s input:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们代码示例的最后部分是我们的`Client`类，我们将使用它通过用户的输入来触发每个状态以测试它们：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we are manually triggering the ship's finite states, but we
    could have easily used events or a health system to trigger them. In other words,
    by using the State pattern, we have been given the flexibility to attach multiple
    stateful behaviors to any entity and trigger them dynamically through any type
    of mechanism, without having to write long and complex conditional statements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们手动触发飞船的有限状态，但我们同样可以轻松地使用事件或健康系统来触发它们。换句话说，通过使用状态模式，我们获得了将多个状态行为附加到任何实体并动态通过任何机制触发的灵活性，而不必编写长而复杂的条件语句。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed a pattern that's the cornerstone of game development.
    We now have the ability to encapsulate stateful behaviors into individual components
    that can be assigned dynamically to an object depending on its state. We have
    reduced our dependency on long conditional statements and have a consistent approach
    to structuring our code that's related to behaviors and state management.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们回顾了一个游戏开发的基础模式。我们现在有能力将状态行为封装成可以动态分配给对象的单独组件。我们减少了我们对长条件语句的依赖，并有一个与行为和状态管理相关的代码结构的一致方法。
- en: In the next chapter, we are going to review the Visitor pattern, a unique pattern
    that gives us the ability to decouple algorithms from an object's structure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾访问者模式，这是一种独特的模式，它赋予我们解耦算法与对象结构的能力。
- en: Exercises
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'A conventional technique in video games to make entities feel less mechanical
    in the way they behave is to ease out the transition between states. For example:
    instead of having a patrolling enemy character transitioning immediately from
    a passive to an aggressive state when they detect the player''s character, there
    could be a short animation sequence in between states, showing the enemy going
    into an alert stance before attacking.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，为了使实体在行为上感觉不那么机械，一种常见的技巧是缓和状态之间的过渡。例如：当巡逻的敌人角色检测到玩家的角色时，它们不会立即从被动状态转变为攻击状态，而是在状态之间有一个简短的动画序列，显示敌人进入警戒姿态然后发起攻击。
- en: As an exercise, I would recommend experimenting with the concept of integrating
    transitional states between each finite state of the spaceship and find a solution
    to make the transition between them blend seamlessly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我建议尝试将过渡状态整合到宇宙飞船的每个有限状态之间，并找到一个使它们之间过渡无缝融合的解决方案。
- en: Further reading
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, by Erich
    Gamma, John Vlissides, Ralph Johnson, and Richard Helm'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 《*设计模式：可复用面向对象软件元素*》，作者Erich Gamma、John Vlissides、Ralph Johnson和Richard Helm
- en: ([http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610))
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ([http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610))
