<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-104"><a id="_idTextAnchor114"/>5</h1>
<h1 id="_idParaDest-105"><a id="_idTextAnchor115"/>Test-Driven Development Explained</h1>
<p><strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) is a set of practices on top of unit tests. They alter the way you design your code and you write unit tests. Basically, it is a different approach to writing code than the classical technique of writing code and then testing it after.</p>
<p>It is a cliché to say that TDD is not just doing testing first, but rather than me telling you otherwise, you will decide yourself after going through <em class="italic">Chapters 5</em> and <em class="italic">6</em>.</p>
<p>In this chapter, we will:</p>
<ul>
<li>Go through TDD pillars</li>
<li>Implement a software feature following the TDD style</li>
<li>Converse the FAQs and criticism around the subject</li>
<li>Discuss having TDD with Sintegration testing</li>
</ul>
<p>By the end of the chapter, you will be able to use TDD to write basic coding tasks and understand the topics around the subject and where TDD fits in the software ecosystem.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor116"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p>https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch05</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor117"/>TDD pillars</h1>
<p>TDD is a set of practices that<a id="_idIndexMarker360"/> specify how and when a unit test should be written. You<a id="_idIndexMarker361"/> can write unit tests without TDD, but TDD has to have a type of test associated with it. Sometimes, you can hear TDD and unit tests used as if they mean the same thing, but they are not.</p>
<p>While the ecosystem around TDD is sophisticated as it touches a lot of software engineering aspects, TDD as a standalone concept is easy to explain and understand. We can summarize TDD as these two pillars:</p>
<ul>
<li><strong class="bold">Test first</strong></li>
<li><strong class="bold">Red, Green, Refactor</strong> (<strong class="bold">RGR</strong>)</li>
</ul>
<p>Let’s discuss these pillars.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor118"/>Test first</h2>
<p>The idea here is to start with the <a id="_idIndexMarker362"/>tests before starting with the production code. It really means testing code that doesn’t exist yet!</p>
<p>Testing first changes the way we write code, as now you are redirected to think about your classes' structure and public methods before the implementation. This encourages the developer to reflect on the design from the client’s perspective (the client is the external code calling your code, also known as the caller).</p>
<p>We will demonstrate how to start with tests by going through a few examples to get you accustomed to the concept and familiarize you with how it is done. Then, we will go into detail about the benefits of this approach in the first section of <a href="B18370_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, <em class="italic">The FIRSTHAND Guidelines of TDD</em>.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor119"/>Red, green, refactor</h2>
<p>The RGR process is the one used <a id="_idIndexMarker363"/>when writing code in TDD-style. This process works<a id="_idIndexMarker364"/> in tandem with the test first guideline. This is how it goes:</p>
<ol>
<li>You are planning to write a coding task, which is part of a feature that you want to add to the code.</li>
<li>You write the unit test for this production code while the production code doesn’t exist (as you haven’t written it yet). Also, maybe you are planning to update existing production code, so you write a unit test first, assuming the final production code is in place.</li>
<li>You run the unit test and it will fail (red), for one of two reasons:<ul><li>The code doesn’t compile, as the production code is not written yet.</li>
<li>The test will fail, as while it is compiling, the logic that implements the new coding task is not the right one, as the existing production code has not been updated to reflect the new feature yet.</li>
</ul></li>
<li>Write the fastest and minimal code to make the test pass (green). Don’t perfect the code at this stage; you can also copy the intended code from the internet. The idea is just to get on with it.</li>
<li>Now, we know that <a id="_idIndexMarker365"/>our coding task is in place and it is working; however, you might consider refactoring the production code if it suffers from one of these issues:<ul><li>Readability</li>
<li>Performance</li>
<li>A design that doesn’t comply with the rest of the code</li>
</ul></li>
<li>Run your unit test to make sure you have not broken anything while you were refactoring. If it is broken (red), then you would naturally go back to <em class="italic">step 3</em>.</li>
</ol>
<p>You can see why the color names were picked:</p>
<ul>
<li><strong class="bold">Red</strong>: Represents failed tests, which look red in the test runners (such as VS Test Explorer)</li>
<li><strong class="bold">Green</strong>: Represents passed tests, which look green in the test runners</li>
</ul>
<div><div><img alt="Figure 5.1 – The red, green, refactor process " height="436" src="img/Figure_5.1_B18370.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The red, green, refactor process</p>
<p>The previous diagram highlights the steps that we’ve just discussed in the RGR process.</p>
<p>We can draw diagrams and talk more about TDD, or we can demonstrate with examples, which is what <a id="_idIndexMarker366"/>we will do next.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor120"/>TDD by example</h1>
<p>TDD is best understood by<a id="_idIndexMarker367"/> looking at examples, so let’s take a story and write it TDD-style. We will be working on the feature described by this story:</p>
<p class="callout-heading">Story Title:</p>
<p class="callout"><em class="italic">Changing a username</em></p>
<p class="callout"><strong class="bold">Story Description:</strong></p>
<p class="callout"><em class="italic">As a customer</em></p>
<p class="callout"><em class="italic">Given I already have an account</em></p>
<p class="callout"><em class="italic">When I navigate to my profile page</em></p>
<p class="callout"><em class="italic">Then I can update my username</em></p>
<p class="callout"><strong class="bold">Acceptance Criteria:</strong></p>
<p class="callout"><em class="italic">The username can only contain between 8 and 12 characters, inclusive:</em></p>
<p class="callout"><em class="italic">- Valid: AnameOf8, NameOfChar12</em></p>
<p class="callout"><em class="italic">- Invalid: AnameOfChar13, NameOf7</em></p>
<p class="callout"><em class="italic">Only alphanumerics and underscores are allowed:</em></p>
<p class="callout"><em class="italic">- Valid: Letter_123</em></p>
<p class="callout"><em class="italic">- Invalid: !The_Start, InThe@Middle, WithDollar$, Space 123</em></p>
<p class="callout"><em class="italic">If the username already exists, generate an error</em></p>
<p>Let’s not waste any<a id="_idIndexMarker368"/> time and implement this story.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor121"/>Creating the solution shell</h2>
<p>We will create a class <a id="_idIndexMarker369"/>library called <code>Uqs.Customer</code>, add a unit testing project to test it called <code>Uqs.Customer.Tests.Unit</code>, and add them to a solution called <code>TddByExample.sln</code>. So, let’s start:</p>
<ol>
<li value="1">In a directory called <code>TddByExample</code>, create the <code>lib</code> class and the following xUnit projects:<pre><strong class="bold">dotnet new classlib -o Uqs.Customer -f net6.0</strong>
<strong class="bold">dotnet new xunit -o Uqs.Customer.Tests.Unit -f net6.0</strong></pre></li>
<li>Create a solution file and add the projects to it. The solution name will be the directory name. So, in this case, it will automatically be called <code>TddByExample.sln</code>:<pre><strong class="bold">dotnet new sln</strong>
<strong class="bold">dotnet sln add Uqs.Customer</strong>
<strong class="bold">dotnet sln add Uqs.Customer.Tests.Unit</strong></pre></li>
<li>Reference the production code project from the unit tests project:<pre><strong class="bold">dotnet add Uqs.Customer.Tests.Unit reference Uqs.Customer</strong></pre></li>
<li>When you open the solution, you will get the following:</li>
</ol>
<div><div><img alt="Figure 5.2 – Solution Explorer showing the newly created project " height="401" src="img/Figure_5.2_B18370.jpg" width="495"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Solution Explorer showing the newly created project</p>
<p>Now, to the coding<a id="_idIndexMarker370"/> stage.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor122"/>Adding coding tasks</h2>
<p>The requested feature <a id="_idIndexMarker371"/>comprises smaller coding tasks (challenges), so you will be adding multiple unit tests with at least one unit test for each coding challenge.</p>
<p>I start with the challenge that gives the shortest feedback and work my way up. This will help me build the initial structure without having to worry about everything at the same time. It will also help me avoid tasks such as connectivity to the database and availability of the username in the database (username is already taken) from the start. Then, start adding more sophisticated challenges in order of complexity. Let’s see how we can achieve this next.</p>
<h3>Coding task one – validate null username</h3>
<p>I normally spend little<a id="_idIndexMarker372"/> time analyzing the shortest code challenge <a id="_idIndexMarker373"/>and use my gut feeling. I feel the shortest route is to check the username for nullability. Now, rename the template test class from <code>UnitTest1.cs</code> to <code>ProfileServiceTests.cs</code> and replace the content with this code:</p>
<pre class="source-code">namespace Uqs.Customer.Tests.Unit;
public class ProfileServiceTests
{
    [Fact]
    public void
       ChangeUsername_NullUsername_ArgumentNullException()
    {
        // Arrange
        var sut = new ProfileService();
        // Act
        var e = Record.Exception(() =&gt; 
            sut.ChangeUsername(null!));
        // Assert
        var ex = Assert.IsType&lt;ArgumentNullException&gt;(e);
        Assert.Equal("username", ex.ParamName);
        Assert.StartsWith("Null", ex.Message);
    }
}</pre>
<p>The previous code does the<a id="_idIndexMarker374"/> preparation to pass <code>null</code> to our intended method. It<a id="_idIndexMarker375"/> executes the method and records <code>Exception</code> generated by the method.</p>
<p>In the end, we check whether we got an exception of the <code>ArgumentNullException</code> type having <code>username</code> as the argument and having the message starting with <code>Null</code>. </p>
<p>Before executing this, let’s reflect on what has happened so far.</p>
<h4>Naming your test class</h4>
<p>Right off the bat, the<a id="_idIndexMarker376"/> decision that I had to take was to think of my production code class name, because I needed it so I could append the <code>Tests</code> suffix to it and create my<a id="_idIndexMarker377"/> test class name (remember the convention: <code>ProductionCodeClass</code><strong class="bold">Tests</strong>). I am following <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) in my architecture, so I directly thought of this as a service class. Don’t worry about DDD terminology and how it fits with TDD for now, as DDD will have a dedicated chapter, <a href="B18370_07.xhtml#_idTextAnchor183"><em class="italic">Chapter 7</em></a>, <em class="italic"> A Pragmatic View of Domain-Driven Design</em>.</p>
<p>I didn’t give naming my class deep thought as I can always rename my classes with minimal effort. I landed on <code>ProfileService</code>, so I can call my unit test class <code>ProfileServiceTests</code>. Please note that I have not created <code>ProfileService</code> at this stage.</p>
<p class="callout-heading">Note</p>
<p class="callout">Some developers write meaningless test class names and then rename them after finishing the first unit test. Do what makes you more productive. This is not a rigid process.</p>
<h4>Unit test method naming</h4>
<p>The moment I wanted to<a id="_idIndexMarker378"/> write my test, I needed to think about what I am testing and what I should expect, following the <code>MethodName_Condition_Expectation</code> approach. So, I chose my method name to be <code>ChangeUsername</code> and the condition to check if <code>null</code>.</p>
<h4>Deciding your expectations upfront</h4>
<p>The expectation requires a bit <a id="_idIndexMarker379"/>of a pause and think. I am expecting whoever calls this method to have not sent <code>null</code>, as they have checked it on the UI or by any other means. So, I will be merciless and throw an exception if it doesn’t match my expectation and let the client deal with it.</p>
<p>The point here is that I directly thought from the client’s perspective and focused on the external behavior of my intended method.</p>
<h4>Making sure the test fails</h4>
<p>At this stage, you can see VS <a id="_idIndexMarker380"/>highlighting your code with squiggly lines, so it doesn’t take a genius to conclude that the code will not compile, as there is no production code written yet.</p>
<p>You have taken your first step in RGR, as you’ve got the red.</p>
<h4>Creating the production code class shell</h4>
<p>Let’s at least be able to <a id="_idIndexMarker381"/>compile to get some IntelliSense help from VS. So, in your <code>Uqs.Customer</code> project, modify <code>Class1.cs</code> to be <code>ProfileService.cs</code>, and the content will be something like this:</p>
<pre class="source-code">namespace Uqs.Customer;
public class ProfileService
{
}</pre>
<p>However, given that you will be doing this a lot, there are shortcuts for this. For example, if you have ReSharper, then it will give you the option to generate the production code based on your unit test. With VS, rather than renaming <code>Class1.cs</code> as in the previous step, just <a id="_idIndexMarker382"/>delete it, and follow these steps to do the same thing:</p>
<ul>
<li>Hover over <code>ProfileService()</code> where you have the squiggly line, and VS will show you a bulb. Expand the bulb and select <strong class="bold">Generate new type…</strong> as in the following figure:</li>
</ul>
<div><div><img alt="Figure 5.3 – Selecting the refactoring bulb " height="269" src="img/Figure_5.3_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Selecting the refactoring bulb</p>
<p class="callout-heading">Note</p>
<p class="callout">Sometimes the bulb takes time to appear; you can always use the <em class="italic">Ctrl</em> + <em class="italic">.</em> shortcut to force it to appear.</p>
<ul>
<li>When the dialog box appears, you can change its settings as follows:</li>
</ul>
<div><div><img alt="Figure 5.4 – Generate Type dialog box " height="682" src="img/Figure_5.4_B18370.jpg" width="660"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Generate Type dialog box</p>
<p>This way, you will get the<a id="_idIndexMarker383"/> same <code>ProfileService.cs</code> class generated as before.</p>
<p class="callout-heading">Note</p>
<p class="callout">Selecting the first option from the bulb menu, <strong class="bold">Generate class ‘ProfileService’ in a new file</strong>, doesn’t do the job, as VS will generate the file in the unit testing project, while you intend to generate it in the production code project.</p>
<p>Now that we have our class shell created, let’s continue our production code writing process.</p>
<h4>Creating the production code method shell</h4>
<p>To create the <code>ChangeUsername</code> method, hover <a id="_idIndexMarker384"/>over it, and select the bulb as follows:</p>
<div><div><img alt="Figure 5.5 – Generate method " height="510" src="img/Figure_5.5_B18370.jpg" width="1122"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Generate method</p>
<p>It will show you what is going <a id="_idIndexMarker385"/>to be generated in the display window. It is exactly what we want, so select <code>ProfileService</code> class:</p>
<pre class="source-code">public void ChangeUsername(string username)
{
    throw new NotImplementedException();
}</pre>
<p>This is the generated code. Alternatively, you can write the code yourself.</p>
<p class="callout-heading">Note</p>
<p class="callout">This is using C# 10, so not having <code>string?</code> (with a question mark after <em class="italic">string</em>) as the parameter warns the caller that this method doesn’t expect <code>null</code>. But, the caller can still force a <code>null</code>. Notice that the unit test did force a <code>null</code> in the <code>Act</code> section by having a bang sign after the <code>null</code>: <code>sut.ChangeUsername(null</code><code>)</code>.</p>
<p>Notice that the generated code has already added for you a <code>NotImplementedException</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Having <code>NotImplementedException</code> is a good practice to highlight to the reader that the code is not yet written, and to throw an exception when called by mistake in case you forgot about it and pushed the code to source control.</p>
<p>Now to the fun part, the <a id="_idIndexMarker386"/>implementation.</p>
<h4>Writing the null check logic</h4>
<p>All this is to write the <a id="_idIndexMarker387"/>following piece of logic:</p>
<pre class="source-code">public void ChangeUsername(string username)
{
    if (username is null)
    {
       throw new ArgumentNullException("username", "Null");
    }
}</pre>
<p>The first argument in the exception represents the parameter name, and the second represents the error message.</p>
<p>Run the unit tests from Test Explorer (<em class="italic">Ctrl</em> + <em class="italic">R</em>, <em class="italic">A</em>) and you should get the code compiling and all the tests passing (green).</p>
<h4>Refactoring</h4>
<p>I looked at the code <a id="_idIndexMarker388"/>after I’d written it and I thought it could be improved with the following:</p>
<p>Using a magic string inside the code to match my parameter name is not a good practice, as whenever I change the parameter name, the string doesn’t necessarily change with it. I will use the <code>nameof</code> keyword.</p>
<p>My refactored code would look as follows:</p>
<pre class="source-code">throw new ArgumentNullException(<strong class="bold">nameof</strong>(username), "Null");</pre>
<p>Now that I did these changes, I ran the tests again, and they passed.</p>
<p>While the size of the refactoring is small, and usually refactoring will be more sophisticated in a more streamlined example, this example serves as a good way to show you how you can implement an optional refactoring.</p>
<p>We have finished <a id="_idIndexMarker389"/>our first coding task! The first task is usually longer than the others as, in the first one, you will be building the shell and deciding about a few names. Our second task is going to be shorter.</p>
<h3>Coding task two – validate min and max lengths</h3>
<p>Again, without spending too much<a id="_idIndexMarker390"/> time thinking about the second thing to test, I thought of the length validation, according to the story<a id="_idIndexMarker391"/> where the length of the username should be between 8 and 12 characters included, so this is my second unit test to target this scenario:</p>
<pre class="source-code">[Theory]
[InlineData("AnameOf8", true)]
[InlineData("NameOfChar12", true)]
[InlineData("AnameOfChar13", false)]
[InlineData("NameOf7", false)]
[InlineData("", false)]
public void ChangeUsername_VariousLengthUsernames_
    ArgumentOutOfRangeExceptionIfInvalid
   (string username, bool isValid)
{
    // Arrange
    var sut = new ProfileService();
    // Act
    var e = Record.Exception(() =&gt;
        sut.ChangeUsernam(username));
    // Assert
    if (isValid)
    {
        Assert.NullI;
    }
    else
    {
        var ex =    
        Assert.IsType&lt;ArgumentOutOfRangeException&gt;(e);
        Assert.Equal("username", ex.ParamName);
        Assert.StartsWith("Length", ex.Message);
    }
}</pre>
<p>The previous code prepares many testing scenarios for valid and invalid-length usernames. It uses the <code>Theory</code> attribute to pass multiple scenarios to the unit test. In the end, we check if <a id="_idIndexMarker392"/>we got an exception of the <code>ArgumentOutOfRangeException</code> type. We branch with an <code>if</code> statement, as a valid username<a id="_idIndexMarker393"/> does not produce an exception, so we will get <code>null</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Some practitioners are against having any logic, such as an <code>if</code> statement, within a unit test. I am with the other school that having light logic that is clear and readable would reduce the amount of repetition in unit tests. Do what feels readable for you and your team.</p>
<p>This sample test data may come from who wrote the story (for example, the product owner, business analyst, or product manager), from you, or a combination of both.</p>
<h4>The red stage</h4>
<p>Run the unit tests, and this<a id="_idIndexMarker394"/> newly added unit test should fail as we have no implementation written yet.</p>
<h4>The green stage</h4>
<p>Add this logic to <a id="_idIndexMarker395"/>your method:</p>
<pre class="source-code">if (username.Length &lt; 8 || username.Length &gt; 12) 
{
    throw new ArgumentOutOfRangeException
        ("username","Length");
}</pre>
<p>Run the unit tests from Test Explorer (<em class="italic">Ctrl</em> + <em class="italic">R</em>, <em class="italic">A</em>) and you should get the code compiling and all the tests passing. We’ve reached green.</p>
<h4>The refactoring stage</h4>
<p>I looked at the code <a id="_idIndexMarker396"/>after I’d written it and I thought it could be improved with the following:</p>
<p>I am getting the length twice to compare it. Lucky for me, C# 8 introduced pattern matching that will lead to a more readable syntax (arguably). Also, C# might do some optimization magic to prevent the <code>Length</code> property from being executed twice. </p>
<p>My refactored code would look as follows:</p>
<pre class="source-code">if (username.Length <strong class="bold">is &lt; 8 or &gt; 12</strong>)
{
  throw new ArgumentOutOfRangeException(
    <strong class="bold">nameof</strong>(username), "Length");
}</pre>
<p>Now that I did these changes, I ran the tests again, and they passed.</p>
<h3>Coding task three – ensure alphanumerics and underscores only</h3>
<p>As per the <a id="_idIndexMarker397"/>requirements, we are only allowing alphanumerics and underscores, so let’s write the test for this:</p>
<pre class="source-code">[Theory]
[InlineData("Letter_123", true)]
[InlineData("!The_Start", false)]
[InlineData("InThe@Middle", false)]
[InlineData("WithDollar$", false)]
[InlineData("Space 123", false)]
public void
    ChangeUsername_InvalidCharValidation_
        ArgumentOutOfRangeException
       (string username, bool isValid)
{
    // Arrange
    var sut = new ProfileService();
    // Act
    var e = Record.Exception(() =&gt; 
        sut.ChangeUsername(username));
    // Assert
    if (isValid)
    {
        Assert.Null(e);
    }
    else
    {
        var ex = 
            Assert.IsType&lt;ArgumentOutOfRangeException&gt;(e);
        Assert.Equal("username", ex.ParamName);
        Assert.StartsWith("InvalidChar", ex.Message);
    }
}</pre>
<p>Run the test and it <a id="_idIndexMarker398"/>should fail except for the first test of <code>Letter_123</code>, which is a valid test. We want everything to fail to make sure we did not make a mistake. This is the output of Test Explorer:</p>
<div><div><img alt="Figure 5.6 – Test Explorer output for the valid letters test " height="347" src="img/Figure_5.6_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Test Explorer output for the valid letters test</p>
<p>You can follow one of these two solutions to make the test fail::</p>
<ol>
<li value="1">Go to the production code and write code that will make this test fail. I don’t personally like this approach, as I feel it is a purist approach, but there is nothing wrong with it.</li>
<li>Debug the code and see why it is passing without implementation. This is the approach that I took and it looks like this is a valid scenario anyway, so it should have passed. I can ignore the passed test and assume everything has failed.</li>
</ol>
<p>So, let’s write the proper implementation.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can see in all our tests that we are not asserting if there is an exception only. We are asserting the type of exception and two fields on the exception. This approach will help us catch the specific exception we are looking for and avoid catching other exceptions caused by something else.</p>
<p>The quickest way <a id="_idIndexMarker399"/>is to use a <em class="italic">regex</em> that will only allow alphanumerics and underscores. The fastest way is to search online for <code>alphanumeric and underscore only C# regex</code>. I found the regex on StackOverflow and it looks like this: <code>^[a-zA-Z0-9_]+$</code>.</p>
<p>Remember that my intention is to make this pass as soon as possible without thinking too much about the code or polishing it. This is the new code:</p>
<pre class="source-code">if (!Regex.Match(username, @"^[a-zA-Z0-9_]+$").Success)
{
    throw new ArgumentOutOfRangeException(nameof(username),
        "InvalidChar");
}</pre>
<p>Run the test again and it will pass.</p>
<p>However, the code suffers from a performance problem, as having an inline regex is slow. Let me optimize the performance and improve the readability. This is my whole class after refactoring:</p>
<pre class="source-code">using System.Text.RegularExpressions;
namespace Uqs.Customer;
public class ProfileService
{
    private const string ALPHANUMERIC_UNDERSCORE_REGEX = 
        @"^[a-zA-Z0-9_]+$";
    private static readonly Regex _formatRegex = new
    (ALPHANUMERIC_UNDERSCORE_REGEX, RegexOptions.Compiled);
    
    public void ChangeUsername(string username)
    {
        if (username is null)
        {
          throw new ArgumentNullException(nameof(username),
          "Null");
        }
        if (username.Length is &lt; 8 or &gt; 12) 
        {
          throw new ArgumentOutOfRangeException(
            nameof(username), "Length");
        }
        if (!_formatRegex.Match(username).Success)
        {
          throw new ArgumentOutOfRangeException(
            nameof(username), "InvalidChar");
        }
    }
}</pre>
<p>Run again after<a id="_idIndexMarker400"/> refactoring. In all honesty, the test failed for me as I missed copying a letter from the regex while refactoring. Running the test again showed me that my refactoring wasn’t right, so I fixed the code and tried again.</p>
<h3>Coding task four – checking if the username is already in use</h3>
<p>Obviously, checking if a <a id="_idIndexMarker401"/>username is already in use will require a trip to the database, and testing for that will require test doubles. Also, as you are doing IO operation (by accessing the DB), all your methods will be following the <code>async</code> <code>await</code> pattern.</p>
<p>This coding task and other coding tasks that are left for this feature to be completed will require database access, and I deliberately avoided this. I wanted this chapter to familiarize you with TDD without going through test doubles and more advanced topics. In <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, of this book, you will have dedicated chapters that will involve a mix of TDD, DDD, test doubles, and DBs. So, for now, we are going to stop here. Otherwise, how can I encourage you to continue reading if I explain everything here?</p>
<p>This ends our coding tasks for this chapter, and I hope so far you’ve got the TDD rhythm.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor123"/>Recap</h2>
<p>When starting a new feature, you need to think of this feature as a series of coding challenges. Every coding challenge will start with a unit test, similar to the following figure:</p>
<div><div><img alt="Figure 5.7 – Feature made of tasks, with a unit test targeting each task " height="297" src="img/Figure_5.7_B18370.jpg" width="483"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Feature made of tasks, with a unit test targeting each task</p>
<p>Sometimes, you don’t have a unit test project created yet, so you’ve seen how to create one. Sometimes, you add your unit tests to an existing unit testing project and you can immediately go ahead and start adding your tests.</p>
<p>You had to think upfront about how your client will interact with your production code and you designed everything according to the expectation of the client.</p>
<p>You followed the RGR pattern in adding each coding task and you’ve seen multiple examples of doing it.</p>
<p>More advanced scenarios are kept for <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor124"/>FAQs and criticism</h1>
<p>TDD is one of the most controversial topics in modern software development. You will find some developers swearing by it and others claiming it is useless.</p>
<p>I will try to objectively answer the questions and show you both views where relevant.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor125"/>Why do I need to do TDD? Can’t I just do unit testing?</h2>
<p>As you’ve gathered from the<a id="_idIndexMarker402"/> start of the chapter, TDD is a style of writing unit tests. So, yes, you can write unit tests without following the TDD style. In the next chapter, you will find the <em class="italic">first guideline</em> from the FIRSTHAND guidelines that will focus on the benefits of following the TDD style.</p>
<p>I found that some teams are reluctant to do TDD for various reasons. My recommendation is not to abandon unit tests in case your team is not inclined to follow TDD. Maybe if you start with unit testing, then the next evolution would be TDD. This would slow down the rate of change for some teams.</p>
<p>Did I say this before? Don’t abandon unit testing even if you are not following TDD.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor126"/>TDD feels unnatural to the software process!</h2>
<p>I trust that when you first learned programming, the concern was to understand basic programming constructs, such as <code>for</code> loops, functions, and OOP. Your concerns, or your tutor’s concerns, were not producing scalable high-quality software, because you just wanted a program that worked, with bugs here and there.</p>
<p>That worked while you were learning, and this is probably what you refer to as <em class="italic">natural</em> because you have done this from day one.</p>
<p>In the real world, the modern expectations<a id="_idIndexMarker403"/> from software are to be:</p>
<ul>
<li><strong class="bold">Scalable</strong>: Cloud-based solutions became the norm and microservices took control.</li>
<li><strong class="bold">Automated</strong>: The manual testing process turned out to be old-fashioned. A <em class="italic">developer in test</em> turned into a popular job title, and automated testing became the modern trend.</li>
<li><strong class="bold">DDD</strong>: Having objects interact with each other in a sophisticated manner. </li>
<li><strong class="bold">Release pipeline ready (CI/CD)</strong>: CI has a dedicated chapter in this book. In brief, your software should allow incremental feature addition and push to production every so often.</li>
</ul>
<p>The preceding scenarios are the concerns of today’s software developers and for that, you have to change your work strategy to the new real-life norm. This requires a paradigm shift in the way you write code, hence, the TDD norm of development.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor127"/>Doing TDD is going to slow us down!</h2>
<p>When starting a project, not <a id="_idIndexMarker404"/>doing any sort of testing would lead to faster results in the short term. Consider the following diagram that depicts this concept:</p>
<div><div><img alt="Figure 5.8 – TDD versus no testing concerning time and features " height="646" src="img/Figure_5.8_B18370.jpg" width="1156"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – TDD versus no testing concerning time and features</p>
<p>If you are starting from scratch building software with no dependencies and no features, it is easy to run doing no tests, maybe even having someone manually doing them. The project is small, manageable, and easy to change and deploy.</p>
<p>Test-free software will be fast to develop at the early stages until you start having a bunch of dependent features, where you change one and the other is broken! This is where test-backed software begins to shine, where adding a new feature has less probability of introducing a bug to an existing feature, as this should be caught by well-implemented tests. I have heard this phrase many times from product owners: <em class="italic">when we add a new feature, another unrelated area breaks!</em> They usually blame the developers or the tester who let this error pass. It is easy to think, for non-developers, that features are not related, but you and I know that this is not the case.</p>
<p>Obviously, after the <em class="italic">critical point</em>, the slowness in speed for non-tested software is due to the fact that the features are no longer manageable. The features are changing rapidly and the developers are moving to different areas or even leaving the project, and new developers are<a id="_idIndexMarker405"/> replacing them.</p>
<p>So, yes, TDD might slow you down, but this depends on where you are in the development process. If you passed the critical point in the preceding diagram, then you will start reaping the benefits of your investment.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor128"/>Is TDD relevant for a start-up?</h2>
<p>Developers involved in start-ups are usually stressed out and bombarded with feature requests. The company’s survival and funding might depend on the next set of features. Rarely the product owners are concerned about the long-term strategy, because why bother if the destiny of the start-up is risky? We will worry about tomorrow later.</p>
<p>If the start-up may fail before the critical point (in the preceding chart), then would it be worth investing in TDD? But what if they passed this critical point and have no unit tests? Maybe the company will rewrite their codebase when they have financial backers and customers. They will add unit tests, or maybe they won’t and they will struggle to add new features.</p>
<p>The start-up situation is complex; you can see this from the previous argument. The answer to this question depends on individual cases.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor129"/>I don’t like to do TDD, I like to do my code design first!</h2>
<p>If you create your classes' structure before writing your tests, <em class="italic">you are still doing TDD</em>. Remember that TDD is a set of best practices and having your own flavor doesn’t exclude you.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor130"/>Unit testing doesn’t test the real thing!</h2>
<p>This is a criticism that the TDD <a id="_idIndexMarker406"/>community seeks to actively improve. This is mainly related to the usage of test doubles.</p>
<p>Test doubles try to mimic the behavior of real objects, and the problem here is in the word <em class="italic">try</em>. The problem of mimicking a real object is that it relies on the developer’s best attempt to predict what the behavior of the real object is. This can be done in three ways:</p>
<ol>
<li value="1">Reading the documentation of the real object and trying to code something similar in a test double</li>
<li>Reading the source code, if available, and extracting its essence to build the test double</li>
<li>Doing a proof-of-concept sample to call the real object to check its behavior</li>
</ol>
<p>These ways take research and <a id="_idIndexMarker407"/>experience. Sometimes, the test double object doesn’t reflect the real object and that may lead to a wrong test and potentially to a bug. Let’s take this example of a third-party method:</p>
<pre class="source-code">public string LoadTextFile(string path){…}</pre>
<p>The method above loads a text file and returns it as a string. If we were to create a test double that involves this method, the question is what happens if the file doesn’t exist at the specified <code>path</code>?</p>
<ul>
<li>Is it going to return null?</li>
<li>Is it going to return an empty string?</li>
<li>Is it going to throw an exception? If so, what is the exception?</li>
</ul>
<p>The developer writing the test double will do the necessary due diligence to establish the answer to these questions, but they might get it wrong. The previous example was trivial, but you start getting more discrepancies between test doubles and real objects with more complex methods. The way to minimize this problem is to do the proper due diligence when creating the test doubles.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor131"/>I’ve heard about London-school TDD and classic-school TDD. What are they?</h2>
<p>There is a debate on the<a id="_idIndexMarker408"/> internet about which should we use and which is better. London-school TDD focuses on test doubles and it is more suited for business applications. Business applications are apps dealing with DB and UI. The classic-school TDD is more suitable for an <a id="_idIndexMarker409"/>algorithmic type of coding.</p>
<p>In this book, we only address the London-school TDD, as we are working on developing business applications.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor132"/>Why do some developers dislike unit testing and TDD?</h2>
<p>Unit testing adds time and <a id="_idIndexMarker410"/>complexity to product development, obviously for a good reason, nevertheless, it is still overhead. Unit testing has four major drawbacks:</p>
<ol>
<li value="1"><strong class="bold">Development time</strong>: Adding unit testing will multiply development time by multiple factors. Developers under pressure to deliver features as soon as possible will find unit testing overwhelming.</li>
<li><strong class="bold">Modifying existing features</strong>: It will require updating the unit tests as well. This can be minimized, but it is hard to eliminate without a major shift from unit testing to Sintegration testing, which is going to be discussed in the next section. </li>
<li><strong class="bold">Usage of test doubles</strong>: Some developers have strong feelings against using test doubles, as they tend to produce less realistic tests if the test doubles were not coded correctly.</li>
<li><strong class="bold">Unit testing is challenging</strong>: It demands advanced coding skills and coordination between team members, which requires synergy.</li>
</ol>
<p>Unit testing is not for the fainthearted. I sympathize with these views, but at the same time, I know that companies who are looking for a high-quality product should allocate more time for unit tests. <em class="italic">Drawbacks 2</em> and <em class="italic">3</em> can be addressed by better coding practices, which also require more effort.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor133"/>What is the relationship between TDD and Agile XP?</h2>
<p>There are many agile<a id="_idIndexMarker411"/> workflow flavors, the most popular <a id="_idIndexMarker412"/>ones are <strong class="bold">Agile Scrum</strong> and <strong class="bold">Agile Kanban</strong>. However, there is<a id="_idIndexMarker413"/> one that is less popular and it is software engineering-focused. It is <a id="_idIndexMarker414"/>called <strong class="bold">Agile XP</strong>, where <strong class="bold">XP</strong> stands for <strong class="bold">Extreme Programming</strong>.</p>
<p>XP puts unit testing in general, and TDD in particular, at the forefront of its practices, while the other popular agile practices do not go to this level of technical details. XP also tries to solve common software engineering problems, such as project management, documentation, and knowledge sharing.</p>
<h3>Code documentation via unit tests</h3>
<p>XP believes that the best way to<a id="_idIndexMarker415"/> document the code is by having unit tests attached to it versus having some document written elsewhere that would become quickly out of sync with the code. On the other hand, unit tests reflect the current state of the system, as they are regularly checked and updated.</p>
<p>The developer can understand the details of any business rule by looking into the unit tests rather than reading the documentation that may not go to that level of detail. </p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor134"/>Can a system survive without TDD?</h2>
<p>I would bounce the question back to the developer and ask, do you require the added quality of TDD? Do you agree with the fact that, as the software grows and as the team changes, you need a quality guard?</p>
<p>Yes, you can survive without TDD and unit tests, but the quality may suffer.</p>
<p>There are successful software systems rolled in corporates without unit tests. This is a fact. However, the teams behind them have a higher maintenance overhead and possibly slower release pace, and maybe they have dedicated staff for bug fixing, and possibly follow a waterfall SDLC. This is fine as long as the organization is happy with the quality and cost and they consider the system as <em class="italic">successful</em>.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor135"/>TDD with Sintegration tests</h1>
<p>One criticism of unit testing is <a id="_idIndexMarker416"/>that the unit test code will be tightly<a id="_idIndexMarker417"/> coupled with the implementation. Changing production code will have a rippling effect that will force updating, adding, and removing multiple unit tests.</p>
<p>These are ways to reduce coupling with unit tests, which are discussed in <a href="B18370_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, <em class="italic">The FIRSTHAND Guidelines of TDD</em>, in <em class="italic">The single-behavior guideline</em> section. However, the provided solutions do reduce coupling but don’t get rid of them completely.</p>
<p>On the other hand, integration<a id="_idIndexMarker418"/> tests have a dependency on the input and output of the tested functionality. If we are doing integration testing for an<a id="_idIndexMarker419"/> API, then we are concerned about what parameters we pass to the API and what we get back, that is, the input and output. This creates loose coupling with the code. Here is a reminder of how integration testing and unit testing operate:</p>
<div><div><img alt="Figure 5.9 – Integration tests versus unit tests " height="786" src="img/Figure_5.9_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Integration tests versus unit tests</p>
<p>As you can see, unit tests have to understand some details of the layers, while integration tests are interested in the input and output. This is why unit tests have more coupling to the implementation details.</p>
<p>Integration tests come with their own disadvantages, but Sintegration tests solve some of the drawbacks, as we discussed in <a href="B18370_04.xhtml#_idTextAnchor097"><em class="italic">Chapter 4</em></a>, <em class="italic">Real Unit Testing with Test Doubles</em>.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor136"/>Sintegration testing as an alternative to unit testing with TDD</h2>
<p>In recent years, Sintegration<a id="_idIndexMarker420"/> tests started competing with unit tests as a way to address these two issues of unit testing:</p>
<ul>
<li>Testing from the end-user perspective (the user might be a software client, not necessarily a human). This is <a id="_idIndexMarker421"/>also known as <strong class="bold">outside-in testing</strong>.</li>
<li>Having a loose coupling with the code.</li>
</ul>
<p>Applying TDD principles to Sintegration can work fine in the following ways:</p>
<ul>
<li>Test first can be applied in the same way it is applied with unit testing.</li>
<li>The red, green, refactor approach can work similarly to unit testing.</li>
<li>Design from the test perspective works in the same way as in unit testing.</li>
<li>Sintegration can use the same mocking framework to build fakes.</li>
<li>Sintegration can use the same AAA and method naming conventions.</li>
</ul>
<p>The main disadvantage is that, while unit testing gives fast feedback as it is focused on small SUTs, the Sintegration tests would not give as fast feedback to the developer. The reason is that they involve building multiple components for the whole feature before a Sintegration test can pass.</p>
<div><div><img alt="Figure 5.10 – Faster and slower feedback " height="457" src="img/Figure_5.10_B18370.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Faster and slower feedback</p>
<p>In the previous figure, you can see the unit tests are only operating on small pieces of code units, and while building these units, you can get the results of your unit test immediately. On the other <a id="_idIndexMarker422"/>hand, the feedback of the Sintegration test will be when the whole feature is implemented.</p>
<p>Consider this example. Let’s say that you are writing a feature to update a username. The feature would include, but not be limited to, the following units of code:</p>
<ul>
<li>Checks username length</li>
<li>Checks username illegal characters </li>
<li>Checks whether the user has the right to change the username</li>
<li>Checks whether the username is already in use</li>
<li>Gives the user an alternative view if they supply a used username</li>
<li>Saves username to the database</li>
<li>Confirms to the user that their username has changed</li>
</ul>
<p>While, in theory, each of these units of code can have multiple unit tests, and by the time each is coded you get the feedback, the Sintegration test needs to wait until the end of the feature so you can get feedback.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor137"/>Challenges of Sintegration testing</h2>
<p>Sintegration tests still rely on fakes, which are test doubles. Fakes are harder to build and maintain than doing mocks or stubs. The way to master building fakes requires experience in building mocks and stubs, as fakes are usually more complex and require advanced coding.</p>
<p>Also, creating fakes has a time <a id="_idIndexMarker423"/>overhead and will delay the start of the project as, before you can write your first Sintegration test, all your related fakes should be ready. For example, if your Sintegration test involves accessing a document database and cloud storage, you might need to create fakes for these components first, before you do any useful Sintegration test. </p>
<p>Practicing TDD with Sintegration requires more experience than practicing it with unit tests. However, the good news is that following the content of this book will help you progress, so when the time comes, and you, with your team, decide to focus on Sintegration, you will have gained the necessary experience to do so.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor138"/>Summary</h1>
<p>We’ve been through the basics and the principles around TDD, thus, I trust that at this point, you can confidently describe the process to a colleague. However, this chapter is the start of learning TDD, as the book will continue adding to your knowledge as you go.</p>
<p>I held my pen (okay, my keyboard) back from writing more advanced examples and stopped here for a smoother introduction. I hope that I explained the concept in a clear way and encouraged you to continue the book, as the upcoming chapters will have more pragmatic examples that will give you the experience to apply TDD in your own project.</p>
<p>In the next chapter, we will discuss the TDD guidelines and what I refer to as the FIRSTHAND guidelines. You will understand why testing first is important and what value it offers you. </p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor139"/>Further reading</h1>
<p>To learn more about the topics discussed in the chapter, you can refer to the following links:</p>
<ul>
<li><em class="italic">Martin Fowler on Test-Driven Development</em>: <a href="https://martinfowler.com/bliki/TestDrivenDevelopment.xhtml%0D">https://martinfowler.com/bliki/TestDrivenDevelopment.xhtml</a></li>
<li><em class="italic">Extreme Programming</em>: <a href="https://www.agilealliance.org/glossary/xp">https://www.agilealliance.org/glossary/xp</a></li>
<li><em class="italic">Classic TDD or “London School”?</em>: <a href="http://codemanship.co.uk/parlezuml/blog/?postid=987">http://codemanship.co.uk/parlezuml/blog/?postid=987</a></li>
</ul>
</div>
</div>
</body></html>