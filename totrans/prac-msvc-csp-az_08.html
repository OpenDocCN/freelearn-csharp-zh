<html><head></head><body>
		<div id="_idContainer104">
			<h1 id="_idParaDest-184" class="chapter-number"><a id="_idTextAnchor183"/>8</h1>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>CI/CD – Publishing with GitHub Actions</h1>
			<p>One of the features of microservices is their ability to continuously build and deploy services. In the previous chapters, we automatically created the infrastructure that’s used by our <span class="No-Break">service solution.</span></p>
			<p>In this chapter, we’ll continue to automatically build and update services and use protection rules before deploying applications to staging and production environments. While doing this, you’ll learn how to use feature flags with Azure <span class="No-Break">App Configuration.</span></p>
			<p>In this chapter, you’ll learn how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Use <span class="No-Break">GitHub Actions</span></li>
				<li>Build and test the application automatically after a <span class="No-Break">pull request</span></li>
				<li>Deploy the application to <span class="No-Break">test environments</span></li>
				<li>Use deployment protection rules before deploying the application to <span class="No-Break">production environments</span></li>
				<li>Publish <span class="No-Break">NuGet packages</span></li>
				<li>Use feature flags with modern <span class="No-Break">deployment patterns</span></li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Technical requirements</h1>
			<p>In this chapter, similar to the previous chapter, you’ll need an Azure subscription, the Azure CLI, the Azure Developer CLI, and .NET Aspire. You’ll also need your own GitHub repository so that you can store secrets, create environments, and run GitHub actions. These features are available in public repositories. If you create a private repository, the GitHub Team feature is required for creating environments (<span class="No-Break">see </span><a href="https://github.com/pricing"><span class="No-Break">https://github.com/pricing</span></a><span class="No-Break">).</span></p>
			<p>The source code for this chapter can be found in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure"><span class="No-Break">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">ch08</strong> folder contains the following projects, along with the output for <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.GameAPIs</strong>: The <strong class="source-inline">game-apis</strong> project we used in the previous chapter has been enhanced using <span class="No-Break">feature flags.</span></li>
				<li><strong class="source-inline">Codebreaker.Bot</strong>: This is the implementation of <strong class="source-inline">bot-service</strong>, which <span class="No-Break">plays games.</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs.KiotaClient</strong>: This is the client library we created in <a href="B21217_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> to be used <span class="No-Break">by clients.</span></li>
				<li><strong class="source-inline">Workflows</strong>: This folder is new. Here, you will find all the GitHub Actions workflows. However, these don’t become active until you copy them to the <strong class="source-inline">.github/workflows</strong> folder in <span class="No-Break">your repository.</span></li>
			</ul>
			<p>To work through the code with this chapter, you can use the <strong class="source-inline">service</strong> and <strong class="source-inline">bot</strong> projects from the previous chapter, as well as the <strong class="source-inline">Kiota</strong> library from <a href="B21217_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<p>For this chapter, you’ll need GitHub rights to run GitHub workflows, as well as to create and use GitHub environments with protection rules. The easiest way to do this is to create a public repository and copy just the code from this chapter into it. Create the <strong class="source-inline">src</strong> folder in this new repository and copy the source code to <span class="No-Break">this folder.</span></p>
			<p>Check out the README file in the <strong class="source-inline">ch08</strong> folder of this book’s GitHub repository for the <span class="No-Break">latest updates.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Preparing the solution using the Azure Developer CLI</h1>
			<p>First, let’s prepare<a id="_idIndexMarker536"/> the solution<a id="_idIndexMarker537"/> using the Azure Developer CLI. When initializing the solution, set the current folder to the root folder of the repository (not the folder of the solution file, as we <span class="No-Break">did previously):</span></p>
			<pre class="console">
azd init</pre>
			<p>Select <strong class="bold">Use code in the current directory</strong>, confirm that you wish to use <strong class="bold">Azure Container Apps</strong>, select <strong class="bold">Continue initializing my app</strong>, select <strong class="source-inline">bot</strong> and <strong class="source-inline">game-apis</strong> as projects to be exposed to the internet, and enter a new environment name – for example, <strong class="source-inline">codebreaker-08-dev</strong>. The generated <strong class="source-inline">azure.yaml</strong> file, which contains a link to the AppHost project file, needs to be committed<a id="_idIndexMarker538"/> to the source code repository. The generated <strong class="source-inline">.azure</strong> folder can contain<a id="_idIndexMarker539"/> secrets and has been – because of the generated <strong class="source-inline">.gitignore</strong> file – excluded from the source <span class="No-Break">code repository.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The reason to use the root directory of the <strong class="source-inline">azd pipeline</strong> command used later; At the time of writing, this command requires the <strong class="source-inline">.github/workflows</strong> directory to be in the same folder. Some changes are planned for a later release, so please check the README file for this chapter <span class="No-Break">for updates.</span></p>
			<p>Now, let’s deploy the resources <span class="No-Break">to Azure:</span></p>
			<pre class="console">
azd auth login
azd up</pre>
			<p>With <strong class="source-inline">azd up</strong>, the resources are deployed to your configured environment. Select the Azure subscription you wish to use and the Azure region where you want to deploy <span class="No-Break">the resources.</span></p>
			<p>The generated file, <strong class="source-inline">azure.yaml</strong>, references the AppHost project. The generated folder, <strong class="source-inline">.azure</strong> (which has been excluded from the source code repository because of possible secrets being stored), contains the current environment and a folder that has the same name as the environment. This folder contains the <strong class="source-inline">config.json</strong> file, which lists the publicly accessible service configuration, and the <strong class="source-inline">.env</strong> file, which contains variables referencing the created <span class="No-Break">Azure resources.</span></p>
			<p>Now, we are ready to use GitHub Actions. You can remove the Azure resources with <strong class="source-inline">azd down</strong> again since the complete infrastructure should have been deployed via <span class="No-Break">GitHub Actions:</span></p>
			<pre class="console">
azd down</pre>
			<p>Answer <strong class="source-inline">y</strong> to delete the resources, and then <strong class="source-inline">y</strong> again to permanently delete the resources that have soft <span class="No-Break">delete enabled.</span></p>
			<p>If you want to permanently delete resources, open the Azure portal (<a href="https://portal.azure.com">https://portal.azure.com</a>), go to <strong class="bold">Key Vault</strong>, and click on <strong class="bold">Manage deleted vaults</strong>. Key vaults that are deleted<a id="_idIndexMarker540"/> need to be purged<a id="_idIndexMarker541"/> so that you can create a resource with the same name again. Purge the key vaults. Similarly, check for Azure App Configuration services that need to <span class="No-Break">be purged.</span></p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Exploring GitHub Actions</h1>
			<p><strong class="bold">GitHub Actions</strong> is a feature of GitHub<a id="_idIndexMarker542"/> that you can use to automatically build, test, and deploy source code. GitHub Actions is a product that consists of <em class="italic">workflows</em>, <em class="italic">events</em>,  <em class="italic">jobs</em>, <em class="italic">actions</em>, <span class="No-Break">and </span><span class="No-Break"><em class="italic">runners</em></span><span class="No-Break">:</span></p>
			<ul>
				<li>A <strong class="bold">workflow</strong> is a YAML file stored in the <strong class="source-inline">.github/workflows</strong> folder<a id="_idIndexMarker543"/> of a repository. A workflow contains events <span class="No-Break">and jobs.</span></li>
				<li>An <strong class="bold">event</strong> specifies what triggers a<a id="_idIndexMarker544"/> workflow. When should the workflow <span class="No-Break">be started?</span></li>
				<li>A <strong class="bold">job</strong> consists of steps<a id="_idIndexMarker545"/> that are<a id="_idIndexMarker546"/> executed on a <span class="No-Break"><strong class="bold">runner</strong></span><span class="No-Break"> machine.</span></li>
				<li>A <strong class="bold">step</strong> can run a script or <span class="No-Break">an</span><span class="No-Break"><a id="_idIndexMarker547"/></span><span class="No-Break"> action.</span></li>
				<li>An <strong class="bold">action</strong> is a reusable GitHub extension<a id="_idIndexMarker548"/> that reduces the need to write scripts. Many of these reusable extensions can be used to build and <span class="No-Break">deploy applications.</span></li>
			</ul>
			<p>Now that we’ve set the foundation with these terms, let’s get into the details by creating a workflow using the <span class="No-Break">Azure portal.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>Creating a GitHub Actions workflow</h2>
			<p>There are several options<a id="_idIndexMarker549"/> to automatically create GitHub Actions workflows to deploy services to Microsoft Azure. Using the Azure portal, upon opening <strong class="bold">Container App</strong>, you can select <strong class="bold">Continuous deployment</strong> under <strong class="bold">Settings</strong>, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B21217_08_01.jpg" alt="Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal</p>
			<p>Using the Azure portal, you can select <a id="_idIndexMarker550"/>the GitHub repository, configure the Azure Container Registry you wish to use, and specify a <strong class="bold">Service Principal</strong> or a <strong class="bold">User-assigned Identity</strong> value to be used to publish <span class="No-Break">the project.</span></p>
			<p>Another option is to use<a id="_idIndexMarker551"/> Visual Studio. With Visual Studio, you can select a project (for example, <strong class="source-inline">game-apis</strong>) and select <strong class="bold">Publish…</strong> from the context menu. Upon adding a new publish profile, which you can do by selecting <strong class="bold">Azure</strong> | <strong class="bold">Azure Container Apps (Linux)</strong>, then selecting <strong class="bold">Container App</strong>, then Container Registry, the following <span class="No-Break">dialogue appears:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B21217_08_02.jpg" alt="Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio</p>
			<p>From this dialogue, you can directly publish to the Azure Container App or create a GitHub <span class="No-Break">Actions workflow.</span></p>
			<p>What’s common with these options is that you can publish service by service. Here, you used <strong class="source-inline">azd up</strong> to deploy the complete solution. Let’s have a look at what the Azure Developer CLI has to offer to create GitHub <span class="No-Break">Actions workflows.</span></p>
			<p>First, you need to create a <strong class="source-inline">.github</strong> folder in the root directory of the repository. Files that are used by specific GitHub functionality are stored in this folder. To this folder, add a <strong class="source-inline">workflows</strong> folder (<strong class="source-inline">.github/workflows</strong>). All the GitHub Actions workflows need to be stored within <span class="No-Break">this folder.</span></p>
			<p>Next, create the <strong class="source-inline">codebreaker-deploy.yml</strong> file. Now, copy the content of the <strong class="source-inline">azure-deploy.yaml</strong> file to this file. This file<a id="_idIndexMarker552"/> is from the <em class="italic">Azure-Samples</em> <span class="No-Break">repository: </span><a href="https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml"><span class="No-Break">https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml</span></a><span class="No-Break">.</span></p>
			<p>Now that we’ve created this workflow file, we can take a closer look <span class="No-Break">at it.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>Workflow file with YAML syntax</h2>
			<p>The syntax of<a id="_idIndexMarker553"/> workflow files<a id="_idIndexMarker554"/> makes use of <strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>, a recursive acronym) syntax. YAML<a id="_idIndexMarker555"/> is a data-oriented human-readable serialization language that uses indentation to specify what <span class="No-Break">belongs together.</span></p>
			<p>See <a href="https://yaml.org/">https://yaml.org/</a> for the YAML spec and<a id="_idIndexMarker556"/> links to libraries. You can check out the following cheat sheet for the <span class="No-Break">syntax: </span><a href="https://yaml.org/refcard.html"><span class="No-Break">https://yaml.org/refcard.html</span></a><span class="No-Break">.</span></p>
			<p>Let’s take a closer look at the workflow file while making some <span class="No-Break">small changes.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>Triggers</h2>
			<p>A workflow file starts<a id="_idIndexMarker557"/> with a name followed by <span class="No-Break">a trigger:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
name: Codebreaker backend workflow
<strong class="bold">on:</strong>
<strong class="bold">  workflow-dispatch:</strong>
<strong class="bold">  </strong><strong class="bold">push:</strong>
<strong class="bold">    branches:</strong>
<strong class="bold">      - main</strong>
<strong class="bold">    paths:</strong>
<strong class="bold">    - 'src/**'</strong></pre>
			<p>The name of a workflow is shown in the list of workflows. The <strong class="source-inline">on</strong> keyword specifies the events that trigger the workflow. GitHub offers many events that can be used with workflows. In this YAML file, the workflow is triggered with a <strong class="source-inline">workflow_dispatch</strong> event. This allows you to manually trigger the workflow. The second event, <strong class="source-inline">push</strong>, is triggered when changes are pushed to the repository. Because of the filtering that follows as part of <strong class="source-inline">push</strong>, the trigger is only done with a push to the <strong class="source-inline">main</strong> branch with changes specified by the files specified with <strong class="source-inline">path</strong>. If we don’t specify branches and path filters, the workflow<a id="_idIndexMarker558"/> will be triggered with every change in <span class="No-Break">this repository.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Permissions for secretless Azure federated credentials</h2>
			<p>The <strong class="source-inline">permissions</strong> section is a new construct<a id="_idIndexMarker559"/> that’s used with secretless Azure federated credentials to deploy <span class="No-Break">to Azure:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
<strong class="bold">permissions:</strong>
<strong class="bold">  id-token: write</strong>
<strong class="bold">  contents: read</strong></pre>
			<p>Permissions are used to access the identity token and the content. With <strong class="source-inline">contents read</strong>, the workflow has read access to the content of the repository. <strong class="source-inline">id-token write</strong> grants write access to the identity token. This token is used to authenticate GitHub <span class="No-Break">with Azure.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>Jobs and runners</h2>
			<p>In the workflow file, after<a id="_idIndexMarker560"/> the trigger<a id="_idIndexMarker561"/> is defined, the <strong class="source-inline">jobs</strong> keyword can be used to list one or more jobs that <span class="No-Break">should run:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
<strong class="bold">jobs</strong>:
  build-and-deploy:
    <strong class="bold">runs-on:</strong> <strong class="bold">ubuntu-latest</strong>
<strong class="bold">    env:</strong>
      AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}</pre>
			<p><strong class="source-inline">build-and-deploy</strong> is the name<a id="_idIndexMarker562"/> of the job. A job needs a runner. GitHub offers hosted runners to run jobs on Linux, Windows, and Mac. You can find out what runners<a id="_idIndexMarker563"/> are available, as well as their versions, at: <a href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources">https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources</a>. If other hardware or operating system versions are needed, a custom runner can <span class="No-Break">be used.</span></p>
			<p>Using the <strong class="source-inline">env</strong> keyword, environment<a id="_idIndexMarker564"/> variables are defined that can be used with the steps in this runner. The values for these variables come from the GitHub project variables using the <strong class="source-inline">vars</strong> object. The <strong class="source-inline">${{ }}</strong> expressions are evaluated during the execution of the workflow, and the values that are retrieved are added to the workflow at runtime. We will specify these values later using <strong class="source-inline">azd </strong><span class="No-Break"><strong class="source-inline">pipeline config</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>Steps and actions</h2>
			<p>A job consists<a id="_idIndexMarker565"/> of steps<a id="_idIndexMarker566"/> <span class="No-Break">and actions:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
<strong class="bold">    steps:</strong>
<strong class="bold">      - name: Checkout</strong>
<strong class="bold">        uses: actions/checkout@v4</strong>
<strong class="bold">      - name: Install azd</strong>
<strong class="bold">        uses: Azure/setup-azd@v1.0.0</strong>
<strong class="bold">      - name: Install .NET Aspire workload</strong>
<strong class="bold">        run: dotnet workload install aspire</strong>
# Code removed for brevity</pre>
			<p>The first step consists<a id="_idIndexMarker567"/> of an action, <strong class="source-inline">actions/checkout@v4</strong>. This action checks out the source<a id="_idIndexMarker568"/> code to ensure it’s available alongside the runner. <strong class="source-inline">@v4</strong> defines the version number to be used for this GitHub action. Actions are available via GitHub Marketplace: <a href="https://github.com/marketplace?category=&amp;query=&amp;type=actions">https://github.com/marketplace?category=&amp;query=&amp;type=actions</a>. Every action has documentation that you can read to learn which parameters are available. <strong class="source-inline">actions/checkout</strong>, for example, allows you to include submodules at checkout and also allows you to check out source code from <span class="No-Break">other repositories.</span></p>
			<p>The next action installs the Azure Developer CLI <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Azure/setup-azd</strong></span><span class="No-Break">.</span></p>
			<p>.NET is installed with the hosted runner, but we need to make sure we install the .NET Aspire workload. This can be done using a one-line script specified with the <strong class="source-inline">run</strong> field – that is, <strong class="source-inline">dotnet workload </strong><span class="No-Break"><strong class="source-inline">install aspire</strong></span><span class="No-Break">.</span></p>
			<p> Next, the <strong class="source-inline">azd auth</strong> command <span class="No-Break">is used:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
      - name: Log in with Azure (Federated Credentials)
        <strong class="bold">if: ${{ env.AZURE_CLIENT_ID != '' }}</strong>
  <strong class="bold">      run: |</strong>
<strong class="bold">          </strong><strong class="bold">azd auth login `</strong>
<strong class="bold">            --client-id "$Env:AZURE_CLIENT_ID" `</strong>
<strong class="bold">            --federated-credential-provider "github" `</strong>
<strong class="bold">            --tenant-id «$Env:AZURE_TENANT_ID»</strong>
<strong class="bold">        shell: pwsh</strong></pre>
			<p>Here, we have the step<a id="_idIndexMarker569"/> where the permissions we defined earlier are needed: authentication<a id="_idIndexMarker570"/> with Federated Identity. <strong class="source-inline">if</strong> specifies that this step is conditional – only if <strong class="source-inline">AZURE_CLIENT_ID</strong> is not empty. We’ll have another option for authentication if <strong class="source-inline">AZURE_CLIENT_ID</strong> is empty with the following step. This step is not using a GitHub action; instead, the <strong class="source-inline">run</strong> field defines that it will invoke a multi-line script. Using multiple lines is specified by <strong class="source-inline">|</strong> at the end of the line. PowerShell (which is specified with the <strong class="source-inline">shell</strong> field) uses the backtick (<strong class="source-inline">`</strong>) as a line <span class="No-Break">continuation character.</span></p>
			<p>The command that’s running with PowerShell is <strong class="source-inline">azd auth login</strong>, passing a few parameters. <strong class="source-inline">--client-id</strong> uses the identifier of the service principal, which has the necessary Azure permissions. <strong class="source-inline">--federated-credential-provider</strong> uses GitHub for federated authentication. Federated authentication allows you to use GitHub identities to access resources on Azure. <strong class="source-inline">--tenant-id</strong> specifies the Azure directory identifier that is used with <span class="No-Break">Azure authentication.</span></p>
			<p>The next step uses another conditional script if the <strong class="source-inline">AZURE_CREDENTIALS</strong> variable <span class="No-Break">is set:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
- name: Log in with Azure (Client Credentials)
   if: ${{ env.AZURE_CREDENTIALS != '' }}
   run: |
<strong class="bold">     $info = $Env:AZURE_CREDENTIALS | ConvertFrom-Json -AsHashtable;</strong>
<strong class="bold">     Write-Host "::add-mask::$($info.clientSecret)"</strong>
<strong class="bold">     azd auth login `</strong>
<strong class="bold">       --client-id "$($info.clientId)" `</strong>
<strong class="bold">       --client-secret "$($info.clientSecret)" `</strong>
<strong class="bold">       --tenant-id "$($info.tenantId)"</strong>
   shell: pwsh
   env:
<strong class="bold">     AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}</strong></pre>
			<p>The <strong class="source-inline">AZURE_CREDENTIALS</strong> environment<a id="_idIndexMarker571"/> variable is stored as a JSON script. This is converted <a id="_idIndexMarker572"/>into a PowerShell hash table variable named <strong class="source-inline">info</strong> and allows us to access each part of the JSON content, such as the client ID, the client secret, and the tenant ID. These parts are then passed to the <strong class="source-inline">azd auth login</strong> command. <strong class="source-inline">AZURE_CREDENTIALS</strong> itself is retrieved using <strong class="source-inline">secrets.AZURE_CREDENTIALS</strong>. Secrets are stored encrypted alongside the GitHub project and are not part of the source code of the repository. We’ll configure these secrets in the <span class="No-Break">next section.</span></p>
			<p>Finally, two one-line commands <span class="No-Break">are invoked:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-deploy.yml</p>
			<pre class="source-code">
      - name: Provision Infrastructure
<strong class="bold">        run: azd provision --no-prompt</strong>
      - name: Deploy Application
<strong class="bold">        run: azd deploy --no-prompt</strong></pre>
			<p>The first command, <strong class="source-inline">azd provision</strong>, creates the Azure infrastructure, as specified by the ap<strong class="source-inline">p-model</strong> definition of the AppHost project. If the infrastructure already exists, it is checked if a change is needed, and only updates are applied. <strong class="source-inline">azd deploy</strong> then deploys the services to Azure, thus building the Docker images, publishing them to Azure Container Registry, and creating various Azure Container Apps with the created images. The <strong class="source-inline">--no-prompt</strong> option doesn’t wait for the user to interact with this command and just <span class="No-Break">uses defaults.</span></p>
			<p>The <strong class="source-inline">azd up</strong> command we used previously used <strong class="source-inline">azd provision</strong> and <span class="No-Break"><strong class="source-inline">azd deploy</strong></span><span class="No-Break">.</span></p>
			<p>Create the <strong class="source-inline">.github/workflows</strong> folder in your<a id="_idIndexMarker573"/> repository and copy<a id="_idIndexMarker574"/> the <strong class="source-inline">codebreaker-deploy.yml</strong> workflow file to <span class="No-Break">this folder.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>GitHub variables and secrets</h2>
			<p>Secrets shouldn’t be part of the<a id="_idIndexMarker575"/> source code, and the workflow file is stored<a id="_idIndexMarker576"/> with the source code. GitHub has a vault where you can store secrets outside of the source code repository. Using <strong class="source-inline">azd</strong>, secrets and variables can automatically be configured <span class="No-Break">with GitHub.</span></p>
			<p>The <strong class="source-inline">azd pipeline</strong> command supports this. Start by having the current directory set to the root folder of the repository. <strong class="source-inline">azd pipeline</strong> needs the .<strong class="source-inline">github/workflows</strong> folder to be in the same directory where you run <strong class="source-inline">azd pipeline</strong>; you must also have the .NET Aspire application initialized in this directory. This requirement might change – check the README file in this chapter’s GitHub repository for <span class="No-Break">more information.</span></p>
			<p>Run the following command to configure <span class="No-Break">the pipeline:</span></p>
			<pre class="console">
azd auth login
azd pipeline config --auth-type federated --principal-name github-codebreaker-dev</pre>
			<p><strong class="source-inline">azd pipeline config</strong> uses the Azure subscription you configured earlier to create GitHub variables and secrets, as well as create an Azure app registration, which allows GitHub to deploy to Azure. By default, the principal name created starts with <strong class="source-inline">az-dev-</strong> and contains the date and time it was created. Here, we specify the principal name as <strong class="source-inline">github-codebreaker-dev</strong>. Repository variables for <strong class="source-inline">AZURE_ENV_NAME</strong>, <strong class="source-inline">AZURE_LOCATION</strong>, <strong class="source-inline">AZURE_SUBSCRIPTION_ID</strong>, <strong class="source-inline">AZURE_TENANT_ID</strong>, and <strong class="source-inline">AZURE_CLIENT_ID</strong> <span class="No-Break">are created.</span></p>
			<p>Open the GitHub repository in your browser. In the portal, click <strong class="bold">Settings</strong>. With the <strong class="bold">Security</strong> category open in the left pane, you’ll see <strong class="bold">Secrets and variables</strong>. In this sub-category, when you open <strong class="bold">Actions</strong>, you’ll see the <strong class="bold">Actions secrets and variables</strong> page, which contains <strong class="bold">Repository secrets</strong>. This is shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B21217_08_03.jpg" alt="Figure 8.3 – Repository secrets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Repository secrets</p>
			<p>The <strong class="source-inline">AZD_INITIAL_ENVIRONMENT_CONFIG</strong> secret contains the content of the <strong class="source-inline">.azure/[environment]/config.json</strong> file. This file contains a list of publicly accessible services and is read by <strong class="source-inline">azd deploy</strong> to configure the Ingress controller. The needed environment name, location, subscription ID, and other details are stored within <span class="No-Break">repository variables.</span></p>
			<p>Because <strong class="source-inline">azd pipeline config</strong> creates Federated Identity credentials for GitHub, secrets to access Azure are not required with the default (federated) configuration. Instead of using a value of <strong class="source-inline">federated</strong>, you can pass <strong class="source-inline">client-credentials</strong>, which configures credentials to be stored within a <span class="No-Break">repository secret.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B21217_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, you understood how to separate secrets and variables with Azure Container Apps, and then with Azure App Configuration and Key Vault in <a href="B21217_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. The reason for this separation is similar here using <span class="No-Break">GitHub Actions.</span></p>
			<p>GitHub allows you to specify<a id="_idIndexMarker577"/> different levels where you can store secrets <a id="_idIndexMarker578"/>and variables. The organization level can be used when secrets should be shared across different repositories within the organization. Repository secrets are stored within the scope of the repository and are not available from other repositories. Environment secrets are scoped within deployment environments. These will be covered later in the <em class="italic">Using deployment </em><span class="No-Break"><em class="italic">environments</em></span><span class="No-Break"> section.</span></p>
			<p>Run the GitHub Actions workflow now – either by pushing a source code update to the GitHub repository or by running the workflow explicitly from the GitHub portal. You’ll see that the workflow is in progress before <span class="No-Break">it completes:</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B21217_08_04.jpg" alt="Figure 8.4 – Workflow in progress"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Workflow in progress</p>
			<p>At this stage, you might need to wait until an agent is available. When it’s in progress, you can click on it to see progress information about what’s going on. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.5</em> shows the steps that appear when the workflow is <span class="No-Break">completed successfully:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B21217_08_05.jpg" alt="Figure 8.5 – Workflow steps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Workflow steps</p>
			<p>Upon checking the logs, you’ll see all the steps that have been completed. In the preceding figure, you can see that federated credentials have been used, and not the client credentials. You can click on each of these steps to find <span class="No-Break">more details.</span></p>
			<p>When creating a GitHub Actions<a id="_idIndexMarker579"/> workflow with <strong class="source-inline">azd</strong>, just a few statements are required<a id="_idIndexMarker580"/> to deploy the complete solution. With every source code change<a id="_idIndexMarker581"/> that is not pushed to the main<a id="_idIndexMarker582"/> branch, the deployment <span class="No-Break">is updated.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>Getting more with GitHub Actions</h2>
			<p>It’s great to have an easy way to create a GitHub action using integration from Visual Studio, the Azure portal, or via the <strong class="source-inline">azd pipeline</strong> command. <strong class="source-inline">azd pipeline</strong> is great for deploying a complete solution, but because of its early development stages, some features are missing. With our solution, some more features are required; we’ll customize <span class="No-Break">these manually.</span></p>
			<p>Let’s have a look at some of the goals<a id="_idIndexMarker583"/> <span class="No-Break">we have:</span></p>
			<ul>
				<li>All the services should be built, tested, <span class="No-Break">and deployed</span></li>
				<li>NuGet packages should be published to GitHub Packages and made <span class="No-Break">available there</span></li>
				<li>We don’t want to repeat code, so we’ll create <span class="No-Break">reusable workflows</span></li>
				<li>Deploying should be done to multiple environments, such as development, staging, <span class="No-Break">and production</span></li>
			</ul>
			<p>Let’s get into <span class="No-Break">the details.</span></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor196"/>Enhancing GitHub Actions workflows</h1>
			<p>To build our services, we must<a id="_idIndexMarker584"/> create reusable workflows. First, let’s configure the variables and secrets that are needed by <span class="No-Break">these workflows.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Configuring variables and secrets</h2>
			<p>We’ve configured<a id="_idIndexMarker585"/> variables <a id="_idIndexMarker586"/>and secrets using <strong class="source-inline">az pipeline config</strong> previously. if you need more customization, you might need to set these values yourself. You’ve already seen how to access the repository secrets and variables with the GitHub portal. Now, let’s add these <span class="No-Break">to secrets:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">AZURE_TENANT_ID</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">AZURE_SUBSCRIPTION_ID</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">AZURE_CLIENT_ID</strong></span></li>
			</ul>
			<p>To get the tenant ID, use the <span class="No-Break">Azure CLI:</span></p>
			<pre class="console">
az account show --query tenantId -o tsv</pre>
			<p><strong class="source-inline">az account show</strong> returns JSON information about the logged-in Azure account. With the JSONPath <strong class="source-inline">--query tenantId</strong> query, the Microsoft Entra tenant ID is returned. <strong class="source-inline">-o tsv</strong> returns the result in tab-separated values. Set the returned value with the <strong class="source-inline">AZURE_TENANT_ID</strong> <span class="No-Break">repository secret.</span></p>
			<p>The subscription ID can also be listed with <strong class="source-inline">az </strong><span class="No-Break"><strong class="source-inline">account show</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
az account show --query id -o tsv</pre>
			<p>Here, <strong class="source-inline">id</strong> contains the subscription ID. Set this value with the <strong class="source-inline">AZURE_SUBSCRIPTION_ID</strong> <span class="No-Break">repository secret.</span></p>
			<p>Earlier in this chapter, we used<a id="_idIndexMarker587"/> the <strong class="source-inline">azd pipeline</strong> command to create<a id="_idIndexMarker588"/> an account for federated authentication. Let’s check out this account within the Microsoft Entra portal: <a href="https://entra.microsoft.com">https://entra.microsoft.com</a>. After logging in, from the left bar, within the <strong class="bold">Identity</strong> category, open <strong class="bold">Applications</strong> and click <strong class="bold">App registrations</strong>. Select the <strong class="bold">All applications</strong> tag. Look for an app registration with a display name starting with <strong class="source-inline">github-codebreaker-dev</strong>. If you didn’t supply a name, <strong class="source-inline">azd</strong> creates an account starting with <strong class="source-inline">az-dev</strong>. Open this account and, within the <strong class="bold">Manage</strong> category, click <strong class="bold">Certificates &amp; secrets</strong>. Open <strong class="bold">Federated credentials</strong>. You will see credentials named based on the GitHub organization and the repository, with entity types of <strong class="bold">Pull request</strong> and <strong class="bold">Branch</strong>. A predefined federated credential scenario for GitHub actions deploying Azure resources will <span class="No-Break">be available.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To create a new app registration with federated credentials using the Azure portal, the Azure CLI, or Azure PowerShell, check<a id="_idIndexMarker589"/> out the following <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials"><span class="No-Break">https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials</span></a><span class="No-Break">.</span></p>
			<p>Copy the value for <strong class="bold">Application (client) ID</strong> and set this identifier<a id="_idIndexMarker590"/> with the <strong class="source-inline">AZURE_CLIENT_ID</strong> <span class="No-Break">repository</span><span class="No-Break"><a id="_idIndexMarker591"/></span><span class="No-Break"> secret.</span></p>
			<p>Now that we’ve specified the necessary secrets and variables, let’s get back to <span class="No-Break">creating workflows.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Running unit tests</h2>
			<p>When triggering the workflow<a id="_idIndexMarker592"/> by updating the source<a id="_idIndexMarker593"/> code of a service, the first step should be to run unit tests. Let’s create a <span class="No-Break">reusable workflow:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/shared-test.yml</p>
			<pre class="source-code">
name: Shared workflow to build and test a .NET project
<strong class="bold">on:</strong>
<strong class="bold">  workflow_call:</strong>
<strong class="bold">    inputs:</strong>
<strong class="bold">      project-name:</strong>
        description: 'The name of the project'
        required: true
        type: string
<strong class="bold">      solution-path:</strong>
        description: 'The solution file of the project to build and run tests'
        required: true
        type: string
<strong class="bold">      dotnet-version:</strong>
        description: 'The version of .NET to use'
        required: false
        type: string
<strong class="bold">        default: '8.0.x'</strong></pre>
			<p>A reusable workflow is triggered by calling this workflow. The trigger specified by <strong class="source-inline">on</strong> uses the <strong class="source-inline">workflow_call</strong> keyword. At this point, the input values that are needed are also defined. With this workflow, <strong class="source-inline">project-name</strong> and <strong class="source-inline">solution-path</strong> are required input values. The <strong class="source-inline">dotnet-version</strong> input value has a default value assigned and is <span class="No-Break">not required.</span></p>
			<p>After the trigger and the input<a id="_idIndexMarker594"/> values, a job with a runner<a id="_idIndexMarker595"/> is defined, followed by the steps to <span class="No-Break">be invoked:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">work flows/shared-test.yml</p>
			<pre class="source-code">
jobs:
  run-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout to the branch
        uses: <strong class="bold">actions/checkout@v4</strong>
      - name: Setup .NET
        uses: <strong class="bold">actions/setup-dotnet@v4</strong>
        with:
          dotnet-version: ${{ inputs.dotnet-version }}
      - name: Install .NET Aspire workload
        run: dotnet workload install aspire
      - name: Restore NuGet Packages
<strong class="bold">        run: dotnet restore ${{ inputs.solution-path }}</strong>
      - name: Run unit tests
<strong class="bold">        run: dotnet test --logger trx --results-directory "TestResults-${{ inputs.project-name}}" --no-restore ${{ inputs.solution-path }}</strong>
      - name: Upload the test results
<strong class="bold">        uses: actions/upload-artifact@v4</strong>
<strong class="bold">        with:</strong>
<strong class="bold">          name: test-results-${{ inputs.project-name}}</strong>
          path: TestResults-${{ inputs.project-name}}
      <strong class="bold">  if: always()</strong></pre>
			<p>After checking out the source code with the <strong class="source-inline">actions/checkout</strong> action, the .NET SDK is installed using <strong class="source-inline">actions/setup-dotnet</strong>. Here, the .NET version is retrieved from the input values. As the .NET SDK is now installed with this runner, the .NET CLI can be used. In the next step, instead of invoking an action, the <strong class="source-inline">run</strong> keyword is used to execute the <strong class="source-inline">dotnet restore</strong> command. <strong class="source-inline">dotnet restore</strong> retrieves the NuGet packages of the referenced solution. If this fails, there’s no need to continue with the next step. The next step runs the unit tests using <strong class="source-inline">dotnet test</strong>.  The <strong class="source-inline">--logger</strong> option specifies to write log output<a id="_idIndexMarker596"/> with the TRX logger format – a Visual Studio <strong class="bold">Test Results File</strong> (<strong class="bold">TRX</strong>). This result file is then uploaded with the <strong class="source-inline">actions/upload-artifact</strong> action. Artifacts<a id="_idIndexMarker597"/> can be used to share data between runners and also downloaded with workflow runs. By default, a step only runs if the previous<a id="_idIndexMarker598"/> step succeeds. In this case, we want to download<a id="_idIndexMarker599"/> the test result from the artifacts if the test fails – that’s why <strong class="source-inline">if: always()</strong> was added on uploading <span class="No-Break">the artifact.</span></p>
			<p>This shared workflow is started from the <span class="No-Break"><strong class="source-inline">codebreaker-test.yml</strong></span><span class="No-Break"> workflow:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-test.yml</p>
			<pre class="source-code">
# code removed for brevity
<strong class="bold">jobs:</strong>
<strong class="bold">  build-and-test:</strong>
<strong class="bold">    uses: ./.github/workflows/shared-test.yml</strong>
<strong class="bold">    with:</strong>
<strong class="bold">      project-name: 'Codebreaker-Backend'</strong>
<strong class="bold">      solution-path: 'src/Chapter08.sln'</strong></pre>
			<p>The job that’s been defined uses the name <strong class="source-inline">build-and-test</strong>, references the shared workflow file with the <strong class="source-inline">uses</strong> keyword, and sets the input values using the <span class="No-Break"><strong class="source-inline">with</strong></span><span class="No-Break"> keyword.</span></p>
			<p>This workflow is triggered when a change<a id="_idIndexMarker600"/> is made in the specified<a id="_idIndexMarker601"/> files and folders in the main branch, explicitly. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.6</em> shows the result of running <span class="No-Break">the workflow:</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B21217_08_06.jpg" alt="Figure 8.6 – Running the workflow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Running the workflow</p>
			<p>With this result, you can see the downloadable<a id="_idIndexMarker602"/> artifacts for viewing<a id="_idIndexMarker603"/> the <span class="No-Break">test results.</span></p>
			<p>Now that we’ve run the unit tests, let’s combine this with the previously created build and <span class="No-Break">deploy job.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Running multiple jobs</h2>
			<p>To run multiple jobs <a id="_idIndexMarker604"/>from one workflow, we’ll need<a id="_idIndexMarker605"/> to create a shared workflow from the <span class="No-Break">deployment project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/shared-deploy.yml</p>
			<pre class="source-code">
name: Shared workflow to deploy a .NET Aspire project
<strong class="bold">on:</strong>
<strong class="bold">  workflow_call:</strong>
    inputs:
# code removed for brevity
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true</pre>
			<p>Because this is a shared workflow that’s triggered from other workflows, <strong class="source-inline">on</strong> specifies <strong class="source-inline">workflow_call</strong>. This workflow is very similar to the previously created deployment workflow, so the code for this hasn’t been repeated here. Check out the source code repository for the complete workflow. What’s important here is that not only inputs are passed from the calling workflow, but also secret information. These secrets are referenced using the <strong class="source-inline">$ {{ secrets.&lt;secret&gt; }}</strong> <span class="No-Break">expression.</span></p>
			<p>The <strong class="source-inline">codebreaker-testanddeploy.yml</strong> workflow<a id="_idIndexMarker606"/> invokes both <span class="No-Break">shared</span><span class="No-Break"><a id="_idIndexMarker607"/></span><span class="No-Break"> workflows:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker-testanddeploy.yml</p>
			<pre class="source-code">
# code removed for brevity
jobs:
  <strong class="bold">build-and-test:</strong>
    uses: ./.github/workflows/shared-test.yml
    with:
      project-name: Codebreaker-Backend
      solution-path: src/Chapter08.sln
<strong class="bold">  build-and-deploy:</strong>
<strong class="bold">    needs:  build-and-test</strong>
<strong class="bold">    uses: ./.github/workflows/shared-deploy.yml</strong>
<strong class="bold">    with:</strong>
<strong class="bold">      environment-name: ${{ vars.AZURE_ENV_NAME }}</strong>
<strong class="bold">      location: ${{ vars.AZURE_LOCATION }}</strong>
<strong class="bold">    secrets:</strong>
<strong class="bold">      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}</strong>
<strong class="bold">      </strong><strong class="bold">AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}</strong>
<strong class="bold">      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}</strong></pre>
			<p>Using the <strong class="source-inline">needs</strong> keyword, the <strong class="source-inline">build-and-deploy</strong> job is defined<a id="_idIndexMarker608"/> to require the <strong class="source-inline">build-and-test</strong> job to run<a id="_idIndexMarker609"/> beforehand. If the <strong class="source-inline">build-and-test</strong> job does not succeed, <strong class="source-inline">build-and-deploy</strong> will not run. Secrets need to be forwarded to the shared workflow. With secrets, you can specify every secret to pass with the calling workflow, or to share all the secrets available from the calling workflow with the called workflow. Inheriting these secrets is required when using environments (as shown in a <span class="No-Break">later section).</span></p>
			<p>When you run the workflow at this stage, you’ll see a graphical view of how the two jobs are connected, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B21217_08_07.jpg" alt="Figure 8.7 – Running multiple jobs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Running multiple jobs</p>
			<p>Both jobs were<a id="_idIndexMarker610"/> <span class="No-Break">completed </span><span class="No-Break"><a id="_idIndexMarker611"/></span><span class="No-Break">successfully.</span></p>
			<p>Next, we’ll dive into environments that can be used from multiple jobs to, for example, deploy the solution to staging and <span class="No-Break">production environments.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Using deployment environments</h1>
			<p>When running the solution<a id="_idIndexMarker612"/> locally on the developer system, projects can be built and debugged locally. Just a few services, such as App Insights and Key Vault, need to be run in the Azure cloud environment. This is done automatically by .NET Aspire, which provisions <strong class="source-inline">app-model</strong> in the AppHost project. You just need to make sure you configure <strong class="source-inline">Azure:SubscriptionId</strong> with the user secrets. To run and test the application while it’s running within Azure, and to try out different Azure offerings, every developer of the team can use <strong class="source-inline">azd init</strong> and <strong class="source-inline">azd up</strong> to have all the services running in the personal Azure subscription that’s part of the Visual Studio Professional and <span class="No-Break">Enterprise offerings.</span></p>
			<p>It’s also useful to use a shared environment where the services of the solution running in Microsoft Azure are used together by the developer team. One example is for client application developers to use a new daily build<a id="_idIndexMarker613"/> to test the client applications accessing the services in the cloud. This is the <span class="No-Break"><em class="italic">development environment</em></span><span class="No-Break">.</span></p>
			<p>To run load <a id="_idIndexMarker614"/>tests, it’s useful to have <em class="italic">test environments</em>. Such environments can be created on demand before running the load test. They can be deleted again after the load tests are finished and the results have been documented. See <a href="B21217_10.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic">Chapter 10</em></span></a> for more details on <span class="No-Break">running tests.</span></p>
			<p>Before moving into<a id="_idIndexMarker615"/> production, <em class="italic">staging environments</em>, which mirror the <em class="italic">production environments</em>, are used to make final<a id="_idIndexMarker616"/> tests if the application is behaving <span class="No-Break">as expected.</span></p>
			<p>We can deploy the solution<a id="_idIndexMarker617"/> to all these environments by using GitHub Actions. However, some of these environments are more restrictive, which means that deployments can only be done when it’s been verified that the solution runs successfully with the <span class="No-Break">defined constraints.</span></p>
			<p>Let’s take a <span class="No-Break">closer look.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Create environments with the Azure Developer CLI</h2>
			<p>To create environments<a id="_idIndexMarker618"/> with the Azure Developer<a id="_idIndexMarker619"/> CLI, you can use the <strong class="source-inline">azd env </strong><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
azd env new codebreaker-08-prod</pre>
			<p>This not only creates a new environment named <strong class="source-inline">codebreaker-08-prod</strong> but also sets the current environment to this new one. To show all environments that have been configured, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
azd env list</pre>
			<p>This shows all the environments that have been configured, as well as the currently selected environment. To change the current one, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
azd env select codebreaker-dev</pre>
			<p>Creating an environment with <strong class="source-inline">azd</strong> creates the <strong class="source-inline">.azure</strong> subdirectory. Upon opening this folder, you will see the <strong class="source-inline">config.json</strong> file. This shows the currently <span class="No-Break">selected environment.</span></p>
			<p>With every environment that’s created, a subdirectory containing the name of the environment is created that contains values for the resource group, the Azure region, and the Azure subscription ID. When you’re creating a new environment, you can change the subscription with the <strong class="source-inline">--subscription</strong> option. To change the location of the resources, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">--location</strong></span><span class="No-Break">.</span></p>
			<p>To see the configuration values for an environment, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
azd env get-values</pre>
			<p>To change the Azure region afterward, you can use <strong class="source-inline">azd </strong><span class="No-Break"><strong class="source-inline">env set</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
azd env set AZURE_LOCATION eastus3</pre>
			<p>While the Azure Developer CLI supports using multiple environments, using this in combination with GitHub environments is (not yet) directly available but can be easily customized. At the time of writing, the <strong class="source-inline">azd pipeline config</strong> command only supports one environment per repository. However, this is expected to change, and integration with GitHub environments is already being discussed. Check the README file in this chapter’s repository <span class="No-Break">for updates.</span></p>
			<p>You can still use <strong class="source-inline">azd pipeline</strong> to create federated accounts for <span class="No-Break">every environment:</span></p>
			<pre class="console">
azd pipeline config --auth-type federated --principal-name github-codebreaker-prod</pre>
			<p>This creates the account<a id="_idIndexMarker620"/> that we’ll use<a id="_idIndexMarker621"/> with the <span class="No-Break"><strong class="source-inline">codebreaker-08-prod</strong></span><span class="No-Break"> environment.</span></p>
			<p>At this point, we need to learn how to use GitHub environments. So, we’ll start by creating <span class="No-Break">GitHub environments.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Creating GitHub environments</h2>
			<p>Before using GitHub environments, you need <a id="_idIndexMarker622"/>to be aware that this GitHub feature is only available for free with public repositories. With private repositories, a Team license is required (<span class="No-Break">see </span><a href="https://github.com/pricing"><span class="No-Break">https://github.com/pricing</span></a><span class="No-Break">).</span></p>
			<p>Open your GitHub repository in your browser and click <strong class="bold">Settings</strong>. In the left pane, under the <strong class="bold">Code and automation</strong> category, click <strong class="bold">Environments</strong>. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.8</em> shows the environments for development, testing, staging, <span class="No-Break">and production:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B21217_08_08.jpg" alt="Figure 8.8 – GitHub environments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – GitHub environments</p>
			<p>You can create these environments<a id="_idIndexMarker623"/> using your browser by accessing your repository. As the environments are being created, protection rules can <span class="No-Break">be applied.</span></p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Defining deployment protection rules</h2>
			<p>Before publishing to<a id="_idIndexMarker624"/> another environment, you can enforce <strong class="bold">deployment protection rules</strong>. Publishing to the production environment might only be allowed from <strong class="bold">protected branches</strong>, specific branches that fulfill a naming<a id="_idIndexMarker625"/> convention, and only with commits from specific tag names. Up to six reviewers can be specified to approve the deployment. There’s also the option to implement custom protection rules, which, for example, might check the results of different test runs (tests will be covered in <a href="B21217_10.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>) or check for issues within the GitHub repository. Third-party protection rules are <span class="No-Break">also available.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">With the first few versions of the application, where you’ll start with deployments across different environments, it’s good practice to add reviewers that do some manual checks. Before<a id="_idIndexMarker626"/> the solution is deployed<a id="_idIndexMarker627"/> to the <strong class="bold">production</strong> environment, it needs to be deployed to the <strong class="bold">staging</strong> environment. In the staging environment, manual checks are used. On the road to improving the CI/CD process, you might add more and more automatic checks. Automated tests, code analysis, checking for issues, and more can be done before moving on to the next stage. You just need to be able to trust how you set up the environment and have your <span class="No-Break">tests running.</span></p>
			<p>Within the production environment, add yourself as a required reviewer with deployment protection, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B21217_08_09.jpg" alt="Figure 8.9 – Required reviewers with GitHub environments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Required reviewers with GitHub environments</p>
			<p>Other than requiring reviewers, you can use rules<a id="_idIndexMarker628"/> defined by existing apps from GitHub partner applications to require some source code or issue checks, and also implement custom <span class="No-Break">protection rules</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">When using deployment protection rules for branches and tags, you should specify that not everyone is allowed to create branches and tags that are used with the rules. See <em class="italic">Configuring tag protection rules</em> at <a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules">https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules</a> for <span class="No-Break">more details.</span></p>
			<p>Next, we’ll configure secrets and variables <span class="No-Break">with environments.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>Setting environment secrets and variables</h2>
			<p>With environments, you can also<a id="_idIndexMarker629"/> specify variables and secrets<a id="_idIndexMarker630"/> that are only available within these environments. We need the tenant ID, the subscription ID , and the account ID of the federated account we created earlier. This information was configured in the <em class="italic">Enhancing GitHub Actions </em><span class="No-Break"><em class="italic">workflows</em></span><span class="No-Break"> section.</span></p>
			<p>As a reminder, to get the tenant ID, use <strong class="source-inline">az account show –query tenantId -o tsv</strong>). To get the subscription ID, use <strong class="source-inline">az account show --query id -o tsv</strong>. With the account, to use an environment, an additional credential <span class="No-Break">is required.</span></p>
			<p>Open the Entra portal (<a href="https://entra.microsoft.com">https://entra.microsoft.com</a>) and select <strong class="bold">App registrations</strong> in the left pane. Then, select the <strong class="bold">All applications</strong> tab and look for the previously created app registration – that is, <strong class="source-inline">az-dev&lt;date&gt;</strong>. Select <strong class="bold">Certificates &amp; secrets</strong> from the left pane and select the <strong class="bold">Federated credentials</strong> tab. Previously, two credentials with the <strong class="source-inline">repo:&lt;github org/repo&gt;:pull_request</strong> and <strong class="source-inline">repo:&lt;github org/repo:refs/heads/main</strong> subject identifiers were added. Add a new credential and select <strong class="bold">GitHub Actions deploying Azure resources</strong>, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B21217_08_10.jpg" alt="Figure 8.10 – Environment credentials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Environment credentials</p>
			<p>Within this dialogue, add<a id="_idIndexMarker631"/> your GitHub <strong class="bold">Organization</strong> and <strong class="bold">Repository</strong>, select <strong class="bold">Environment</strong> for <strong class="bold">Entity type</strong>, enter the <strong class="bold">GitHub environment name</strong> value<a id="_idIndexMarker632"/> that matches your GitHub environment, and provide <span class="No-Break"><strong class="bold">Credential details</strong></span><span class="No-Break">.</span></p>
			<p>To configure the secret, copy the <strong class="bold">Application (client) ID</strong> value of this <span class="No-Break">app registration.</span></p>
			<p>Once you have these values, open the environment in the GitHub portal and add <strong class="bold">Environment secrets</strong> and <strong class="bold">Environment variables</strong>, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B21217_08_11.jpg" alt="Figure 8.11 – Configuring Environment secrets and Environment variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Configuring Environment secrets and Environment variables</p>
			<p>The following variables<a id="_idIndexMarker633"/> <span class="No-Break">are required:</span></p>
			<ul>
				<li><strong class="source-inline">AZURE_ENV_NAME</strong>: The resource group<a id="_idIndexMarker634"/> name that should be used without the <strong class="source-inline">rg-</strong> prefix – for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">codebreaker-08-prod</strong></span></li>
				<li><strong class="source-inline">AZURE_LOCATION</strong>: Your preferred <span class="No-Break">Azure region</span></li>
			</ul>
			<p>You will need the <span class="No-Break">following secrets:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">AZURE_SUBSCRIPTION_ID</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">AZURE_TENANT_ID</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">AZURE_CLIENT_ID</strong></span></li>
			</ul>
			<p>With this configuration in place, let’s update <span class="No-Break">the workflows.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>Using environments with workflows</h2>
			<p>To use an environment<a id="_idIndexMarker635"/> from a workflow, all you need<a id="_idIndexMarker636"/> to do is reference the environment name. Copy the shared workflow, <strong class="source-inline">shared-deploy.yml</strong>, to <strong class="source-inline">shared-deploy-withenvironment.yml</strong> and enhance it with an <span class="No-Break">environment configuration:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/shared-deploy-withenvironment.yml</p>
			<pre class="source-code">
# code removed for brevity
  workflow_call:
<strong class="bold">    </strong><strong class="bold">inputs:</strong>
<strong class="bold">      environment-name:</strong>
        description: 'The environment to deploy to'
        required: true
        type: string
jobs:
  build-and-publish:
    runs-on: ubuntu-latest
<strong class="bold">    environment: ${{ inputs.environment-name }}</strong></pre>
			<p>When configuring the job, the <strong class="source-inline">environment</strong> keyword is used to reference an environment name. With this implementation, a required input parameter is used to pass the name of the environment. No changes need to be made regarding the secrets and variables. When running in the environment, these values are retrieved from the <span class="No-Break">environment configuration.</span></p>
			<p>The <strong class="source-inline">codebreaker-production.yml</strong> workflow, which uses the various workflows to create and push the Docker image and publish the Container App, is different from the development environment, as <span class="No-Break">shown here:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">workflows/codebreaker- produnction.yml</p>
			<pre class="source-code">
# code removed for brevity
jobs:
  build-and-deploy:
    uses: ./.github/workflows/shared-deploy-withenvironment.yml
<strong class="bold">    secrets: inherit</strong>
    with:
<strong class="bold">      environment-name: codebreaker-08-prod</strong></pre>
			<p>The environment parameter<a id="_idIndexMarker637"/> is now set<a id="_idIndexMarker638"/> to <strong class="source-inline">codebreaker-08-prod</strong>. This time, the secrets are not explicitly declared, but all secrets this workflow has access to are given to the called workflow. Because of the environment specified by the called workflow, secrets and variables are referenced from the <span class="No-Break">GitHub environment.</span></p>
			<p>Now, you can try triggering the workflow. The first stage runs, but the second stage must be reviewed, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B21217_08_12.jpg" alt="Figure 8.12 – Workflow review requested"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Workflow review requested</p>
			<p>Review the results<a id="_idIndexMarker639"/> of the workflow<a id="_idIndexMarker640"/> and approve it, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.13</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B21217_08_13.jpg" alt="Figure 8.13 – Approve and deploy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Approve and deploy</p>
			<p>At this point, you need to wait a few minutes until all the resources are deployed to the production environment. Verify that the deployment succeeded. After a successful deployment, you can use a client, update<a id="_idIndexMarker641"/> the link to the new environment, and play<a id="_idIndexMarker642"/> <span class="No-Break">a game.</span></p>
			<p>For the client programmers, we’ll create a <span class="No-Break">NuGet package.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Publishing NuGet packages</h1>
			<p>With our solution, we also have libraries<a id="_idIndexMarker643"/> that are used by client applications. Having NuGet packages helps with using these libraries. By creating a GitHub action, we can automatically build and publish the NuGet package. If you want to make a package publicly available, you can publish it to the NuGet server (you’ve already used packages that are available for this book). To make packages<a id="_idIndexMarker644"/> private with authentication, GitHub offers <span class="No-Break"><strong class="bold">GitHub Packages</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Preparing the library project</h2>
			<p>Adding some metadata, such<a id="_idIndexMarker645"/> as a README Markdown file to the project describing the package, and a custom icon to replace the default icon, <span class="No-Break">enhances usability.</span></p>
			<p>The <strong class="source-inline">Codebreaker.GameAPIs.KiotaClient</strong> project contains a <strong class="source-inline">readme.md</strong> file and a JPG file for an icon. These additions need to be uploaded within the <span class="No-Break">project file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj</p>
			<pre class="source-code">
  &lt;ItemGroup&gt;
    &lt;None Include="package/readme.md" Pack="true" PackagePath="\" /&gt;
    &lt;None Include="package/codebreaker.jpeg" Pack="true" 
     PackagePath="\" /&gt;
  &lt;/ItemGroup&gt;</pre>
			<p>The README file and the icon don’t need to be built into the library, which is why <strong class="source-inline">None</strong> is used within <strong class="source-inline">ItemGroup</strong> to exclude them from the build result of the library. Adding these items to the NuGet package is specified by the <strong class="source-inline">Pack</strong> attribute. <strong class="source-inline">PackagePath</strong> specifies the folder within the package where these items can <span class="No-Break">be found.</span></p>
			<p>The following <strong class="source-inline">PropertyGroup</strong> definitions specify the use of the README file and the package icon and add <span class="No-Break">some metadata:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj</p>
			<pre class="source-code">
  &lt;PropertyGroup&gt;
    &lt;PackageId&gt;
      CNinnovation.Codebreaker.KiotaClient
    &lt;/PackageId&gt;
    &lt;PackageTags&gt;
      Codebreaker;CNinnovation;Kiota
    &lt;/PackageTags&gt;
    &lt;Description&gt;
      This library contains Kiota-generated classes for communication 
      with the Codebreaker games API service.
      See https://github.com/codebreakerapp for more information on 
        the complete solution.
    &lt;/Description&gt;
    &lt;PackageReadmeFile&gt;readme.md&lt;/PackageReadmeFile&gt;
    &lt;PackageIcon&gt;codebreaker.jpeg&lt;/PackageIcon&gt;
  &lt;/PropertyGroup&gt;</pre>
			<p>Adding metadata to the package is specified with the <strong class="source-inline">PackageId</strong>, <strong class="source-inline">PackageTags</strong>, and <span class="No-Break"><strong class="source-inline">Description</strong></span><span class="No-Break"> elements.</span></p>
			<p>It’s also a good idea to define the version of the package. With the source code repository, the <strong class="source-inline">VersionPrefix</strong> element, which is defined within the <strong class="source-inline">Directory.Build.props</strong> file, specifies the first part of the version for all the projects found in subdirectories. Using a GitHub action, a <strong class="source-inline">VersionSuffix</strong> element is added dynamically that increments with every build. This versioning scheme is used with <strong class="source-inline">alpha</strong>, <strong class="source-inline">beta</strong>, and <span class="No-Break"><strong class="source-inline">prerelease</strong></span><span class="No-Break"> versions.</span></p>
			<p>As soon as the library is released, the <strong class="source-inline">Version</strong> element is added to specify the complete version of the package. Adding the <strong class="source-inline">Version</strong> element to the project overrides <strong class="source-inline">VersionPrefix</strong> and <strong class="source-inline">VersionSuffix</strong>, and just this version is used. After the release, when the next beta versions are available, the <strong class="source-inline">Version</strong> element is removed again, and the <strong class="source-inline">VersionPrefix</strong> element is incremented to the <span class="No-Break">next</span><span class="No-Break"><a id="_idIndexMarker646"/></span><span class="No-Break"> iteration.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>Creating access tokens</h2>
			<p>To publish a package<a id="_idIndexMarker647"/> to GitHub Packages, a <strong class="bold">personal access token (classic)</strong> is required. At the time of<a id="_idIndexMarker648"/> writing, the new fine-grained personal access tokens cannot be used with <span class="No-Break">GitHub Packages.</span></p>
			<p>You can create a personal access token by clicking on the user icon in the top-right corner, selecting <strong class="bold">Settings</strong>, and then clicking on <strong class="bold">Developer Settings</strong> in the left pane. Select <strong class="bold">Personal access tokens</strong> and click <strong class="bold">Tokens (classic)</strong>. To create a new token, select <strong class="bold">Generate new token (classic)</strong>. Select an expiration date. The scope that is required to publish packages is <strong class="bold">write:packages</strong>. Selecting this scope also adds other scopes, such as reading packages and access to the repository. Click <strong class="bold">Generate token</strong>. You need to copy this generated token – it will not be visible again after you close the screen. Just make sure you store it in a safe place. You can create a new token in case you don’t have one anymore, or when the token <span class="No-Break">has expired.</span></p>
			<p>For the GitHub action you wish<a id="_idIndexMarker649"/> to use, store this token alongside the secrets of the <span class="No-Break"><strong class="source-inline">PAT_PUBLISHPACKAGE</strong></span><span class="No-Break"> repository.</span></p>
			<p>Now that we’ve stored this secret, let’s use it with a <span class="No-Break">GitHub action.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Creating a GitHub action to publish a GitHub package</h2>
			<p>The GitHub actions that are used<a id="_idIndexMarker650"/> to create a NuGet package have similarities with the GitHub actions we created previously. Check out the source code repository <span class="No-Break">for details.</span></p>
			<p>The <strong class="source-inline">shared-create-nuget.yml</strong> shared workflow builds the NuGet package and uploads it with GitHub artifacts. The following steps are completed in <span class="No-Break">this workflow:</span></p>
			<ol>
				<li>Check out the <span class="No-Break">source code.</span></li>
				<li>Set <span class="No-Break">up .NET.</span></li>
				<li>Calculate the build number (using a configured offset to the GitHub <span class="No-Break">build number).</span></li>
				<li>Build the library using <span class="No-Break"><strong class="source-inline">dotnet build</strong></span><span class="No-Break">.</span></li>
				<li>Test the library using <span class="No-Break"><strong class="source-inline">dotnet test</strong></span><span class="No-Break">.</span></li>
				<li>Create a NuGet package using <span class="No-Break"><strong class="source-inline">dotnet pack</strong></span><span class="No-Break">.</span></li>
				<li>Upload the package with <span class="No-Break">GitHub artifacts.</span></li>
			</ol>
			<p>The next shared workflow (<strong class="source-inline">shared-githubpackages.yml</strong>) uploads the package to GitHub Packages by following <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Download the <span class="No-Break">GitHub artifact.</span></li>
				<li>Set <span class="No-Break">up .NET.</span></li>
				<li>Set the NuGet source with <strong class="source-inline">dotnet nuget </strong><span class="No-Break"><strong class="source-inline">add source</strong></span><span class="No-Break">.</span></li>
				<li>Push the package to GitHub Packages with <strong class="source-inline">dotnet </strong><span class="No-Break"><strong class="source-inline">nuget push</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Pushing the package makes use of the configured <span class="No-Break">access token.</span></p>
			<p>The <strong class="source-inline">kiota-lib.yml</strong> workflow connects the two shared workflows and passes parameters. Upon running this workflow successfully, you can verify the packages with the organization of your GitHub repository, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B21217_08_14.jpg" alt="Figure 8.14 – GitHub Packages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – GitHub Packages</p>
			<p>Using GitHub environments, you can enhance the creation of NuGet packages and define environments, such as those to publish to the publicly available NuGet server only after successfully using a private feed<a id="_idIndexMarker651"/> with <span class="No-Break">GitHub Packages.</span></p>
			<p>With modern deployments, there’s more than just using development, staging, and production environments. We’ll discuss <span class="No-Break">this next.</span></p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/>Using modern deployment patterns</h1>
			<p>Using development, staging, and production environments is one of the “traditional” deployment patterns. Nowadays, other deployment<a id="_idIndexMarker652"/> patterns are used <span class="No-Break">as well:</span></p>
			<ul>
				<li>When using <strong class="bold">canary releases</strong>, different versions of an application<a id="_idIndexMarker653"/> are available for the user to choose from. This is evident from the Edge browser, which offers a Beta channel that’s updated monthly, a Dev channel that’s updated weekly, and a Canary channel that’s updated daily. The user can decide<a id="_idIndexMarker654"/> what version to test. See <a href="https://www.microsoft.com/en-us/edge/download/insider">https://www.microsoft.com/en-us/edge/download/insider</a> for <span class="No-Break">more details.</span></li>
				<li>With <strong class="bold">A/B testing</strong>, users randomly receive<a id="_idIndexMarker655"/> one of two different user interfaces. When using this pattern, you can monitor which UI allows the user to be <span class="No-Break">more productive.</span></li>
				<li><strong class="bold">Blue-green deployments</strong> allow you to quickly roll back an installation<a id="_idIndexMarker656"/> by installing to a staging server, swapping staging with production. If something fails, an easy rollback can <span class="No-Break">be done.</span></li>
				<li><strong class="bold">Dark launching</strong> is a pattern that you can use to publish<a id="_idIndexMarker657"/> a new version of the application while ensuring that the new features are hidden until they are activated by turning on a switch. One example of this is when a feature should be available at a specific time. This switch can be turned on by a time event – there’s no need to redeploy <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Feature toggles</strong> allow you to turn each feature<a id="_idIndexMarker658"/> on/off. One option is to enable some of the features for a specific group of users, such as early adopters. Users themselves can also decide which of the new features they want to test. Such toggles are available with Microsoft Azure and <span class="No-Break">Visual Studio.</span></li>
			</ul>
			<p>In <a href="B21217_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, you saw Azure App Configuration in action. This Azure service not only supports a central application configuration but also offers feature flags. This functionality of Azure App Configuration can be used with several of the modern deployment patterns by using different feature <span class="No-Break">flag filters.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>Configuring feature flags</h2>
			<p>Let’s open the Azure App Configuration <a id="_idIndexMarker659"/>service that was created with Bicep scripts. In the left pane, within the <strong class="bold">Operations</strong> category, open <span class="No-Break"><strong class="bold">Feature manager</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might not have access to this resource to add configuration data since the resource was created from Bicep scripts. Using <strong class="bold">Access control (IAM)</strong>, add your user to the <strong class="bold">App Configuration Data Owner</strong> or <strong class="bold">Contributor</strong> role. You might need to wait about 15 minutes before the <span class="No-Break">role changes.</span></p>
			<p>Create a new feature flag, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B21217_08_15.jpg" alt="Figure 8.15 – Creating feature flags"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Creating feature flags</p>
			<p>Set the feature flag’s name to <strong class="source-inline">Feature8x5Game</strong>, add a description, and check the <strong class="bold">Enable feature flag</strong> box. Before applying this configuration, click on <strong class="bold">Create</strong> under <strong class="bold">Feature filters</strong>. Select the targeting filter. Read the information about the evaluation flow, but leave the other values with their default settings. Add other feature flags for <strong class="source-inline">FeatureGame6x4Mini</strong>, <strong class="source-inline">FeatureGame6x4</strong>, and <strong class="source-inline">FeatureGame5x5x4</strong>. Don’t add filters for the first two; just enable one of these. For the last one, add a time filter so that it can be enabled in the future, but don’t set an <span class="No-Break">expiration date.</span></p>
			<p>The <strong class="bold">targeting filter</strong> allows you to open a feature<a id="_idIndexMarker660"/> for a specific user group (early adopters). It can also act as a percentage filter, so you can turn this feature on for a random percentage of users. The <a id="_idIndexMarker661"/>other built-in filter is the <strong class="bold">time window filter</strong>. Using this filter, you can specify start and end times when this feature should be enabled. You can also create a custom<a id="_idIndexMarker662"/> implementation for <span class="No-Break">a filter.</span></p>
			<p>Now that we’ve configured this feature flag, let’s use this from the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>DI and middleware configuration for feature flags</h2>
			<p>To use Feature<a id="_idIndexMarker663"/> Management, add<a id="_idIndexMarker664"/> the <strong class="source-inline">Microsoft.FeatureManagement.AspNetCore</strong> NuGet package<a id="_idIndexMarker665"/> to the <strong class="source-inline">Codebreaker.GameAPIs</strong> project. The DI container needs<a id="_idIndexMarker666"/> to be configured for feature flags, as <span class="No-Break">shown here:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
builder.Services.AddFeatureManagement()
  .AddFeatureFilter&lt;TargetingFilter&gt;()
  .AddFeatureFilter&lt;TimeWindowFilter&gt;();</pre>
			<p>The <strong class="source-inline">AddFeatureManagement</strong> extension method registers types that are needed for feature flags. Every filter that is used is added using the <strong class="source-inline">AddFeatureFilter</strong> <span class="No-Break">extension method.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Feature Management API can also be used without Azure App Configuration. Upon viewing the source code in this book’s GitHub repository, you’ll see that the Feature Management API can be configured without using Azure as well. In this case, an overload of the <strong class="source-inline">AddFeatureManagement</strong> API is invoked to pass an <strong class="source-inline">IConfiguration</strong> object. With this, feature flags can be configured with the .NET configuration options. Revisit <a href="B21217_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> for more information <span class="No-Break">on configuration.</span></p>
			<p>To connect Feature Management with Azure App Configuration, you must update the <span class="No-Break"><strong class="source-inline">AddAzureAppConfiguration</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
  builder.Configuration.AddAzureAppConfiguration(options =&gt;
  {
    options.Connect(new Uri(endpoint), credential)
      .Select("GamesAPI*")
      .ConfigureKeyVault(kv =&gt;
      {
        kv.SetCredential(credential);
      })
<strong class="bold">      .UseFeatureFlags();</strong>
  });</pre>
			<p><strong class="source-inline">UseFeatureFlags</strong> is a method of the <strong class="source-inline">AzureAppConfigurationOptions</strong> class for connecting <span class="No-Break">feature flags.</span></p>
			<p>When using feature<a id="_idIndexMarker667"/> flags, the Azure App Configuration<a id="_idIndexMarker668"/> middleware<a id="_idIndexMarker669"/> also needs<a id="_idIndexMarker670"/> to <span class="No-Break">be configured:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
var app = builder.Build();
if (solutionEnvironment == "Azure")
{
<strong class="bold">  app.UseAzureAppConfiguration();</strong>
}</pre>
			<p>With the setup in place, we can check if feature flags have <span class="No-Break">been set.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>Using feature flags</h2>
			<p>Now, we can use the feature manager<a id="_idIndexMarker671"/> to check if features are available. We’ll start by creating an extension method for the <span class="No-Break"><strong class="source-inline">IFeatureManager</strong></span><span class="No-Break"> interface:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Extensions/FeatureManagerExtensions.cs</p>
			<pre class="source-code">
public static class FeatureManagerExtensions
{
  private static List&lt;string&gt;? s_featureNames;
  public static async Task&lt;bool&gt; IsGameTypeAvailable(<strong class="bold">this </strong>
    <strong class="bold">IFeatureManager featureManager</strong>, GameType gameType)
  {
    async Task&lt;List&lt;string&gt;&gt; GetFeatureNamesAsync()
    {
      List&lt;string&gt; featureNames = [];
<strong class="bold">      await foreach (string featureName in featureManager.</strong>
<strong class="bold">        GetFeatureNamesAsync())</strong>
      {
        featureNames.Add(featureName);
      }
      return featureNames;
    }
    string featureName = $"Feature{gameType}";
    if ((s_featureNames ?? await GetFeatureNamesAsync()).
    Contains(featureName))
    {
<strong class="bold">      return await featureManager.IsEnabledAsync(featureName);</strong>
    }
    else
    {
      return true;
    }
  }
}</pre>
			<p>This method uses<a id="_idIndexMarker672"/> the <strong class="source-inline">GetFeatureNamesAsync</strong> and <strong class="source-inline">IsEnabledAsync</strong> methods defined by the <strong class="source-inline">IFeatureManager</strong> interface. On the first invocation of this method, the list of features registered with the feature manager is retrieved and added to the <strong class="source-inline">_featureNames</strong> collection. Not every game type is registered as a feature. For the game types that are not registered as features, the method returns <strong class="source-inline">true</strong> to inform us that this type is available. With all the game types registered as a feature, the <strong class="source-inline">IsEnabledAsync</strong> method is used to check if the feature <span class="No-Break">is enabled.</span></p>
			<p>Next, let’s inject <strong class="source-inline">IFeatureManager</strong> with the <span class="No-Break">minimal API:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
group.MapPost("/", async Task&lt;Results&lt;Created&lt;CreateGameResponse&gt;, BadRequest&lt;GameError&gt;&gt;&gt; (
  CreateGameRequest request,
  IGamesService gameService,
<strong class="bold">  IFeatureManager featureManager,</strong>
  HttpContext context,
  CancellationToken cancellationToken) =&gt;
  {
    Game game;
    try
    {
<strong class="bold">      bool featureAvailable = await featureManager.</strong>
        <strong class="bold">IsGameTypeAvailable(request.GameType);</strong>
      if (!featureAvailable)
      {
        GameError error = new(ErrorCodes.
          GameTypeCurrentlyNotAvailable, "Game type currently not 
          available", context.Request.GetDisplayUrl());
        return TypedResults.BadRequest(error);
      }
      game = await gameService.StartGameAsync(request.GameType.
        ToString(), request.PlayerName, cancellationToken);}
// code removed for brevity</pre>
			<p>On starting a game<a id="_idIndexMarker673"/> using the API, the <strong class="source-inline">IFeatureManagement</strong> interface is injected to check the requested game type for the feature to be enabled using the previously created extension method, <strong class="source-inline">IsGameTypeAvailable</strong>. Depending on the result, an error is returned, or a new game <span class="No-Break">is created.</span></p>
			<p>With this implementation, you can run the application and test these feature flags. The <strong class="source-inline">game-apis</strong> project contains an HTTP file that you can use to create all the different game types and see the results that were returned when using feature flags. You can test this locally on your developer system. Upon pushing an update to your GitHub repository, a workflow is ready to be triggered. Then, you just need to configure the link of your API service within the HTTP<a id="_idIndexMarker674"/> file to test the service that’s running with Azure <span class="No-Break">Container Apps.</span></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Summary</h1>
			<p>After creating Azure services with Bicep scripts in <a href="B21217_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, in this chapter, you learned how to use <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) with GitHub Actions. Here, you changed the source code, created and merged a pull request, tested code, and deployed Azure Container Apps. Using GitHub Actions, you learned how to build NuGet packages and push them to <span class="No-Break">GitHub Packages.</span></p>
			<p>Using GitHub environments, you created multiple deployment environments where additional checks are required before deployment is extended to <span class="No-Break">another stage.</span></p>
			<p>After, you learned how to configure Azure App Configuration, as well as how to use feature flags, which are needed for modern deployment patterns such as A/B testing, blue-green deployments, and <span class="No-Break">dark launching.</span></p>
			<p>The next chapter covers another important topic: authentication and authorization. In <a href="B21217_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, you learned how to run Azure services with managed identities. In <a href="B21217_09.xhtml#_idTextAnchor216"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we’ll restrict the applications that are allowed to invoke APIs, authenticate users to restrict functionality for anonymous users, and add APIs that are only allowed to be used by specific <span class="No-Break">user groups.</span></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">GitHub Actions </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://docs.github.com/en/actions"><span class="No-Break">https://docs.github.com/en/actions</span></a></li>
				<li><em class="italic">azd: configure a </em><span class="No-Break"><em class="italic">pipeline</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline"><span class="No-Break">https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline</span></a></li>
				<li><em class="italic">Using environments for </em><span class="No-Break"><em class="italic">deployments</em></span><span class="No-Break">: </span><a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment"><span class="No-Break">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment</span></a></li>
				<li><em class="italic">Creating custom protection </em><span class="No-Break"><em class="italic">rules</em></span><span class="No-Break">: </span><a href="https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules"><span class="No-Break">https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules</span></a></li>
				<li><em class="italic">Microsoft Feature Management </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet</span></a></li>
			</ul>
		</div>
	</body></html>