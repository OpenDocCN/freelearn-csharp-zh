["```cs\npublic class Inventory\n{\n   int _quantity;\n    private Object _lock = new Object();\n\n    public void RemoveQuantity(int amount)\n    {\n        lock (_lock)\n        {\n            if (_quantity - amount < 0)\n {\n throw new Exception(\"Cannot remove more than we have!\");\n }\n _quantity -= amount;\n        }\n    }\n}\n```", "```cs\ninternal interface IInventoryContext\n{\n    Book[] GetBooks();\n    bool AddBook(string name);\n    bool UpdateQuantity(string name, int quantity);\n}\n```", "```cs\ninternal class InventoryContext : IInventoryContext\n{ \n    public InventoryContext()\n    {\n        _books = new Dictionary<string, Book>();\n    }\n\n    private readonly IDictionary<string, Book> _books; \n\n    public Book[] GetBooks()\n    {\n        return _books.Values.ToArray();\n    }\n\n    public bool AddBook(string name)\n    {\n        _books.Add(name, new Book { Name = name });\n        return true;\n    }\n\n    public bool UpdateQuantity(string name, int quantity)\n    {\n        _books[name].Quantity += quantity;\n        return true;\n    }\n}\n```", "```cs\n [TestClass]\npublic class InventoryContextTests\n{ \n    [TestMethod]\n    public void MaintainBooks_Successful()\n    { \n        var context = new InventoryContext();\n\n        // add thirty books\n        ...\n\n        // let's update the quantity of the books by adding 1, 2, 3, 4, 5 ...\n        ...\n\n        // let's update the quantity of the books by subtracting 1, 2, 3, 4, 5 ...\n        ...\n\n        // all quantities should be 0\n        ...\n    } \n}\n```", "```cs\n        // add thirty books\n        foreach(var id in Enumerable.Range(1, 30))\n        {\n            context.AddBook($\"Book_{id}\"); \n        }\n```", "```cs\n        // let's update the quantity of the books by adding 1, 2, 3, 4, 5 ...\n        foreach (var quantity in Enumerable.Range(1, 10))\n        {\n            foreach (var id in Enumerable.Range(1, 30))\n            {\n                context.UpdateQuantity($\"Book_{id}\", quantity);\n            }\n        }\n```", "```cs\n        foreach (var quantity in Enumerable.Range(1, 10))\n        {\n            foreach (var id in Enumerable.Range(1, 30))\n            {\n                context.UpdateQuantity($\"Book_{id}\", -quantity);\n            }\n        }\n```", "```cs\n        // all quantities should be 0\n        foreach (var book in context.GetBooks())\n        {\n            Assert.AreEqual(0, book.Quantity);\n        }\n```", "```cs\npublic Task AddBook(string book)\n{\n    return Task.Run(() =>\n    {\n        var context = new InventoryContext();\n        Assert.IsTrue(context.AddBook(book));\n    });\n}\n```", "```cs\npublic Task UpdateQuantity(string book, int quantity)\n{\n    return Task.Run(() =>\n    {\n        var context = new InventoryContext();\n        Assert.IsTrue(context.UpdateQuantity(book, quantity));\n    });\n}\n```", "```cs\n    // add thirty books\n    foreach (var id in Enumerable.Range(1, 30))\n    {\n        tasks.Add(AddBook($\"Book_{id}\"));\n    }\n\n    Task.WaitAll(tasks.ToArray());\n    tasks.Clear();\n```", "```cs\n    // let's update the quantity of the books by adding 1, 2, 3, 4, 5 ...\n    foreach (var quantity in Enumerable.Range(1, 10))\n    {\n        foreach (var id in Enumerable.Range(1, 30))\n        {\n            tasks.Add(UpdateQuantity($\"Book_{id}\", quantity));\n        }\n    }\n\n    // let's update the quantity of the books by subtractin 1, 2, 3, 4, 5 ...\n    foreach (var quantity in Enumerable.Range(1, 10))\n    {\n        foreach (var id in Enumerable.Range(1, 30))\n        {\n            tasks.Add(UpdateQuantity($\"Book_{id}\", -quantity));\n        }\n    }\n\n    // wait for all adds and subtracts to finish\n    Task.WaitAll(tasks.ToArray());\n```", "```cs\ninternal class InventoryContext : IInventoryContext\n{ \n    protected InventoryContext()\n    {\n        _books = new Dictionary<string, Book>();\n    }\n\n    private static InventoryContext _context;\n    public static InventoryContext Singleton\n    {\n        get\n        {\n            if (_context == null)\n            {\n                _context = new InventoryContext();\n            }\n\n            return _context;\n        }\n    }\n    ...\n}    \n```", "```cs\npublic static InventoryContext Singleton\n{\n    get\n    {\n        if (_context == null)\n        {\n            _context = new InventoryContext();\n        }\n\n        return _context;\n    }\n}\n```", "```cs\nprivate static object _lock = new object();\npublic static InventoryContext Singleton\n{\n    get\n    { \n        if (_context == null)\n        {\n lock (_lock)\n            {\n                _context = new InventoryContext();\n            }\n        }\n\n        return _context;\n    }\n}\n```", "```cs\npublic static InventoryContext Singleton\n{\n    get\n    { \n        if (_context == null)\n        {\n            lock (_lock)\n            {\n if (_context == null)\n                {\n                    _context = new InventoryContext();\n                }\n            }\n        }\n\n        return _context;\n    }\n}\n```", "```cs\nprotected InventoryContext()\n{\n    _books = new ConcurrentDictionary<string, Book>();\n}\n```", "```cs\npublic bool UpdateQuantity(string name, int quantity)\n{\n    lock (_lock)\n    {\n        _books[name].Quantity += quantity;\n    }\n\n    return true;\n}\n```", "```cs\ninternal class AddInventoryCommand : NonTerminatingCommand, IParameterisedCommand\n{\n    private readonly IInventoryContext _context;\n\n    internal AddInventoryCommand(IUserInterface userInterface, IInventoryContext context) \n                                                            : base(userInterface)\n    {\n        _context = context;\n    }\n\n    public string InventoryName { get; private set; }\n\n    /// <summary>\n    /// AddInventoryCommand requires name\n    /// </summary>\n    /// <returns></returns>\n    public bool GetParameters()\n    {\n        if (string.IsNullOrWhiteSpace(InventoryName))\n            InventoryName = GetParameter(\"name\");\n\n        return !string.IsNullOrWhiteSpace(InventoryName);\n    }\n\n    protected override bool InternalCommand()\n    {\n        return _context.AddBook(InventoryName); \n    }\n}\n```", "```cs\nprivate readonly IDictionary<string, Book> _seedDictionary;\nprivate readonly IDictionary<string, Book> _books;\n```", "```cs\npublic TestInventoryContext(IDictionary<string, Book> books)\n{\n    _seedDictionary = books.ToDictionary(book => book.Key,\n                                         book => new Book { Id = book.Value.Id, \n                                                            Name = book.Value.Name, \n                                                            Quantity = book.Value.Quantity });\n    _books = books;\n}\n```", "```cs\npublic Book[] GetBooks()\n{\n    return _books.Values.ToArray();\n}\n\npublic bool AddBook(string name)\n{\n    _books.Add(name, new Book() { Name = name });\n\n    return true;\n}\n\npublic bool UpdateQuantity(string name, int quantity)\n{\n    _books[name].Quantity += quantity;\n\n    return true;\n}\n```", "```cs\npublic Book[] GetAddedBooks()\n{\n    return _books.Where(book => !_seedDictionary.ContainsKey(book.Key))\n                                                    .Select(book => book.Value).ToArray();\n}\n\npublic Book[] GetUpdatedBooks()\n{ \n    return _books.Where(book => _seedDictionary[book.Key].Quantity != book.Value.Quantity)\n                                                    .Select(book => book.Value).ToArray();\n}\n```", "```cs\nconst string expectedBookName = \"AddInventoryUnitTest\";\nvar expectedInterface = new Helpers.TestUserInterface(\n    new List<Tuple<string, string>>\n    {\n        new Tuple<string, string>(\"Enter name:\", expectedBookName)\n    },\n    new List<string>(),\n    new List<string>()\n);\n```", "```cs\nvar context = new TestInventoryContext(new Dictionary<string, Book>\n{\n    { \"Gremlins\", new Book { Id = 1, Name = \"Gremlins\", Quantity = 7 } }\n});\n```", "```cs\n// create an instance of the command\nvar command = new AddInventoryCommand(expectedInterface, context);\n\n// add a new book with parameter \"name\"\nvar result = command.RunCommand();\n\nAssert.IsFalse(result.shouldQuit, \"AddInventory is not a terminating command.\");\nAssert.IsTrue(result.wasSuccessful, \"AddInventory did not complete Successfully.\");\n\n// verify the book was added with the given name with 0 quantity\nAssert.AreEqual(1, context.GetAddedBooks().Length, \"AddInventory should have added one new book.\");\n\nvar newBook = context.GetAddedBooks().First();\nAssert.AreEqual(expectedBookName, newBook.Name, \"AddInventory did not add book successfully.\"); \n```", "```cs\ninternal class UpdateQuantityCommand : NonTerminatingCommand, IParameterisedCommand\n{\n    private readonly IInventoryContext _context; \n\n    internal UpdateQuantityCommand(IUserInterface userInterface, IInventoryContext context) \n                                                                            : base(userInterface)\n    {\n        _context = context;\n    }\n\n    internal string InventoryName { get; private set; }\n\n    private int _quantity;\n    internal int Quantity { get => _quantity; private set => _quantity = value; }\n\n    ...\n}\n```", "```cs\n    /// <summary>\n    /// UpdateQuantity requires name and an integer value\n    /// </summary>\n    /// <returns></returns>\n    public bool GetParameters()\n    {\n        if (string.IsNullOrWhiteSpace(InventoryName))\n            InventoryName = GetParameter(\"name\");\n\n        if (Quantity == 0)\n            int.TryParse(GetParameter(\"quantity\"), out _quantity);\n\n        return !string.IsNullOrWhiteSpace(InventoryName) && Quantity != 0;\n    }   \n```", "```cs\n    protected override bool InternalCommand()\n    {\n        return _context.UpdateQuantity(InventoryName, Quantity);\n    }\n```", "```cs\nconst string expectedBookName = \"UpdateQuantityUnitTest\";\nvar expectedInterface = new Helpers.TestUserInterface(\n    new List<Tuple<string, string>>\n    {\n        new Tuple<string, string>(\"Enter name:\", expectedBookName),\n        new Tuple<string, string>(\"Enter quantity:\", \"6\")\n    },\n    new List<string>(),\n    new List<string>()\n);\n\nvar context = new TestInventoryContext(new Dictionary<string, Book>\n{\n    { \"Beavers\", new Book { Id = 1, Name = \"Beavers\", Quantity = 3 } },\n    { expectedBookName, new Book { Id = 2, Name = expectedBookName, Quantity = 7 } },\n    { \"Ducks\", new Book { Id = 3, Name = \"Ducks\", Quantity = 12 } }\n});\n```", "```cs\n// create an instance of the command\nvar command = new UpdateQuantityCommand(expectedInterface, context);\n\nvar result = command.RunCommand();\n\nAssert.IsFalse(result.shouldQuit, \"UpdateQuantity is not a terminating command.\");\nAssert.IsTrue(result.wasSuccessful, \"UpdateQuantity did not complete Successfully.\");\n```", "```cs\nAssert.AreEqual(0, context.GetAddedBooks().Length, \n                    \"UpdateQuantity should not have added one new book.\");\n\nvar updatedBooks = context.GetUpdatedBooks();\nAssert.AreEqual(1, updatedBooks.Length, \n                    \"UpdateQuantity should have updated one new book.\");\nAssert.AreEqual(expectedBookName, updatedBooks.First().Name, \n                    \"UpdateQuantity did not update the correct book.\");\nAssert.AreEqual(13, updatedBooks.First().Quantity, \n                    \"UpdateQuantity did not update book quantity successfully.\");\n```", "```cs\ninternal class GetInventoryCommand : NonTerminatingCommand\n{\n    private readonly IInventoryContext _context;\n    internal GetInventoryCommand(IUserInterface userInterface, IInventoryContext context) \n                                                           : base(userInterface)\n    {\n        _context = context;\n    }\n\n    protected override bool InternalCommand()\n    {\n        foreach (var book in _context.GetBooks())\n        {\n            Interface.WriteMessage($\"{book.Name,-30}\\tQuantity:{book.Quantity}\"); \n        }\n\n        return true;\n    }\n}\n```", "```cs\nvar expectedInterface = new Helpers.TestUserInterface(\n    new List<Tuple<string, string>>(),\n    new List<string>\n    {\n        \"Gremlins                      \\tQuantity:7\",\n        \"Willowsong                    \\tQuantity:3\",\n    },\n    new List<string>()\n);\n```", "```cs\nvar context = new TestInventoryContext(new Dictionary<string, Book>\n{\n    { \"Gremlins\", new Book { Id = 1, Name = \"Gremlins\", Quantity = 7 } },\n    { \"Willowsong\", new Book { Id = 2, Name = \"Willowsong\", Quantity = 3 } },\n});\n```", "```cs\n// create an instance of the command\nvar command = new GetInventoryCommand(expectedInterface, context); \nvar result = command.RunCommand();\n\nAssert.IsFalse(result.shouldQuit, \"GetInventory is not a terminating command.\");\n```", "```cs\nAssert.AreEqual(0, context.GetAddedBooks().Length, \"GetInventory should not have added any books.\");\nAssert.AreEqual(0, context.GetUpdatedBooks().Length, \"GetInventory should not have updated any books.\");\n```", "```cs\npublic class InventoryCommandFactory : IInventoryCommandFactory\n{\n    private readonly IUserInterface _userInterface;\n    private readonly IInventoryContext _context = InventoryContext.Instance;\n\n    public InventoryCommandFactory(IUserInterface userInterface)\n    {\n        _userInterface = userInterface;\n    }\n\n    ...\n}\n```", "```cs\npublic InventoryCommand GetCommand(string input)\n{\n    switch (input)\n    {\n        case \"q\":\n        case \"quit\":\n            return new QuitCommand(_userInterface);\n        case \"a\":\n        case \"addinventory\":\n            return new AddInventoryCommand(_userInterface, _context);\n        case \"g\":\n        case \"getinventory\":\n            return new GetInventoryCommand(_userInterface, _context);\n        case \"u\":\n        case \"updatequantity\":\n            return new UpdateQuantityCommand(_userInterface, _context);\n        case \"?\":\n            return new HelpCommand(_userInterface);\n        default:\n            return new UnknownCommand(_userInterface);\n    }\n}\n```", "```cs\ninternal class UnknownCommand : NonTerminatingCommand\n{ \n    internal UnknownCommand(IUserInterface userInterface) : base(userInterface)\n    {\n    }\n\n    protected override bool InternalCommand()\n    { \n        Interface.WriteWarning(\"Unable to determine the desired command.\"); \n\n        return false;\n    }\n}\n```", "```cs\n[TestClass]\npublic class UnknownCommandTests\n{\n    [TestMethod]\n    public void UnknownCommand_Successful()\n    {\n        var expectedInterface = new Helpers.TestUserInterface(\n            new List<Tuple<string, string>>(),\n            new List<string>(),\n            new List<string>\n            {\n                \"Unable to determine the desired command.\"\n            }\n        ); \n\n        // create an instance of the command\n        var command = new UnknownCommand(expectedInterface);\n\n        var result = command.RunCommand();\n\n        Assert.IsFalse(result.shouldQuit, \"Unknown is not a terminating command.\");\n        Assert.IsFalse(result.wasSuccessful, \"Unknown should not complete Successfully.\");\n    }\n}\n```", "```cs\n[TestInitialize]\npublic void Initialize()\n{\n    var expectedInterface = new Helpers.TestUserInterface(\n        new List<Tuple<string, string>>(),\n        new List<string>(),\n        new List<string>()\n    ); \n\n    Factory = new InventoryCommandFactory(expectedInterface);\n}\n```", "```cs\n[TestMethod]\npublic void QuitCommand_Successful()\n{ \n    Assert.IsInstanceOfType(Factory.GetCommand(\"q\"), typeof(QuitCommand), \n                                                            \"q should be QuitCommand\");\n    Assert.IsInstanceOfType(Factory.GetCommand(\"quit\"), typeof(QuitCommand), \n                                                            \"quit should be QuitCommand\");\n}\n```", "```cs\n[TestMethod]\npublic void HelpCommand_Successful()\n{\n    Assert.IsInstanceOfType(Factory.GetCommand(\"?\"), typeof(HelpCommand), \"h should be HelpCommand\"); \n}\n```", "```cs\n[TestMethod]\npublic void UnknownCommand_Successful()\n{\n    Assert.IsInstanceOfType(Factory.GetCommand(\"add\"), typeof(UnknownCommand), \n                                                        \"unmatched command should be UnknownCommand\");\n    Assert.IsInstanceOfType(Factory.GetCommand(\"addinventry\"), typeof(UnknownCommand), \n                                                        \"unmatched command should be UnknownCommand\");\n    Assert.IsInstanceOfType(Factory.GetCommand(\"h\"), typeof(UnknownCommand), \n                                                        \"unmatched command should be UnknownCommand\");\n    Assert.IsInstanceOfType(Factory.GetCommand(\"help\"), typeof(UnknownCommand), \n                                                        \"unmatched command should be UnknownCommand\");\n}\n```", "```cs\n[TestMethod]\npublic void UpdateQuantityCommand_Successful()\n{\n    Assert.IsInstanceOfType(Factory.GetCommand(\"u\"), \n                            typeof(UpdateQuantityCommand), \n                            \"u should be UpdateQuantityCommand\");\n    Assert.IsInstanceOfType(Factory.GetCommand(\"updatequantity\"), \n                            typeof(UpdateQuantityCommand), \n                            \"updatequantity should be UpdateQuantityCommand\");\n    Assert.IsInstanceOfType(Factory.GetCommand(\"UpdaTEQuantity\"), \n                            typeof(UpdateQuantityCommand), \n                            \"UpdaTEQuantity should be UpdateQuantityCommand\");\n}\n```", "```cs\npublic InventoryCommand GetCommand(string input)\n{\n    switch (input.ToLower())\n    {\n        ...\n    }\n}\n```", "```cs\nIServiceCollection services = new ServiceCollection();\nservices.AddTransient<IUserInterface, ConsoleUserInterface>();\n```", "```cs\nservices.AddTransient<IInventoryCommandFactory, InventoryCommandFactory>();\n```", "```cs\npublic class InventoryCommandFactory : IInventoryCommandFactory\n{\n    private readonly IUserInterface _userInterface;\n\n    public InventoryCommandFactory(IUserInterface userInterface)\n    {\n        _userInterface = userInterface;\n    }\n    ...\n}\n```", "```cs\nIServiceProvider serviceProvider = services.BuildServiceProvider();\nvar service = serviceProvider.GetService<IInventoryCommandFactory>();\nservice.GetCommand(\"a\");\n```", "```cs\ninterface ICatalogService\n{\n    void Run();\n}\n```", "```cs\npublic class CatalogService : ICatalogService\n{\n    private readonly IUserInterface _userInterface;\n    private readonly IInventoryCommandFactory _commandFactory;\n\n    public CatalogService(IUserInterface userInterface, IInventoryCommandFactory commandFactory)\n    {\n        _userInterface = userInterface;\n        _commandFactory = commandFactory;\n    }\n    ...\n}\n```", "```cs\npublic void Run()\n{\n    Greeting();\n\n    var response = _commandFactory.GetCommand(\"?\").RunCommand();\n\n    while (!response.shouldQuit)\n    {\n        // look at this mistake with the ToLower()\n        var input = _userInterface.ReadValue(\"> \").ToLower();\n        var command = _commandFactory.GetCommand(input);\n\n        response = command.RunCommand();\n\n        if (!response.wasSuccessful)\n        {\n            _userInterface.WriteMessage(\"Enter ? to view options.\");\n        }\n    }\n}\n```", "```cs\nclass Program\n{\n    private static void Main(string[] args)\n    {\n        IServiceCollection services = new ServiceCollection();\n        ConfigureServices(services);\n        IServiceProvider serviceProvider = services.BuildServiceProvider();\n\n        var service = serviceProvider.GetService<ICatalogService>();\n        service.Run();\n\n        Console.WriteLine(\"CatalogService has completed.\");\n    }\n\n    private static void ConfigureServices(IServiceCollection services)\n    {\n        // Add application services.\n        services.AddTransient<IUserInterface, ConsoleUserInterface>(); \n        services.AddTransient<ICatalogService, CatalogService>();\n        services.AddTransient<IInventoryCommandFactory, InventoryCommandFactory>(); \n    }\n}\n```"]