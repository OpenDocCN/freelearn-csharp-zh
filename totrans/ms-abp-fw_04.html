<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-45"><em class="italic"><a id="_idTextAnchor044"/>Chapter 3</em>: Step-By-Step Application Development</h1>
			<p>This chapter introduces the fundamentals of ABP Framework by building an example application. The example application is used to manage products on a typical <strong class="bold">CRUD</strong> page (note that a CRUD page is used to <strong class="bold">Create</strong>, <strong class="bold">Read</strong> (view), <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong> entities).</p>
			<p>The example presented in this chapter is more advanced than a simple CRUD page. It implements many aspects of application development with production quality. By the end of this chapter, you will understand the basics, and you will be ready to start development with ABP Framework.</p>
			<p>I will proceed, step by step, in the order of building a real-world project. This chapter consists of the following topics; each represents a step in this process:</p>
			<ul>
				<li>Creating the solution</li>
				<li>Defining the domain objects</li>
				<li><strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) Core and database mappings</li>
				<li>Listing the product data</li>
				<li>Creating products</li>
				<li>Editing products</li>
				<li>Deleting products<p class="callout-heading">User Interface (UI) and Database Preference</p><p class="callout">I prefer <strong class="bold">Razor Pages (MVC)</strong> as the UI framework and <strong class="bold">EF Core</strong> as the database provider. We will cover other UI frameworks and database providers in separate chapters.</p></li>
			</ul>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Technical requirements</h1>
			<p>We will be building an application, so you need to have .NET runtime, ABP CLI, and an IDE/editor installed to build ASP.NET Core projects.</p>
			<p>Please refer to <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>, to learn how to prepare your development environment, as well as create and run the solution.</p>
			<p>You can download the source code of the final application from the GitHub repository at <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Creating the solution</h1>
			<p>The first step is to <a id="_idIndexMarker094"/>create a solution for the product management application. If you've created the <em class="italic">ProductManagement</em> solution in <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>, you can use it. Otherwise, create an empty folder in your computer, open a command-line terminal in this folder, and run the following <strong class="bold">ABP CLI</strong> command to create a new web application:</p>
			<p class="source-code">abp new ProductManagement -t app</p>
			<p>Open the solution in your favorite IDE, create the database, and run the web project. If you have problems with running the solution, please refer to the previous chapter.</p>
			<p>Now we have a running solution. We can start the development by defining the domain objects of the solution.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Defining the domain objects</h1>
			<p>In this section, you <a id="_idIndexMarker095"/>will learn how to define entities with ABP Framework. The domain is simple for this application. We have <strong class="bold">Product</strong> and <strong class="bold">Category</strong> entities and a <strong class="bold">ProductStockState</strong> enum, as shown in <em class="italic">Figure 3.1</em>:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_3.1_B17287.jpg" alt="Figure 3.1 – An example product management domain&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – An example product management domain</p>
			<p>Entities are defined in the <em class="italic">Domain Layer</em> of the <a id="_idIndexMarker096"/>solution, and the domain layer is split into two projects within the solution:</p>
			<ul>
				<li><strong class="bold">ProductManagement.Domain</strong> is used to define your entities, value objects, domain services, repository interfaces, and other core domain-related classes.</li>
				<li><strong class="bold">ProductManagement.Domain.Shared</strong> is used to define some primitive shared types. The types defined in this project are available to all other layers. Typically, we define enums and some constants here. </li>
			</ul>
			<p>So, we can start by creating the <strong class="source-inline">Category</strong> and <strong class="source-inline">Product</strong> entities and the <strong class="source-inline">ProductStockState</strong> enum. </p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Category</h2>
			<p>The <strong class="source-inline">Category</strong> entity<a id="_idIndexMarker097"/> is used to categorize the products. Create a <em class="italic">Categories</em> folder inside the <em class="italic">ProductManagement.Domain</em> project and a <strong class="source-inline">Category</strong> class inside i<a id="_idTextAnchor049"/>t:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using Volo.Abp.Domain.Entities.Auditing;</p>
			<p class="source-code">namespace ProductManagement.Categories</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class Category : AuditedAggregateRoot&lt;Guid&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public string Name { get; set; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Category</strong> is a <a id="_idIndexMarker098"/>class is derived from <strong class="source-inline">AuditedAggregateRoot&lt;Guid&gt;</strong>. Here, <strong class="source-inline">Guid</strong> is the primary key (<strong class="source-inline">Id</strong>) type of the entity. You can use any type of primary key (such as <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, or <strong class="source-inline">string</strong>) as long as your database management system supports it.</p>
			<p><strong class="source-inline">AggregateRoot</strong> is a special type of entity that is used to create the root entity type of an aggregate. An <a id="_idIndexMarker099"/>aggregate<a id="_idIndexMarker100"/> is a <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) concept that we will discuss in greater detail in the upcoming chapters. For now, consider that we inherit the main entities from this class.</p>
			<p>The <strong class="source-inline">AuditedAggregateRoot</strong> class adds some more properties to the <strong class="source-inline">AggregateRoot</strong> class: <strong class="source-inline">CreationTime</strong> as <strong class="source-inline">DateTime</strong>, <strong class="source-inline">CreatorId</strong> as <strong class="source-inline">Guid</strong>, <strong class="source-inline">LastModificationTime</strong> as <strong class="source-inline">DateTime</strong>, and <strong class="source-inline">LastModifierId</strong> as <strong class="source-inline">Guid</strong>. </p>
			<p>ABP automatically sets these properties. For example, when you insert an entity into the database, <strong class="source-inline">CreationTime</strong> is set to the current time, and <strong class="source-inline">CreatorId</strong> is automatically set to the <strong class="source-inline">Id</strong> property of the current user.</p>
			<p>The audit logging system and the base <strong class="source-inline">Audited</strong> classes will be covered in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p class="callout-heading">About Rich Domain Models</p>
			<p class="callout">In this chapter, I keep the entities simple, with public getters and setters. If you want to create rich domain models and apply DDD principles and other best practices, we will discuss them in upcoming chapters.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>ProductStockState</h2>
			<p><strong class="source-inline">ProductStockState</strong> is a<a id="_idIndexMarker101"/> simple enum to set and track the availability of the product in stock.</p>
			<p>Create a <em class="italic">Products</em> folder inside the <em class="italic">ProductManagement.Domain.Shared</em> project and a <strong class="source-inline">ProductStockState</strong> enum insi<a id="_idTextAnchor051"/>de it:</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public enum ProductStockState : byte</p>
			<p class="source-code">    {</p>
			<p class="source-code">        PreOrder,</p>
			<p class="source-code">        InStock,</p>
			<p class="source-code">        NotAvailable,</p>
			<p class="source-code">        Stopped</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We define this <strong class="source-inline">enum</strong> in the <strong class="source-inline">ProductManagement.Domain.Shared</strong> project since we will reuse it in the <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>) and the<a id="_idIndexMarker102"/> UI layer.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Product</h2>
			<p>The <strong class="source-inline">Product</strong> class<a id="_idIndexMarker103"/> represents a real product. I intentionally added different types of properties to show their usages. Create a <em class="italic">Products</em> folder inside the <em class="italic">ProductManagement.Domain</em> project and a <strong class="source-inline">Product</strong> class in<a id="_idTextAnchor053"/>side it:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using Volo.Abp.Domain.Entities.Auditing;</p>
			<p class="source-code">using ProductManagement.Categories;</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class Product : FullAuditedAggregateRoot&lt;Guid&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public Category Category { get; set; }</p>
			<p class="source-code">        public Guid CategoryId { get; set; }</p>
			<p class="source-code">        public string Name { get; set; }</p>
			<p class="source-code">        public float Price { get; set; }</p>
			<p class="source-code">        public bool IsFreeCargo { get; set; }</p>
			<p class="source-code">        public DateTime ReleaseDate { get; set; }</p>
			<p class="source-code">        public ProductStockState StockState { get; set; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This time, I<a id="_idIndexMarker104"/> inherited from <strong class="source-inline">FullAuditedAggregateRoot</strong>, which adds <strong class="source-inline">IsDeleted</strong> as <strong class="source-inline">bool</strong>, <strong class="source-inline">DeletionTime</strong> as <strong class="source-inline">DateTime</strong>, and <strong class="source-inline">DeleterId</strong> as <strong class="source-inline">Guid</strong> properties in addition to the <strong class="source-inline">AuditedAggregateRoot</strong> class used for the <strong class="source-inline">Category</strong> class.</p>
			<p><strong class="source-inline">FullAuditedAggregateRoot</strong> implements the <strong class="source-inline">ISoftDelete</strong> interface, which makes the <a id="_idIndexMarker105"/>entity <strong class="bold">Soft-Delete</strong>. That means it is never deleted from the database but just <em class="italic">marked as deleted</em>. ABP automatically handles all the Soft-Delete logic. You delete the entity as you normally do, but it is not actually deleted. The next time you query, deleted entities are automatically filtered, and you don't get them in the query result unless you intentionally request them. We will return to that feature in the <em class="italic">Using the data filtering system</em> section of <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p class="callout-heading">About the Navigation Properties</p>
			<p class="callout">In this example, <strong class="source-inline">Product.Category</strong> is a navigation property<a id="_idIndexMarker106"/> for the <strong class="source-inline">Category</strong> entity. If you use MongoDB or want to implement DDD truly, you should not add navigation properties to other aggregates. However, for relational databases, it works perfectly and provides flexibility to our code. We will discuss alternative approaches in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>.</p>
			<p>The new files in the solution should look like <em class="italic">Figure 3.2</em>:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_3.2_B17287.jpg" alt="Figure 3.2 – Adding domain objects to the solution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Adding domain objects to the solution</p>
			<p>We've created the domain objects. In addition, we will create a few <strong class="source-inline">const</strong> values to be used later in the application.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>Constants</h2>
			<p>We need to define constant<a id="_idIndexMarker107"/> values for the properties of the entities. We will then use them in the input validation and database mapping phase.</p>
			<p>First, create a <em class="italic">Categories</em> folder inside the <em class="italic">ProductManagement.Domain.Shared</em> project and add a <strong class="source-inline">CategoryConsts</strong> class<a id="_idTextAnchor055"/> inside it:</p>
			<p class="source-code">namespace ProductManagement.Categories</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static class CategoryConsts</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public const int MaxNameLength = 128;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, the <strong class="source-inline">MaxNameLength</strong> value will be<a id="_idIndexMarker108"/> used to implement the constraint for the <strong class="source-inline">Name</strong> property of a <strong class="source-inline">Category</strong> instance.</p>
			<p>Then, create a <strong class="source-inline">ProductConsts</strong> class inside the <em class="italic">Products</em> folder of the <em class="italic">ProductManagement.Domain.Sha<a id="_idTextAnchor056"/>red</em> project:</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static class ProductConsts</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public const int MaxNameLength = 128;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">MaxNameLength</strong> value will be used to implement the constraint for a <strong class="source-inline">Product</strong> instance's <strong class="source-inline">Name</strong> property.</p>
			<p>The <em class="italic">ProductManagement.Domain.Shared</em> project should look similar to <em class="italic">Figure 3.3</em>:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_3.3_B17287.jpg" alt="Figure 3.3 – Adding constant classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Adding constant classes</p>
			<p>Now that the domain layer has been completed, we can now configure the database mappings for EF Core.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor057"/>EF Core and database mappings</h1>
			<p>We are using <strong class="bold">EF Core</strong> in this <a id="_idIndexMarker109"/>application. EF Core is an <strong class="bold">Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) provider<a id="_idIndexMarker110"/> provided by Microsoft. ORMs provide abstractions to make you feel like you are working with objects in your application code rather than the database tables. We will cover ABP's EF Core integration in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>. However, for now, let's focus on how we can use it practically.</p>
			<p>First, we will add entities to the <strong class="source-inline">DbContext</strong> class and define the mappings between entities and database tables. Then, we will use EF Core's <strong class="bold">Code First Migration</strong> approach<a id="_idIndexMarker111"/> to build the necessary code that creates the database tables. Following this, we will look at ABP's <strong class="bold">Data Seeding</strong> system<a id="_idIndexMarker112"/> to insert <a id="_idIndexMarker113"/>some initial data into the database. Finally, we will apply the migrations and seed data to the database to prepare it for the application.</p>
			<p>First, let's start by defining the <strong class="source-inline">DbSet</strong> properties for the entities.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor058"/>Adding entities to the DbContext class</h2>
			<p>EF's <strong class="source-inline">DbContext</strong> class<a id="_idIndexMarker114"/> is the main class that is used to define mappings between entities and database tables. Additionally, it is used to access the database and perform database<a id="_idIndexMarker115"/> operations for the related entities.</p>
			<p>Open the <strong class="source-inline">ProductManagementDbContext</strong> class in the <em class="italic">ProductManagement.EntityFrameworkCore</em> project, and add the following <strong class="source-inline">DbSet</strong> properties inside it (you will need to import the namespaces of the <strong class="source-inline">Product</strong> and <a id="_idTextAnchor059"/><strong class="source-inline">Category</strong> objects):</p>
			<p class="source-code">public DbSet&lt;Product&gt; Products { get; set; }</p>
			<p class="source-code">public DbSet&lt;Category&gt; Categories { get; set; }</p>
			<p>Adding a <strong class="source-inline">DbSet</strong> property for an entity relates the entity with the <strong class="source-inline">DbContext</strong> class. Then, we can use that <strong class="source-inline">DbContext</strong> class to perform database operations for the entity. EF Core can make most of the mapping using conventions based on the property names and types. If you want to customize the default mapping configuration or perform additional configurations, you<a id="_idIndexMarker116"/> have two <a id="_idIndexMarker117"/>options: <strong class="bold">Data Annotations</strong> (attributes) and <strong class="bold">Fluent API</strong>.</p>
			<p>In the data annotation approach, you add attributes, such as <strong class="source-inline">[Required]</strong> and <strong class="source-inline">[StringLength]</strong>, to your entity properties. It is very practical and easy to use. It also makes it easier to understand when you read the source code of your entity.</p>
			<p>One problem<a id="_idIndexMarker118"/> with the data annotation attributes is that they are<a id="_idIndexMarker119"/> limited (compared to the Fluent API) and make your domain layer dependant on the EF Core NuGet package when you need to use EF Core's custom attributes, such as <strong class="source-inline">[Index]</strong> and <strong class="source-inline">[Owned]</strong>. If that's not a problem for you, you can use the data annotation attributes and combine them with the Fluent API where they are not sufficient.</p>
			<p>In this chapter, I will prefer the Fluent API approach, which keeps the entity cleaner and places all the ORM logic inside the infrastructure layer.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor060"/>Mapping entities to the database tables</h2>
			<p>The <strong class="source-inline">ProductManagementDbContext</strong> class (in the <em class="italic">ProductManagement.EntityFrameworkCore</em> project) contains an <strong class="source-inline">OnModelCreating</strong> method to configure mappings of the entities to the database tables. When you <a id="_idIndexMarker120"/>first create your solution, this method looks <a id="_idIndexMarker121"/>like the following:</p>
			<p class="source-code">protected override void OnModelCreating(ModelBuilder builder)</p>
			<p class="source-code">{</p>
			<p class="source-code">    base.OnModelCreating(builder);</p>
			<p class="source-code">    builder.ConfigurePermissionManagement();</p>
			<p class="source-code">    builder.ConfigureSettingManagement();</p>
			<p class="source-code">    builder.ConfigureIdentity();</p>
			<p class="source-code">    ...configuration of the other modules</p>
			<p class="source-code">    /* Configure your own tables/entities here */</p>
			<p class="source-code">}</p>
			<p>Add the<a id="_idIndexMarker122"/> following code<a id="_idIndexMarker123"/> af<a id="_idTextAnchor061"/>ter the preceding comment:</p>
			<p class="source-code">builder.Entity&lt;Category&gt;(b =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">      b.ToTable("Categories");</p>
			<p class="source-code">      b.Property(x =&gt; x.Name)</p>
			<p class="source-code">            .HasMaxLength(CategoryConsts.MaxNameLength)</p>
			<p class="source-code">            .IsRequired();</p>
			<p class="source-code">      b.HasIndex(x =&gt; x.Name);</p>
			<p class="source-code">});</p>
			<p class="source-code">builder.Entity&lt;Product&gt;(b =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">      b.ToTable("Products");</p>
			<p class="source-code">      b.Property(x =&gt; x.Name)</p>
			<p class="source-code">            .HasMaxLength(ProductConsts.MaxNameLength)</p>
			<p class="source-code">            .IsRequired();</p>
			<p class="source-code">      b.HasOne(x =&gt; x.Category)</p>
			<p class="source-code">           .WithMany()</p>
			<p class="source-code">           .HasForeignKey(x =&gt; x.CategoryId)</p>
			<p class="source-code">           .OnDelete(DeleteBehavior.Restrict)</p>
			<p class="source-code">           .IsRequired();</p>
			<p class="source-code">b.HasIndex(x =&gt; x.Name).IsUnique();</p>
			<p class="source-code">});</p>
			<p>This code<a id="_idIndexMarker124"/> part defines <a id="_idIndexMarker125"/>the <strong class="source-inline">Category</strong> and <strong class="source-inline">Product</strong> mapping configurations.</p>
			<p class="callout-heading">About Namespaces</p>
			<p class="callout">You might need to add <strong class="source-inline">using</strong> statements for the namespaces of the <strong class="source-inline">Product</strong> class, the <strong class="source-inline">Category</strong> class, and any other classes used in the code. If you have trouble, you can always refer to the source code in the GitHub repository that I've shared in the <em class="italic">Technical requirements</em> section of this chapter.</p>
			<p>The <strong class="source-inline">Category</strong> entity is mapped to the <em class="italic">Categories</em> database table. We use <strong class="source-inline">CategoryConsts.MaxNameLength</strong> that was defined before to set the maximum length of the <strong class="source-inline">Name</strong> field in the database. The <strong class="source-inline">Name</strong> field is also a <em class="italic">required</em> property. Finally, we define a <em class="italic">unique</em> database index for the <strong class="source-inline">Name</strong> property because it helps search categories by the <strong class="source-inline">Name</strong> field.</p>
			<p>The <strong class="source-inline">Product</strong> mapping is similar to the <strong class="source-inline">Category</strong> mapping. Additionally, it defines a relationship between the <strong class="source-inline">Category</strong> entity and the <strong class="source-inline">Product</strong> entity; a <strong class="source-inline">Product</strong> entity belongs to a <strong class="source-inline">Category</strong> entity, while a <strong class="source-inline">Category</strong> entity can have many related <strong class="source-inline">Product</strong> entities.</p>
			<p class="callout-heading">EF Core Fluent Mapping</p>
			<p class="callout">You can refer to the EF Core documentation to learn about all the details and other options for the Fluent Mapping API.</p>
			<p>The mapping <a id="_idIndexMarker126"/>configuration is complete. It is time to create a database <a id="_idIndexMarker127"/>migration to update the database schema for the newly added entities.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor062"/>The Add-Migration command</h2>
			<p>When you create a new<a id="_idIndexMarker128"/> entity or make changes to an existing entity, you should also create or alter the related table in the database. EF Core's <strong class="bold">Code First Migration</strong> system<a id="_idIndexMarker129"/> is a perfect way to keep the database schema aligned with the application code. Typically, you generate migrations and apply them to the database. A migration is an incremental schema change for the database. When you update the database, all the migrations are applied since the last update, and the database becomes aligned with the application code.</p>
			<p>There are two ways to generate a new migration.</p>
			<h3>With Visual Studio</h3>
			<p>If you <a id="_idIndexMarker130"/>are using<a id="_idIndexMarker131"/> Visual Studio, open <strong class="bold">Package Manager Console (PMC)</strong> from the <strong class="bold">View</strong> | <strong class="bold">Other Windows</strong> | <strong class="bold">Package Manager Console</strong> menu:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_3.4_B17287.jpg" alt="Figure 3.4 – Package Manager Console&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Package Manager Console</p>
			<p>Select the <em class="italic">ProductManagement.EntityFrameworkCore</em> project as the <strong class="bold">Default project</strong> type. Ensure that the <em class="italic">ProductManagement.Web</em> project is selected as the startup project. You can right-click on the <em class="italic">ProductManagement.Web</em> project and click on the <strong class="bold">Set as Startup Project</strong> action.</p>
			<p>Now, you can type the following command into the PMC to add a new migration class:</p>
			<p class="source-code">Add-Migration "Added_Categories_And_Products"</p>
			<p>The output of this command should be similar to <em class="italic">Figure 3.5</em>:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_3.5_B17287.jpg" alt="Figure 3.5 – Output of the Add-Migration command&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Output of the Add-Migration command</p>
			<p>If you get an<a id="_idIndexMarker132"/> error such as <em class="italic">No DbContext was found in assembly…</em>, be sure that you've set the <strong class="bold">Default project</strong> type to<a id="_idIndexMarker133"/> the <em class="italic">ProductManagement.EntityFrameworkCore</em> project.</p>
			<p>If everything goes well, a new migration class should be added inside the <em class="italic">Migrations</em> folder of the <em class="italic">ProductManagement.EntityFrameworkCore</em> project.</p>
			<h3>In the command line</h3>
			<p>If you are not using <a id="_idIndexMarker134"/>Visual Studio, you can use the EF Core <a id="_idIndexMarker135"/>command-line tools. If you haven't installed it yet, execute the following command in a command-line terminal:</p>
			<p class="source-code">dotnet tool install --global dotnet-ef</p>
			<p>Now, open a command-line terminal in the root directory of the <em class="italic">ProductManagement.EntityFrameworkCore</em> project, and type in the following command:</p>
			<p class="source-code">dotnet ef migrations add "Added_Categories_And_Products"</p>
			<p>A new migration class <a id="_idIndexMarker136"/>should be added inside the <em class="italic">Migrations</em> folder of the <em class="italic">ProductManagement.EntityFrameworkCore</em> project.</p>
			<p>Before applying the newly <a id="_idIndexMarker137"/>created migration to the database, I want to mention the data seeding feature of ABP Framework.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor063"/>Seeding data</h2>
			<p>The data seeding system<a id="_idIndexMarker138"/> is used to add some initial data when you migrate the database. For example, the identity module creates an admin user in the database with all permissions granted to log in to the application. </p>
			<p>While data seeding is not essential in our scenario, I want to add some example categories and products to the database to make it easier to develop and test the application.</p>
			<p class="callout-heading">About the EF Core Data Seeding</p>
			<p class="callout">This section uses ABP's <a id="_idIndexMarker139"/>data seed system, while EF Core has its own data seeding feature. The ABP data seed system allows you to inject runtime services and implement advanced logic in your data seed code, and it is suitable for development, test, and production environments. However, for simpler development and test scenarios, you can use EF Core's data seeding system. Please check the official documentation at <a href="https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding">https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding</a>.</p>
			<p>Create a <strong class="source-inline">ProductManagementDataSeedContributor</strong> class in the <em class="italic">Data</em> folder <a id="_idTextAnchor064"/>of the <em class="italic">ProductManagement.Domain</em> project:</p>
			<p class="source-code">using ProductManagement.Categories;</p>
			<p class="source-code">using ProductManagement.Products;</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Volo.Abp.Data;</p>
			<p class="source-code">using Volo.Abp.DependencyInjection;</p>
			<p class="source-code">using Volo.Abp.Domain.Repositories;</p>
			<p class="source-code">namespace ProductManagement.Data</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class ProductManagementDataSeedContributor :</p>
			<p class="source-code">           IDataSeedContributor, ITransientDependency</p>
			<p class="source-code">    {</p>
			<p class="source-code">        private readonly IRepository&lt;Category,                           Guid&gt;_categoryRepository;</p>
			<p class="source-code">        private readonly IRepository&lt;Product,                           Guid&gt;_productRepository;</p>
			<p class="source-code">        public ProductManagementDataSeedContributor(</p>
			<p class="source-code">            IRepository&lt;Category, Guid&gt; categoryRepository,</p>
			<p class="source-code">            IRepository&lt;Product, Guid&gt; productRepository)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _categoryRepository = categoryRepository;</p>
			<p class="source-code">            _productRepository = productRepository;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public async Task SeedAsync(DataSeedContext                     context)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            /***** TODO: Seed initial data here *****/</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This class implements the <strong class="source-inline">IDataSeedContributor</strong> interface. ABP automatically discovers and calls its <strong class="source-inline">SeedAsync</strong> method when you want to seed the database. You can implement constructor injection and use any service in your class (such as the repositories in this example).</p>
			<p>Then, write the <a id="_idIndexMarker140"/>fo<a id="_idTextAnchor065"/>llowing code inside the <strong class="source-inline">SeedAsync</strong> method:</p>
			<p class="source-code">if (await _categoryRepository.CountAsync() &gt; 0)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return;</p>
			<p class="source-code">}</p>
			<p class="source-code">var monitors = new Category { Name = "Monitors" };</p>
			<p class="source-code">var printers = new Category { Name = "Printers" };</p>
			<p class="source-code">await _categoryRepository</p>
			<p class="source-code">    .InsertManyAsync(new[] { monitors, printers });</p>
			<p class="source-code">var monitor1 = new Product</p>
			<p class="source-code">{</p>
			<p class="source-code">    Category = monitors,</p>
			<p class="source-code">    Name = "XP VH240a 23.8-Inch Full HD 1080p IPS LED               Monitor",</p>
			<p class="source-code">    Price = 163,</p>
			<p class="source-code">    ReleaseDate = new DateTime(2019, 05, 24),</p>
			<p class="source-code">    StockState = ProductStockState.InStock</p>
			<p class="source-code">};</p>
			<p class="source-code">var monitor2 = new Product</p>
			<p class="source-code">{</p>
			<p class="source-code">    Category = monitors,</p>
			<p class="source-code">    Name = "Clips 328E1CA 32-Inch Curved Monitor, 4K UHD",</p>
			<p class="source-code">    Price = 349,</p>
			<p class="source-code">    IsFreeCargo = true,</p>
			<p class="source-code">    ReleaseDate = new DateTime(2022, 02, 01),</p>
			<p class="source-code">    StockState = ProductStockState.PreOrder</p>
			<p class="source-code">};</p>
			<p class="source-code">var printer1 = new Product</p>
			<p class="source-code">{</p>
			<p class="source-code">    Category = monitors,</p>
			<p class="source-code">    Name = "Acme Monochrome Laser Printer, Compact All-In           One",</p>
			<p class="source-code">    Price = 199,</p>
			<p class="source-code">    ReleaseDate = new DateTime(2020, 11, 16),</p>
			<p class="source-code">    StockState = ProductStockState.NotAvailable</p>
			<p class="source-code">};</p>
			<p class="source-code">await _productRepository</p>
			<p class="source-code">    .InsertManyAsync(new[] { monitor1, monitor2, printer1 });</p>
			<p>We've created two categories with three products and inserted them into the database. This class is executed whenever you run the <em class="italic">DbMigrator</em> application (please refer to the following section). Additionally, we checked <strong class="source-inline">if (await _categoryRepository.CountAsync() &gt; 0)</strong> to prevent us from inserting the same data in every run.</p>
			<p>We are now ready to migrate the database, which will update the database schema and seed the initial data.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor066"/>Migrating the database</h2>
			<p>The ABP application startup<a id="_idIndexMarker141"/> template includes a <em class="italic">DbMigrator</em> console application that is pretty useful in development and production environments. When you run it, all pending migrations are applied in the database, and the data seeder classes are executed. It supports multi-tenant, multi-database scenarios, which is not possible if you use the standard <strong class="source-inline">Update-Database</strong> command. This application can be deployed and executed in the production environment, typically, as a stage of your <strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>) pipeline. Separating <a id="_idIndexMarker142"/>the migration from the main application is a good approach, as the main application doesn't require permission to alter the database schema in such cases. Also, you can get rid of any concurrency issues you might have if you apply migrations in your main application and run multiple instances of the application.</p>
			<p>Run the <em class="italic">ProductManagement.DbMigrator</em> application to migrate the database (that is, set it as the startup project, and hit <em class="italic">Ctrl</em> + <em class="italic">F5</em>). Once the application exits, you can check the database to see that the <em class="italic">Categories</em> and <em class="italic">Products</em> tables have the initial data inserted (if you are using Visual Studio, you can use <strong class="bold">SQL Server Object Explorer</strong> to connect to <strong class="bold">LocalDB</strong> and explore the databases).</p>
			<p>The EF Core configuration is complete, and the database is ready for development. We will continue by showing the product data on the UI.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor067"/>Listing the product data</h1>
			<p>I prefer to develop the application functionality feature by feature. This section will explain how to show a list of the products in a data table on the UI.</p>
			<p>We will <a id="_idIndexMarker143"/>begin by defining a <strong class="bold">DTO</strong>, <strong class="source-inline">ProductDto</strong>, for the <strong class="source-inline">Product</strong> entity. Then, we will create an application service method that returns a list of products to the presentation layer. Additionally, we will learn how to map the <strong class="source-inline">Product</strong> entity to <strong class="source-inline">ProductDto</strong> automatically.</p>
			<p>Before creating the UI, I will show you how to write an <strong class="bold">Automated Test</strong> for the application service. In this way, we will be sure that the application service is working properly before starting the UI development.</p>
			<p>Throughout the<a id="_idIndexMarker144"/> development, we will explore some benefits of ABP Framework, such as the automatic API controller and dynamic JavaScript Proxy systems.</p>
			<p>Finally, we will create a new page, add a data table inside it, get a list of the products from the server, and show it on the UI.</p>
			<p>In the next section, we will begin by creating a <strong class="source-inline">ProductDto</strong> class.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor068"/>The ProductDto class</h2>
			<p>DTOs are used to transfer data between the application and presentation layers. It is best practice to return DTOs to the presentation (UI) layer instead of the entities. DTOs allow you to expose data in a<a id="_idIndexMarker145"/> controlled way and abstract your entities from the presentation layer. Directly exposing entities to the presentation layer might cause serialization and security problems, too. We will discuss the benefits of using DTOs in <a href="B17287_11_Epub_AM.xhtml#_idTextAnchor340"><em class="italic">Chapter 11</em></a>, <em class="italic">DDD – The Application Layer</em>.</p>
			<p>DTOs are defined in the <em class="italic">Application.Contracts</em> project to make them available within the UI layer. So, we start by creating a <strong class="source-inline">ProductDto</strong> class inside the <em class="italic">Products</em> folder of the <em class="italic">Pr<a id="_idTextAnchor069"/>oductManagement.Application.Contracts</em> project:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using Volo.Abp.Application.Dtos;</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class ProductDto : AuditedEntityDto&lt;Guid&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public Guid CategoryId { get; set; }</p>
			<p class="source-code">        public string CategoryName { get; set; }</p>
			<p class="source-code">        public string Name { get; set; }</p>
			<p class="source-code">        public float Price { get; set; }</p>
			<p class="source-code">        public bool IsFreeCargo { get; set; }</p>
			<p class="source-code">        public DateTime ReleaseDate { get; set; }</p>
			<p class="source-code">        public ProductStockState StockState { get; set; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">ProductDto</strong> class is <a id="_idIndexMarker146"/>a similar class to the <strong class="source-inline">Product</strong> entity with the following differences:</p>
			<ul>
				<li>It is derived from <strong class="source-inline">AuditedEntityDto&lt;Guid&gt;</strong>, which defines the <strong class="source-inline">Id</strong>, <strong class="source-inline">CreationTime</strong>, <strong class="source-inline">CreatorId</strong>, <strong class="source-inline">LastModificationTime</strong>, and <strong class="source-inline">LastModifierId</strong> properties (we don't need to delete auditing properties, such as <strong class="source-inline">DeletionTime</strong>, since the deleted entities are not read from the database).</li>
				<li>Instead of adding a navigation property to the <strong class="source-inline">Category</strong> entity, we used a <strong class="source-inline">string</strong> <strong class="source-inline">CategoryName</strong> property, which is enough to show on the UI.</li>
			</ul>
			<p>We will use the <strong class="source-inline">ProductDto</strong> class to return a list of products from the <strong class="source-inline">IProductAppService</strong> interface.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor070"/>IProductAppService</h2>
			<p><strong class="bold">Application Services</strong> implement <a id="_idIndexMarker147"/>the use <a id="_idIndexMarker148"/>cases of an application. The UI uses them to perform business logic on user interactions. Typically, an application service method gets and returns DTOs.</p>
			<p class="callout-heading">Application Services versus API Controllers</p>
			<p class="callout">You could compare application services with API controllers in an ASP.NET Core MVC application. While they have similarities for some use cases, application services are plain classes that better fit into DDD. They don't depend on a particular UI technology. In addition, ABP can automatically expose your application services as HTTP APIs, as we will discover in the <em class="italic">Auto API Controllers and the Swagger UI</em> section of this chapter.</p>
			<p>We define interfaces for application services in the <em class="italic">Application.Contracts</em> project of the solution. Create an <strong class="source-inline">IProductAppService</strong> interface inside the <em class="italic">Products</em> folder of the<a id="_idTextAnchor071"/> <em class="italic">ProductManagement.Application.Contracts</em> project:</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Volo.Abp.Application.Dtos;</p>
			<p class="source-code">using Volo.Abp.Application.Services;</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public interface IProductAppService :                           IApplicationService</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Task&lt;PagedResultDto&lt;ProductDto&gt;&gt;</p>
			<p class="source-code">            GetListAsync(PagedAndSortedResultRequestDto                     input);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>You can see some <a id="_idIndexMarker149"/>predefined ABP types in the preceding code block:</p>
			<ul>
				<li><strong class="source-inline">IProductAppService</strong> is derived from the <strong class="source-inline">IApplicationService</strong> interface. In this way, ABP can recognize the application services.</li>
				<li>The <strong class="source-inline">GetListAsync</strong> method gets <strong class="source-inline">PagedAndSortedResultRequestDto</strong>, which is a standard DTO class of ABP Framework that defines the <strong class="source-inline">MaxResultCount</strong> (int), <strong class="source-inline">SkipCount</strong> (int), and <strong class="source-inline">Sorting</strong> (string) properties.</li>
				<li>The <strong class="source-inline">GetListAsync</strong> method returns <strong class="source-inline">PagedResultDto&lt;ProductDto&gt;</strong>, which contains a <strong class="source-inline">TotalCount</strong> (long) property and an <strong class="source-inline">Items</strong> collection of <strong class="source-inline">ProductDto</strong> objects. That is a convenient way of returning paged results with ABP Framework.</li>
			</ul>
			<p>You could use your own DTOs instead of these predefined DTO types. However, they are pretty helpful when you want to standardize some common patterns and use the same naming everywhere.</p>
			<p class="callout-heading">Asynchronous Methods</p>
			<p class="callout">It is a best practice to define all the application service methods as asynchronous. If you define synchronous application service methods, in some cases, certain ABP features (such as Unit of Work) might not work as expected.</p>
			<p>Now, we can implement the <strong class="source-inline">IProductAppService</strong> interface to perform the use case.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor072"/>ProductAppService</h2>
			<p>Create a <strong class="source-inline">ProductAppService</strong> class<a id="_idIndexMarker150"/> inside the <em class="italic">Products</em> f<a id="_idTextAnchor073"/>older of the <em class="italic">ProductManagement.Application</em> project:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">u<a id="_idTextAnchor074"/>sing System.Collections.Generic;</p>
			<p class="source-code">using System.Linq;</p>
			<p class="source-code">using System.Linq.Dynamic.Core;</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Volo.Abp.Application.Dtos;</p>
			<p class="source-code">using Volo.Abp.Domain.Repositories;</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class ProductAppService :</p>
			<p class="source-code">        ProductManagementAppService, IProductAppService</p>
			<p class="source-code">    {</p>
			<p class="source-code">        private readonly IRepository&lt;Product, Guid&gt;                     _productRepository;</p>
			<p class="source-code">        public ProductAppService(</p>
			<p class="source-code">            IRepository&lt;Product, Guid&gt; productRepository)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _productRepository = productRepository;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public async Task&lt;PagedResultDto&lt;ProductDto&gt;&gt;                   GetListAsync(</p>
			<p class="source-code">            PagedAndSortedResultRequestDto input)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            /* TODO: Implementation */</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">ProductAppService</strong> class is<a id="_idIndexMarker151"/> derived from <strong class="source-inline">ProductManagementAppService</strong>, which was defined in the startup template, and can be used as the base class for your application services. It implements the <strong class="source-inline">IProductAppService</strong> interface that was previously defined. It injects the <strong class="source-inline">IRepository&lt;Product, Guid&gt;</strong> service. This is called <a id="_idIndexMarker152"/>a <strong class="bold">Default Repository</strong>. A repository is a collection-like interface that allows you to perform operations on the database. ABP automatically provides default repository implementations for all aggregate root entities.</p>
			<p>We can implement the <strong class="source-inline">GetLi<a id="_idTextAnchor075"/>stAsync</strong> method, as shown in the following code block:</p>
			<p class="source-code">public async Task&lt;PagedResultDto&lt;ProductDto&gt;&gt; GetListAsync(</p>
			<p class="source-code">    PagedAndSortedResultRequestDto input)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var queryable = await _productRepository</p>
			<p class="source-code">        .WithDetailsAsync(x =&gt; x.Category);</p>
			<p class="source-code">    queryable = queryable</p>
			<p class="source-code">        .Skip(input.SkipCount)</p>
			<p class="source-code">        .Take(input.MaxResultCount)</p>
			<p class="source-code">        .OrderBy(input.Sorting ?? nameof(Product.Name));</p>
			<p class="source-code">    var products = await                                             AsyncExecuter.ToListAsync(queryable);</p>
			<p class="source-code">    var count = await _productRepository.GetCountAsync();</p>
			<p class="source-code">    return new PagedResultDto&lt;ProductDto&gt;(</p>
			<p class="source-code">        count,</p>
			<p class="source-code">        ObjectMapper.Map&lt;List&lt;Product&gt;, List&lt;ProductDto&gt;&gt;                (products)</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">_productRepository.WithDetailsAsync</strong> returns an <strong class="source-inline">IQueryable&lt;Product&gt;</strong> object <a id="_idIndexMarker153"/>by including the categories (the <strong class="source-inline">WithDetailsAsync</strong> method is similar to EF Core's <strong class="source-inline">Include</strong> extension method, which loads the related data into the query). We can use the standard <strong class="bold">Language-Integrated Query</strong> (<strong class="bold">LINQ</strong>) extension <a id="_idIndexMarker154"/>methods such as <strong class="source-inline">Skip</strong>, <strong class="source-inline">Take</strong>, and <strong class="source-inline">OrderBy</strong> on the queryable object.</p>
			<p>The <strong class="source-inline">AsyncExecuter</strong> service (which is pre-injected in the base class) is used to execute the <strong class="source-inline">IQueryable</strong> object to perform a database query asynchronously. This makes it possible to use the async LINQ extension methods without depending on the EF Core package in the application layer.</p>
			<p>Finally, we are using the <strong class="source-inline">ObjectMapper</strong> service (pre-injected in the base class) to map a list of <strong class="source-inline">Product</strong> (entity) objects to a <strong class="source-inline">ProductDto</strong> (DTO) object list. In the next section, we will explain how the object mapping is configured.</p>
			<p class="callout-heading">Repositories and Async Query Execution</p>
			<p class="callout">We will explore <strong class="source-inline">IRepository</strong> and <strong class="source-inline">AsyncExecuter</strong> in greater detail in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor076"/>Object to object mapping</h2>
			<p><strong class="source-inline">ObjectMapper</strong> (the <strong class="source-inline">IObjectMapper</strong> service) automates type conversions and uses the <strong class="bold">AutoMapper</strong> library<a id="_idIndexMarker155"/> by default. It requires you to define the mapping before <a id="_idIndexMarker156"/>using it. The startup template contains a profile class that you can create the mappings inside.</p>
			<p>Open the <strong class="source-inline">ProductManagementApplicationAutoMapperProfile</strong> class in the <em class="italic">ProductManage<a id="_idTextAnchor077"/>ment.Application</em> project, and change it to the following:</p>
			<p class="source-code">using AutoMapper;</p>
			<p class="source-code">using ProductManagement.Products;</p>
			<p class="source-code">namespace ProductManagement</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class ProductManagementApplicationAutoMapperProfile</p>
			<p class="source-code">        : Profile</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public ProductManagementApplicationAutoMapperProfile()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            CreateMap&lt;Product, ProductDto&gt;();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">CreateMap</strong> defines the mapping. Then, you can automatically convert <strong class="source-inline">Product</strong> objects into <strong class="source-inline">ProductDto</strong> objects where you need them.</p>
			<p>One of the <a id="_idIndexMarker157"/>interesting AutoMapper features is <strong class="bold">Flattening</strong>. This involves<a id="_idIndexMarker158"/> taking a complex object model and flattening it into a simpler model. In this example, the <strong class="source-inline">Product</strong> class has a <strong class="source-inline">Category</strong> property, and the <strong class="source-inline">Category</strong> class has a <strong class="source-inline">Name</strong> property. So, if you want to access the category name of a product, you should use the <strong class="source-inline">Product.Category.Name</strong> expression. However, <strong class="source-inline">ProductDto</strong> has a direct <strong class="source-inline">CategoryName</strong> property that can be accessed using the <strong class="source-inline">ProductDto.CategoryName</strong> expression. AutoMapper automatically maps these expressions by flattening <strong class="source-inline">Category.Name</strong> into <strong class="source-inline">CategoryName</strong>.</p>
			<p>The application layer is complete. Before starting the UI, I want to show you how to write automated tests for the application layer.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor078"/>Testing the ProductAppService class</h2>
			<p>The startup template comes with the test infrastructure properly configured using the <strong class="bold">xUnit</strong>, <strong class="bold">Shouldly</strong>, and <strong class="bold">NSubstitute</strong> libraries. It uses the <em class="italic">SQLite in-memory</em> database to mock the database. A separate database is created for each test. It is seeded and destroyed at the end of the<a id="_idIndexMarker159"/> test. In this way, tests do not affect each other, and your real database remains untouched.</p>
			<p><a href="B17287_17_Epub_AM.xhtml#_idTextAnchor476"><em class="italic">Chapter 17</em></a>, <em class="italic">Building Automated Tests</em>, will explore all the details of testing. However, here, I want to show you how you can easily write some automated test code for the <strong class="source-inline">GetListAsync</strong> method of the <strong class="source-inline">ProductAppService</strong> class. It is good to write the test code for the application services before using them on the UI.</p>
			<p>Create a <em class="italic">Products</em> folder in the <em class="italic">ProductManagement.Application.Tests</em> pr<a id="_idTextAnchor079"/>oject, and create a <strong class="source-inline">ProductAppService_Tests</strong> class inside it:</p>
			<p class="source-code">using Shouldly;</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Volo.Abp.Application.Dtos;</p>
			<p class="source-code">using Xunit;</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class ProductAppService_Tests</p>
			<p class="source-code">        : ProductManagementApplicationTestBase</p>
			<p class="source-code">    {</p>
			<p class="source-code">        private readonly IProductAppService                             _productAppService;</p>
			<p class="source-code">        public ProductAppService_Tests()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _productAppService =</p>
			<p class="source-code">                GetRequiredService&lt;IProductAppService&gt;();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        /* TODO: Test methods */</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This class<a id="_idIndexMarker160"/> inherits from the <strong class="source-inline">ProductManagementApplicationTestBase</strong> class (which is included in your solution) that integrates ABP Framework and other infrastructure libraries and makes it possible to write our tests. Instead of constructor injection (which is not possible in tests), we use the <strong class="source-inline">GetRequiredService</strong> method to resolve dependencies in the test code.</p>
			<p>Now, we can write the first test method. Add t<a id="_idTextAnchor080"/>he following method inside the <strong class="source-inline">ProductAppService_Tests</strong> class:</p>
			<p class="source-code">[Fact]</p>
			<p class="source-code">public async Task Should_Get_Product_List()</p>
			<p class="source-code">{</p>
			<p class="source-code">    //Act</p>
			<p class="source-code">    var output = await _productAppService.GetListAsync(</p>
			<p class="source-code">        new PagedAndSortedResultRequestDto()</p>
			<p class="source-code">    );</p>
			<p class="source-code">    //Assert</p>
			<p class="source-code">    output.TotalCount.ShouldBe(3);</p>
			<p class="source-code">    output.Items.ShouldContain(</p>
			<p class="source-code">        x =&gt; x.Name.Contains("Acme Monochrome Laser                     Printer")</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p>This method <a id="_idIndexMarker161"/>calls the <strong class="source-inline">GetListAsync</strong> method and checks whether the result is correct. If you open the <strong class="bold">Test Explorer</strong> window (under the <strong class="bold">View</strong> | <strong class="bold">Test Explorer</strong> menu in Visual Studio), you can see the test method that we've added. <strong class="bold">Test Explorer</strong> is used for showing and running the tests in the solution:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_3.6_B17287.jpg" alt="Figure 3.6 – The Test Explorer window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The Test Explorer window</p>
			<p>Run the test to <a id="_idIndexMarker162"/>check whether it is working as expected. If the <strong class="source-inline">GetListAsync</strong> method works properly, you will see a green icon on the left-hand side of the test method name, as shown in <em class="italic">Figure 3.6</em>. Unit and integration tests will be covered in <a href="B17287_17_Epub_AM.xhtml#_idTextAnchor476"><em class="italic">Chapter 17</em></a>, <em class="italic">Building Automated Tests</em>.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor081"/>Auto API Controllers and the Swagger UI</h2>
			<p><strong class="bold">Swagger</strong> is a popular <a id="_idIndexMarker163"/>tool in which to explore and test HTTP APIs. It comes preinstalled with the startup template.</p>
			<p>Run the <em class="italic">ProductManagement.Web</em> project to start the web application (set it as the startup project if not done so already, and hit <em class="italic">Ctrl</em> + <em class="italic">F5</em>). Once the application starts, enter the <strong class="source-inline">/swagger</strong> URL, as shown in <em class="italic">Figure 3.7</em>:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_3.7_B17287.jpg" alt="Figure 3.7 – The Swagger UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The Swagger UI</p>
			<p>You will see a lot of API <a id="_idIndexMarker164"/>endpoints coming from the modules installed in the application. If you scroll down, you will see a <strong class="bold">Product</strong> endpoint, too. You can test it to get the list of products:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.8_B17287.jpg" alt="Figure 3.8 – The Product endpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – The Product endpoint</p>
			<p>We haven't created a <em class="italic">ProductController</em> endpoint yet. So, how is this endpoint available here? This is known as<a id="_idIndexMarker165"/> the <strong class="bold">Auto API Controller</strong> feature of ABP Framework. It automatically exposes your application services as HTTP APIs based on naming conventions and configurations. Typically, we don't write the controllers manually.</p>
			<p>The Auto API Controller feature will be covered in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>, in detail.</p>
			<p>So, we have the HTTP API to get the list of products. The next step is to consume this API from the client code.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor082"/>Dynamic JavaScript proxies</h2>
			<p>Typically, you call the<a id="_idIndexMarker166"/> HTTP API endpoints from your JavaScript code. ABP dynamically creates client-side proxies for all HTTP APIs. Then, you can use these dynamic JavaScript functions to consume your APIs from the client application.</p>
			<p>Run the <em class="italic">ProductManagement.Web</em> project again, and open the <strong class="bold">Developer Console</strong> of the browser while you are on the application's landing page. The developer console is available in any modern browser and is typically opened using the <em class="italic">F12</em> shortcut key (on Windows). It is used to explore, trace, and debug the application by developers.</p>
			<p>Open the <strong class="bold">Console</strong> tab, and type in the following JavaScript code:</p>
			<p class="source-code">productManagement.products.product.getList({}).then(function(result) {</p>
			<p class="source-code">    console.log(result);</p>
			<p class="source-code">});</p>
			<p>Once you execute this code, a request is made to the server, and the returning result is logged in the <strong class="bold">Console</strong> tab, as shown in <em class="italic">Figure 3.9</em>:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.9_B17287.jpg" alt="Figure 3.9 – Using the dynamic JavaScript proxies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Using the dynamic JavaScript proxies</p>
			<p>We can see<a id="_idIndexMarker167"/> that the product list is logged in the <strong class="bold">Console</strong> tab. That means we can easily consume server-side APIs from JavaScript code without having to deal with the low-level details.</p>
			<p>If you are wondering where that <strong class="source-inline">getList</strong> JavaScript is defined, you can check the <strong class="source-inline">/Abp/ServiceProxyScript</strong> endpoint in your application to see the JavaScript proxy functions dynamically created by ABP Framework.</p>
			<p>In the next section, we will create a <strong class="bold">Razor Page</strong> to show the table of products on the UI.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor083"/>Creating a products page</h2>
			<p>Razor Pages is the recommended<a id="_idIndexMarker168"/> way of creating a UI in the ASP.NET Core MVC framework.</p>
			<p>First, create a <em class="italic">Products</em> folder under the <em class="italic">Pages</em> folder of the <em class="italic">ProductManagement.Web</em> project. Then, add a new, empty razor page by right-clicking on the <em class="italic">Products</em> folder and then selecting <strong class="bold">Add</strong> | <strong class="bold">Razor Page</strong>. Select the <strong class="bold">Razor Page - Empty</strong> option. Name it <strong class="source-inline">Index.cshtml</strong>. <em class="italic">Figure 3.10</em> shows the location of the page that we've added:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.10_B17287.jpg" alt="Figure 3.10 – Creating a Razor Page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Creating a Razor Page</p>
			<p>Edit<a id="_idTextAnchor084"/> the <strong class="source-inline">Index.cshtml</strong> content, as shown in the following code block:</p>
			<p class="source-code">@page</p>
			<p class="source-code">@using ProductManagement.Web.Pages.Products</p>
			<p class="source-code">@model IndexModel</p>
			<p class="source-code">&lt;h1&gt;Products Page&lt;/h1&gt;</p>
			<p>Here, I've just<a id="_idIndexMarker169"/> placed an <strong class="source-inline">h1</strong> element as the page header. When we create a page, typically, we want to add an item to the main menu to open this page.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor085"/>Adding a new menu item</h2>
			<p>ABP provides a dynamic<a id="_idIndexMarker170"/> and modular menu system. Every module can add items to the main menu.</p>
			<p>Open the <strong class="source-inline">ProductManagementMenuContributor</strong> class in the <em class="italic">Menus</em> folder of the <em class="italic">ProductManagement.Web</em> project, and add t<a id="_idTextAnchor086"/>he following code at the end of the <strong class="source-inline">ConfigureMainMenuAsync</strong> method:</p>
			<p class="source-code">context.Menu.AddItem(</p>
			<p class="source-code">    new ApplicationMenuItem(</p>
			<p class="source-code">        "ProductManagement",</p>
			<p class="source-code">        l["Menu:ProductManagement"],</p>
			<p class="source-code">        icon: "fas fa-shopping-cart"</p>
			<p class="source-code">            ).AddItem(</p>
			<p class="source-code">        new ApplicationMenuItem(</p>
			<p class="source-code">            "ProductManagement.Products",</p>
			<p class="source-code">            l["Menu:Products"],</p>
			<p class="source-code">            url: "/Products"</p>
			<p class="source-code">        )</p>
			<p class="source-code">    )</p>
			<p class="source-code">);</p>
			<p>This code adds a <em class="italic">Product Management</em> main menu item with the <em class="italic">Products</em> menu item inside it. It uses localization keys (with the <strong class="source-inline">l["…"]</strong> syntax) that we should define. Open the <strong class="source-inline">en.json</strong> file in the <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared</em> proje<a id="_idTextAnchor087"/>ct, and add the following entries to the end of the <strong class="source-inline">texts</strong> section:</p>
			<p class="source-code">"Menu:ProductManagement": "Product Management",</p>
			<p class="source-code">"Menu:Products": "Products"</p>
			<p>Localization keys are arbitrary, which means you can use any string value as the localization key. I prefer to use the <strong class="source-inline">Menu:</strong> prefix for the localization keys of menu items, such as <strong class="source-inline">Menu:Products</strong>, in this example. We will return to the topic of localization in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p>Now, you can rerun the application and open the <em class="italic">Products</em> page using the new <em class="italic">Product Management</em> menu <a id="_idIndexMarker171"/>item, as shown in <em class="italic">Figure 3.11</em>:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.11_B17287.jpg" alt="Figure 3.11 – The Products page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The Products page</p>
			<p>So, we've created a page and can open the page using the menu element. We are ready to create a data table to show the list of products.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor088"/>Creating the products data table</h2>
			<p>We will create a<a id="_idIndexMarker172"/> data table to show the list of products with paging and sorting. The ABP startup template comes with the <strong class="bold">Datatables.net</strong> JavaScript library preinstalled and configured. It is a flexible and feature-rich library to show tabular data.</p>
			<p>Open the <strong class="source-inline">Index.cshtml</strong> page (in th<a id="_idTextAnchor089"/>e <em class="italic">Pages/Products</em> folder), and change its contents to the following:</p>
			<p class="source-code">@page</p>
			<p class="source-code">@using ProductManagement.Web.Pages.Products</p>
			<p class="source-code">@using Microsoft.Extensions.Localization</p>
			<p class="source-code">@using ProductManagement.Localization</p>
			<p class="source-code">@model IndexModel</p>
			<p class="source-code">@inject IStringLocalizer&lt;ProductManagementResource&gt; L</p>
			<p class="source-code">@section scripts</p>
			<p class="source-code">{</p>
			<p class="source-code">    &lt;abp-script src="/Pages/Products/Index.cshtml.js" /&gt;</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;abp-card&gt;</p>
			<p class="source-code">    &lt;abp-card-header&gt;</p>
			<p class="source-code">        &lt;h2&gt;@L["Menu:Products"]&lt;/h2&gt;</p>
			<p class="source-code">    &lt;/abp-card-header&gt;</p>
			<p class="source-code">    &lt;abp-card-body&gt;</p>
			<p class="source-code">        &lt;abp-table id="ProductsTable" striped-rows="true" /&gt;</p>
			<p class="source-code">    &lt;/abp-card-body&gt;</p>
			<p class="source-code">&lt;/abp-card&gt;</p>
			<p>Here, <strong class="source-inline">abp-script</strong> is an ABP tag helper for adding script files to the page with automatic bundling, minification, and versioning support. <strong class="source-inline">abp-card</strong> is another tag helper to render a <a id="_idIndexMarker173"/>card component in a type-safe and easy way (it renders a Bootstrap card).</p>
			<p>We could use the standard HTML tags. However, ABP tag helpers dramatically simplify UI creation in MVC/Razor Page applications. Additionally, they prevent errors with the help of IntelliSense and compile-time type checking. We will investigate tag helpers in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>.</p>
			<p>Create a new JavaScript file, named <strong class="source-inline">Index.cshtml.js</strong> (you might prefer a different naming style, such as <strong class="source-inline">index.js</strong>; that's fine, as long as you use the same file name in the <strong class="source-inline">abp-scri<a id="_idTextAnchor090"/>pt</strong> tag), under the <em class="italic">Pages/Products</em> folder with the following content:</p>
			<p class="source-code">$(function () {</p>
			<p class="source-code">    var l = abp.localization.getResource('ProductManagement');</p>
			<p class="source-code">    var dataTable = $('#ProductsTable').DataTable(</p>
			<p class="source-code">        abp.libs.datatables.normalizeConfiguration({</p>
			<p class="source-code">            serverSide: true,</p>
			<p class="source-code">            paging: true,</p>
			<p class="source-code">            order: [[0, "asc"]],</p>
			<p class="source-code">            searching: false,</p>
			<p class="source-code">            scrollX: true,</p>
			<p class="source-code">            ajax: abp.libs.datatables.createAjax(</p>
			<p class="source-code">                productManagement.products.product.getList),</p>
			<p class="source-code">            columnDefs: [</p>
			<p class="source-code">                /* TODO: Column definitions */</p>
			<p class="source-code">            ]</p>
			<p class="source-code">        })</p>
			<p class="source-code">    );</p>
			<p class="source-code">});</p>
			<p>ABP allows you to <a id="_idIndexMarker174"/>reuse the localization texts in your JavaScript code. In this way, you can define them on the server side and use them on both sides. <strong class="source-inline">abp.localization.getResource</strong> returns a function to localize the values.</p>
			<p>ABP simplifies the data table's library configuration and provides built-in integrations:</p>
			<ul>
				<li><strong class="source-inline">abp.libs.datatables.normalizeConfiguration</strong> is a helper function defined by ABP Framework. It simplifies the data table's configuration by providing conventional default values for missing options.</li>
				<li><strong class="source-inline">abp.libs.datatables.createAjax</strong> is another helper function that adapts ABP's dynamic JavaScript client proxies to the data table's parameter format.</li>
				<li><strong class="source-inline">productManagement.products.product.getList</strong> is the dynamic JavaScript proxy function introduced earli<a id="_idTextAnchor091"/>er.</li>
			</ul>
			<p>Define the columns <a id="_idIndexMarker175"/>of the data table inside the <strong class="source-inline">columnDefs</strong> array:</p>
			<p class="source-code">{</p>
			<p class="source-code">    title: l('Name'),</p>
			<p class="source-code">    data: "name"</p>
			<p class="source-code">},</p>
			<p class="source-code">{</p>
			<p class="source-code">    title: l('CategoryName'),</p>
			<p class="source-code">    data: "categoryName",</p>
			<p class="source-code">    orderable: false</p>
			<p class="source-code">},</p>
			<p class="source-code">{</p>
			<p class="source-code">    title: l('Price'),</p>
			<p class="source-code">    data: "price"</p>
			<p class="source-code">},</p>
			<p class="source-code">{</p>
			<p class="source-code">    title: l('StockState'),</p>
			<p class="source-code">    data: "stockState",</p>
			<p class="source-code">    render: function (data) {</p>
			<p class="source-code">        return l('Enum:StockState:' + data);</p>
			<p class="source-code">    }</p>
			<p class="source-code">},</p>
			<p class="source-code">{</p>
			<p class="source-code">    title: l('CreationTime'),</p>
			<p class="source-code">    data: "creationTime",</p>
			<p class="source-code">    dataFormat: 'date'</p>
			<p class="source-code">}</p>
			<p>Typically, a column definition has a <strong class="source-inline">title</strong> field (display name) and a <strong class="source-inline">data</strong> field. The data field matches the property names in the <strong class="source-inline">ProductDto</strong> class, formatted as <strong class="bold">camelCase</strong> (a naming style in which the first letter of each word is capitalized, except for the first word; it is <a id="_idIndexMarker176"/>commonly used in the JavaScript language).</p>
			<p>The <strong class="source-inline">render</strong> option can be <a id="_idIndexMarker177"/>used to finely control how to show the column data. We are providing a function to customize the rendering of the stock state column.</p>
			<p>On this page, we've used some localization keys. We should define them in the localization resource. Open the <strong class="source-inline">en.json</strong> file in the <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared<a id="_idTextAnchor092"/></em> project, and add the following entries at the end of the <strong class="source-inline">texts</strong> section:</p>
			<p class="source-code">"Name": "Name",</p>
			<p class="source-code">"CategoryName": "Category name",</p>
			<p class="source-code">"Price": "Price",</p>
			<p class="source-code">"StockState": "Stock state",</p>
			<p class="source-code">"Enum:StockState:0": "Pre-order",</p>
			<p class="source-code">"Enum:StockState:1": "In stock",</p>
			<p class="source-code">"Enum:StockState:2": "Not available",</p>
			<p class="source-code">"Enum:StockState:3": "Stopped",</p>
			<p class="source-code">"CreationTime": "Creation time"</p>
			<p>You can run the web <a id="_idIndexMarker178"/>application again to see the product data table in action:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.12_B17287.jpg" alt="Figure 3.12 – The Products data table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – The Products data table</p>
			<p>We've created a fully working page that lists the products with paging and sorting support. In the next sections, we will add functionality to create, edit, and delete the products.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor093"/>Creating products</h1>
			<p>In this section, we will<a id="_idIndexMarker179"/> create the necessary functionality to add a new product. A product should have a category. So, we should select a category while adding a new product. We will define new application service methods to get categories and create products. In the UI section, we will use ABP's dynamic form feature to automatically generate the product creation form, based on a C# class.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor094"/>Application service contracts</h2>
			<p>L<a id="_idTextAnchor095"/>et's start by adding <a id="_idIndexMarker180"/>two new methods to the <strong class="source-inline">IProductAppService</strong> interface:</p>
			<p class="source-code">Task CreateAsync(CreateUpdateProductDto input);</p>
			<p class="source-code">Task&lt;ListResultDto&lt;CategoryLookupDto&gt;&gt; GetCategoriesAsync();</p>
			<p>We will use the <strong class="source-inline">GetCategoriesAsync</strong> method to show a drop-down list of categories on product creation. We've introduced two new DTOs, and we should define them.</p>
			<p><strong class="source-inline">CreateUpdateProductDto</strong> is used to create and update products (we will reuse it in the <em class="italic">Editing products</em> section). Define it in t<a id="_idTextAnchor096"/>he <em class="italic">Products</em> folder of the <em class="italic">ProductManagement.Application.Contracts</em> project:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using System.ComponentModel.DataAnnotations;</p>
			<p class="source-code">namespace ProductManagement.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class CreateUpdateProductDto</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public Guid CategoryId { get; set; }</p>
			<p class="source-code">        [Required]</p>
			<p class="source-code">        [StringLength(ProductConsts.MaxNameLength)]</p>
			<p class="source-code">        public string Name { get; set; }</p>
			<p class="source-code">        public float Price { get; set; }</p>
			<p class="source-code">        public bool IsFreeCargo { get; set; }</p>
			<p class="source-code">        public DateTime ReleaseDate { get; set; }</p>
			<p class="source-code">        public ProductStockState StockState { get; set; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Next, define<a id="_idIndexMarker181"/> a <strong class="source-inline">CategoryLookupDto</strong> class in the <em class="italic">Categories</em> folder of the <em class="italic">ProductManagement.Application.Contracts</em> project:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">namespace <a id="_idTextAnchor097"/>ProductManagement.Categories</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class CategoryLookupDto</p>
			<p class="source-code">    {</p>
			<p class="source-code">        public Guid Id { get; set; }</p>
			<p class="source-code">        public string Name { get; set; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We've created the contracts, so now we can implement the contracts in the application layer.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor098"/>Application service implementation</h2>
			<p>Implement <a id="_idIndexMarker182"/>the <strong class="source-inline">CreateAsync</strong> and <strong class="source-inline">GetCategoriesAsync</strong> methods in <strong class="source-inline">ProductAppService</strong> (in the <em class="italic">P<a id="_idTextAnchor099"/>roductManagement.Application</em> project), as shown in the following code block:</p>
			<p class="source-code">public async Task CreateAsync(CreateUpdateProductDto input)</p>
			<p class="source-code">{</p>
			<p class="source-code">    await _productRepository.InsertAsync(</p>
			<p class="source-code">        ObjectMapper.Map&lt;CreateUpdateProductDto, Product&gt;                (input)</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p class="source-code">public async Task&lt;ListResultDto&lt;CategoryLookupDto&gt;&gt;</p>
			<p class="source-code">       GetCategoriesAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    var categories = await _categoryRepository.GetListAsync();</p>
			<p class="source-code">    return new ListResultDto&lt;CategoryLookupDto&gt;(</p>
			<p class="source-code">        ObjectMapper</p>
			<p class="source-code">        .Map&lt;List&lt;Category&gt;, List&lt;CategoryLookupDto&gt;&gt;                    (categories)</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">_categoryRepository</strong> is a type of <strong class="source-inline">IRepository&lt;Category, Guid&gt;</strong> service. You<a id="_idIndexMarker183"/> inject it just as you did for <strong class="source-inline">_productRepository</strong> earlier. I think the method implementations are pretty simple, and there is no need for additional explanation.</p>
			<p>We've used object mapping in two places, and now we have to define the mapping configuration. Open the <strong class="source-inline">ProductManagementApplicationAutoMapperProfile.cs</strong> f<a id="_idTextAnchor100"/>ile in the <em class="italic">ProductManagement.Application</em> project, and add the following code:</p>
			<p class="source-code">CreateMap&lt;CreateUpdateProductDto, Product&gt;();</p>
			<p class="source-code">CreateMap&lt;Category, CategoryLookupDto&gt;();</p>
			<p>This code sets <a id="_idIndexMarker184"/>up the AutoMapper configuration for the object mapping.</p>
			<p class="callout-heading">Automated Tests</p>
			<p class="callout">I will not show any more automated tests in this chapter; however, I have added them to the solution. You can check the source code in the GitHub repository.</p>
			<p>Now, we can go and consume these methods from the UI layer.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor101"/>UI</h2>
			<p>Create a <a id="_idIndexMarker185"/>new <strong class="source-inline">CreateProductModal.cshtml</strong> Razor Page under the <em class="italic">Pages/Products</em> folder of the <em class="italic">ProductManagement.Web</em> project. Open the <strong class="source-inline">CreateProductModal.cshtml.<a id="_idTextAnchor102"/>cs</strong> file, and change the <strong class="source-inline">CreateProductModalModel</strong> class using the following code:</p>
			<p class="source-code">using System.Linq;</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc;</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc.Rendering;</p>
			<p class="source-code">using ProductManagement.Products;</p>
			<p class="source-code">namespace ProductManagement.Web.Pages.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    Public class CreateProductModalModel:</p>
			<p class="source-code">        ProductManagementPageModel</p>
			<p class="source-code">    {</p>
			<p class="source-code">        [BindProperty]</p>
			<p class="source-code">        public CreateEditProductViewModel Product { get;                 set; }</p>
			<p class="source-code">        public SelectListItem[] Categories { get; set; }</p>
			<p class="source-code">        private readonly IProductAppService                             _productAppService;</p>
			<p class="source-code">        public CreateProductModalModel(</p>
			<p class="source-code">            IProductAppService productAppService)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _productAppService = productAppService;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public async Task OnGetAsync()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // TODO</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public async Task&lt;IActionResult&gt; OnPostAsync()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // TODO</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">ProductManagementPageModel</strong> is a base class defined in the startup template. You <a id="_idIndexMarker186"/>can inherit it to create <strong class="source-inline">PageModel</strong> classes. <strong class="source-inline">Categories</strong> will be used to show a list of the categories in a drop-down list. <strong class="source-inline">[BindProperty]</strong> is a standard ASP.NET Core attribute to bind the post data to the <strong class="source-inline">Product</strong> property on an HTTP Post request. We are injecting the <strong class="source-inline">IProductAppService</strong> interface to use the methods defined earlier.</p>
			<p>We've already used <strong class="source-inline">CreateEditProductViewModel</strong>, so we need to define it. Define it in the <a id="_idIndexMarker187"/>same folder as <strong class="source-inline">CreateProductModal.cshtml</strong>:</p>
			<p class="source-code">using ProductManagement.Products;</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using System.ComponentModel;</p>
			<p class="source-code">using System.ComponentModel.DataAnnotations;</p>
			<p class="source-code">using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Form;</p>
			<p class="source-code">namespace ProductManagement.Web.Pages.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class CreateEditProductViewModel</p>
			<p class="source-code">    {</p>
			<p class="source-code">        [SelectItems("Categories")]</p>
			<p class="source-code">        [DisplayName("Category")]</p>
			<p class="source-code">        public Guid CategoryId { get; set; }</p>
			<p class="source-code">        [Required]</p>
			<p class="source-code">        [StringLength(ProductConsts.MaxNameLength)]</p>
			<p class="source-code">        public string Name { get; set; }</p>
			<p class="source-code">        public float Price { get; set; }</p>
			<p class="source-code">        public bool IsFreeCargo { get; set; }</p>
			<p class="source-code">        [DataType(DataType.Date)]</p>
			<p class="source-code">        public DateTime ReleaseDate { get; set; }</p>
			<p class="source-code">        public ProductStockState StockState { get; set; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">SelectItems</strong> tells us that the <strong class="source-inline">CategoryId</strong> property will be selected from the <strong class="source-inline">Categories</strong> list. We <a id="_idIndexMarker188"/>will reuse this class in the edit modal dialog. That's why I named it <strong class="source-inline">CreateEditProductViewModel</strong>.</p>
			<p class="callout-heading">DTOs versus ViewModels</p>
			<p class="callout">It might seem unnecessary to define the view model (<strong class="source-inline">CreateEditProductViewModel</strong>) since it is very similar to the DTO (<strong class="source-inline">CreateUpdateProductDto</strong>). However, it has just a few more attributes. These attributes can be easily <a id="_idIndexMarker189"/>added to the DTO, and we can reuse the DTO on the view<a id="_idIndexMarker190"/> side. It is up to your design decision, and you can do it. However, I think it is better practice to separate each concern, considering these classes have different purposes and evolve in different directions over time. For example, the <strong class="source-inline">[SelectItems("Categories")]</strong> attribute refers to the Razor Page model, and it has no meaning in the application layer.</p>
			<p>Now, we can implement the <strong class="source-inline">OnGe<a id="_idTextAnchor103"/>tAsync</strong> method in the <strong class="source-inline">CreateProductModalModel</strong> class:</p>
			<p class="source-code">public async Task OnGetAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    Product = new CreateEditProductViewModel</p>
			<p class="source-code">    {</p>
			<p class="source-code">        ReleaseDate = Clock.Now,</p>
			<p class="source-code">        StockState = ProductStockState.PreOrder</p>
			<p class="source-code">    };</p>
			<p class="source-code">    </p>
			<p class="source-code">    var categoryLookup =</p>
			<p class="source-code">        await _productAppService.GetCategoriesAsync();</p>
			<p class="source-code">    Categories = categoryLookup.Items</p>
			<p class="source-code">        .Select(x =&gt; new SelectListItem(x.Name,                         x.Id.ToString()))</p>
			<p class="source-code">                .ToArray();</p>
			<p class="source-code">}</p>
			<p>We are creating the <strong class="source-inline">Product</strong> class with default values, then filling the <strong class="source-inline">Categories</strong> list using the product application service. <strong class="source-inline">Clock</strong> is a service provided by ABP Framework to<a id="_idIndexMarker191"/> get the current time without dealing with time zones and Local/UTC times. We use it instead of <strong class="source-inline">DateTime.Now</strong>. This will be explained in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p>We can implement <strong class="source-inline">OnPostAsync</strong>, a<a id="_idTextAnchor104"/>s shown in the following code block:</p>
			<p class="source-code">public async Task&lt;IActionResult&gt; OnPostAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    await _productAppService.CreateAsync(</p>
			<p class="source-code">        ObjectMapper</p>
			<p class="source-code">            .Map&lt;CreateEditProductViewModel,CreateUpdateProductDto&gt;                   (Product)</p>
			<p class="source-code">    );</p>
			<p class="source-code">    return NoContent();</p>
			<p class="source-code">}</p>
			<p>Since we are mapping <strong class="source-inline">CreateEditProductViewModel</strong> to <strong class="source-inline">CreateProductDto</strong>, we need to define the mapping configuration. Open the <strong class="source-inline">ProductManagementWebAutoMapperProfile</strong> class in the <em class="italic">ProductManagement.Web</em> project, and change the content using the following code block:</p>
			<p class="source-code">public class ProductManagementWebAutoMappe<a id="_idTextAnchor105"/>rProfile : Profile</p>
			<p class="source-code">{</p>
			<p class="source-code">    public ProductManagementWebAutoMapperProfile()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        CreateMap&lt;CreateEditProductViewModel,                                   CreateUpdateProductDto&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This class defines the object mappings for the AutoMapper library.</p>
			<p>We've completed the C# side of the product creation UI. </p>
			<p>Now we can start<a id="_idIndexMarker192"/> to build the UI markup and JavaScript code. T<a id="_idTextAnchor106"/>o do this, open the <strong class="source-inline">CreateProductModal.cshtml</strong> file, and change the content as follows:</p>
			<p class="source-code">@page</p>
			<p class="source-code">@using Microsoft.AspNetCore.Mvc.Localization</p>
			<p class="source-code">@using ProductManagement.Localization</p>
			<p class="source-code">@using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Modal</p>
			<p class="source-code">@model ProductManagement.Web.Pages.Products.CreateProductModalModel</p>
			<p class="source-code">@inject IHtmlLocalizer&lt;ProductManagementResource&gt; L</p>
			<p class="source-code">@{</p>
			<p class="source-code">    Layout = null;</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;abp-dynamic-form abp-model="Product"</p>
			<p class="source-code">                  asp-page="/Products/CreateProductModal"&gt;</p>
			<p class="source-code">    &lt;abp-modal&gt;</p>
			<p class="source-code">        &lt;abp-modal-header title="@L["NewProduct"].Value"&gt;&lt;/abp-                  modal-header&gt;</p>
			<p class="source-code">        &lt;abp-modal-body&gt;</p>
			<p class="source-code">            &lt;abp-form-content /&gt;</p>
			<p class="source-code">        &lt;/abp-modal-body&gt;</p>
			<p class="source-code">        &lt;abp-modal-footer buttons="@(AbpModalButtons.Cancel|AbpModalButtons.Save)"&gt;&lt;/abp-modal-footer&gt;</p>
			<p class="source-code">    &lt;/abp-modal&gt;</p>
			<p class="source-code">&lt;/abp-dynamic-form&gt;</p>
			<p>Here, <strong class="source-inline">abp-dynamic-form</strong> automatically creates the form elements based on the C# model class. <strong class="source-inline">abp-form-content</strong> is where the form elements are rendered. <strong class="source-inline">abp-modal</strong> is used to create a modal dialog.</p>
			<p>You can use the standard Bootstrap HTML elements and ASP.NET Core's bindings to create form elements. However, ABP's Bootstrap and dynamic form tag helpers simplify the UI code a lot. We will cover ABP tag helpers in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>.</p>
			<p>We've completed <a id="_idIndexMarker193"/>the product creation modal code. Now, we will add a <strong class="bold">New Product</strong> button to the products page to open that modal. Open the <strong class="source-inline">Index.cshtm<a id="_idTextAnchor107"/>l</strong> file in the <em class="italic">Pages/Products</em> folder, and change the <strong class="source-inline">abp-card-header</strong> section as follows:</p>
			<p class="source-code">&lt;abp-card-header&gt;</p>
			<p class="source-code">    &lt;abp-row&gt;</p>
			<p class="source-code">        &lt;abp-column size-md="_6"&gt;</p>
			<p class="source-code">            &lt;abp-card-title&gt;@L["Menu:Products"]&lt;/abp-card-                  title&gt;</p>
			<p class="source-code">        &lt;/abp-column&gt;</p>
			<p class="source-code">        &lt;abp-column size-md="_6" class="text-end"&gt;</p>
			<p class="source-code">            &lt;abp-button id="NewProductButton"</p>
			<p class="source-code">                        text="@L["NewProduct"].Value"</p>
			<p class="source-code">                        icon="plus"</p>
			<p class="source-code">                        button-type="Primary"/&gt;</p>
			<p class="source-code">        &lt;/abp-column&gt;</p>
			<p class="source-code">    &lt;/abp-row&gt;</p>
			<p class="source-code">&lt;/abp-card-header&gt;</p>
			<p>I've added 2 columns where each column has a <strong class="source-inline">size-md="_6"</strong> attribute (that is half of the 12-column Bootstrap grid). Then, I placed a button on the right-hand side by keeping the card title on the left-hand side.</p>
			<p>Following this, I added the follow<a id="_idTextAnchor108"/>ing code to the end of the <strong class="source-inline">Index.cshtml.js</strong> file (right before the final <strong class="source-inline">});</strong> code part):</p>
			<p class="source-code">var createModal = new abp.ModalManager(abp.appPath +                     'Products/CreateProductModal');</p>
			<p class="source-code">createModal.onResult(function () {</p>
			<p class="source-code">    dataTable.ajax.reload();</p>
			<p class="source-code">});</p>
			<p class="source-code">$('#NewProductButton').click(function (e) {</p>
			<p class="source-code">    e.preventDefault();</p>
			<p class="source-code">    createModal.open();</p>
			<p class="source-code">});</p>
			<p><strong class="source-inline">abp.ModalManager</strong> is used to <a id="_idIndexMarker194"/>manage modal dialogs on the client side. Internally, it uses Twitter Bootstrap's standard modal component but abstracts many details by providing a simple API. <strong class="source-inline">createModal.onResult()</strong> is a callback that is called when the modal is saved. <strong class="source-inline">createModal.open();</strong> is used to open the modal dialog.</p>
			<p>Finally, we need to define some localization texts in the <strong class="source-inline">en.json</strong> file in t<a id="_idTextAnchor109"/>he <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared</em> project:</p>
			<p class="source-code">"NewProduct": "New Product",</p>
			<p class="source-code">"Category": "Category",</p>
			<p class="source-code">"IsFreeCargo": "Free Cargo",</p>
			<p class="source-code">"ReleaseDate": "Release Date"</p>
			<p>You can run the web application again and try to create a new product:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_3.13_B17287.jpg" alt="Figure 3.13 – The New Product modal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – The New Product modal</p>
			<p>ABP has<a id="_idIndexMarker195"/> automatically created the form fields based on the C# class model. Localization and validation also work automatically by reading the attributes and using the conventions. Try to leave the name field empty and save the modal to see an example of the validation error mesage. We will cover the validation and localization topics in more detail in <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>.</p>
			<p>We can now create products on the UI. Now, let's see how to edit products.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor110"/>Editing products</h1>
			<p>Editing a <a id="_idIndexMarker196"/>product is similar to adding a new product. This time, we need to get the product to edit and prepare the edit form.</p>
			<h2 id="_idParaDest-75">Application servic<a id="_idTextAnchor111"/>e contracts</h2>
			<p>Let's start by<a id="_idIndexMarker197"/> defining two new methods for the <strong class="source-inline">IProductAppService</strong> interface:</p>
			<p class="source-code">Task&lt;ProductDto&gt; GetAsync(Guid id);</p>
			<p class="source-code">Task UpdateAsync(Guid id, CreateUpdateProductDto input);</p>
			<p>The first method will be used to obtain the product data by ID. We are reusing <strong class="source-inline">CreateUpdateProductDto</strong> (which was defined earlier) in the <strong class="source-inline">UpdateAsync</strong> method.</p>
			<p>We haven't introduced a new DTO, so we can go straight to the implementation.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor112"/>Application service implementation</h2>
			<p>Implementing <a id="_idIndexMarker198"/>th<a id="_idTextAnchor113"/>ese new methods is pretty simple. Add the following methods to the <strong class="source-inline">ProductAppService</strong> class:</p>
			<p class="source-code">public async Task&lt;ProductDto&gt; GetAsync(Guid id)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return ObjectMapper.Map&lt;Product, ProductDto&gt;(</p>
			<p class="source-code">        await _productRepository.GetAsync(id)</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p class="source-code">public async Task UpdateAsync(Guid id, CreateUpdateProductDto input)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var product = await _productRepository.GetAsync(id);</p>
			<p class="source-code">    ObjectMapper.Map(input, product);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">GetAsync</strong> method uses <strong class="source-inline">productRepository.GetAsync</strong> to get the product from the database and returns it by mapping it to a <strong class="source-inline">ProductDto</strong> object. The <strong class="source-inline">UpdateAsync</strong> method gets the product and maps the given input properties to the product's properties. In this way, we overwrite the product properties with new values.</p>
			<p>For this example, we don't need to call <strong class="source-inline">_productRepository.UpdateAsync</strong> because EF Core<a id="_idIndexMarker199"/> has a change tracking system. ABP's <strong class="bold">Unit of Work</strong> system<a id="_idIndexMarker200"/> automatically saves the changes at the end of the request if it doesn't throw an exception. We will cover the Unit of Work system in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>.</p>
			<p>The application layer is now complete. In the next section, we'll create a product editing UI.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor114"/>UI</h2>
			<p>Create a<a id="_idIndexMarker201"/> new <strong class="source-inline">EditProductModal.cshtml</strong> Razor Page under the <em class="italic">Pages/Products</em> folder of the <em class="italic">ProductManagement.<a id="_idTextAnchor115"/>Web</em> project. Open <strong class="source-inline">EditProductModal.cshtml.cs</strong>, and change the content using the following code:</p>
			<p class="source-code">using System;</p>
			<p class="source-code">using System.Linq;</p>
			<p class="source-code">using System.Threading.Tasks;</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc;</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc.Rendering;</p>
			<p class="source-code">using ProductManagement.Products;</p>
			<p class="source-code">namespace ProductManagement.Web.Pages.Products</p>
			<p class="source-code">{</p>
			<p class="source-code">    public class EditProductModalModel :                             ProductManagementPageModel</p>
			<p class="source-code">    {</p>
			<p class="source-code">        [HiddenInput]</p>
			<p class="source-code">        [BindProperty(SupportsGet = true)]</p>
			<p class="source-code">        public Guid Id { get; set; }</p>
			<p class="source-code">        [BindProperty]</p>
			<p class="source-code">        public CreateEditProductViewModel Product { get; set; }</p>
			<p class="source-code">        public SelectListItem[] Categories { get; set; }</p>
			<p class="source-code">        private readonly IProductAppService _productAppService;</p>
			<p class="source-code">        public EditProductModalModel(IProductAppService                         productAppService)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _productAppService = productAppService;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public async Task OnGetAsync()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // TODO</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public async Task&lt;IActionResult&gt; OnPostAsync()</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // TODO</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Id</strong> property <a id="_idIndexMarker202"/>will be a hidden field in the form. It should also support an HTTP GET request since a GET request opens this modal, and we need the product's ID to prepare the edit form. The <strong class="source-inline">Product</strong> and <strong class="source-inline">Categories</strong> properties are similar to the create modal. We are also injecting the <strong class="source-inline">IProductAppService</strong> interface into<a id="_idTextAnchor116"/> the constructor.</p>
			<p>We can implement the <strong class="source-inline">OnGetAsync</strong> method, as shown in the following code block:</p>
			<p class="source-code">public async Task OnGetAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    var productDto = await _productAppService.GetAsync(Id);</p>
			<p class="source-code">    Product = ObjectMapper.Map&lt;ProductDto,                                   CreateEditProductViewModel&gt;(productDto);</p>
			<p class="source-code">    </p>
			<p class="source-code">    var categoryLookup = await                                               _productAppService.GetCategoriesAsync();</p>
			<p class="source-code">    Categories = categoryLookup.Items</p>
			<p class="source-code">        .Select(x =&gt; new SelectListItem(x.Name, x.Id.ToString()))</p>
			<p class="source-code">        .ToArray();</p>
			<p class="source-code">}</p>
			<p>First, we are getting the product (<strong class="source-inline">ProductDto</strong>) to edit. We are converting it into <strong class="source-inline">CreateEditProductViewModel</strong>, which is then used on the UI to create the edit form. Then, we are getting the categories to select on the form, as we did earlier for the creation form.</p>
			<p>We've mapped <strong class="source-inline">ProductDto</strong> to <strong class="source-inline">CreateEditProductViewModel</strong>, so now we need to define the mapping configuration in the <strong class="source-inline">ProductManagementWeb<a id="_idTextAnchor117"/>AutoMapperProfile</strong> class (in the <em class="italic">ProductManagement.Web</em> project) just like we've done previously:</p>
			<p class="source-code">CreateMap&lt;ProductDto, CreateEditProductViewModel&gt;();</p>
			<p>The <strong class="source-inline">OnPostAsync</strong> method<a id="_idIndexMarker203"/> is simple; we c<a id="_idTextAnchor118"/>all the <strong class="source-inline">UpdateAsync</strong> method by converting <strong class="source-inline">CreateEditProductViewModel</strong> into <strong class="source-inline">CreateUpdateProductDto</strong>:</p>
			<p class="source-code">public async Task&lt;IActionResult&gt; OnPostAsync()</p>
			<p class="source-code">{</p>
			<p class="source-code">    await _productAppService.UpdateAsync(Id,</p>
			<p class="source-code">        ObjectMapper.Map&lt;CreateEditProductViewModel,                             CreateUpdateProductDto&gt;(Product)</p>
			<p class="source-code">    );</p>
			<p class="source-code">    return<a id="_idTextAnchor119"/> NoContent();</p>
			<p class="source-code">}</p>
			<p>Now we can switch to <strong class="source-inline">EditProductModal.cshtml</strong>, and change its content as follows:</p>
			<p class="source-code">@page</p>
			<p class="source-code">@using Microsoft.AspNetCore.Mvc.Localization</p>
			<p class="source-code">@using ProductManagement.Localization</p>
			<p class="source-code">@using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Modal</p>
			<p class="source-code">@model ProductManagement.Web.Pages.Products.EditProductModalModel</p>
			<p class="source-code">@inject IHtmlLocalizer&lt;ProductManagementResource&gt; L</p>
			<p class="source-code">@{</p>
			<p class="source-code">    Layout = null;</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;abp-dynamic-form abp-model="Product"</p>
			<p class="source-code">                  asp-page="/Products/EditProductModal"&gt;</p>
			<p class="source-code">    &lt;abp-modal&gt;</p>
			<p class="source-code">        &lt;abp-modal-header title="@Model.Product.Name"&gt;&lt;/abp-modal-              header&gt;</p>
			<p class="source-code">        &lt;abp-modal-body&gt;</p>
			<p class="source-code">            &lt;abp-input asp-for="Id" /&gt;</p>
			<p class="source-code">            &lt;abp-form-content/&gt;</p>
			<p class="source-code">        &lt;/abp-modal-body&gt;</p>
			<p class="source-code">        &lt;abp-modal-footer buttons="@(AbpModalButtons.Cancel|AbpModalButtons.Save)"&gt;&lt;/abp-modal-footer&gt;</p>
			<p class="source-code">    &lt;/abp-modal&gt;</p>
			<p class="source-code">&lt;/abp-dynamic-form&gt;</p>
			<p>This page is very similar to <strong class="source-inline">CreateProductModal.cshtml</strong>. I just added the <strong class="source-inline">Id</strong> field to the form (as a hidden input) to store the <strong class="source-inline">Id</strong> property of the product being edited.</p>
			<p>Finally, we can<a id="_idIndexMarker204"/> add an <strong class="bold">Edit</strong> action to open that modal from the products data table. Open the <strong class="source-inline">Ind<a id="_idTextAnchor120"/>ex.cshtml.js</strong> file, and add a new <strong class="source-inline">ModalManager</strong> object on top of the <strong class="source-inline">dataTable</strong> initialization code:</p>
			<p class="source-code">var editModal = new abp.ModalManager(abp.appPath + 'Products/EditProductModal');</p>
			<p>Then, add a new colu<a id="_idTextAnchor121"/>mn definition as the first item in the <strong class="source-inline">columnDefs</strong> array within the <strong class="source-inline">dataTable</strong> initialization code:</p>
			<p class="source-code">{</p>
			<p class="source-code">    title: l('Actions'),</p>
			<p class="source-code">    rowAction: {</p>
			<p class="source-code">        items:</p>
			<p class="source-code">            [</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    text: l('Edit'),</p>
			<p class="source-code">                    action: function (data) {</p>
			<p class="source-code">                        editModal.open({ id: data.record.id });</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                }</p>
			<p class="source-code">            ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">},</p>
			<p>This code adds a new <strong class="bold">Actions</strong> column to the data table and adds an <strong class="bold">Edit</strong> action, which opens the edit modal with a click. <strong class="source-inline">rowAction</strong> is a special option provided by ABP Framework. It is used to add one or more actions<a id="_idTextAnchor122"/> for a row in the table.</p>
			<p>Finally, add the<a id="_idIndexMarker205"/> following code after the <strong class="source-inline">dataTable</strong> initialization code:</p>
			<p class="source-code">editModal.onResult(function () {</p>
			<p class="source-code">    dataTable.ajax.reload();</p>
			<p class="source-code">});</p>
			<p>This code refreshes the data table after saving a product edit dialog, so we can see the latest data on the table. The final UI looks similar to <em class="italic">Figure 3.14</em>:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_3.14_B17287.jpg" alt="Figure 3.14 – Editing an existing product&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Editing an existing product</p>
			<p>We can now see the products, create new products, and edit existing ones. The final section will add a new action to delete an existing product.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor123"/>Deleting products</h1>
			<p>Deleting a <a id="_idIndexMarker206"/>product is pretty simple compared to the create or edit actions since, in this<a id="_idTextAnchor124"/> case, we don't need to build a form. First, add a new method to the <strong class="source-inline">IProductA<a id="_idTextAnchor125"/>ppService</strong> interface:</p>
			<p class="source-code">Task DeleteAsync(Guid id);</p>
			<p>Then, implement it in the <strong class="source-inline">ProductAppService</strong> class:</p>
			<p class="source-code">public async Task DeleteAsync(Guid id)</p>
			<p class="source-code">{</p>
			<p class="source-code">    await _productRepository.DeleteAsync(id);</p>
			<p class="source-code">}</p>
			<p>We can now add a new action to the product data table. Open <strong class="source-inline">Index.csht<a id="_idTextAnchor126"/>ml.js</strong>, and add the following definition just after the <strong class="bold">Edit</strong> action (in the <strong class="source-inline">rowAction.items</strong> array):</p>
			<p class="source-code">{</p>
			<p class="source-code">    text: l('Delete'),</p>
			<p class="source-code">    confirmMessage: function (data) {</p>
			<p class="source-code">        return l('ProductDeletionConfirmationMessage',                           data.record.name);</p>
			<p class="source-code">    },</p>
			<p class="source-code">    action: function (data) {</p>
			<p class="source-code">        productManagement.p<a id="_idTextAnchor127"/>roducts.product</p>
			<p class="source-code">            .delete(data.record.id)</p>
			<p class="source-code">            .then(function() {</p>
			<p class="source-code">                abp.notify.info(l('SuccessfullyDeleted'));</p>
			<p class="source-code">                dataTable.ajax.reload();</p>
			<p class="source-code">            });</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">confirmMessage</strong> is a function that is used to get a confirmation from the user before <a id="_idIndexMarker207"/>executing the action. The <strong class="source-inline">productManagement.products.product.delete</strong> function is dynamically created by ABP Framework, as explained earlier. In this way, you can directly call server-side methods in your JavaScript code. We are just passing the current record's ID. It returns a promise so that we can register a callback to the <strong class="source-inline">then</strong> function. Finally, we use <strong class="source-inline">abp.notify.info</strong> to send a notification to inform the user, then refresh the data table.</p>
			<p>We've used some localization texts, so we need to add the following lines to the localization file (the <strong class="source-inline">en.json<a id="_idTextAnchor128"/></strong> file in the <em class="italic">Localization/ProductManagement</em> folder of the <em class="italic">ProductManagement.Domain.Shared</em> project):</p>
			<p class="source-code">"ProductDeletionConfirmationMessage": "Are you sure to delete this book: {0}",</p>
			<p class="source-code">"SuccessfullyDeleted": "Successfully deleted!"</p>
			<p>You can run <a id="_idIndexMarker208"/>the web project again to see the result:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.15_B17287.jpg" alt="Figure 3.15 – The Delete action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – The Delete action</p>
			<p>The <strong class="bold">Edit</strong> button automatically turns into an <strong class="bold">Action</strong> drop-down button since we now have two actions. When you click on the <strong class="bold">Delete</strong> action, you get a confirmation message to delete the product:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.16_B17287.jpg" alt="Figure 3.16 – The delete confirmation message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – The delete confirmation message</p>
			<p>If you click<a id="_idIndexMarker209"/> on the <strong class="bold">Yes</strong> button, you will see a notification on the page, and the data table will be refreshed. </p>
			<p>Implementing product deletion was pretty simple. ABP's built-in features helped us by implementing common patterns such as client-to-server communication, confirmation dialogs, and UI notifications.</p>
			<p>Notice that the <strong class="source-inline">Product</strong> entity has been inherited from the <strong class="source-inline">FullAuditedAggregateRoot</strong> class that made it Soft-Delete. Check the database after deleting a product. You will see that it was not really deleted, but the <strong class="source-inline">IsDeleted</strong> field is set to <strong class="source-inline">true</strong>. Setting <strong class="source-inline">IsDeleted</strong> to <strong class="source-inline">true</strong> makes the product entity soft-deleted (that is, deleted logically but not physically). The next time you query products, deleted products are automatically filtered and not included in the query result. That's done by the data filtering system of ABP Framework and will be covered in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor129"/>Summary</h1>
			<p>In this chapter, we created a fully working CRUD page. We went through all layers of the application and have seen the fundamental approaches of ABP-based application development.</p>
			<p>You were introduced to many different concepts, such as entities, repositories, database mapping and migrations, automated tests, API controllers, dynamic JavaScript proxies, object to object mapping, Soft-Delete, and more. If you're building a serious software solution, you will use all of them, with ABP or not. ABP is a full-stack application framework that helps you implement these concepts with best practices. It provides the necessary infrastructure to make your daily development easier.</p>
			<p>You might not understand all of the details at this point. That's not a problem because the purpose of the remaining chapters is to deep dive into these concepts and show their details and different use cases.</p>
			<p>This example application was relatively simple. It doesn't contain any important business logic because I've introduced many concepts and tried to keep the application simple to focus on these concepts rather than business complexities. I've ignored authorization in this example. Authorization will be explained in <a href="B17287_07_Epub_AM.xhtml#_idTextAnchor213"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Cross-Cutting Concerns</em>.</p>
			<p>Demonstrating an example application with real-world complexity is not easy in a book. However, I've prepared a complete reference application with real-world qualities and complexities for the readers of this book. The reference application is open source and available on GitHub. Additionally, it is a live application, so you can try it directly.</p>
			<p>The next chapter will introduce that reference application and show the reference solution's functionalities, layers, and code structure. The remaining chapters frequently refer to the source code of that application. </p>
		</div>
	</body></html>