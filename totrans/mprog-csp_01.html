<html><head></head><body>
		<div id="_idContainer009">
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>How Can Metaprogramming Benefit You?</h1>
			<p>So, what is <strong class="bo d">metaprogramming</strong> and why should you care? If you picked up this book hoping to learn <a id="_idIndexMarker000"/>about programming in the <strong class="bo d">metaverse</strong>, you’re about to become <a id="_idIndexMarker001"/><span class="No-Break">very disappointed.</span></p>
			<p>Metaprogramming is all about code treating other code as data. This could be just to understand and reason <a id="_idIndexMarker002"/>about the code, or actually create new code based on metadata implicitly through structure or <span class="No-Break">explicitly added.</span></p>
			<p>“But why should I care about that,” you might ask? “Isn’t it just enough to write the code and get it shipped?” In this chapter, we will look into the concrete benefits you can get from doing metaprogramming and how it can benefit you daily. We will also provide tips on how it can increase productivity and remove tedious tasks we developers tend to have <span class="No-Break">to do.</span></p>
			<p>The main objective of this chapter is to introduce you to metaprogramming and examples of use cases. In doing this, we’ll see some of the building blocks .NET has for metaprogramming. In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Reasoning about <span class="No-Break">your code</span></li>
				<li>Removing manual structures <span class="No-Break">and processes</span></li>
			</ul>
			<p>By the end of this chapter, you should have some good ideas and inspiration for how metaprogramming can benefit you. You should have also gained insight into what metaprogramming is <span class="No-Break">all about.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Reasoning about your code</h1>
			<p>The software industry <a id="_idIndexMarker003"/>is very young. In the last 20-30 years, we’ve seen a dramatic increase in <span class="No-Break">its usage.</span></p>
			<p>Today, software is engraved into every aspect of our lives – our work, our transportation, and in our homes, down to the smart light bulbs many of us <span class="No-Break">have installed.</span></p>
			<p>With the breadth of applications and users using the software we make, there are expectations from the software. Users today expect far more from software than they did 20 years ago. And <a id="_idIndexMarker004"/>since software is so engraved in our lives, we are far more vulnerable, which makes it a <span class="No-Break">risk factor.</span></p>
			<p>In this section, we’ll discuss why you, as a developer, should care about metaprogramming. We’ll go through the developer concerns, how we can do some nifty automation, and cover some of the basics <span class="No-Break">around metaprogramming.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Developer concerns</h2>
			<p>For us developers, we <a id="_idIndexMarker005"/>have a lot of different aspects to cover to guarantee the success of <span class="No-Break">our software.</span></p>
			<p>End users have high expectations of great user experiences, and they expect to be put in the pit of success. We also need to be empathetic to the different types of users our system will have and make sure it is accessible <span class="No-Break">to everyone.</span></p>
			<p>Our systems need to maintain the integrity of their data and help the end users do the right thing. To do this, we need to validate all the input according to what we expect or what our data model requires. In addition, we need to have business rules that enforce the integrity of <span class="No-Break">the system.</span></p>
			<p>The data is also something we want to protect, so security plays an important role. Users need to be authenticated and we also want to make sure the user has the correct authorization to perform the different tasks of <span class="No-Break">the system.</span></p>
			<p>We must also make sure that our systems don’t have security flaws that would allow hackers to breach <a id="_idIndexMarker006"/>the system. The input from users also needs to be sanitized, to prevent malicious attacks through things such as <span class="No-Break"><strong class="bo d">SQL injection</strong></span><span class="No-Break">.</span></p>
			<p>For our software to be available to our users, we need to have it running somewhere, on an on-premises server or servers with a hosting partner, or in the cloud, be it physical or virtual. This means we need to think about how we package the software and then how we get it onto the <span class="No-Break">running environment.</span></p>
			<p>Once it is running, we have to make sure it runs all the time and doesn’t have any downtime; our users rely on it. For this, we want to consider having more than one instance of the system running so that it can fail over to a second instance if the primary one <span class="No-Break">goes down.</span></p>
			<p>We also need to make sure that the environment it is running in can handle the number of users it <span class="No-Break">is targeting.</span></p>
			<p>Instead of just having a fail-over instance, we can scale out horizontally and have a load balancing mechanism spreading the users across the different instances we have. This makes our system a <span class="No-Break">distributed system.</span></p>
			<p>Those are a lot of different concerns. Ideally, you want to have different people doing different aspects <a id="_idIndexMarker007"/>of the job, but this is not always the case (depending on the size of the organization, as well as its culture). Today, you’ll often see in job ads that companies are looking for <em class="ita ic">full stack developers</em>. In many cases, this could mean the expectations are that you need to work with all of the <span class="No-Break">following aspects:</span></p>
			<ul>
				<li><strong class="bo d">User experience</strong>: This is all <a id="_idIndexMarker008"/>about the interaction, flows, and how it <span class="No-Break">all feels</span></li>
				<li><strong class="bo d">Accessibility</strong>: This involves <a id="_idIndexMarker009"/>creating empathetic software that is accessible to those <span class="No-Break">with disabilities</span></li>
				<li><strong class="bo d">Frontend code</strong>: This is the <a id="_idIndexMarker010"/>layout, styling, and necessary logic to make the user experience come <span class="No-Break">to life</span></li>
				<li><strong class="bo d">Backend code</strong>: This is for <a id="_idIndexMarker011"/>creating the glue that represents the domain we’re <span class="No-Break">working in</span></li>
				<li><strong class="bo d">Data modeling</strong>: This is how <a id="_idIndexMarker012"/>we store the data and model it for the usage <span class="No-Break">we need</span></li>
				<li><strong class="bo d">Authentication and authorization</strong>: This is <a id="_idIndexMarker013"/>for making sure users <a id="_idIndexMarker014"/>are authenticated and the proper authorization policies are applied to the <span class="No-Break">different features</span></li>
				<li><strong class="bo d">Security</strong>: This makes the <a id="_idIndexMarker015"/>application robust from any attacks and protects <span class="No-Break">the data</span></li>
				<li><strong class="bo d">DevOps</strong>: This involves <a id="_idIndexMarker016"/>delivering features to production in a timely fashion without <span class="No-Break">any ceremony</span></li>
			</ul>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Automation</h2>
			<p>Being humans, we <a id="_idIndexMarker017"/>make mistakes and we forget things. Sometimes, this has some really bad outcomes, such as systems going down, or worse, such as being breached <span class="No-Break">by hackers.</span></p>
			<p>Luckily, computers are good at doing what they’re told and repeating it endlessly. They never complain and don’t make mistakes. This means there are great opportunities for streamlining a lot of our work. As the industry has matured over the years, we have seen improved workflows and tooling that can help us achieve what we aim to achieve, often taking away tedious and <span class="No-Break">time-consuming tasks.</span></p>
			<p>A great example of automation is what has happened in the last decade in cloud computing. Before this, we had to set up physical hardware and often had manual routines for getting our software onto that hardware. This has completely changed into us being able to spin up anything our hearts desire with a few clicks, connect it to some continuous deployment software that will build our software, and automatically get it onto the running environment. All this can be achieved in minutes, rather than hours <span class="No-Break">or days.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Metaprogramming</h2>
			<p>Where am I going with all this? Wasn’t this book supposed to be about something <span class="No-Break">called metaprogramming?</span></p>
			<p>Metaprogramming is all about additional information surrounding your code. This information is sometimes <a id="_idIndexMarker018"/>implicit – that is, it’s already <a id="_idIndexMarker019"/>there. Sometimes, however, it needs to be added explicitly or deliberately by you, as <span class="No-Break">a developer.</span></p>
			<p>The computer that runs the software only understands the machine language instructions laid out in memory for the CPU to execute. For us humans, this is less than intuitive. Early on, we came up with languages that would help us write something more friendly and we could reason <a id="_idIndexMarker020"/>about more easily. This started with the <strong class="bo d">assembly language</strong> and, later, higher-level languages that would compile down to <span class="No-Break">assembly language.</span></p>
			<p>With this tooling in place, we gained the ability to not just translate from one language into another, but also to reason about what was going on with our code. In 1978, Stephen C. Johnson, from Bell Labs, came up with what he called <strong class="bo d">lint</strong> – a static code analysis tool that could be used to <a id="_idIndexMarker021"/>reason about C code and detect potential issues with it. Today, this is common with most programming languages. For web development in <strong class="bo d">JavaScript</strong> or <strong class="bo d">TypeScript</strong>, we could typically add tools such as <strong class="bo d">ESLint</strong> to our <a id="_idIndexMarker022"/>build pipelines to <a id="_idIndexMarker023"/>do this. With <strong class="bo d">C#</strong>, we have this built into the <a id="_idIndexMarker024"/>compiler, and with the Roslyn compiler, it is completely extensible with our own custom rules, something we will cover in <a href="B19418_17.xhtml#_idTextAnchor299"><span class="No-Break"><em class="ita ic">Chapter 17</em></span></a>, <em class="ita ic">Static </em><span class="No-Break"><em class="ita ic">Code Analysis</em></span><span class="No-Break">.</span></p>
			<p>For programming languages such as <strong class="bo d">C</strong>/<strong class="bo d">C++</strong> that compile down to something that runs natively on the CPU, we’re limited to what we can <a id="_idIndexMarker025"/>reason about at the compile level. However, with programming languages such as Java or C#, often referred to as managed languages, we’re now running code in a managed environment. The code we write compiles down to an intermediate language that will be translated on the fly while running. These languages then carry information with them about the code we wrote – this is known as <strong class="bo d">metadata</strong>. This lets us treat our programs or others as <a id="_idIndexMarker026"/>data at runtime and allows us to reason about the code; we can even discover code <span class="No-Break">at runtime.</span></p>
			<p>With C#, from <em class="ita ic">version 1</em>, we could add additional information and more metadata. Through the use of C# <strong class="bo d">attributes</strong>, we could adorn things such as types, properties on types, and <a id="_idIndexMarker027"/>methods with additional information. This information <a id="_idIndexMarker028"/>would carry through to the running program and is something we can use to reason about <span class="No-Break">our software.</span></p>
			<p>For instance, with attributes, we can now add additional information that we can reason about both at compile time and runtime. We can do things such as marking properties on an object with validation information, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-in ine">[Required]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class RegisterPerson
{
    [Required]
    public string FirstName { get; set; }
    [Required]
    public string LastName { get; set; }
    [Required]
    public string SocialSecurityNumber { get; set; }
}</pre>
			<p>This code represents what is <a id="_idIndexMarker029"/>needed to register a person. All the <a id="_idIndexMarker030"/>properties that we required have the <strong class="source-in ine">[Required]</strong> attribute <span class="No-Break">as metadata.</span></p>
			<p>Now that we have added metadata to the code, we can take concrete actions based <span class="No-Break">on it.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Removing manual structure and process</h1>
			<p>Adding explicit metadata is great for visibility and makes it very explicit in the code for the type of <a id="_idIndexMarker031"/>metadata that has been added. However, this metadata is not actionable on its own. This means that there is nothing that will inherently deal with it – for instance, a property is required, as <span class="No-Break">we’ve seen.</span></p>
			<p>This metadata gives us the power to not only reason about the metadata surrounding our code but put it into action. We can build our systems in a way that leverages this information to make decisions for us, or we could automate <span class="No-Break">tedious tasks.</span></p>
			<p>One of the most common things I’ve seen throughout my career is what I call <strong class="bo d">recipe-driven development</strong>. Code bases tend to settle on a certain structure and a certain set of things developers <a id="_idIndexMarker032"/>need to do when creating features in it. These <em class="ita ic">recipes</em> are then often written down as a part of the documentation for the code base and something everyone has to read and make sure they follow. This is not necessarily a bad thing, and I think all code bases have this to <span class="No-Break">some degree.</span></p>
			<p>Taking a step back, there might be some potential to improve our productivity and have to write less code. The recipes and patterns could be formalized and automated. The main reason for doing so is that following recipes can be error-prone. We can forget to do something or do it wrong or maybe even mix up the ordering <span class="No-Break">of steps.</span></p>
			<p>Imagine that you have an API and that for every action, you have the <span class="No-Break">following recipe:</span></p>
			<ul>
				<li>Check if the user <span class="No-Break">is authorized</span></li>
				<li>Check if all the input <span class="No-Break">is valid</span></li>
				<li>Check for malicious input (for example, <span class="No-Break">SQL injection)</span></li>
				<li>Check if the action is allowed by the domain logic, typically <span class="No-Break">business-specific rules</span></li>
				<li>Perform the <span class="No-Break">business logic</span></li>
				<li>Return the correct HTTP status code and result, depending on whether or not <span class="No-Break">we’re successful</span></li>
			</ul>
			<p>Those are a lot of concerns mixed into one place. At this point, you’re probably thinking that this is not how we do things in modern <strong class="bo d">ASP.NET</strong> API development. And that is correct – they are typically <a id="_idIndexMarker033"/>split into concerns and things such as the SQL injection handled by <span class="No-Break">the pipeline.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">We’ll revisit how ASP.NET leverages metaprogramming to make the developer experience it offers in <a href="B19418_03.xhtml#_idTextAnchor041"><span class="No-Break"><em class="ita ic">Chapter 3</em></span></a>, <em class="ita ic">Demystifying through Existing </em><span class="No-Break"><em class="ita ic">Real-World Examples</em></span><span class="No-Break">.</span></p>
			<p>Even though these <a id="_idIndexMarker034"/>things might not be in the same method and spread out, they are still concerns we have to be aware of, and a recipe would then still state that these things would need to be done. Often, they are repetitive and could potentially be optimized for an improved developer experience and also reduce the risk of fatal errors in <span class="No-Break">the system.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Maintaining software</h2>
			<p>Another aspect <a id="_idIndexMarker035"/>of this type of repetitive code is that all code we add to our system is code we need to maintain. Building out a feature might not take that long, but chances are the code needs to be maintained for years to come. It might not be maintained by you, but by others on the team or a successor to you. So, we should be optimizing our code bases for maintenance first. Getting features out the door in a timely fashion is expected of us, but if we don’t consider the maintenance of the code, we, as the owners of the code, will suffer when it needs to <span class="No-Break">be maintained.</span></p>
			<p>Maintenance is not just about keeping the code working and delivering on its promise. It’s also about its ability to change and adapt to new requirements, whether business or technical. The very beginning of a project is when you know the least <span class="No-Break">about it.</span></p>
			<p>So, planning for this is super hard and would require us to be able to predict the future. But we can write our code in a way that would make it more adaptable <span class="No-Break">to change.</span></p>
			<p>Instead of repeating all this code all over the place, we could put metadata into our code that we could leverage. This is typically what ASP.NET supports – for instance, for authorization with the <strong class="source-in ine">[Authorize]</strong> attribute for controllers. It would require a specific policy to be fulfilled, such as the user having to be in a role. If our system has a deliberate structure for our features, you might find natural groupings of features belonging to specific roles. We could then reason about this structure by looking at the namespace <a id="_idIndexMarker036"/>metadata on the type and putting in the correct authorization rules. For developers, you replaced the need for an explicit piece of information and made it implicit through the structure. This may seem like a small thing, but throughout the lifetime of the code base, this type of mindset can have a huge impact on productivity <span class="No-Break">and maintainability.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Generating code</h2>
			<p>With C#, we can go even further than just reasoning about code and making decisions based on <a id="_idIndexMarker037"/>what we find – we can generate code. Code generation can take place at compile time if we have all the information we need or are pushed to the runtime level. This opens up a lot more flexibility and gives us a vast amount <span class="No-Break">of power.</span></p>
			<p>As an <a id="_idIndexMarker038"/>example, if you’ve ever worked with XAML-based <a id="_idIndexMarker039"/>frontend technology such as <strong class="bo d">Windows Presentation Foundation</strong> (<strong class="bo d">WPF</strong>) or <strong class="bo d">Universal Windows Platform</strong> (<strong class="bo d">UWP</strong>) and have used data binding, you have probably come across the <strong class="source-in ine">INotifyPropertyChanged</strong> interface. Its purpose is to enable the view controls so that you’re notified when the value of a property has changed on an instance of an object in the view to which it <span class="No-Break">is bound.</span></p>
			<p>Let’s say you have an object representing <span class="No-Break">a person:</span></p>
			<pre class="source-code">
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}</pre>
			<p>Now, let’s say we want to make this notification appear whenever one of the properties changes. Using the <strong class="source-in ine">INotifyPropertyChanged</strong> interface for binding purposes, the object <a id="_idIndexMarker040"/>would need to expand into <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class Person : INotifyPropertyChanged
{
    private string _firstName;
    public string FirstName
    {
        get { return _firstName; }
        set
        {
            _name = value;
            RaisePropertyChanged("FirstName");
        }
    }
    public string LastName { get; set; }
    public event PropertyChangedEventHandler
      PropertyChanged;
    protected void RaisePropertyChanged(string
      propertyName)
    {
        if (PropertyChanged != null)
        {
            PropertyChanged(this, new
              PropertyChangedEventArgs(propertyName));
        }
    }
}</pre>
			<p>As you can see, creating a property is now very tedious. Imagine having all the properties of an object do this. This easily becomes code that is hard to read, and there's more code to maintain, and it’s not adding any business value to <span class="No-Break">your code.</span></p>
			<p>This can be improved upon thanks to the latest version of the <span class="No-Break">C# compiler.</span></p>
			<p>Microsoft rewrote the C# compiler a few years back. The compiler was given the name Roslyn. There were a couple of reasons they rewrote the compiler, with one being that they wanted to have the compiler itself be written in C# – a proof of the maturity of the language and the .NET runtime Also, as part of the move from Microsoft to open source, having a rewrite and doing it in the open and leaving the old license model behind made more sense. But the most important reason in my opinion was to make it more extensible, and not just for Microsoft themselves, <span class="No-Break">but everyone.</span></p>
			<p>Part of this extensibility is what is called Roslyn code generation. With it, we could go and make <a id="_idIndexMarker041"/>this code very close to the original. Let’s imagine we introduce some metadata in the form of an <strong class="source-in ine">[Bindable]</strong> attribute and we create a compiler extension that makes all private fields into properties that are needed for <strong class="source-in ine">InotifyPropertyChanged</strong>. Here, our object would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[Bindable]
public class Person
{
    private string _firstName;
    private string _lastName;
}</pre>
			<p>We could also do this at runtime. However, at runtime, we are limited to what has been compiled and can’t change the type. So, the approach would be slightly different. Instead of changing the existing type, we would need to create a new type that inherits from the original type and then extend it. This would require us to make the original properties <strong class="source-in ine">virtual</strong> for us to override them in a <span class="No-Break">generated type:</span></p>
			<pre class="source-code">
[Bindable]
public class Person
{
    public virtual string FirstName { get; set; }
    public virtual string LastName { get; set; }
}</pre>
			<p>For this to work, we would need a factory that knows how to create these objects. We would call this when we needed an instance <span class="No-Break">of it.</span></p>
			<p>With great <a id="_idIndexMarker042"/>power also comes great responsibility, and it needs to be a very deliberate choice to go down this path. We’ll cover this in <a href="B19418_18.xhtml#_idTextAnchor323"><span class="No-Break"><em class="ita ic">Chapter 18</em></span></a>, <em class="ita ic">Caveats and </em><span class="No-Break"><em class="ita ic">Final Words.</em></span></p>
			<p>We will cover the Roslyn extensibility in more depth in <a href="B19418_15.xhtml#_idTextAnchor250"><span class="No-Break"><em class="ita ic">Chapter 15</em></span></a>, <em class="ita ic">Roslyn </em><span class="No-Break"><em class="ita ic">Compiler Extensions</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Compile time safety</h2>
			<p>There are also times when we must add certain metadata for the system to work. This is a candidate <a id="_idIndexMarker043"/>for writing a code analyzer for the Roslyn compiler. The analyzer would figure out what’s missing and let the developer know as soon as possible, providing a tight feedback loop rather than the developer having to discover the problem <span class="No-Break">at runtime.</span></p>
			<p>An example of this is in a platform I work <a id="_idIndexMarker044"/>on called <strong class="bo d">Cratis</strong> (<a href="https://cratis.io">https://cratis.io</a>), an event sourcing platform. For all the events being persisted, we require a unique identifier that represents the type of event. This is added as an attribute for <span class="No-Break">the event:</span></p>
			<pre class="source-code">
[EventType("66f58b90-c027-41b3-aa2c-2cfd18e7db69")]
public record PersonRegistered(string FirstName, string LastName);</pre>
			<p>When calling the <strong class="source-in ine">Append()</strong> method on the event log, the type has to be associated with the unique identifier. If there is no association between an event type and the .NET type, the <strong class="source-in ine">Append()</strong> method <a id="_idIndexMarker045"/>will throw an exception. This is a great opportunity to perform a compile-time check of anything being sent to the <strong class="source-in ine">Append()</strong> method and to check whether or not the type of the object has the <strong class="source-in ine">[</strong><span class="No-Break"><strong class="source-in ine">EventType]</strong></span><span class="No-Break"> attribute.</span></p>
			<p>We will revisit all this in <a href="B19418_17.xhtml#_idTextAnchor299"><span class="No-Break"><em class="ita ic">Chapter 17</em></span></a>, <em class="ita ic">Static </em><span class="No-Break"><em class="ita ic">Code Analysis</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Summary</h1>
			<p>Hopefully, you now know of the great potential of metaprogramming. It is very powerful. This comes with great responsibility – the balance of code you don’t see that magically gets added either at compile time or runtime versus the explicitness in every code file is a hard one. From my experience, new developers coming into a code base with a lot of implicit automation can run into trouble and might end up not trusting <span class="No-Break">the magic.</span></p>
			<p>But after a while, once they get used to it, they tend to want more magic. The benefits are clear once you have experience with them, but it might be a bit scary at first. To remedy this, you should communicate the automation you have. That will at least make it adhere more to the <em class="ita ic">principle of </em><span class="No-Break"><em class="ita ic">least surprise</em></span><span class="No-Break">.</span></p>
			<p>In the next chapter, we will dive into more concrete concepts of metaprogramming and look at what’s behind the concepts. We’ll become familiar with how the .NET runtime sees code and the metadata it produces and how this can be leveraged in a running application. Finally, we’ll learn how to extend <span class="No-Break">this metadata.</span></p>
		</div>
	</body></html>