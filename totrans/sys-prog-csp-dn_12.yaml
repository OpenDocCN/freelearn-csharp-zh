- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Security Safeguards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Security essentials for* *systems programming*'
  prefs: []
  type: TYPE_NORMAL
- en: Security is more critical these days than ever. Software never stands alone;
    it always works with hardware and other software packages. Attackers do whatever
    they can to find the weakest link in the chain. As developers, we must ensure
    our software is not the weakest link.
  prefs: []
  type: TYPE_NORMAL
- en: Security is not a “thing” but a mindset and a process. It is a never-ending
    quest to find the best solution, keeping in mind maintainability and useability.
    As system programmers, we have to trade off security against performance and memory
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: This makes building secure software a challenge. But let’s be honest – isn’t
    that sort of challenge the reason we chose this profession?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to care about security as system programmers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with strings securely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle keys in your systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the requirements around credentials and privileges?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you transfer data safely across a network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security is an important but complicated topic. I will not cover everything
    there is to say about security. Still, as a system programmer, I will touch upon
    the most important things you should know. But let’s not talk too loudly – we
    must keep our secrets to ourselves! So, make sure nobody is listening in, and
    then follow me.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will find all the code in this chapter at this URL: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to follow along when I discuss Azure Key Vault, you need a subscription
    to Azure. You can create one here: [https://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free).'
  prefs: []
  type: TYPE_NORMAL
- en: Security for system programmers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I started programming, security was not an issue. Imagine this – my computer
    had one connection, the one to the power outlet on the wall. And, of course, the
    computer was attached to a television to display whatever it needed to show. Yes,
    a TV. I did not have a monitor; I could not afford one back then. I started the
    machine up, and it would load the OS and the basic programming environment from
    ROM. And that was it. This setup was extremely secure – there were no attachments
    to anything that could interfere with my machine and data. I kept the computer
    in my bedroom, so physical security was also taken care of (no one goes into a
    teenager’s bedroom voluntarily; the mess was unbelievable).
  prefs: []
  type: TYPE_NORMAL
- en: Fast-forward to today. My desktop computer is always on and always connected
    to the internet. Some systems I have written run on a virtual machine with a cloud
    provider; others are serverless and waiting for connections.
  prefs: []
  type: TYPE_NORMAL
- en: My firewalls and application gateways inform me that other systems constantly
    try to connect to all those environments and machines. I have the feeling that
    all of those machines are under constant threat.
  prefs: []
  type: TYPE_NORMAL
- en: Security is something everybody in the software industry needs to be aware of
    all the time. Only adding security measures at the end of the development cycle
    is the best way to ensure attackers have access to your system. You are bound
    to forget something. Security must be considered at every step, from the initial
    design to maintaining a running system.
  prefs: []
  type: TYPE_NORMAL
- en: As I said in the second paragraph of this chapter, security is a mindset. You
    need to ask yourself continuously, “Can someone take advantage of the things I
    am doing?”
  prefs: []
  type: TYPE_NORMAL
- en: What could happen if we have a vulnerability?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I can almost hear you say, “Hey, I write low-level code, not some fancy customer-facing
    website. Why should I be bothered with all this?” That is a reasonable response,
    but there are ways you, as a system programmer, should be very aware of the risks.
    If you aren’t, the results could be catastrophic. Let me outline some of the things
    that could happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privilege escalation**: A lot of the code we write runs with elevated privileges.
    Hackers who exploit a vulnerability can escalate their privilege from regular
    users to administrators, giving them extensive control over a system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data theft**: Hackers who gain access to your system can use that to steal
    sensitive information, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User data, such as personal information and credit card information
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidential business data, including trade secrets, intellectual property,
    and internal communications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System logs and configurations that might contain information about other systems,
    so they can be targeted as well
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code injection**: Hackers might exploit vulnerabilities such as buffer overflows
    or inadequate input validation to inject malicious code into a process. This action
    might enable them to do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute arbitrary commands**: They can run any code, potentially installing
    malware, ransomware, or other malicious software'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alter system behavior**: Change how a system behaves, causing instability
    or hiding their activities'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial of service or distributed denial of service**: Attackers can disrupt
    the normal operation of a system by doing the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overloading a process**: Sending excessive requests or data, causing a system
    to crash or become unresponsive.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource exhaustion**. Consuming system resources such as CPU, memory, or
    disk space, leading to performance degradation or system crashes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backdoors and persistent access**: Once they have control over a background
    process, hackers can do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Install backdoors**: Create hidden entry points to re-access a system even
    if the initial vulnerability is patched'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Establish persistence**: Modify a process to restart or maintain their presence
    on the system, even after a reboot or restart'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spying and surveillance**: Hackers can use compromised systems to monitor
    and collect data over an extended period:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keystroke logging**: Capture what users type, potentially stealing passwords
    and other sensitive information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen capture**: Periodically take screenshots to monitor users’ activity'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network traffic monitoring**: Capture data being sent to and received from
    other systems'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spreading malware**: A compromised system can be used as a launchpad for
    further attacks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lateral movement**: Use a compromised system to move to other systems within
    a network'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Propagation**: Spread malware to other devices or processes, creating a larger
    attack surface'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulating data**: Hackers can alter data processed by a background process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data corruption**: Introduce errors or malicious modifications to data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tampering with logs**: Modifying or deleting log entries to cover their tracks
    makes detecting a breach harder.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, there are a lot of things that can go wrong if we leave our
    systems vulnerable. To hammer the point home, imagine a background process that
    monitors a serial port and handles data from an external device. That process
    runs 24/7, and since it deals with the lower-level Win32, we run it as an administrator.
    But we made a mistake somewhere, and a hacker accessed our process. The following
    is a potential scenario that might happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploiting the vulnerability**: The hacker finds and exploits a buffer overflow
    vulnerability in the process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Privilege escalation**: They escalate their privilege to gain administrative
    rights.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data theft**: They extract the entire database of user credentials and personal
    information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Installing a backdoor**: They install a backdoor to maintain access and monitor
    user activities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data manipulation**: They alter account balances and change bank information
    for accounts payable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Disruption**: Finally, they launch a DDOS attack, bringing your whole company
    down.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you think this is exaggerated, I suggest you go online and find articles
    about security hacks. If you look hard enough, you will find many examples. Most
    companies are reluctant to share their experiences, but the data is there.
  prefs: []
  type: TYPE_NORMAL
- en: How to protect yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If I have scared you a little bit, good. It can be scary. But do not worry
    too much – following some good security practices can avert many of these risks.
    In fact, the rest of this chapter is all about what you, as a developer, should
    do to protect your systems. However, besides the coding aspect of security, there
    are several other things you should be doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Holding regular security audits**: Continuously review and audit your code
    and systems for vulnerabilities. I really would suggest hiring an external party
    for this. They have a lot more experience, and they are not likely to have the
    same blind spots as the people who developed the systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input validation**: Ensure all inputs are properly validated and sanitized.
    Just do not trust anything coming in from an external source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Least privilege principle**: Run processes with the minimum necessary privileges
    to limit potential damages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User modern security practices**: Employ encryption, secure coding practices,
    and up-to-date third-party libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and logging activities**: Keep detailed logs and monitor for suspicious
    activities to quickly detect and respond to breaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, now you know why security is important. Now, let’s investigate how to do
    that in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your application likely has **strings**. Most of them are irrelevant to the
    outside world; if you write “Hello World” to a console, an attacker probably couldn’t
    care less about that. But other strings are a lot more interesting to these people.
    Consider connection strings to a database, for instance. They can be an excellent
    resource for a hacker. Then, there are other data, such as user information, passwords,
    and credit card information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can distinguish between two types of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings that are part of your code and thus are compiled in the binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings that are handled in your code and originate from an outside process
    or go to an outside process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see whether we can protect this sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we deal with the strings in your application that are part of your code
    base. Think of things such as passwords and connection strings. In an ideal world,
    you store this information in an external file. The reason for this is that by
    not having them in your source code, you can change them without recompiling your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that a breach has been detected somewhere in your organization. The
    security department tells everybody to update their passwords. In your case, that
    would mean opening Visual Studio, loading the solution, changing the password
    to the database server, recompiling, and finally, redeploying the system. Or,
    on second thought, you could just change the password in the config file. I know
    what I would prefer to do!
  prefs: []
  type: TYPE_NORMAL
- en: Still, having a password in a config file is a pretty bad idea. If you have
    the password as part of your code, an attacker must decompile your assembly to
    find it. If we store the password in a text file, all the attacker has to do is
    open that file and read the password. To counter that, we encrypt the password.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed encryption several times before, so I am sure you can figure
    out how to do this. But all the techniques we have looked at so far require a
    password to be part of the source code, and we just determined that that is a
    bad idea. Storing a password in a config file to enable decrypting the rest of
    the file sounds even worse. There must be a better way. There is.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s investigate this.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a sample application that has some sensitive information. I have this
    information in a file called `appsettings.json`. You know – a typical .NET-based
    configuration file. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have two sections – insensitive data and data we do not want others to read.
    We need to protect the latter. Now, the way we handle this is a bit inconvenient.
    We must write a separate program to encrypt the data before writing the code that
    uses this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new **console application** and add the following NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.FileExtensions`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.Json`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.DependencyInjection`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.DataProtection`'
  prefs: []
  type: TYPE_NORMAL
- en: These packages are needed to read and use configuration files, and `Microsoft.AspNetCore.DataProtection`
    is there to protect our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we have to set up the dependency injection infrastructure. The data
    protection tools use this; they require packages to be injected when required.
    So, the first lines of our code look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We first create a `ServiceCollection` instance. Then, we call `AddDataProtection()`
    to that collection so that all required packages are loaded and ready to use.
    After getting `serviceProvider`, we get an instance of an `IDataProtector` interface
    by calling `GetDataProtector()`. This method expects a parameter – a string describing
    the purpose. This string can be anything you want; it acts as a label so that
    you can group items. Think of it as labeling your encrypted data so that you can
    later track what belongs to what.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we read the config file into the configuration infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to mark your `appsettings.json` file as `Copy when newer` in Solution
    Explorer; otherwise, your code will not load it.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, now for the funny part – we reread the configuration file, but this time
    as text. We do this because we will replace the sensitive strings with encrypted
    versions. This is the code to read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `json` string now holds our complete settings file. It’s time to start encrypting!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we read the section we want to protect, iterate through all the items
    in that section, encrypt the values, and then change the strings in the `json`
    variable. Finally, we write the new string to the configuration file. This is
    what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The call to `dataProtector.Protect()` does all the hard work for us. It takes
    a string and encrypts it. We replace the old value with the new one and write
    it in the file.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the `appsettings.json` file (the one in the folder with the debug
    build, not the original one!), you will see that the secret strings are not human-readable
    anymore. So, anyone opening that file will not have access to our secrets!
  prefs: []
  type: TYPE_NORMAL
- en: Reading encrypted data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an application where you intend to use secret strings, you can simply read
    the data from the configuration file and decrypt them. That goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, I reload the configuration to ensure the object has the encrypted strings.
    Then, I get the section and read the first setting and its value. Finally, I use
    `dataProtector` to decrypt the string. The result is a lovely, unencrypted, readable
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you should not do encryption and decryption in production systems
    using the same program. You need to split them up. When you do, remember to use
    the same string for the purpose. If you do not do that, you will get an exception
    telling you that the decryption did not work. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I call `GetDataProtector()` with a new purpose string, and I use that to unprotect
    the string. That will not work. If I use `"MySecureString"` instead of `"AnotherSection"`,
    it works again, even though I have a new `DataProtector`.
  prefs: []
  type: TYPE_NORMAL
- en: Where are the keys?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder why I never specified a password to encrypt and decrypt. The
    answer is that the framework generates one for me. It is more or less hidden in
    the `"%LocalAppData%\ASP.NET\DataProtection-Keys"` folder. This special folder
    is where the runtime stores and reads the keys. Open that folder, pick one of
    the XML files, and open it to see what it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify another folder where the system stores the keys. Change the
    start of the program, where we call `AddDataProtection()` to add the data protection
    classes to `serviceCollection`, to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This line of code tells the system to use the folder specified in `myKeyFolder`
    to store the keys.
  prefs: []
  type: TYPE_NORMAL
- en: In a production system, you can distribute the key file and store it in a known
    location. Of course, any attacker with access to your `appsettings.json` file
    probably has no problem finding the key file. There must be better ways to deal
    with this. And there are, but I will deal with that in the next part. First, I
    want to talk about the strings that are in memory. Those can be hardcoded strings
    in your code or decrypted strings from your settings file. Are those a potential
    security risk? Let’s find out!
  prefs: []
  type: TYPE_NORMAL
- en: Handling strings in memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might think encrypted strings in a configuration file are safe. After all,
    nobody can read them. Only your program can access them, provided it can access
    the key file. The program can read and decrypt the settings in memory, making
    everything safe and secure. Unfortunately, that is not the case. Finding that
    kind of information in a running program is not hard.
  prefs: []
  type: TYPE_NORMAL
- en: Disclosing strings in your application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I agree. This isn’t the most exciting piece of code you have ever seen, but
    it does what it needs to do. It loads a string in memory and then waits for the
    user to press a key to abort the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I compile this in release mode and start the handy **WinDbg** tool
    (you can install that by going to the Microsoft Store and searching for it). In
    that case, I can do all sorts of inspections on a running program. With some digging
    around, I finally found this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: WinDbg gives me all sorts of information about the `System.String` object found
    at a specific memory location. Part of that information is the contents of that
    string – `"This is my` `Open String"`.
  prefs: []
  type: TYPE_NORMAL
- en: My sample program is straightforward, so finding the information wasn’t hard.
    But the fact that I can actually do this by just attaching it to a running program
    shows you what a hacker can do. If your program takes encrypted data from an `appsettings.json`
    file and keeps that string in memory, you might as well not encrypt your data
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: There must be a better way. And guess what – there is!
  prefs: []
  type: TYPE_NORMAL
- en: Using SecureStrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve discovered that strings in memory are not secure. The people behind the
    BCL thought of this as well and gave us an alternative – `SecureString`.
  prefs: []
  type: TYPE_NORMAL
- en: That sounds like a beautiful idea, but `SecureString` is less convenient than
    a “real” string. Not by far. However, it does have one advantage – the data in
    it is encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating `SecureString` is easy enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But that doesn’t really help us. We want some data in it. That’s not hard,
    but you must copy the data one character at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, `secureString` contains some data. The nice thing is that the data is encrypted
    and not readable anymore. The call to `MakeReadOnly()` is important. By making
    it read-only, you ensure that the string is not changeable anymore, which helps
    in performance.
  prefs: []
  type: TYPE_NORMAL
- en: '`SecureString` is mainly used to store passwords. A lot of classes in the BCL
    that need passwords accept `SecureString` as their parameter. For instance, these
    are some of the classes that can work with `SecureString` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProcessStartInfo`: When starting a new process, you can provide a password
    as `SecureString` using the `ProcessStartInfo` struct, or by calling an overload
    of `Process.Start()` that accepts `SecureString`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkCredential`: When you need to identify a resource with a network resource,
    you can use `NetworkCredential` to pass along the required parameters, such as
    the username, password, and domain. The password can be an instance of the `SecureString`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CspParameters` and `X509Certificate`: These are important if you are dealing
    with certificates, and they also allow `SecureString` instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, now we have a secure string. Great. But we still have an issue. Can you
    spot it? I will give you a minute while you look at the code that we last discussed.
  prefs: []
  type: TYPE_NORMAL
- en: The problem, of course, is where we seed the secure string. We create a string
    in memory with the `"This is a big secret"` contents and transfer it to the secure
    string. But the original string is still in memory.
  prefs: []
  type: TYPE_NORMAL
- en: We would have had the same issue if we had read an encrypted string from a configuration
    file, decrypted it, and copied it to the secure string. The original, decrypted
    string is still in memory and can be read externally.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to circumvent it is to erase that provisional string as soon as
    you finish it. The unencrypted strings should be in memory for as long as possible.
    Technically, it is still vulnerable, but the attacker has to break the running
    application exactly when the strings are in memory. The attack window is still
    there, but it is very, very small.
  prefs: []
  type: TYPE_NORMAL
- en: 'Erasing a string is not the same as assigning a new value – strings are immutable.
    When you try to change the string, you get a new instance, and the old data is
    still readable. The only way to completely eradicate it from memory is to erase
    the chars that form the string. You can erase a string from memory with something
    similar to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You have to set the `'0'`. Since `0` denotes the end of the string, it is harder
    to see the original length of the string.
  prefs: []
  type: TYPE_NORMAL
- en: I am not saying you need to call this method for every string. But suppose you
    are dealing with strings that you absolutely do not want to leak. In that case,
    this might solve the intermediate problem of copying data to a secure string.
  prefs: []
  type: TYPE_NORMAL
- en: But where do we get the decryption keys from? We can distribute them as shown
    previously, but there are other ways. Let’s discuss those! However, before doing
    that, let’s think about what we have learned. This was a complicated topic; dealing
    with strings in memory is not something many C# developers think about. But therein
    lies the problem – since people do not think about it, they are unaware of any
    risks.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, you now know about the risks and are ready to deal with them if
    you encounter the need for this level of security.
  prefs: []
  type: TYPE_NORMAL
- en: Using key management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keys are the best-kept secrets of your application. Keys are used to encrypt
    and decrypt a lot of sensitive data. This means the keys themselves are even more
    sensitive; they hold the power to unlock all your secrets. Storing a key in a
    text file next to an executable might not be the best way to treat this valuable
    piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: How and where you store the keys depends on where you run your program. If your
    application lives in the cloud, you should use a cloud-based key management system.
    If you run your systems on a machine you can touch, you need another solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure Key Vault
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Azure Key Vault** is a centralized, cloud-based secret and key management
    solution. It is straightforward to set up and easy to use. Its main purpose is
    to guard secrets and keys for Azure-based applications. However, it can also be
    used by applications running on-premise.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will not teach you how to create a key vault here; plenty of resources can
    help you. For instance, this is a good resource from Microsoft itself: [https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal](https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a key vault deployed and have added a secret, retrieving that
    secret is simple. But before we look at the code to get that secret, we must ensure
    access to the resource. That means we make notes of the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Item name** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Key vault name | `mykeyvault` | The name of the key vault you specified when
    you created it |'
  prefs: []
  type: TYPE_TB
- en: '| Secret name | `MySecretValue` | The name of the secret |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.1: Values to find the Azure Key Vault secret'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you should change these values to match your setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C# application, we need to add a couple of NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Azure.Identity` to enable authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Azure.Security.KeyvaultSecrets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have installed those packages, the code to get the secrets out of
    the key vault is very straightforward. For instance, you can use this helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet shows how to use the `SecretClient` class from the previously
    installed package to access the secrets in the key vault. To authenticate this
    request, I use the `DefaultAzureCredential` class. Using this class means I authenticate
    against the Azure URL with the current user’s credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a production system, you would not do that. Instead, you should probably
    create a registration for your system and use that to authenticate. Authentication
    in Azure is a topic that deserves its own book, but the following URL should get
    you on your way: [https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line](https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line).'
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even when using Azure (and not using the default credentials), you need to store
    some sort of access key, secret ID, or user ID and password before you can use
    the resources. The same applies when you store data encrypted in your `appsettings.json`
    file – you need a key to decrypt. As we saw in a previous sample, you can ask
    the .NET runtime to create a key for you and store it in a known place. That is
    one way of solving this issue, but there is also a much simpler way. We can use
    environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables are convenient, but they are not secure – not by a long
    shot. Everybody can look up their values if they have physical access to the machine.
    Never store sensitive information in environment variables unless you can be confident
    the virtual or physical machine is secure.
  prefs: []
  type: TYPE_NORMAL
- en: An environment variable is simply a key-value pair that lives in Windows. It
    is usually used to contain settings from outside of the process. This is why they
    can be useful for holding data we need to identify resources; they can change
    on the fly without changing or restarting our application.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variable scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Where precisely these variables live and how long they persist depends on the
    kind of environment variable. The variables can have a scope that affects where
    they persist (and how long they do so). These are the options we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process scope**: These variables are only available to the process that defined
    them, or any child processes that the main process spawns. They can be useful
    for temporary values that can be discarded if the process goes out of memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User scope**: They are specific to the currently logged-in user. They are
    available to all processes that run under that user’s credentials. These variables
    persist across logins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Machine scope (or system scope)**: These variables are available to all users
    and processes on a machine. They require administrative privileges to set and
    modify but not to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session scope**: These variables are scoped to a user session. This scope
    is more or less the same as the user scope, but the variables are discarded as
    the session ends. That happens, for instance, if the user logs off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volatile environment variables**: This is a special category mainly used
    by a system. They are intended to be temporary. Users typically do not handle
    or even access these. An example is the settings set during boot time that can
    be removed once the login process ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are a lot of different scopes, some of which most users
    have never even heard of before. Make sure you pick the correct one!
  prefs: []
  type: TYPE_NORMAL
- en: Setting environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we can use our C# code to set variables. However, we usually do not
    do that; in our case, we want to set some secret data outside our application
    and then use it in our code. This means we have to set the data from the outside.
    Setting the values is typically done during the installation of our software.
    However, during development, you have to do it manually.
  prefs: []
  type: TYPE_NORMAL
- en: Setting these variables is very easily done from a PowerShell session, and the
    exact syntax depends on the scope you want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Process scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I only add this here for completeness. After all, if we set a variable so that
    we can read it in our application, using the **process scope** does not make sense.
    The variable is set in the scope of the PowerShell session and thus is not readable
    in our application. But anyway, here is how you do it. In PowerShell, enter this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new variable named `"MY_SECRET_ID"` in memory and assigns
    it the `12345678` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you read the data, you’ll be surprised to see that it is almost as simple
    as setting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command should return the `12345678` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting and reading the data, you might want to erase it. Again, this
    is very easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that that last command happens automatically if you close the PowerShell
    session.
  prefs: []
  type: TYPE_NORMAL
- en: User scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**User scope** is the first useable scope for our purposes. Setting this variable
    goes like this in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new variable and sets the data. The variable is stored
    in the Windows Registry under the `HKEY_CURRENT_USER\Environment` key. Windows
    keeps this value across reboots. Since the data is stored in `HKEY_CURRENT_USER`,
    you can only read the data in processes belonging to that user. That means you
    can read it during debugging in **Visual Studio** (**VS**), but only if you run
    VS under the same credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Machine scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The broadest scope is the **machine scope**. Setting data is just as simple
    as using the user scope, with one tiny addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The use of `/m` at the end makes this variable a machine-scoped one. This means
    it is stored in a different location as well; you can now find this variable in
    the Windows Registry under the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session
    Manager\Environment` key. This variable is persisted across reboots and is accessible
    to all users and processes on that machine.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the variables in your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is little use in storing data somewhere if it is impossible to read. So,
    let’s investigate how we can use that data in our C# application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the data, you only need one line of code, which is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: However, remember that `MY_SECRET_ID` was set using the user scope. So, if you
    run your PowerShell command as an administrator, you must also run VS as an administrator.
    Otherwise, the code returns an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you want to see how to read the machine-scoped variable? I thought you might.
    This is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that is the same code, with the only change being the variable name we
    are looking for. Not all code in this book is hard to understand!
  prefs: []
  type: TYPE_NORMAL
- en: There are many more ways to handle keys, but you have now seen two of the most
    used ones. You now know how to use Azure Key Vault and have learned a lot about
    environmental variables. Let’s move on!
  prefs: []
  type: TYPE_NORMAL
- en: Using the right privilege level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most systems do not need to run as admin. Requiring your application to have
    admin rights is a potential security risk. It would be best to ensure your application
    runs on the lowest security level possible to avoid potential leaks.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes you have no choice. There are certain cases where admin-level
    privilege is needed. The bad news is that this happens often in the world where
    we, system programmers, live. Our systems need an admin level more than a regular
    program does.
  prefs: []
  type: TYPE_NORMAL
- en: Admin-level scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s investigate some areas where elevated privileges are needed if we want
    our system to do what it needs to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Windows\System32` directory is a good example of a protected directory.
    You need elevated rights if you want to read something from that folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE` key. That area cannot be reached without the proper security
    level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service management**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting, stopping, or configuring Windows services is another nice example
    of requiring admin-level privileges. Also, installing and uninstalling these services
    need that level of trust. Since we work a lot with background processes, we can
    imagine scenarios where we need to control those processes from other processes.
    That means elevating the level again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Network configuration**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying network settings is also a reason you might need elevated privileges.
    These tasks include changing an IP address, configuring network adapters, and
    adjusting firewall rules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**System monitoring** **and diagnostics**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the performance counters or diagnostics tools require elevated privileges.
    Also, reading system logs in an event or other logs requires admin access.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is not an exhaustive list; there are other areas as well. If you run into
    one of those, you will find out soon enough – your system won’t work and crash
    with a nice exception.
  prefs: []
  type: TYPE_NORMAL
- en: Impersonating as an admin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your system does something from the preceding list, you might be tempted
    to install your system with admin credentials. That way, you are sure it always
    works. But as we have discussed before, that is not necessarily a good idea. It
    would be much better to go to the administrator level only when needed. When done,
    revert to the regular, less privileged user account.
  prefs: []
  type: TYPE_NORMAL
- en: How can we do that? First, we must create an account with admin-level rights
    on the machine where our software will run. I would not use the generic administrator
    account found on machines; you are better off using a dedicated account.
  prefs: []
  type: TYPE_NORMAL
- en: On my machine, I created an account named `MySecureAdmin`. I gave it the extremely
    safe password `P@ssw0rd!`. No, that’s not a password I would use in real life,
    but for this demonstration, it will suffice. This account is a local admin. And
    finally, my machine has the name `DennisMachine`. This is all the information
    you would need if you wanted to log in as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: The technique to temporarily act as another user in your application is called
    impersonating. Let me show you how that is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have created a console application and added a new class called `ImpersonationHelper`.
    The class imports two methods from the Win32 API – `LogonUser` and `CloseHandle`.
    This is their signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `LogonUser` API resides in the “`advapi32.dll"` DLL, while the `CloseHandle`
    API can be found in `"kernel32.dll"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I declare two constants that we will need later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all we need to start impersonating. This is the code that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let me explain what is going on here.
  prefs: []
  type: TYPE_NORMAL
- en: The method gets all the required information to log into Windows – the username,
    password, and domain. We also give it the code we want to run under these credentials
    in the form of an `Action`.
  prefs: []
  type: TYPE_NORMAL
- en: We call `LogonUser()` and give it the username, domain, and password. Then,
    we specify the login type; we give it `LOGON32_LOGON_BATCH`. This type is used
    for batch servers. Batch servers execute code on behalf of a user without their
    intervention. In contrast, a standard login would use `LOGON32_LOGON_INTERACTIVE`.
    The `BATCH` option results in higher performance, which is very convenient for
    us. After this, we give it the login provider and instruct it to use the default
    provider by passing `LOGON32_PROVIDER_DEFAULT`.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, we will get a pointer in `SafeAccessTokenHandle`. If it does
    not work, we get an error.
  prefs: []
  type: TYPE_NORMAL
- en: With that handle, we can call `WindowsIdentity.RunImpersonated()`, which in
    turn calls our action.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to call `Dispose()` on the handle!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this code is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code uses our new class to temporarily log in as another user. But before
    that, it shows the current username. I do the same in the `Action`, but the results
    will differ. We are now logged in as the new user, which should also be shown
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to log out – the call to `LogonUser()` doesn’t alter the logged-in
    state of that user; it is just required to get the handle. The moment we dispose
    of the handle, the impersonation also terminates. This means we are now back operating
    under the standard credentials. Run this sample and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Impersonation is another nice tool in your toolbelt, but use it sparingly. Only
    increase the trust level in your applications if you absolutely need it. Oh, and
    I am sure I do not need to remind you that storing usernames and passwords in
    plain code in your application is terrible, especially if they belong to admin-level
    users. Right?
  prefs: []
  type: TYPE_NORMAL
- en: Many developers, by default, assume their code needs admin-level privileges.
    After reading this section, you now know better. We discussed the situations where
    admin-level is required, but please remember that less is more, especially regarding
    privilege levels! And if you need admin-level privileges in your code, you know
    how to take care of that temporarily before returning to a normal level.
  prefs: []
  type: TYPE_NORMAL
- en: How to transmit network data securely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, keeping data sensitive on your machine is hard. But things
    get even more complicated once we leave the safe haven of the machine we control
    and venture into the wasteland of networks.
  prefs: []
  type: TYPE_NORMAL
- en: I probably do not have to remind you that you should never use a public website
    that uses an HTTP connection instead of an HTTPS connection. The “S,” after all,
    stands for “Secure.” That is what we want – we want our data to be encrypted,
    and we want to be confident that the server we talk to is secure and belongs to
    the party we think it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to our code – if we talk to an outside system, we want to ensure
    that our data is not being tampered with or intercepted. That also applies to
    other systems when they connect to us – we want to give those users the same sense
    of security. How do we achieve that? The answer is simple – we do the same as
    those HTTPS servers. The next question is, how do we implement that? And that
    is slightly more complicated. But don’t worry – I will walk you through it step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: How HTTPS works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let me ask you a question. How do you know you can trust the website you visit?
    Just because it says HTTPS in the address bar? But what does that mean? How can
    that be a guarantee? To answer that, we need to look at what HTTPS actually means.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTPS** stands for **Hyper Text Transport Protocol Secure**. This is a variation
    of regular HTTP traffic – it has added security. Let’s examine the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your browser, you enter a URL: [https://www.microsoft.com](https://www.microsoft.com).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser resolves the domain name to an IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client initiates a TCP connection with the server using a three-way handshake
    (SYN, SYN-ACK, and ACK).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The client sends a `"ClientHello"` message to the server. This message includes
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supported TLS versions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported cipher suites
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported compression methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A randomly generated value (client random)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Session IDs and extensions (optional)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server then responds with a `"ServerHello"` message, which includes the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chosen TLS version
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The chosen cipher suite
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The chosen compression method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A randomly generated value (server random)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The session ID (if supported and desired)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The server sends its digital certificate, including its public key and a digital
    signature, from a trusted certificate authority.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the server may (if required) send a `"``ServerKeyExchange"` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, the server requests a client certificate for mutual authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the server sends a `"ServerHelloDone"` message, indicating that this
    is the end of the handshake.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client then optionally sends its own certificate (if requested).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends a `"ClientKeyExchange"` message. The contents depend on the
    algorithm chosen. For instance, if RSA is chosen, the client encrypts a pre-master
    secret with the server’s public key and sends that to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends a `"CertificateVerify"` message to prove it owns the client
    certificate. This involves signing a hash of the handshake messages using the
    client’s private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both parties then generate the session keys (symmetric keys) for encryption
    and authentication, using the pre-master secret and the random values exchanged
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client then sends a `"ChangeCipherSpec"` message to inform the server that,
    from now on, all messages will be encrypted using the negotiated keys and algorithms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server also sends a `"``ChangeCipherSpec"` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends a `"Finished"` message, which is a hash of all the handshake
    messages encrypted with the session key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server responds with its `"Finished"` key, with the same sort of information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From now on, the client and the server can use the keys and algorithms to encrypt
    and decrypt the data flow.
  prefs: []
  type: TYPE_NORMAL
- en: If you think this sounds complicated, you are right. The good news is that we
    do not have to worry about this. All of the classes in the BCL dealing with HTTP
    handle this for us. All you have to do is connect to a secure server, specify
    that you want to use SSL, and you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates and certificate authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding steps outline how the client and server exchange keys securely.
    However, a key question remains – how do they know they can trust each other?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to that question lies in the use of certificates. A certificate
    is a digital document containing information about the certificate’s owner. It
    includes the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subject**: The entity that the certificate represents (for instance, the
    website’s domain name)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issuer**: Who issued the certificate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key**: The public key of the entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validity period**: The date range in which the certificate is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial number**: A unique identifier for the certificate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: The digital signature of the issuer, verifying that the certificate
    is genuine and has not been tampered with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you get a certificate from a website, you can use that to verify that the
    site you are connecting to is indeed the one it claims to be. If the information
    on the certificate doesn’t match what is expected, you had better not use that
    site.
  prefs: []
  type: TYPE_NORMAL
- en: But how can you be sure that the certificate is valid? This question leads us
    to the last part of the SSL infrastructure – certificate authorities.
  prefs: []
  type: TYPE_NORMAL
- en: A certificate has to be obtained from a third party. These companies sell certificates,
    but only after they have verified that the one requested a certificate is who
    they say they are. We call these companies **certificate authorities** (**CAs**).
    These authorities are regularly audited to make sure they can be trusted. This
    starts a whole chain – a CA has its own certificate. However, that certificate
    is a root certificate; it is implicitly trusted. No organization guarantees the
    CA’s certificate is valid. But if we trust that root certificate, we can assume
    that all certificates signed with that root certificate are also safe. Then, we
    can use the secondary certificate to sign another certificate. We can build a
    whole tree of trusted certificates, all of which can be traced back to the CA
    that issued the original certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Windows keeps track of all the trusted root certificates and stores them on
    the local machine. That way, the software can compare the hashes with the data
    it receives from the HTTPS server and make sure the certificate is secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see these root certificates, run the `mmc.exe` command on your machine.
    Then, press *CTRL* + *M* to add the **Certificates** snap-in. Open the tree on
    the left to see all the trusted root certificate authorities. This is what it
    looks like on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF2.1: Root certificates in Windows](img/B20924_13_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Root certificates in Windows'
  prefs: []
  type: TYPE_NORMAL
- en: Your list will undoubtedly differ from mine, but these are all trusted root
    certificates. Windows regularly updates this list to make sure it is still valid.
  prefs: []
  type: TYPE_NORMAL
- en: You must get a certificate from one of these CA organizations to set up a HTTPS
    server. They all have a slightly different process, so I suggest you investigate
    some of them to see if they are suitable for you. It doesn’t matter which CA you
    use; all certificates suit your purposes. Some are faster than others, and others
    are cheaper than others. Just pick what you feel is the best option for you.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware of free certificates!
  prefs: []
  type: TYPE_NORMAL
- en: I will be very clear about this – there are no free certificates to be had at
    the time of writing. A few CAs issued free certificates, but that doesn’t happen
    anymore. The demands for verification have significantly increased; the CA needs
    to be more thorough than ever to combat cybercrime. And that costs money. If you
    see a CA that offers a free certificate, do not fall for it. Remember that if
    something sounds too good to be true, it probably is. Some CA organizations provide
    a free certificate, but they have other demands. You have to build your software
    on their pipelines, or you have to host with them. Ultimately, you still pay for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we know what a certificate is and how to get one. But let’s be honest
    – if you want to play around with certificates or are still in development, you
    might not be ready to purchase a certificate. If that is your situation, then
    I have good news. There is a free alternative – you can make your own certificate!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a development certificate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, you can create your own certificate. But this is just for experimental
    or development purposes. You cannot use it in a production system; the verification
    will fail, since your certificate is not vouched for by a CA.
  prefs: []
  type: TYPE_NORMAL
- en: The tools to create a certificate are part of the SDK installed with VS. Let’s
    make a certificate!
  prefs: []
  type: TYPE_NORMAL
- en: 'In a developer command prompt or PowerShell terminal, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`MakeCert`, part of the SDK, is the tool to create a certificate. There are
    many options, but we do not need most of them. I have given you the minimum we
    need for our purpose. Let’s investigate what we did by looking at the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | This means the certificate is self-signed and not signed by a CA.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``pe` | This marks the private key as exportable. The private and public
    keys are all part of the certificate, so you need this option if you want a copy
    of the private key. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``ss PrivateCertStore` | The specifies the certificate store where the
    generated certificate will be placed. In our case, we use `PrivateCertStore`,
    one of those entries in the Management console we looked at earlier. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``n "CN=localhost"` | This is the `localhost` (**CN** means **common name**)
    so that the clients know which domain this certificate belongs to. |'
  prefs: []
  type: TYPE_TB
- en: '| `-``sv testcer.pvk` | We marked the private key as exportable; this option
    does the export. The private key is stored in the `testcer.pvk` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `testcer.cer` | The filename of the certificate |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.2: Parameters for MakeCert'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the `MakeCert` command, you will be asked to enter passwords. Make
    sure you remember them and store them somewhere secure!
  prefs: []
  type: TYPE_NORMAL
- en: This command results in two files – `testcer.cer` (the certificate) and `testcer.pvk`
    (the private key). Make sure you treat these files as confidential; they contain
    your private keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The certificate can now be used, but not for everything we want to use it for.
    Later, we will use the certificate to encrypt data streams, but that will require
    a different format. These tools need a `pfx` format. Luckily, converting a `.cer`
    file to a `.pfx` file is easy enough. Just enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `pvk2pfx` tool takes the exported private key and the certificate and converts
    them into a `.pfx` file. The parameters speak for themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The certificate we created is now stored in the certificate store under the
    `PrivateCertStore` section. But we also need to store the newly generated `.pfx`
    file in the certificate store for later use. To do this, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `certutil` command invoked another handy tool to take the
    new `testcer.pfx` file and store it in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: And that is all there is to it. We now have our own certificate, so let’s secure
    some network traffic!
  prefs: []
  type: TYPE_NORMAL
- en: Securing TCP streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a web server, such as IIS, you can import the `.pfx` file there.
    That way, you can use HTTPS on your local network. Again, this is not SSL; other
    clients will not accept that self-signed certificate. It is for development only.
  prefs: []
  type: TYPE_NORMAL
- en: However, I am not currently interested in setting up a HTTPS server. I am more
    concerned about the other network communication types we discussed previously.
    For instance, how can we secure simple, straightforward TCP communications? If
    we want to use sockets, how do we secure that? The answer is to use SSL, as we
    have seen with HTTPS. Let’s build some secure code!
  prefs: []
  type: TYPE_NORMAL
- en: I have created two console applications. One is a server waiting for incoming
    TCP connections; the other is the client connecting to that server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the server code first. I have created a new class called
    `SecureServer`. This class gets a constructor that takes the required information
    to set up the server. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We pass the file path to the certificate we just created and the password in
    the port that the TCP socket listens to (I told you to write that down, didn’t
    I?). We store the port number in a local variable and use the other two variables
    to create an instance of the `X509Certificate2` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the method that starts the server. We investigated that before (in
    [*Chapter 8*](B20924_09.xhtml#_idTextAnchor181), *The One with the Network Navigation*),
    so there shouldn’t be any surprises here. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of `TcpListener`, tell it to use any IP address on the
    machine, and give it the correct port. Then, we call `Start()` to accept incoming
    connections. In a never-ending loop, we wait for a client to connect. If that
    happens, we accept the connection with a call to `AcceptSocketAsync()` and pass
    the handling of the connection to a method called `HandleClientConnection()`.
    Let’s look at that one next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first half of the method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using a normal stream, we use a specialized one called `SslStream`.
    This takes `NetworkStream` and a parameter, indicating whether the stream should
    be kept open when we finish it (we don’t want that, so we give it a `False`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `AuthenticateAsServerAsync()` on that `SslStream`, giving it the
    certificate, tell it that we do not require a client certificate, also tell it
    that we want to use TLS version 1.2, and finally, inform the method that we want
    to check the certificate revocation (hence the `True`). This one line of code
    makes sure the server does all the steps needed for it to set up a secure connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the method is straightforward – we read data coming in and display
    it. This is the rest of that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And that is all! Well, almost – we need to use this method as well. But that
    is even simpler. In the `Main()` method, use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With all this, we have a working and secure socket server!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, the client! For the client, I did a similar thing. I added a new class
    called `SecureClient` with the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This constructor takes two parameters – the name of the server and the port
    it wants to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a method called `ConnectAsync()` that allows the client to
    connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This method starts with familiar code – we create an instance of `TcpClient`
    and give it the server and port. After that, we open `NetworkStream` from that
    `TcpClient`. But then things get more interesting – we create a new instance of
    the `SslStream` class, giving it `NetworkStream`, the same `False` that indicates
    that we do not want to keep the stream open when we are done with it, and a callback
    method called `ValidateServerCertificate`. After that, we call `AuthenticateAsClientAsync()`
    to make sure the client and the server exchange messages, as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this method is nothing special – we just write the bytes to the
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `ValidateServerCertificate()` callback method next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method is called when we create `SslStream` and is part of validating the
    server’s certificate. The method itself is straightforward – we just check to
    see whether there are any errors in the `SslPolicyErrors` enum. If there are,
    we return `false`. This is picked up by the `SslStream` class, which will raise
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: A developers’ trick – simplify your development
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing a solution like this but do not have a valid certificate,
    there is a quick hack you can use. Change the validation method to always return
    `True`. That way, your client will accept all sorts of certificates, regardless
    of their validity. Just do not use this technique in production code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this class is easy. This is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Just a word of warning – this is only for development purposes. The code itself
    is fine for any scenario, but the certificate we created is not. We signed it
    ourselves, so no real client should accept it. Next, we specified that the server’s
    name is `"localhost`”. This apparently only works on your machine, not across
    a network. You could change that when you create the certificate, of course.
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it – a working TCP client using a secure channel. You have
    made it much harder, if not impossible, for a hacker to eavesdrop and listen in
    on your communications!
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have to be honest with you. We only touched briefly on the subject of security.
    There are hundreds, if not thousands, of books on this topic. But the information
    I gave you should help you get in the right mindset. Remember that a system is
    only as secure as the weakest link. And security is something that you should
    consider from the beginning, not added as an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: One final warning – do not try to reinvent the wheel and come up with your own
    algorithms. Your solutions are never as good as what teams of hundreds of crypto
    and security experts can come up with. Trust them to do their job so that you
    can focus on yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, we did cover a lot of ground. We discussed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for security in modern applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How data is represented in memory and how to protect against that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle keys in Azure Key Vault but also in simple things such as environment
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with the proper privilege level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to secure your network communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is one thing that we mentioned briefly but did not cover in detail
    – how to pass credentials securely from our development machine to a production
    environment. How do we ensure the environment variables are set when deploying
    our solutions? This and other questions are part of the deployment strategies
    we can use, which happens to be the topic of the next chapter!
  prefs: []
  type: TYPE_NORMAL
