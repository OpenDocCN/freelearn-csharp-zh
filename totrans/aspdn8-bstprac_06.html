<html><head></head><body>
<div id="_idContainer039">
<h1 class="chapter-number" id="_idParaDest-130"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-131"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.2.1">Best Practices with Web User Interfaces</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When creating a </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">user interface</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">UI</span></strong><span class="koboSpan" id="kobo.7.1">) with ASP.NET 8, it can be intimidating since most developers are so used to working with C#. </span><span class="koboSpan" id="kobo.7.2">There are a lot of factors to consider when creating a web application, such as avoiding duplication, recognizing similar interfaces for reusable components, creating a structured website, and making it easier for search engines to index the site—a process known as </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">search engine </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.9.1">optimization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.10.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.11.1">SEO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Using a </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">task runner</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Applying standards </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">to UIs</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Introducing Buck’s coffee </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">shop project</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">In the first section, we’ll examine why a task runner is so important to developers, how to set it up and run it automatically, and how to bundle and minify scripts. </span><span class="koboSpan" id="kobo.21.2">Then, in the next section, we’ll review a number of common standards with ASP.NET 8 sites, including centralizing links, keeping controllers and Razor Pages small, why </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.23.1"> classes are better than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">HTMLHelper</span></strong><span class="koboSpan" id="kobo.25.1"> class or partials, replacing HTML helpers with tag helpers, and why creating SEO-friendly URLs </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">are important.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Finally, we’ll create a new project called </span><em class="italic"><span class="koboSpan" id="kobo.28.1">Buck’s Coffee Shop</span></em><span class="koboSpan" id="kobo.29.1">, applying everything </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">we’ve covered.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">By the end of this chapter, we’ll know how to include client-side resources into a task runner, implement common practices for UIs, understand how to build additional functionality into an existing web application using the Task Runner tool, consolidate links using extension methods, and extend HTML by creating our own </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">HTML Tags.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.33.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.34.1">Even with a simple web UI, the Visual Studio family of products creates an easy way to build web applications using IntelliSense. </span><span class="koboSpan" id="kobo.34.2">We recommend using your favorite editor to view the GitHub repository. </span><span class="koboSpan" id="kobo.34.3">We recommend </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">Visual Studio (</span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">latest version)</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Visual </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Studio Code</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.40.1">JetBrains Rider</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.41.1">The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work with </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">The code for </span><a href="B19493_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.45.1"> is located in Packt Publishing’s GitHub repository, found </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">at </span></span><a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.47.1">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.48.1">.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.49.1">Using a task runner</span></h1>
<p><span class="koboSpan" id="kobo.50.1">In this section, we’ll explain </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.51.1">what a task runner is, what its responsibilities are, how to automatically execute it when building the solution, and provide some examples of how to </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">As developers, we are always looking for better ways to quickly automate tasks. </span><span class="koboSpan" id="kobo.53.2">With JavaScript frameworks, this task is essential, especially when building the solution in a </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">Continuous Integration/Continuous Delivery</span></strong><span class="koboSpan" id="kobo.55.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.56.1">CI/CD</span></strong><span class="koboSpan" id="kobo.57.1">) pipeline. </span><span class="koboSpan" id="kobo.57.2">The consistent repetition </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.58.1">of certain tasks becomes monotonous and takes away from development time. </span><span class="koboSpan" id="kobo.58.2">Why not have a computer process </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the work?</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">As developers, the need to include a task runner section in this chapter is meant to show developers how to automate tasks to make client-side endeavors more efficient. </span><span class="koboSpan" id="kobo.60.2">In recent years, I’ve experienced developers who’ve never used a task runner for client-side tasks or even know what it is. </span><span class="koboSpan" id="kobo.60.3">A task runner is a tremendous benefit to </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">all developers.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.62.1">What is a task runner?</span></h2>
<p><span class="koboSpan" id="kobo.63.1">As JavaScript became </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.64.1">popular, developers wanted a way to build their JavaScript as well as build their solutions. </span><span class="koboSpan" id="kobo.64.2">In addition to using JavaScript, TypeScript was created to give JavaScript more of a strong-typed feel and required a compilation step </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">Along with “compiling” TypeScript, most websites require additional tasks such as minifying and bundling JavaScript and optimizing. </span><span class="koboSpan" id="kobo.66.2">There was a need for a tool to make the developer’s experience seamless when working with C# </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">and JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">This is why the Task Runner tool was created and integrated into Visual Studio. </span><span class="koboSpan" id="kobo.68.2">Its primary responsibility is to automate tasks using either Grunt or Gulp with </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">build scripts.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Gulp and Grunt are also task runners, but each one has a different file format in JavaScript when defining tasks. </span><span class="koboSpan" id="kobo.70.2">While we can use either Grunt or Gulp scripts in the Visual Studio Task Runner, we’ll be using the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">Gulp format.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">The Task Runner in Visual Studio is what I would consider a “mini-pipeline for the client side.” </span><span class="koboSpan" id="kobo.72.2">A task runner is a great introduction for developers learning to create a CI/CD pipeline for </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">an application.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.74.1">Setting up the Task Runner</span></h2>
<p><span class="koboSpan" id="kobo.75.1">The Task Runner </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.76.1">relies heavily on Node.js for running scripts. </span><span class="koboSpan" id="kobo.76.2">By default, Node.js should already be installed through </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">Visual Studio.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">To find out whether Node.js is installed on your machine, do </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.80.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.82.1"> from </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">View | </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.84.1">Other Windows</span></strong></span><span class="No-Break"><span class="P---Regular-Char"><span class="koboSpan" id="kobo.85.1">.</span></span></span></li>
<li><span class="koboSpan" id="kobo.86.1">When a prompt appears, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">npm --version</span></strong><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">If it displays a version number, we can proceed with the next step. </span><span class="koboSpan" id="kobo.88.3">If not, a repair of Visual Studio through the Visual Studio Installer may </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">be required.</span></span></li>
<li><span class="koboSpan" id="kobo.90.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">npm install -g gulp --save-dev</span></strong><span class="koboSpan" id="kobo.92.1">. </span><span class="koboSpan" id="kobo.92.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">-g</span></strong><span class="koboSpan" id="kobo.94.1"> option is to install Gulp globally, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">--save-dev</span></strong><span class="koboSpan" id="kobo.96.1"> is there to save the dependency in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">package.json</span></strong><span class="koboSpan" id="kobo.98.1"> file. </span><span class="koboSpan" id="kobo.98.2">With that said, there should be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">package.json</span></strong><span class="koboSpan" id="kobo.100.1"> file added to </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">the solution.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Add a new JavaScript file to the root of the project, </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">gulpfile.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.106.1">Depending on whether we’re using Grunt or Gulp, the Task Runner requires a specific file. </span><span class="koboSpan" id="kobo.106.2">In the </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.107.1">examples (as I mentioned before), we’ll be using the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Gulp format.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.109.1">Structure of a gulpfile</span></h2>
<p><span class="koboSpan" id="kobo.110.1">When </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.111.1">creating a gulpfile, it should be named </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">The file</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.114.1"> should be placed into the root of </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the solution.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">The structure of a gulpfile contains </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.118.1">Defined packages</span></strong><span class="koboSpan" id="kobo.119.1">—These are the modules used throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">the gulpfile.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.121.1">Processing and cleanup tasks</span></strong><span class="koboSpan" id="kobo.122.1">—Each task will contain a process task along with a </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">cleanup task.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Export groupings</span></strong><span class="koboSpan" id="kobo.125.1">—This provides a list of tasks to execute in a specific order. </span><span class="koboSpan" id="kobo.125.2">Usually, cleanup procedures are used first, followed by regular </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">processing tasks.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.127.1">Gulp requires a </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.129.1"> file to be located in the root of the solution. </span><span class="koboSpan" id="kobo.129.2">The standard layout of a gulpfile is usually segmented using the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">following stru</span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.131.1">cture:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.132.1">Packages defined at the top</span></strong><span class="koboSpan" id="kobo.133.1">—The packages at the top are the modules installed through your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">npm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.135.1"> installs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.136.1">Tasks (processing and cleanup)</span></strong><span class="koboSpan" id="kobo.137.1">—For every automated concept in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.139.1"> file, there should be two tasks: a processing task and a cleanup task. </span><span class="koboSpan" id="kobo.139.2">The processing task is meant to achieve what we want to automate, whereas the cleanup task is meant to delete created or </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">processed files.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.141.1">Global default and cleanup tasks</span></strong><span class="koboSpan" id="kobo.142.1">—Segment the processing and cleanup tasks into logical groupings when building </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the scripts.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.144.1">Since we already have our file, we’ll create a simple task for our solution. </span><span class="koboSpan" id="kobo.144.2">Copy the following JavaScript code into the new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">gulpfile.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
const { series } = require('gulp');
// Packages defined at the top
const gulp = require('gulp');
// Tasks (no cleanup for Hello World) ;-)
function testTask(done) {
    console.log('Hello World! </span><span class="koboSpan" id="kobo.147.2">We finished a task!');
    done();
}
// Global default and cleanup tasks
exports.build = series(
    testTask
);</span></pre> <p><span class="koboSpan" id="kobo.148.1">Since this is </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.149.1">a build script, we’ll be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">series()</span></strong><span class="koboSpan" id="kobo.151.1"> function</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.152.1"> from the Gulp package, which defines sequential processes. </span><span class="koboSpan" id="kobo.152.2">This is represented through the first line. </span><span class="koboSpan" id="kobo.152.3">The second line creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">const</span></strong><span class="koboSpan" id="kobo.154.1"> instance representing the Gulp package, making the Gulp functions available </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">to us.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Our simple task for the Task Runner is the world-famous “Hello World!” </span><span class="koboSpan" id="kobo.156.2">task defined through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">testTask</span></strong><span class="koboSpan" id="kobo.158.1"> function while passing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">done</span></strong><span class="koboSpan" id="kobo.160.1"> function, which Gulp handles </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Finally, we attach a </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">build</span></strong><span class="koboSpan" id="kobo.164.1"> property to our exports that defines a series of tasks from the preceding code. </span><span class="koboSpan" id="kobo.164.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">series</span></strong><span class="koboSpan" id="kobo.166.1"> function is defined in the Gulp package. </span><span class="koboSpan" id="kobo.166.2">The name following the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">exports</span></strong><span class="koboSpan" id="kobo.168.1"> namespace can be named anything which appears in the Task Runner. </span><span class="koboSpan" id="kobo.168.2">If the build task isn’t displaying in the Task Runner, click the </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Refresh</span></strong><span class="koboSpan" id="kobo.170.1"> button and it should reload the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">gulpfile.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">When right-clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">build</span></strong><span class="koboSpan" id="kobo.175.1"> option (or double-click), the build will execute showing the results, as displayed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 6.1 – Results from our first Task Runner process" src="image/Figure_6.01_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 6.1 – Results from our first Task Runner process</span></p>
<p><span class="koboSpan" id="kobo.179.1">In the next </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.180.1">section, we’ll learn how to run our gulpfile</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.181.1"> automatically when we build </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">our solution.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.183.1">Running automatically</span></h2>
<p><span class="koboSpan" id="kobo.184.1">To assist in </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.185.1">automatically running our </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.187.1"> file, we have the ability to bind certain tasks to events when building the solution. </span><span class="koboSpan" id="kobo.187.2">Right-click on the task in the Task Runner to select the appropriate action for the</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.188.1"> builds, </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.190.1">Before Build</span></strong><span class="koboSpan" id="kobo.191.1">—Execute a task before compiling </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the solution</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.193.1">After Build</span></strong><span class="koboSpan" id="kobo.194.1">—Execute a task after the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">solution compiled</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.196.1">Clean Build</span></strong><span class="koboSpan" id="kobo.197.1">—Execute a task on a “Clean Solution” or “Clean &lt;</span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">Project&gt;” action</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.199.1">Project Open</span></strong><span class="koboSpan" id="kobo.200.1">—Execute a task after the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">project opens</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.202.1">When we select </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">Before Build</span></strong><span class="koboSpan" id="kobo.204.1">, the following line will be added to the top of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">gulpfile.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
/// &lt;binding BeforeBuild='build' /&gt;</span></pre> <p><span class="koboSpan" id="kobo.208.1">When we build the application, the Task Runner executes the build task and, if successful, it proceeds to compile the application, as shown in the following screenshot. </span><span class="koboSpan" id="kobo.208.2">If not, the Task Runner will display an error message in the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">results pane:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.210.1"><img alt="Figure 6.2 – A successful build of client-side tasks and solution" src="image/Figure_6.02_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.211.1">Figure 6.2 – A successful build of client-side tasks and solution</span></p>
<p><span class="koboSpan" id="kobo.212.1">While this provides a basic foundation for our application, we need to define our client-side directory structure so that when adding resources such as images, scripts, and styles, our tasks </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.213.1">know where to find </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">the resources.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">In the next section, we’ll look at how to set up the structure for our </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">client-side workflow.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.217.1">Creating a workflow structure</span></h2>
<p><span class="koboSpan" id="kobo.218.1">Before we</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.219.1"> write scripts for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.221.1"> file, we need to define a simple workflow for our Task Runner. </span><span class="koboSpan" id="kobo.221.2">Generally, our gulpfile contains, at the very least, a JavaScript and CSS bundler and minifier. </span><span class="koboSpan" id="kobo.221.3">It doesn’t matter which one is executed first, but they could even be candidates for a collection of parallel tasks. </span><span class="koboSpan" id="kobo.221.4">While Visual Studio created our server-side application, the client-side structure requires a little more attention in regard to where to place files throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">In every ASP.NET 8 application, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">wwwroot</span></strong><span class="koboSpan" id="kobo.225.1"> folder that contains our client-side scripts, styles, and static content (such as images). </span><span class="koboSpan" id="kobo.225.2">This is considered the root path to our application for our static content, so if we have a website called </span><a href="https://www.mywebsite.com/"><span class="koboSpan" id="kobo.226.1">https://www.mywebsite.com/</span></a><span class="koboSpan" id="kobo.227.1">, the wwwroot folder will be our root. </span><span class="koboSpan" id="kobo.227.2">For example, if we want to access our CSS folder, we’d access it via </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">https://www.mywebsite.com/css/</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">While every resource (such as scripts and styles) has its own way of processing and creating production-ready output files, there needs to be a workflow on how each task in our Task Runner </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">will perform.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">The current</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.232.1"> directory structure looks </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.234.1"><img alt="Figure 6.3 – A common ASP.NET 8 structure" src="image/Figure_6.03_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.235.1">Figure 6.3 – A common ASP.NET 8 structure</span></p>
<p><span class="koboSpan" id="kobo.236.1">The preceding structure is meant for a production-level application. </span><span class="koboSpan" id="kobo.236.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">css</span></strong><span class="koboSpan" id="kobo.238.1"> directory doesn’t contain any SASS or LESS files for processing, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">js</span></strong><span class="koboSpan" id="kobo.240.1"> directory has only simple JavaScript files. </span><span class="koboSpan" id="kobo.240.2">We need additional directories for our workflow to </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">function properly.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">For our application, we’ll be using TypeScript and SASS. </span><span class="koboSpan" id="kobo.242.2">SASS is a preprocessor for CSS files and requires a directory for our source files (with an extension of </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">.scss</span></strong><span class="koboSpan" id="kobo.244.1">). </span><span class="koboSpan" id="kobo.244.2">TypeScript also requires transpilation into JavaScript files, so we’ll create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">scss</span></strong><span class="koboSpan" id="kobo.246.1"> directory for our SASS files and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">src</span></strong><span class="koboSpan" id="kobo.248.1"> directory for our </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">TypeScript files.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">src</span></strong><span class="koboSpan" id="kobo.252.1"> folder and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">scss</span></strong><span class="koboSpan" id="kobo.254.1"> folder under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">wwwroot</span></strong><span class="koboSpan" id="kobo.256.1"> folder. </span><span class="koboSpan" id="kobo.256.2">These folders will contain the source code for our application. </span><span class="koboSpan" id="kobo.256.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">src</span></strong><span class="koboSpan" id="kobo.258.1"> folder will contain all TypeScript files for the application, whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">scss</span></strong><span class="koboSpan" id="kobo.260.1"> folder will contain all of the styles ready for compilation into production-ready </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">CSS files.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">The following</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.263.1"> steps show a common workflow for a </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">task runner:</span></span></p>
<ol>
<li><span class="No-Break"><span class="koboSpan" id="kobo.265.1">TypeScript files:</span></span><ul><li><span class="koboSpan" id="kobo.266.1">Transpile the TypeScript files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">src</span></strong><span class="koboSpan" id="kobo.268.1"> folder into JavaScript files. </span><span class="koboSpan" id="kobo.268.2">The output files will reside in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">src</span></strong><span class="koboSpan" id="kobo.270.1"> folder. </span><span class="koboSpan" id="kobo.270.2">The output files are </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">JavaScript files.</span></span></li></ul></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.272.1">JavaScript files:</span></span><ul><li><span class="koboSpan" id="kobo.273.1">Use a bundler to process the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">.js</span></strong><span class="koboSpan" id="kobo.275.1"> files. </span><span class="koboSpan" id="kobo.275.2">The bundler should automatically know how to include all files based on the JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">module pattern.</span></span></li><li><span class="koboSpan" id="kobo.277.1">Use a minifier to process the bundled JavaScript files. </span><span class="koboSpan" id="kobo.277.2">The output files are copied from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">src</span></strong><span class="koboSpan" id="kobo.279.1"> folder over to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">js</span></strong><span class="koboSpan" id="kobo.281.1"> folders. </span><span class="koboSpan" id="kobo.281.2">These files are also renamed to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">.min.js</span></strong><span class="koboSpan" id="kobo.283.1"> suffix added to them to identify them as </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">minified files.</span></span></li></ul></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.285.1">Styles:</span></span><ul><li><span class="koboSpan" id="kobo.286.1">Use a “styler compiler” such as LESS or SASS. </span><span class="koboSpan" id="kobo.286.2">We’ll be using SASS to precompile our styles. </span><span class="koboSpan" id="kobo.286.3">These files will reside in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">scss</span></strong><span class="koboSpan" id="kobo.288.1"> folder. </span><span class="koboSpan" id="kobo.288.2">Once compiled, the folder will contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">.css</span></strong><span class="koboSpan" id="kobo.290.1"> files and be inevitably moved to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">css</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1"> folder.</span></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.293.1">The workflow structure of our application implies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">js</span></strong><span class="koboSpan" id="kobo.295.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">css</span></strong><span class="koboSpan" id="kobo.297.1"> folders are production-level </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.298.1">folders while making our </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">src</span></strong><span class="koboSpan" id="kobo.300.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">scss</span></strong><span class="koboSpan" id="kobo.302.1"> folders specific to </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">developer modifications.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.304.1">Defining our workflow paths</span></h2>
<p><span class="koboSpan" id="kobo.305.1">Since we </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.306.1">created our workflow structure, we need to tell Gulp where our source and destination folders reside in our application. </span><span class="koboSpan" id="kobo.306.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">path</span></strong><span class="koboSpan" id="kobo.308.1"> module contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">resolve</span></strong><span class="koboSpan" id="kobo.310.1"> function to concatenate folder names as we go, as </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
// Packages defined at the top
const gulp = require('gulp'),
      path = require('path');
// define our paths for our app
const basePath = path.resolve(__dirname, "wwwroot");</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">__dirname</span></strong><span class="koboSpan" id="kobo.314.1"> is a reserved word and is based on the current directory (in our case, this is the root of our application). </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">basePath</span></strong><span class="koboSpan" id="kobo.316.1"> is used to operate solely in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">wwwroot</span></strong><span class="koboSpan" id="kobo.318.1"> folder and below and won’t interfere with our ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">8 application.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.320.1">Transpiling TypeScript</span></h2>
<p><span class="koboSpan" id="kobo.321.1">Our first order</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.322.1"> of business is to transpile our TypeScript files </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.323.1">into JavaScript files. </span><span class="koboSpan" id="kobo.323.2">Transpiling is the process of converting TypeScript into JavaScript. </span><span class="koboSpan" id="kobo.323.3">With most of our TypeScript projects, we almost always have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.325.1"> configuration file, and this will reside in the root of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">wwwroot</span></strong><span class="koboSpan" id="kobo.327.1"> folder. </span><span class="koboSpan" id="kobo.327.2">However, we need a special package for reading the configuration file specifically </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">for Gulp.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">To include the package, pr</span><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.330.1">oceed </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.332.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.334.1">, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">npm install -g gulp-cli</span></strong><span class="koboSpan" id="kobo.336.1">. </span><span class="koboSpan" id="kobo.336.2">It should then be added to your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">package.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1"> file.</span></span></li>
<li><span class="koboSpan" id="kobo.339.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.341.1">, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">npm install gulp@4</span></strong><span class="koboSpan" id="kobo.343.1"> to install Gulp as a </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">project dependency.</span></span></li>
<li><span class="koboSpan" id="kobo.345.1">One last time in the </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.347.1">, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">npm install gulp-typescript typescript gulp-clean --save-dev</span></strong><span class="koboSpan" id="kobo.349.1"> to install TypeScript, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">gulp-typescript</span></strong><span class="koboSpan" id="kobo.351.1">, and the ability to remove </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">files (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">gulp-clean</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.355.1">Define the module at the top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">gulpfile.js</span></strong><span class="P---Regular-Char"><span class="koboSpan" id="kobo.357.1"> file, </span></span><span class="No-Break"><span class="P---Regular-Char"><span class="koboSpan" id="kobo.358.1">like so:</span></span></span><pre class="source-code"><span class="koboSpan" id="kobo.359.1">
const gulp = require('gulp'),
      path = require('path'),
      tsConfig = require("gulp-typescript");</span></pre></li> <li><span class="koboSpan" id="kobo.360.1">Load the </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.361.1">configuration using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">createProject</span></strong><span class="koboSpan" id="kobo.363.1"> function</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.364.1"> referencing the path to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.366.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.368.1">
// define our paths for our app
const basePath = path.resolve(__dirname, "wwwroot");
const tsProject = tsConfig.createProject(path.resolve(basePath, 'tsconfig.json'));</span></pre></li> <li><span class="koboSpan" id="kobo.369.1">Define the TypeScript source folder, </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
const tsSource = path.resolve(basePath, "src");</span></pre></li> <li><span class="koboSpan" id="kobo.372.1">We’ll keep track of paths through a source object. </span><span class="koboSpan" id="kobo.372.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">srcPaths</span></strong><span class="koboSpan" id="kobo.374.1"> object will contain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">js</span></strong><span class="koboSpan" id="kobo.376.1"> path pointing to our </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">source code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.378.1">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js')
    ]
};</span></pre></li> <li><span class="koboSpan" id="kobo.379.1">We need to create process (</span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">ts_transpile</span></strong><span class="koboSpan" id="kobo.381.1">) and cleanup (</span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">ts_cleanup</span></strong><span class="koboSpan" id="kobo.383.1">) functions for our TypeScript. </span><span class="koboSpan" id="kobo.383.2">Here’s the code to </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">achieve that:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
function ts_transpile(done) {
    tsProject
        .src()
        .pipe(tsProject()).js
        .pipe(gulp.dest(tsSource));
    done();
}
function ts_clean(done) {
    gulp.src(srcPaths.js, {allowEmpty: true})
        .pipe(clean({ force: true }));
    done();
}</span></pre></li> <li><span class="koboSpan" id="kobo.386.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">ts_transpile</span></strong><span class="koboSpan" id="kobo.388.1"> function uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">tsProject</span></strong><span class="koboSpan" id="kobo.390.1"> configuration to locate the source </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.391.1">files (through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">include</span></strong><span class="koboSpan" id="kobo.393.1"> property </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.394.1">near the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.396.1"> file) and convert all of the TypeScript files into JavaScript files in the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">same directory.</span></span></li>
<li><span class="koboSpan" id="kobo.398.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">ts_clean</span></strong><span class="koboSpan" id="kobo.400.1"> function will simply remove all JavaScript (</span><em class="italic"><span class="koboSpan" id="kobo.401.1">NOT</span></em><span class="koboSpan" id="kobo.402.1"> TypeScript) files from </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">every directory.</span></span></li>
<li><span class="koboSpan" id="kobo.404.1">Once we have our TypeScript tasks defined, we simply add them to our build process at the bottom of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.406.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.408.1">
// Global default and cleanup tasks
exports.build = series(
    ts_clean,
    ts_transpile
);</span></pre></li> <li><span class="koboSpan" id="kobo.409.1">First, we delete all of the JavaScript files with </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">ts_clean</span></strong><span class="koboSpan" id="kobo.411.1">, then perform the transpiling </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">ts_transpile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.415.1">As shown in the example, our workflow structure locates all of the TypeScript files and</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.416.1"> transpiles them into </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">JavaScript</span></span><span class="No-Break"><a id="_idIndexMarker334"/></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1"> files:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 6.4 – TypeScript files in src folders converted to JavaScript" src="image/Figure_6.04_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 6.4 – TypeScript files in src folders converted to JavaScript</span></p>
<p><span class="koboSpan" id="kobo.421.1">Since our TypeScript is now transpiled down to JavaScript, we can focus on bundling and minifying </span><a id="_idIndexMarker335"/><span class="No-Break"><span class="koboSpan" id="kobo.422.1">the </span></span><span class="No-Break"><a id="_idIndexMarker336"/></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">files.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.424.1">Bundling and minifying</span></h2>
<p><span class="koboSpan" id="kobo.425.1">By nature, JavaScript </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.426.1">takes a while to load in the browser. </span><span class="koboSpan" id="kobo.426.2">To make</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.427.1"> matters worse, if a JavaScript file is formatted for readability, the file takes even longer to load, therefore making it slower to download. </span><span class="koboSpan" id="kobo.427.2">A minification process is necessary to shorten the loading process as much as possible to give the user a </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">better experience.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Bundling is the concept of taking an application’s scripts and styles and combining them into one script or style instead of loading </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">multiple files.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Since spaces and tabs take up…well, space, minifying the scripts and styles is the process of shrinking client-side files down to a smaller size for faster delivery to </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">To bundle our scripts, we need a module called Browserify for our Gulp script. </span><span class="koboSpan" id="kobo.433.2">Let’s start adding the bundling functionality to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.435.1"> file. </span><span class="koboSpan" id="kobo.435.2">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">the steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.437.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.439.1">, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">npm install -g browserify gulp-rename vinyl-source-stream vinyl-buffer vinyl-transform gulp-uglify-es</span></strong><span class="koboSpan" id="kobo.441.1">. </span><span class="koboSpan" id="kobo.441.2">We should see these modules added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">package.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.443.1"> file.</span></span></li>
<li><span class="koboSpan" id="kobo.444.1">Once these are installed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">package.json</span></strong><span class="koboSpan" id="kobo.446.1"> file, we need to include another </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">srcPath</span></strong><span class="koboSpan" id="kobo.448.1"> object containing all of the files we </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">want bundled/minified:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.450.1">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js') // all *.js in every                                              folder
    ],
    jsBundles: [
        path.resolve(tsSource, 'site.js') // specific files to                                              bundle/minify
    ]
};</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.451.1">We’ll call the property </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">jsBundles</span></strong><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">Since every TypeScript file was transpiled into a JavaScript file, we have to identify which files to load. </span><span class="koboSpan" id="kobo.453.3">A good practice to follow is to name the file the same as the actual page. </span><span class="koboSpan" id="kobo.453.4">The good news is the Browserify module will follow the imports in each file and include it in the bundling. </span><span class="koboSpan" id="kobo.453.5">As we add more TypeScript to the project, add the primary script to the list for </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">automatic compilation.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.455.1">Create a new variable where the scripts will reside for the </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">web application:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
const destPaths = {
    jsFolder: path.resolve(basePath, 'js') // wwwroot/js
};</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.458.1">We’ll call the </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">variable </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">destPaths</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.462.1">Next, we </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.463.1">create</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.464.1"> our processing and cleanup for bundling and minifying </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the scripts:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.466.1">
/* JavaScript */
function js_bundle_min(done) {
    srcPaths.jsBundles.forEach(file =&gt; {
        const b = browserify({
            entries: file, // Only need initial file, browserify                               finds the deps
            transform: [['babelify', { 'presets': ["es2015"] }]]
        });
        b.bundle()
            .pipe(source(path.basename(file)))
            .pipe(rename(path =&gt; {
                path.basename += ".min";
                path.extname = ".js";
            }))
            .pipe(buffer())
            .pipe(uglify())
            .pipe(gulp.dest(destPaths.jsFolder));
        done();
    });
}
function js_clean(done) {
    gulp.src(path.resolve(destPaths.jsFolder, '**/*.js'), { read: false })
        .pipe(gp_clean({ force: true }));
    done();
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.467.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">js_bundle_min</span></strong><span class="koboSpan" id="kobo.469.1"> function</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.470.1"> shown in the preceding </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.471.1">snippet, we loop through all of the files we want bundled. </span><span class="koboSpan" id="kobo.471.2">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">browserify</span></strong><span class="koboSpan" id="kobo.473.1"> object with options set and start the bundling process </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">per file.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">The first process is getting the base name of the file we’re currently processing. </span><span class="koboSpan" id="kobo.475.2">Once we have the filename, we can rename the base from </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">site</span></strong><span class="koboSpan" id="kobo.477.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">site.min</span></strong><span class="koboSpan" id="kobo.479.1"> and then add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">.js</span></strong><span class="koboSpan" id="kobo.481.1"> extension to the end of the file. </span><span class="koboSpan" id="kobo.481.2">We then buffer the file and perform an </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">uglify</span></strong><span class="koboSpan" id="kobo.483.1"> operation on it, meaning we minify it. </span><span class="koboSpan" id="kobo.483.2">After it’s bundled and minified, we write the file out to the destination folder, which </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">wwwroot/js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">js_clean</span></strong><span class="koboSpan" id="kobo.489.1"> function removes all of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">.js</span></strong><span class="koboSpan" id="kobo.491.1"> files from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">wwwroot/js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.493.1"> folder.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.494.1">Finally, we can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">js_bundle_min</span></strong><span class="koboSpan" id="kobo.496.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">js_clean</span></strong><span class="koboSpan" id="kobo.498.1"> functions to our build exports at the bottom of </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.500.1">
// Global default and cleanup tasks
exports.build = series(
    ts_clean,
    js_clean,
    ts_transpile,
    js_bundle_min
);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.501.1">Once the gulpfile is </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.502.1">saved, double-click </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.503.1">on the build, and the files should appear in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">wwwroot/js</span></strong><span class="koboSpan" id="kobo.505.1"> folder. </span><span class="koboSpan" id="kobo.505.2">If we double-click the JavaScript file, we’ll see it’s been bundled </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">and minified.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.507.1">Implementing additional tasks</span></h2>
<p><span class="koboSpan" id="kobo.508.1">While bundling </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.509.1">and minifying scripts is a big deal, there are other tasks we can add to a task runner. </span><span class="koboSpan" id="kobo.509.2">Such tasks can include </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.511.1">SCSS/LESS precompiling</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.512.1">Image optimization</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.513.1">Release notes</span></span></li>
<li><span class="koboSpan" id="kobo.514.1">Copying </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">dist</span></strong><span class="koboSpan" id="kobo.516.1"> folders from </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">node_modules</span></strong><span class="koboSpan" id="kobo.518.1"> to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">lib</span></strong><span class="koboSpan" id="kobo.520.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">on build</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.522.1">These are just a few of the simple tasks available when preparing the web application. </span><span class="koboSpan" id="kobo.522.2">For additional tasks, refer to the source code for </span><a href="B19493_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.523.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.524.1"> on GitHub in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">TaskRunner</span></strong><span class="koboSpan" id="kobo.526.1"> project </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">at </span></span><a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.528.1">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.529.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">In this section, we reviewed what a task runner is and what it can do for developers and showed how to automatically execute it when building the solution. </span><span class="koboSpan" id="kobo.530.2">We also demonstrated the power of the Task Runner by creating a workflow structure and defining our workflow paths, how to transpile TypeScript, and how to minify and bundle scripts. </span><span class="koboSpan" id="kobo.530.3">As we can see, this simplifies the developer experience by automating client-side tasks and building</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.531.1"> the solution using </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">one build.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">In the next section, we’ll examine more UI standards and what is considered common knowledge when it comes to ASP.NET 8 </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">web applications.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.535.1">Applying standards to UIs</span></h1>
<p><span class="koboSpan" id="kobo.536.1">ASP.NET’s web page</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.537.1"> model has evolved over the years. </span><span class="koboSpan" id="kobo.537.2">With Web Forms, it was </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">ViewState</span></strong><span class="koboSpan" id="kobo.539.1"> and components. </span><span class="koboSpan" id="kobo.539.2">With MVC, it had partials and HTML Helpers. </span><span class="koboSpan" id="kobo.539.3">Now, ASP.NET 8 provides more advanced techniques using </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.541.1"> classes and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">TagHelper</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1"> classes.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">For this section, we’ll examine how ASP.NET 8 uses its language-specific features to build quicker and more flexible UIs. </span><span class="koboSpan" id="kobo.544.2">We’ll see how to consolidate links across a site, why it’s important to keep controllers/pages small, how </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.546.1"> classes are better than partials and </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">HTMLHelper</span></strong><span class="koboSpan" id="kobo.548.1"> classes, and look at how to create </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">SEO-friendly routes.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.550.1">Centralizing your site links</span></h2>
<p><span class="koboSpan" id="kobo.551.1">If we have a </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.552.1">large site with hundreds of links, developers</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.553.1"> understand what it means when a page is renamed, moved, or (gasp) deleted. </span><span class="koboSpan" id="kobo.553.2">It’s definitely a time-consuming effort to change every link on a large site. </span><span class="koboSpan" id="kobo.553.3">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">TagHelper</span></strong><span class="koboSpan" id="kobo.555.1"> classes are…well, helpful, one common practice is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">UrlHelper</span></strong><span class="koboSpan" id="kobo.557.1"> classes to consolidate </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">the links.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">Let’s examine a website with the following ASP.NET 8 </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">TagHelper</span></strong><span class="koboSpan" id="kobo.561.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
&lt;a asp-page="Index"&gt;Go to Main Page&lt;/a&gt;</span></pre> <p><span class="koboSpan" id="kobo.564.1">Imagine all of these on secondary pages pointing to the main page, </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Index.cshtml</span></strong><span class="koboSpan" id="kobo.566.1">, and we receive a request to change the name of the page </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Index2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">With extension methods, we can create custom site-specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">UrlHelper</span></strong><span class="koboSpan" id="kobo.572.1"> class URLs for each page, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
    Public static class SiteLinkExtensions
    {
        public static string HomeUrl(this UrlHelper helper) =&gt;
            helper.RouteUrl(new UrlRouteContext
            {
                RouteName = "Default",
                Values = new
                {
                    Controller="Home",
                    Action ="Index"
                }
            });
    }</span></pre> <p><span class="koboSpan" id="kobo.575.1">Extension </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.576.1">methods require three things: a static class, a static </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.577.1">method, and the method’s first parameter in the signature must have </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.579.1"> declared.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.580.1">What is an extension method?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.581.1">For more details on using extension methods, navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">to </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods"><span class="No-Break"><span class="koboSpan" id="kobo.583.1">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.584.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">We can apply this technique to Razor Pages as well using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">PageLink</span></strong><span class="koboSpan" id="kobo.587.1"> method, as </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
Public static string DetailsUrl(this IurlHelper helper, string blogId) =&gt;
    helper.PageLink("Detail", values: new { Id = blogId, area = "admin" });</span></pre> <p><span class="koboSpan" id="kobo.590.1">The only difference between the two methods is the extension method attaches to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">IurlHelper</span></strong><span class="koboSpan" id="kobo.592.1"> class instead of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">UrlHelper</span></strong><span class="koboSpan" id="kobo.594.1"> class and, for Razor Pages, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">.PageLink</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.596.1">method instead.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">If using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">TagHelper</span></strong><span class="koboSpan" id="kobo.599.1"> anchor with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">asp-page</span></strong><span class="koboSpan" id="kobo.601.1"> attribute, this approach limits our flexibility because we are defining a page in multiple places. </span><span class="koboSpan" id="kobo.601.2">By adding an extension method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">UrlHelper</span></strong><span class="koboSpan" id="kobo.603.1"> class, we can simplify it by using the HTML </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">href</span></strong><span class="koboSpan" id="kobo.605.1"> attribute, as </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
&lt;a href="@Url.HomeUrl()"&gt;Go to Main Page&lt;/a&gt;</span></pre> <p><span class="koboSpan" id="kobo.608.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">UrlHelper</span></strong><span class="koboSpan" id="kobo.610.1"> extension </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.611.1">methods, all of the links across the site </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.612.1">are easier to integrate and more efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">to update.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.614.1">Keeping controllers/pages small</span></h2>
<p><span class="koboSpan" id="kobo.615.1">When ASP.NET MVC was</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.616.1"> introduced, controllers were often the dumping ground for most code, making calls to the database, creating models, and validating </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">the model.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">MVC controllers (and now Razor Pages) should be “traffic cops,” directing the logic to certain parts of the application based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">page’s function.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">While the following list is far from complete, certain aspects can be offloaded to other parts of ASP.NET 8 to put controllers and pages on </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">a diet:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.622.1">Validating models</span></strong><span class="koboSpan" id="kobo.623.1">—Instead of validating models in the controller, use data attributes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">[Required]</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.625.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">[Email]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.628.1">Database calls</span></strong><span class="koboSpan" id="kobo.629.1">—Instead of making database calls directly from the controller or Razor page, dependency inject a </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">DbContext</span></strong><span class="koboSpan" id="kobo.631.1"> instance and use Entity Framework. </span><span class="koboSpan" id="kobo.631.2">If Entity Framework isn’t a viable solution, offload the database processing to </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">Service</span></strong><span class="koboSpan" id="kobo.633.1"> classes (see </span><a href="B19493_05.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.634.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.635.1"> on Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">Framework Core).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.637.1">Secondary processes</span></strong><span class="koboSpan" id="kobo.638.1">—If the application contains code to send emails, process records, or build an object, refactor the process out to its own class and inject it into the controller/Razor page, making it cleaner and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">to test.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.640.1">Large methods in </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.641.1">controllers or Razor Pages can complicate matters further when trying to test or debug code. </span><span class="koboSpan" id="kobo.641.2">Smaller code, in this instance, is the </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">better approach.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.643.1">Using ViewComponents</span></h2>
<p><span class="koboSpan" id="kobo.644.1">When HTML Helpers </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.645.1">and Partial views were introduced </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.646.1">with MVC, the ability to pass an object into a small section and have it create a snippet of HTML for the View was a great feature for developers. </span><span class="koboSpan" id="kobo.646.2">However, there were a few downsides to using these </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">two features.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">The downside of using HTML Helpers was the ability to create new HTML snippets through code and render that back to the View. </span><span class="koboSpan" id="kobo.648.2">If the HTML changed, it would require updating and recompiling of the code </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.649.1">violating </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">separation of concerns</span></strong><span class="koboSpan" id="kobo.651.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.652.1">SoC</span></strong><span class="koboSpan" id="kobo.653.1">) (“You’ve got your C# in my HTML”). </span><span class="koboSpan" id="kobo.653.2">There wasn’t any HTML associated with the Helper; it had to be created </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">using code.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">Swinging the pendulum the other way, Partials introduced the ability to have HTML with no code with the ability to pass objects into the partial. </span><span class="koboSpan" id="kobo.655.2">The issue with this approach was the ability to place </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">if</span></strong><span class="koboSpan" id="kobo.657.1">…</span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">then</span></strong><span class="koboSpan" id="kobo.659.1"> statements inside the HTML. </span><span class="koboSpan" id="kobo.659.2">When an </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">if</span></strong><span class="koboSpan" id="kobo.661.1">…</span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">then</span></strong><span class="koboSpan" id="kobo.663.1"> statement was introduced in HTML, this was considered a code smell (which is code looking like it doesn’t belong or looks suspicious) and was meant to be a business rule. </span><span class="koboSpan" id="kobo.663.2">HTML should be declarative—almost template-like with no </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">branching involved.</span></span></p>
<p><span class="koboSpan" id="kobo.665.1">With ASP.NET Core, </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.667.1"> classes were introduced and, while not meant to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">HTMLHelper</span></strong><span class="koboSpan" id="kobo.669.1"> classes or Partials, fulfilled a larger need for building modular web applications. </span><span class="koboSpan" id="kobo.669.2">Considered to be “mini-controllers,” </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.671.1"> classes provide ASP.NET developers with a better approach for the </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">following reasons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.673.1">SoC</span></strong><span class="koboSpan" id="kobo.674.1">—With an HTML and C# combination, this allows a better way of writing </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">modular components.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.676.1">Chunky rendering</span></strong><span class="koboSpan" id="kobo.677.1">—By default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.679.1"> classes only render a chunk of the view instead of the entire response. </span><span class="koboSpan" id="kobo.679.2">This makes the component independently </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">render faster.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.681.1">Easy to test</span></strong><span class="koboSpan" id="kobo.682.1">—</span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.684.1"> classes are isolated by nature, making them extremely easy to test. </span><span class="koboSpan" id="kobo.684.2">Create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.686.1"> class, pass in arguments, and test to see if it returned what </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">was expected.</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.689.1"> classes give us the best of both worlds, rendering HTML while using C# for</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.690.1"> applying </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.691.1">business rules in a </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">single component.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.693.1">Additional ViewComponent material</span></p>
<p class="callout"><span class="koboSpan" id="kobo.694.1">For more details on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.696.1"> class, navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">to </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components"><span class="No-Break"><span class="koboSpan" id="kobo.698.1">https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.699.1">.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.700.1">Using Tag Helpers instead of HTML Helpers</span></h2>
<p><span class="koboSpan" id="kobo.701.1">While HTML</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.702.1"> Helpers provide the ability </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.703.1">to create small snippets of HTML (just don’t go overboard), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">TagHelper</span></strong><span class="koboSpan" id="kobo.705.1"> class take it a </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">step further.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">The difference between Tag Helpers and HTML Helpers is </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">TagHelper</span></strong><span class="koboSpan" id="kobo.709.1"> classes allow us to build our own tag elements through code and </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">HTMLHelper</span></strong><span class="koboSpan" id="kobo.711.1"> classes are directly called as methods in </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">the HTML.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">For example, if we were building a hotel application, some </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">TagHelper</span></strong><span class="koboSpan" id="kobo.715.1"> classes would include  </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">&lt;calendar&gt;</span></strong><span class="koboSpan" id="kobo.717.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">&lt;availability&gt;</span></strong><span class="koboSpan" id="kobo.719.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">&lt;room-gallery&gt;</span></strong><span class="koboSpan" id="kobo.721.1"> tags. </span><span class="koboSpan" id="kobo.721.2">These would look like brand new tags in HTML, but ASP.NET would render them on the server and create HTML based on the data model fed </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">to them.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">Tag Helpers are an extremely powerful feature for developers wanting to create their own custom library of domain-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">HTML tags.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.725.1">Creating SEO-friendly URLs</span></h2>
<p><span class="koboSpan" id="kobo.726.1">Site architecture </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.727.1">is important when building </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.728.1">websites. </span><span class="koboSpan" id="kobo.728.2">If it’s a public-facing website, the site should be easy to crawl with </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">simple URLs.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">To look at this another way, examine the following </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">two URLs:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">https://www.mysite.com/Blog/my-first-blog-post</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">https://www.mysite.com/?blogpost=E1FCFB35-87C7-442F-9516-7C8585E8CD49</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.734.1">If we found these links and we were talking with someone on the phone, which one would we tell them </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">to follow?</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">Creating friendly URLs provides the </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">following benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.738.1">Easier to identify the page</span></strong><span class="koboSpan" id="kobo.739.1">—We know the first URL is someone’s first blog post. </span><span class="koboSpan" id="kobo.739.2">The second URL is…well, we don’t know what kind of page </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">it is.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.741.1">Easy to repeat</span></strong><span class="koboSpan" id="kobo.742.1">—It’s easier to say the first URL over the phone as opposed to </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">the GUID.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.744.1">Better SEO</span></strong><span class="koboSpan" id="kobo.745.1">—If we have the opportunity, it’s always good to help search engines identify what kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">page created.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.747.1"> Best practices of Google’s URL structure</span></p>
<p class="callout"><span class="koboSpan" id="kobo.748.1">For better naming of URLs and what Google recommends, navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">to </span></span><a href="https://developers.google.com/search/docs/crawling-indexing/url-structure"><span class="No-Break"><span class="koboSpan" id="kobo.750.1">https://developers.google.com/search/docs/crawling-indexing/url-structure</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.751.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">Creating these SEO-friendly URLs requires a site-wide link strategy using mapping methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">.MapRoute()</span></strong><span class="koboSpan" id="kobo.754.1"> and, if using Razor Pages, naming pages related to </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">the content.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">In this section, we learned how to catalog our links using extension methods, how controllers and pages should be made as small as possible, how </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.758.1"> classes can improve the efforts of writing modular code, why </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">TagHelper</span></strong><span class="koboSpan" id="kobo.760.1"> classes can propel HTML to </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.761.1">new heights, and why creating SEO-friendly </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.762.1">URLs is </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">so important.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">In the last section, we’ll apply our knowledge of implementing these concepts into </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">an application.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.766.1">Introducing Buck’s coffee shop project</span></h1>
<p><span class="koboSpan" id="kobo.767.1">We covered a lot in the last</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.768.1"> section, with various concepts explained. </span><span class="koboSpan" id="kobo.768.2">It’s one thing to explain </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.770.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">TagHelper</span></strong><span class="koboSpan" id="kobo.772.1"> classes, but where do we apply these concepts on </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">a website?</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">In this section, we’ll apply those concepts to a brand-new project. </span><span class="koboSpan" id="kobo.774.2">Our friend wanted a new website for his coffee shop, so we used the ASP.NET 8 Web Application template as a starting point for </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">the site.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.776.1">Setting up Buck’s website</span></h2>
<p><span class="koboSpan" id="kobo.777.1">Since we have a </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.778.1">new website, we want to create the client-side pipeline so that we can focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">site’s functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">This sounds like a job for…the </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">Task Runner.</span></span></p>
<p><span class="koboSpan" id="kobo.782.1">While we’ve included the transpiling of TypeScript and bundling/minifying JavaScript in the project, we can add additional tasks to make our lives </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">even easier.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">One easy task is to bundle and minify our styles using SASS, </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.786.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.788.1">, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">npm install --save-dev sass gulp-sass</span></strong><span class="koboSpan" id="kobo.790.1">. </span><span class="koboSpan" id="kobo.790.2">These modules should be added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">package.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.792.1"> file.</span></span></li>
<li><span class="koboSpan" id="kobo.793.1">Once these are installed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">package.json</span></strong><span class="koboSpan" id="kobo.795.1"> file, we include the module as required at the top of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.797.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.799.1">
gp_sass = require('gulp-sass')(require("sass"));</span></pre></li> <li><span class="koboSpan" id="kobo.800.1">Create a variable containing the path to the </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">SCSS files:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.802.1">
const sassSource = path.resolve(basePath, "scss");</span></pre></li> <li><span class="koboSpan" id="kobo.803.1">Add the style file to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">srcPaths</span></strong><span class="koboSpan" id="kobo.805.1"> object (in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">sassSrc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.807.1"> property):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.808.1">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js') // all *.js in every                                              folder
    ],
    jsBundles: [
        path.resolve(tsSource, 'site.js') // specific files to                                              bundle/minify
    ],
    sassSrc: [
        path.resolve(sassSource, 'site.scss')
    ]
}</span></pre></li> <li><span class="koboSpan" id="kobo.809.1">Add the style path to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">destPaths</span></strong><span class="koboSpan" id="kobo.811.1"> object (with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">cssFolder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.813.1"> property):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.814.1">
const destPaths = {
    jsFolder: path.resolve(basePath, 'js'), // wwwroot/js
    cssFolder: path.resolve(basePath, 'css') // wwwroot/css
};</span></pre></li> <li><span class="koboSpan" id="kobo.815.1">Add the</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.816.1"> processing and </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">cleaning functions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.818.1">
/* SASS/CSS */
function sass_clean(done) {
    gulp.src(destPaths.cssFolder + "*.*", { read: false })
        .pipe(gp_clean({ force: true }));
    done();
}
function sass(done) {
    gulp.src(srcPaths.sassSrc)
        .pipe(gp_sass({ outputStyle: 'compressed' }))
        .pipe(rename({
            suffix: '.min'
        }))
        .pipe(gulp.dest(destPaths.cssFolder));
    done();
}</span></pre></li> <li><span class="koboSpan" id="kobo.819.1">Finally, add</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.820.1"> the functions to the </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">build process:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.822.1">
// Global default and cleanup tasks
exports.build = series(
    ts_clean,
    js_clean,
    sass_clean,
    ts_transpile,
    js_bundle_min,
    sass
);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.823.1">What about those JavaScript libraries? </span><span class="koboSpan" id="kobo.823.2">They’re in the dreaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">node_modules</span></strong><span class="koboSpan" id="kobo.825.1"> folder. </span><span class="koboSpan" id="kobo.825.2">Most JavaScript libraries have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">dist</span></strong><span class="koboSpan" id="kobo.827.1"> folder for distribution. </span><span class="koboSpan" id="kobo.827.2">This was the case when we installed the Bootstrap and Font Awesome libraries. </span><span class="koboSpan" id="kobo.827.3">Why not copy that into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">/lib</span></strong><span class="koboSpan" id="kobo.829.1"> folder for our </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">local purposes?</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.831.1">Create a variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">gulpfile.js</span></strong><span class="koboSpan" id="kobo.833.1"> file containing the path to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">node_modules</span></strong><span class="koboSpan" id="kobo.835.1"> folder. </span><span class="koboSpan" id="kobo.835.2">This should be in the root of </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">the solution:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.837.1">
const moduleSource = path.resolve(__dirname, "node_modules");</span></pre></li> <li><span class="koboSpan" id="kobo.838.1">Create a new variable containing the destination of where to place our </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">dist</span></strong><span class="koboSpan" id="kobo.840.1"> packages (our </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">lib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.843.1"> folder):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.844.1">
const libSource = path.resolve(basePath, "lib");</span></pre></li> <li><span class="koboSpan" id="kobo.845.1">Define the </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.846.1">copy details in a property </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">lib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.850.1">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js') // all *.js in every                                              folder
    ],
    jsBundles: [
        path.resolve(tsSource, 'site.js') // specific files to                                              bundle/minify
    ],
    sassSrc: [
        path.resolve(sassSource, 'site.scss')
    ],
    // local dev (copy dist into lib)
    lib: [
        {
            src: path.resolve(moduleSource, 'bootstrap/                dist/**/*'),
            dest: path.resolve(libSource, 'bootstrap/')
        },
        {
            src: path.resolve(moduleSource, '@fortawesome/                fontawesome-free/**/*'),
            dest: path.resolve(libSource, 'fontawesome/')
        }
    ]
};</span></pre></li> <li><span class="koboSpan" id="kobo.851.1">Add the </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.852.1">processing and </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">cleaning functions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.854.1">
/* Copy Libraries to their location */
function copyLibraries(done) {
    srcPaths.lib.forEach(item =&gt; {
        return gulp.src(item.src)
            .pipe(gulp.dest(item.dest));
    });
    done();
}
function cleanLibraries(done) {
    srcPaths.lib.forEach(item =&gt; {
        return gulp.src(item.dest + "/*.*")
            .pipe(gp_clean({ force: true }));
    });
    done();
}</span></pre></li> <li><span class="koboSpan" id="kobo.855.1">Finally, add our library copy to the </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">build process:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.857.1">
// Global default and cleanup tasks
exports.build = series(
    cleanLibraries,
    copyLibraries,
    ts_clean,
    js_clean,
    sass_clean,
    ts_transpile,
    js_bundle_min,
    sass
);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.858.1">This gives us the ability to automatically receive the latest versions of packages for our application. </span><span class="koboSpan" id="kobo.858.2">When</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.859.1"> updating our </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">package.json</span></strong><span class="koboSpan" id="kobo.861.1"> file, we’ll benefit from the latest versions in </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">node_modules</span></strong><span class="koboSpan" id="kobo.863.1"> delivered right to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">lib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.866.1"> folder.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.867.1">Updating the links</span></h2>
<p><span class="koboSpan" id="kobo.868.1">Since we</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.869.1"> have a new application, we’ll create </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">Url</span></strong><span class="koboSpan" id="kobo.871.1"> Helpers to help catalog the site. </span><span class="koboSpan" id="kobo.871.2">Based on the template, we have two links: </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">Home</span></strong><span class="koboSpan" id="kobo.873.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">Privacy</span></strong><span class="koboSpan" id="kobo.875.1">. </span><span class="koboSpan" id="kobo.875.2">Let’s create those </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">Url</span></strong><span class="koboSpan" id="kobo.877.1"> Helpers, </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.879.1">
public static class BucksUrlExtensions
{
    public static string HomeUrl(this IUrlHelper helper) =&gt;
        helper.PageLink("/Index")!;
    public static string PrivacyUrl(this IUrlHelper helper) =&gt;
        helper.PageLink("/Privacy")!;
}</span></pre> <p><span class="koboSpan" id="kobo.880.1">This makes our HTML easier to read. </span><span class="koboSpan" id="kobo.880.2">Instead of the Anchor Tag Helpers, we can substitute them with a Url Helper. </span><span class="koboSpan" id="kobo.880.3">Here is the result of replacing the Privacy Anchor </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">Tag Helper:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.882.1">
    &lt;footer class="border-top footer text-muted"&gt;
        &lt;div class="container"&gt;
            &amp;copy; 2023 - Buck's Coffee Shop - &lt;a href="@Url.PrivacyUrl()"&gt;Privacy&lt;/a&gt;
        &lt;/div&gt;
    &lt;/footer&gt;</span></pre> <p><span class="koboSpan" id="kobo.883.1">While this is one instance on this page, we can already see the dividends of our efforts. </span><span class="koboSpan" id="kobo.883.2">Notice the </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">navigation bar?</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">In the navigation </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.886.1">bar, there’s another location where we can remove the hardcoded URL and use a strongly typed </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">UrlHelper</span></strong><span class="koboSpan" id="kobo.888.1"> class, as </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">illustrated here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.890.1">
&lt;ul class="navbar-nav flex-grow-1"&gt;
    &lt;li class="nav-item"&gt;
        &lt;a class="nav-link text-dark" href="@Url.HomeUrl()"&gt;Home&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class="nav-item"&gt;
        &lt;a class="nav-link text-dark" href="@Url.PrivacyUrl()"&gt;Privacy&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;</span></pre> <p><span class="koboSpan" id="kobo.891.1">There are </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">Privacy</span></strong><span class="koboSpan" id="kobo.893.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">Home</span></strong><span class="koboSpan" id="kobo.895.1"> links </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">we replaced.</span></span></p>
<p><span class="koboSpan" id="kobo.897.1">The technique also works with controllers or Razor Pages. </span><span class="koboSpan" id="kobo.897.2">If we need to redirect to another page, there is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">UrlHelper</span></strong><span class="koboSpan" id="kobo.899.1"> class available to us by default, as </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.901.1">
public IActionResult OnGet()
{
    return Redirect(Url.HomeUrl());
}</span></pre> <p><span class="koboSpan" id="kobo.902.1">It removes the</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.903.1"> need for hardcoded URLs, providing a more efficient way of referencing links across a </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">large website.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.905.1">Creating an OffCanvas Tag Helper</span></h2>
<p><span class="koboSpan" id="kobo.906.1">Since responsive </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.907.1">websites are</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.908.1"> important, we need to have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.910.1"> menu for when users see the site with a </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">mobile device.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.913.1"> menus are activated on mobile devices when clicking on a hamburger menu (shown as three lines on top of each other). </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.915.1"> menus are hidden from the main content on a web page, hence the name. </span><span class="koboSpan" id="kobo.915.2">They’re only necessary to hide navigational items until they’re </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">actually needed.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">We’re creating an </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.919.1"> menu for Buck’s website. </span><span class="koboSpan" id="kobo.919.2">However, we want to use this on multiple sites, so there is a requirement to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">reusable component.</span></span></p>
<p><span class="koboSpan" id="kobo.921.1">Bootstrap has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.923.1"> component and, while it’s simple HTML, we can turn this into a reusable component with </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">Tag Helpers.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">First, we need the structure of a Tag Helper. </span><span class="koboSpan" id="kobo.925.2">Here’s the code we need </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">to execute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.927.1">
[HtmlTargetElement("offcanvas")]
public class OffCanvasTagHelper: TagHelper
{
    [HtmlAttributeName("id")]
    public string Id { get; set; }
    [HtmlAttributeName("tabindex")]
    public string TabIndex { get; set; }
    public override async Task ProcessAsync(TagHelperContext context,
        TagHelperOutput output)
    {
        var childData = (await output.GetChildContentAsync()).GetContent();
        output.Attributes.Clear();
        output.TagName = "div";
        output.Attributes.Add("class", "offcanvas offcanvas-start");
        if (!string.IsNullOrEmpty(Id))
        {
            output.Attributes.Add("id ", Id);
        }
        if (!string.IsNullOrEmpty(TabIndex))
        {
            output.Attributes.Add("tabindex", TabIndex);
        }
        output.Content.SetHtmlContent(childData);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.928.1">At the </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.929.1">beginning of the code, we</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.930.1"> need to identify which HTML Tag we want to use for our Tag Helper. </span><span class="koboSpan" id="kobo.930.2">In this case, it’s a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">offcanvas</span></strong><span class="koboSpan" id="kobo.932.1"> tag. </span><span class="koboSpan" id="kobo.932.2">Since HTML tags, attributes, and CSS classes are all lowercase by default, every reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.934.1"> class should contain a lowercase string of </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">the tag.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">We want to include an ID and a tab index based on the examples, so we need two properties called </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">Id</span></strong><span class="koboSpan" id="kobo.938.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">TabIndex</span></strong><span class="koboSpan" id="kobo.940.1">, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">[HtmlAttributeName]</span></strong><span class="koboSpan" id="kobo.942.1"> data annotations applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">each property.</span></span></p>
<p><span class="koboSpan" id="kobo.944.1">The primary method is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">ProcessAsync</span></strong><span class="koboSpan" id="kobo.946.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">Process</span></strong><span class="koboSpan" id="kobo.948.1">) method. </span><span class="koboSpan" id="kobo.948.2">We immediately grab any children inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">offcanvas</span></strong><span class="koboSpan" id="kobo.950.1"> tag and process the child tags, which we’ll get to later in </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.952.1">We set </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">tagname</span></strong><span class="koboSpan" id="kobo.954.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">DIV</span></strong><span class="koboSpan" id="kobo.956.1">, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">classname</span></strong><span class="koboSpan" id="kobo.958.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">offcanvas</span></strong><span class="koboSpan" id="kobo.960.1">, set the attributes, and finally, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">innerHTML</span></strong><span class="koboSpan" id="kobo.962.1"> to the child data retrieved from the beginning of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">ProcessAsync</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.964.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.965.1">According to the </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.966.1">Bootstrap </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.968.1"> documentation, we</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.969.1"> need a header and a body. </span><span class="koboSpan" id="kobo.969.2">We can easily duplicate this code to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">header</span></strong><span class="koboSpan" id="kobo.971.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">body</span></strong><span class="koboSpan" id="kobo.973.1"> tag </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">offcanvasTagHelper</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.977.1">
[HtmlTargetElement("header", ParentTag = "offcanvas")]
public class OffCanvasHeaderTagHelper: TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context,
        TagHelperOutput output)
    {
        var childData = (await output.GetChildContentAsync()).GetContent();
        output.TagName = "div";
        output.Attributes.Add("class", "offcanvas-header");
        var header = new TagBuilder("h5")
        {
            TagRenderMode = TagRenderMode.Normal
        };
        header.Attributes.Add("id", "offcanvasLabel");
        header.AddCssClass("offcanvas-title");
        header.InnerHtml.Append(childData);
        var button = new TagBuilder("button")
        {
            TagRenderMode = TagRenderMode.Normal
        };
        button.AddCssClass("btn-close");
        button.Attributes.Add("type","button");
        button.Attributes.Add("data-bs-dismiss","offcanvas");
        button.Attributes.Add("aria-label","Close");
        output.Content.AppendHtml(header);
        output.Content.AppendHtml(button);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.978.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">HTMLTargetElement</span></strong><span class="koboSpan" id="kobo.980.1"> data </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.981.1">annotation </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.982.1">is a little bit different. </span><span class="koboSpan" id="kobo.982.2">We called this tag </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">header</span></strong><span class="koboSpan" id="kobo.984.1">. </span><span class="koboSpan" id="kobo.984.2">Won’t this interfere with the regular HTML header tag? </span><span class="koboSpan" id="kobo.984.3">Not so long as we include </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">ParentTag</span></strong><span class="koboSpan" id="kobo.986.1"> as a second parameter, saying this element is only valid within an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">offcanvas</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.988.1"> element.</span></span></p>
<p><span class="koboSpan" id="kobo.989.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">Process</span></strong><span class="koboSpan" id="kobo.991.1"> method, we create a header and button and append the HTML to the output’s content at the bottom. </span><span class="koboSpan" id="kobo.991.2">This content is sent back to the parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">offcanvasTagHelper</span></strong><span class="koboSpan" id="kobo.993.1"> instance as the </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">child data.</span></span></p>
<p><span class="koboSpan" id="kobo.995.1">We only need to create the body with </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">OffCanvasBodyTagHelper</span></strong><span class="koboSpan" id="kobo.997.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.999.1">
[HtmlTargetElement("body", ParentTag = "offcanvas")]
public class OffCanvasBodyTagHelper: TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context,
        TagHelperOutput output)
    {
        var childData = (await output.GetChildContentAsync()).            GetContent();
        output.TagName = "div";
        output.Attributes.Add("class", "offcanvas-body");
        output.Content.SetHtmlContent(childData);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1000.1">This will</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.1001.1"> contain the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">HTMLTargetElement</span></strong><span class="koboSpan" id="kobo.1003.1"> data</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.1004.1"> annotation as our header, but we’ll call this the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">body</span></strong><span class="koboSpan" id="kobo.1006.1"> tag. </span><span class="koboSpan" id="kobo.1006.2">Again, it won’t interfere with the standard body HTML tag since we’re inside an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">&lt;offcanvas&gt;</span></strong><span class="koboSpan" id="kobo.1008.1"> element. </span><span class="koboSpan" id="kobo.1008.2">We get the child data (which should be a lot of HTML), we set the class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">TagName</span></strong><span class="koboSpan" id="kobo.1010.1"> property, and finally set the content to what was inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">body tag.</span></span></p>
<p><span class="koboSpan" id="kobo.1012.1">One last thing required for our tag helper to work is to include all </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">TagHelper</span></strong><span class="koboSpan" id="kobo.1014.1"> instances in the project through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">_ViewImports.cshtml</span></strong><span class="koboSpan" id="kobo.1016.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
@addTagHelper *, BucksCoffeeShop</span></pre> <p><span class="koboSpan" id="kobo.1019.1">We can add a button to our HTML to trigger </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">offcanvas</span></strong><span class="koboSpan" id="kobo.1021.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
&lt;button class="btn btn-primary btn-sm" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasExample" aria-controls="offcanvasExample"&gt;
    Open
&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.1024.1">We can now create a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">offcanvas</span></strong><span class="koboSpan" id="kobo.1026.1"> component in our HTML, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
&lt;offcanvas id="offcanvasExample" tabindex="-1"&gt;
    &lt;header&gt;Buck's Coffee Shop&lt;/header&gt;
    &lt;body&gt;
        &lt;p&gt;
            Content for the offcanvas goes here.
</span><span class="koboSpan" id="kobo.1028.2">            You can place just about any Bootstrap
            component or custom elements here.
</span><span class="koboSpan" id="kobo.1028.3">        &lt;/p&gt;
    &lt;/body&gt;
&lt;/offcanvas&gt;</span></pre> <p><span class="koboSpan" id="kobo.1029.1">Once this is rendered, it will produce the Bootstrap result of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.1031.1"> component with </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">valid HTML.</span></span></p>
<p><span class="koboSpan" id="kobo.1033.1">This powerful technique can be applied to create a simplified HTML language for any domain where even non-developers can understand </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">web pages.</span></span></p>
<p><span class="koboSpan" id="kobo.1035.1">In this section, we</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.1036.1"> took a sample</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.1037.1"> website and optimized our client-side scripts and styles, centralized our links by creating URL Helper extension methods, and finally, built an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">OffCanvas</span></strong><span class="koboSpan" id="kobo.1039.1"> Tag Helper to showcase how we can create our own HTML library of </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">powerful elements.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1041.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1042.1">In this chapter, we began with how important a task runner is for client-side tasks and how to set up a task runner, then understood the structure of a gulpfile and how to create a workflow structure. </span><span class="koboSpan" id="kobo.1042.2">Once we had our task runner working, we put it to work by focusing on transpiling TypeScript into JavaScript and bundling and minifying it into something for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">production website.</span></span></p>
<p><span class="koboSpan" id="kobo.1044.1">We proceeded with looking at what’s considered a standard in the industry when it comes to UIs in ASP.NET 8. </span><span class="koboSpan" id="kobo.1044.2">We learned about how to save time by centralizing all links in one place, why it’s important to keep controllers and Razor Pages small, and the key reasons why </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">ViewComponent</span></strong><span class="koboSpan" id="kobo.1046.1"> classes should be used. </span><span class="koboSpan" id="kobo.1046.2">We learned why </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">TagHelper</span></strong><span class="koboSpan" id="kobo.1048.1"> classes are better than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">HTMLHelper</span></strong><span class="koboSpan" id="kobo.1050.1"> classes and why a site should use </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">SEO-friendly URLs.</span></span></p>
<p><span class="koboSpan" id="kobo.1052.1">To finalize this chapter, we looked at an example website and had a task runner bundle and minify our styles along with updating libraries automatically on build. </span><span class="koboSpan" id="kobo.1052.2">We also applied URL Helper extension methods to the site, making it easier to change site-wide links. </span><span class="koboSpan" id="kobo.1052.3">Finally, we took a Bootstrap </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">offcanvas</span></strong><span class="koboSpan" id="kobo.1054.1"> HTML component and converted it into a reusable </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">TagHelper</span></strong><span class="koboSpan" id="kobo.1056.1"> class to showcase the power of </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">Tag Helpers.</span></span></p>
<p><span class="koboSpan" id="kobo.1058.1">In the next chapter, we’ll look at the different types of testing and what are the best ways to unit test </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">our code.</span></span></p>
</div>
</body></html>