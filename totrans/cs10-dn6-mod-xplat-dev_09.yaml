- en: 09
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Files, Streams, and Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about reading and writing to files and streams, text encoding,
    and serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding and decoding text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing object graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling JSON processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your applications will often need to perform input and output operations with
    files and directories in different environments. The `System` and `System.IO`
    namespaces contain classes for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Handling cross-platform environments and filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore how to handle cross-platform environments like the differences
    between Windows and Linux or macOS. Paths are different for Windows, macOS, and
    Linux, so we will start by exploring how .NET handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application**/`console`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter09`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithFileSystems`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to statically import the `System.Console`,
    `System.IO.Directory`, `System.Environment`, and `System.IO.Path` types, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, create a static `OutputFileSystemInfo` method, and write statements
    in it to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the path and directory separation characters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Output the path of the current directory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Output some special paths for system files, temporary files, and documents.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Environment` type has many other useful members that we did not use in
    this code, including the `GetEnvironmentVariables` method and the `OSVersion`
    and `ProcessorCount` properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, above the function, call the `OutputFileSystemInfo` method,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code and view the result, as shown in *Figure 9.1*:![Text  Description
    automatically generated](img/B17442_09_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.1: Running your application to show filesystem information on Windows'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When running the console app using `dotnet run` with Visual Studio Code, the
    `CurrentDirectory` will be the project folder, not a folder inside `bin`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Windows uses a backslash `\` for the directory separator
    character. macOS and Linux use a forward slash `/` for the directory separator
    character. Do not assume what character is used in your code when combining paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing drives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage drives, use the `DriveInfo` type, which has a static method that returns
    information about all the drives connected to your computer. Each drive has a
    drive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore drives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithDrives` method, and write statements to get all the drives
    and output their name, type, size, available free space, and format, but only
    if the drive is ready, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Check that a drive is ready before reading properties such
    as `TotalSize` or you will see an exception thrown with removable drives.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the previous method call and add a call to `WorkWithDrives`,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code and view the result, as shown in *Figure 9.2*:![](img/B17442_09_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.2: Showing drive information on Windows'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Managing directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage directories, use the `Directory`, `Path`, and `Environment` static
    classes. These types include many members for working with the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When constructing custom paths, you must be careful to write your code so that
    it makes no assumptions about the platform, for example, what to use for the directory
    separator character:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithDirectories` method, and write statements to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a custom path under the user's home directory by creating an array of
    strings for the directory names, and then properly combining them with the `Path`
    type's `Combine` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for the existence of the custom directory path using the `Exists` method
    of the `Directory` class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create and then delete the directory, including files and subdirectories within
    it, using the `CreateDirectory` and `Delete` methods of the `Directory` class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment out the previous method call, and add a call to `WorkWithDirectories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, and use your favorite file management tool
    to confirm that the directory has been created before pressing Enter to delete
    it, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Managing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with files, you could statically import the file type, just as
    we did for the directory type, but, for the next example, we will not, because
    it has some of the same methods as the directory type and they would conflict.
    The file type has a short enough name not to matter in this case. The steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithFiles` method, and write statements to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for the existence of a file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a text file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a line of text to the file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the file to release system resources and file locks (this would normally
    be done inside a `try-finally` statement block to ensure that the file is closed
    even if an exception occurs when writing to it).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the file to a backup.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read the backup file''s contents and then close it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment out the previous method call, and add a call to `WorkWithFiles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Managing paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to work with parts of a path; for example, you might want
    to extract just the folder name, the filename, or the extension. Sometimes, you
    need to generate temporary folders and filenames. You can do this with static
    methods of the `Path` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following statements to the end of the `WorkWithFiles` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetTempFileName` creates a zero-byte file and returns its name, ready for
    you to use. `GetRandomFileName` just returns a filename; it doesn''t create the
    file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting file information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get more information about a file or directory, for example, its size or
    when it was last accessed, you can create an instance of the `FileInfo` or `DirectoryInfo`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileInfo` and `DirectoryInfo` both inherit from `FileSystemInfo`, so they
    both have members such as `LastAccessTime` and `Delete`, as well as extra members
    specific to themselves, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Members |'
  prefs: []
  type: TYPE_TB
- en: '| `FileSystemInfo` | Fields: `FullPath`, `OriginalPath`Properties: `Attributes`,
    `CreationTime`, `CreationTimeUtc`, `Exists`, `Extension`, `FullName`, `LastAccessTime`,
    `LastAccessTimeUtc`, `LastWriteTime`, `LastWriteTimeUtc`, `Name`Methods: `Delete`,
    `GetObjectData`, `Refresh` |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo` | Properties: `Parent`, `Root`Methods: `Create`, `CreateSubdirectory`,
    `EnumerateDirectories`, `EnumerateFiles`, `EnumerateFileSystemInfos`, `GetAccessControl`,
    `GetDirectories`, `GetFiles`, `GetFileSystemInfos`, `MoveTo`, `SetAccessControl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FileInfo` | Properties: `Directory`, `DirectoryName`, `IsReadOnly`, `Length`Methods:
    `AppendText`, `CopyTo`, `Create`, `CreateText`, `Decrypt`, `Encrypt`, `GetAccessControl`,
    `MoveTo`, `Open`, `OpenRead`, `OpenText`, `OpenWrite`, `Replace`, `SetAccessControl`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s write some code that uses a `FileInfo` instance for efficiently performing
    multiple actions on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to the end of the `WorkWithFiles` method to create an instance
    of `FileInfo` for the backup file and write information about it to the console,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The number of bytes might be different on your operating system because operating
    systems can use different line endings.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling how you work with files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with files, you often need to control how they are opened. The
    `File.Open` method has overloads to specify additional options using `enum` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileMode`: This controls what you want to do with the file, like `CreateNew`,
    `OpenOrCreate`, or `Truncate`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileAccess`: This controls what level of access you need, like `ReadWrite`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileShare`: This controls locks on the file to allow other processes the specified
    level of access, like `Read`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might want to open a file and read from it, and allow other processes to
    read it too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an `enum` for attributes of a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileAttributes`: This is to check a `FileSystemInfo`-derived types'' `Attributes`
    property for values like `Archive` and `Encrypted`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You could check a file or directory''s attributes, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stream** is a sequence of bytes that can be read from and written to. Although
    files can be processed rather like arrays, with random access provided by knowing
    the position of a byte within the file, it can be useful to process files as a
    stream in which the bytes can be accessed in sequential order.
  prefs: []
  type: TYPE_NORMAL
- en: Streams can also be used to process terminal input and output and networking
    resources such as sockets and ports that do not provide random access and cannot
    seek (that is, move) to a position. You can write code to process some arbitrary
    bytes without knowing or caring where it comes from. Your code simply reads or
    writes to a stream, and another piece of code handles where the bytes are actually
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding abstract and concrete streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an `abstract` class named `Stream` that represents any type of stream.
    Remember that an `abstract` class cannot be instantiated using `new`; they can
    only be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: There are many concrete classes that inherit from this base class, including
    `FileStream`, `MemoryStream`, `BufferedStream`, `GZipStream`, and `SslStream`,
    so they all work the same way. All streams implement `IDisposable`, so they have
    a `Dispose` method to release unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common members of the `Stream` class are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `CanRead`, `CanWrite` | These properties determine if you can read from and
    write to the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `Length`, `Position` | These properties determine the total number of bytes
    and the current position within the stream. These properties may throw an exception
    for some types of streams. |'
  prefs: []
  type: TYPE_TB
- en: '| `Dispose` | This method closes the stream and releases its resources. |'
  prefs: []
  type: TYPE_TB
- en: '| `Flush` | If the stream has a buffer, then this method writes the bytes in
    the buffer to the stream and the buffer is cleared. |'
  prefs: []
  type: TYPE_TB
- en: '| `CanSeek` | This property determines if the `Seek` method can be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `Seek` | This method moves the current position to the one specified in its
    parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Read`, `ReadAsync` | These methods read a specified number of bytes from
    the stream into a byte array and advance the position. |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadByte` | This method reads the next byte from the stream and advances
    the position. |'
  prefs: []
  type: TYPE_TB
- en: '| `Write`, `WriteAsync` | These methods write the contents of a byte array
    into the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteByte` | This method writes a byte to the stream. |'
  prefs: []
  type: TYPE_TB
- en: Understanding storage streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some storage streams that represent a location where the bytes will be stored
    are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `FileStream` | Bytes stored in the filesystem. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `MemoryStream` | Bytes stored in memory in the current process.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Sockets` | `NetworkStream` | Bytes stored at a network location.
    |'
  prefs: []
  type: TYPE_TB
- en: '`FileStream` has been re-written in .NET 6 to have much higher performance
    and reliability on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some function streams that cannot exist on their own, but can only be "plugged
    onto" other streams to add functionality, are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Security.Cryptography` | `CryptoStream` | This encrypts and decrypts
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO.Compression` | `GZipStream`, `DeflateStream` | These compress
    and decompress the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Security` | `AuthenticatedStream` | This sends credentials across
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: Understanding stream helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although there will be occasions where you need to work with streams at a low
    level, most often, you can plug helper classes into the chain to make things easier.
    All the helper types for streams implement `IDisposable`, so they have a `Dispose`
    method to release unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some helper classes to handle common scenarios are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `StreamReader` | This reads from the underlying stream as plain
    text. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `StreamWriter` | This writes to the underlying stream as plain
    text. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `BinaryReader` | This reads from streams as .NET types. For
    example, the `ReadDecimal` method reads the next 16 bytes from the underlying
    stream as a `decimal` value and the `ReadInt32` method reads the next 4 bytes
    as an `int` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `BinaryWriter` | This writes to streams as .NET types. For
    example, the `Write` method with a `decimal` parameter writes 16 bytes to the
    underlying stream and the `Write` method with an `int` parameter writes 4 bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Xml` | `XmlReader` | This reads from the underlying stream using
    XML format. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Xml` | `XmlWriter` | This writes to the underlying stream using XML
    format. |'
  prefs: []
  type: TYPE_TB
- en: Writing to text streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s type some code to write text to a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new console app named `WorkingWithStreams`
    to the `Chapter09` solution/workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithStreams` as the active OmniSharp project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `WorkingWithStreams` project, in `Program.cs`, import the `System.Xml`
    namespace and statically import the `System.Console`, `System.Environment`, and
    `System.IO.Path` types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, define a static class named `Viper` with a static
    array of `string` values named `Callsigns`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above the `Viper` class, define a `WorkWithText` method that enumerates the
    Viper call signs, writing each one on its own line in a single text file, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Below the namespace imports, call the `WorkWithText` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the file that was created and check that it contains the list of call signs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing to XML streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to write an XML element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteStartElement` and `WriteEndElement`: Use this pair when an element might
    have child elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WriteElementString`: Use this when an element does not have children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s try storing the Viper pilot call signs array of `string` values
    in an XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithXml` method that enumerates the call signs, writing each
    one as an element in a single XML file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment out the previous method call, and add a call to the
    `WorkWithXml` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Disposing of file resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you open a file to read or write to it, you are using resources outside
    of .NET. These are called **unmanaged resources** and must be disposed of when
    you are done working with them. To deterministically control when they are disposed
    of, we can call the `Dispose` method inside of a `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve our previous code that works with XML to properly dispose of
    its unmanaged resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `WorkWithXml` method, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You could also go back and modify the other methods you previously created but
    I will leave that as an optional exercise for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Before calling the `Dispose` method, check that the object
    is not null.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying disposal by using the using statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can simplify the code that needs to check for a `null` object and then call
    its `Dispose` method by using the `using` statement. Generally, I would recommend
    using `using` rather than manually calling `Dispose` unless you need a greater
    level of control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confusingly, there are two uses for the `using` keyword: importing a namespace
    and generating a `finally` statement that calls `Dispose` on an object that implements
    `IDisposable`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler changes a `using` statement block into a `try`-`finally` statement
    without a `catch` statement. You can use nested `try` statements; so, if you do
    want to catch any exceptions, you can, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even simplify the code further by not explicitly specifying the braces
    and indentation for the `using` statements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Compressing streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XML is relatively verbose, so it takes up more space in bytes than plain text.
    Let''s see how we can squeeze the XML using a common compression algorithm known
    as GZIP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for working with compression,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `WorkWithCompression` method, which uses instances of `GZipStream` to
    create a compressed file containing the same XML elements as before and then decompresses
    it while reading it and outputting to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, leave the call to `WorkWithXml`, and add a call to `WorkWithCompression`,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and compare the sizes of the XML file and the compressed XML file.
    It is less than half the size of the same XML without compression, as shown in
    the following edited output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compressing with the Brotli algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In .NET Core 2.1, Microsoft introduced an implementation of the Brotli compression
    algorithm. In performance, Brotli is like the algorithm used in DEFLATE and GZIP,
    but the output is about 20% denser. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `WorkWithCompression` method to have an optional parameter to indicate
    if Brotli should be used and to use Brotli by default, as shown highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Near the top of `Program.cs`, call `WorkWithCompression` twice, once with the
    default using Brotli and once with GZIP, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and compare the sizes of the two compressed XML files. Brotli
    is more than 21% denser, as shown in the following edited output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Encoding and decoding text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text characters can be represented in different ways. For example, the alphabet
    can be encoded using Morse code into a series of dots and dashes for transmission
    over a telegraph line.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, text inside a computer is stored as bits (ones and zeros)
    representing a code point within a code space. Most code points represent a single
    character, but they can also have other meanings like formatting.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ASCII has a code space with 128 code points. .NET uses a standard
    called **Unicode** to encode text internally. Unicode has more than one million
    code points.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will need to move text outside .NET for use by systems that do
    not use Unicode or use a variation of Unicode, so it is important to learn how
    to convert between encodings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists some alternative text encodings commonly used by
    computers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Encoding | Description |'
  prefs: []
  type: TYPE_TB
- en: '| ASCII | This encodes a limited range of characters using the lower seven
    bits of a byte. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-8 | This represents each Unicode code point as a sequence of one to four
    bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-7 | This is designed to be more efficient over 7-bit channels than UTF-8
    but it has security and robustness issues, so UTF-8 is recommended over UTF-7.
    |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16 | This represents each Unicode code point as a sequence of one or
    two 16-bit integers. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-32 | This represents each Unicode code point as a 32-bit integer and
    is therefore a fixed-length encoding unlike the other Unicode encodings, which
    are all variable-length encodings. |'
  prefs: []
  type: TYPE_TB
- en: '| ANSI/ISO encodings | This provides support for a variety of code pages that
    are used to support a specific language or group of languages. |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice**: In most cases today, UTF-8 is a good default, which is why
    it is literally the default encoding, that is, `Encoding.Default`.'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding strings as byte arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore text encodings:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithEncodings`
    to the `Chapter09` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithEncodings` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, import the `System.Text` namespace and statically import the
    `Console` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to encode a `string` using an encoding chosen by the user, loop
    through each byte, and then decode it back into a `string` and output it, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code and note the warning to avoid using `Encoding.UTF7` because it
    is insecure. Of course, if you need to generate text using that encoding for compatibility
    with another system, it needs to remain an option in .NET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press 1 to choose ASCII and note that when outputting the bytes, the pound sign
    (£) and accented e (é) cannot be represented in ASCII, so it uses a question mark
    instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the code and press 3 to choose UTF-8 and note that UTF-8 requires two
    extra bytes for the two characters that need 2 bytes each (18 bytes instead of
    16 bytes total) but it can encode and decode the é and £ characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the code and press 4 to choose Unicode (UTF-16) and note that UTF-16 requires
    two bytes for every character, so 32 bytes in total, and it can encode and decode
    the é and £ characters. This encoding is used internally by .NET to store `char`
    and `string` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encoding and decoding text in files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using stream helper classes, such as `StreamReader` and `StreamWriter`,
    you can specify the encoding you want to use. As you write to the helper, the
    text will automatically be encoded, and as you read from the helper, the bytes
    will be automatically decoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify an encoding, pass the encoding as a second parameter to the helper
    type''s constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Often, you won''t have the choice of which encoding to use,
    because you will be generating a file for use by another system. However, if you
    do, pick one that uses the least number of bytes, but can store every character
    you need.'
  prefs: []
  type: TYPE_NORMAL
- en: Serializing object graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Serialization** is the process of converting a live object into a sequence
    of bytes using a specified format. **Deserialization** is the reverse process.
    You would do this to save the current state of a live object so that you can recreate
    it in the future. For example, saving the current state of a game so that you
    can continue at the same place tomorrow. Serialized objects are usually stored
    in a file or database.'
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of formats you can specify, but the two most common ones are
    **eXtensible Markup Language** (**XML**) and **JavaScript Object Notation** (**JSON**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: JSON is more compact and is best for web and mobile applications.
    XML is more verbose but is better supported in more legacy systems. Use JSON to
    minimize the size of serialized object graphs. JSON is also a good choice when
    sending object graphs to web applications and mobile applications because JSON
    is the native serialization format for JavaScript and mobile apps often make calls
    over limited bandwidth, so the number of bytes is important.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET has multiple classes that will serialize to and from XML and JSON. We will
    start by looking at `XmlSerializer` and `JsonSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing as XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking at XML, probably the world''s most used serialization
    format (for now). To show a typical example, we will define a custom class to
    store information about a person and then create an object graph using a list
    of `Person` instances with nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithSerialization`
    to the `Chapter09` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithSerialization` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class named `Person` with a `Salary` property that is `protected`, meaning
    it is only accessible to itself and derived classes. To populate the salary, the
    class has a constructor with a single parameter to set the initial salary, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, import namespaces for working with XML serialization and statically
    import the `Console`, `Environment`, and `Path` classes, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to create an object graph of `Person` instances, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that an exception is thrown, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person`, add a statement to define a parameterless constructor, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The constructor does not need to do anything, but it must exist so that the
    `XmlSerializer` can call it to instantiate new `Person` instances during the deserialization
    process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rerun the code and view the result, and note that the object graph is serialized
    as XML elements like `<FirstName>Bob</FirstName>` and that the `Salary` property
    is not included because it is not a `public` property, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generating compact XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could make the XML more compact using attributes instead of elements for
    some fields:'
  prefs: []
  type: TYPE_NORMAL
- en: In `Person`, import the `System.Xml.Serialization` namespace so that you can
    decorate some properties with the `[XmlAttribute]` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Decorate the first name, last name, and date of birth properties with the `[XmlAttribute]`
    attribute, and set a short name for each property, as shown highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that the size of the file has been reduced from 752 to
    462 bytes, a space-saving of more than a third, by outputting property values
    as XML attributes, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deserializing XML files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s try deserializing the XML file back into live objects in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to open the XML file and then deserialize it, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that the people are loaded successfully from the XML
    file and then enumerated, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are many other attributes that can be used to control the XML generated.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use any annotations, `XmlSerializer` performs a case-insensitive
    match using the property name when deserializing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: When using `XmlSerializer`, remember that only the public
    fields and properties are included, and the type must have a parameterless constructor.
    You can customize the output with attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: Serializing with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most popular .NET libraries for working with the JSON serialization
    format is Newtonsoft.Json, known as Json.NET. It is mature and powerful. Let''s
    see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithSerialization` project, add a package reference for the
    latest version of `Newtonsoft.Json`, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `WorkingWithSerialization` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to create a text file and then serialize the
    people into the file as JSON, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that JSON requires less than half the number of bytes
    compared to XML with elements. It''s even smaller than the XML file, which uses
    attributes, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: High-performance JSON processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Core 3.0 introduced a new namespace for working with JSON, `System.Text.Json`,
    which is optimized for performance by leveraging APIs like `Span<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, older libraries like Json.NET are implemented by reading UTF-16\. It would
    be more performant to read and write JSON documents using UTF-8 because most network
    protocols, including HTTP, use UTF-8 and you can avoid transcoding UTF-8 to and
    from Json.NET's Unicode `string` values.
  prefs: []
  type: TYPE_NORMAL
- en: With the new API, Microsoft achieved between 1.3x and 5x improvement, depending
    on the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original author of Json.NET, James Newton-King, joined Microsoft and has
    been working with them to develop their new JSON types. As he says in a comment
    discussing the new JSON APIs, "Json.NET isn''t going away," as shown in *Figure
    9.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: A comment by the original author of Json.NET'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use the new JSON APIs to deserialize a JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithSerialization` project, in `Program.cs`, import the new
    JSON class for performing serialization using an alias to avoid conflicting names
    with the Json.NET one we used before, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to open the JSON file, deserialize it, and output the names
    and counts of the children of the people, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Choose Json.NET for developer productivity and a large feature
    set or `System.Text.Json` for performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling JSON processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many options for taking control of how JSON is processed, as shown
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Including and excluding fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a casing policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a case-sensitivity policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between compact and prettified whitespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see some in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithJson`
    to the `Chapter09` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithJson` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithJson` project, in `Program.cs`, delete the existing code,
    import the two main namespaces for working with JSON, and then statically import
    the `System.Console`, `System.Environment`, and `System.IO.Path` types, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, define a class named `Book`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above the `Book` class, add statements to create an instance of the `Book`
    class and serialize it to JSON, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The JSON file is 315 bytes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The member names use camelCasing, for example, `publishDate`. This is best for
    subsequent processing in a browser with JavaScript.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All fields are included due to the options set, including `pages`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON is prettified for easier human legibility.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTimeOffset` values are stored as a single standard string format.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateOnly` values are stored as an object with sub-properties for date parts
    like `year` and `month`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In `Program.cs`, when setting the `JsonSerializerOptions`, comment out the setting
    of casing policy, write indented, and include fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The JSON file is 230 bytes, a more than 25% reduction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The member names use normal casing, for example, `PublishDate`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Pages` field is missing. The other fields are included due to the `[JsonInclude]`
    attribute on `PublishDate` and `Created` field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON is compact with minimal whitespace to save bandwidth for transmission or
    storage.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New JSON extension methods for working with HTTP responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET 5, Microsoft added refinements to the types in the `System.Text.Json`
    namespace like extension methods for `HttpResponse`, which you will see in *Chapter
    16*, *Building and Consuming Web Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from Newtonsoft to new JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have existing code that uses the Newtonsoft Json.NET library and you
    want to migrate to the new `System.Text.Json` namespace, then Microsoft has specific
    documentation for that, which you will find at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with more in-depth research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between using the `File` class and the `FileInfo` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `ReadByte` method and the `Read` method of
    a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use the `StringReader`, `TextReader`, and `StreamReader` classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `DeflateStream` type do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes per character does UTF-8 encoding use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an object graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best serialization format to choose for minimizing space requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best serialization format to choose for cross-platform compatibility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it bad to use a `string` value like `"\Code\Chapter01"` to represent
    a path, and what should you do instead?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you find information about NuGet packages and their dependencies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 9.2 – Practice serializing as XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter09` solution/workspace, create a console application named `Exercise02`
    that creates a list of shapes, uses serialization to save it to the filesystem
    using XML, and then deserializes it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Shapes should have a read-only property named `Area` so that when you deserialize,
    you can output a list of shapes, including their areas, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what your output should look like when you run your console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 9.3 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-9---working-with-files-streams-and-serialization](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-9---working-with-files-streams-and-serialization)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to read from and write to text files and XML
    files, how to compress and decompress files, how to encode and decode text, and
    how to serialize an object into JSON and XML (and deserialize it back again).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to work with databases using Entity
    Framework Core.
  prefs: []
  type: TYPE_NORMAL
