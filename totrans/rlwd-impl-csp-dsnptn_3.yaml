- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Creative with Creational Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational patterns deal with creating objects, a process we call *instantiation*.
    Remember, an object is a class that has been instantiated. Objects only exist
    in running programs. They are built from blueprints called *classes*. Since C#
    is a static language, you can’t generally change the structure of an object once
    it has been instantiated, which means you should use the best strategy to create
    your objects. That’s what we’ll be discussing in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you’re `new` to software development with C# (that might be the first
    pun in the book that relies only on formatting to be funny), you already know
    the simplest way to instantiate an object from a class. You simply use the `new`
    keyword and invoke the class’s constructor:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s instantiation. You’re creating an instance of a class that acts as the
    point where the class turns into an object. In C#, like many languages, we use
    the `new` keyword in conjunction with a constructor. A constructor is a method,
    whose name. matches the class’s name Its only job is to create and return an instance
    of the class as a new object. That is why you have a parenthesis at the end of
    `CreateObjectThingy()`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need anything else? Remember the foundational principles we covered
    earlier in this book. We don’t want a stovepipe system consisting of a bunch of
    object classes we can’t build from because they’re too specific, too concrete,
    or tightly coupled to one another. By definition, the `new` keyword creates a
    concrete object. Our classes should be open for extension but closed for modification.
    and However in stovepipe software they aren’t stovepipe software, they aren’t.
    Following patterns will help us avoid those situations and provide us with a clear
    way to create complex objects that are easy to understand and extend.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The initial design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No pattern implementation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Simple Factory pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory Method pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Builder pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Object Pool pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton pattern
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These patterns will be shown in simple C# command-line projects to keep the
    proverbial signal-to-noise ratio low. There are a great many books out there that
    teach patterns independently of any coding language. I think this is a mistake.
    Most people learn by doing, and to “do” patterns, you need an implementation language.
    Without that, you are just learning academic concepts. We are focused on the real
    world and we’re using C#, but what you will learn in this book is 100% portable.
    As you learn about these patterns, remember that they are not language-specific.
    You can use the knowledge you gain here and apply it to Java, Python, or any other
    object-oriented language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, I assume you know how to create new C# projects in your
    favorite **integrated development environment** (**IDE**), so I won’t spend any
    time on the mechanics of setting up and running projects. Should you decide to
    try any of this out, you’ll need the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A computer running the Windows operating system. I’m using Windows 10\. Since
    the projects are simple command-line projects, I’m pretty sure everything here
    would also work on a Mac or Linux, but I haven’t tested the projects on those
    operating systems.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A supported IDE such as Visual Studio, JetBrains Rider, or Visual Studio Code
    with C# extensions. I’m using Rider 2021.3.3.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some version of the .NET SDK. Again, the projects are simple enough that our
    code shouldn’t be reliant on any particular version. I happen to be using the
    .NET Core 6 SDK.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the completed project files for this chapter on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-3).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following story is fictitious
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any resemblance to actual persons, alive or dead, is a mere coincidence.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Meet Kitty and Phoebe – Texas-born sisters who share a love for riding bicycles.
    Phoebe is studying engineering at Southern Methodist University, a private university
    in the sisters’ hometown of Dallas, Texas. Texas is one of the southernmost states
    in the United States. Kitty is studying industrial design at Sul Ross University
    in West Texas. Purely through kismet, they both won a summer internship at MegaBikeCorp,
    which is a large multi-national bicycle manufacturing company:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Kitty (left) and Phoebe (right) posing with their innovative
    bicycle prototype built entirely in their robotic factory. ](img/B18605_Figure_3.1_NEW.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Kitty (left) and Phoebe (right) posing with their innovative bicycle
    prototype built entirely in their robotic factory.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'While working at MegaBikeCorp, the sisters had the opportunity to try out several
    different kinds of bicycles. Phoebe, who lives in a big city, is partial to the
    road bike. Road bikes use a diamond-shaped frame with two large thin wheels, slick
    tires, and plenty of gears to help a rider deal with the steep hills they often
    encounter in many cities:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Kitty’s CAD design for a road bike she calls Hillcrest. ](img/B18605_Figure_4.2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Kitty’s CAD design for a road bike she calls Hillcrest.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The rider on a road bike leans far forward on a set of dropped handlebars. This
    makes these bicycles fast, and every year, hundreds of riders from all over the
    world compete in a famous race called the *Tour de France*. In the tour, racers
    compete to see who is the fastest in the world. Kitty and Phoebe recalled that
    their mother, a huge cycling fan, would not allow anyone in the house to speak
    while the race was on television. Phoebe also enjoyed the tour and as she cycled
    through the streets of Dallas on her road bike, she would often have a desire
    to ride faster. This requires a different bike.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Phoebe rides a recumbent bike when she needs to satisfy her need for speed.
    A recumbent bicycle features the rider sitting in a comfortable seat that looks
    more like a lawn chair but with wheels. You can see Kitty’s design in the following
    diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Kitty’s CAD design for a recumbent bicycle. Note that the frame
    is shaped differently than the diamond shape used on most other bicycles such
    as the Hillcrest shown in the inset. These are among the fastest bicycles ever
    made. ](img/B18605_Figure_4.3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Kitty’s CAD design for a recumbent bicycle. Note that the frame
    is shaped differently than the diamond shape used on most other bicycles such
    as the Hillcrest shown in the inset. These are among the fastest bicycles ever
    made.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The rider leans way back and sits very low on the bicycle. The seat is stretched
    out beneath Phoebe. The pedals are elevated above the front wheel to capture the
    power of the rider’s full leg extension. These bikes can go faster than a traditional
    racing bicycle and they’re very comfortable to ride over long distances. However,
    because of racing rules recognized throughout the world, they are never used for
    racing in events such as the *Tour de France*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitty, on the other hand, enjoys riding a mountain bike, which is designed
    to be ridden off-road like a Jeep. Mountain bikes, like road bikes, use a diamond-shaped
    frame, but they have big, knobby tires and disc brakes that work well in the mud.
    The rider sits more upright so that they can see and react to any off-road obstacles.
    The standard mountain bicycles usually have fancy shock absorbers in the front,
    and the more expensive bikes have a separate shock absorber on the back wheel,
    along with the front shocks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Kitty’s CAD drawing for an innovative design for a mountain
    bike that she calls the “Palo Duro Canyon Ranger”. ](img/B18605_Figure_4.4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Kitty’s CAD drawing for an innovative design for a mountain bike
    that she calls the “Palo Duro Canyon Ranger”.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitty also likes riding in town, but she doesn’t like the uncomfortable riding
    position of a road bike. A recumbent bike is too dangerous to ride because it
    is so low to the ground that cowboys driving the big trucks that are so popular
    in Texas won’t be able to see her. Instead, Kitty likes to ride comfort cruisers,
    sometimes called *granny bikes*. They are perfect for in-town riding. They let
    her sit fully upright in a comfortable position owing to a curved handlebar design:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Kitty’s design for a comfort cruiser bicycle, sometimes called
    a granny bike. These are perfect for in-town commutes and tourists who need to
    get around comfortably. ](img/B18605_Figure_4.5.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Kitty’s design for a comfort cruiser bicycle, sometimes called
    a granny bike. These are perfect for in-town commutes and tourists who need to
    get around comfortably.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The cruisers have thick tires for stability and they have a chain guard and
    enclosed gear system to prevent ruining the left leg of your pants, which tends
    to rub against the bicycle chain. These bicycles are built for comfort rather
    than speed or off-road prowess.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Between them, the sisters rode every model of bicycle produced by MegaBikeCorp.
    Phoebe found the level of engineering innovation at MegaBikeCorp uninspiring.
    Kitty felt MegaBike’s designs were stale. “*They’ve been making the same four
    bicycles for 30 years,*” Kitty said. The sisters decided they could do better
    and decided to make a plan of action. After many long nights, lots of tacos, online
    collaboration sessions, bicycle rides, and a few skinned knees, they came up with
    four bicycle designs. But the sisters did not stop with bike designs. They also
    came up with plans for a robotic manufacturing system that could fully automate
    the bicycle production process. Together, they formed a start-up company called
    *Bumble Bikes Incorporated*, named after Phoebe’s favorite childhood toy: a stuffed
    bumblebee she named *Bumbles*. They plan to open two manufacturing locations:
    one in the sisters’ hometown of Dallas, Texas, and the other in Kitty’s college
    town of Alpine, Texas. The two areas are very different geographically.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: North Texas, Dallas in particular, is urban and heavily developed. Cycling is
    a popular sport and hobby for many North Texans. The riders in the Dallas area
    primarily buy traditional road bicycles. Surprisingly, there is also a lot of
    interest in recumbent bicycles, especially around the large engineering colleges.
    You can even see recumbents ridden around the 7 million-square-foot (650 million
    square-meter) campus of Texas Instruments – a large semi-conductor manufacturer
    in Dallas. The girls decided to build their road bike and recumbent bike designs
    in the factory in Dallas.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In West Texas, the city of Alpine is the last bastion of civilization north
    of Big Bend National Park. Extreme mountain biking is popular in the Chisos mountain
    basin and the old mining and cattle roads that crisscross the desert. Alpine is
    a small town and doesn’t have or need any mass transit services. Kitty’s research
    indicates there is a market for comfortable “cruiser” bicycles that are ideal
    for getting around town. Kitty decides to manufacture the mountain bike and the
    cruiser models in Alpine. Phoebe and Kitty, with their initial plans in hand,
    set to work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Phoebe tasked herself to work on the robotics to be used in manufacturing the
    bicycles. Kitty settled down with her favorite C# IDE and got to work on the control
    software that would ultimately control Phoebe’s robotics. She knows that her designs,
    along with Phoebe’s engineering, will produce the best bicycles the industry has
    ever seen. Kitty is planning on their company and the software that runs it being
    wildly successful, which, as we learned in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016),
    *There’s a Big Ball of Mud on Your Plate of Spaghetti*, is the worst-case scenario.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Kitty’s starting point in writing the code for her robotics control software
    is going to be modeling out the basic class structure for very generic bicycle
    objects. This modeling will form the basis of her entire company’s future. Modeling
    the classes well the first time will put Kitty and Phoebe riding their bicycles
    down the road to success!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow the exploits of the sisters, Kitty and Phoebe, as they embark
    on building the automated plant’s robotic control systems. We’ll focus on creational
    patterns, which are just what they sound like: patterns for controlling the instantiation
    of objects.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The initial design
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kitty knows she wants to model a bicycle for her software, and she wants to
    design her models in a way that maximizes each class’s flexibility. The plan for
    the start-up is to develop four bicycles with a future expansion to include exotic
    bicycles and custom builds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Kitty opens her IDE and creates a class library project to hold her classes
    since she knows she’s probably going to use these in several different programs.
    She calls the class library `BumbleBikesLibrary` which you’ll find in the sample
    code for this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'She decides to start with an abstract class and to use inheritance to define
    her bicycle models for each of the four types of bicycles she intends to initially
    design and manufacture. *Figure 3.6* shows the result of her effort. This set
    of properties can be used to define nearly any type of bicycle:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The abstract bicycle model. ](img/B18605_Figure_4.6.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The abstract bicycle model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at these properties in more detail:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`ModelName`: The name of the model as it will appear on the company website.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Year`: The model year for the bicycle. All bicycle designs should be updated
    every 2 years to prevent the designs from becoming stale like MegaBikeCorp’s.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SerialNumber`: A unique identifier for each bicycle that rolls off the assembly
    line.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Color`: The color of the bicycle. To keep initial costs low, Kitty will define
    an enumeration with a limited set of colors for each model.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Geometry`: This refers to the frame configuration for the bicycle. All the
    bikes for the initial manufacturing run are either upright or recumbent geometries.
    This can be moved into an enumeration as well.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Suspension`: This refers to the type of shock absorbers used on the bicycle.
    Shocks are most important on mountain bikes, but you also find them on road bicycles,
    recumbents, and some cruisers. It could be argued that this property is only appropriate
    for a mountain bike subclass, but Kitty knows about “analysis paralysis.” Rather
    than trying to get the model perfect on the first go-around, she decides to put
    it in the superclass for now. She can always refactor it later when things become
    more concrete, or if she gets a whiff of smelly code structure.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BuildStatus`: Kitty knows her robotics control system needs to understand
    the current state of the bicycle build process, so she decides to include an enumerated
    property to hold this information.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Several properties can be expressed as an enumeration, which is a fixed collection.
    Back in the old days, we used “magic numbers” to represent finite lists. The programmers
    would assign an integer to each value. As an example, to represent a finite list
    of suspension types, we might be tempted to number them 0 through 3, since there
    are four possibilities. This made maintenance difficult because everyone had to
    remember what each number meant. Was it 0 for a full suspension? What was the
    code for a hardtail? Later, we wised up and defined constants for everything:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is better, but it isn’t very object-oriented. You wind up with dozens
    of lines of ugly constant definitions in all caps. You might be tempted to use
    an integer type to model them since you are presented with the opportunity to
    assign an arbitrary integer as a value. What will stop someone from setting it
    to 100 when the potential values are supposed to be from 0 to 3? We could write
    encapsulation logic to enforce our range of 0 to 3\. That’s all well and good,
    but we’d have to constantly alter the accessor logic every time we add a new suspension
    to the line-up. Thankfully, in C#, we have `<<Enumeration>>` tag at the top of
    the box. Our bicycle class uses four enumerations, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Four enumerations are defined to limit the options available
    for our abstract bicycle’s geometry, suspension, color, and current manufacturing
    status. Enumerations help us keep our object’s state clean, valid, and easy to
    read. ](img/B18605_Figure_4.7.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Four enumerations are defined to limit the options available for
    our abstract bicycle’s geometry, suspension, color, and current manufacturing
    status. Enumerations help us keep our object’s state clean, valid, and easy to
    read.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting into patterns, let’s begin by creating what we have diagrammed
    so far. First, Kitty will make the four enumerations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`SuspensionTypes`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BicycleGeometries`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BicyclePaintColors`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ManufacturingStatus`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the `BicycleGeometries` enumeration:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, she makes an `enum` for suspension types:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next comes the paint colors:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, Kitty makes an `enum` for manufacturing status codes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With those out of the way, let’s see what the `Bicycle` base class looks like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Kitty creates the `Bicycle` class as an abstract class, just as she did in the
    UML model. Note that the name of the class in *Figure 3.6* is *italicized*, indicating
    it is abstract. Next, she adds the properties. The UML model purposefully left
    out the access modifiers and types, leaving those as implementation details for
    the programmer to determine. In this case, as it is with many start-up projects,
    the architect and developer are the same person.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Kitty defines several of the properties as being protected because she intends
    to manipulate them from the subclasses. A few of the properties are marked `private`
    since it is appropriate to manipulate those at a higher level.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, she moves on to the constructor, which is the function that is run with
    instantiation using the `new` keyword:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Kitty sets the default values for each property within the constructor. The
    model name, for now, is empty. She’ll change that in the subclass. The serial
    number property is a generated GUID, which is a string that is guaranteed to always
    be unique. The `Year` property is set to the current year, and `BuildStatus` is
    set to the first status in the enumeration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to add the `Build` method. For now, the `Build` method will
    just print to the console to show the logic is working correctly. Eventually,
    this can be substituted for the more complex control logic for Phoebe’s robotic
    systems:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The abstract class is done! Next, Kitty needs to create the concrete subclasses
    for the bicycles they intend to build:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`RoadBike`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MountainBike`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Recumbent`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cruiser`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, she makes the `RoadBike` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `RoadBike` class inherits from `Bicycle` and the constructor sets the defaults
    for the class. The model name is `Hillcrest`, after the name of the street that
    runs West of Phoebe’s university campus. Road bikes typically lack shock absorbers,
    so she defines the suspension type as `Hardtail`. The initial models only come
    in one color, and this one comes in blue. Since this isn’t a recumbent, the geometry
    is set to `Upright`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'With Phoebe’s favorite road bike out of the way, Kitty sets to modeling her
    favorite – the mountain bike:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Kitty names the mountain bike after the Palo Duro Canyon located in the Texas
    panhandle. Few people know that the Palo Duro Canyon is the second-largest canyon
    in the United States, after the Grand Canyon. Palo Duro Canyon is home to some
    of the best mountain biking in Texas. She wants an aggressive look for her design,
    so she goes with `Black` for the color. Naturally, not being one to skimp, she
    creates the design with full suspension – shocks on the front and rear of the
    bicycle to handle any obstacle the trail might present. As mentioned previously,
    given it isn’t recumbent, the geometry is defined as `Upright`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `Recumbent` bicycle class needs to be created:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Kitty decides to call this bike *Big Bend*. The Big Bend area is a desert with
    a mountain range, which has a host of mountain biking opportunities. However,
    there are great stretches of paved and unpaved roads that are more or less straight.
    Recumbents do well in those environments as their design allows riders to go faster
    and farther without getting tired. The recumbents are also pretty good at pulling
    trailers. A person who desires to camp can carry adequate water and supplies.
    Since the bicycle’s namesake has paved and unpaved roads, Kitty opts for a front
    suspension. Recumbents already have a nice seat, so rear suspension doesn’t add
    many benefits, and it would make the bicycle more expensive. Naturally, the geometry
    is set to `Recumbent`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The final bicycle is the cruiser:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Kitty names this bicycle the *Galveston Cruiser* after fondly remembering her
    seaside vacations with her family. Galveston is a medium-sized city on the Gulf
    of Mexico. Galveston has beaches, a pier for commercial and vacation cruise ships,
    and a lively historical district called *The Strand*. The Strand is loaded with
    one-of-a-kind shops, cafes, bars, museums, and fun activities for tourists. Parking
    at the Strand is expensive, and often difficult to find. Galveston’s Strand is
    the perfect place to ride a cruiser, aside from the less known streets of Alpine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: No pattern implementation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kitty is on a roll! You know how it gets. She knocked out the enumerations,
    base class, and subclasses in nary an hour. She’s seriously *cruising* along and
    she doesn’t want to lose velocity. Kitty gives in to the temptation to write this
    code for the final implementation of the main entry point for the program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We take in an argument from the command-line program and use that to determine
    what to make. If a string was passed in, the length of `args` will be greater
    than zero and we can do our thing. Otherwise, we can admonish our foolish users
    for thinking our software can read their minds:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s a good idea to trim and normalize your command-line input. This means
    we ignore extra spaces in front of and after the argument. We ignore the case
    by forcing everything to either upper or lowercase so that we can compare the
    input with our expected values. The comparison works regardless of whether the
    user passed in *mountainbike*, *MOUNTAINBIKE*, or even *mOuNtAiNbIkE*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next comes a `switch` statement based on the input. The input determines what
    to build and returns the corresponding class instance:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the user passes an argument that we haven’t accounted for in the switch,
    such as `MotorCycle` or `PeanutButter`, we write and throw an exception:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If no arguments were passed into the command-line program, we show an error
    message instructing the user to supply the required argument:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Effectively, Kitty is taking a command-line argument and using the software’s
    main entry point, `Program.cs`, as the class that will instantiate the correct
    bicycle type. She tries it out and it works! Kitty has cleverly leveraged Liskov
    substitution by using the abstract base class as her type for the `bikeToBuild`
    variable, which allows her to instantiate the appropriate subclass based on what
    kind of bike she wants to build. Kitty would not be able to do that if she was
    working at MegaBikeCorp. She would probably have a pointy-haired boss who would
    tell her to clean up the code and ship it. Thankfully, she’s in business for herself
    as a nagging voice in the back of her mind decries, “*You can do better.*”
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Kitty’s first implementation can be found in the `NoPattern` project within
    this chapter’s sample source code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The Simple Factory pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kitty decides to do a little research on patterns. She wasn’t a computer science
    major in college and had only heard of patterns in her coding class. Kitty looks
    around and finds some blog articles on something called **the Simple Factory pattern**.
    Perfect, she thinks. This being her first coding project since college, and since
    she has a lot *riding* on her code (see what I did there?), she decides that something
    with *simple* right there in the name is a good place to start.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: According to the blogs, all she has to do is move her instantiation logic into
    its own class, called a **factory class**. This is done, say the articles, to
    decouple the instantiation logic from the main program. This should get her closer
    to honoring the open-closed principle and should make her code more flexible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'She returns to her IDE and adds a class called `SimpleBicycleFactory` and moves
    her instantiation logic there. The logic is the same as that shown previously:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, Kitty refactors her `Program.cs` file to use the simple factory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the different part – Kitty uses the `SimpleBicycleFactory` class instead
    of directly running a `switch` statement:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A refactor, by definition, means you are improving the structure or performance
    of your code without introducing any new features. Kitty has accomplished this
    by making her code a little more elegant.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When the logic is free-range in the `Program.cs` file, it is locked into being
    used in only that program. Kitty wisely realizes that she and, undoubtedly, Phoebe
    will want to create other programs that can use the creation logic. Encapsulating
    the logic into a class is an obvious improvement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Kitty, before closing her laptop for the evening, notices a post on social media
    from her programming professor. She asks how he’s been and while catching up,
    she mentions her code project. The prof says he’d love to see it, so she sends
    him a GitHub link.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The code Kitty’s professor is going to review can be found in the `SimpleFactoryPattern`
    project within this chapter’s sample source code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The Factory Method pattern
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kitty’s old professor looks at the code and tells her this newer code is an
    improvement, but she isn’t using a pattern. The simple factory is classified as
    a **programming idiom**. Idioms are like patterns, in that they occur frequently.
    You recognize them when you see one, but they haven’t fully realized any solutions
    to common problems. Perhaps the most famous programming idiom ever devised was
    created in Kernighan and Ritchie’s book titled *The C Programming Language*, also
    known as *The K&R book*. It was in this book we saw our very first *Hello, World*
    program. *Hello, World* is an idiom. It usually serves as the first few lines
    of code you try when you are learning a new language. It doesn’t solve any industrial-grade
    problems by encouraging flexibility and code reuse.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitty realized she’d seen this idiom in her IDE of choice for C#, JetBrains
    *Rider*. When you create a console application, like the one she’s been working
    on, the first thing you see is this code , which is generated by the IDE as a
    starting point for the project:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I have included an example of a `Hello,` `World` program. You’ll find it in
    the `HelloWorld` project, located within the chapter’s source code. Yes, I did
    include a `Hello, World` program because I’m all about attention to detail. Now,
    back to the story.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The next day, Kitty sets herself to fully researching the creational patterns.
    She wanted to do this the right way. After some reading, Kitty found several patterns
    called factory patterns:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The simple factory, which we’ve established isn’t a pattern, but it is often
    mistaken for one.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory pattern, which is a mild improvement over the simple factory.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory Method pattern, which truly abstracts the creation process when
    you have a variety of object types to instantiate.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Abstract Factory pattern, which, for now, seems more complex than necessary
    since it deals with creating groups of objects.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kitty settled on what she thought would be the perfect pattern for her problem:
    **the Factory Method pattern**. She also thought it ironic that the starting point
    for her software design was working with a factory pattern, given she was modeling
    what would one day be a physical factory. The factory patterns are so-called because
    they take a set of inputs and produce a concrete object as output. The simple
    factory accomplished this at a superficial level, but there are some problems
    with relying on the idiom in place of the real pattern. The idiom isn’t as flexible
    as it could be. Bumble Bikes Inc. is going to have two factory locations making
    different types of bicycles. The simple factory can create any bicycle, but at
    the same time, it’s locked into making all four. Relate that to a real factory
    and you can see it might be wasteful to require the factory to make every kind
    of bicycle, instead of the two that it will be making.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'In our software design, the factory shouldn’t have any knowledge of what it
    is going to create. It should be flexible enough to make any kind of bicycle.
    We can structure this so that we can create a factory capable of producing a subset
    of all the subclasses. The subclasses decide what can and should be made concrete.
    We can diagram the generic factory method pattern as so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – A generic diagram of the Factory Method pattern. ](img/B18605_Figure_4.8.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – A generic diagram of the Factory Method pattern.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review each part of the diagram based on the numbers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The Factory Method pattern starts with an interface that defines a common behavior
    or set of behaviors. In general, using interfaces is more flexible than using
    a base class because you aren’t limited by the inheritance rules in C. This is
    to say that any child class in C# may have only one parent class. Multiple class
    inheritance is not supported. In the case of interfaces, any class may implement
    as many different interfaces as are needed.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we discuss the Factory Method pattern, we call the objects the factory
    creates `products`. These are the concrete products the factory will produce.
    They will all implement the common product interface. In practice, you don’t need
    to stick with the same names, as shown in the preceding diagram.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A factory method has a `Creator` class that houses the factory method itself.
    The Factory Method is coded to return the `Product` interface so that it can return
    any product that implements that interface. It isn’t tied to a particular abstract
    base class, as was the case with Kitty’s original refactor. These creators are
    abstract and are meant to be overridden in concrete creator subclasses. This is
    what provides the flexibility we need with our bicycle factory.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concrete creators provide the actual concrete classes. All your creation logic
    will be here.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s remember the specifics of Kitty and Phoebe’s plan. It calls for two factories
    – one in Dallas to make road and recumbent bicycles and another in Alpine to make
    mountain and cruiser bicycles. Kitty heads to her whiteboard and makes her version
    of the preceding diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Kitty’s whiteboard drawing of her Factory Method pattern design
    idea. ](img/B18605_Figure_4.9.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Kitty’s whiteboard drawing of her Factory Method pattern design
    idea.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty good! Kitty decides to move a lot of what is in her abstract
    bicycle class into an interface she calls `IBicycle`. This doesn’t mean she should
    throw out the abstract class, but it’s easy to have the abstract class implement
    the interface. Once she does that, she can pass the interface around, which is
    more flexible than using the base class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The abstract bicycle base class won’t change, other than implementing the `IBicycle`
    interface. None of the bicycle subclasses change at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: She does need to add some creator classes. She’ll need to create an abstract
    `BicycleCreator` class, which will be subclassed by as many concrete creation
    classes as she might need.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This fits the design problem because we need to model two actual factories.
    One is called `DallasCreator`, which will make road bikes and recumbent bikes,
    and the other is called `AlpineCreator`, which will produce mountain bikes and
    cruisers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Our design is closed for modification. We never need to mess with the base classes
    and interface again. However, the design is also open for extension. As the line
    of products expands in the future, we can continue to add factories and each factory
    can specialize in any set of products. New bikes can be added by simply creating
    new subclasses of `Bicycle`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing left but the typing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitty adds the `IBicycle` interface to her `class` library:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, she modifies the `Bicycle` base class. Defining non-public members is
    not possible in an interface. C# generally requires properties and methods defined
    in an interface to be `public`. Non-public members in an interface don’t make
    sense. They would be housing implementation details, not something for public
    consumption, which is the point of an interface. The bottom line is that if we
    want to require anything on the `Bicycle` base class, we will need to change the
    access modifiers to `public`. We usually want to avoid changing classes once they
    are published in production. At this stage, we haven’t done that yet. We can either
    change the access modifiers or avoid defining those elements in the interface
    and just have the `build` function. Kitty decides on the more complete version
    of the interface she’s already typed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need our creator classes. Kitty starts with the abstract class, which
    she’ll call `BicycleCreator`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next comes the two concrete creator classes, beginning with `DallasCreator`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is followed by the `AlpineCreator` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Kitty needs a quick test, so she adds this code to `Program.cs`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now is the moment of truth. Kitty hits the run button in the IDE and moves
    to the edge of her seat as her code compiles:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Booyah! It works! The Factory Method pattern is running in
    Kitty’s code! ](img/B18605_Figure_4.10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Booyah! It works! The Factory Method pattern is running in Kitty’s
    code!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Kitty commits and pushes her code, which you can review in the `FactoryMethodExample`
    project within the source code for this chapter. Don’t forget that the `IBicycle`
    interface was added to the `BumbleBikesLibrary` project.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory pattern
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After Kitty finishes her initial design using the factory method, Phoebe checks
    Kitty’s work on GitHub. Phoebe has managed to finish the tooling that creates
    the frames and she’s hard at work on some of the other parts that go into making
    a bicycle.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: “*Kitty!,*” Phoebe says, “*This code will allow us to make a bicycle object
    but that’s a little bit too abstract. A bicycle is made of lots of different parts.*”
    After a long discussion, the two decided to concentrate on manufacturing the bicycle
    frame and the handlebars for each bicycle type. The other parts, such as the wheels,
    tires, brakes, and gears, can be outsourced for the initial production of the
    bicycles.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: It occurs to Phoebe that these parts can be made in families. The road bike
    uses dropped handlebars, while mountain bikes use a flat handlebar design. You
    shouldn’t interchange these parts. Flat handlebars on a road bike create a new
    class of bicycle called a *gravel bike* or *hybrid*. We’re not interested in changing
    our product line-up yet. Drop handlebars on a mountain bike make no sense at all
    and are dangerous. It makes sense for the physical bicycle factory to mirror the
    software pattern. The sisters conclude a better fit might be to use the **Abstract
    Factory pattern**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This is a pattern a lot of people get wrong. It is a common misconception that
    the Abstract Factory pattern simply involves making your factory class abstract.
    Not so! The Abstract Factory pattern is designed to create objects that are related
    and to decouple those objects from the client’s dependency on a concrete type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Our bicycle design consists of four families of bicycles:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Road bicycles (the Hillcrest)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mountain bicycles (The Palo Duro Canyon Ranger)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recumbent bicycles (The Big Bend)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cruiser bicycles (The Galveston Cruiser)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type has a particular type of frame, as well as a different design for
    handlebars. We can say we will be making four *families* of bicycle components.
    When you encounter a problem that involves families of related objects, you should
    automatically think about the abstract factory pattern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'A second benefit of the abstract factory pattern is that it decouples the client’s
    dependency on any particular concrete object. Let’s look at the following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The Abstract Factory Pattern. ](img/B18605_Figure_4.11.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – The Abstract Factory Pattern.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'I have drawn the parts going from right to left, beginning with the client:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The client is whatever code consumes the objects created by the Abstract Factory.
    Here, I’m showing a private reference to an Abstract Factory as a property on
    the client object.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client is dependent on the `AbstractFactory` interface. This interface defines
    two methods. Normally, I don’t put the return types in the UML, but in this case,
    it is truly important. The interface is going to refer to a pair of abstract classes.
    Maybe now you’re starting to see where this is going. The final product created
    by the Abstract Factory will be a concrete class that inherits from one of these
    abstract classes.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two concrete factories are presented for each family of products. Our requirements
    have four families of products, but this diagram only shows two to keep things
    simple. You can add as many concrete factories as you need.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two abstract classes are used to define two types of objects, independent of
    the family for the concrete object.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final concrete products inherit from the abstract products. Phoebe and Kitty
    can model more specifics into their process because they are not just making bicycles
    – they are making the handlebars too. Each physical factory should make the frames
    and handlebars that are needed.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The sisters head to the whiteboard and draw out the Abstract Factory pattern
    design. They will limit their diagramming to road bikes and mountain bikes to
    keep things simple:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13  – Phoebe and Kitty’s whiteboard design using the Abstract Factory
    pattern. ](img/B18605_Figure_4.12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Phoebe and Kitty’s whiteboard design using the Abstract Factory
    pattern.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The client in this program is just the `Program.cs` file created by your IDE
    when you created a command-line project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The diagram says `Program.cs` and depends on an object created from `IBicycleFactory`.
    Note that the arrowheads are different. These are significant in UML. The closed
    arrowhead on a solid line indicates inheritance. A closed arrowhead on a dashed
    line indicates a realization of an interface. The open arrowhead on a closed line
    indicates an association. The client depends on something that follows `IBicycleFactory`.
    The `Program.cs` class has a private field to hold an instance of an object that
    realizes this interface, which can be either `RoadBicycleFactory` or `MountainBicycleFactory`,
    as per the preceding diagram.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting here that Phoebe drew `IBicyleFactory` as a literal interface.
    The code-level understanding of an interface may be either a literal interface
    or an abstract class because either can serve to define the structure an object
    must take.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We have concrete classes that realize the `IBicycleFactory` interface called
    `RoadBicycleFactory` and `MountainBicycleFactory`, respectively. Each concrete
    factory is responsible for creating a family of objects. In our case, the families
    are `Road` and `Mountain`. `RoadBicycleFactory` can create `RoadBicycleFrame`
    and `RoadBicycleHandlebars` based on the dependency line, but you can see that
    `RoadBicycleFrame` and `RoadBicycleHandlebars` inherit from the `BicycleFrame`
    and `BicycleHandlebars` abstract classes respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: When the client requests a bicycle frame and a set of handlebars, it can reference
    the abstract classes. Owing to Liskov substitution, the client doesn’t need to
    be strictly coupled to any concrete class. This makes our client very flexible.
    As our bicycle family line-up changes, we won’t need to alter the client because
    the client does not know what the factory is sending back. The client only knows
    it has methods called `CreateBicycleFrame` and `CreateBicycleHandlebars`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Phoebe makes a branch on the repository. She knows you should always work in
    a branch and goes to work creating the code. She begins with the `IBicycleFactory`
    interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the first two `using` statements. Since we are starting to break the bicycle
    into components, Kitty and Phoebe decided to refactor those components into a
    `BicycleComponents` namespace within `BumbleBikesLibrary`. The refactor isn’t
    particularly relevant to patterns – it’s just a refactor to get a little bit more
    organized. You can find the components in BumbleBikesLibrary in the GitHub repository
    for this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The sisters are coding by the book. Everything is typed into an interface for
    flexibility. We’re adding methods to handle creating frames and handlebars, two
    related classes specified by the interfaces. Naturally, we could make more. There
    are more component classes in the `BicycleComponents` namespace. We’re keeping
    it to two here to keep things simple. If you’d like to practice, see whether you
    can add the other components, such as seats, drivetrain, and brakes, to the pattern
    code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Kitty and Phoebe need to work in the concrete factories. These classes
    will only be used in this project, so you’ll find them in the `BicycleAbstractFactoryExample`
    project in the book’s sample source on GitHub. Remember, an *abstraction* can
    refer to an interface or an *abstract* class. In this case, the abstract part
    of the *abstract factory* is this interface. Kitty takes on writing `MountainBicycleFactory`
    based on the `IBicycleFactory` interface:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The concrete factory is responsible for creating the specific objects we need
    relative to the object family we’re creating. In this case, Kitty is making the
    parts for a mountain bike, so all the parts being returned are specific to that
    family. More product families can be added without modifying the abstract factory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what Phoebe wrote for the `RoadBicycleFactory` class, which also extends
    `IBicycleFactory`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now have an Abstract Factory pattern in place making two possible components,
    in two possible product families. Let’s look at the client. Phoebe writes that
    part:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We made a road bike using `RoadBikeFactory`! The key here is the use of the
    interface as the factory type. Coding this way makes it possible to change the
    factory without relying on concrete factory classes directly. You can see the
    console output showing the results of the operation. Phoebe continues and writes
    some code to generate a mountain bike using `MountainBikeFactory`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The same process could be repeated for any new bicycle type that Phoebe and
    Kitty could ever dream of making.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The Builder pattern
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phoebe finishes her implementation of the Abstract Factory and goes back to
    designing more on the robotics for the bicycle factory. How many times have you
    thought some job or project was simple, only to find out that once you got into
    the thick of working on it, things involved more than you realized?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Phoebe and Kitty are new to engineering, design, and software development. Phoebe’s
    unique understanding of the design problems surrounding building an automated
    factory solidifies over time. She realizes that building a bicycle is more complicated
    than she had first realized. The sisters built their prototypes by hand. They
    were able to use wood for the frames and off-the-shelf parts for everything else.
    They are now committed to making their own frames and handlebars using a lightweight
    aluminum alloy.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Phoebe realizes the frame is the hard part. The other components, such as the
    wheels, brakes, and drivetrain, as well as the handlebars, could easily be built
    in-house as part of the automated process.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, this increases the complexity of the machinery and the software that
    runs it. Phoebe calls Kitty.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: “*Hey sis, how is the Abstract Factory pattern treating you?*” Kitty asks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: “*It’s fine, but I’ve been thinking,*” Phoebe replies.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: “*Uh oh. Every time you do that Daddy’s credit card gets a workout. What is
    your idea?*” Kitty asks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Phoebe told Kitty about her idea to make all the parts from the same aluminum
    alloy. “*Some of the parts will need to be reinforced, but the result will be
    a lighter bicycle that costs less to build than we initially thought,*” said Phoebe.
    Kitty loved the idea. The sisters were excited before, but now they are fired
    up. Phoebe says, “*I’ll get Dad’s credit card and source the aluminum I need for
    the first few bicycles.*” Kitty replies “*Great. While you’re doing that, I’ll
    incorporate your ideas into the control software. You merged your branch into
    main, right?*”
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Kitty pulls the latest code from *GitHub* and starts a new branch. She starts
    thinking hard about how to accomplish coding a process that will build an entire
    bicycle per any possible specification a customer might have. The sisters have
    a set of four bicycles with constrained options for the first release. Kitty doesn’t
    want to lock her thinking and her software design into building just those four
    bicycles. That would make it a stovepipe system. Kitty heads to the whiteboard.
    She realizes that she might have to disregard the progress she’s made so far in
    the Abstract Factory pattern. A different pattern might not simply be a direct
    evolution of what they’ve done so far. She knows the elemental structures will
    remain the same. A bicycle will always need a frame, seat, handlebars, wheels,
    brakes, and a drivetrain.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The new problem entails creating a complex object. The construction will require
    multiple steps instead of a simple `BuildBicycle` method that creates the frame
    and handlebars, as she had in the earlier designs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Deep in thought, her reverie is broken by a loud buzzing from her phone. It’s
    sitting on her metal worktable and the vibration, indicating she’s received a
    text, nearly bounced a small pile of screws and some tools right off the edge
    of the table:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – She checks the screen. There’s a text from her father. ](img/B18605_Figure_4.15_NEW.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – She checks the screen. There’s a text from her father.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Uh - oh. Kitty decides to rip off the proverbial band-aid and calls her father.
    Maybe her excitement over the latest developments will cushion the blow. “*Daddy
    will understand,*” she says quietly to herself as if she is quietly trying to
    convince herself out loud.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Kitty and Phoebe’s father was a software engineer. He’d lost his job a few years
    ago because he was always talking about crazy conspiracy theories on social media.
    He decided to just retire, and after a falling out with his extended family, Kitty
    and Phoebe’s parents moved to a small town in Southern Oklahoma, just north of
    the Texas border where the roads are unpaved and the internet access is non-existent.
    This is just the way he likes it. Kitty dials the number.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: When he answered, her father’s language was, shall we say, colorful. This wasn’t
    the first time Phoebe had run up a bill. She had once charged over a thousand
    dollars in 1 day. Most teenage girls run up a bill traveling or shopping. Phoebe’s
    bill was from several reputable industrial suppliers, a tool and die shop, and
    a peanut butter factory. She never came clean on what she was up to, but shortly
    after that, she got into engineering school and the incident was all but forgotten.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Kitty talks him down from his anger and tells him about what’s going on. “*You
    should look at* **the Builder pattern***,*” he says. “*Yeah, I once wrote a book
    on patterns and I remember this one. It is used to make complex objects using
    a flexible set of steps. It sounds like that’s what you need. Oh, and y’all are
    gonna pay me back! I want stock in your company and the first bicycle you two
    build.*”
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: “*Of course, Daddy,*” Kitty said in her sweetest voice, normally reserved for
    when she wanted ice cream but had already been told, “*No.*” She decided not to
    admonish him for not telling her he had written a book on patterns. Her father
    had taught the sisters to code when Phoebe was 11 and Kitty was 12\. He had published
    a lot of books and videos over the years. Of course, he had done one on patterns.
    At that moment, Kitty’s call went to static. It was hard to hear anything. Her
    father was still speaking to her, but she only caught a few words. Something about
    alternate timelines and temporal recursion. “*He says the silliest things sometimes.
    He’s probably been watching old episodes of Doctor Who again,*” she thought. The
    call dropped.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitty shrugged and set to researching the Builder pattern. Her father’s book
    had been out of print for years, but it was a runaway international bestseller,
    so she was able to find a few of the diagrams among the many more recent books
    that cited his:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The builder pattern consists of a builder interface, a director
    to control the creation process, and concrete builders based on the builder interface
    to produce specific products. ](img/B18605_Figure_4.13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – The builder pattern consists of a builder interface, a director
    to control the creation process, and concrete builders based on the builder interface
    to produce specific products.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at this diagram in more detail:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: There are two important parts to the Builder pattern. The first is the IB. Remember,
    this can be a literal interface or an abstract class. I’ll stick to using a true
    interface for the sake of flexibility. The `Builder` interface defines all the
    methods that will be in a set of concrete builder classes. The second part that
    you’ll always find in the Builder pattern is the `Director` class.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Director class` is created, which contains logic that defines the creation
    process in a step-by-step fashion.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A set of concrete builder classes defines each type of object that can be created.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Different products come out of the concrete builder classes, depending on the
    logic contained within the director.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Armed with this new knowledge, Kitty goes back to her whiteboard:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Kitty’s whiteboard implementation of the builder pattern. ](img/B18605_Figure_4.14.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Kitty’s whiteboard implementation of the builder pattern.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Kitty was excited about this one. Having gone through a few different patterns,
    this one felt like it was the best representation of what the sisters are trying
    to accomplish. You can find this code in the `BicycleBuilderExample` project within
    this chapter’s GitHub repository.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitty starts by creating an abstraction for what the builders will be producing
    – that is, the product. She creates an interface called `IBicycleProduct`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The interface contains everything needed to make a complete bicycle. We have
    something of a design luxury at play here. All the bicycles follow the same interface.
    We no longer need to think about a road bike or a mountain bike. A road bike is
    simply a collection of parts:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: A road bike frame
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hardtail suspension (that is, no suspension at all)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Road bike handlebars (that is, dropped curved handlebars)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A road bike drive train (that is, a normal length chain and a group set with
    3 front and 8 rear cogs for a total of 24 speeds)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caliper brakes
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A standard, cheap, very uncomfortable seat
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phoebe and Kitty learned about seats during their internship. Bicycle manufacturers
    know that seats are a very personal choice and no two riders will pick the same
    seat if they are given a choice. They all sell bicycles with cheap, uncomfortable
    seats and offer separate products to upgrade the seat to the rider’s preference.
    This lowers the build cost for the bicycle and gives their dealers something to
    upcharge, as well as offering seat installation as a service.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitty codes a generic bicycle object for the builder called `BicycleProduct`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This class is just an implementation of the interface, plus a large `ToString()`override
    that we’re using as the meat of our sample code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Kitty creates the `IBicycleBuilder` interface, which will define the
    various builders for the bicycle lines:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The interface defines what must be in a `builder` class. The next piece of
    the puzzle is the `Director` class. The classical implementation of the `Builder`
    pattern will always have one of these. In our case, we could skip this part because
    all of our bicycles fit the same interface. A director can create anything, given
    a builder. The director’s job is to call the methods in the builder according
    to any business logic required and to return the product created by the builder.
    In our case, every product has the same set of properties, and the builders all
    have the same methods. Just realize that if your builders don’t all follow the
    same interface, it’s okay to have a lot more logic in your director to figure
    out what to do with it. The point of the director is to run the build methods
    in the builder in the right order. Sometimes, that entails a lot more logic than
    what we have here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Kitty starts with a private field to hold a reference to the builder she’ll
    be working with. You can pass in anything that extends the `IBicycleBuilder` interface.
    The constructor sets the actual builder object that is passed in. Next, she makes
    a method that allows us to change the builder without exposing it directly:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Lastly, she creates a `Make` method per her UML diagram. It’s the `Make` method’s
    job to run the build steps in the right order. Kitty has this method follow the
    same process the robots will use. They’d start with a frame and then add parts
    to it. Nobody would think to start building a bicycle around the seat or the gears.
    Here, we can see a logical build process for a bicycle that starts with the bigger
    and more important parts, followed by smaller parts that attach to the larger
    ones:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, Kitty creates the concrete builders for mountain and road bikes. Naturally,
    she created the code for the other bicycle types, but here, we’ll keep things
    short so that you don’t have to sort through so much code to see the pattern.
    Here’s the `RoadBikeBuilder` class based on the `IBicycleBuilder` class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Kitty creates a private field called `_bicycle` to hold the product to be built
    by the `Director` class. We have a public constructor and a `Reset()` method that
    sets the `_bicycle` field to a new bicycle based on the `BicycleProduct` class:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The same builders can be made for mountain, recumbent, and cruiser bikes. They
    look the same, but naturally, they use different parts as appropriate. The builder
    steps (methods) understand the parts needed to build, while the director understands
    the order needed for the steps (methods) to be called.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The client code that’s used to call these builders would look like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s where all the hard work pays off. You can build any bicycle with three
    lines of code. First, make the builder. Then, make a director, if you don’t have
    one yet, and pass in the builder you just created. Then, call the `Make()` method.
    The result is a perfectly built product:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Would you rather have a mountain bike? That’s easy!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can make recumbents and cruisers just as easily, but in the interest of saving
    trees, I’ll leave that to your imagination. If you’re like me and have a weak
    imagination, the sample code for this chapter contains the builder for creating
    all four types.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Kitty is delighted with the way things turned out. She has a software architecture
    that is closed for modification but open for extension. She has leveraged interfaces
    and abstract classes wisely, so Kitty is ready for the next challenge the world
    of robotic bicycle manufacturing might have for her.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The Object Pool pattern
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back at the factory, Phoebe has made progress on the robotics. She has developed
    a mobile robotic arm to handle the welding during the manufacturing process. She
    was hoping to build 30 of these arms to allow for maximum factory output, but
    her father’s credit card mysteriously stopped working. This puzzled Phoebe. Could
    her sister have told on her, leading her father to block the card from further
    purchases? “*She wouldn’t do that!*” Phoebe thought, but as soon as she said it,
    she knew that’s exactly what had happened. She considered calling her sister out
    on it but decided to focus on her father’s words:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: “*A good engineer is someone who makes the best product possible given constraints
    of time, materials, people, and budget with a minimum of complaining.*”
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the hardest. Most engineers complain, “*If I’d gotten the
    budget, I’d asked for…*” or “*If only I had another year…*” It’s an ego thing.
    Phoebe swallows hers and decides she must figure out how to make do with just
    the 10 robot arms she was able to build. Her arm design looks a little like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Phoebe’s design for a robotic arm to handle the welding on
    the bicycle frames. ](img/B18605_Figure_4.15.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Phoebe’s design for a robotic arm to handle the welding on the
    bicycle frames.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Given that the arms are mobile, Phoebe decides it is possible to have the arms
    move between welding projects as needed. As the bicycles come through the line,
    only a few will need welding at any given point in time. Phoebe thought, “*Running
    with 30 arms would have been nice, but honestly, they’d be dormant most of the
    time. This will be better. I’m forced to be more efficient.*”
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The pool of 10 arms sit on a track where they move to any of the assembly lines
    at a moment’s notice. As a weld is needed, Kitty’s software will move the arm
    to where it’s required. After the weld is finished, the arm can return to the
    pool and wait until it’s needed again. If several welders are needed on different
    projects, one arm will come out of the pool and do its work, then return. So long
    as we don’t need more than 10 arms at a time, we’re fine. If we do, the eleventh
    job will have to wait until one of the arms is available. Phoebe is happy with
    this because creating the arms is expensive, and as she’s discovered, she only
    needs a few. She can add more arms to the pool as the business expands.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Phoebe has unwittingly stumbled onto the **O****bject Pool pattern**. This pattern
    is used to create computationally expensive objects, and as such, they tend to
    slow software performance to a crawl. The most obvious case is working with relational
    databases. This is something every software developer does at some point, and
    for many of us, this is a skill we rely on daily.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiating and connecting to a database is computationally costly and time-consuming.
    Sure, it takes maybe 100 milliseconds, but most relational databases are designed
    to handle millions of transactions every hour. When your software is under load
    at scale, 100 milliseconds is an eternity. Every commercially viable database
    has a driver that handles connection pooling for you. The driver creates a pool
    of open database connections. Just like with the robot arms, your software takes
    connections from the pool, runs queries, and then when the connection is closed
    (which should always be done as quickly as is feasible) the open connection, instead
    of being truly closed, is returned to the pool and is available for another process
    in your running program. Check out the following generic diagram:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – The object pool pattern creates an object that manages a collection
    of other objects. The client requests objects from the pool to use them and then
    releases them when it’s finished. ](img/B18605_Figure_4.16.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – The object pool pattern creates an object that manages a collection
    of other objects. The client requests objects from the pool to use them and then
    releases them when it’s finished.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: There is a private collection called `PooledObjects` that holds the objects
    in the pool. The client, after gaining access to the object pool, can request
    objects from the pool using the `GetPooledObject` method. Once it is finished,
    the borrowed object is returned to the pool. If the pool is ever empty, a subsequent
    request to `GetInstance` will create a new object if it can. If it can’t, it is
    common for an implementation to wait until an object is returned to the pool.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Phoebe decides to add a pool to control access to her limited number of robot
    arms:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Phoebe’s design for an object pool to control a limited number
    of available robot arms on her assembly line. ](img/B18605_Figure_4.17.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Phoebe’s design for an object pool to control a limited number
    of available robot arms on her assembly line.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Phoebe writes the code for the diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Phoebe only has 10 robot arms available, but she knows she’ll have more in
    the future. She makes a private variable here and initializes it to `10`. Next,
    she makes a constructor, but normally, a constructor would just handle creating
    the initialized object. The UML diagram contains an entry for a `Reset()` method,
    which does the same thing. She’ll write that in a moment but puts it in place
    within the constructor. The IDE protests, but she knows it’ll all work out when
    she has finished:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The most important part of the object pool is some sort of collection to hold
    the pooled objects. Phoebe opted for a `List` of `WeldingArm` objects. This will
    be initialized in the `Reset()`method we mentioned a moment ago, though Phoebe
    hasn’t created it yet:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Phoebe wants to be able to change the max size of the pool so that she’s able
    to build more robot arms. She can increase the pool size or even decrease it if
    the arms are out of the pool for servicing:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Phoebe decides it would be nice to have a way to see how many arms are in the
    pool:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, the fabled `Reset()` method we’ve been promised. It looks like code
    you’d put in a constructor. Phoebe wants a way to reset the pool if she needs
    to. Since being DRY is a good thing and calling a constructor with anything besides
    the `new` keyword seems weird and unnatural, Phoebe flips things around and puts
    the logic here and then calls it from wherever it’s needed, including the constructor.
    This drives my IDE crazy. It thinks I have a non-nullable list that is never initialized.
    That’s not true, but the automation in the IDE isn’t savvy enough to see that.
    The code itself initializes the list and then fills it with as many arms as indicated
    by the `MaxSize` property:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need a way to get arms from the pool. The following method checks whether
    there are any arms available, and if there are, it retrieves the first one in
    the pool. If there aren’t any arms, we throw an error:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In a real program, you would probably just return a new object and pay the
    performance penalty. In this case, we are physically constrained. We could implement
    some concurrent code that watches for an available arm as it becomes free, which
    directs to a new job, but that’s getting outside the scope of a pattern demonstration.
    Phoebe needs a way to return her arms to the pool. The arm stores the location
    of its last weld. Phoebe, to avoid confusion, decides to reset it to zero. This
    will indicate the arm isn’t working on anything and that it’s in the pool, ready
    for assignment:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Wrapping things up, Phoebe writes a small test program in `Program.cs`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As a tool, the Object Pool can seriously speed up most software because usually,
    you only think to use it when an object takes a lot of time or resources to create.
    The pool creates the objects in advance, and hopefully, never again.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: “*BUT!*” Phoebe says aloud to herself, “*this seems like it would work best
    if you could guarantee only one pool was in use at a time.*” She’s right. Concerning
    the robot arms, it wouldn’t do to have the software simply create more instances
    of the arm. It stands to reason that eventually, the control software should be
    multithreaded. You can’t have multiple threads creating their own pool. Instantiating
    additional pools can’t magically generate more resources in the real world. “*If
    only there were a way to make sure the object pool is only ever instantiated once
    per program run,*” Phoebe thinks. She’d keep working, but it’s taco night, so
    she shuts down her laptop and prepares herself for dinner. You can find Phoebe’s
    source for the object pool pattern in this chapter’s source code in the `ObjectPoolExample`
    project.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That night, perhaps inspired by her Object Pool singularity problem, perhaps
    by the tacos, or perhaps both, Phoebe had a strange dream. She was a judge dressed
    in long flowing black robes sitting high on her bench in a courtroom. A trial
    was in progress. The defendant was one Sing Elton. He was a well-dressed middle-aged
    gentleman who sat quietly behind a large elaborately carved oaken table next to
    his counsel.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The courtroom clerk cleared her throat and spoke without inflection into a microphone.
    “*The defendant, Sing Elton, stands accused of impersonating a beneficial design
    pattern and is, in fact, an antipattern.*”
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: There was a collective gasp from half of the gallery. It came from the back
    of the courtroom, which Phoebe only now notices. The room is filled with software
    developers, all of whom are clad in cargo shorts, Birkenstock sandals, and $300
    replicas of vintage *Metallica* T-shirts. Phoebe bangs her gavel and shouts, “*ORDER
    IN THE COURT!*” She had seen that in a movie once and had always wanted to do
    that. With the gallery quietened, the clerk continued without looking up from
    her computer screen. “*These are very serious charges, Mr. Elton; how do you plead*?”
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Elton’s counsel, a wiry nervous man in an inexpensive blue suit stood and in
    a squeaky voice said, “*Not guilty!*”
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The clerk entered the plea and the trial began. The prosecutor rose for his
    opening remarks, delivered in a slow Southern drawl reminiscent of a cowboy Western
    movie. “*Your honor, we intend to show beyond a reasonable doubt that Sing Elton
    is not a pattern as he represents himself but is an antipattern. He is openly
    a member of an outlaw coding organization called The Golden Hammers.*” The prosecutor
    sat down, flashing a wry smile with far too many teeth to be human. Do you know
    why sharks never attack attorneys? Professional courtesy.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The defense called Mr. Elton to the stand and as he questioned him, the defense
    was able to establish several salient premises aiming to prove Sing Elton was
    a pattern.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: First, it’s a widely used, popular pattern that was published in the *Gang of
    Four* book. This book is considered by many to be unassailable, given it is a
    seminal work in software design patterns.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: “*OBJECTION!,*” the prosecutor yelled as he pounded his fist on the table. “*Your
    honor, neither popularity nor inclusion in a single book is sufficient evidence
    to prove this is a pattern.*”
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Phoebe tapped her gavel lightly on the bench and said, “*Sustained. The defense
    will continue, but you’re on thin ice, counselor. To be a pattern, Sing Elton
    must solve a common problem faced by many software developers. This isn’t a popularity
    contest. You’ll have to do better.*”
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: “*Yes, your honor.*” The counselor blushed and was flustered, as though he were
    hoping the case would be dismissed based on this opening argument. He continued
    to question Mr. Elton.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: “*Can you tell the court exactly what problems you solve?*”
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: “*Sometimes,*” began Mr. Elton, “*you need to ensure there is only one copy
    of a class instantiated at any given time while your program is running. For example,
    you need access to a database, perhaps via an object pool, or maybe you need access
    to a file or a configuration service. In these cases, you should only have one
    instance to handle that. The instance is available to all parts of your program,
    giving you tight control over the global state. These are problems I can solve,
    and I do it in one place within a single class rather than them being scattered
    throughout your code.*”
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'At one point during the trial, the bailiffs brought in a big whiteboard, and
    Mr. Elton was asked to draw a diagram of himself. It looks as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – The Singleton pattern uses a private constructor (not shown)
    to create an instance of the object (itself) held in a private field. Any calls
    to new for that class will check to see whether an instance already exists. If
    it does, the existing object is returned. ](img/B18605_Figure_4.18.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – The Singleton pattern uses a private constructor (not shown) to
    create an instance of the object (itself) held in a private field. Any calls to
    new for that class will check to see whether an instance already exists. If it
    does, the existing object is returned.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'The defense continued and summarized its arguments this way:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Shared resources used by your application, whether they be databases, files,
    remote services, or robotic arms, are granted and guaranteed a single point of
    access.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global state of the program is protected because there is only one point
    of access.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singletons are only initialized once, so any performance hit is taken only when
    the singleton is initialized.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defense attorney concluded with “*The defense rests.*”
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The nearly silent courtroom suddenly boomed with the echoing sound of a loud
    slow golf clap. The prosecutor stood up and straightened his tie while hungrily
    eyeing the jury. You could feel the confidence emanating from him. It was electric.
    As he spoke, it almost sounded as if his Southern drawl was intentionally more
    pronounced.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: “*Your honor, members of the jury, let me tell you why everything the defense
    just said is a gigantic load of BAM!*” The *BAM* came from Judge Phoebe, who saw
    where this was going and slammed her gavel on the bench. She’d only been a judge
    for a few minutes, and might never be again, so there was no way she was going
    to let that kind of language into her courtroom. A girl’s gotta have standards.
    Having admonished the prosecutor, to the bemusement of the clerk and defense attorney,
    the prosecutor called several witnesses who offered anecdotal evidence of Sing
    Elton being an antipattern and a Golden Hammer.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: One software engineering manager testified that Sing Elton must be a Golden
    Hammer because in every job interview he had ever conducted, the applicants always
    claimed to have studied patterns. When the manager asked for an example of a pattern,
    the only pattern anyone could name was the singleton pattern. There are quite
    a few classes out there (you’d think there would be only one example) where the
    implementation doesn’t need to be a singleton. Everyone uses it because it’s the
    one pattern they understand and remember.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'One software developer employed by a major software company specializing in
    defenestration pointed out the most damning arguments:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: According to the widely accepted tenet, every class should have one responsibility;
    it should only solve one problem. Ironically, a singleton solves two. It ensures
    only one single instance of the class exists and it provides a single point of
    access to some shared or constrained resource.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton pattern smells a lot like a global variable. Instead of just a
    variable, it’s a whole class. Globals are universally vilified throughout coder-land
    because they are considered unsafe. Any method on any given object within your
    running program can modify the global state, which typically leads to unstable
    software. This has compounded ramifications for software designed for threading
    or concurrency.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singletons are cited as promoting tight coupling between classes. You really
    can’t get around this since there is no such thing as an abstract singleton.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementations of singletons are impossible to unit - test effectively. Besides
    our earlier stated problem of tight coupling, which is itself anathema to testing,
    you can’t mock the singleton class. It’s sealed and has no parent class, so using
    Liskov substitution is impossible as a tool for testing. Unit tests should be
    isolable and the effects of one test shouldn’t affect other tests. With a singleton
    in the mix, they probably will.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prosecutor concluded with, “*So you see, your honor, ladies and gentlemen
    of the jury, Sing Elton is nothing but a low-down dirty fraud. He’s no pattern
    at all and should be stripped of the title.*”
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: A chorus of harumphs erupted from the gallery. Phoebe smiled because that was
    her cue to bang the gavel again. She could get used to this. She hit the bench
    so hard that the resulting sound shook her from her dream. It was like that dream
    everybody has had at least once – the one where you dream you’re falling and you
    wake up just as you hit the ground.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: “*I’m never eating tacos again!”* Phoebe exclaimed sleepily. She knew she was
    lying. She had a not-taco breakfast and went back to work. The details of her
    dream had some valid points, but she felt this was a case where she truly needed
    a singleton, given the very real constraints at play.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Phoebe models an object pool using a singleton to represent her constrained
    shared collection of robot arms in the control software:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Phoebe has refactored her object pool into a singleton. Now,
    only one robot arm pool can exist within her running program at any given time.
    ](img/B18605_Figure_4.19.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – Phoebe has refactored her object pool into a singleton. Now, only
    one robot arm pool can exist within her running program at any given time.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Phoebe moves to her IDE and starts refactoring the object pool for her robotic
    arms into a singleton. It’s pretty short work. First, she renames the class and
    seals it so that it can’t be extended. If the class were able to be extended,
    it would lose the protection afforded by the pattern. You can start to see why
    people hate the Singleton pattern. It’s breaking a lot of the rules we’ve come
    to admire about keeping things open for extension:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For a Singleton pattern to work, it needs a private static method to hold the
    singleton instance. In effect, this is a class that has a reference to itself,
    which is kinda odd. The key is that there can only be one of them, which is why
    we need the field to be static:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The next oddity you don’t see often is a private constructor. There isn’t a
    public one. Right about now is when your IDE, if it is equipped with static analysis
    tools, will start to complain. It will tell you there is no way to instantiate
    the object. That’s good. That’s what we’re after. Phoebe keeps her `Reset()` logic
    in place. All she did was rename the constructor so that it matches the class
    name and changed the access modifier to private:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The last piece to the Singleton is a static method to gain access to the instance
    property we started with. Phoebe uses C#’s property syntax to expose it. The first
    time the client program references the `Instance` property, the getter checks
    to see whether an instance already exists. If not, it creates one and sets the
    backing field’s `_instance`. If `_instance` is not `null`, that means it’s been
    called once already, so it just returns the instance that is already there. Since
    it’s a static field, all references point to the same location in memory. Voila
    – you have a class that is impossible to instantiate twice:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The rest of Phoebe’s code remains unchanged. You can find the complete refactor
    in the `SingletonExample` project of this chapter’s source code.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented one idiom, the simple factory, and four patterns
    – the Factory Method pattern, the Abstract Factory pattern, the Object Pool pattern,
    and the Singleton pattern.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: All of these patterns are classified as Creational patterns. This means they
    govern the creation of objects by encapsulating the creation logic in a structure
    that is more flexible than using strictly concrete objects with the `new` keyword.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The Factory Method pattern is what most people think of when they hear “factory
    pattern.” Using it entails abstracting creation logic into a factory class called
    a creator. The creator object is defined by an interface to maximize flexibility.
    We also create an interface for the objects the factory is producing. We call
    this the product. Each factory creator class is responsible for a subset of all
    the products in your program.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory pattern involves creating families of objects that organically
    go together. Using it entails creating an abstract definition for multiple creator
    classes. Each creator is responsible for a concrete object.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The Builder pattern is used when you need to make objects using a complex set
    of steps. Using it is similar to the Abstract Factory pattern, but your builder
    classes are defined by an interface. Each method in the builder represents a step
    of the build process. It might be tempting to put a single method in each builder
    class to call the steps in order. However, this is usually delegated to a `Director`
    class. The builder houses the methods to build the object, but the `Director`
    class contains the logic behind the order in which those methods are called.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The Object pool Pattern is designed to help you manage objects that are either
    limited through a real constraint, such as our robot arms, or objects that are
    computationally expensive to create, such as a database, network service, or file
    connections. The idea is to pay the creation penalty once by creating a list of
    those objects that are kept available during your program’s run. When one of these
    objects is needed, the object is taken from the pool and it’s returned when it’s
    no longer needed. This allows other processes to use it later, without having
    to go through normal instantiation.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The Object Pool pattern can be effectively combined with the Singleton pattern.
    The Singleton pattern is controversial and often considered an antipattern because
    it cannot be extended, and it promotes tight coupling. Phoebe was able to use
    it in combination with her robot arm pool to ensure she didn’t accidentally create
    multiple robot arm pools. She only has 10 physical arms to work with, so duplicating
    pools could prove to be problematic.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: These patterns were presented as progression. The sisters started with the simple
    factory and worked iteratively to the builder pattern. This wasn’t intentional
    – that’s just the way it worked out. You shouldn’t take this progression as an
    indication that the Builder pattern is better than the Factory Method or Abstract
    Factory. Each of these patterns has its place and often, patterns can be paired
    together like a fine wine and a good steak.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at structural patterns, which are patterns designed
    to refine the way you structure your class hierarchies for maximum flexibility
    and to fully achieve the open-closed principle.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is a programming idiom and how are they different from patterns?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程惯用法是什么，它们与模式有何不同？
- en: What are some popular programming idioms besides `Hello, World`?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 `Hello, World` 之外，还有一些流行的编程惯用法吗？
- en: What is the downside to relying on the simple factory idiom?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖于简单工厂惯用法有什么缺点？
- en: Is the Singleton a pattern or an antipattern? Why?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例模式是一个模式还是一个反模式？为什么？
- en: What pattern should you use when you are dealing with creating a family of related
    objects?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你处理创建一系列相关对象时，你应该使用哪种模式？
- en: What pattern should you use for objects that have a complex build process?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于具有复杂构建过程的对象，你应该使用哪种模式？
- en: Which class in the Builder pattern is responsible for controlling the execution
    of the build steps in the proper order?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建造者模式中哪个类负责以正确的顺序控制构建步骤的执行？
- en: Further reading
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Ritchie, D. M., Kernighan, B. W., & Lesk, M. E. (1988). *The C programming
    language*. Englewood Cliffs: Prentice Hall.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ritchie, D. M., Kernighan, B. W., & Lesk, M. E. (1988). 《C程序设计语言》。Englewood
    Cliffs: Prentice Hall.'
- en: '[https://sites.google.com/site/steveyegge2/singleton-considered-stupid](https://sites.google.com/site/steveyegge2/singleton-considered-stupid)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://sites.google.com/site/steveyegge2/singleton-considered-stupid](https://sites.google.com/site/steveyegge2/singleton-considered-stupid)'
