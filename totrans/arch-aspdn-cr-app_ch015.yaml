- en: 14 Layering and Clean Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file74.png)In this chapter,
    we explore the inherent concepts behind layering. Layering is a popular way of
    organizing computer systems by encapsulating major concerns into layers. Those
    concerns are related to a computer vocation, such as data access, instead of a
    business concern, such as inventory. Understanding the concepts behind layering
    is essential, as other concepts were born from layers and are very common.We start
    this chapter by exploring the initial ideas behind layering. Then, we explore
    alternatives that can help us solve different problems. We use anemic and rich
    models and expose their pros ** and cons. Finally, we quickly explore **Clean
    Architecture**, an evolution of layering, and a way to organize layers.This chapter
    lays out the evolution of layering, starting with basic, restrictive, and even
    flawed techniques, then we gradually move toward more modern patterns. This journey
    should help you understand the concepts and practices behind layering, giving
    you a stronger understanding than just learning one way of doing things. The key
    is to understand.In this chapter, we cover the following topics:**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   Introducing layering'
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities of the common layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing layering in real life
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing layering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve explored a few design patterns and played with ASP.NET Core,
    it is time to jump into layering. In most computer systems, there are layers.
    Why? Because it is an efficient way to partition and organize units of logic together.
    We could conceptually represent layers as horizontal software segments, each encapsulating
    a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Classic layering model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by examining a classic three-layer application design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: A classic three-layer application design](img/file75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: A classic three-layer application design'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **presentation layer** represents any user interface that a user can interact
    with to reach the **domain**. It could be an ASP.NET Core web application. Anything
    from WPF to WinForms to Android could be a valid non-web presentation layer alternative.The
    **domain layer** represents the core logic driven by the business rules; this
    solves the application’s problem. The domain layer is also called the **business
    logic layer** (**BLL**).The **data layer** represents the bridge between the data
    and the application. The layer can store the data in a SQL Server database, a
    NoSQL database hosted in the cloud, a mix of many data sources, or anything else
    that fits the business needs. The data layer is also called the **data access
    layer** (**DAL**) and the **persistence layer**.Let’s jump to an example. Given
    that a user has been authenticated and authorized, here is what happens when they
    want to create a book in a bookstore application built using those three layers:'
  prefs: []
  type: TYPE_NORMAL
- en: The user requests the page by sending a `GET` request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server handles that `GET` request (**presentation layer**) and then returns
    the page to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user fills out the form and sends a `POST` request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server handles the `POST` request (**presentation layer**) and then sends
    it to the **domain layer** for processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **domain layer** executes the logic required to create a book, then tells
    the **data layer** to persist that data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After unrolling to the presentation layer, the server returns the appropriate
    response to the user, most likely a page containing a list of books and a message
    saying the operation was successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following a classic layering architecture, a layer can only talk to the next
    layer in the stack—**presentation** talks to **domain**, which talks to **data**,
    and so on. The important part is that **each layer must be independent and isolated
    to limit tight coupling**.In this classic layering model, each layer should own
    its **model**. For example, the presentation layer should not send its **view
    models** to the **domain** layer; only **domain objects** should be used there.
    The opposite is also true: since the **domain** returns its own objects to the
    **presentation layer**, the **presentation layer** should not leak them to its
    consumers but organize the required information into **view models** or **DTO**
    instead.Here is a visual example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2: Diagram representing how the layers interact with one another](img/file76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Diagram representing how the layers interact with one another'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if three is probably the most popular number of layers, we can create
    as many as we need; we are not limited to three layers.Let’s examine the advantages
    and disadvantages of classic layering, starting with the advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the purpose of a layer makes it easy to understand. For example, guessing
    that the data layer components read or write some data somewhere is easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a cohesive unit built around a single concern. For example, our **data
    layer** should not render any user interface but stick to accessing data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to decouple the layer from the rest of the system (the other layers).
    You can isolate and work within a layer with limited to no knowledge of the others.
    For example, suppose you are tasked with optimizing a query in a data access layer.
    In that case, you don’t need to know about the user interface that eventually
    displays that data to a user. You only need to focus on that element, optimize
    it, test it in isolation, and then ship the layer or redeploy the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like any other isolated unit, it should be possible to reuse a layer. For example,
    we could reuse our **data access layer** in another application that needs to
    query the same database for a different purpose (a different **domain layer**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some layers are theoretically easier to reuse than others, and reusability could
    add more or less value, depending on the software you are building. I have never
    seen a layer being integrally reused in practice, and I’ve rarely heard or read
    about such a situation—each time rather ends in a not-so-reusable-after-all situation.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on my experience, I would strongly suggest not over-aiming at reusability
    when it is not a precise specification that adds value to your application. Limiting
    your overengineering endeavors could save you and your employers a lot of time
    and money. We must not forget that our job is to deliver value.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a rule of thumb, do what needs to be done, not more, but do it well.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'OK, now, let’s look at the drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: By splitting your software horizontally into layers, each feature crosses all
    of the layers. This often leads to cascading changes between layers. For example,
    if we decide to add a field to our bookstore database, we would need to update
    the database, the code that accesses it (**data layer**), the business logic (**domain
    layer**), and the user interface (**presentation layer**). With volatile specs
    or low-budget projects, this can become painful!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a full-stack feature is more challenging for newcomers because
    it crosses all layers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using layering often leads to or is caused by a separation of responsibilities
    between the staff. For example, DBAs manage the data layer, backend devs manage
    the domain layer, and frontend devs manage the presentation layer, leading to
    coordination and knowledge-sharing issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since a layer directly depends on the layer under it, dependency injection is
    impossible without introducing an **abstraction layer** or referencing lower layers
    from the **presentation layer**. For example, if the **domain layer** depends
    on the **data layer**, changing the data layer would require rewriting all of
    that coupling from the **domain** to the **data**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since each layer owns its entities, the more layers you add, the more copies
    there are of the entities, leading to minor performance loss and a higher maintenance
    cost. For example, the **presentation layer** copies a **DTO** to a **domain object**.
    Then, the **domain layer** copies it to a **data object**. Finally, the **data
    layer** translates it into SQL to persist it into a **database** (SQL Server,
    for example). The opposite is also true when reading from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explore ways to combat some of those drawbacks later.I strongly recommend
    that you don’t do what we just explored. It is an old, more basic way of doing
    layering. We are looking at multiple improvements to this layering system in this
    chapter, so keep reading before jumping to a conclusion. I decided to explore
    layering from the beginning in case you have to work with that kind of application.
    Furthermore, studying its chronological evolution, fixing some flaws, and adding
    options should help you understand the concepts instead of just knowing a single
    way of doing things. Understanding the patterns is the key to software architecture,
    not just learning how to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve discussed layers and seen them as big horizontal slices of responsibilities,
    we can organize our applications more granularly by splitting those big slices
    vertically, creating multiple smaller layers. This can help us organize applications
    by features or by bounding context, and it could also allow us to compose various
    user interfaces using the same building blocks, which would be easier than reusing
    colossal-size layers.Here is a conceptual representation of this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: Organizing multiple applications using smaller partially shared
    layers](img/file77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Organizing multiple applications using smaller partially shared
    layers'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can split an application into multiple features (vertically) and divide
    each into layers (horizontally). Based on the previous diagram, we named those
    features as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inventory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online shopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we can bring in the online shopping domain and data layers to our Shopping
    web API without bringing everything else with it. Moreover, we can bring the online
    shopping domain layer to the mobile app and swap its data layer for another that
    talks to the web API.We could also use our web API as a plain and simple data
    access application with different logic attached to it while keeping the shopping
    data layer underneath.We could end up with the following recomposed applications
    (this is just one possible outcome):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: Organizing multiple applications using smaller partially shared
    layers](img/file78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Organizing multiple applications using smaller partially shared
    layers'
  prefs: []
  type: TYPE_NORMAL
- en: These are just examples of what we can conceptually do with layers. However,
    the most important thing to remember is not how the diagrams are laid out but
    the specifications of the applications you are building. Only those specs and
    good analyses can help you create the best possible design for that exact problem.
    I used a hypothetical shopping example here, but it could have been anything.Splitting
    huge horizontal slices vertically makes each piece easier to reuse and share.
    This improvement can yield interesting results, especially if you have multiple
    frontend apps or plan to migrate away from a monolith.
  prefs: []
  type: TYPE_NORMAL
- en: A **monolithic application** (or monolith) is a program deployed as a single
    integrated piece with low modularity. A monolith can leverage layers or not. People
    often compare monolithic applications to microservices applications because they
    are antipodes. We explore microservices in *Chapter 19*, *Introduction to Microservices
    Architecture*, and monoliths in *Chapter 20*, *Modular Monoliths*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Layers versus tiers versus assemblies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far in this chapter, we have been talking about layers without talking about
    making them into code. Before jumping into that subject, I’d like to discuss **tiers**.
    You may have seen the term **3-tier architecture** somewhere before or heard people
    talking about **tiers** and **layers**, possibly interchanging them in the same
    context as synonyms. However, they are not the same.In a nutshell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tiers** are **physical**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layers** are **logical**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a Tier?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can deploy each **tier** on its own machine. For example, you could have
    a database server, a server hosting your web API that contains the business logic
    (the **domain**), and another server that serves an Angular application (**presentation**);
    these are three tiers (three distinct machines), and each **tier** can scale independently.We
    look at layers next.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Layer?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On the other hand, each **layer** is only the logical organization of code,
    with concerns organized and divided in a layered fashion. For example, you may
    create one or more projects in Visual Studio and organize your code into three
    layers. For example, a Razor Pages application depends on a business logic layer
    that depends on a data access layer. When you deploy that application, all these
    layers, including the database, are deployed together on the same server. This
    would be one tier and three layers. Of course, nowadays, chances are you have
    a cloud database somewhere, which adds a second tier to that architecture: the
    application tier (which still has three layers) and database tier.Now that we’ve
    discussed **layers** and **tiers**, let’s look at a **layer** versus an **assembly**.'
  prefs: []
  type: TYPE_NORMAL
- en: What is an assembly?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Assemblies** are commonly compiled into `.dll` or `.exe` files; you can compile
    and consume them directly. In most cases, each project of a Visual Studio solution
    gets compiled into an assembly. You can also deploy them as NuGet packages and
    consume them from [nuget.org](https://www.nuget.org) or a custom NuGet repository
    of your choosing. But there is no one-to-one relationship between a layer and
    an assembly or a tier and an assembly; assemblies are only consumable units of
    compiled code: a library or a program.Moreover, you do not need to split your
    layers into different assemblies; you can have your three layers residing in the
    same assembly. It can be easier to create undesirable coupling this way, with
    all of the code being in the same project, but it is a viable option with some
    rigor, rules, and conventions. Moving each layer to an assembly does not necessarily
    improve the application; the code inside each layer or assembly can become mixed
    up and coupled with other system parts.Don’t get me wrong: you can create an assembly
    per layer; I even encourage you to do so in most cases, but doing so does not
    mean the layers are not tightly coupled. A layer is simply a logical unit of organization,
    so each contributor’s responsibility is to ensure the layer’s code stays healthy.Furthermore,
    having multiple assemblies let us deploy them to one or more machines, potentially
    different machines, leading to multiple tiers.Let’s now look at the responsibilities
    of the most common layers.'
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities of the common layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we explore the most commonly used layers in more depth. We
    do not dig too deep into each one, but the overview should help you understand
    the essential ideas behind layering.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **presentation layer** is probably the easiest layer to understand because
    it is the only one we can see: the user interface. However, the presentation layer
    can also be the data contracts in case of a REST, OData, GraphQL, or other types
    of web service. The presentation layer is what the user uses to access your program.
    As another example, a CLI program can be a presentation layer. You write commands
    in a terminal, and the CLI dispatches them to its domain layer, executing the
    required business logic.The key to a maintainable presentation layer is to keep
    it as focused on displaying the user interface as possible with as little business
    logic as possible.Next, we look at the **domain layer** to see where these calls
    go.'
  prefs: []
  type: TYPE_NORMAL
- en: Domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **domain layer** is where the software’s value resides and where most of
    the complexity lies. The **domain layer** is the home of your business logic rules.It
    is easier to sell a **user interface** than a **domain layer** since users connect
    to the domain through the presentation. However, it is important to remember that
    the domain is responsible for solving the problems and automating the solutions;
    the **presentation layer** only links users’ actions to the **domain**.We usually
    build the domain layer around a domain model. There are two macro points of view
    on this:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a **rich model**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an **anemic model**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can leverage **Domain-Driven Design** (**DDD**) to build that model and
    the program around it. DDD goes hand in hand with rich models, and a well-crafted
    model should simplify the maintenance of the program. Doing DDD is not mandatory,
    and you can achieve the required level of correctness without it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another dilemma is persisting the domain model directly into the database or
    using an intermediate data model. We talk about that in more detail in the *Data*
    section.Meanwhile, we look at the two primary ways to think about the domain model,
    starting with the rich domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Rich domain model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A rich domain model is more object-oriented, in the “purest” sense of the term,
    and encapsulates the domain logic as part of the model inside methods. For example,
    the following class represents the rich version of a minimal `Product` class that
    contains only a few properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `AddStock` and `RemoveStock` methods represent the domain logic of adding
    and removing stock for the product inventory. Of course, we only increment and
    decrement a property’s value in this case, but the concept would be the same in
    a more complex model.The biggest advantage of this approach is that most of the
    logic is built into the model, making this very domain-centric with operations
    programmed on model entities as methods. Moreover, it reaches the basic ideas
    behind object-oriented design, where behaviors should be part of the objects,
    making them a virtual representation of their real-life counterparts.The biggest
    drawback is the accumulation of responsibilities by a single class. Even if object-oriented
    design tells us to put logic into the objects, this does not mean it is always
    a good idea. If flexibility is important for your system, hardcoding logic into
    the domain model may hinder your ability to evolve business rules without changing
    the code itself (it can still be done). A rich model might be a good choice for
    your project if the domain is fixed and predefined.A relative drawback of this
    approach is that injecting dependencies into the domain model is harder than other
    objects, such as services. This drawback reduces flexibility and increases the
    complexity of creating the models.A rich domain model can be useful if you are
    building a stateful application where the domain model can live in memory longer
    than the time of an HTTP request. Other patterns can help you with that, such
    as **Model-View-View-Model** (**MVVM**), Model-View-Presenter (MVP), and **Model-View-Update**
    (**MVU**).If you believe your application would benefit from keeping the data
    and the logic together, then a rich domain model is most likely a good idea for
    your project. If you are practicing DDD, I probably don’t have to tell you that
    a rich model is the way to go. Without DDD notions, achieving a maintainable and
    flexible rich model is challenging.A rich model can be a good option if your program
    is built around a complex domain model and persists those classes directly to
    your database using an **object-relational mapper** (**ORM**). Using Cosmos DB,
    Firebase, MongoDB, or any other document database can make storing complex models
    as a single document easier than a collection of tables (this applies to anemic
    models too).As you may have noticed, there are a lot of “ifs” in this section
    because I don’t think there is an absolute answer to whether a rich model is better
    or not, and it is more a question of whether it is better for your specific case
    than better overall. You also need to take your personal preferences and skills
    into account.Experience is most likely your best ally here, so I’d recommend coding,
    coding, and coding more applications to acquire that experience.
  prefs: []
  type: TYPE_NORMAL
- en: Anemic domain model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An anemic domain model usually does not contain methods but only getters and
    setters. Such models must not contain business logic rules. The `Product` class
    we had previously would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there is no method in the class anymore, only the three
    properties with public setters. We can also leverage a record class to add immutability
    to the mix. As for the logic, we must move it elsewhere, in other classes. One
    such pattern would be to move the logic to a **service layer**.A **service layer**
    in front of such an **anemic model** would take the input, mutate the domain object,
    and update the database. The difference is that the service owns the logic instead
    of the rich model.With the anemic model, separating the operations from the data
    can help us add flexibility to a system. However, enforcing the model’s state
    at any given time can be challenging since external actors (services) are modifying
    the model instead of the model managing itself.Encapsulating logic into smaller
    units makes it easier to manage each of them, and it is easier to inject those
    dependencies into the service classes than injecting them into the entities themselves.
    Having more smaller units of code can make a system more dreadful for a newcomer
    as it can be more complex to understand since it has more moving parts. On the
    other hand, if the system is built around well-defined abstractions, it can be
    easier to test each unit in isolation.However, the tests can be quite different.
    In the case of our rich model, we test the rules and the persistence separately.
    We call this **persistence ignorance**, which allows us to test business rules
    in isolation. Then we could create integration tests to cover the persistence
    aspect of the service layer and more unit and integration tests on the data and
    domain levels. With an anemic model, we test both the business rules and the persistence
    simultaneously with integration tests at the service layer level or test only
    the business rules in unit tests that mock the persistence part away. Since the
    model is just a data bag without logic, there is nothing to test there.All in
    all, if the same rigorous domain analysis process is followed, the business rules
    of an anemic model backed by a service layer should be as complex as a rich domain
    model. The biggest difference should be in which classes the methods are located.An
    anemic model is a good option for stateless systems, such as RESTful APIs. Since
    you have to recreate the model’s state for every request, an anemic model can
    offer you a way to independently recreate a smaller portion of the model with
    smaller classes optimized for each use case. Stateless systems require a more
    procedural type of thinking than a purely object-oriented approach, leaving the
    anemic models as excellent candidates for that.
  prefs: []
  type: TYPE_NORMAL
- en: I personally love anemic models behind a service layer, but some people would
    not agree with me. I recommend choosing what you think is best for the system
    you are building instead of doing something based on what someone else did in
    another system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another good tip is to let the refactoring flow *top-down* to the right location.
    For example, if you feel that a method is bound to an entity, nothing stops you
    from moving that piece of logic into that entity instead of a service class. If
    a service is more appropriate, move the logic to a service class.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, let’s go back to the **domain layer** and explore a pattern that emerged
    over the years to shield the **domain model** using a **service layer**, splitting
    the **domain layer** into two distinct pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Service layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **service layer** shields the domain model and encapsulates domain logic.
    The service layer orchestrates the complexity of interacting with the model or
    external resources such as databases. Multiple components can then use the service
    layer while having limited knowledge of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: Service layer relationships with other layers](img/file79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Service layer relationships with other layers'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows that the presentation layer talks to the service
    layer, which manages the domain model and implements the business logic.The **service
    layer** contains services, which are classes that interact with other **domain
    objects**, such as the **domain model** and the **data layer**.We can further
    divide services into two categories, **domain services**, and **application services**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain services** are those services we are talking about so far. They contain
    domain logic and allow consumers from the presentation layer to read or write
    data. They access and mutate the domain model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application services** like email services are unrelated to the domain and
    should live elsewhere, like in a shared (why rewrite an email service for every
    project, right?).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with other layers, your service layer could expose its own model, shielding
    its consumers from domain model (internal) changes. In other words, the service
    layer should only expose its contracts and interfaces (keyword: shield). **A service
    layer is a form of façade.**'
  prefs: []
  type: TYPE_NORMAL
- en: We further explore ways to keep copying anemic classes into other anemic classes
    to a minimum.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are many ways to interpret this layer, and I’ll try to illustrate as
    many as possible in a condensed manner (from simpler to more complex ones):'
  prefs: []
  type: TYPE_NORMAL
- en: The classes and interfaces of the service layer could be part of the domain
    layer’s assembly, created in a *Services* directory, for example. This is less
    reusable, but it paves the way to sharing services in the future without managing
    multiple projects at first. It needs rigor to not depend on what you should not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service layer could be an assembly containing interfaces and implementation.
    This is a great compromise between reusability and maintenance time. Chances are
    you will never need two implementations (see the next point) because the services
    are tied to the logic; they are the domain. You could even hide the implementation,
    as we did with the **opaque façade** in *Chapter 11*, *Structural Patterns*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service layer could be divided into two assemblies -- one containing abstractions
    (referenced by consumers) and one containing implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service layer could be an actual web service tier (such as a web API).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When writing services code, by convention, people usually suffix a service
    class with `Service`, such as `ProductService` and `InventoryService`; the same
    goes for interfaces (`IProductService` and `IInventoryService`).No matter which
    technique you choose, remember that the service layer contains the domain logic
    and shields the domain model from direct access.The service layer is an amazing
    addition that shields and encapsulates the logic for manipulating an anemic domain
    model. It can defeat the purpose of a rich domain model if it’s just a pass-through
    but can be very useful to handle complex, non-atomic business rules that affect
    multiple domain objects.The primary decider of whether or not to add a service
    layer is tied to the complexity of your project’s domain. The more complex, the
    more it makes sense. The more trivial, the less it makes sense. Here are a few
    tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a service layer when using an anemic model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a service layer for very complex domains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not add a service layer for low-complexity domains or *façade over database*
    applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s look at the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **data layer** is where the persistence code goes. In most programs, we
    need some kind of persistence to store our application data, which is often a
    database. Several patterns come to mind when discussing the data layer, including
    the **Unit of Work** and **Repository patterns**, which are very common. We cover
    these two patterns very briefly at the end of this subsection.We can persist our
    **domain model** as is or create a **data model** that is more suited to be stored.
    For example, a many-to-many relationship is not a thing in the object-oriented
    world, while it is from a relational database standpoint.You can view a **data
    model** like a **DTO** for the data. The **data model** is how the data is stored
    in your data store; that is, how you modeled your data or what you have to live
    with.In a classic layering project, you have no choice but to have a data model.
    However, we explore better solutions as we continue to explore additional options.
  prefs: []
  type: TYPE_NORMAL
- en: An **ORM** is a piece of software that translates objects into a database language
    such as SQL. It allows mutating data, querying data, loading that data into objects,
    and more.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modern data layers usually leverage an **ORM** such as **Entity Framework Core**
    (**EF Core**), which does a big part of our job, making our lives easier. In the
    case of **EF Core**, it allows us to choose between multiple providers, from SQL
    Server to Cosmos DB, passing by the in-memory provider. The great thing about
    EF Core is that it already implements the **Unit of Work** and the **Repository**
    patterns for us, among other things. In the book, we use the in-memory provider
    to cut down setup time and run integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve used EF6 before and dread Entity Framework, know that EF Core is lighter,
    faster, and easier to test. Feel free to give it a second shot. EF Core’s performance
    is very high now too. However, if you want complete control over your SQL code,
    look for Dapper (not to be confused with **Dapr**).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I don’t want to go into too much detail about these patterns, but they are important
    enough to deserve an overview. As mentioned, EF Core already implements these
    patterns, so we don’t have to deal with them. Moreover, using such patterns is
    not always desirable, can be hard to implement right, and can lead to bloated
    data access layers, but they can also be very useful when used well.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve written a multi-part article series about the Repository pattern. See the
    *Further reading* section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the meantime, let’s at least study their goals to know what they are for,
    and if the situation arises where you need to write such components, you know
    where to look.
  prefs: []
  type: TYPE_NORMAL
- en: Repository pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The goal of the Repository pattern is to allow consumers to query the database
    in an object-oriented way. Usually, this implies caching objects and filtering
    data dynamically. EF Core represents this concept with a `DbSet<T>` and provides
    dynamic filtering using LINQ and the `IQueryable<T>` interface.People also use
    the term **repository** to represent the **Table Data Gateway pattern**, which
    is another pattern that models a class that gives us access to a single table
    in a database and provides access to operations such as creating, updating, deleting,
    and fetching entities from that database table. Both patterns are from the *Patterns
    of Enterprise Application Architecture* and are extensively used.Homegrown custom
    implementations usually follow the Table Data Gateway pattern more than the Repository
    pattern. They are based on an interface that looks like the following code and
    contains methods to create, update, delete, and read entities. They can have a
    base entity or not, in this case, `IEntity<TId>`. The `Id` property can also be
    generic or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing that often happens with those table data gateways is that people
    add a save method to the interface. As long as you update a single entity, it
    should be fine. However, that makes transactions that cross multiple repositories
    harder to manage or dependent on the underlying implementation (breaking abstraction).
    To commit or revert such transactions, we can leverage the Unit of Work pattern,
    moving the save method from the table data gateway there.For example, when using
    EF Core, we can use `DbSet<Product>` (the `db.Products` property) to add new products
    to the database, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the querying part, the easiest way to find a single product is to use it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we could use LINQ instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These are some of the querying capabilities that a **repository** should provide.
    EF Core seamlessly translates LINQ into the configured provider expectations like
    SQL, adding extended filtering capabilities.Of course, with EF Core, we can query
    collections of items, fetching all products and projecting them as domain objects
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also filter further using LINQ here; for example, by querying all the
    products that are out of stock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also allow a margin for error, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We now have briefly explored how to use the EF Core implementation of the Repository
    pattern, `DbSet<T>`. These few examples might seem trivial, but it would require
    considerable effort to implement custom repositories on par with EF Core’s features.EF
    Core’s unit of work, the `DbContext` class, contains the *save* methods to persist
    the modifications done to all its `DbSet<T>` properties (the repositories). Homebrewed
    implementations often feature such methods on the repository itself, making cross-repository
    transactions harder to handle and leading to bloated repositories containing tons
    of operation-specific methods to handle such cases.Now that we understand the
    concept behind the **Repository pattern**, let’s jump into an overview of the
    **Unit of Work pattern** before going back to layering.
  prefs: []
  type: TYPE_NORMAL
- en: Unit of Work pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A **unit of work** keeps track of the object representation of a transaction.
    In other words, it manages a registry of what objects should be created, updated,
    and deleted. It allows us to combine multiple changes in a single transaction
    (one database call), offering multiple advantages over calling the database every
    time we make a change.Assuming we are using a relational database, here are two
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it can speed up data access; calling a database is slow, so limiting
    the number of calls and connections can improve performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, running a transaction instead of individual operations allows us to
    roll back all operations if one fails or commit the transaction as a whole if
    everything succeeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EF Core implements this pattern with the `DbContext` class and its underlying
    types, such as the `DatabaseFacade` and `ChangeTracker` classes.Our small applications
    don’t need transactions, but the concept remains the same. Here is an example
    of what happens using EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the database for a single entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changes the value of the `QuantityInStock` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Persists the changes back into the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In reality, what happened is closer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We ask EF Core for a single entity through the `ProductContext` (a unit of
    work), which exposes the `DbSet<Product>` property (the product repository). Under
    the hood, EF Core does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Queries the database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Caches the entity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tracks changes for that entity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns it to us.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We change the value of the `QuantityInStock` property; EF Core detects the change
    and marks the object as *dirty*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We tell the unit of work to persist the changes that it tracked, saving the
    *dirty product* back to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a more complex scenario, we could have written the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `SaveChanges()` method triggers saving the three operations instead
    of sending them individually. You can control database transactions using the
    `Database` property of `DbContext` (see the *Further reading* section for more
    information).Now that we’ve explored the **unit of work** pattern, we could implement
    one by ourselves. Would that add value to our application? Probably not. If you
    want to build a custom **unit of work** or a wrapper over EF Core, there are plenty
    of existing resources to guide you. Unless you want to experiment or need a custom
    **unit of work** and **repository** (which is possible), I recommend staying away
    from doing that. Remember: **do only what needs to be done for your program to
    be correct**.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t get me wrong when I say *do only what needs to be done*; wild engineering
    endeavors and experimentations are a great way to explore, and I encourage you
    to do so. However, I recommend doing so in parallel so that you can innovate,
    learn, and possibly even migrate that knowledge to your application later instead
    of wasting time and breaking things. If you are using Git, creating an experimental
    branch is a good way of doing this. You can then delete it when your experimentation
    does not work, merge the branch if it yields positive results, or leave it there
    as a reference (depending on the team’s policies in place).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we explored a high-level view of the Repository and Unit of Work patterns,
    and what those common layers are for, we can continue our journey of using layers.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section looks at abstract layers using an abstract data layer implementation.
    This type of abstraction can be very useful and is another step closer to **Clean
    Architecture**. Moreover, you can abstract almost anything this way, which is
    nothing more than applying the **Dependency Inversion Principle** (**DIP**).Let’s
    start with some context and the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: The **domain layer** is where the logic lies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **UI** links the user to the **domain**, exposing the features built into
    that **domain**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **data layer** should be an implementation detail that the **domain** blindly
    uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **data layer** contains the code that knows where the data is stored, which
    should be irrelevant to the **domain**, but the **domain** directly depends on
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The solution to **break the tight coupling** between the **domain** and the
    **data** persistence implementations is to create an additional abstract layer,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: Replacing the data (persistence) layer with a data abstraction
    layer](img/file80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Replacing the data (persistence) layer with a data abstraction
    layer'
  prefs: []
  type: TYPE_NORMAL
- en: 'New rule: **only interfaces and data model classes go into the data abstractions
    layer**. This new layer now defines our data access API and does nothing but expose
    a set of interfaces—the contract.Then, **we can create one or more data implementations**
    based on that abstract layer contract, like using EF Core. The link between the
    abstractions and implementations is done with dependency injection. The bindings
    defined in the **composition root** explain the indirect connection between the
    presentation and the data implementation.The new dependency tree looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7: The relationships between layers](img/file81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: The relationships between layers'
  prefs: []
  type: TYPE_NORMAL
- en: The **presentation layer** references a **data implementation layer** for the
    sole purpose of creating the DI bindings. We need those bindings to inject the
    correct implementation when creating **domain** classes. Besides, **the presentation
    layer must not use the data layer’s abstractions or implementations**.I created
    a sample project that showcases the relationships between the projects and the
    classes. However, that project would have added pages of code, so I decided not
    to include it in the book. The most important thing about abstract layers is the
    dependency flow between the layers, not the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: The project is available on GitHub ([https://adpg.link/s9HX](https://adpg.link/s9HX)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In that project, the program injects an instance of the `EF.ProductRepository`
    class when a consumer asks for an object that implements the `IProductRepository`
    interface. In that case, the consuming class is `ProductService` and only depends
    on the `IProductRepository` interface. The `ProductService` class is unaware of
    the implementation itself: it leverages only the interface. The same goes for
    the program that loads a `ProductService` class but knows only about the `IProductService`
    interface. Here is a visual representation of that dependency tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8: The dependency flow between layers, classes, and interfaces](img/file82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: The dependency flow between layers, classes, and interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, look at how dependencies converge on the `Data.Abstract`
    layer. The dependency tree ends up on that abstract data layer.With this applied
    piece of architectural theory, we are inverting the flow of dependencies on the
    data layer by following the **DIP**. We also cut out the direct dependency on
    EF Core, allowing us to implement a new data layer and swap it without impacting
    the rest of the application or update the implementation without affecting the
    domain. As I mentioned previously, swapping layers should not happen very often,
    if ever. Nonetheless, this is an important part of the evolution of layering,
    and more importantly, we can apply this technique to any layer or project, not
    just the data layer, so it is imperative to understand how to invert the dependency
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: To test the APIs, you can use the Postman collection that comes with the book;
    visit [https://adpg.link/postman8](https://adpg.link/postman8) or GitHub ([https://adpg.link/net8](https://adpg.link/net8))
    for more info.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, let’s explore sharing and persisting a rich domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have explored strict layering and how to apply the DIP, but we still have
    multiple models. An alternative to copying models from one layer to another is
    to share a model between multiple layers, generally as an assembly. Visually,
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9: Sharing a model between all three layers](img/file83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Sharing a model between all three layers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything has pros and cons, so no matter how much time this can save you
    at first, it will come back to haunt you and become a pain point later as the
    project advances and becomes more complex.Suppose you feel that sharing a model
    is worth it for your application. In that case, I recommend using **view models**
    or **DTOs** at the presentation level to control and keep the input and output
    of your application loosely coupled from your model. This way of shielding your
    lower layers can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10: Sharing a model between the domain and data layers](img/file84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Sharing a model between the domain and data layers'
  prefs: []
  type: TYPE_NORMAL
- en: By doing that, you will save some time initially by sharing your model between
    your domain and data layers. By hiding that shared model under the presentation
    layer, you should dodge many problems in the long run, making this a good compromise
    between quality and development time. Moreover, since your presentation layer
    shields your application from the outside world, you can refactor your other layers
    without impacting your consumers.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty much how Clean Architecture does it but represented differently.
    Using that, the model is at the center of the application and is manipulated and
    persisted. While the layers have different names, the concept remains very similar.
    More on that later.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**View models** and **DTOs** are key elements to successful programs and developers’
    sanity; they should save you many headaches for long-running projects. We revisit
    and explore the concepts of controlling the input and output later in *Chapter
    16*, *Mediator and CQRS Design Patterns*, where inputs become **commands** and
    **queries**.Meanwhile, let’s merge that concept with an abstraction layer. In
    the previous project, the **data abstraction layer** owned the **data model**,
    and the **domain layer** owned the **domain model**.In this architectural alternative,
    we are sharing the model between the two layers. The presentation layer can indirectly
    use that shared model to dialog with the domain layer without exposing it externally.
    The objective is to directly persist the **domain model** and skip the copy from
    the **domain** to the **data layer** while having that data abstraction layer
    that breaks the tight coupling between the domain logic and the persistence.Here
    is a visual representation of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11: Diagram representing a shared rich model](img/file85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Diagram representing a shared rich model'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is well suited for **rich models,** but we can also do this for anemic models.
    With a **rich domain model**, you delegate the job of reconstructing the model
    to the ORM and immediately start calling its methods.The ORM also recreates the
    anemic model, but those classes just contain data, so you need to call other pieces
    of the software that contain the logic to manipulate those objects.In the code
    sample, the **data abstraction layer** now contains only the data access abstractions,
    such as the repositories, and it references the new `Model` project that is now
    the persisted model.Conceptually, it cleans up a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: The data abstraction layer’s only responsibility is to contain data access abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain layer’s only responsibility is implementing the domain services and
    the logic that is not part of that rich model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of an anemic model, the domain layer’s responsibility would be to
    encapsulate all the domain logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Model` project contains the entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, I skip publishing most of the code here as it is irrelevant to
    the overall concept. If you think reading the code would help, you can consult
    and explore the sample on GitHub ([https://adpg.link/9F5C](https://adpg.link/9F5C)).
    Using an IDE to browse the code should help you understand the flow, and as with
    the abstract layer, the dependencies between the projects, classes, and interfaces
    are the key to this.Nevertheless, here is the `StockService` class that uses that
    shared model so you can peek at some code that directly relates to the explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are injecting an implementation of the `IProductRepository`
    interface we use in the next two methods. Next, we look at the `AddStockAsync`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The fun starts in the preceding code, which does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The repository recreates the product (model) that contains the logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It validates that the product exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses that model and calls the `AddStock` method (encapsulated domain logic).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tells the repository to update the product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns the updated product’s `QuantityInStock` to the consumer of the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we explore the `RemoveStockAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We applied the same logic as the `AddStock` method to the `RemoveStock` method,
    but it calls the `Product.RemoveStock` method instead. From the `StockService`
    class, we can see the service gating the access to the domain model (the product),
    fetching and updating the model through the abstract data layer, manipulating
    the model by calling its methods, and returning domain data (an `int` in this
    case, but could be an object).
  prefs: []
  type: TYPE_NORMAL
- en: This type of design can be either very helpful or undesirable. Too many projects
    depending on and exposing a shared model can lead to leaking part of that model
    to consumers, for example exposing properties that shouldn’t be, exposing the
    whole domain model as output, or the very worst, exposing it as an input and opening
    exploitable holes and unexpected bugs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be careful not to expose your shared model to the presentation layer consumers.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pushing logic into the model is not always possible or desirable, which is
    why we are exploring multiple types of domain models and ways to share them. Making
    a good design is often about options and deciding what option to use for each
    scenario. There are also tradeoffs to make between flexibility and robustness.The
    rest of the code is similar to the abstract layer project. Feel free to explore
    the source code ([https://adpg.link/9F5C](https://adpg.link/9F5C)) and compare
    it with the other projects. The best way to learn is to practice, so play with
    the samples, add features, update the current features, remove stuff, or even
    build your own project. Understanding these concepts will help you apply them
    to different scenarios, sometimes creating unexpected but efficient constructs.Now,
    let’s look at the final evolution of layering: Clean Architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve covered many layering approaches, it is time to combine them
    into **Clean Architecture**, also known as Hexagonal Architecture, Onion Architecture,
    Ports and Adapters, and more. Clean Architecture is an evolution of the layers,
    a way of organizing the relationships between the layers, yet very similar to
    what we just built. Instead of presentation, domain, and data (or persistence),
    Clean Architecture suggests **UI**, **Core**, and **Infrastructure**.As we saw
    previously, we can design a layer containing abstractions or implementations.
    When implementations depend only on abstractions, that inverts dependency flow.
    Clean Architecture emphasizes such layers but with its own guidance about organizing
    them.We also explored the theoretical concept of breaking layers into smaller
    ones (or multiple projects), thus creating “fractured layers” that are easier
    to port and reuse. Clean Architecture leverages that concept at the infrastructure
    layer level.There are probably as many points of view and variants of this as
    there are names for it, so I’ll try to be as general as possible while keeping
    the essence. By doing this, if you are interested in this type of architecture,
    you can pick a resource and dig deeper into it, following the style you prefer.Let’s
    take a look at a diagram that resembles what we can find online:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12: A diagram representing the most basic Clean Architecture layout](img/file86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: A diagram representing the most basic Clean Architecture layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a layering diagram-like standpoint, the preceding diagram could look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13: A two-layer view of the previous Clean Architecture diagram](img/file87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: A two-layer view of the previous Clean Architecture diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your chosen method, you can split those layers into multiple other
    sublayers. One thing that we often see is dividing the **Core** layer into **Entities**
    and **Use cases**, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14: Widespread Clean Architecture layout diagram](img/file88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Widespread Clean Architecture layout diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since people in the tech industry are creative, there are many names for many
    things, but the concepts remain the same. From a layering diagram-like standpoint,
    that diagram could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15: A layer-like view of the previous Clean Architecture diagram](img/file89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: A layer-like view of the previous Clean Architecture diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'The infrastructure layer is conceptual and can represent multiple projects,
    such as an infrastructure assembly containing EF Core implementations and a website
    project representing the web UI. We could also add more projects to the infrastructure
    layer.The dependency rule of Clean Architecture states that dependencies can only
    point inward, from the outer layers to the inner layers. This means that abstractions
    lie inside, and concretions lie outside. Based on the preceding layer-like diagram,
    inside translates to downward. That means a layer can use any direct or transitive
    dependencies, which means that infrastructure can depend on use cases and entities.Clean
    Architecture follows all the principles that we’ve been discussing since the beginning
    of this book, such as decoupling our implementations using abstractions, dependency
    inversion, and separation of concerns. These implementations are glued over abstractions
    using dependency injection (this is not mandatory, but it helps).I’ve always found
    those circle diagrams a bit confusing, so here is my take on an updated, more
    linear diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.16: A two-layer view of Clean Architecture’s common elements](img/file90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.16: A two-layer view of Clean Architecture’s common elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s revisit our layered application using Clean Architecture, starting
    with the **core layer**. The core project contains the domain model, the use cases
    (services), and the interfaces needed to fulfill those use cases. We must not
    access external resources in this layer: no database calls, disk access, or HTTP
    requests. This layer contains the interfaces that expose such interaction, but
    the implementations live in the **infrastructure layer**.The presentation layer
    was renamed `Web` and lives in the outer layer with the EF Core implementation.
    The `Web` project depends only on the `Core` project. Once again, since the composition
    root is in this project, it must load the EF Core implementation project to configure
    the IoC container.Here is a diagram representing the relation between the shared
    model and the new Clean Architecture project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.17: From shared project to the Clean Architecture project structure](img/file91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.17: From shared project to the Clean Architecture project structure'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we took the center of the classic layered solution
    and merged the layers into a single `Core` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the link to this project on GitHub: [https://adpg.link/rT1P](https://adpg.link/rT1P).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Most of the code is not that relevant since, once again, the most significant
    aspect is the dependency flow and relationships between projects. Nonetheless,
    here is a list of changes that I made aside from moving the pieces to different
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I removed the `ProductService` class and `IProductService` interface and used
    the `IProductRepository` interface directly from the `StockService` class (`Core`
    project) and the `/products` endpoint (`Web` project: `Program.cs`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I removed the `IStockService` interface, and now both the add and remove stocks
    endpoints (`Web` project: `Program.cs`) depend directly on the `StockService`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why use the `IProductRepository` interface directly, you might wonder? Since
    the `Web` project (**infrastructure layer**) depends on the **core layer**, we
    can leverage the inward dependency flow. It is acceptable to use a repository
    directly as long as the feature has no business logic. Programming empty shells
    and pass-through services adds useless complexity. However, when business logic
    starts to be involved, create a service or any other domain entity you deem necessary
    for that scenario. Don’t pack business logic into your controllers or minimal
    API delegates.I removed the `IStockService` interface since the `StockService`
    class contains concrete business rules that can be consumed as is from the infrastructure
    layer. I know we have emphasized using interfaces since the beginning of the book,
    but I also often said that principles are not laws. All in all, there is nothing
    to abstract away: if the business rules change, the old ones won’t be needed anymore.
    On the other hand, we could have kept the interface.To wrap this up, Clean Architecture
    is a proven pattern for building applications that is fundamentally an evolution
    of layering. Many variants can help you manage use cases, entities, and infrastructure;
    however, we will not cover those here. There are many open-source projects to
    start with Clean Architecture if you seek organizational guidance.'
  prefs: []
  type: TYPE_NORMAL
- en: I left a few links in the *Further reading* section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you think this is a great fit for you, your team, your project, or your organization,
    feel free to dig deeper and adopt this pattern. In subsequent chapters, we explore
    some patterns, such as CQRS, Publish-Subscribe, and feature-based design, which
    we can combine with Clean Architecture to add flexibility and robustness. These
    become particularly useful as your system grows in size and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing layering in real life
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we covered all of this, it is important to note that on the one hand,
    there is the theory, and on the other, life is hitting you in the face. Suppose
    you are working in a big enterprise. In that case, chances are your employer can
    pour hundreds of thousands or even millions of dollars into a feature to run experiments,
    spend months designing every little piece, and ensure everything is perfect. Even
    then, is achieving perfection even possible? Probably not.For companies that don’t
    have that type of capital, you must build entire products for a few thousand dollars
    sometimes because they are not trying to resell them but just need that tool built.
    That is where your architectural skills come in handy. How do you design the least-worst
    product in a maintainable fashion while meeting stakeholders' expectations? The
    most important part of the answer is to set expectations upfront. Moreover, never
    forget that someone needs to maintain and change the software over time; no software
    does not evolve; there’s always something.
  prefs: []
  type: TYPE_NORMAL
- en: If you are in a position where you must evaluate the feasibility of products
    and features in this context, setting expectations lower can be a good way to
    plan for the unplannable. It is easier to overdeliver than justify why you underdelivered.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s dig deeper into this and look at a few tricks to help you out. Even if
    you are working for a larger enterprise, you should get something out of it.
  prefs: []
  type: TYPE_NORMAL
- en: To be or not to be a purist?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your day-to-day work, you may not always need the rigidity of a **domain
    layer** to create a wall in front of your data. Maybe you just don’t have the
    time or the money, or it’s just not worth doing.Taking and presenting the data
    can often work well enough, especially for simple data-driven applications that
    are only a user interface over a database, as is the case for many internal tools.The
    answer to the *“To be or not to be a purist?”* question is: it depends!'
  prefs: []
  type: TYPE_NORMAL
- en: This section covers layering, but we explore other patterns that are feature-oriented,
    so I suggest you continue reading and explore using the techniques from *Chapter
    17*, *Vertical Slice Architecture*, *Chapter 18*, *Request-EndPoint-Response (REPR)*,
    and *Chapter 20*, *Modular Monolith*, to improve your design while keeping the
    design overhead low.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are a few examples of things that the answer depends on, to help you out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project; for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-heavy or logic-intensive projects** will benefit from a domain layer,
    helping you centralize parts for an augmented level of reusability and maintainability.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data management projects** tend to have less or no logic in them. We can
    often build them without adding a domain layer as the **domain** is often only
    a tunnel from the **presentation** to the **data**; a pass-through layer. We can
    often simplify those systems by dividing them into two layers: **data** and **presentation**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Your team; for example, a highly skilled team may tend to use advanced concepts
    and patterns more efficiently, and the learning curve for newcomers should be
    easier due to the number of seasoned engineers that can support them on the team.
    This does not mean that less skilled teams should aim lower; on the contrary,
    it may just be harder or take longer to start. Analyze each project individually
    and find the best patterns to drive them accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your boss; if the company you work for puts pressure on you and your team to
    deliver complex applications in record time and nobody tells your boss that it
    is impossible, you may need to cut corners a lot and enjoy many maintenance headaches
    with crashing systems, painful deployments, and more. That being said, if it is
    inevitable for these types of projects, I’d go with a very simple design that
    does not aim at reusability—aim at low-to-average testability and code stuff that
    just works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your budget; once again, this often depends on the people selling the application
    and the features. I saw promises that were impossible to keep but delivered anyway
    with a lot of effort, extra hours, and corner-cutting. The thing to remember when
    going down that path is that at some point, there is no return from the accumulated
    **technical debt**, and it will just get worse (this applies to all budgets).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The audience; the people who use the software can make a big difference to
    how you build it: ask them. For example, suppose you are building a tool for your
    fellow developers. In that case, you can cut corners that you would not for less
    technically skilled users (like delivering a CLI tool instead of a full-blown
    user interface). On the other hand, if you’re aiming your application at multiple
    clients (web, mobile, and so on), isolating your application’s components and
    focusing on reusability could be a winning design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected quality; you should not tackle the problem in the same way for
    building a prototype and a SaaS application. It is acceptable, even encouraged,
    for a prototype to have no tests and not follow best practices, but I’d recommend
    the opposite for a production-quality application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any other things that life throws at you; yes, life is unpredictable, and no
    one can cover every possible scenario in a book, so just keep the following in
    mind when building your next piece of software:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not over-engineer your applications.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only implement features that you need, not more, as per the **you aren’t gonna
    need it** (**YAGNI**) **principle.**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***   Use your judgment and take the less-worst options; there is no perfect
    solution.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**I hope you found this guidance helpful and that it will serve you in your
    career.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a façade over a database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Data-driven programs are a type of software that I often see in smaller enterprises.
    Those companies need to support their day-to-day operations with computers, not
    the other way around. Every company needs internal tools, and many needed them
    yesterday.The reason is simple; every company is unique. Because it’s unique,
    due to its business model, leadership, or employees, it also needs unique tools
    to help with its day-to-day operations. Those small tools are often simple user
    interfaces over a database, controlling access to that data. In these cases, you
    don’t need over-engineered solutions, as long as everyone is informed that the
    tool will not evolve beyond what it is: a small tool.In real life, this one is
    tough to explain to non-programmers because they tend to see complex use cases
    as easy to implement and simple use cases as hard to implement. It’s normal; they
    just don’t know, and we all don’t know something. In these scenarios, a big part
    of our job is also to educate people. Advising decision-makers about the differences
    in quality between a small tool and a large business application. Educating and
    working with stakeholders makes them aware of the situation and make decisions
    with you, leading to higher project quality that meets everyone’s expectations.
    This can also reduce the “*it’s not my fault*” syndrome from both sides.I’ve found
    that immersing customers and decision-makers in the decision process and having
    them follow the development cycle helps them understand the reality behind the
    programs and helps both sides stay happy and grow more satisfied. Stakeholders
    not getting what they want is no better than you being super stressed over unreachable
    deadlines.That said, our educational role does not end with decision-makers. Teaching
    new tools and techniques to your peers is also a major way to improve your team,
    peers, and yourself. Explaining concepts is not always as easy as it sounds.Nevertheless,
    data-driven programs may be hard to avoid, especially if you are working for SMEs,
    so try to get the best out of it. Nowadays, with low-code and no-code solutions
    and all the open-source libraries, you might be able to save yourself a lot of
    this kind of trouble, but maybe not all.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that someday, someone must maintain those small tools. Think of that
    person as you, and think about how you’d like some guidelines or documentation
    to help you. I’m not saying to over-document projects, as documentation often
    gets out of sync with the code and becomes more of a problem than a solution.
    However, a simple `README.md` file at the project's root explaining how to build
    and run the program and some general guidelines could be beneficial. Always think
    about documentation as if you were the one reading it. Most people don’t like
    to spend hours reading documentation to understand something simple, so keep it
    simple.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When building a *façade over a database*, you want to keep it simple. Also,
    you should make it clear that it should not evolve past that role. One way to
    build this would be to use EF Core as your data layer and scaffold an MVC application
    as your presentation layer, shielding your database. You can use the built-in
    ASP.NET Core authentication and authorization mechanism if you need access control.
    You can then choose role-based or policy-based access control or any other way
    that makes sense for your tool and allows you to control access to the data the
    way you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping it simple should help you build more tools in less time, making everyone
    happy.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'From a layering standpoint, using my previous example, you will end up having
    two layers sharing the data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18: A façade-like presentation layer over a database application’s
    design](img/file92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.18: A façade-like presentation layer over a database application’s
    design'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing stops you from creating a **view model** here and there for more complex
    views, but the key is to keep the logic’s complexity to a minimum. Otherwise,
    you may discover the hard way that sometimes, rewriting a program from scratch
    takes less time than trying to fix it. Moreover, nothing stops you from using
    any other presentation tools and components available to you.Using this data-driven
    architecture as a temporary application while the main application is in development
    is also a good solution. It takes a fraction of the time to build, and the users
    have access to it immediately. You can even get feedback from it, which allows
    you to fix any mistakes before they are implemented in the real (future) application,
    working like a living prototype.
  prefs: []
  type: TYPE_NORMAL
- en: A good database design in these sorts of applications can go a long way.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not all projects are that simple, but still, many are; the key is to make the
    program good enough while ensuring you cut the right corners. The presentation
    layer in these types of applications could leverage a low-code solution such as
    Power Apps, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Layering is one of the most used architectural techniques when it comes to
    designing applications. An application is often split into multiple different
    layers, each managing a single responsibility. The three most popular layers are
    **presentation**, **domain**, and **data**. You are not limited to three layers;
    you can split each into smaller layers (or smaller pieces inside the same conceptual
    layer), leading to composable, manageable, and maintainable applications.Moreover,
    you can create abstraction layers to invert the flow of dependency and separate
    interfaces from implementations, as we saw in the *Abstract layers* section. You
    can persist the domain entities directly or create an independent model for the
    data layer. You can also use an anemic model (no logic or method) or a rich model
    (packed with entity-related logic). You can share that model between multiple
    layers or have each layer possess its own.Out of layering was born Clean Architecture,
    which guides organizing your application into concentric layers, often dividing
    the application into use cases.Let’s see how this approach can help us move toward
    the **SOLID** principles at app scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Layering leads us toward splitting responsibilities horizontally, with
    each layer oriented around a single macro-concern. The main goal of layering is
    responsibility segregation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Abstract layers enable consumers to act differently (change behaviors)
    based on the provided implementation (concrete layer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Splitting layers based on features (or cohesive groups of features)
    is a way of segregating a system into smaller blocks (interfaces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Abstraction layers lead directly to the dependency flow’s inversion,
    while classic layering leads in the opposite direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we learn how to centralize the logic of copying objects
    (models) using object mappers and an open-source tool to help us skip the implementation,
    also known as productive laziness.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a layered application, is it true that we must have presentation,
    domain, and data layers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is a rich domain model better than an anemic domain model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does EF Core implement the Repository and Unit of Work patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we need to use an ORM in the data layer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a layer in Clean Architecture access any inward layers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few links to help you build on what we learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dapper** is a simple yet powerful ORM for .NET, made by the people of Stack
    Overflow. If you like writing SQL, but don’t like mapping data to objects, this
    ORM might be for you: [https://adpg.link/pTYs](https://adpg.link/pTYs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An article that I wrote in 2017, talking about the Repository pattern; that
    is, « Design Patterns: ASP.NET Core Web API, services, and repositories | Part
    5: Repositories, the ClanRepository, and integration testing »: [https://adpg.link/D53Z](https://adpg.link/D53Z).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entity Framework Core – Using Transactions: [https://adpg.link/gxwD](https://adpg.link/gxwD).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are resources about Clean Architecture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common web application architectures (Microsoft Learn): [https://adpg.link/Pnpn](https://adpg.link/Pnpn)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft eShopOnWeb ASP.NET Core Reference Application: [https://adpg.link/dsw1](https://adpg.link/dsw1)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub—Clean Architecture (Ardalis/Steve Smith)—Solution templates: [https://adpg.link/tpPi](https://adpg.link/tpPi)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub—Clean Architecture (Jason Taylor)—Solution templates: [https://adpg.link/jxX2](https://adpg.link/jxX2)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No, you can have as many layers as you need and name and organize them as you
    want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, both have their place, their pros, and their cons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. A `DbContext` is an implementation of the Unit of Work pattern. `DbSet<T>`
    is an implementation of the Repository pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, you can query any system in any way you want. For example, you could use
    ADO.NET to query a relational database, manually create the objects using a `DataReader`,
    track changes using a `DataSet`, or do anything else that fits your needs. Nonetheless,
    ORMs can be very convenient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. A layer can never access outward layers, only inward ones.****
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
