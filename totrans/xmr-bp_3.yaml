- en: Chapter 3. Building a GPS Locator Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve deeper into code sharing. We will build a `Xamarin.Forms`
    application that integrates native GPS location services and Google Maps APIs.
    We will cover more content on IoC containers, the `Xamarin.Forms.Maps` library,
    and techniques for c-sharp `async` and background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Geocoding APIs (it helps to have a Google Developer account)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Core location and GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation with `Xamarin.Forms`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Maps integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Google Maps with `Xamarin.Forms.Maps`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core location with iOS and the `CLLocationManager` Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android and the `LocationManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Windows project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core location services with Windows Phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Application class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services and data contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with a Google APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Geocoding web service controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Newtonsoft.Json` and Microsoft HTTP client libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModernHttpClient` and client message handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feeding JSON data into the `IObservable` framework more reactive extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource (RESX) files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Geocoding web server controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnNavigatedTo` and `OnShow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pythagoras equirectangular projection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core location and GPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All mobile phone platforms have access to core location services. These services
    are background tasks that run in the background and update the latitude and longitude
    values at certain intervals indefinitely until the service is stopped. 99% of
    smart phones come with a built-in GPS tracker, allowing you to integrate these
    latitude and longitude values with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's jump straight into project setup and create a new `Xamarin.Forms` application.
    We are going to start by setting up an IoC container with **Autofac**, exactly
    the same as the previous project, import **Autofac** into all three projects (PCL,
    Android, and iOS). We can reuse a lot of the PCL code from the IoC container implementation
    in the previous project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The more apps you build, the more problems you solve; why reinvent the wheel
    over and over? Eventually, when you have built multiple applications, future apps
    will be built mostly from piecing parts of different projects together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy in the `IoC`, `Pages`, and `ViewModels` folders, and let''s start building
    our `MainPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is very much the same as the previous `MainPage`, but this time we are
    adding two `Buttons`, a `Label`, and an `Image`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before reading any further, have a look at the properties bounded to each element.
    See if you can build the properties for the view model.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation with Xamarin.Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start building any view models we are going to build our navigation
    system. `Xamarin.Forms` comes complete with navigation control for all platforms,
    so you won't have to worry about it. But as we always like to do things the hard
    way, we are going to show you a technique to separate our cross-platform structure
    a little more, in order to keep things more modular. Using one PCL project to
    contain both view models and views is great, but what if we could separate our
    views from view models into two PCL projects?
  prefs: []
  type: TYPE_NORMAL
- en: Why would we do this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One small issue we have with the current PCL is that it relies completely on
    `Xamarin.Forms`. Only our XAML sheets and user interfaces rely on `Xamarin.Forms`;
    our view models do not. Then let's move the view models from the `Xamarin.Forms`
    PCL into an even lower-level PCL project that only relies on c-sharp libraries.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good technique to keep the PCL projects completely separated. Developing
    a modular system is advantageous when it comes to code sharing. For example, we
    are building a new app that requires a login screen, a list view screen, and other
    similar screens most apps include. As we already have the view models that handle
    all the web services, JSON processing, and property bindings, do we really need
    to change much? Now that we have a low-level project that simply has the view
    models, let's just extract the ones we need, design our user interfaces for the
    view models, and bind them together. Not only can we reuse these view models for
    other apps, but if we wanted to develop an entirely separated application (for
    example, a WPF application), we can just compare the required screens, take the
    related view models, create new user interfaces, and bind them together. Keeping
    everything completely separated allows for complete plug-and-play capability,
    which will dramatically decrease the development time required to build similar
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s approach this pattern by creating a new PCL project and copying in the
    view models; call it **Locator.Portable**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why would we do this?](img/B05293_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also want to copy over the `IoC` folder as well.
  prefs: []
  type: TYPE_NORMAL
- en: Building the navigation control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first step is to create a folder called `enum`, add the `PageNames.cs`
    file, and copy in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a new folder called `UI` and create a new file called `INavigationService.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a new folder in the `Xamarin.Forms` PCL (Locator) project called
    `UI`, and create a new file called `NavigationService.cs`. The `NavigationService`
    class will inherit the `INavigationService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple, right? Navigate will be used whenever we want the stack to navigate
    to a page. In making an abstracted interface, as we have done for navigation,
    this allows us to control navigation way down in the lower-level PCL. Now, fill
    in the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, look more closely at the private function `GetPage`; this will be called
    every time the `Navigate` function is called to retrieve the correct `ContentPage`
    object (which is registered in the `IoC` container) based upon the `PageName ``enum`
    passed to it, and if we have found the correct page, push it onto the navigation
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s build our new `XamFormsModule` for registering the pages and
    navigation service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are registering one navigation page throughout the entire life of the application,
    and we set the starting page to the one main page item we registered before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open up the `App.cs` file and update it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Making sense now?
  prefs: []
  type: TYPE_NORMAL
- en: IoC is a very powerful pattern for cross-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: View model navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s get back to our `MainPageViewModel` and update and modify the previous
    chapter''s `MainPageViewModel` with the properties required for the data-bindings
    on `MainPage.xaml` shown previously. Firstly, let''s implement the `private` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the `Public` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Are we starting to see the same pattern here?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the constructor, which is going to use the navigation service interface
    that we abstracted earlier through the `IoC` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to show you another trick using the IoC container. In our constructor,
    we need to be able to create a new `Command` object from the `Xamarin.Forms` library.
    We are lucky here, because since commands from `Xamarin.Forms` inherit the `ICommand`
    interface from `System.Windows.Input`, we are able to register this object in
    the IoC container. Open up `XamFormsModule.cs` and update the `Register` function
    to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take note that we are registering this type as an `InstancePerDependency` because
    we want an independent instance every time we create a command in the view model
    constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a new command through the constructor of `MainPageViewModel`;
    update the constructor like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we are pulling a `Func` out of the `IoC` container, which
    takes an Action and returns an `ICommand` object, because we have registered this
    interface to a `Xamarin.FormsCommand` object, we will be left with a new `Command`
    with the action passed in the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as doing this if we were using the `Xamarin.Forms`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a new `Command` set with and `Action` to push a new `MapPage` onto
    the stack when the button is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now to register our new view model with the `IoC` container. Create a new folder
    called `Modules` for the portable `IoC` module. Create a new file called `PortableModule.cs`
    and paste in the preceding code into it.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Google Maps using Xamarin.Forms.Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next step is to implement the `MapPage`; this page will show a panel that
    will display Google Maps. Underneath this panel, we will also display the location
    information (latitude, longitude, address, and so on) retrieved from our native
    platform core location services. To access these native services, we need to import
    `Xamarin.Forms.Maps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating Google Maps using Xamarin.Forms.Maps](img/B05293_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have imported the `Xamarin.Forms.Maps` library, we can access the
    native Google Maps services. We can now create the `Map` user interface element
    via `MapPage.xaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See at the top how we imported the `Xamarin.Forms.Maps` library?
  prefs: []
  type: TYPE_NORMAL
- en: We have created four rows in the `Grid`, one for the `Map` (this will cover
    most of the screen), one for a label that will display the address, and two buttons
    for starting/stopping location updates and finding the closest location out of
    a list of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: So where does the address come from?
  prefs: []
  type: TYPE_NORMAL
- en: We now need to implement the core location service; this is a background service
    that will send position information based upon your location. The information
    returned is very detailed; we can depict exact longitude and latitude values,
    as well as addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Core location services can drain device battery life, so when using core location,
    we must manage the usage and turn it on and off when required. As this is a background
    service, when the app is placed in the background, the location service will still
    be running.
  prefs: []
  type: TYPE_NORMAL
- en: To begin our core location implementation, we are going to create an abstracted
    geolocation interface called **IGeolocator**, but first we are going to add another
    library for processing our location updates.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't heard of the RX framework before, you are about to enter a never-ending
    rabbit hole of asynchrony. RX gives developers the ability to use LINQ-style query
    operations for processing objects in observable sequences. It allows for full
    control over event-based operations between different elements of an application.
  prefs: []
  type: TYPE_NORMAL
- en: In our project, we are going to use a **Subject** for handling location events
    received on the native side. In cross-platform development, because we work in
    both PCL and native-level projects, it involves passing data and events up and
    down the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the `event` framework, which is standard in c-sharp, but instead
    we are going to use a `Subject` to push events into an observable sequence, while
    we subscribe to the subject at a lower level to receive and handle these events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the **Reactive Extensions** interface in our native
    and PCL projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reactive Extensions](img/B05293_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s create our `IGeolocator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the interface `IPosition`? We must also create a new interface, which
    is going to store all the location information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The interface is designed to return these variables to be used for the `Xamarin.Forms`
    geolocator, so we can pull down address information. This information is returned
    by `CLLocationManager` with every position update.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to create an interface for the position information?
  prefs: []
  type: TYPE_NORMAL
- en: As this information comes from different native services, we want to create
    our own object to contain the information we need in the lower-level projects.
  prefs: []
  type: TYPE_NORMAL
- en: Core location with iOS and the CLLocationManager library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CLLocationManager` is used for the delivery of location and heading events;
    we must use this object in our Geolocator implementation, so let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'From our interface, we must include the `Subject`. Now let''s instantiate `CLLocationManager`.
    First, we must import the `CoreLocation` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we instantiate `CLLocationManager` in the constructor when this is created
    through the IoC container. According to iOS standards, since changes to iOS 9
    and iOS 8, we must implement a few separate calls to allow the location manager
    to begin sending location events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nothing major; in iOS 8 we must request the authorization before using
    the location manager. For iOS 9, we can also set some conditional settings. For
    our example, we have used this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows the location manager to keep sending events, even when the app
    is in the background. We can also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will only allow events from `CLLocationManager` when the app is in the
    foreground. There are multiple settings that can be changed, between controlling
    location events in the foreground and background when using location services.
    We want to know whether our app is going to keep updates running in the background/foreground.
    Most of the time, we want location updates when the app is in the foreground to
    reduce battery consumption, but there are scenarios where updates should continue
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the rest of the class; let''s begin handling the location events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The previous function is called every time we receive a location update from `CLLocationManager`.
    From the event argument `CLLocationsUpdatedEventArgs`, we pull out a list of locations;
    as sometimes the `CLLocationManager` receives multiple updates at one time, we
    always want to take the very last location. Then once we create a new `Position`,
    assign the latitude and longitude values, and by calling the `OnNext` function,
    we push a new event into the observable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to add some small additions to the `info.plist` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code is from the source of the `info.plist` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSLocationAlwaysUsageDescription` and `NSLocationWhenInUseUsageDescription`
    keys will be displayed to the user in the alert that requests location data access.
    We must also add the background modes for the location in which we can set the
    iOS project properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Core location with iOS and the CLLocationManager library](img/B05293_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we must implement the `Start` and `Stop` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Start` function will check whether location services have been enabled,
    assign the `LocationsUpdated` event, and start the location updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `Stop` function will do nothing more than stop the location updates and
    remove the event handler. That's all for the iOS geolocator. Next, we must register
    this interface through the IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Handling location updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next step is to build the `MapPageViewModel`; this view model will contain
    the `IGeolocator` we just built. We will also be listening for location updates
    from the observable sequence and processing latitude and longitude values to gather
    address details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our constructor will retrieve the navigation service and the geolocator. Notice
    how we assign the `geolocator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will also be responsible for creating the commands for the
    two buttons on our map page. Any view models that require objects from the IoC
    container are usually assigned as read-only properties because they will never
    change. We want the property name to be the exact same as the item in the constructor
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create our private properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have a new object, the `IDisposable` interface, which is used to take control
    of unmanaged resources, meaning we can release objects that have no control over
    memory disposal. In our case, we are going to be setting up a subscription to
    the events received via the observable sequence (`Subject`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this technique more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use these functions to be called when the `MapPage` appears
    and disappears. The `OnAppear` function will create a subscription to the `Subject`,
    so whenever a new position is pushed onto the observable sequence, we will receive
    an item on the other side where we subscribed. In this case, we will be calling
    the `OnNext` function on a different subject, meaning we are passing the item
    of the observable sequence into another observable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: What a pointless function. We will show you why soon.
  prefs: []
  type: TYPE_NORMAL
- en: We are also assigning the subscription to our `IDisposable`. A subscription
    is an unmanaged resource, meaning that without the use of an `IDisposable`, we
    can't control the release of the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to worry about disposing of the subscription?
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes our observable streams may be propagating events to a user interface
    on the main UI thread. If we change pages, and the previous page's view model
    is still receiving events to update the previous page's interface, this means
    the events will be changing the user interface on a different thread from the
    main UI thread, which will break the application. This is just one example, but
    cleaning up subscriptions when we aren't using them is a good practice to control
    unwanted application processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `public` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need is a string that will be bound to `MapPageLabel` under the map
    item. It will be used to display the address of the current location. Now we must
    create a label on `MapPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our next step is to make use of the latitude and longitude values that we receive
    from `CLLocationManager`. We are going to use the `Geocoder` class to get address
    information from our positions. A `Geocoder` class is used to convert positions
    (latitudes and longitudes) into address information. We could actually do this
    conversion on the native side, but the idea of this exercise is to show you what
    is available in `Xamarin.Forms` to share between the different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's get back to answering the questions about passing events between two
    observable sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building the `MapPage.xaml.cs` sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create another two `IDisposables` for handling the events from the
    view-model. We will also be subscribing to and disposing on the page''s appearing
    and disappearing events, so now add the `HandleAppearing` and `HandleDisappearing` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create a new `Geocoder`, so every time we receive an event from the
    observable sequence in the view model, we use this position to retrieve the address
    information from `Geocoder` via the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'That is everything we need to retrieve our latitude and longitude positions,
    as well as update the current address. The last step of our iOS version is to
    update the position on the map; we want the map view to zoom in to our current
    position and place the blue marker on the map. Next, we add the following to the
    end of `LocationChanged` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `MoveToRegion` function requires a `MapSpan`; a `MapSpan` is created from
    the latitude, longitude point and the radius from the position point. A circle
    will be drawn from the point to give the view radius to be shown on the map; in
    our case the radius is 0.3 miles around the latitude and longitude position.
  prefs: []
  type: TYPE_NORMAL
- en: The `ContinueWith` function is used to execute some extra work as soon as the
    task finishes. As soon as we have retrieved all the possible address names, we
    wake the first on the list and assign it to the `Address` property of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final step is to complete the rest of the project; we must first create
    an iOS module for registering the geolocator class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then finally we add the extras to the `AppDelegate.cs` file (exactly the same
    as the previous example iOS project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Let's run the project and click on the **Find Location** button.
    Watch the map update with the address shown in the preceding label.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the Android project and implement the same features.
  prefs: []
  type: TYPE_NORMAL
- en: Android and the LocationManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android `LocationManager` works like the `CLLocationManager`, but we will
    use an observable sequence to handle location updates. When a location update
    is received, a new Position object is instantiated with the latitude and longitude
    values from the location update. Then the resulting Position is pushed on to the
    Geolocator's Subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we create the `Geolocator` implementation. It must also inherit the `ILocationListener`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed the `#define` keywords. These are useful for separating
    different sections and for referencing locations in code sheets, making code more
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: The only one we are concerned about is the `OnLocationChanged` function; whenever
    a location update is received by the location manager, the listener function will
    be called with the latitude and longitude values, and we will then use these values
    to push into the observable sequence for the `Geocoder` and `MapSpan`.
  prefs: []
  type: TYPE_NORMAL
- en: We also have to implement the extra requirements for the `ILocationListener`
    interface. Since this interface inherits the `IJavaObject` interface, we are required
    to implement the `Dispose` function and the `IntPtr` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save time, we can have the class inherit the `Java.Lang.Object` class like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we pull out the required system service using the `GetSystemService`
    function for the location service. The line underneath simply retrieves the `NetworkProvider`
    of the `LocationManager`; we need to use this for starting the location updates.
    There are further configurations we can set for retrieving correct providers (mainly
    logging purposes), but in this example we aren't going to bother too much as we
    are only interested in retrieving location positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to implement the other required functions of the `IGeolocator`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `Start` function will first check whether we have these services enabled,
    then by calling the `RequestLocationUpdates` function, we pass in the provider,
    the minimum time between locations updates, the minimum location distance between
    updates, and the pending intent to be called on each location update; in our case,
    this is the geolocator (the same class that started the location updates) as we
    have implemented the `ILocationListener` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Stop` function simply removes the updates from the `Geolocator`, which
    in turn will stop the location updates from the location manager. Our next step
    in implementing the Android `Geolocator` is to create the Android IoC module,
    and register this implementation in the IoC container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final step is to set up the `MainActivity` class, which is exactly the
    same as the previous project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take note of how much code we are starting to reuse from previous projects.
    Why reinvent the wheel when we can save a lot of time by pulling from similar
    problems that have already been solved in other projects?
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in the Android project is to apply some Android permissions to
    allow your app to use location services. Open up the `Mainfest.xml` and add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `<application>` tag, we have to place `API_KEY`, which is generated
    from the Google APIs platform (we will be doing this later). We then have to add
    the `ACCESS_FINE_LOCATION`, `ACCESS_COARSE_LOCATION`, and `ACCESS_NETWORK_STATE`
    permissions for **LocationManager** to work. We can switch these permissions on
    through the **Application** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android and the LocationManager](img/B05293_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an exit point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed the extra button added on the starting page for exiting
    the application. We will have to go ahead and create an abstracted object for
    exiting the application. Start by creating a new folder called `Extras`, then
    create a new file for the `IMethods` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before moving on with the tutorial, have a go at implementing the native side
    for each project on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the iOS version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For the iOS version, we must dig into the `SharedApplication` object and perform
    a selector method `terminateWithSuccess`. We must then register this new object
    in our iOS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the Android implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Android operating system namespace, we use the static item `Process`
    to call the function `KillProcess` on the main process. Again, we also register
    this within the IoC container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the `IMethods` interface in our `MainPageViewModel` to call
    the exit function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this more closely, we are using the command factory to initialize
    the exit command to a new `Xamarin.Forms Command`, and when this command is executed,
    it will call the `Exit` method from the `IMethods` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Our last step is to create an API key using the Google APIs for our Android
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API key for Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for us to create an API key, we will have to access the Google API
    portal. Android requires this extra step when configuring Google Maps:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need a Google Developer account to complete this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the following link to create a new project in the API portal: [https://console.developers.google.com/iam-admin/projects](https://console.developers.google.com/iam-admin/projects).![Creating
    an API key for Android](img/B05293_03_06.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create Project** from the top menu and call the project `Locator`:![Creating
    an API key for Android](img/B05293_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on setting up an API key, visit this link: [https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have our new project, visit the API Manager and select the **Google
    Maps Android API**:![Creating an API key for Android](img/B05293_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Enable** button, then click **Credentials** from the left-hand
    menu. We want to create a new **API key** from the drop-down list:![Creating an
    API key for Android](img/B05293_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure we select an **Android key**:![Creating an API key for Android](img/B05293_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to leave the name as `Android key 1`. Now click the **Create**
    button:![Creating an API key for Android](img/B05293_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, let's select our Android key and place it in the `AndroidManifest.xml`
    file where it states `YOUR-API-KEY`:![Creating an API key for Android](img/B05293_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations, we have now integrated the iOS and Android location services
    with Google Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the Windows Phone version.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Windows project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving on to Visual Studio once again, let start by creating a new c-shape
    universal Windows project and calling it `Locator.WinRT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our Windows project](img/B05293_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can remove the Windows store and shared projects. Before you remove the shared
    projects, move the `app.xaml` files into the Windows Phone project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Map` object from `Xamarin.Forms.Maps` is not usable in Windows Phone 8.1\.
    We have to use the universal platform instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Windows Phone version, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Windows Phone module for registering the geolocator and methods interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement the geolocator interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement the methods interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have a think about that for a second...
  prefs: []
  type: TYPE_NORMAL
- en: '**That''s all we have to do to replicate the application for Windows Phone?**
    Think how much extra work would be involved if we were to rebuild this app from
    scratch entirely on the Windows platform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the three folders, `Modules`, `Location`, and `Extras`, and create
    a new `.cs` file for each folder and name them accordingly: `WinPhoneModule.cs`,
    `GeolocatorWinPhone.cs`, and `WinPhoneMethods.cs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we have to change the targets of the PCL projects to be compatible
    with the Windows Phone frameworks. Select the **Windows Phone 8.1** target for
    both PCL projects, then the Windows project can reference the two PCL projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our Windows project](img/B05293_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We must also import the `Xamarin.Forms`, `Xamarin.Forms.Maps`, and `Autofacnuget`
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Core Location Services with Windows Phone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now for the exciting part. Let''s integrate the core location services. First,
    we must turn on certain permissions. Open up the `package.appmanifest` file, select
    the **Capabilities** tab, and select the **Location** checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Core Location Services with Windows Phone](img/B05293_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Secondly, open the `GeolocatorWinPhone.cs` file, and let's start building the
    Windows Phone locator class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We are implementing a native `Geolocator` from the interface `IGeolocator`,
    meaning we need to create an observable sequence for the positions. We also need
    a `Geolocator` object to receive location updates, which we will use to push events
    into the sequence. With all native locators, we can set accuracy for location
    points, which is what we are doing with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to implement the `Start` and `Stop` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Start` function uses `Geolocator` to retrieve the positions with the asynchronous
    function `GetGeopositionAsync`. The function will take the maximum age of a location,
    meaning once the time period is passed, the location will update again. The request
    for this location will cancel when the timeout value is reached during a location
    update. We also listen on the event handler `PositionChanged` via the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We actually have two places, which will push a new geoposition's latitude and
    longitude into the observable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add the `Stop` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: All this does is remove the event handler function that we assigned in the `Start`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be noticing the development patterns with this project, how we implement
    abstracted interfaces, generate modules, register types, and so on. The processes
    are all the same, no matter what platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all for the `Geolocator` class; we can now get on to the `WinPhoneModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now let's get to the `WinPhoneMethods` class. We only need to implement the
    one function, `Exit`.
  prefs: []
  type: TYPE_NORMAL
- en: The Application class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The static class `Application` plays a similar role to the iOS `UIApplication`
    class. We simply reference the current application, and terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we simply build the remaining elements with the `MainPage.xaml` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And we do it for the `MainPage.xaml.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Exactly the same as the previous chapter, we are starting the `IoC` container,
    adding our modules, and loading the `Xamarin.Forms.App` object. The only difference
    is the `SharedModule`, as we pass in true so the `NativeMessageHandler` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have one more issue to address. Since `Xamarin.Forms` 1.5, only
    Windows Phone Silverlight is supported for using Google Maps. We have to add an
    additional library to use maps in Windows Phone 8.1.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Personal thanks to *Peter Foot* for addressing this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, an open source library is available to address this issue. We must
    install the nuget package `InTheHand.Forms.Maps`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This library is only available up to `Xamarin.Forms` 2.1.0.6529, meaning this
    entire example must stick to this version of `Xamarin.Forms`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside `App.xaml.cs`, we need to initialize `Xamarin.Forms` and `Xamarin.Forms.Maps`.
    The `Xamarin.Forms.Maps` framework is initialized through the library `InTheHand.Forms.Maps`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Just like that, we now have the application on Windows Phone. Now that we have
    core location services running with Google Maps, let's take things one step further
    with the Google API platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Web services and data contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to look at creating a web service controller to access web
    services provided by Google. These are useful implementations for downloading
    JSON data, deserializing it, and feeding this data in observable sequences for
    processing. With a web service controller, we get to use more of the `IObservable`
    interface. These sequences will be used to take in deserialized JSON objects from
    a web source, and feed these into our view models.
  prefs: []
  type: TYPE_NORMAL
- en: Our web service controller will be kept inside the **Locator.Portable** project.
    Remember, we can share this work across the different platforms as all use some
    form of HTTP client to connect to a web URL.
  prefs: []
  type: TYPE_NORMAL
- en: What about data contracts?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your data contract is a JSON object that is used to absorb the elements of the
    deserialized objects, so whenever we pull down raw JSON data, your contract will
    be the deserialized object or objects.
  prefs: []
  type: TYPE_NORMAL
- en: So the next question is, what data are we pulling to our application?
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the Google `Geocoder` API to turn address information into
    latitude and longitude positions. We are going to pull down a list of addresses,
    calculate their latitude and longitude positions, calculate the closest address
    to our current position, and place a pin on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to create a new folder called `WebServices` in `Locator.Portable`.
    Inside this folder, we want to create another folder called `GeocodingWebServiceController`,
    and another folder inside this called `Contracts`. Let''s first implement our
    contracts. A nice quick easy way to implement your JSON objects is to use an online
    application like this one: [http://json2csharp.com/](http://json2csharp.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are pulling down JSON data, it takes time to look through the text
    and find all the properties required for your JSON object. This provides a nice
    way is to call the web service URL, retrieve some sample JSON data, and paste
    this JSON data into the box here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What about data contracts?](img/B05293_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Personal thanks to **Jonathan Keith** for saving us time.
  prefs: []
  type: TYPE_NORMAL
- en: This application creates c-sharp JSON objects based on the JSON data you entered.
    Now let's get our sample JSON data to paste in the box, but before we can do this
    we have to access the **Google API**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating another API key for geocoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Log back in to the Google Developer console, and our first step is to enable
    to the Geocoding API from the API manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating another API key for geocoding](img/B05293_03_17-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then select the project `Locator` we created earlier, and this time we are
    going to create a browser key to access the Geocoding API via HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating another API key for geocoding](img/B05293_03_18-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the key `Geocoding Key` and click **Create**. We are now going to use
    this key for every HTTP request passed to the Geocoding API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating another API key for geocoding](img/B05293_03_19-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating GeocodingWebServiceController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first step creating `GeocodingWebServiceController` is to hit the web URL
    using your API key to pull down some sample JSON data; here is a test link: `https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=YOUR_API_KEY`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where it says `YOUR_API_KEY`, replace this text with your newly created API
    key, and then paste this link into the browser. You should get JSON results like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to copy and paste the entire resulting JSON into **Json2Sharp**
    to create our c-sharp objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating GeocodingWebServiceController](img/B05293_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are quite a few JSON objects, so in the `Contracts` folder, create the
    following files:'
  prefs: []
  type: TYPE_NORMAL
- en: AddressComponentContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeocodingContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeocodingResultContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeometryContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LocationContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NortheastContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SouthwestContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ViewportContract.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin with `AddressComponentContract.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Make sure we keep all these contracts in the namespace `Locator.Portable.GeocodingWebServiceController.Contracts`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Namespaces should be named according to the folder hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `GeocodingContract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the files are exactly the same; we simply copy the c-sharp objects
    created by **Json2Sharp**. Now it''s time to complete the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you double-check the property names are exactly the same as the JSON
    properties, otherwise the values inside the JSON string will not be deserialized
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not going to paste in every contract, as this should be enough direction
    for you to build the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our geocoding contracts, let''s create the interface for the
    `GeocodingWebServiceController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is only a small interface; we only have one function, `GetGeocodeFromAddressAsync`.
    The function requires three arguments to build the parameters in the web URL.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's implement this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good practice with object-oriented and abstract coding is to declare interfaces
    before implementing the class which coincides; it will help you build the class
    quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Newtonsoft.Json and Microsoft HTTP client libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we are going to be deserializing JSON, we will need to import a JSON framework
    library. Newtonsoft is one of the most commonly used frameworks, so let''s import
    this library into our **Locator.Portable** project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will also need to import the HTTP client libraries for our web service controller
    to access online web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have all the extra libraries for our **Locator.Portable** project,
    before we implement the `IGeocodingWebServiceController`, we have to make some
    additions to the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the **Locator** and create a new shared project called **Locator.Shared**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ModernHttpClient and client message handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, we will be creating a shared module to register a `HttpClientHandler` class
    in the IoC container. `HttpClientHandler` is a message handler class that receives
    a HTTP request and returns a HTTP response. Message handlers are used on both
    the client and server side for handling/delegating requests between different
    end points.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are interested in the client side, as we are calling the
    server; our client handler will be used to handle our HTTP messages sent from
    the HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by adding the `ModernHttpClient` library to our **Locator** (we
    will refer to this project as the `Xamarin.Forms` project) and all native projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ModernHttpClient and client message handlers](img/B05293_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also want to add the Microsoft Client Libraries package to all native projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our shared project, remember we can''t import libraries; these projects
    are only used to share code sheets. In this project, we want to create a folder
    called `Modules`. In the `Modules` folder, create a new file called `SharedModule.cs`
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: One thing to notice is the minor change we have to make between the iOS and
    Android projects, and the Windows Phone project. Windows must use `NativeMessageHandler`
    for the `HttpClientHandler` in the IoC container. In iOS and Android, we can use
    a default `HttpClientHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: We tell the client handler that we not going to be using cookies, and we allow
    for automatic decompression on the data being pulled through the client handler
    (**GZIP** is a common form of JSON data compression).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's focus our attention on the constructor. We simply pass in a `bool`
    to determine whether we are using Windows to register the correct type of message
    handler for the current platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add this module to the registration in the `AppDelegate` and `MainActivity`
    file; it must be called before the `LoadApplication` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We now have access to our HTTP client handler in the IoC container,
    so let''s start building the `GeocodingWebServiceController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Feeding JSON data into the IObservable framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we are going to be registering this web service controller in the IoC container,
    we can pull out the client handler we just created and registered in the `SharedModule`
    class. Now we must implement the function we defined in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: It may look a bit daunting at first, but let's break it down. Our web service
    controller is going to pull down data, deserialize the data into our main JSON
    object `GeocodingContract`, and create contracts in an observable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: When we instantiate a new `HttpClient`, we must pass in our registered client
    handler to delegate the request messages being sent from the HTTP client. We then
    create a new `Http.Get` message; this will be sent from the `HttpClient` and delegated
    through the message handler (`HttpClientHandler`), which in turn will receive
    a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: This is where it gets tricky. Look at the `Observable.FromAsync` function; this
    method takes an asynchronous function, will run and await the function, and will
    return data as an observable sequence. The asynchronous function must return an
    `IObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: The function we are passing is the `SendAsync` function of the `HttpClient`;
    we then use the RX function `SelectMany` to take all the response objects. If
    each response object incurs a HTTP status code `200` (`OK`), we return the response
    content as a string. Notice the `async` keyword in front of the expression; we
    have to use an asynchronous function to await the `ReadAsAsync` function and return
    the response content as a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the RX function `Select` to take each response string and return
    the deserialized `GeocodingContract`. This contract will be fed into the observable
    sequence and returned to the original caller `Observable.FromAsync`, which in
    turn will be the data returned from the function.
  prefs: []
  type: TYPE_NORMAL
- en: More Reactive Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on, let's talk more about the RX functions we just used. The
    `Select` function is used for iterating over any `List`, `Enumerable`, or `IObservable`,
    and taking the value of each item to create a new observable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a list of objects with a string property `Name`, and we do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We are simply returning the same sequence of items, but then we do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Our new sequence would be a stream of just the `Name` property for each object.
    These functions are very useful for filtering streams and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Resource (RESX) files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Notice in our `GetGeocodeFromAddressAsync` function we are referencing a static
    class, `ApiConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This is a technique for containing your application's resources, such as strings,
    URLs, constant variables, settings properties, and so on. It is also used for
    languages in which we have different constant variable values, based on language
    settings. This is normally how you would make your app multilingual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new folder called `Resources` inside the **Locator.Portable**
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resource (RESX) files](img/B05293_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `ApiConfig.Designer.cs` file, we must have the namespace set according
    to the folder hierarchy. In this example, it is **Locator.Portable** | **Resources**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Locator.Portable** is the name assigned to our assembly. We must know the
    assembly name to reference where the folders will be stored when the app is built.
    To find out the name of your assembly, visit the properties page, shown in the
    next screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resource (RESX) files](img/B05293_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our `ApiConfig.resx` file, let''s add a variable for the `GoogleMapsUrl`
    property; paste the following in the `ApiConfig.resx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you save this file, you will notice the `ApiConfig.Designer.resx` file
    is automatically generated, meaning the namespace may change to incorrect folder
    paths. Sometimes we have to manually change the folder path every time this file
    regenerates.
  prefs: []
  type: TYPE_NORMAL
- en: Using GeocodingWebServiceController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have set up our web service controller, let''s integrate it with
    our `MapPageViewModel`. Our first step is to register the web service controller
    inside the IoC container; open up `PortableModule.cs` and add the following to
    the `Register` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we update the constructor inside `MapPageViewModel` to use `GeocodingWebServiceController`
    from the IoC container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to add an array of static addresses as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use the geocoder API to determine latitude and longitude positions
    of all these address locations, and from your current location, determine which
    one is closer.
  prefs: []
  type: TYPE_NORMAL
- en: OnNavigatedTo and OnShow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go any further with the Geocoding API, we need to make some additions
    to the navigation setup. Let''s begin by implementing the `OnNavigatedTo` function
    for all content pages. Create a new file called `INavigableXamFormsPage.cs` and
    paste in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the `internal` keyword; this is because this class will never leave the
    `Xamarin.Forms` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want every page to inherit this interface and create the `OnNavigatedTo`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to call the `OnNavigatedTo` function every time a page is navigated
    to. First, let''s update our interface for the `NavigationService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open up the `NavigationService` class and update the `Navigate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: After the page is pushed, we then call the `OnNavigatedTo` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to do a similar thing with page view models. In your `ViewModelBase`
    class, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `OnShow` function will take in the navigation parameters from the coinciding
    page's `OnNavigatedTo` function.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the RX approach with handling asynchronous functions when the `LoadAsync`
    has finished?
  prefs: []
  type: TYPE_NORMAL
- en: We have options to handle results and errors from the `LoadAsync` function.
    You may have also noticed the short expressions used with arrows. This type of
    syntax is known as lambda expressions, a very common c-sharp syntax for abbreviating
    functions, arguments, and delegates. Our `LoadAsync` is also virtual, which means
    any page view model that implements this interface can override this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make some extra additions to the `Xamarin.Forms` project (`Locator`).
    Create a new file in the `UI` folder and call it `XamarinNavigationExtensions.cs`.
    Now for the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at this more closely, we are actually making extension functions for
    all `ContentPage` types. The `OnShow` function for a `ContentPage` will extract
    the binding context as a `ViewModelBase` and call the `OnShow` function of the
    view model, which in turn will call `LoadAsync`. Finally, we make the changes
    to `MapPage.xaml.cs` and `MainPage.xaml.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Well done! What we just implemented is a Windows Phone principle. We know that
    when the `OnNavigatedTo` function is called, our layout for the `XAML` sheet is
    already sized accordingly. The advantage of having this is we can now retrieve
    x, y, height, and width figures from the page inside this function.
  prefs: []
  type: TYPE_NORMAL
- en: Pythagoras equirectangular projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now back to the Geocoding API. We are going to implement the math behind calculating
    the closest address to a latitude and longitude (current position).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first step, we need to add some properties for `MapPageViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the extra `public` property, which will hold the string address of
    the closest position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to add another `Subject` sequence for when the closet position
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This must be initialized in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now for the fun part.
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to calculate the closest position?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the first private function, which will get the positions
    from the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we finally get to use our `GeocodingWebServiceController`.
  prefs: []
  type: TYPE_NORMAL
- en: See how we pass in the variables that will make up the web service URL?
  prefs: []
  type: TYPE_NORMAL
- en: For each address, we must ping this API call to get the latitude and longitudes
    required to calculate the closest position. Then we do a bunch of checks on the
    values in the data contracts to make sure they aren't null, until we get the `GeometryContract`
    values; we will then use these to create a new position and add it to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make a small change to the `Position` class and interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Add the `Address` property so we can record the address string for the closest
    property. We need to record this in the position because as we fire off so many
    requests to the API, they will not necessarily finish in order so we can't expect
    to use index referencing to obtain the position index in the list, to be the coinciding
    address in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the mathematical functions for calculating distances using the
    `PythagorasEquirectangular` projection. It uses angular projection to calculate
    the distance between two coordinates on a map plane. We also need a `DegreesToRadians`
    conversion for the `PythagorasEquirectangular` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If the distance falls outside the radius value, it will not be used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try playing around with this setting to see the results you get.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `FindNearestSite` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We will call this when all the geocodes for the address have been obtained and
    added to the positions list. We then go through all the positions and compare
    each to our current position, determine which coordinate difference is the smallest,
    and use this as our closest position. Then we push a new position onto the `ClosestUpdates`
    observable sequence, which we will subscribe to on the `MapPage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last step on the `MapPageViewModel` is to override the `LoadAsync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This is where everything will kick off; when the page loads, it will iterate
    through every address and download the geocode, then once we count the entire
    count of the address list, we find the nearest positions and push onto the `ClosestUpdates`
    sequence. We also want to run the `GetGeocodeFromAddress` function in parallel
    for each address; this is why we have `ConfigureAwait` set to false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make changes to the `MapPage`. We are going to use two `IDisposables`
    now for the `MapPage`, one for each subject in the view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we update the `OnAppear` and `OnDisappear` functions to handle the subscribing
    to and disposing of the `Subjects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And our final touch is to add the function that is called every time for the
    `ClosetUpdates` observable sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a pin to place on the map. This pin will also show the address
    information when we click on the pin. We then move to the region on the map to
    show this pin, using the `MoveToRegion` function.
  prefs: []
  type: TYPE_NORMAL
- en: That is everything; we have now integrated with Google Maps and Geocoding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed development with `Xamarin.Forms` and `Xamarin.Forms.Maps`.
    We learned how to implement location services on each platform, handling backgrounding
    location update events and using latitudes and longitudes to calculate positions.
    Have a play around with the application on all three platforms, and watch how
    the location updates and nearest positions update the regions on the map. In the
    next chapter, we will jump back into native development, and build an application
    that will control a sound file like an audio player.
  prefs: []
  type: TYPE_NORMAL
