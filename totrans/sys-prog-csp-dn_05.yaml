- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: The One with the Filesystem Chronicles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统编年史
- en: '*File Systems* *and IO*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件系统* 和 IO'
- en: Computers are incredible machines, but they have one downside. If the power
    goes off, they forget everything. If we do not want to lose our work, we must
    store it elsewhere. We can print data, put it on the network, or store it in permanent
    storage. This is the most common option. Of course, we need to have a way to get
    data into the CPU. We can read data from a file or a network. We can even use
    the keyboard to enter data. This is something that both you (a programmer) and
    I (a writer) are very familiar with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是令人难以置信的机器，但它们有一个缺点。如果电源关闭，它们会忘记一切。如果我们不希望丢失我们的工作，我们必须将其存储在其他地方。我们可以打印数据，将其放在网络上，或者存储在永久存储中。这是最常见的选项。当然，我们需要一种方法将数据输入
    CPU。我们可以从文件或网络中读取数据。我们甚至可以使用键盘输入数据。这是我们（程序员）和我（作者）都非常熟悉的事情。
- en: When we are programming software, we refer to the concept of **streams**. A
    stream represents a sequence of data elements made available over time. This sequence
    can be stored on a disk, it can be data flowing over network wires, or it can
    be the state of a memory chip. Data must flow back and forth no matter what physical
    medium we use. This chapter handles that topic, covering streams, files, and other
    ways of **Input and** **Output** (**IO**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写软件时，我们提到 **流** 的概念。流表示随时间提供的一系列数据元素。这个序列可以存储在磁盘上，可以是通过网络线缆流动的数据，也可以是内存芯片的状态。无论我们使用什么物理介质，数据都必须来回流动。这一章处理这个主题，涵盖流、文件以及其他
    **输入和输出**（**IO**）的方式。
- en: One thing that we will not dive into in this chapter is the topic of networking.
    Networking is such a different concept that a separate chapter will deal with
    this topic. You can find all the low-level networking details in [*Chapter 8*](B20924_09.xhtml#_idTextAnchor181).
    However, the concepts of data handling over that network are the same for files
    and other media. So, the principles laid out here still apply.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不会深入探讨的主题是网络。网络是一个如此不同的概念，以至于将有一个单独的章节来处理这个主题。您可以在 [*第 8 章*](B20924_09.xhtml#_idTextAnchor181)
    中找到所有低级网络细节。然而，通过网络处理数据的概念对于文件和其他媒体是相同的。因此，这里阐述的原则仍然适用。
- en: 'In this chapter, we cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to work with files using .NET
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 .NET 处理文件
- en: How to use Win32 APIs to work with the filesystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Win32 API 与文件系统交互
- en: How to work with Directory and Path
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理目录和路径
- en: Why and how we should use asynchronous IO
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么以及如何使用异步 IO
- en: How to use encryption and compression
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用加密和压缩
- en: We have a lot of ground to cover, so let’s dive in!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多内容要覆盖，所以让我们深入探讨吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To view all the code in this chapter, you can visit the following link: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章中的所有代码，您可以访问以下链接：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05)。
- en: File writing basics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件写入基础
- en: 'There cannot be anything more straightforward than writing to a file, right?
    That’s why I think that that is a good starting point. Here is the code to do
    so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比写入文件更直接的了，对吧？这就是为什么我认为这是一个好的起点。以下是实现这一点的代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line gets the system `temp` path. Then we specify the filename, add
    that to the `temp` path, and write a line of text to that file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行获取系统 `temp` 路径。然后我们指定文件名，将其添加到 `temp` 路径中，并向该文件写入一行文本。
- en: This example is simple enough, but it already shows something useful. First,
    we can get to the `temp` folder quickly; we don’t have to specify where that is
    in our code. Second, we can combine the filename and the path without worrying
    about the path separator. On Windows, the parts of the path are separated by a
    backslash, while on Linux, this is a forward slash. The CLR figures out what it
    should use and uses the correct one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子足够简单，但它已经展示了某些有用的内容。首先，我们可以快速访问 `temp` 文件夹；我们不需要在我们的代码中指定它的位置。其次，我们可以组合文件名和路径，而不用担心路径分隔符。在
    Windows 上，路径的部分由反斜杠分隔，而在 Linux 上，这是一个正斜杠。CLR 会确定应该使用什么，并使用正确的一个。
- en: The `File.WriteAllText` then takes that data and creates a file, opens it, writes
    the string, and closes the file. If the file is already there, the system overwrites
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`File.WriteAllText` 然后使用这些数据创建一个文件，打开它，写入字符串，然后关闭文件。如果文件已经存在，系统将覆盖它。'
- en: 'If we wanted to have a temporary filename instead of `WriteLines.Text`, the
    code could have been even easier:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用临时文件名而不是 `WriteLines.Text`，代码可以更加简单：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The system looks up the path for `temp` files, generates a new file with a unique
    filename, and uses that to write the string. The downside is that we now have
    no idea which file it is. We have to log that somewhere; otherwise, our `temp`
    folder will fill up quickly with unused files (most operating systems clean up
    the `temp` folder though, so no real worries there).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会查找 `temp` 文件的路径，生成一个具有唯一文件名的新的文件，并使用该文件写入字符串。缺点是现在我们不知道它是哪个文件。我们必须将其记录在某个地方；否则，我们的
    `temp` 文件夹会很快填满未使用的文件（尽管大多数操作系统都会清理 `temp` 文件夹，所以这里没有真正的担忧）。
- en: 'You can obviously use any folder you want. However, if you want to use some
    of the special folders, such as the `Documents` folder on Windows, the system
    can help you get to those as well. Have a look at the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您当然可以使用任何您想要的文件夹。然而，如果您想使用一些特殊文件夹，例如 Windows 上的 `Documents` 文件夹，系统也可以帮助您访问这些文件夹。看看以下代码片段：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code looks up the location of `My Documents` on my machine and returns
    that so that I can write the file to that location. You can choose from a long
    list of special locations, all of which are part of the `SpecialFolder` enum.
    I will not list all of them; you can find them here: [https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0](https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码查找我的机器上 `My Documents` 的位置，并返回该位置，以便我可以将文件写入该位置。您可以从一个很长的特殊位置列表中进行选择，所有这些位置都是
    `SpecialFolder` 枚举的一部分。我不会列出所有这些位置；您可以在以下链接中找到它们：[https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0](https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0)。
- en: This way of writing files is effortless. However, as we have seen many times
    before, ease comes with less control. As systems programmers, we want all the
    control we can get. Let’s take back some control.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种写文件的方式毫不费力。然而，正如我们之前多次看到的，方便往往伴随着控制力的减少。作为系统程序员，我们希望获得尽可能多的控制权。让我们夺回一些控制权。
- en: FileStream
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileStream
- en: The static `File` class is easy to use and very convenient if you quickly want
    to write something to, or read something from, a file. However, it is not the
    fastest way. At least, it is not the fastest if we are referring to execution
    time. As systems programmers, we are very interested in speed, even if it means
    giving up on ease of coding.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `File` 类易于使用，如果您想快速向文件写入或从文件读取内容，它非常方便。然而，它并不是最快的方式。至少，如果我们谈论执行时间，它不是最快的。作为系统程序员，我们非常关注速度，即使这意味着放弃编码的便利性。
- en: 'The following example is about 20% faster than the previous one, but it does
    the same things. It just needs a few more lines:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例比之前的示例快约 20%，但它执行的是相同的事情。它只需要几行额外的代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This sample uses the `FileStream` that `File.Create()` returns. We can, of
    course, create one ourselves. Replace the line where we created the `FileStream`
    through `File` with the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了 `File.Create()` 返回的 `FileStream`。我们当然可以自己创建一个。将创建 `FileStream` 的行替换为以下内容：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I have used the most extensive overload here to show you some of the options
    that you can use. Most are self-explanatory, but I want to highlight two parameters:
    **share** and **options**.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了最全面的重载来向您展示您可以使用的部分选项。大多数选项都是不言自明的，但我想要强调两个参数：**share** 和 **options**。
- en: '`Share` is a flag that tells the operating system how to share the file while
    we use it. It has the following options:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Share` 是一个标志，用于告诉操作系统在使用文件时如何共享文件。它有以下选项：'
- en: '| **Flag** | **Value** | **Description** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **值** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `None` | 0 | No sharing is allowed. Any other process trying to access the
    file will fail to do so. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `None` | 0 | 不允许共享。任何尝试访问文件的进程都将失败。|'
- en: '| `Read` | 1 | Other processes can read the file while we are still using it.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Read` | 1 | 当我们仍在使用文件时，其他进程可以读取文件。|'
- en: '| `Write` | 2 | Other processes might write to the file at the same time. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Write` | 2 | 其他进程可能同时向文件写入。|'
- en: '| `ReadWrite` | 3 | This combines the `Read` and `Write` flags. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWrite` | 3 | 这结合了 `Read` 和 `Write` 标志。|'
- en: '| `Delete` | 4 | This allows requests for deletion of the file while we are
    using it. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Delete` | 4 | 这允许我们在使用文件的同时请求删除文件。|'
- en: '| `Inheritable` | 16 | The file handle is inheritable by child processes. However,
    this does not work on Win32 applications. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Inheritable` | 16 | 文件句柄可以被子进程继承。然而，这在Win32应用程序中不起作用。|'
- en: 'Table 5.1: Share options for files'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1：文件共享选项
- en: Although specifying a flag from this list might indicate that other processes
    can do things with our files while we use them, there is no guarantee that these
    other processes can actually do so. Usually, they need other permissions as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然指定这个列表中的标志可能表明其他进程在我们使用文件时可以对我们文件进行操作，但并不能保证这些其他进程实际上可以这样做。通常，它们还需要其他权限。
- en: '`Delete` is a nice flag. It allows for deletion while we are still working
    with the file. That could lead to weird situations. If we create a file and specify
    that we allow deletion, we might write to the file while another process has already
    deleted it. The system does not complain and continues running. However, you will
    end up without that file, which means losing your data forever. Let me show you
    what I mean:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete`是一个很好的标志。它允许我们在使用文件的同时进行删除。这可能会导致奇怪的情况。如果我们创建一个文件并指定我们允许删除，我们可能在另一个进程已经删除文件的情况下向文件写入。系统不会抱怨并继续运行。然而，你最终会失去那个文件，这意味着永远失去了你的数据。让我给你展示一下我的意思：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example is straightforward. We will first get a temporary filename. Then,
    we will get the bytes that form our payload. After that, we will create an instance
    of the `FileStream`, setting a couple of properties as we do so.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单。我们首先获取一个临时文件名。然后，我们获取构成有效载荷的字节。之后，我们将创建一个`FileStream`实例，在创建过程中设置一些属性。
- en: One of them is the `Share` option. We have set it to `FileShare.Delete`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是`Share`选项。我们将其设置为`FileShare.Delete`。
- en: We will write some data to the file and then pause the program. If you run it,
    this is the moment to take the output that tells you the name and location of
    the file and delete it. You should notice that you can do that. Then continue
    the program. As you can see, the following line writes the same data again to
    the file we just deleted. Nothing happens. Really, nothing happens. There are
    no errors, but no data is written anywhere either.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向文件写入一些数据，然后暂停程序。如果你运行它，这就是你获取输出的时候，它会告诉你文件的名称和位置，然后将其删除。你应该注意到你可以这样做。然后继续程序。正如你所看到的，下一行再次将相同的数据写入我们刚刚删除的文件。什么也没有发生。真的，什么也没有发生。没有错误，也没有任何数据被写入任何地方。
- en: In most cases, this is a behavior you would want to avoid. However, maybe your
    use case calls for just this kind of behavior. In that case, now you know how
    to do this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这是你想要避免的行为。然而，也许你的用例需要的就是这种行为。在这种情况下，现在你知道如何做到这一点。
- en: Even faster – Win32
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更快的是 – Win32
- en: There is a faster way to write files. If we remove the overhead of the CLR,
    we can write files about 20% faster. A 20% increase in speed can mean the difference
    between a sluggish application and one that seems lightning-fast. As usual, this
    comes with a price. All the good things the CLR provides us with are now in our
    own hands. We have to do a lot more work. However, if you are looking for the
    fastest way to write data to a file, theWin32 approach is, again, the best way
    to do this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种更快的方式来写入文件。如果我们移除了CLR的开销，我们可以将文件写入速度提高大约20%。速度提高20%可能意味着一个运行缓慢的应用程序和一个看起来闪电般快速的应用程序之间的区别。通常，这会带来一定的代价。CLR为我们提供的一切现在都掌握在我们自己的手中。我们必须做更多的工作。然而，如果你在寻找将数据写入文件的最快方式，Win32方法再次是做这件事的最佳方式。
- en: 'We will begin by declaring some constants:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明一些常量：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`GENERIC_WRITE` tells the system that we want to write to a file. `CREATE_ALWAYS`
    specifies that we want to create a new file every time we call this. `FILE_APPEND_DATA`
    means that we want to add to the current file (which doesn’t make much sense,
    since we just created the file).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`GENERIC_WRITE`告诉系统我们想要写入文件。`CREATE_ALWAYS`指定每次调用此方法时都想要创建一个新文件。`FILE_APPEND_DATA`意味着我们想要向当前文件添加内容（这没有太多意义，因为我们刚刚创建了文件）。'
- en: 'It is time to import the Win32 APIs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候导入Win32 API了：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will import three methods from `kernel32.dll`. `CreateFile` creates a file,
    `WriteFile` writes to that file, and `CloseHandle` closes handles and, in our
    case, the handle to the file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`kernel32.dll`导入三个方法。`CreateFile`创建一个文件，`WriteFile`向该文件写入，而`CloseHandle`关闭句柄，在我们的例子中，是文件的句柄。
- en: 'That is all we need to write. Let me show you how that works:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有内容。让我给你展示它是如何工作的：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the knowledge you have right now, you should be able to follow along. We
    will first create a file with the correct parameters. If that works, we will get
    the bytes we want to write and then use `WriteFile` to do the actual writing.
    After that, we will close the handle. We do that in the `finally` block; handles
    are expensive and they lock access to the file. We want to close it so other processes
    can access the file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你现在的知识，你应该能够跟上。我们首先将创建一个具有正确参数的文件。如果这成功了，我们将得到我们想要写入的字节，然后使用`WriteFile`进行实际的写入。之后，我们将关闭句柄。我们在`finally`块中这样做；句柄很昂贵，并且锁定对文件的访问。我们希望关闭它，以便其他进程可以访问文件。
- en: You are partially correct if you think that this does not look too bad. This
    was very simple. However, I omitted a lot of things, such as error checking. Do
    you remember what I told you about performance? I said in the previous chapters
    that file IO takes forever compared to normal CPU operations. Thus, we must use
    the asynchronous approach as much as we can. You can do that with Win32, but that
    is pretty complex. I will not show you how to do that here, but if you do a quick
    search on the Win32 API, `CreateFile`, and `FILE_FLAG_OVERLAPPED`, you can find
    out how it all works. In short, you will have to check everything yourself. My
    advice is to stick to the CLR functions. We will discuss asynchronous I/O later
    in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这看起来还不错，你部分是正确的。这非常简单。然而，我省略了很多东西，比如错误检查。你还记得我之前关于性能的讨论吗？我在前面的章节中说，与正常的CPU操作相比，文件I/O要慢得多。因此，我们必须尽可能多地使用异步方法。你可以用Win32做到这一点，但这相当复杂。在这里，我不会向你展示如何做，但如果你在Win32
    API、`CreateFile`和`FILE_FLAG_OVERLAPPED`上快速搜索，你可以了解它是如何工作的。简而言之，你将不得不自己检查一切。我的建议是坚持使用CLR函数。我们将在本章后面讨论异步I/O。
- en: 'We have learned how to write to files and all that goes with doing that. However,
    that is only one part of the story. Let’s move to the other half of the equation:
    reading a file.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何写入文件以及与之相关的所有内容。然而，这仅仅是故事的一部分。让我们转向等式的另一半：读取文件。
- en: File reading basics
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件读取基础
- en: 'Great. We have written a file. Now we should be able to read it as well, right?
    Okay, let’s dive into that. We will start with a simple example: a file with some
    lines of text that we want to read into a string:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。我们已经写了一个文件。现在我们应该能够读取它，对吧？好的，让我们深入探讨一下。我们将从一个简单的例子开始：一个包含一些文本行的文件，我们希望将其读取到字符串中：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I can’t make it simpler than this. We have the static `ReadAllText` method,
    which takes a filename and reads all text into the string. Then we return that.
    Keep in mind that not all files contain text. I even dare to say that *most* files
    do not contain text. They are binary. Now, technically, a `text` file is also
    a `binary` file. So, let’s read the file again, but now by reading the actual
    bytes. I use the `FileStream` this time, so we have a bit more control over what
    is happening:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法使它比这更简单了。我们有一个静态的`ReadAllText`方法，它接受一个文件名并将所有文本读取到字符串中。然后我们返回它。请记住，并非所有文件都包含文本。我甚至敢说*大多数*文件都不包含文本。它们是二进制的。现在，从技术上讲，一个`text`文件也是一个`binary`文件。所以，让我们再次读取文件，但现在是通过读取实际的字节。这次我使用`FileStream`，这样我们就可以对发生的事情有更多的控制：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The nice thing about the `FileStream` is that it knows the length of the stream.
    That means that we can allocate enough space for our array to contain all the
    data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`的好处是它知道流的长度。这意味着我们可以为我们的数组分配足够的空间来包含所有数据。'
- en: We will read all data through one call to `fs.Read()`, giving it the byte array,
    the start position `0`, and the total number of bytes to read. Again, we will
    close the stream when we are done with it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一次调用`fs.Read()`来读取所有数据，给它一个字节数组，起始位置`0`，以及要读取的总字节数。再次强调，当我们完成时，我们将关闭流。
- en: Last, we will convert the file to a string, assuming the contents are ASCII
    characters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将假设内容是ASCII字符，将文件转换为字符串。
- en: This way of reading works fine if you have a relatively small file. In that
    case, you can read it all in one go. However, if the file is too big, you must
    read it in chunks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件相对较小，这种方式读取是可行的。在这种情况下，你可以一次性读取所有内容。然而，如果文件太大，你必须分块读取。
- en: For that, the `Read()` method helps you by telling you how much data it has
    read. You can create a loop and iterate through the complete file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，`Read()`方法通过告诉你它读取了多少数据来帮助你。你可以创建一个循环并遍历整个文件。
- en: 'We can rewrite the part where we read the file like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样重写读取文件的部分：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a silly way to do this, but it illustrates my point. We will keep reading
    the file until we have all the data, in which case `fs.Read()` returns `0`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个愚蠢的方法，但它说明了我的观点。我们将继续读取文件，直到我们有了所有数据，在这种情况下 `fs.Read()` 返回 `0`。
- en: Reading binary data
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取二进制数据
- en: If you have a `binary` file that you know the structure of, you can use a `BinaryReader`
    to help.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个你知道结构的 `binary` 文件，你可以使用 `BinaryReader` 来帮助。
- en: Binary data is usually much more memory-efficient than text data. Since we,
    as systems programmers, are always searching for more efficient code, this is
    worth looking into.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数据通常比文本数据更节省内存。由于我们作为系统程序员总是在寻找更高效的代码，这值得一看。
- en: 'Let’s assume that I have the following class. This doesn’t mean anything special;
    it is just a data collection:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个以下这样的类。这并没有什么特殊的意义；它只是一个数据集合：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let us assume that I have created an instance of this class with the properties
    `42`, `3.1415`, `True`, `MyFlags.One | MyFlags.Three` and `Hello, Systems Programmers`.
    I can write it to a file using JSON serialization. That results in a file of 114
    bytes. If I use a binary format, I can shrink it down to 44 bytes. That is a considerable
    saving, especially when putting that data on a network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我已经创建了一个具有属性 `42`、`3.1415`、`True`、`MyFlags.One | MyFlags.Three` 和 `Hello,
    Systems Programmers` 的该类实例。我可以使用JSON序列化将其写入文件。这会产生一个114字节的文件。如果使用二进制格式，我可以将其缩小到44字节。这是一个相当大的节省，尤其是在将数据放在网络上时。
- en: 'Reading that file is straightforward using the `BinaryReader` class. Let me
    show you:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BinaryReader` 类读取该文件是直接的。让我给你展示一下：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Doing it this way means that you have to be very careful. You have to know the
    structure of the file precisely. You are responsible for getting all data in the
    correct order and knowing each field’s type exactly. However, doing it this way
    ensures efficiency and can save you many CPU cycles.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做意味着你必须非常小心。你必须精确地知道文件的结构。你必须负责以正确的顺序获取所有数据，并确切地知道每个字段的类型。然而，这样做可以确保效率，并且可以节省你许多CPU周期。
- en: 'We now know all about how to read and write files. However, files are not the
    only things we can find in file systems. We need a way to organize all those files.
    That brings us to the next topic in IO: directories!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了如何读取和写入文件。然而，文件系统中的不仅仅是文件。我们需要一种方法来组织所有这些文件。这把我们带到了IO的下一个主题：目录！
- en: Directory operations
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录操作
- en: 'Imagine having a file system with one root folder. All files on your drive
    are stored there. You would have a tough time finding all your files. Luckily,
    operating systems all support the notion of folders or directories. The CLR helps
    us by giving us two classes to work with paths, folders, and directories: **Path**
    and **Directory**.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有一个只有一个根文件夹的文件系统。你的驱动器上的所有文件都存储在那里。你将很难找到所有文件。幸运的是，操作系统都支持文件夹或目录的概念。CLR通过给我们提供两个类来帮助我们处理路径、文件夹和目录：**Path**
    和 **Directory**。
- en: The Path class
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径类
- en: '`Path` is a class that has helper methods for dealing with paths. With `Path`,
    I mean the string that denotes the name of a directory. You should use the `Directory`
    class when dealing with the actual directory and files.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 是一个具有处理路径的辅助方法的类。我指的是表示目录名称的字符串。当处理实际的目录和文件时，你应该使用 `Directory` 类。'
- en: We have already seen the `Path` class in previous samples. I used it to get
    a temporary filename and the name of the `Documents` folder. I also used it to
    combine a path and a filename to avoid dealing with path separators myself.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的示例中看到了 `Path` 类。我使用它来获取临时文件名和 `Documents` 文件夹的名称。我还用它来合并路径和文件名，以避免自己处理路径分隔符。
- en: There are quite a few handy methods and properties in the `Path` class. You
    can see some of the most-used ones in the following table.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 类中有许多实用的方法和属性。你可以在以下表中看到一些最常用的。'
- en: '| **Method** | **Description** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Path.Combine` | Combines two or more strings into a path |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `Path.Combine` | 将两个或多个字符串合并为一个路径 |'
- en: '| `ath.GetFileName` | Returns the filename and extension of the specified path
    string |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetFileName` | 返回指定路径字符串的文件名和扩展名 |'
- en: '| `Path.GetFileNameWithoutExtension` | Returns the filename of the specified
    path string without the extension |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetFileNameWithoutExtension` | 返回指定路径字符串的文件名，不带扩展名 |'
- en: '| `Path.GetExtension` | Gets the extension (including the period) of the specified
    path string |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetExtension` | 获取指定路径字符串的扩展名（包括点）|'
- en: '| `Path.GetDirectoryName` | Gets the directory information for the specified
    path string |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetDirectoryName` | 获取指定路径字符串的目录信息 |'
- en: '| `Path.GetFullPath` | Converts a relative path to an absolute path |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetFullPath` | 将相对路径转换为绝对路径 |'
- en: '| `Path.GetTempPath` | Returns the path to the system’s temporary folder |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetTempPath` | 返回系统临时文件夹的路径 |'
- en: '| `Path.GetRandomFileName` | Returns a random filename that is not already
    in use |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetRandomFileName` | 返回一个尚未被使用的随机文件名 |'
- en: '| `Path.GetInvalidFileNameChars` | Returns an array of characters that are
    not allowed in filenames on the current platform |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetInvalidFileNameChars` | 返回当前平台上不允许在文件名中使用的字符数组 |'
- en: '| `Path.GetInvalidPathChars` | Returns an array of characters that are not
    allowed in path strings on the current platform |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Path.GetInvalidPathChars` | 返回当前平台上不允许在路径字符串中使用的字符数组 |'
- en: '| `Path.ChangeExtension` | Changes the extension of a file path |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Path.ChangeExtension` | 改变文件路径的扩展名 |'
- en: '| `Path.HasExtension` | Determines whether a path includes a filename extension
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Path.HasExtension` | 确定路径是否包含文件名扩展名 |'
- en: '| `Path.IsPathRooted` | Gets a value indicating whether the specified path
    string contains a root |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Path.IsPathRooted` | 获取一个值，指示指定的路径字符串是否包含根 |'
- en: '| `Path.DirectorySeparatorChar` | A platform-specific separator character that
    is used in path strings |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Path.DirectorySeparatorChar` | 用于路径字符串的平台特定分隔符 |'
- en: 'Table 5.2: The Path class and its methods and properties'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2：Path 类及其方法和属性
- en: As you can see, the `Path` class has a set of nice and convenient helpers. We
    will encounter them again when we investigate other platforms, but for now, please
    remember to use them as much as possible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Path` 类有一组非常好用且方便的辅助工具。当我们调查其他平台时，我们还会遇到它们，但现在，请记住尽可能多地使用它们。
- en: The Directory class
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录类
- en: The `Directory` class deals with the actual directory in your filesystem. This
    class works closely with the `Path` class. If you need to specify the directory’s
    name (and thus its location), you would use the `Path` class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directory` 类处理您文件系统中的实际目录。这个类与 `Path` 类紧密合作。如果您需要指定目录的名称（以及其位置），您将使用 `Path`
    类。'
- en: 'Let’s assume that we want to list all images in our `Pictures` folder on our
    Windows machine. You would do that like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在 Windows 机器上的 `Pictures` 文件夹中列出所有图像。您会这样做：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I use `Environment.SpecialFolder.MyPictures` here to identify the folder that
    has all my pictures. The actual path depends on your operating system, the username,
    and how you have set up your machine. That means there are a lot of possible variations,
    but we need not bother much about that. Let the operating system figure that out,
    as long as we get the correct folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用 `Environment.SpecialFolder.MyPictures` 来标识包含所有图片的文件夹。实际的路径取决于您的操作系统、用户名以及您如何设置您的机器。这意味着有很多可能的变体，但我们不必过于担心这一点。让操作系统去处理这个问题，只要我们得到正确的文件夹即可。
- en: 'I used the `Directory.GetFiles()` method to iterate through that folder. I
    want all the JPEG images I have collected in all subfolders. Notice how I spelled
    the extension in the `searchPattern` variable: `*.jPg`. On Windows, filenames
    are not case-sensitive. On Linux, they are. So, on a Linux-based machine, this
    would not work. Okay, it will work, but it does not return all the files you might
    expect to get. Unfortunately, `GetFiles()` cannot set up a filter for case insensitivity.
    If you want to get all JPG images, no matter what their extensions look like,
    you have to do this another way:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `Directory.GetFiles()` 方法来遍历该文件夹。我想获取所有子文件夹中收集的所有 JPEG 图像。注意我在 `searchPattern`
    变量中如何拼写扩展名：`*.jPg`。在 Windows 上，文件名不区分大小写。在 Linux 上，它们是区分大小写的。因此，在基于 Linux 的机器上，这不会起作用。好吧，它将起作用，但它不会返回您可能期望得到的所有文件。不幸的是，`GetFiles()`
    无法设置不区分大小写的过滤器。如果您想获取所有 JPG 图像，无论它们的扩展名看起来如何，您必须以另一种方式来做：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I have created a regular expression here, saying I want to filter on strings
    that end in `.jpg` or `jpeg` and ignore the case. Then I use `Directory.EnumerateFiles()`
    and apply the `Where()` LINQ operator to apply the `regex` filter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里创建了一个正则表达式，表示我想过滤以 `.jpg` 或 `jpeg` 结尾的字符串，并忽略大小写。然后我使用 `Directory.EnumerateFiles()`
    并应用 `Where()` LINQ 操作符来应用 `regex` 过滤器。
- en: 'This method works fine on all platforms. You could have avoided the `regex`
    filter by using the following code, which is more verbose but, I assume, more
    readable to many people:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在所有平台上都工作得很好。您本可以通过以下代码避免使用 `regex` 过滤器，该代码更冗长，但我假设对许多人来说更易读：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I have collected the most-used methods and properties of the `Directory` class
    for you in the following table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我在下面的表中为您收集了`Directory`类最常用的方法和属性：
- en: '| **Method** **or property** | **Description** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **方法** **或属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Directory.CreateDirectory` | Creates all directories and subdirectories
    in the specified path unless they already exist |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.CreateDirectory` | 在指定的路径中创建所有目录和子目录，除非它们已经存在 |'
- en: '| `Directory. Delete` | Deletes the specified directory and, optionally, any
    subdirectories and files in the directory |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.Delete` | 删除指定的目录，以及可选地删除目录中的任何子目录和文件 |'
- en: '| `Directory.Exists` | Determines whether the given path refers to an existing
    directory on the disk |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.Exists` | 确定给定的路径是否指向磁盘上的现有目录 |'
- en: '| `Directory.GetCurrentDirectory` | Gets the current working directory of the
    application |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.GetCurrentDirectory` | 获取应用程序的当前工作目录 |'
- en: '| `Directory.GetDirectories` | Gets the names of subdirectories (including
    their paths) in the specified directory |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.GetDirectories` | 获取指定目录中子目录的名称（包括它们的路径） |'
- en: '| `Directory.GetFiles` | Returns the names of files (including their paths)
    in the specified directory |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.GetFiles` | 返回指定目录中文件的名称（包括它们的路径） |'
- en: '| `Directory.GetFileSystemEntries` | Returns the names of all the files and
    subdirectories in a specified directory |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.GetFileSystemEntries` | 返回指定目录中所有文件和子目录的名称 |'
- en: '| `Directory.GetLastAccessTime` | Returns the date and time when the specified
    file or directory was last accessed |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.GetLastAccessTime` | 返回指定文件或目录最后访问的日期和时间 |'
- en: '| `Directory.GetLastWriteTime` | Returns the date and time when the specified
    file or directory was last written to |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.GetLastWriteTime` | 返回指定文件或目录最后写入的日期和时间 |'
- en: '| `Directory.GetParent` | Retrieves the parent directory of the specified path,
    including both absolute and relative paths |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.GetParent` | 获取指定路径的父目录，包括绝对路径和相对路径 |'
- en: '| `Directory.Move` | Moves a file or a directory and its contents to a new
    location |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.Move` | 将文件或目录及其内容移动到新位置 |'
- en: '| `Directory.SetCreationTime` | Sets the creation date and time for the specified
    file or directory |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.SetCreationTime` | 设置指定文件或目录的创建日期和时间 |'
- en: '| `Directory.SetCurrentDirectory` | Sets the application’s current working
    directory to the specified directory |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.SetCurrentDirectory` | 将应用程序的当前工作目录设置为指定的目录 |'
- en: '| `Directory.SetLastAccessTime` | Sets the date and time when the specified
    file or directory was last accessed |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.SetLastAccessTime` | 设置指定文件或目录最后访问的日期和时间 |'
- en: '| `Directory.SetLastWriteTime` | Sets the date and time when the specified
    file or directory was last written to |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `Directory.SetLastWriteTime` | 设置指定文件或目录最后写入的日期和时间 |'
- en: 'Table 5.3: The methods and properties of the Directory class'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3：目录类的属性和方法
- en: The `Directory` has some nice helpers and properties. You could figure out all
    of these properties yourself, but why bother if the CLR is friendly enough to
    help you? These properties will also be beneficial when we move to other platforms
    later on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directory`有一些不错的辅助方法和属性。你可以自己找出所有这些属性，但为什么麻烦自己去做，如果CLR足够友好地帮助你呢？当我们以后转移到其他平台时，这些属性也将是有益的。'
- en: The DirectoryInfo class
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DirectoryInfo`类'
- en: 'There is one more class I want to discuss: the `DirectoryInfo` class. The difference
    between `Directory` and `DirectoryInfo` is that the former uses static methods,
    whereas the latter is used as an instance. `Directory` returns information about
    directories as strings. `DirectoryInfo` returns objects with much more information.
    Let me give you an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想讨论另一个类：`DirectoryInfo`类。`Directory`和`DirectoryInfo`之间的区别在于前者使用静态方法，而后者用作实例。`Directory`返回关于目录的字符串信息。`DirectoryInfo`返回包含更多信息的对象。让我给你举一个例子：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I created an instance of the `DirectoryInfo` class and gave it the path to our
    `images` folder. This instance has a lot of valuable properties, such as the full
    name, time of creation, attributes, and many more. I have listed the most-used
    properties and methods in the following table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个`DirectoryInfo`类的实例，并给它提供了我们`images`文件夹的路径。这个实例有很多有价值的属性，例如完整名称、创建时间、属性等等。我在下表中列出了最常用的属性和方法。
- en: '| **Method** **or property** | **Description** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **方法** **或属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DirectoryInfo.Create` | Creates a directory |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Create` | 创建一个目录 |'
- en: '| `DirectoryInfo.Delete` | Deletes this instance of a `DirectoryInfo`, specifying
    whether to delete subdirectories and files |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Delete` | 删除此 `DirectoryInfo` 实例，指定是否删除子目录和文件 |'
- en: '| `DirectoryInfo.Exists` | Gets a value indicating whether the directory exists
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Exists` | 获取一个值，指示目录是否存在 |'
- en: '| `DirectoryInfo.Extension` | Gets the string representing the extension part
    of the directory |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Extension` | 获取表示目录扩展部分的字符串 |'
- en: '| `DirectoryInfo.FullName` | Gets the full path of the directory or file |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.FullName` | 获取目录或文件的完整路径 |'
- en: '| `DirectoryInfo.Name` | Gets the name of this `DirectoryInfo` instance |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Name` | 获取此 `DirectoryInfo` 实例的名称 |'
- en: '| `DirectoryInfo.Parent` | Gets the parent directory of a specified subdirectory
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Parent` | 获取指定子目录的父目录 |'
- en: '| `DirectoryInfo.Root` | Gets the root portion of a path |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Root` | 获取路径的根部分 |'
- en: '| `DirectoryInfo.GetFiles` | Returns a file list from the current directory
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.GetFiles` | 从当前目录返回文件列表 |'
- en: '| `DirectoryInfo.GetDirectories` | Returns the subdirectories of the current
    directory |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.GetDirectories` | 返回当前目录的子目录 |'
- en: '| `DirectoryInfo.GetFileSystemInfos` | Retrieves an array of `FileSystemInfo`
    objects representing the files and subdirectories of the current directory |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.GetFileSystemInfos` | 获取表示当前目录中的文件和子目录的 `FileSystemInfo` 对象数组
    |'
- en: '| `DirectoryInfo.MoveTo` | Moves a `DirectoryInfo` instance and its contents
    to a new path |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.MoveTo` | 将 `DirectoryInfo` 实例及其内容移动到新路径 |'
- en: '| `DirectoryInfo.Refresh` | Refreshes the state of the object |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Refresh` | 刷新对象的状态 |'
- en: '| `DirectoryInfo.EnumerateFiles` | Returns an enumerable collection of file
    information in the current directory |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.EnumerateFiles` | 返回当前目录中文件信息的可枚举集合 |'
- en: '| `DirectoryInfo.EnumerateDirectories` | Returns an enumerable collection of
    directory information in the current directory |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.EnumerateDirectories` | 返回当前目录中目录信息的可枚举集合 |'
- en: '| `DirectoryInfo.Enumerate FileSystemInfos` | Returns an enumerable collection
    of file system information in the current directory |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo.Enumerate FileSystemInfos` | 返回当前目录中文件系统信息的可枚举集合 |'
- en: 'Table 5.4: DirectoryInfo properties and methods'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.4：DirectoryInfo 属性和方法
- en: As you can see, `Path`, `Directory`, and `DirectoryInfo` can greatly help when
    dealing with files.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Path`、`Directory` 和 `DirectoryInfo` 在处理文件时可以提供很大帮助。
- en: File system monitoring
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统监控
- en: As systems programmers, we must find ways to communicate with our apps. After
    all, there is no user interface wherein the user can indicate their desired actions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统程序员，我们必须找到与我们的应用程序通信的方法。毕竟，没有用户界面让用户可以表明他们的期望操作。
- en: Most apps in that category listen to network ports or have other ways for systems
    to communicate with them. One of those ways is to wait for changes in files or
    directories.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那个类别的多数应用程序都监听网络端口或以其他方式让系统与之通信。其中一种方式是等待文件或目录的变化。
- en: Keeping an eye on files or folders is a fairly common scenario. For instance,
    we could build a system that processes the files that we get through an email
    system. As soon as a file is delivered as an attachment, the mail client places
    it in a directory and our system picks it up.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 监视文件或文件夹是一个相当常见的场景。例如，我们可以构建一个系统来处理通过电子邮件系统获取的文件。一旦文件作为附件发送，邮件客户端就会将其放置在一个目录中，我们的系统就会去获取它。
- en: This means that we need to have a way to keep an eye on that folder. Luckily,
    that is not too hard to do. It does require some explanation, so let me walk you
    through it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要有一种方法来监视那个文件夹。幸运的是，这并不太难实现。这确实需要一些解释，所以让我带你了解一下。
- en: 'We will begin with the class that other classes interact with:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从其他类与之交互的类开始：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will need to clean up some resources later, so I have implemented the `IDisposable`
    interface here. The class that we need to clean up is an instance of the `FileSystemWatcher`
    type. This class, when instantiated, keeps an eye on a folder and, optionally,
    a filter for the filenames. If something of interest happens there, the `FileSystemWatcher`
    notifies us. It is up to us to define what “something of interest” means.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后需要清理一些资源，所以我在这里实现了 `IDisposable` 接口。我们需要清理的类是 `FileSystemWatcher` 类型的实例。这个类在实例化时监视一个文件夹，并且可选地监视文件名过滤器。如果那里发生了一些有趣的事情，`FileSystemWatcher`
    会通知我们。定义“有趣的事情”是什么取决于我们。
- en: 'Let’s set it up as a private member of our class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它设置为我们类的一个私有成员：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We could change our `Dispose`(bool disposing) method to clean this up, but I
    will hold on to that for now. We need to do more than just dispose of the `FileSystemWatcher`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的 `Dispose`(bool disposing) 方法改为清理这些内容，但我会暂时保留这个。我们需要做的不仅仅是销毁 `FileSystemWatcher`。
- en: A `FileSystemWatcher` is resource-intensive. Keeping an eye on a folder can
    lead to much CPU pressure. Therefore, we must be sure to only enable it when we
    need it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystemWatcher` 是资源密集型的。监视一个文件夹可能会导致大量的CPU压力。因此，我们必须确保只有在需要时才启用它。'
- en: 'Then, we will add a method that enables the watcher and set some settings:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个启用监视器并设置一些设置的方法：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will start with two checks. First, we will see whether the watcher has not
    already been created. If it has, we will throw an error. The second is to check
    whether the supplied path exists or not.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始进行两项检查。首先，我们将查看监视器是否已经被创建。如果已经创建，我们将抛出一个错误。第二是检查提供的路径是否存在。
- en: If those two checks both pass, we will create an instance of the `FileSystemWatcher`
    class and give it the path we want to monitor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个检查都通过，我们将创建一个 `FileSystemWatcher` 类的实例，并给它我们想要监视的路径。
- en: You can specify what you want to monitor. This is controlled by the `NotifyFilter`
    property. This property takes an enum or a combination of the `NotifyFilter` enums.
    You can see what your options are in the following table.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定您想要监视的内容。这由 `NotifyFilter` 属性控制。这个属性接受一个枚举或 `NotifyFilter` 枚举的组合。您可以在以下表中查看您的选项。
- en: '| **NotifyFilters enum** | **Description** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **NotifyFilters 枚举** | **描述** |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Attributes` | Watches for changes in the attributes of the file or folder
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `Attributes` | 监视文件或文件夹属性的变化 |'
- en: '| `CreationTime` | Monitors changes to the creation times of files and directories
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `CreationTime` | 监视文件和目录的创建时间的变化 |'
- en: '| `DirectoryName` | Watches for changes in the names of directories |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryName` | 监视目录名称的变化 |'
- en: '| `FileName` | Watches for changes in the names of files |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `FileName` | 监视文件名称的变化 |'
- en: '| `LastAccess` | Monitors changes to the last access times of files and directories
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `LastAccess` | 监视文件和目录的最后访问时间的变化 |'
- en: '| `LastWrite` | Watches for changes to the last write times of files and directories
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `LastWrite` | 监视文件和目录的最后写入时间的变化 |'
- en: '| `Security` | Monitors changes in the security settings of files and directories
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `Security` | 监视文件和目录的安全设置的变化 |'
- en: '| `Size` | Watches for changes in the sizes of files and directories |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `Size` | 监视文件和目录的大小变化 |'
- en: 'Table 5.5: NotifyFilters options'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.5：NotifyFilters 选项
- en: I am only interested in new or changed files in our folder. So, I have given
    it the `NotifyFilters.FileName` | `NotifyFilters.LastWrite` value. The `FileName`
    of a file changes, of course, when you first create the file. I could also have
    chosen `CreationTime`, which hardly ever changes. I will also keep a watch on
    `LastWrite`, which tells me when a file has changed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我只对文件夹中的新文件或更改的文件感兴趣。因此，我给它设置了 `NotifyFilters.FileName` | `NotifyFilters.LastWrite`
    的值。当然，当您第一次创建文件时，文件的 `FileName` 会发生变化。我也可以选择 `CreationTime`，它几乎不会变化。我还会监视 `LastWrite`，它告诉我文件何时发生变化。
- en: 'After this, I will give the `_watcher` a callback to call when either of the
    two events I care about are raised. Since all events share the same signature,
    I can get away with just one method. That method is what we will look at next.
    However, before we do that, we need to start the watcher by setting `_watcher.EnableRaisingEvents`
    to `True`. The next piece of code contains the body of the `eventhandler`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我将给 `_watcher` 一个回调，当两个我关心的任意一个事件被触发时调用。由于所有事件共享相同的签名，我可以用一个方法来完成。这个方法就是我们接下来要看的。然而，在我们这样做之前，我们需要通过将
    `_watcher.EnableRaisingEvents` 设置为 `True` 来启动监视器。下一段代码包含了 `eventhandler` 的主体：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the watcher calls this callback, we get an instance of the `FileSystemEventArgs`
    class. This class contains a field called `ChangeType` that indicates what type
    of change triggered this call. It also contains the full path and name of the
    file affected in the `FullPath` property.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当监视器调用这个回调时，我们得到一个 `FileSystemEventArgs` 类的实例。这个类包含一个名为 `ChangeType` 的字段，它指示触发了这个调用的变化类型。它还包含受影响的文件的完整路径和名称，在
    `FullPath` 属性中。
- en: 'We will switch on that `ChangeType` field and call one of the two event handlers
    for our class. Those two event handlers that are part of our class look like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将切换到 `ChangeType` 字段，并调用我们类中的一个事件处理器。我们类中的两个事件处理器如下所示：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `FileCreatedEventArgs` and `FileChangedEventArgs` types for the `EventHandler`
    are straightforward as well. I could have used only one type. However, for future
    uses, I decided to give them distinct classes that I might extend at some point
    with more information. They look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileCreatedEventArgs`和`FileChangedEventArgs`类型对于`EventHandler`来说也很直接。我本可以使用一个类型。然而，为了未来的使用，我决定为它们提供不同的类，我可能在某个时候通过更多信息扩展它们。它们看起来像这样：'
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`FileSystemWatcher` implements `IDisposable`. So, we must dispose of it when
    we no longer use it. We need to rewrite our own `Dispose(bool disposing)` method
    to look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystemWatcher`实现了`IDisposable`。因此，当我们不再使用它时，我们必须将其释放。我们需要重写自己的`Dispose(bool
    disposing)`方法，使其看起来像这样：'
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After doing some checks, we will stop the system from receiving any events.
    Then we will clear the events. If we do not do this, other objects might hold
    a reference to our class and thus prevent this class from being freed from memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了一些检查后，我们将停止系统接收任何事件。然后我们将清除事件。如果我们不这样做，其他对象可能会持有对我们类的引用，从而阻止此类从内存中释放。
- en: When that is done, we dispose of `_watcher` and set it to null.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当那件事完成时，我们将释放`_watcher`并将其设置为null。
- en: That’s it. If you run it from your program, give it a folder, and attach some
    `eventhandlers` to it, you will be able to see what happens when you add or change
    files in that folder.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如果你从你的程序中运行它，给它一个文件夹，并附加一些`eventhandlers`，你将能够看到当你向该文件夹添加或更改文件时会发生什么。
- en: It is almost perfect. Almost – but not quite.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎完美。几乎——但并不完全。
- en: If you add a file, you will get multiple events. If you think about that, it
    makes sense. After all, a file is created on the file system and then it is changed
    immediately. If you wanted to, you could change our class to consider that. It
    is not hard to do, so I will leave that up to you.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加一个文件，你会得到多个事件。如果你这么想，这是有道理的。毕竟，文件是在文件系统中创建的，然后立即被更改。如果你愿意，你可以更改我们的类来考虑这一点。这并不难做，所以我会把它留给你。
- en: Asynchronous I/O
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步I/O
- en: 'I have said it before, but this is so important that I have to repeat it here:
    IO is slow. Every piece of code that works with IO should be done asynchronously.
    Luckily, most of the classes in the `System.IO` namespace have asynchronous members
    that we can use with async/await.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前已经说过，但这一点非常重要，所以我必须在这里重复一遍：I/O很慢。任何与I/O一起工作的代码都应该异步执行。幸运的是，`System.IO`命名空间中的大多数类都有我们可以使用的异步成员，我们可以与async/await一起使用。
- en: I would be happy if Microsoft decided to mark all non-asynchronous methods in
    `System.IO` as obsolete.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果微软决定将`System.IO`中所有非异步方法标记为过时，我会很高兴。
- en: The naïve approach
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 天真的方法
- en: Most of the methods you know in `System.IO` have an asynchronous version. So,
    just add the `async` postfix to the method name and await it. Simple!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`System.IO`中知道的大部分方法都有一个异步版本。所以，只需在方法名后添加`async`后缀并等待它即可。很简单！
- en: On second thought, no. It is not that simple.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细想想，不。这并不简单。
- en: 'Let me show you an example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你举一个例子：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method creates a file and then writes a string line to it. Once finished,
    it closes the file and nicely disposes of it. It does that asynchronously. So
    this is the way things should be, right?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个文件，然后向其中写入一行字符串。完成后，它关闭文件并很好地释放它。它是异步执行的。所以这就是事情应该这样做的方式，对吧？
- en: 'Let’s use this method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个方法：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add these two lines to your main Console application. Run it and let it run
    for a few seconds. Note what line is written to the file on the screen (it should
    say something to the effect of *This is the line n*, where `n` is the number of
    the line). Then press *Ctrl* + *C* to cancel the operation. The program will stop.
    Now, please open the file and see how far it got. There is a big chance that you
    will see that the last line written on the file is not the number that you saw
    on the screen.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两行代码添加到你的主控制台应用程序中。运行它并让它运行几秒钟。注意屏幕上写入的行（它应该说的是类似于“这是第n行”，其中`n`是行的编号）。然后按*Ctrl*
    + *C*取消操作。程序将停止。现在，请打开文件并看看它走了多远。有很大可能性你会看到文件上最后写入的行不是你在屏幕上看到的数字。
- en: Why is that, you might wonder? The CLR ensures that performance is as high as
    possible for our code. So, all data written to a file system is buffered into
    a cache before it is sent to the SSD or other media. After all, writing to storage
    is slow. However, since we killed the process, the CLR did not have time to flush
    the cache.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么？CLR确保我们的代码的性能尽可能高。所以，所有写入文件系统的数据都会在发送到SSD或其他媒体之前缓冲到缓存中。毕竟，写入存储是慢的。然而，由于我们终止了进程，CLR没有时间刷新缓存。
- en: Using CancellationTokens
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用取消令牌
- en: Of course, this would not happen often in the real world. However, you might
    want to cancel a long-running IO process, and then you might encounter this.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实世界中这种情况不会经常发生。然而，你可能想要取消一个长时间运行的 IO 进程，然后你可能会遇到这种情况。
- en: There is a solution to this. Remember the chapter where we talked about threads?
    Remember that I said that there was this thing called a `CancellationToken`? That
    is the one that we need.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个解决方案。还记得我们讨论线程的那一章吗？还记得我说过有一个叫做`CancellationToken`的东西吗？那就是我们需要的东西。
- en: 'Let’s rewrite the code that writes the file. Let’s remove the `naïve` from
    the method name; we know better now:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写写入文件的代码。让我们从方法名称中移除`naïve`；我们现在知道得更多了：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have added quite a bit of code here. Let me walk you through it. First, we
    added a parameter of the `CancellationToken` type to the method. We will constantly
    check to see whether `Cancel` has been requested in our loop. If so, we will print
    the message on the screen and graciously exit the loop.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了很多代码。让我带你看看。首先，我们向方法添加了一个`CancellationToken`类型的参数。我们将在循环中不断检查是否请求了`Cancel`。如果是这样，我们将在屏幕上打印消息并优雅地退出循环。
- en: In the `Task.Delay()`, we also passed the `CancellationToken`. After all, while
    the system waits for this delay, the cancellation can also be requested. However,
    when that happens during a `Task.Delay()`, the CLR will throw an exception of
    the `TaskCanceledException` type. We have to catch that to prevent our program
    from crashing and stopping. That’s why we have the `try..catch` block here. We
    need that `try..catch` block to prevent the exception from bubbling up the call
    stack.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Task.Delay()`中，我们也传入了`CancellationToken`。毕竟，当系统等待这个延迟时，也可以请求取消。然而，当这发生在`Task.Delay()`期间时，CLR
    将抛出一个`TaskCanceledException`类型的异常。我们必须捕获它以防止我们的程序崩溃并停止。这就是为什么我们在这里有`try..catch`块。我们需要这个`try..catch`块来防止异常向上冒泡到调用堆栈。
- en: 'We have to mimic breaking up the loop from the outside. Change the code that
    calls this method into the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须模拟从外部中断循环。将调用此方法的代码更改为以下内容：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we will create a new `CancellationtokenSource`. Then, we will pull a
    thread from the `ThreadPool` and give it something to do. After waiting for 10
    seconds, it will request a cancellation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的`CancellationtokenSource`。然后，我们将从`ThreadPool`中拉取一个线程并给它一些事情做。等待10秒后，它将请求取消。
- en: The call to `CreateBigFile` now has a `CancellationTokenSource`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用`CreateBigFile`时有一个`CancellationTokenSource`。
- en: Run it and see that it stops after 10 seconds. Notice which line it stopped
    on and check the actual file to see whether that was the last line written to
    it. On my machine, this works nicely.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它并看到它在10秒后停止。注意它停止在哪一行，并检查实际的文件以查看是否是最后写入的一行。在我的机器上，这工作得很好。
- en: 'Remember: when dealing with asynchronous file handling, no matter what you
    do, try to use a `CancellationSourceToken`. Also, be sure that you deal with any
    side effects. Be sure to clean up after the cancellation has been requested so
    that the CLR can properly flush the cache and clean up its resources.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：在处理异步文件处理时，无论你做什么，尽量使用`CancellationSourceToken`。同时，确保你处理任何副作用。确保在请求取消后进行清理，以便
    CLR 可以正确刷新缓存并清理其资源。
- en: BufferedStream
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BufferedStream
- en: The CLR is pretty good at maximizing performance for your I/O operations. As
    we saw, it can cache data before writing to external devices. This caching speeds
    up our code since we no longer have to wait for the slow write operations to finish.
    However, the CLR makes an educated guess about those caches. Sometimes it gets
    it wrong. If we know the size of the data we want to write, we can use that knowledge
    to get even more performance out of our application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 在最大化 I/O 操作性能方面做得相当不错。正如我们所见，它可以在写入外部设备之前缓存数据。这种缓存加快了我们的代码，因为我们不再需要等待缓慢的写入操作完成。然而，CLR
    对那些缓存做出了明智的猜测。有时它会出错。如果我们知道我们想要写入的数据的大小，我们可以利用这个知识从我们的应用程序中获得更高的性能。
- en: 'Let’s say that we have a system that writes the following record to the I/O:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个系统，它会将以下记录写入 I/O：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This block is 24 bytes long. We can quickly determine that by adding up the
    sizes of `int`, `DateTime`, and double.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块长24字节。我们可以通过将`int`、`DateTime`和`double`的大小相加来快速确定这一点。
- en: If we write that to a file, the CLR will cache it until the systems find a suitable
    moment to do the actual writing of the data to the storage. However, we can improve
    that. We can use the `BufferedStream` class to write this data to a buffer first.
    Then the CLR can flush that buffer to the underlying storage when it thinks it
    is the best time. The advantage here is that we control the size of that buffer
    or cache. If we specify the size just right, we will not waste memory. However,
    we are also not making it too small so that it flushes too often. It is just right
    for us.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些内容写入文件，CLR会将其缓存，直到系统找到一个合适的时机将实际的数据写入存储。然而，我们可以改进这一点。我们可以使用`BufferedStream`类首先将数据写入缓冲区。然后，当CLR认为这是最佳时机时，可以将该缓冲区刷新到底层存储。这里的优势在于我们可以控制该缓冲区或缓存的大小。如果我们指定的大小恰到好处，我们就不会浪费内存。然而，我们也不会将其设置得太小，以免刷新过于频繁。这对我们来说刚刚好。
- en: 'The code to do that looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一功能的代码看起来像这样：
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we will create a `FileStream`. This `FileStream` is the actual handle
    to the file we are writing to. Then, we will create a `BufferedStream` and give
    it the `FileStream` and the size of the record that we want to write. After that,
    we will create a `BinaryWriter` to take our data and write it to the buffer as
    efficiently as possible.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`FileStream`。这个`FileStream`是我们写入的实际文件的句柄。然后，我们将创建一个`BufferedStream`，并给它提供`FileStream`以及我们想要写入的记录的大小。之后，我们将创建一个`BinaryWriter`，以便尽可能高效地将我们的数据写入缓冲区。
- en: When that has all been set up, we will do the writing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置好之后，我们再进行写作。
- en: A word of warning
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告
- en: If you are not sure of the size of the data, having a `BufferedStream` might
    work against you. `BufferedStream` works best if you are doing a lot of smaller,
    frequent writes of data that you know the size of. Otherwise, the cache management
    is best left to the CLR.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定数据的大小，使用`BufferedStream`可能会对你不利。`BufferedStream`在执行大量已知大小的较小、频繁的数据写入时表现最佳。否则，缓存管理最好留给CLR。
- en: File system security
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统安全
- en: Files are where we store things. Those things might not be for everybody to
    see. Sometimes, we must hide data or ensure that only programs that we trust can
    access it. OSs can help. Every OS has a way of handling access to files and directories.
    You can generally allow or disallow read- or write access to them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是我们存储东西的地方。那些东西可能不是每个人都想看到的。有时，我们必须隐藏数据或确保只有我们信任的程序可以访问它。操作系统可以提供帮助。每个操作系统都有处理文件和目录访问的方式。你通常可以允许或拒绝对这些文件的读取或写入访问。
- en: However, what happens when you want to share files? Let us assume that you want
    to transfer data over a wire or store it on another drive such as a removable
    USB drive. In that case, ensuring that level of security is quite challenging.
    This means that you might have to encrypt data to prevent it from being abused.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你想要分享文件时会发生什么呢？让我们假设你想要通过电线传输数据或者将其存储在另一个驱动器上，比如可移动的USB驱动器。在这种情况下，确保那样的安全级别是非常具有挑战性的。这意味着你可能需要加密数据以防止其被滥用。
- en: Security – a topic of its own
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性——一个独立的话题
- en: I am only covering the basics of security and encryption here. This is not a
    complete guide to this complicated and extensive topic. There have been hundreds
    of books written on this topic alone. I want you to know that you can do security
    and encryption. However, if you want to take this seriously, I suggest that you
    go out and find a few good resources on those topics and learn from there.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里只介绍安全性和加密的基础知识。这并不是这个复杂且广泛主题的完整指南。仅关于这个主题就有数百本书籍被撰写。我想让你知道你可以进行安全和加密。然而，如果你想要认真对待这个问题，我建议你出去寻找一些关于这些主题的优质资源，并从那里学习。
- en: Encryption basics
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密基础
- en: 'Basically, we have two encryption flavors: **symmetric** and **asymmetric**
    algorithms. Although there are many similarities between them, one big difference
    is in how they handle keys.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们有两种加密类型：**对称**和**非对称**算法。尽管它们之间有很多相似之处，但一个很大的区别在于它们处理密钥的方式。
- en: Let’s discuss an elementary sample. We’ll say that you have a message and want
    to transmit it to someone else. Since the contents of the message are sensitive,
    you do not want anyone else to be able to read it, so you decided to encrypt it.
    That means that you will change the contents of your message so that nobody can
    make any sense of it. The recipient then decrypts it to change your text into
    something intelligible. We call the text that people can actually read and understand
    **cleartext**. In contrast, the encrypted, unreadable text is something we call
    **ciphertext**. People read cleartext; ciphertext needs decrypting.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个基本的例子。假设你有一条信息，想要将它传输给其他人。由于信息内容敏感，你不想让其他人能够阅读它，所以你决定对其进行加密。这意味着你需要改变信息的内文，使得没有人能够理解它。接收者随后解密它，将你的文本转换成可理解的内容。我们称人们可以实际阅读并理解的内容为**明文**。相反，加密的、不可读的文本是我们所说的**密文**。人们阅读明文；密文需要解密。
- en: This way of protecting information is not new. Julius Caesar did such a thing
    over 2,000 years ago. He used a straightforward substitution algorithm. All he
    did was take a piece of text he wanted to send to his commanders in the field
    and then shift all characters left or right by a certain number of positions.
    The number here is what we call his key.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保护信息的方式并不新颖。2000多年前，凯撒就做过这样的事情。他使用了一种简单的替换算法。他所做的就是取一段他想发送给战场指挥官的文字，然后将所有字符向左或向右移动一定的位置。这里的数字就是我们所说的他的密钥。
- en: So, if Ceasar chose a key of `3`, all As in his message would become Ds. The
    character B would become an E, and so on.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果凯撒选择了`3`这个密钥，他信息中的所有A都会变成D。字符B会变成E，以此类推。
- en: If you knew the key, you could take his ciphertext and reverse the operation
    to get back to the cleartext.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道了密钥，你就可以用他的密文进行逆向操作，恢复成明文。
- en: The problem here is to transmit the actual number to use. Both parties need
    to know the key, or things never work out. You need a secure way of telling the
    other person which key to use so that they can decrypt your ciphertext into cleartext.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是传输实际要使用的数字。双方都需要知道密钥，否则事情永远不会成功。你需要一种安全的方式告诉对方使用哪个密钥，这样他们才能将你的密文解密成明文。
- en: If you know the other person, sharing this key is not hard. You can walk up
    to them, give them the key on a piece of paper in a sealed envelope, and tell
    them to open it only when they receive the encrypted message. These days, however,
    that is a lot harder to do. Computers do not know the other computer they want
    to talk to. It is hard to exchange keys safely.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认识对方，共享这个密钥并不难。你可以走上前去，将密钥写在一张密封的信封里递给他们，并告诉他们只有在收到加密信息时才能打开。然而，如今这样做要困难得多。计算机不知道它们想要与之通信的其他计算机。安全地交换密钥很困难。
- en: 'A possible solution for this is asymmetric encryption and decryption. This
    solution is complicated, but the basis is this: you have two keys. One key is
    used to encrypt the data and another is used to decrypt the data. One of the keys
    is kept private and the other is made public. The private key is yours and yours
    alone. You use it to encrypt a file. Anyone with the public key can then decrypt
    it. Of course, if you want the message to only be read by one other party, you
    can reverse this. You can request that the other party share their public key
    with you. You would then take that key and encrypt the message. Now, only the
    other party can decrypt it again with their private key.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的可能方法是使用非对称加密和解密。这个解决方案很复杂，但其基础是这样的：你有两个密钥。一个密钥用于加密数据，另一个用于解密数据。其中一个密钥是私有的，另一个是公开的。私钥只属于你一个人。你用它来加密文件。任何拥有公钥的人都可以解密它。当然，如果你想信息只被另一个特定方阅读，你可以反过来操作。你可以要求对方与你共享他们的公钥。然后，你用那个密钥加密信息。现在，只有对方才能用他们的私钥再次解密。
- en: Symmetric algorithms are much faster than asymmetric ones. However, they face
    the issue of key sharing. This issue is why most algorithms combine the two methods.
    They use an asymmetric algorithm to encrypt a key, which can be used for symmetric
    encryption. The key is relatively tiny, so encrypting and decrypting can be done
    reasonably quickly. Then that symmetric key is used to encrypt the complete message.
    This way, the symmetric key can be part of the message. It is encrypted itself,
    so only the intended recipient can decrypt the key and, thus, the rest of the
    message.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对称算法比非对称算法快得多。然而，它们面临密钥共享的问题。这就是为什么大多数算法结合两种方法的原因。它们使用非对称算法加密一个密钥，这个密钥可以用于对称加密。这个密钥相对较小，因此加密和解密可以相对快速地进行。然后，使用这个对称密钥来加密整个消息。这样，对称密钥就可以成为消息的一部分。它本身被加密，所以只有预期的接收者才能解密密钥，从而解密消息的其余部分。
- en: 'If this sounds complicated, I have some good news: the CLR has many classes
    to help us do this. They are pretty simple to use as well.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，我有好消息：CLR有许多类可以帮助我们完成这项工作。它们的使用也很简单。
- en: Symmetric encryption and decryption
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称加密和解密
- en: 'Let’s see whether we can encrypt and decrypt a simple message in C# code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否可以在C#代码中加密和解密一个简单的消息：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method takes the names of an input file, an output file, and a key. Then,
    it opens the input file, reads its contents, encrypts it, and writes the cyphertext
    to the output file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法接受输入文件名、输出文件名和一个密钥。然后，它打开输入文件，读取其内容，加密它，并将密文写入输出文件。
- en: The way this works is pretty straightforward.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式非常直接。
- en: First, we will create the two streams. Then we will take the key and generate
    its byte array. The key must be a 128-bit, 192-bit, or 256-bit array. In other
    words, it has to be 16, 24, or 32 bytes long. The longer the key, the harder it
    is to hack. However, a long key also slows down the encryption and decryption
    processes. The choice is yours.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个流。然后，我们将获取密钥并生成其字节数组。密钥必须是128位、192位或256位数组。换句话说，它必须是16、24或32字节长。密钥越长，破解就越困难。然而，长密钥也会减慢加密和解密过程。选择权在你。
- en: We will create an instance of the `Aes` class. **Advanced Encryption Standard**
    (**AES**) is widely considered a good and safe encryption algorithm. To make things
    even safer, the key we will use is augmented with an **Initialization Vector**
    (**IV**). You can think of this as something we add to the key to make it less
    readable. We will write that IV as the first thing in our file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Aes`类的实例。**高级加密标准**（**AES**）被广泛认为是一个好且安全的加密算法。为了使事情更加安全，我们将使用**初始化向量**（**IV**）增强我们的密钥。你可以将其视为我们添加到密钥中以使其更难以阅读的东西。我们将把这个IV作为文件中的第一件事写入。
- en: Then, we will create an instance of the `CryptoStream` class. This class helps
    us write encrypted data, as you can see in the ensuing code block. We will take
    arrays of bytes and write them to the `CryptoStream` class. Since we initialized
    the `CryptoStream` class with our AES class (well, the result of the call to `CreateEncryptor`
    of that class, to be more precise), it uses our key to encrypt data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个`CryptoStream`类的实例。这个类帮助我们写入加密数据，正如你将在接下来的代码块中看到的那样。我们将字节数组传递给`CryptoStream`类。由于我们使用AES类（更确切地说，是该类`CreateEncryptor`调用的结果）初始化了`CryptoStream`类，因此它使用我们的密钥来加密数据。
- en: 'Decrypting is also simple. It works along the same principle: get the files
    from the key, read the IV from the file, then decrypt the rest and store it in
    a new file. That looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 解密也很简单。它遵循相同的原理：从密钥获取文件，从文件中读取IV，然后解密其余部分并将其存储在新文件中。这看起来是这样的：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instead of getting an `Encryptor` from the `CryptoStream`, we now get a `Decryptor`.
    The rest should be self-explanatory by now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不是从`CryptoStream`获取`Encryptor`，而是获取`Decryptor`。其余的现在应该很容易理解了。
- en: Asymmetric encryption and decryption
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称加密和解密
- en: In the previous example, we generated a simple 128-bit, 192-bit, or 256-bit
    key. For instance, you can pass it a string such as `SystemSoftware42` and get
    the bytes. The same key is used for encrypting and decrypting.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们生成了一个简单的128位、192位或256位密钥。例如，你可以传递一个字符串，如`SystemSoftware42`，并获取字节。相同的密钥用于加密和解密。
- en: 'For asymmetric encryption, keys are a bit harder to get. However, there are
    helper classes for that, so it’s not hard to do in practice. Here is the code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非对称加密，获取密钥要困难一些。然而，有辅助类可以帮助完成这项工作，所以在实践中并不困难。以下是代码：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I used the `RSA` class to generate the key pair. The **Rivest, Shamir, and Adleman**
    (**RSA**) class was named after the three cryptographers who invented this algorithm.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了`RSA`类来生成密钥对。**Rivest, Shamir, and Adleman**（**RSA**）类是以发明这个算法的三位密码学家命名的。
- en: We will create an instance of `RSA` by calling `Create()`. Then, we will call
    `ExportRSAPublicKey()` and `ExportRSAPrivateKey()` to get the generated keys out
    of it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用`Create()`来创建一个`RSA`实例。然后，我们将调用`ExportRSAPublicKey()`和`ExportRSAPrivateKey()`来从其中获取生成的密钥。
- en: Since the keys are byte arrays, we will use `ToBase64String()` to make them
    more or less readable. That makes it easier to share the keys.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密钥是字节数组，我们将使用`ToBase64String()`来使它们更易于阅读。这使得共享密钥变得更加容易。
- en: 'Now that we have a key pair, we can use it to encrypt a message. Of course,
    we can also decrypt it again. That code looks like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了密钥对，我们可以用它来加密一条消息。当然，我们也可以再次解密它。这段代码看起来是这样的：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code is simple enough. I only want to point out the last parameter in the
    `rsa.Encrypt()` and `rsa.Decrypt()` methods. We will use padding here to add extra
    data to the results (and we will remove it again when decrypting). This padding
    makes it harder for attackers to try to hack our message.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码足够简单。我只想指出`rsa.Encrypt()`和`rsa.Decrypt()`方法中的最后一个参数。在这里我们将使用填充来向结果中添加额外的数据（并且在解密时我们会将其移除）。这种填充使得攻击者尝试破解我们的消息变得更加困难。
- en: 'You can use the three methods combined like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这三个方法结合起来使用，如下所示：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we will create a key pair. Our method returns that pair as strings so
    we can print them (I am again using our handy `Dump()` extension method). However,
    the keys need to be in a binary format, so I am reverting them to byte arrays.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个密钥对。我们的方法将这个对作为字符串返回，这样我们就可以打印它们（我再次使用我们方便的`Dump()`扩展方法）。然而，密钥需要以二进制格式存在，所以我将它们转换成字节数组。
- en: I will define the message I want to encrypt, get the bytes of that message,
    and encrypt it. Then, I will print the encrypted message. If you do this, I think
    you will agree that it is hard to see the actual message. It is a mess of characters.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我将定义我想要加密的消息，获取该消息的字节，并对其进行加密。然后，我将打印加密后的消息。如果你这样做，我想你会同意这很难看到实际的消息。它是一堆字符的混乱。
- en: Then, we will reverse it by calling `DecryptWithPrivateKey()`. This method returns
    our string.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过调用`DecryptWithPrivateKey()`来反转它。这个方法返回我们的字符串。
- en: If we send the `Base64` version of our public key to someone and then transmit
    the encoded message, they can decode it with that public key. They would be sure
    that we sent that message; no one, other than us, can generate a message that
    can be decrypted by that public key but us. After all, private and public keys
    are a pair. You need one to encrypt so the second can decrypt.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的公钥的`Base64`版本发送给某人，然后传输编码后的消息，他们可以用这个公钥来解码它。他们会确信我们发送了这条消息；除了我们之外，没有人能够生成可以被该公钥解密的消息。毕竟，私钥和公钥是一对。你需要一个来加密，以便第二个可以解密。
- en: Julius Caesar would be proud of us!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 朱利叶斯·凯撒会为我们感到骄傲！
- en: However, we have one more thing to talk about. We need to lose weight. Well,
    not us personally, but the payload in our files could benefit from this. Let’s
    talk about file compression.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有另一件事要讨论。我们需要减轻负担。好吧，不是我们个人，而是我们文件中的有效载荷可能会从中受益。让我们谈谈文件压缩。
- en: File compression
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件压缩
- en: Files can get quite large. As we have already discussed, file IO and network
    IO take a long time, especially compared to CPUs’ speeds. Anything we can do to
    minimize the time it takes to read from or write to IO could be worth it. This
    is even true if it means that we must make the CPU do a lot more. Of course, you
    need to measure this and see whether that also applies in your situation, but
    sometimes, sacrificing CPU time to speed up IO can make a huge difference.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可能会变得相当大。正如我们已经讨论过的，文件I/O和网络I/O需要很长时间，尤其是与CPU的速度相比。我们能够做的任何减少从I/O读取或写入所需时间的操作都可能是有价值的。即使这意味着我们必须让CPU做更多的工作，这也同样是正确的。当然，你需要测量这一点并看看它是否也适用于你的情况，但有时，为了加快I/O速度而牺牲CPU时间可能会产生巨大的差异。
- en: One of the ways to do this is by limiting the amount of data we write in a file
    or a network stream. That can be done using compression.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法是通过限制写入文件或网络流中的数据量。这可以通过压缩来完成。
- en: In the CLR, you have a choice. You can use `DeflateStream` or `GZipStream` to
    do this. `GZipStream` uses `DeflateStream` internally, so `DeflateStream` is obviously
    faster. `GZipStream`, however, produces compressed files that can be read by external
    software. GZip is a standardized compression algorithm.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CLR 中，你有选择。你可以使用 `DeflateStream` 或 `GZipStream` 来做这件事。`GZipStream` 在内部使用 `DeflateStream`，所以
    `DeflateStream` 显然更快。然而，`GZipStream` 生成的压缩文件可以被外部软件读取。GZip 是一个标准化的压缩算法。
- en: Compressing some data
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩一些数据
- en: 'Let’s compress a string using `GZipStream`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `GZipStream` 压缩一个字符串：
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since compression and decompression might take a long time to finish, we really
    should use the `Async/Await` pattern here.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于压缩和解压缩可能需要很长时间才能完成，我们在这里真的应该使用 `Async/Await` 模式。
- en: We will take some strings that we want to compress and pass them to the input
    variable. I use a `MemoryStream` in this example, but you could use any stream
    you like. Most real-world examples use a `FileStream` of some sort.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将取一些想要压缩的字符串并将它们传递给输入变量。在这个例子中，我使用了 `MemoryStream`，但你也可以使用你喜欢的任何流。大多数现实世界的例子使用某种形式的
    `FileStream`。
- en: I will create an instance of the `GZipStream` class and give it the `MemoryStream`
    instance. This memory stream is where it writes the data. I will also tell the
    class that I want to compress data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个 `GZipStream` 类的实例，并给它一个 `MemoryStream` 实例。这个内存流是它写入数据的地方。我还会告诉这个类我想要压缩数据。
- en: Then I just write data to it, flush the buffers, and get the bytes out of it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我只需将数据写入其中，刷新缓冲区，并从中获取字节。
- en: That’s it! I have just compressed a string.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我已经压缩了一个字符串。
- en: Decompressing some data
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解压缩一些数据
- en: 'Decompressing is just as easy. Look at the following code sample:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩同样简单。看看下面的代码示例：
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, I used two instances of the `MemoryStream` class. I used one as the source
    of the data and one as the destination of the uncompressed data. Again, please
    use any stream you want.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了两个 `MemoryStream` 类的实例。我使用一个作为数据的源，另一个作为未压缩数据的目的地。再次提醒，请使用你想要的任何流。
- en: 'You can use these methods as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方法：
- en: '[PRE38]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That was not too hard, was it?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 那并不太难，对吧？
- en: However, we are not done yet. The data that we want to store or read needs to
    be in a certain format. If you have a C# class with data in it, you cannot simply
    write that to a file. We need to translate that somehow. That’s where serialization
    comes in.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完成。我们想要存储或读取的数据需要以某种格式存在。如果你有一个包含数据的 C# 类，你不能简单地将其写入文件。我们需要以某种方式将其转换。这就是序列化的用武之地。
- en: Serialization – JSON and Binary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化 – JSON 和二进制
- en: Earlier in this chapter, we saw how to write binary data to a stream. We can
    call all the `write` methods to write all sorts of types to a file. However, that
    can be pretty hard and also quite error-prone. You have to keep track of the format
    of the data. One simple mistake will make your files unreadable.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们看到了如何将二进制数据写入流。我们可以调用所有 `write` 方法将各种类型写入文件。然而，这可能会相当困难，并且也容易出错。你必须跟踪数据的格式。一个简单的错误会使你的文件无法读取。
- en: 'A better way would be to serialize your data in a format that the streams can
    understand. There are two ways to do that: **JSON** and **Binary**.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是将你的数据序列化成流可以理解的格式。有两种方法可以做到这一点：**JSON** 和 **二进制**。
- en: 'JSON is simple: most programming languages and platforms understand it. JSON
    has become the de facto standard for displaying a structure in text. In most places,
    JSON has replaced XML. JSON is smaller and more lightweight.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 很简单：大多数编程语言和平台都理解它。JSON 已经成为在文本中显示结构的既定标准。在大多数地方，JSON 已经取代了 XML。JSON 更小，更轻量。
- en: However, it can be even more lightweight. You can also serialize your data as
    a binary stream. That requires more coding but usually results in much smaller
    files and data streams. Again, that might be precisely what we, as system programmers,
    are looking for.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它还可以更轻量。你还可以将你的数据序列化为二进制流。这需要更多的编码，但通常会产生更小文件和数据流。再次提醒，这可能是我们作为系统程序员所寻找的。
- en: JSON serialization
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 序列化
- en: To serialize an object to the JSON format, people used to turn to `NewtonSoft.JSON`
    by default. `NewtonSoft.JSON` was the library of choice. It was easy to use (and
    still is) and offered many features that people liked, such as custom converters.
    However, Microsoft has since released `System.Text.Json`, which does the same
    but is much more efficient. As system programmers, we care about memory efficiency
    and speed, so I will focus on that one here.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要将对象序列化为 JSON 格式，人们过去默认使用 `NewtonSoft.JSON`。`NewtonSoft.JSON` 是首选库。它易于使用（并且仍然如此）并提供了许多人们喜欢的功能，例如自定义转换器。然而，微软随后发布了
    `System.Text.Json`，它执行相同的操作但效率更高。作为系统程序员，我们关心内存效率和速度，因此我将重点关注这一点。
- en: Before we can serialize something, we need something to serialize. The advantage
    of `System.Text.Json` is that I do not need to change my classes with attributes.
    The framework is smart enough to figure out what is needed and does that.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够序列化某个对象之前，我们需要一个可以序列化的对象。`System.Text.Json` 的优势在于我无需更改带有属性的类。框架足够智能，能够找出所需的内容并完成它。
- en: 'I will use the same data class we saw earlier in this chapter in these examples.
    However, to save you from flipping through pages, I present it to you here once
    again:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用本章前面看到的相同数据类在这些示例中。然而，为了节省您翻页的时间，我再次在这里向您展示它：
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we want to serialize this to JSON to store it as text and later reread it,
    we will use the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将此序列化为 JSON 以存储为文本并在以后重新读取，我们将使用以下代码：
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The code presented here is pretty straightforward. We will take the `MyData`
    class and give it to the static `Serialize` method, `System.Text.Json.JsonSerializer`.
    There are a couple of overloads for this method. I will use the one that takes
    an instance of the `JsonSerializerOptions` class. This way, I can format the output.
    I will set the `WriteIdented` property to `True`. I would get the whole string
    on one line if I had not done that. Granted, that would have saved me a couple
    of newline and tab characters, but for readability, I prefer this.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码相当直接。我们将使用 `MyData` 类并将其传递给静态 `Serialize` 方法，`System.Text.Json.JsonSerializer`。此方法有几个重载。我将使用一个接受
    `JsonSerializerOptions` 类实例的重载。这样，我可以格式化输出。我将 `WriteIdented` 属性设置为 `True`。如果没有这样做，我将会得到整个字符串在一行上。诚然，这会节省我几个换行符和制表符字符，但为了可读性，我更喜欢这种方式。
- en: 'We will get the following result if we run this with some values in our class:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类中运行一些值，我们将得到以下结果：
- en: '[PRE41]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Deserializing, thereby reversing the process, is just as simple:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化，即逆转该过程，同样简单：
- en: '[PRE42]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the process is simple enough.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个过程足够简单。
- en: Binary serialization
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制序列化
- en: It is not the most efficient way to encode an object so you can store it in
    a file. It is relatively fast, but the actual data is also pretty large. Binary
    formatting is more work and the result is not human-readable, but it does lead
    to smaller files. That means that the time spent reading and writing data to a
    slow storage medium is significantly reduced. Of course, the tradeoff is that
    the CPU gets a bit busier, but that might be worth it. As always, measure and
    then decide whether this applies to your situation.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是将对象编码以便存储在文件中的最有效方式。它相对较快，但实际数据也相当大。二进制格式化需要更多的工作，结果也不是人类可读的，但它确实导致了文件更小。这意味着将数据写入和读取到慢速存储介质所需的时间显著减少。当然，权衡是
    CPU 会变得稍微忙碌一些，但这可能值得。一如既往，先衡量，然后决定这是否适用于您的情况。
- en: In .NET Framework, before the days of .NET Core and .NET, we had a class named
    `BinaryFormatter`. That class, however, is now marked as obsolete. There are serious
    security concerns associated with that class, so Microsoft decided to get rid
    of it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Framework 中，在 .NET Core 和 .NET 之前，我们有一个名为 `BinaryFormatter` 的类。然而，该类现在已被标记为过时。与该类相关的存在严重的安全担忧，因此微软决定将其淘汰。
- en: There are third-party packages you can use to achieve the same goal. However,
    if you do not want to use those, you can always do it yourself. We already discussed
    the `BinaryWriter` class and its methods. There is nothing wrong with using that
    class, but the downside is that you must write all the code, writing and reading
    each field or property. The `BinaryFormatter` class did that. That was quite handy,
    to be honest.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用第三方包来实现相同的目标。然而，如果您不想使用那些，您始终可以自己完成。我们已经讨论了 `BinaryWriter` 类及其方法。使用该类并没有什么问题，但缺点是您必须编写所有代码，包括写入和读取每个字段或属性。`BinaryFormatter`
    类就是这样做的。坦白说，这相当方便。
- en: 'The best package these days to achieve the same thing is `protobuf-net`. This
    package is available on NuGet, making it easy to install in your project. If you
    want to use `protobuf-net`, you must annotate your classes before you can serialize
    them. Using our `MyData` class again, it would look like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 目前实现相同功能的最佳包是 `protobuf-net`。此包可在 NuGet 上找到，这使得在项目中安装变得容易。如果您想使用 `protobuf-net`，您必须在序列化之前对您的类进行注解。再次使用我们的
    `MyData` 类，它看起来会是这样：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We have decorated the class with the `ProtoContract` attribute. Then, we decorated
    the properties with the `ProtoMember` attribute. This attribute can have associated
    data, but the first one is mandatory. This is the tag and it defines where the
    field is stored in the file. There is no hard rule on the numbering or the order
    aside from one: you cannot start with 0\. Yes. Indeed. I heard you gasp there.
    This is the only example I can think of in programming where starting with 0 is
    forbidden. If you want to start with 42, you can do that. However, the number
    has to be a positive integer, and 0 is not a positive integer.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 `ProtoContract` 属性装饰了类。然后，我们用 `ProtoMember` 属性装饰了属性。这个属性可以关联数据，但第一个是必需的。这是标签，它定义了字段在文件中的存储位置。除了一个规则之外，没有关于编号或顺序的硬性规定：你不能从
    0 开始。是的。确实如此。我听到你在那里倒吸一口凉气。这是我能想到的唯一一个在编程中从 0 开始是禁止的例子。如果你想从 42 开始，你可以这样做。然而，数字必须是一个正整数，而
    0 不是一个正整数。
- en: 'Serializing and deserializing are simple. You have to ensure that the data
    is available in a memory stream or can be written to a memory stream, but that
    is the only slightly complicated thing. This is the code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化很简单。您必须确保数据可以在内存流中可用或可以写入内存流，但这只是稍微复杂的一件事。这是代码：
- en: '[PRE44]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That is it. I promised you that it would be simple, didn’t I?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了。我承诺这会很简单，不是吗？
- en: If I take the same data as in the JSON serialization and compare the sizes,
    I can see that the binary version is much smaller. Even if I use the option not
    to write intended files, thus saving on newlines and tabs, the JSON version is
    131 bytes. In comparison, the binary version is only 60 bytes long. That is a
    big difference!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将与 JSON 序列化相同的数据进行比较，我可以看到二进制版本的数据量要小得多。即使我使用不写入预期文件的选择，从而节省了换行符和制表符，JSON
    版本也有 131 字节。相比之下，二进制版本只有 60 字节长。这是一个很大的差异！
- en: Next steps
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: I/O is essential for all software. No software runs in isolation, especially
    software written for systems. After all, these applications do not have a traditional
    user interface; they are meant to be used by other software. The only way to communicate
    with that software is by exchanging data in one way or another.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 对所有软件都是至关重要的。没有软件是孤立运行的，尤其是为系统编写的软件。毕竟，这些应用程序没有传统的用户界面；它们是供其他软件使用的。与该软件的唯一通信方式是通过以某种方式交换数据。
- en: This chapter has looked at ways to serialize and deserialize data to and from
    storage. We saw that JSON is simple and produces human-readable data. However,
    the data can be pretty big. In contrast, the binary version results in much smaller
    data, but that data is not human-readable anymore. Additionally, it requires a
    third-party package. What is the best solution? That depends on your use cases!
    It doesn’t matter whether you use files or a network connection; they are all
    approaches of I/O. In this chapter, you saw how to do that efficiently, quickly,
    and safely.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了将数据序列化和反序列化到存储中的方法。我们了解到 JSON 简单且生成可读性强的数据。然而，数据可能相当庞大。相比之下，二进制版本的数据量要小得多，但这样的数据不再适合人类阅读。此外，它还需要第三方包。最佳解决方案是什么？这取决于您的使用场景！无论您使用文件还是网络连接，它们都是
    I/O 的方法。在本章中，您看到了如何高效、快速且安全地实现这一点。
- en: However, one way that is much more efficient for systems software to communicate
    is through direct communication over **Interprocess Communications** (**IPC**).
    IPC is a perfect way for systems software to establish an interface layer that
    other software can talk to or listen to. It is also the topic of the next chapter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于系统软件来说，一种更高效的方式来通信是通过直接在 **进程间通信**（**IPC**）上进行通信。IPC 是系统软件建立其他软件可以与之交谈或监听的接口层的一个完美方式。这也是下一章的主题。
