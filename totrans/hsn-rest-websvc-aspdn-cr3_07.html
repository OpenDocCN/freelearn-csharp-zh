<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Web Service Stack in ASP.NET Core</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter describes how to deal with controllers and actions in a web service stack. Controllers are a fundamental part of ASP.NET Core; they are the entry point of the HTTP requests. In this chapter, we will look closely at the mechanics of the controller classes and how they can transfer information to the client using the HTTP protocol.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>What is a controller?</li>
<li>Handling requests using controllers and actions</li>
<li>How to deal with DTO objects</li>
<li>Implementing validation</li>
</ul>
<p>By the end of the chapter, the reader will have a general overview of the web stack provided by ASP.NET Core and will know how to deal with incoming HTTP requests using controllers and actions. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a controller?</h1>
                </header>
            
            <article>
                
<p>Controllers are the <em>C</em> part of the MVC pattern. They <span><span>are </span></span>a set of actions that usually handle requests from a client. You should bear in mind that what we are discussing in this chapter refers to the MVC stack that's defined by ASP.NET Core. Furthermore, if we take as reference the incoming requests, remember that they have already passed through the others middleware in the middleware pipeline and that they have already hit the <em>MVC middleware</em>.</p>
<p>The following diagram shows how a request is typically handled:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bf9541b7-bc49-4440-94c6-19cea945cfe0.png" style=""/></div>
<p class="mce-root">As we discussed in <a href="b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml">Chapter 1</a>, <em>REST 101 and Getting Started with ASP.NET Core</em>, the incoming request is usually generated by a client: the browser, another API, or an external system. The request is composed of an <em>HTTP verb,</em> a <em>URI</em>, <em>body payload</em>, and other additional information<em>.</em> The <strong>Routing engine</strong> handles the request and passes it to an <em>action method</em> inside one of our <em>controllers. </em>The <strong>Action</strong> methods usually proceed by providing a response. Furthermore, controllers usually interact with third-party systems through other classes, such as databases or other services. Finally, they serve the result in a specific format. In the case of MVC applications, they usually return a view, while in the case of the web API, they return the result in a format such as <strong>JSON/XML</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73cd4cb1-2e15-40a0-ac07-5c22eab039de.png" style=""/></div>
<p>The preceding diagram shows the flow of an incoming request through the model-controller stack. As you can see, the flow is omitting the views part of the MVC stack since it is not useful for the purpose of building web services. The next part focuses on controllers and explains how to identify a controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying controllers</h1>
                </header>
            
            <article>
                
<p>Controllers and actions<span> </span>are usually decorated<span> </span>with attributes and filters in a sort of meta-programming style, which allows developers to understand the purpose of the implemented code. ASP.NET Core follows a set of criteria to find the controllers in our project, usually by using a filesystem convention. Controllers<span> </span>are generally stored<span> </span>in the <kbd>Controllers</kbd> folder.  </p>
<p>In order to be identified by the routing system, a controller class needs to be compliant with one of the following rules:</p>
<ul>
<li>The class<span> </span>is suffixed<span> </span>with <kbd>Controller</kbd>, or it inherits from a class that has the <kbd>Controller</kbd> suffix</li>
<li>The<span> </span>class<span> </span>is decorated<span> </span>with the <kbd>[Controller]</kbd> or the <kbd>[ApiController]</kbd> attribute, which identifies it as a controller class</li>
</ul>
<div class="packt_tip">As we mentioned in <a href="54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml">Chapter 4</a>, <em>Dependency Injection</em>, it is recommended to define controller dependencies using the constructor or action injection explicitly<span>. The dependency injection approach improves the testability and maintainability of the controller.</span></div>
<p>Now, let's see how a widespread concept like inheritance can be applied to the controllers in order to extend their functionalities, and how ASP.NET Core provides some of the bases attributes to the controller classes using this technique. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending controllers</h1>
                </header>
            
            <article>
                
<p class="mce-root">As already mentioned, controllers are classes, therefore they can extend other types, including other controllers. This technique can be applied so that we can reuse a particular implementation or feature. In general, the controllers extend the <kbd>Controller</kbd> or <kbd>ControllerBase</kbd> classes, which are part of the ASP.NET Core framework. These base classes provide some utilities to manage requests and responses on behalf of the controller. First of all, let's analyze the difference between the <kbd>Controller</kbd> and <kbd>ControllerBase</kbd> classes:</p>
<ul>
<li><kbd>ControllerBase</kbd> represents a base class for an MVC controller without view support. It provides some essential attributes to child classes, such as the <kbd>HttpContext</kbd>, <kbd>Request</kbd>,<span> </span>and <kbd>Response</kbd> attributes.</li>
<li>The <kbd>Controller</kbd> class extends the <kbd>ControllerBase</kbd> class, but it also adds some properties and methods for managing views, such as the <kbd>ViewData</kbd> attribute and the <kbd>View()</kbd> and <kbd>PartialView()</kbd> methods.</li>
</ul>
<p>When we deal with RESTful APIs and with web services in general, the <kbd>ControllerBase</kbd> class provides sufficient utilities. If we are dealing with views, however, we should extend the <kbd>Controller</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ApiController attribute</h1>
                </header>
            
            <article>
                
<p>From version 2.1, ASP.NET Core introduced a new attribute, that is, the <kbd>ApiController</kbd> attribute:</p>
<pre><span>using </span><span>Microsoft</span>.<span>AspNetCore</span>.<span>Mvc</span>;<br/><br/><span>namespace SampleAPI.API.Controllers</span><span><br/></span>{<br/>    [<span>Route</span>(<span>"api/[controller]"</span>)]<br/>    <strong>[<span>ApiController</span>]</strong><br/>    <span>public class </span><span>ValuesController </span>: <span>ControllerBase<br/></span><span>    </span><span>{</span><br/>      // ...<br/>    }<br/>{</pre>
<p><span>The <kbd>ApiController</kbd> </span><span>attribute is commonly coupled with the <kbd>ControllerBase</kbd> class </span><span>to enable REST-specific behavior for controllers, and it allows us to build HTTP APIs. </span><span>First of all, it provides <em>implicit model state validation</em>, which means that we do not need to explicitly check the <kbd>ModelState.IsValid</kbd> attribute in each action. Secondly, it also implicitly defines the model binding attributes, which means that we do not need to specify the <kbd>[FromBody]</kbd>, <kbd>[FromForm]</kbd>, <kbd>[FromHeader]</kbd>, <kbd>[FromQuery]</kbd>, or <kbd>[FromRoute]</kbd> attributes for each parameter. ASP.NET Core will define these for us using the following criteria:</span></p>
<ul>
<li><kbd>[FromBody]</kbd> is used for complex type parameters, such as custom classes or built-in objects.</li>
<li><kbd>[FromForm]</kbd> is inferred for action parameters of the <kbd>IFormFile</kbd> or <kbd>IFormFileCollection</kbd> type.</li>
<li><kbd>[FromRoute]</kbd><span> is inferred for any action parameter whose name matches a setting in the route template.</span></li>
<li class=""><kbd>[FromQuery]</kbd><span> </span>is inferred for any other action parameters.</li>
</ul>
<p>Let's examine the following generic action method:</p>
<pre>    [<span>Route</span>(<span>"api/[controller]"</span>)]<br/>    <span>public class </span><span>ValuesController </span>: <span>ControllerBase<br/></span><span>    </span>{<br/>        // ...<br/><span><br/></span><span>        </span>[<span>HttpPost</span>]<br/>        <span>public </span><span>IActionResult </span><span>Post</span>([<span>FromBody</span>]<span>ValueRequest </span><span>request</span>)<br/>        {<br/>            <span>if </span>(<span>ModelState</span>.<span>IsValid</span>) <br/>            {<br/>                <span>return </span><span>BadRequest</span>(<span>ModelState</span>);<br/>            }<br/><br/>            <span>return </span><span>Ok</span>();<br/>        }<br/><br/>        // ..<br/>    }</pre>
<p class="mce-root">After the application of the <kbd>ApiController</kbd> attribute, the action method can be minimized, as shown here:</p>
<pre>    [<span>Route</span>(<span>"api/[controller]"</span>)]<br/>    <strong>[ApiController]</strong><br/>    <span>public class </span><span>ValuesController </span>: <span>ControllerBase<br/></span><span>    </span>{<br/>        // ...<br/><span><br/></span><span>        </span>[<span>HttpPost</span>]<br/>       <strong> <span>public </span><span>IActionResult </span><span>Post</span>(<span>ValueRequest </span><span>request</span>)</strong><br/><strong>        {</strong><br/><strong>            <span>return </span><span>Ok</span>();</strong><br/><strong>        }</strong><br/><br/>        // ..<br/>    }</pre>
<p>The <kbd>[FromBody]</kbd> attribute is implicitly specified because of the <kbd>ValueRequest</kbd> complex type. In the same way, the <kbd>ModelState.IsValid</kbd> check is also implicit: if the client passes a model that is not valid for the action, it will return <kbd>400 bad requests</kbd>. In the next section, we will look into the implementation of a simple controller that can handle and perform some logic using a repository class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling requests using controllers and actions</h1>
                </header>
            
            <article>
                
<p><span>The purpose of action methods is to handle and respond to incoming requests. </span>The example described in this section will show you how to deal with HTTP requests using controllers.<span> We will apply some of the concepts we have looked at in previous chapters, such as dependency injection. The following example will use the same project structure we created in <em>Setting up an ASP.NET Core project</em> section of <a href="6127f023-703b-42e3-a76e-b70a7b110b90.xhtml">Chapter 2</a></span>,<span> <em>Overview of ASP.NET Core.</em></span></p>
<div class="packt_infobox">The source code for this section is available on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</div>
<p>The next subsection introduces a plain in-memory repository that will be used<span> to store some data and retrieve it through our controller stack. The purpose of this type of repository is to set up a quick storage system without introducing any additional application complexity.  </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an in-memory repository</h1>
                </header>
            
            <article>
                
<p>The simplest way to create an <em>in-memory</em> repository is to define a singleton class with a private attribute, which represents a collection of elements. The repository will be initialized as a <em>singleton type</em>; therefore, this specific life cycle guarantees that data will be persistent until the application is restarted. </p>
<div class="packt_infobox">At this stage, we don't need to use a repository with a real data source because we only <span>need to focus on the HTTP part of our example and not how the data is stored. Later on in this book, we will take a look closer at the data access part.</span></div>
<p><span>First of all, we need a model that represents the data we want to store using our repository. Let's create a new folder, called</span> <kbd>Models</kbd><span>, and create a new class named <kbd>Order.cs</kbd>:</span></p>
<pre><span>using </span><span>System</span>;<br/><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Models<br/></span><span> </span>{<br/>  <span>public class </span><span>Order</span><br/>     {<br/>         <span>public </span><span>Guid </span><span>Id </span>{ <span>get</span>; <span>set</span>; }<br/>         <span>public </span><span>IEnumerable</span>&lt;<span>string</span>&gt; <span>ItemsIds </span>{ <span>get</span>; <span>set</span>; }<br/>     }<br/> }</pre>
<p>Now, <span>we need to define a new interface called <kbd>IOrderRepository</kbd>. The interface represents our order repository, and it will be located in a new folder called </span><kbd>Repositories</kbd><span>:</span></p>
<pre><span>using </span><span>System</span>;<br/><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><span>using </span><span>SampleAPI</span>.<span>Models</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Repositories<br/></span>{<br/>    <span>public interface </span><span>IOrderRepository<br/></span><span>    </span>{<br/>        IEnumerable&lt;<span>Order</span>&gt; <span>Get</span>();<br/>        <span>Order </span><span>Get</span>(<span>Guid </span>orderId);<br/>        <span>void </span><span>Add</span>(<span>Order </span>order);<br/>        <span>void </span><span>Update</span>(<span>Guid </span>orderId, <span>Order </span>order);<br/>        <span>Order </span><span>Delete</span>(<span>Guid </span>orderId);<br/>    }<br/>}</pre>
<p>Our interface is implemented by the <kbd>MemoryOrderRepository</kbd> <span>class,</span><span> </span><span>which provides the concrete logic of our interface:</span></p>
<pre><span>using </span>System;<br/><span>using </span>System.Collections.Generic;<br/><span>using </span>System.Linq;<br/><span>using SampleAPI.Models;<br/><br/>namespace </span>SampleAPI.Repositories<br/>{<br/>    <span>public class </span><span>MemoryOrderRepository </span>: <span>IOrderRepository<br/></span><span>    </span>{<br/>        <span>private </span><span>IList</span>&lt;<span>Order</span>&gt; _orders { <span>get</span>; <span>set; </span>}<br/>        <br/>        <span>public </span><span>MemoryOrderRepository</span>()<br/>        <span>{</span><br/>            _orders = <span>new </span><span>List</span>&lt;<span>Order</span>&gt;();<br/>        <span>}</span><br/>        <span>public </span><span>IEnumerable</span>&lt;<span>Order</span>&gt; Get() =&gt; _orders;<br/><br/>        <span>public </span><span>Order </span>Get(<span>Guid </span>orderId)<br/>        {<br/>            <span>return </span>_orders.FirstOrDefault(o =&gt; o.Id <span>== </span>orderId);<br/>        }<br/>        <span>public void </span>Add(<span>Order </span>order)<br/>        {<br/>            _orders.Add(order);<br/>        }<br/><br/>        <span>public void </span>Update(<span>Guid </span>orderId, <span>Order </span>order)<br/>        {<br/>            <span>var </span>result = _orders.FirstOrDefault(o =&gt; o.Id <span>== </span>orderId);<br/><br/>            <span>if </span>(result != <span>null</span>) result.ItemsIds = order.ItemsIds;<br/>        }<br/>        <span>public </span><span>Order </span>Delete(<span>Guid </span>orderId)<br/>        {<br/>            <span>var </span>target = _orders.FirstOrDefault(o =&gt; o.Id <span>== </span>orderId);<br/>            _orders.Remove(target);<br/><br/>            <span>return </span>target;<br/>        }<br/>    }<br/>}</pre>
<p class="p1">The <kbd>MemoryOrderRepository</kbd> class initializes a private list of the <kbd>Order</kbd> type. <span>Furthermore, it also defines some operations that we can use to manipulate the list of orders, that are, the <kbd>Get</kbd>, <kbd>Add</kbd>, <kbd>Update</kbd>, and <kbd>Delete</kbd> methods. These methods use the LINQ syntax to act on the list elements. Furthermore, the main collection that's represented by the <kbd>_orders</kbd> attribute is declared as private in order to prevent any external access.</span></p>
<div class="packt_tip">Note that each namespace path reflects the structure of the filesystem. For example, the <kbd>SampleAPI.Repositories</kbd> namespace reflects the <kbd>Sample.API/Repositories</kbd> filesystem path.</div>
<p>Finally, we can proceed by initializing the <kbd>MemoryOrderRepository</kbd> implementation as <em>a singleton.</em> To do that, we need to modify the <kbd>Startup</kbd> class and add our service to the <em>services collection</em> using the <kbd>AddSingleton</kbd> method:</p>
<pre><span>using Microsoft.AspNetCore.Builder;<br/></span><span>using Microsoft.AspNetCore.Hosting;<br/></span><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>Configuration</span>;<br/><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>DependencyInjection</span>;<br/><span>using Microsoft.Extensions.Hosting;<br/></span><strong><span>using </span><span>SampleAPI</span>.<span>Repositories</span>;</strong><br/><br/><span>namespace </span><span>SampleAPI<br/></span>{<br/>    <span>public class </span><span>Startup<br/></span><span>    </span>{<br/><br/>        <span>public </span><span>IConfiguration </span><span>Configuration </span>{ <span>get</span>; }<br/>        <br/>        // ..<br/><br/>        <span>public void </span><span>ConfigureServices</span>(<span>IServiceCollection </span>services)<br/>        {<br/>            services<br/>                <strong>.<span>AddSingleton</span>&lt;<span>IOrderRepository</span>, <span>MemoryOrderRepository</span>&gt;()</strong><br/>                .<span>AddControllers</span>();<br/>        }<br/>        // ...<br/>    }<br/>}</pre>
<div class="packt_infobox">The following example uses the <kbd>IOrderRepository</kbd> interface for demonstration and learning purposes. I strongly suggest that you avoid using singleton instances to store data in memory since singleton instances are not persistent storage, and this also causes performance degradation in our application.</div>
<p>In summary, we now have an <kbd>Order</kbd> class that describes a single order. The <kbd>IOrderRepository</kbd> interface allows us to store and read the data, and it has an in-memory implementation provided by the <kbd>MemoryOrderRepository</kbd> type, which uses the memory as a data store. Now, we have all the necessary components so that we can deal with the data and we can proceed by handling the client request through our controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling client requests</h1>
                </header>
            
            <article>
                
<p class="mce-root">Every time we implement a class, we should always bear the <em>single</em> <em>responsibility</em> <em>principle</em> in mind.<em> </em>Therefore<em>,</em> the action methods inside our controllers should be simple handlers that call methods that act as data. The controllers in an ASP.NET Core service usually behave as follows:</p>
<ul>
<li>They make calls other classes in order to obtain or update data held in, for example, a repository class.</li>
<li>They handle exceptions. The action methods typically wrap the calls of other objects to catch exceptions. These<span> </span>are then presented<span> </span>to the client.</li>
<li>They enhance the returned data using the required HTTP conventions.</li>
</ul>
<p>Let's proceed and build our controller class by creating a new <kbd>OrderController</kbd> type inside the <kbd>Controllers</kbd> folder. This bit of code includes the <kbd>ApiController</kbd> attribute and the extension to the <kbd>ControllerBase</kbd> class:</p>
<pre><span>...<br/><strong>[Route("api/order")]</strong><br/>[ApiController]<br/>public class OrderController : ControllerBase {}<br/>...<br/></span></pre>
<p>ASP.NET Core provides two ways to deal with routing:</p>
<ul>
<li>Decorating controllers with attributes</li>
<li>Extending the default routing system (for example, using the <kbd>MapRoute</kbd> method)</li>
</ul>
<p>Defining routes using attributes covers a lot of cases and is suitable for a range of business requirements. It is also more straightforward in regard to the maintainability and readability of our code. The <kbd><span>[Route("api/order")]</span></kbd><span> </span>attribute maps a specific controller to one particular route. In this case, the <kbd>OrderController</kbd> will respond at the <kbd>//hostname/api/order</kbd> URI. In addition, the ASP.NET Core framework also provides <span>two placeholders</span><span>:</span> <kbd>[controller]</kbd> <span>and</span> <kbd>[action]</kbd><span>. They can be used to refer to the current controller or to the immediate action. For example, the previous snippet can also be written as follows:</span></p>
<pre><span>...<br/><strong>[Route("api/[controller]")]</strong><br/>[ApiController]<br/>public class OrderController : ControllerBase<br/>...<br/></span></pre>
<div class="packt_tip"><span>I strongly suggest avoiding the use of the </span><kbd>[controller]</kbd><span> and </span><kbd>[action]</kbd><span> placeholders. If you refactor the name of your controllers or actions, you also change the routing of your service without throwing any errors. Therefore, it can cause problems in systems with interdependent services.</span></div>
<p>Let's proceed by initializing and resolving the dependencies of the <kbd>OrderController</kbd> class. Furthermore, we will see how we can inject and initialize the <kbd>IOrderRepository</kbd> interface into the controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling HTTP methods using actions</h1>
                </header>
            
            <article>
                
<p>Now that we have the <kbd>OrderController</kbd> definition and the <kbd>IOrderRepository</kbd> interface has been registered through the dependency injection engine, we can proceed by defining the explicit dependencies using <em>constructor injection</em>:</p>
<pre><span>using System;<br/>using </span>Microsoft.AspNetCore.Mvc;<br/>using SampleAPI.Models;<br/><br/><span>namespace </span>SampleAPI.Controllers<br/> {<br/>     [<span>Route</span>(<span>"api/order"</span>)]<br/>     [<span>ApiController</span>]<br/>     <span>public class </span><span>OrderController </span>: <span>ControllerBase<br/></span><span>     </span><span>{</span><br/>         <strong><span>private readonly </span><span>IOrderRepository </span><span>_orderRepository</span>;</strong><br/><br/>         <strong><span>public </span><span>OrderController</span>(<span>IOrderRepository </span>orderRepository)</strong><br/><strong>         {</strong><br/><strong>             _orderRepository = orderRepository;</strong><br/><strong>         }</strong><br/><br/>        ...<br/>    <span>}</span><br/> }</pre>
<p>The <kbd>OrderController</kbd> class depends on the <kbd>IOrderRepository</kbd> class, and it uses constructor injection to resolve the dependency. This dependency is clearly visible if we check the constructor signature of the controller. In most cases, you can get an idea of the level of complexity of a class by counting the number of dependencies that have been injected into the <em>constructor</em>. Therefore, as a general rule, when you see a class with a lot of dependencies injected into it, it is probably not compliant with the <em>single responsibility principle. </em></p>
<p><span>The controller classes usually group a set of action methods. As we discussed in <a href="b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml">Chapter 1</a>, <em>REST 101 and Getting Started with ASP.NET Core</em>, HTTP verbs are essential in web APIs and REST services. They are used to indicate a specific operation on our data. For example, an HTTP GET corresponds to a read operation, while an HTTP POST corresponds to a creation action. Let's continue with the implementation of the HTTP GET actions:</span></p>
<pre><span><span>[</span><span>Route</span><span>(</span><span>"api/order"</span><span>)</span><span>]</span><br/><span>[</span><span>ApiController</span><span>]</span><br/><span>public</span><span> </span><span>class</span><span> </span><span>OrderController</span><span> </span><span>:</span><span> </span><span>ControllerBase</span><br/> <span>    </span><span>{</span><br/> <span> </span><span>private</span><span> </span><span>readonly</span><span> </span><span>IOrderRepository</span><span> </span><span>_orderRepository</span><span>;</span><br/> <br/> <span> </span><span>public</span><span> </span><span>OrderController</span><span>(</span><span>IOrderRepository</span><span> </span><span>orderRepository</span><span>)</span><br/> <span> </span><span>{</span><br/> <span>    </span><span>_orderRepository</span><span> </span><span>=</span><span> </span><span>orderRepository</span><span>;</span><br/> <span> </span><span>}</span><br/> <br/> <span> </span><strong><span>[</span><span>HttpGet</span><span>]</span></strong><br/><strong> <span> </span><span>public</span><span> </span><span>IActionResult</span><span> </span><span>Get</span><span>(</span><span>)</span></strong><br/><strong> <span> </span><span>{</span></strong><br/><strong> <span>   </span><span>return</span><span>  </span><span>Ok</span><span>(</span><span>_orderRepository</span><span>.</span><span>Get</span><span>(</span><span>)</span><span>)</span><span>;</span></strong><br/><strong> <span> </span><span>}</span></strong><br/> <br/> <strong> <span>[</span><span>HttpGet</span><span>(</span><span>"{id:guid}"</span><span>)</span><span>]</span></strong><br/><strong> <span> </span><span>public</span><span> </span><span>IActionResult</span><span> </span><span>GetById</span><span>(</span><span>Guid</span><span> </span><span>id</span><span>)</span></strong><br/><strong> <span> </span><span>{</span></strong><br/><strong> <span>   </span><span>return</span><span> </span><span>Ok</span><span>(</span><span>_orderRepository</span><span>.</span><span>Get</span><span>(</span><span>id</span><span>)</span><span>)</span><span>;</span></strong><br/><strong> <span> </span><span>}<br/></span></strong></span>... </pre>
<p>The implementation describes two actions, which means there are two different routes:</p>
<table border="1" style="border-collapse: collapse">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><strong>Http verb</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 277px"><strong>URI</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px"><strong>Action</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><kbd>GET</kbd></td>
<td><kbd>hostname/api/order</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px">
<pre>[HttpGet]<br/>IActionResult Get()</pre></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><kbd>GET</kbd></td>
<td><kbd>hostname/api/order/&lt;guid&gt;</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px">
<pre>[HttpGet("{id:guid}")]<br/>IActionResult GetById(Guid id)</pre></td>
</tr>
</tbody>
</table>
<p> </p>
<p>As we mentioned previously, <span>ASP.NET Core handles</span><span> incoming requests and maps them to actions using the routing middleware. Routes are defined both in the startup code and in the attributes. Each HTTP verb has its corresponding attribute: <kbd>HttpGet</kbd> corresponds to the</span> <kbd>GET</kbd> <span>method, <kbd>HttpPost</kbd> corresponds to the</span> <kbd>POST</kbd> <span>method, and so on.</span></p>
<p>In general, HTTP verb attributes have a signature that looks as follows:</p>
<pre>[HttpVerbAttribute(string template, [Name = string], [Order = string]]</pre>
<p>The <em>template</em> is a string<em> </em>parameter that represents the URL of a specific action. It may also accept some <em>routing constraints.</em> For example, <kbd>[HttpGet("{id:guid}")]</kbd> will receive a GUID identifier in the form of a string: </p>
<pre>https://localhost:5001/api/order/7719c8d3-79f4-4fbd-b99a-2ff54c5783d2</pre>
<p class="mce-root">We will look at routing constraints in more detail in <a href="88a48d0b-32c6-4adb-b907-ecd8365a3659.xhtml">Chapter 6</a>, <em>Routing System</em>.</p>
<div class="packt_infobox">It is essential to bear in mind that routing constraints are not meant to be a validation system. If we have an invalid route, our service will return <kbd>404 Not Found</kbd> and not <kbd>400 Bad Request</kbd>.</div>
<p>The <kbd>Name</kbd> parameter of the attribute indicates the route name that identifies that action method. In general, it doesn't have any impact on the routing system. Besides, it is used to refer to the routing rule during the generation of the URL, and it must be unique in the entire code base. By following the preceding specifications, it is easy to implement the other CRUD operations in our controller. The result looks as follows:</p>
<pre><span>using </span>System;<br/><span>using </span>System.Collections.Generic;<br/><span>using </span>Microsoft.AspNetCore.Mvc;<br/><span>using </span>SampleAPI.Models;<br/><span>using </span>SampleAPI.Repositories;<br/><br/><span>namespace </span>SampleAPI.Controllers<br/>{<br/>    [Route(<span>"api/order"</span>)]<br/>    [ApiController]<br/>    <span>public class </span>OrderController : ControllerBase<br/>    {<br/>        <span>private readonly </span>IOrderRepository _orderRepository;<br/><br/>        <span>public </span><span>OrderController</span>(<span>IOrderRepository </span>ordersRepository)<br/>        {<br/>            <span>_orderRepository </span>= ordersRepository;<br/>        }<br/><br/>        [<span>HttpGet</span>]<br/>        <span>public </span><span>IActionResult </span><span>Get</span>()<br/>        {<br/>            <span>return </span><span>Ok</span>(<span>_orderRepository</span>.<span>Get</span>());<br/>        }<br/><br/>        [<span>HttpGet</span>(<span>"{id:guid}"</span>)]<br/>        <span>public </span><span>IActionResult </span><span>GetById</span>(<span>Guid </span>id)<br/>        {<br/>            <span>return </span><span>Ok</span>(<span>_orderRepository</span>.<span>Get</span>(id));<br/>        }<br/><br/>        [HttpPost]<br/>        public IActionResult Post(Order request)<br/>        {<br/>            var order = new Order()<br/>            {<br/>                Id = Guid.NewGuid(),<br/>                ItemsIds = request.ItemsIds<br/>            };<br/><br/>            _orderRepository.Add(order);<br/>            return Ok();<br/>        }<br/><br/>        [HttpPut("{id:guid}")]<br/>        public IActionResult Put(Guid id, Order request)<br/>        {<br/>            var order = new Order<br/>            {<br/>                Id = id,<br/>                ItemsIds = request.ItemsIds<br/>            };<br/><br/>            _orderRepository.Update(id, order);<br/>            return Ok();<br/>        }<br/><br/>        [<span>HttpDelete</span>(<span>"{id:guid}"</span>)]<br/>        <span>public </span><span>IActionResult </span><span>Delete</span>(<span>Guid </span>id)<br/>        {<br/>            <span>_orderRepository</span>.<span>Delete</span>(id);<br/>            <span>return </span><span>Ok</span>();<br/>        }<br/>    }<br/>}</pre>
<p><span>Now that we've had a quick look at</span><span> </span><span>the implementation controller, let's have a closer look at the actions that are defined by it:</span></p>
<table border="1" style="border-collapse: collapse">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><strong>HTTP verb</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 277px"><strong>URI</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px"><strong>Action</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><kbd>GET</kbd></td>
<td><kbd>hostname/api/order</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px">
<pre>[HttpGet]<br/>IActionResult Get()</pre></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><kbd>GET</kbd></td>
<td><kbd>hostname/api/order/&lt;guid&gt;</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px">
<pre>[HttpGet("{id:guid}")]<br/>IActionResult GetById(Guid id)</pre></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><kbd>POST</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 277px"><kbd>hostname/api/order</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px">
<pre><span> [HttpPost]<br/> IActionResult Post(Order request)</span></pre></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><kbd>PUT</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 277px"><kbd>hostname/api/order/&lt;guid&gt;</kbd><em> </em></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px">
<pre><span>[HttpPut("{id:guid}")]<br/>IActionResult Put(Guid id, Order request)</span></pre></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 95px"><kbd>DELETE</kbd></td>
<td><kbd>hostname/api/order/&lt;guid&gt;</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 439px">
<pre><span>[HttpDelete("{id:guid}")]<br/>IActionResult Delete(Guid id)</span></pre></td>
</tr>
</tbody>
</table>
<p> </p>
<p>We should also notice that the controller does not implement any validation on the input data. Furthermore, the <kbd>[ApiController]</kbd> attribute, when applied on top of a class, provides the <em>out-of-the-box validation</em> and model binding of ASP.NET Core. Therefore, all the associated objects, such as the <kbd>Order request</kbd> parameter, must be passed from the body of the request in case they are required. </p>
<p>To run the ASP.NET Core api, we should run our application by executing <kbd>dotnet run</kbd> inside the project folder and perform an HTTP request using <kbd>curl</kbd> or whatever client, as follows:</p>
<pre><strong>curl -X GET  https:<span>//localhost:5001/api/order  -H 'Content-Type: application/json' -k</span></strong></pre>
<p>The preceding command executes a GET request on the <kbd>/api/order</kbd> URL, using the <kbd>Content-Type: application/json</kbd>. Since ASP.NET Core provides HTTPS out-of-box we can ignore the certificate validation using the <kbd>-k</kbd> flag. Later in the book, we will see how to install the certificate locally.</p>
<p>The output will look as follows:</p>
<pre>[]</pre>
<div class="packt_tip"><span>For Windows users, starting from </span>Windows 10, <span>build 17063</span> (<a href="https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/">https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/</a>), the OS ships with a copy of <kbd>curl</kbd> already set up and ready to use. However, it is possible to download and install <kbd>curl</kbd> from <a href="https://curl.haxx.se/">https://curl.haxx.se/</a>. Another option is to install <kbd>curl</kbd> using the Chocolatey package manager by executing <kbd>choco install curl</kbd> on your command line.</div>
<p>Futhermore, if we try to perform a <kbd>curl</kbd> command with an empty payload as follow:</p>
<pre class="p1"><strong><span class="s1">curl -X POST <span class="Apple-converted-space">  </span>https://localhost:5001/api/order -H 'Content-Type: application/json' -d '' </span><span class="s1">-k</span></strong></pre>
<p>The output will look as follows:</p>
<pre>{<br/>  <span>"type"</span>: <span>"https://tools.ietf.org/html/rfc7231#section-6.5.1"</span>,<br/>  <span>"title"</span>: <span>"One or more validation errors occurred."</span>,<br/>  <span>"status"</span>: <span>400</span>,<br/>  <span>"traceId"</span>: <span>"|7c58576e-47baf080f74cf2ab."</span>,<br/>  <span>"errors"</span>: {<br/>    <span>""</span>: [<br/>      <span>"A non-empty request body is required."<br/></span><span>    </span>]<br/>  }<br/>}</pre>
<p><span>In this case, we have passed an empty body payload using the <kbd>-d</kbd> empty flag.</span><span> Therefore</span><span>, the out-of-the-box model validation returns the error message in the request's response, and it returns an HTTP</span><span> </span><kbd>400 Bad request</kbd><span> message.</span></p>
<div class="packt_infobox">In real-world applications, this kind of validation is not enough. It is usually replaced by some custom validations, such as <em>data annotation</em> or <em>fluent validation.</em> We will look at these techniques in more detail later in this chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Responding to requests</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we have a controller that is able to handle our requests, we should focus on the response part. Looking at the <kbd>OrderController</kbd> from the response point of view, we may notice that it is not compliant with REST specifications. None of the action methods considers any failure states. What should happen if our data source is down? What should happen if the requested order is not present in our repository?</p>
<p>Let's start by checking what happens when we ask for an order that doesn't exist. To proceed with this check, all we need to do is make a <kbd>curl</kbd> request with a GUID that doesn't exist:</p>
<pre><strong>curl -X GET https://localhost:5001/api/order/a54f58bc-216d-4a40-8040-bafaec68f2de -H 'Content-Type: application/json' -i -k</strong></pre>
<p>The preceding command-line instruction will produce the following output:</p>
<pre class="p1"><span class="s1">HTTP/1.1 204 No Content<br/></span><span class="s1">Date: Fri, 17 Aug 2018 14:37:58 GMT<br/></span><span class="s1">Server: Kestrel<br/></span><span class="s1">Content-Length: 0<br/></span></pre>
<p>As we can see from the response, ASP.NET Core automatically handles the empty result, and it returns the HTTP status <kbd>204 No Content</kbd>. It is important to note that all these behaviors came out of the box. Besides, it is also possible to override the default components and add our own custom validation implementation and response handling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CreateAt response</h1>
                </header>
            
            <article>
                
<p>The <kbd>Post</kbd> action method is responsible for creating resources. Another principal responsibility of the <kbd>Post</kbd> action method is to tell the client where the resource<span> </span>is created<span> </span>and how to access it. This responsibility<span> </span>is usually implemented<span> </span>within the<span> </span>action method. ASP.NET Core provides two methods that can give this information to the client, which are <kbd>CreatedAtAction</kbd> and <kbd>CreatedAtRoute</kbd>. The following example shows how to use the <kbd>CreatedAtAction</kbd> method in our <kbd>Post</kbd> action:</p>
<pre><span><span>...<br/></span></span>        [HttpPost]<br/>        public IActionResult Post(Order request)<br/>        {<br/>            var order = new Order()<br/>            {<br/>                Id = Guid.NewGuid(),<br/>                ItemsIds = request.ItemsIds<br/>            };<br/><br/>            _orderRepository.Add(order);<br/>            <strong>return CreatedAtAction(nameof(GetById), new { id = order.Id }, null);</strong><br/>        }<br/>...</pre>
<p>After that, the response to the below  <kbd>POST</kbd> request will appear as follows:</p>
<pre><strong>curl -X POST https:<span>//localhost:5001/api/order/ -H 'Content-Type: application/json' -d '{"itemsIds": ["1","4"]}' -i -k</span></strong><span><br/><br/><br/></span><span class="s1">HTTP/1.1 <strong>201 Created</strong><br/></span><span class="s1">Date: Mon, 20 Aug 2018 11:19:49 GMT<br/></span><span class="s1">Server: Kestrel<br/></span><span class="s1">Content-Length: 0<br/></span><strong><span class="s1">Location: https://localhost:5001/api/orders/372459c7-6e16-4276-b286-f341d7009c43</span></strong></pre>
<p>As you can see, the response contains the <kbd>201 Created</kbd> header. It also provides the <kbd>Location</kbd> of the resource. This kind of information is useful for the client so that we can get more information about the<span> </span>resource.</p>
<p>The <kbd>CreateAtAction</kbd> method accepts three parameters:</p>
<ul>
<li><kbd>actionName</kbd> represents the name of the action that's used for generating the URL.</li>
<li><kbd>routeValues</kbd> is an object that contains all the<span> </span>parameters<span> </span>of the<span> </span>action.</li>
<li><kbd>value</kbd> is an object that represents the content of the response.</li>
</ul>
<p class="mce-root">An alternative to <kbd>CreateAtAction</kbd> is <kbd>CreateAtRoute</kbd>, which takes the <kbd>routeName</kbd> and generates the same result as <kbd>CreateAtAction</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating resources</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Put</kbd> action handles how resources are updated. We should bear in mind that the <kbd>PUT</kbd> verb is intended as a total replacement of the specific resource. Therefore, when we call an API using a <kbd>PUT</kbd> verb, all the resource fields will be replaced with the <em>body payload.</em> As we will see later in this chapter, <span>for a more precise update</span> for some of the specific fields of our entity, it is better to use the <kbd>PATCH</kbd> verb.</p>
<p>Another critical thing to keep in mind when we implement a <kbd>Put</kbd> action is that we need to handle Ids that don't exist. APIs usually manage non-existent IDs in <kbd>Put</kbd> actions using two different approaches:</p>
<ul>
<li>When the client makes an update request on a non-existent ID, the API creates a new record with that resource.</li>
<li>When the client makes an update request on a <span>non-existent ID</span>, the API informs the client that the resource doesn't exist with a <kbd>404 Not Found</kbd> error.</li>
</ul>
<div class="packt_infobox">I'm not a massive supporter of <kbd>CreateOrUpdate</kbd> methods. I prefer to keep the <kbd>Put</kbd> action compliant with the <em>single</em> <em>responsibility</em> <em>principle.</em> Therefore, separate the <em>create</em> and <em>update</em> operations into two different action methods.</div>
<p>Let's see how we can implement our <kbd>Put</kbd> action:</p>
<pre>...<br/>        [HttpPut("{id:guid}")]<br/>        public IActionResult Put(Guid id, Order request)<br/>        {<br/>           <strong> var order = _orderRepository.Get(id);</strong><br/>            <br/>           <strong> if (order == null) </strong><br/><strong>                return NotFound(new { Message = $"Item with id {id} not exist." });</strong> <br/><br/>            order.ItemsIds = request.ItemsIds;<br/><br/>            _orderRepository.Update(id, order);<br/>            return Ok();<br/>        }<br/>...</pre>
<p>The first step is to check whether the order with the corresponding <kbd>id</kbd> exists. If it doesn't exist, the application returns a <kbd>404 Not Found</kbd> error. Otherwise, it performs the update operation and returns <kbd>200 Ok</kbd>.</p>
<div class="packt_infobox">Note that the <kbd>NotFound</kbd> result also contains a message. In real-world applications, this message is usually associated with a piece of code, that is, a custom error, and it is serialized into JSON or XML format. </div>
<p>It is also significant to consider what should happen when the request contains <kbd>null</kbd> in <kbd>itemsIds</kbd>. It is essential to understand the difference between a <kbd>null</kbd> request object and an empty request object. In the first case, the client may accidentally call our APIs without passing any value. In the second case, the client explicitly requests our resource to be replaced with an empty value. Let's modify our code to avoid <kbd>null</kbd> request values by adding the following guard as the first statement of our <kbd>Put</kbd> method:</p>
<pre>...<br/>  [HttpPut("{id:guid}")]<br/>  public IActionResult Put(Guid id, Order request)<br/>        {<br/>            <strong>if (request.ItemsIds == null) </strong><br/><strong>                return BadRequest();</strong><br/>...</pre>
<p>The preceding <kbd>if</kbd> statement returns a <kbd>BadRequest</kbd> message if the <kbd>ItemsIds</kbd> field is <kbd>null</kbd>. Therefore, the client that sent the request will now the source of the issue. In the next section, we will discover another widespread update technique implemented in RESTful web services.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Partial updating</h1>
                </header>
            
            <article>
                
<p><kbd>Put</kbd> actions are used to replace a resource with another one. Therefore, the client must add the whole entity in the <em>body payload</em> of the request. If our<span> </span>entity<span> </span>is a complex object, keeping the entire<span> </span>entity<span> </span>in memory may cause performance issues. It is possible to avoid these problems by implementing a <kbd>Patch</kbd> action instead.<span> </span>The <kbd>Patch</kbd> action usually modifies an existing resource without replacing it, therefore you are able to specify only one the field you want to update. Let's see how we can perform this kind of<span> </span>action<span> </span>in ASP.NET Core.</p>
<p>First of all, let's add a new field to our <kbd>Order.cs</kbd> class:</p>
<pre><span>using </span><span>System</span>;<br/><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Models<br/></span><span> </span><span>{</span><br/>  <span>public class </span><span>Order<br/></span><span>     </span>{<br/>         <span>public </span><span>Guid </span><span>Id </span>{ <span>get</span>; <span>set</span>; }<br/>         <span>public </span><span>IEnumerable</span>&lt;<span>string</span>&gt; <span>ItemsIds </span>{ <span>get</span>; <span>set</span>; }<br/>         <strong><span>public string </span><span>Currency </span>{ <span>get</span>; <span>set</span>; }</strong><br/>     }<br/> <span>}</span></pre>
<p>Now, the <kbd>Order</kbd> class contains an additional field that represents the currency of our orders. Let's create a <kbd>Patch</kbd> action in our <kbd>OrderController</kbd>. The code we are going to implement uses two NuGet packages that provide the support for the PATCH method and all the types that help us to perform the operations related to that type of HTTP verb. We can add the package to our project by running the following instructions in the <kbd>SampleAPI</kbd> project folder:</p>
<pre><strong>dotnet add package <span>Microsoft.AspNetCore.JsonPatch<br/>dotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson<br/></span></strong></pre>
<p>The first <span>NuGet package provides the <kbd>JsonPatchDocument</kbd> class type, the second package enables the <kbd>NewtonsoftJson</kbd> serializer needed by the PATCH operation support</span><span>. In addition, we should also enable the NewtonsoftJson serializer into the application by adding the following extension method in the <kbd>Startup</kbd> class:</span></p>
<pre><span>public class </span><span>Startup<br/></span>{<br/>    ...<br/><span><br/></span><span>    </span><span>public void </span>ConfigureServices(<span>IServiceCollection </span>services)<br/>    <span>{</span><br/>        services<br/>            .AddSingleton&lt;<span>IOrderRepository</span>, <span>MemoryOrderRepository</span>&gt;()<br/>            .AddControllers()<br/>            <strong>.AddNewtonsoftJson();</strong><br/>    <span>}</span></pre>
<p><span>  Furthermore, it is possible to implement the <kbd>Patch</kbd> action method in the following way:</span></p>
<div>
<pre><strong>[<span>HttpPatch</span>(<span>"{id:guid}"</span>)]</strong> <br/><span>public </span><span>IActionResult </span><span>Patch</span>(<span>Guid </span>id, <strong><span>JsonPatchDocument</span>&lt;<span>Order</span>&gt; requestOp</strong>)<br/><span>{</span><br/>    <span>var </span>order = <span>_orderRepository</span>.<span>Get</span>(id);<br/>    <span>if </span>(order == <span>null</span>)<br/>    {<br/>        <span>return </span><span>NotFound</span>(<span>new </span>{ <span>Message </span>= <span>$</span><span>"Item with id {</span>id<span>} not exist." </span>});<br/>    }<br/><br/>    <strong>requestOp.<span>ApplyTo</span>(order);</strong><br/>    <span>_orderRepository</span>.<span>Update</span>(id, order);<br/><br/>    <span>return </span><span>Ok</span>();<br/><span>}</span></pre></div>
<p>The aforementioned code has three key points:</p>
<ul>
<li>The action method reacts to the <kbd>HttpPatch</kbd> verb requests. Just like the <kbd>Put</kbd> action, it accepts a <kbd>Guid</kbd> as the input parameter, which identifies the target resource.</li>
<li>The action method also accepts a <kbd>JsonPatchDocument</kbd> <span>as the payload of the body</span>. The <kbd>JsonPatchDocument</kbd> class is a generic class that is part of the ASP.NET Core Framework. More specifically, our action uses the <kbd>JsonPatchDocument&lt;Order&gt;</kbd> type to implement operations on our <kbd>Order</kbd> class.</li>
<li>The action method applies the <kbd>JsonPatchDocument</kbd> class using the <kbd>ApplyTo</kbd> method, which merges the changes in the request to our target resource. Finally, it updates the repository.</li>
</ul>
<p>The <kbd>JsonPatchDocument</kbd> class accepts a specific request schema. For example, the following <kbd>curl</kbd> operation performs a partial update through the <kbd>PATCH</kbd> verb:</p>
<pre><strong>curl -X PATCH \</strong><br/><strong>  https://localhost:5001/api/order/5749c944-239c-4c0c-8549-2232cf585473 \</strong><br/><strong>  -H 'Content-Type: application/json' \</strong><br/><strong>  -d '[</strong><br/><strong>  {</strong><br/><strong>    "op": "replace", "path": "/itemsIds", "value" : [1,2]</strong><br/><strong>  }</strong><br/><strong>]' -k</strong></pre>
<p>In this case, the body payload is a JSON array of objects: every object is composed of an <kbd>op</kbd> field, a <kbd>path</kbd>, and a <kbd>value</kbd>.</p>
<p>The <kbd>op</kbd> field describes the operation to perform on our target, <kbd>path</kbd> refers to the name of our field, and <kbd>value</kbd> is the replacement for our target. In this case, the request will replace the <kbd>itemsIds</kbd> field with the value <kbd>[1,2]</kbd>. Furthermore, the <kbd>op</kbd> field accepts a bunch of operations on data, including <kbd>add</kbd> and <kbd>remove</kbd>. As we saw previously, the syntax is almost the same as it was in the previous example:</p>
<pre>[{<br/>    "op": "add", "path": "/itemsIds", "value" : [3]<br/>},<br/>{<br/>    "op": "remove", "path": "/itemsIds"<br/>}]<strong> </strong></pre>
<div class="packt_infobox"><span><kbd>JsonPatchDocument</kbd> is compliant with the specification of the </span><strong>Internet Engineering Task Force</strong> (<span><strong>IETF</strong>), an organization that promotes internet standards. You can find</span><span> out more information about the </span><kbd>Patch</kbd> <span>document syntax in the declaration of the standard at the following link: </span><a href="https://tools.ietf.org/html/rfc5789">https://tools.ietf.org/html/rfc5789</a><span>. All the other specifications about the HTTP method that we've discussed in this chapter can also be found here. <br/></span>You should pay attention when using the <kbd>JsonPatchDocument</kbd> object. The client may request to update a read-only field or a non-existent field. Furthermore, the <kbd>JsonPatchDocument</kbd> type requires a <strong>validation step</strong>. This problem is usually solved by creating a custom <strong>data transfer object</strong> (<strong>DTO</strong>) model for this kind of request.</div>
<p>Let's move on to the next subsection, which describes the deleting process for the resources and how to implement the resulting action method in the controller class.<br/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting resources</h1>
                </header>
            
            <article>
                
<p>The <kbd>Delete</kbd> action method is marked with the <kbd>HttpDelete</kbd> attribute. It usually accepts the identifier of the resource to remove.</p>
<div class="packt_infobox">In real-world applications, <kbd>Delete</kbd> action methods do not perform physical delete operation on the database. They actually carry out update operations. Real-world applications and web services typically perform soft deletes instead of physical deletes because it is essential to keep track of historical data and information that's stored by our services. If we think about an e-commerce application, for example, it would be crucial to keep track of orders that have been dispatched by our system. <em>Soft deletes</em> are usually implemented using an <kbd>isDeleted</kbd> flag or an object that represents the status of our resource. All the other routes that are implemented in our APIs should implement logic to filter out all the resources in a deleted state. For example, a <kbd>Get</kbd> route should exclude all the deleted resources before presenting them to the client.</div>
<p>In our case, we are going to implement a real delete operation on our <span><kbd>IOrderRepository</kbd>. The <kbd>Delete</kbd> action methods usually return a <kbd>204 No Content</kbd> error to confirm the deletion or a <kbd>404 Not Found</kbd> error if the client passes a non-existent identifier:</span></p>
<pre><strong>[<span>HttpDelete</span>(<span>"{id:guid}"</span>)]</strong><br/><span>public </span><span>IActionResult </span><span>Delete</span>(<span>Guid </span>id)<br/><span>{</span><br/>    <span>var </span>order = <span>_orderRepository</span>.<span>Get</span>(id);<br/><br/>    <span>if </span>(order == <span>null</span>)<br/>    {<br/>       <strong> <span>return </span><span>NotFound</span>(<span>new </span>{ <span>Message </span>= <span>$</span><span>"Item with id {</span>id<span>} not exist." </span>});</strong><br/>    }<br/><br/>    <span>_orderRepository</span>.<span>Delete</span>(id);<br/>    <strong><span>return </span><span>NoContent</span>();</strong><br/><span>}</span></pre>
<p>The implementation fetches the resource with the corresponding <kbd>id</kbd> from the <kbd>IOrderRepository</kbd> interface. It proceeds by checking whether the resource is <kbd>null</kbd>, and in this case, it will produce a not found error. If the order entity is present in the data source, it continues with the deletion process, and it returns a no content result. Now, let's proceed by having a look at the asynchronous process using a web service.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous processing and acceptance status</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Sometimes, the operations on our resources are not applied immediately. Consider an order on an e-commerce website: it takes time to be dispatched and sent to our storage system. Therefore, data placed into a queue or something similar and handled as soon as possible.</span></p>
<p class="mce-root">These kinds<span> </span>of<span> </span>asynchronous<span> </span>processing structures may also be present in a web<span> </span>service. We also need to represent them and<span> </span>communicate<span> </span>with the client when<span> </span>these kinds<span> </span>of processes start.</p>
<p>In general,<span> </span>these kinds<span> </span>of processes have the following workflow:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fab174c8-cb4d-40a5-9b40-4a7d3680c1fa.png" style=""/></div>
<p>The previous schema shows how the client interacts with an asynchronous process:</p>
<ol>
<li>The client sends a <kbd>POST</kbd> request to our services. The <kbd>POST</kbd> request triggers an asynchronous operation, which updates and adds the order to our storage.</li>
<li>The action method receives the request from the client and, if the<span> </span>request<span> structure is as expected</span>, triggers the asynchronous process and returns <kbd>202 Accepted</kbd> to the client. Otherwise, it returns <kbd>403 Bad Request</kbd>. The <kbd>202 Accept</kbd> code indicates that the asynchronous operation<span> </span>is running, but that it<span> hasn't</span> finished yet.</li>
<li>The client doesn't know precisely when the asynchronous process will end, but it is up to it to recall our service once the information has been updated. The <kbd>202 Accepted</kbd> message it<span> </span>is usually combined<span> </span>with a JSON message that contains some information, such as the estimated time, or the code of the process.</li>
</ol>
<div class="packt_infobox">Note that all the example URIs present in this book<span> </span>doesn't<span> </span>contain<span> </span><em>verbs</em>. For example, the previous implementation describes<span> </span>a process<span> </span>for generating new order. As you can see, the URI is<span> </span><kbd>&lt;hostname&gt;/api/orderrequest</kbd><em>,</em> and<span> </span>the only element that contains a verb is the HTTP method, which is<span> </span><kbd>POST</kbd><em>. </em>We shouldn't use<span> </span><em>verbs </em>in URIs because they are used to identify resources and must, therefore, be<span> </span>nouns.</div>
<p>The next step in our web service stack journey is to see how we can decouple the requests and the response object from the core entities that are used by our application. This approach becomes really useful when a web service's complexity increases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data transfer objects</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous section, we looked at how to manage HTTP requests and responses using controllers. In this section, we will look at how to manage complex objects in our requests and responses. This section is more focused on the <em>M</em> part of the MVC pattern. First of all, let's distinguish between three different types of model that are usually present in web services:</p>
<ul>
<li>The <strong>Domain model</strong><em> </em>describes the entities and the resources in our web services. It often reflects the schema of our data source, and it is very close to the lower level and the business logic of the application.</li>
<li>The <strong>Request model</strong><em> </em>is the representation of the model of the request. Each action method in our controller usually has its own <strong>Request model</strong>. As we will see later in this chapter, this is also the model that's associated with the validation of the request.</li>
<li>The<em> </em><strong>Response model</strong><em> </em>is the view model, or the presentation model, of the web service. It represents the response of the request, and there is usually one <strong>Response model</strong> per action method.</li>
</ul>
<p>The following workflow schema shows how the models in our application are laid out:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5ab39100-1893-475e-bb5e-170a75b4296d.png" style=""/></div>
<p>As you can see, the<span> </span><strong>Request model</strong><span> </span>is the front part of our service; it represents<span> </span>the request. The<span> </span><strong>Domain model</strong><span> </span>is used to describe our stored data. Finally<span>, </span>the<span> </span><em>response model</em><span> </span>presents<span> </span>the data to the client. The request and response model are also defined as<span> </span><strong>data transfer objects</strong> (<strong>DTOs</strong>)<em>.</em> These are not <span>model classes at all; they transport information between the client and the server.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing request models</h1>
                </header>
            
            <article>
                
<p><span>Now, let's look at the implementation of some</span><span> </span>DTOs <span>in practice. The <kbd>Order</kbd> entity describes some actions that accept</span> <kbd>List&lt;string&gt;</kbd><span> </span><span>as input.</span><span> Let's suppose that the implementation is getting more complex and our service needs to store additional</span><span> </span><span>information</span><span> </span><span>about our orders:</span></p>
<pre><span>using </span><span>System</span>;<br/><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Models<br/></span><span> </span><span>{</span><br/>  <span>public class </span><span>Order<br/></span><span>     </span>{<br/>         <span>public </span><span>Guid </span><span>Id </span>{ <span>get</span>; <span>set</span>; }<br/>         <span>public </span><span>IEnumerable</span>&lt;<span>string</span>&gt; <span>ItemsIds </span>{ <span>get</span>; <span>set</span>; }<br/>         <span>public string </span><span>Currency </span>{ <span>get</span>; <span>set</span>; }<br/>     }<br/> <span>}</span></pre>
<p>The <em>domain model</em> is a critical part of our application. It is essential to keep it separated from the <em>request/response model</em>. Therefore, we should avoid having the <em>domain model</em> tightly coupled with the <em>request</em> and the <em>response</em> models. <span>Let's start by implementing the </span><kbd>OrderRequest</kbd><span> class, which will be a representation of the </span><em>create request model</em><span>. I</span>t will be used by<span> the </span><kbd>Post</kbd><span> action method to create a new entity:</span></p>
<pre><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Requests<br/></span>{<br/>    <span>public class </span><span>OrderRequest<br/></span><span>    </span><span>{</span><br/>        <span>public </span><span>IEnumerable</span>&lt;<span>string</span>&gt; <span>ItemsIds </span>{ <span>get</span>; <span>set</span>; }<br/> <br/>        <span>public string </span><span>Currency </span>{ <span>get</span>; <span>set</span>; }<br/>    <span>}</span><br/>}</pre>
<p>The <kbd>OrderRequest</kbd> class contains the same fields as the <kbd>Order</kbd> <em>domain model</em>, apart from the <kbd>Id</kbd> field. This is because the client of the API should not insert the <kbd>Id</kbd> information. The request model makes our filesystem in a separate folder. In this case, as you can see from the namespace, <kbd>OrderRequest</kbd> is stored in the <kbd>Requests</kbd> folder. Our <kbd>OrderController</kbd> can use <kbd>OrderRequest</kbd> as follows:</p>
<pre><span><span>     [</span><span>Route</span><span>(</span><span>"api/order"</span><span>)</span><span>]</span><br/><span>     [</span><span>ApiController</span><span>]</span><br/> <span>    </span><span>public</span><span> </span><span>class</span><span> </span><span>OrderController</span><span> </span><span>:</span><span> </span><span>ControllerBase</span><br/> <span>    </span><span>{</span><br/>         <br/>         ...<br/><br/><span>        [HttpPost]<br/>        public IActionResult Post(<strong>OrderRequest request</strong>)<br/>        {<br/>            var order = Map(request);<br/>            <br/>            _orderRepository.Add(order);<br/> <br/>            return CreatedAtAction(nameof(GetById), new { id = order.Id }, <br/>            null);<br/>        }<br/> <br/>        ...<br/></span><br/><span><strong>        private Order Map(OrderRequest request)</strong><br/><strong>        {</strong><br/><br/><strong>            return new Order</strong><br/><strong>            {</strong><br/><strong>                Id = Guid.NewGuid(),</strong><br/><strong>                ItemsIds = request.ItemsIds,</strong><br/><strong>                Currency = request.Currency</strong><br/><strong>            };</strong><br/><strong>        }</strong><br/>         ...</span></span></pre>
<p>The <kbd>Post</kbd> action method accepts a parameter of the <kbd>OrderRequest</kbd> type, which is the representation of the order request that we want to create. To link incoming data with the domain model, we should create a <kbd>Map</kbd> method that initializes a new domain model that's populated with the request model. Furthermore, we should also create a new instance of the <kbd>Order</kbd> object with the requested data and combine it with <kbd>IOrderRepository</kbd>. The same concept can be applied to the <kbd>Put</kbd> action method of our controller:</p>
<pre> <span>        ...<br/><br/> <span>        </span><span>[</span><span>HttpPut</span><span>(</span><span>"{id:guid}"</span><span>)</span><span>]</span><br/> <span>        </span><span>public</span><span> </span><span>IActionResult</span><span> </span><span>Put</span><span>(</span><span>Guid</span><span> </span><span>id</span><span>,</span><span> </span><span><strong>OrderRequest</strong></span><strong><span> </span><span>request</span></strong><span>)</span><br/> <span>        </span><span>{</span><br/> <span>            </span><span>var</span><span> </span><span>order</span><span> </span><span>=</span><span> </span><span>_orderRepository</span><span>.</span><span>Get</span><span>(</span><span>id</span><span>)</span><span>;</span><br/> <br/> <span>            </span><span>if</span><span> </span><span>(</span><span>order</span><span> </span><span>==</span><span> </span><span>null</span><span>)</span><br/> <span>            </span><span>{</span><br/> <span>                </span><span>return</span><span> </span><span>NotFound</span><span>(</span><span>new</span><span> </span><span>{</span><span> </span><span>Message</span><span> </span><span>=</span><span> </span><span>$"</span><span>Item with id </span><span>{</span><span>id</span><span>}</span><span> not exist.</span><span>"</span><span> </span><span>}</span><span>)</span><span>;</span><br/> <span>            </span><span>}</span><br/> <br/> <span>            </span><span>order</span><span> </span><span>=</span><span> </span><span>Map</span><span>(</span><span>request</span><span>,</span><span> </span><span>order</span><span>)</span><span>;</span><br/> <br/> <span>            </span><span>_orderRepository</span><span>.</span><span>Update</span><span>(</span><span>id</span><span>,</span><span> </span><span>order</span><span>)</span><span>;</span><br/> <br/> <span>            </span><span>return</span><span> </span><span>Ok</span><span>(</span><span>)</span><span>;</span><br/> <span>        </span><span>}<br/>           <br/> <strong>        <span>private Order Map(OrderRequest request, Order order)<br/>         {<br/>             order.ItemsIds = request.ItemsIds;<br/>             order.Currency = request.Currency;<br/> <br/>             return order;<br/>         }</span> </strong><br/>         ...</span></span></pre>
<p>In this case, we create a new <kbd>Map</kbd> method, which takes two parameters as input: the <kbd>OrderRequest</kbd> and the <kbd>Order</kbd>, and we can proceed by assigning each property of the request object to the order. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing response models</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, another critical part of our APIs is the response model. The response model classes act as filters between the <em>domain model</em> and the <em>client.</em> For example, let's think about a particular field in our domain model that, for whatever reason, must not be part of our response. Response models help us deal with cases such as these.</p>
<p>Let's suppose that we need to implement a <em>soft-delete</em> in our APIs. As we mentioned earlier, a <em>soft-delete </em>is a way to mark a record for the deletion or to temporarily prevent it from being selected. To perform a soft-delete on <kbd>MemoryOrderRepository</kbd>, we should add an <kbd>IsInactive</kbd> flag, which marks the target record as deleted:</p>
<pre><span><span>public</span><span> </span><span>class</span><span> </span><span>Order</span><br/><span>{</span><br/> <span>    </span><span>public</span><span> </span><span>Guid</span><span> </span><span>Id</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span><br/> <br/> <span>    </span><span>public</span><span> </span><span>IEnumerable</span><span>&lt;</span><span>string</span><span>&gt;</span><span> </span><span>ItemsIds</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span><br/> <br/> <span>    </span><span>public</span><span> </span><span>string</span><span> </span><span>Currency</span><span>;</span><br/> <br/> <span>    </span><strong><span>p</span><span>ublic</span><span> </span><span>bool</span><span> </span><span>IsInactive</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></strong><br/> <span>}</span><br/></span></pre>
<p><span>The <kbd>IsInactive</kbd> flag indicates whether</span> <kbd>Order</kbd><span> is inactive or not. To complete the </span><em>soft-delete</em><span> implementation, we should change the </span><kbd>MemoryOrderRepository</kbd><span>. It should now cancel orders using the </span><kbd>IsInactive</kbd><span> flag.</span></p>
<p><span>Furthermore, the </span><kbd>Get</kbd><span> method inside the repository should filter all the records by excluding inactive orders:</span></p>
<pre><span>...<br/><span>public</span><span> </span><span>class</span><span> </span><span>MemoryOrderRepository</span><span> </span><span>:</span><span> </span><span>IOrderRepository</span><br/><span> {</span><br/> <span>     </span><br/> <span>       public IEnumerable&lt;Order&gt; Get() =&gt; _orders<strong>.Where(o =&gt; !o.IsInactive)</strong>.ToList();<br/>        <br/>        public Order Get(Guid orderId)<br/>        {<br/>            return _orders<br/>               <strong> .Where(o =&gt; !o.IsInactive)</strong><br/>                .FirstOrDefault(o =&gt; o.Id == orderId);<br/>        }<br/>        <br/>        public Order Delete(Guid orderId)<br/>        {<br/>            var target = _orders.FirstOrDefault(o =&gt; o.Id == orderId);<br/> <br/>          <strong>  target.IsInactive = true;</strong><br/>            Update(orderId, target);<br/>            <br/>            return target;<br/>        }</span><br/>...<br/><br/></span></pre>
<p>These changes eliminate inactive orders from the responses of our APIs. Since the <kbd>IsInactive</kbd> flag is implicit in the response of our APIs, we don't need to serialize the <kbd>IsInactive</kbd> flag in the response JSON. Consequently, we can decouple the response of the <kbd>Get</kbd> action method from our domain model by adding a new response class called <kbd>OrderResponse</kbd>. It can be defined in the following way:</p>
<pre><span>using </span><span>System</span>;<br/><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><br/><span>namespace </span><span>SampleAPI<br/></span><span>{</span><br/>    <span>public class </span><span>OrderResponse<br/></span><span>    </span>{<br/>        <span>public </span><span>Guid </span><span>Id </span>{ <span>get</span>; <span>set</span>; }<br/>        <span>public </span><span>IEnumerable</span>&lt;<span>string</span>&gt; <span>ItemsIds </span>{ <span>get</span>; <span>set</span>; }<br/>        <span>public string </span><span>Currency </span>{ <span>get</span>; <span>set</span>; }<br/>    }<br/><span>}</span></pre>
<p>As you can see, the <kbd>OrderResponse</kbd> class model exposes all the fields except for the <kbd>IsInactive</kbd> flag. At this point, we can proceed by editing the <kbd>OrderController</kbd> class so that it maps the <kbd>Order</kbd> entity with the <kbd>OrderResponse</kbd> model in the following way:</p>
<pre><span> ...<br/><br/> <span>public</span><span> </span><span>class</span><span> </span><span>OrderController</span><span> </span><span>:</span><span> </span><span>ControllerBase</span><br/> <span>{<br/></span><br/> <span>    ...<br/></span><br/> <span>    </span><span>[</span><span>HttpGet</span><span>]</span><br/> <span>    </span><span>public</span><span> </span><span>IActionResult</span><span> </span><span>Get</span><span>(</span><span>)</span><br/> <span>    </span><span>{</span><br/> <br/> <span>        </span><span>return</span><span> </span><span>Ok</span><span>(</span><strong><span>Map</span><span>(</span><span>_orderRepository</span><span>.</span><span>Get</span><span>(</span><span>)</span><span>)</span></strong><span>)</span><span>;</span><br/> <span>    </span><span>}</span><br/> <br/> <span>    </span><span>[</span><span>HttpGet</span><span>(</span><span>"{id:guid}"</span><span>)</span><span>]</span><br/> <span>    </span><span>public</span><span> </span><span>IActionResult</span><span> </span><span>GetById</span><span>(</span><span>Guid</span><span> </span><span>id</span><span>)</span><br/> <span>    </span><span>{</span><br/> <span>        </span><span>return</span><span> </span><span>Ok</span><span>(<strong>Map(</strong></span><strong><span>_orderRepository</span><span>.</span><span>Get</span><span>(</span><span>id</span><span>))</span></strong><span>)</span><span>;</span><br/> <span>    </span><span>}<br/><br/>    ...</span><br/> <br/> <strong><span>    </span><span>private</span><span> </span><span>IEnumerable</span><span>&lt;</span><span>OrderResponse</span><span>&gt;</span><span> </span><span>Map</span><span>(</span><span>IEnumerbale</span><span>&lt;</span><span>Order</span><span>&gt;</span><span> </span><span>orders</span><span>)</span></strong><br/><strong> <span>    </span><span>{</span></strong><br/><strong> <span>        </span><span>return</span><span> </span><span>orders</span><span>.</span><span>Select</span><span>(</span><span>Map</span><span>)</span><span>.</span><span>ToList</span><span>(</span><span>)</span><span>;</span></strong><br/><strong> <span>    </span><span>}</span></strong><br/> <br/><strong> <span>    </span><span>private</span><span> </span><span>OrderResponse</span><span> </span><span>Map</span><span>(</span><span>Order</span><span> </span><span>order</span><span>)</span></strong><br/><strong> <span>    </span><span>{</span></strong><br/><strong> <span>        </span><span>return</span><span> </span><span>new</span><span> </span><span>OrderResponse</span></strong><br/><strong> <span>        </span><span>{</span></strong><br/><strong> <span>            </span><span>Id</span><span> </span><span>=</span><span> </span><span>order</span><span>.</span><span>Id</span><span>,</span></strong><br/><strong> <span>            </span><span>ItemsIds</span><span> </span><span>=</span><span> </span><span>order</span><span>.</span><span>ItemsIds</span><span>,</span></strong><br/><strong> <span>            </span><span>Currency</span><span> </span><span>=</span><span> </span><span>order</span><span>.</span><span>Currency</span></strong><br/><strong> <span>        </span><span>}</span><span>;</span></strong><br/><strong> <span>    </span><span>}</span></strong><br/> <span>}</span></span> </pre>
<p>This approach allows us to decouple the domain model from the response of our API. The <kbd>Map</kbd> method is the point at which we can decide which fields we should show.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing validation of requests</h1>
                </header>
            
            <article>
                
<p>We can now create dedicated types to represent our requests, but we should also consider adding validation. Validation is important if we wish to prevent messy data and possible exceptions in our web service. ASP.NET Core provides an out of the box way for us to implement validation in our controllers and services: <kbd>System.ComponentModel.DataAnnotations</kbd>. The namespace provides a set of attributes that can be used to describe the validation of model fields. For example, consider the following code snippet:</p>
<pre><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Requests<br/></span><span>{</span><br/>    <span>public class </span><span>OrderRequest<br/></span><span>    </span>{<br/>        <span>public </span><span>IEnumerable</span>&lt;<span>string</span>&gt; <span>ItemsIds </span>{ <span>get</span>; <span>set</span>; }<br/>        <span>public string </span><span>Currency </span>{ <span>get</span>; <span>set</span>; }<br/>    }<br/><span>}</span></pre>
<p>In this case, the <kbd>[Required]</kbd> attribute specifies that both the <kbd>ItemsIds</kbd> and <kbd>Currency</kbd> attributes should not be <kbd>null</kbd> or empty; otherwise, the APIs will return the following validation message:</p>
<pre>{<br/>    "ItemsIds": [<br/>        "The ItemsIds field is required."<br/>    ]<br/>}</pre>
<p class="mce-root"><span>Simply r</span>eading through the model allows us to understand <span>the constraints that were defined for the model, so this approach improves the readability and maintainability of our code. Furthermore, ASP.NET Core provides</span><span> several popular built-in validation attributes: <kbd>[EmailAddress]</kbd>, <kbd>[StringLength]</kbd>, <kbd>[Url]</kbd>, <kbd>[CreditCard]</kbd>, and <kbd>[RegularExpression]</kbd>. </span></p>
<p>In the <kbd>Currency</kbd> field, we may add a constraint as follows:</p>
<pre><span>   public class OrderRequest<br/>     {<br/>         <strong>[Required]</strong><br/>         public IEnumerbale&lt;string&gt; ItemsIds { get; set; }<br/>         <span><strong>[Required]</strong><br/><strong>         [StringLength(3)]</strong><br/>         public string Currency {get; set;}</span> <br/>     }<br/></span></pre>
<p>In this case, the <kbd>Currency</kbd> attribute will contain a currency code, such as EUR or USD. We can add a restriction on the maximum length of the field so that it is limited to three characters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom validation attributes</h1>
                </header>
            
            <article>
                
<p>ASP.NET Core provides a way for us to create custom validations for our requests by extending <kbd>ValidationAttribute</kbd>, which means we can create custom validators for our types. Let's create a more appropriate validation for our <kbd>Currency</kbd> attribute:</p>
<pre><span>using </span><span>System</span>.<span>Collections</span>.<span>Generic</span>;<br/><span>using </span><span>System</span>.<span>ComponentModel</span>.<span>DataAnnotations</span>;<br/><span>using </span><span>System</span>.<span>Linq</span>;<br/><br/><span>namespace </span><span>SampleAPI</span>.<span>Requests<br/></span>{<br/>    <span>public class </span><span>CurrencyAttribute </span>: <span>ValidationAttribute<br/></span><span>    </span><span>{</span><br/>        <span>private readonly </span><span>IList</span>&lt;<span>string</span>&gt; <span>_acceptedCurrencyCodes </span>= <br/><span>        new </span><span>List</span>&lt;<span>string</span>&gt;{<br/>            <span>"EUR"</span>,<br/>            <span>"USD"</span>,<br/>            <span>"GBP"<br/></span><span>        </span>};<br/><br/>        <span>protected override </span><span>ValidationResult </span><span>IsValid</span>(<span>object </span>value, <br/><span>        ValidationContext </span>validationContext)<br/>        {<br/>            <span>return </span><span>_acceptedCurrencyCodes</span>.<span>Any</span>(c =&gt; c == value.<span>ToString</span>()) ?<br/>                <span>ValidationResult</span>.<span>Success <br/></span><span>                </span>: <span>new </span><span>ValidationResult</span>(<span>$</span><span>"{</span>validationContext.<span>MemberName</span><span>} is <br/>                not an accepted currency"</span>);<br/>        }<br/>    <span>}</span><br/>}</pre>
<p class="mce-root">The preceding implementation matches the request model currency with the list of <kbd>_acceptedCurrencyCodes</kbd>. If the match is successful, it returns <kbd>ValidationResult.Success</kbd>; otherwise, it returns a new validation result with a validation message. The <kbd>MemberName</kbd> attribute provides the name of the property that is associated with the custom validation attribute. Creating a custom validation attribute can be useful when we implement a more complex validation that involves third-party services or aggregate operations on the subject of the validation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have seen how we can build a web service stack using ASP.NET Core. We also looked at how to implement CRUD operations on a repository and how to deal with data transfer objects and validation. <span>This chapter has provided a starting point and the knowledge we need to build a very simple web service using ASP.NET Core, including how to handle requests, how to use model binding, and how to validate requests. </span></p>
<p><span>In the next chapte</span><span>r, we will cover the routing system of ASP.NET Core in more detail by exploring how it can be extended and customized.</span></p>


            </article>

            
        </section>
    </body></html>