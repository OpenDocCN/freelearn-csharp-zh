<html><head></head><body>
<div id="_idContainer048">
<h1 class="chapter-number" id="_idParaDest-78"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-79"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.2.1">Dealing with Time and Technical Debt</span></h1>
<p><span class="koboSpan" id="kobo.3.1">An information system is like a living organism: it always moves and changes. </span><span class="koboSpan" id="kobo.3.2">Yet, most of them are designed “one shot,” without thinking of its adequation to the business in time, but only of its capacity to handle the business needs at the moment it is designed. </span><span class="koboSpan" id="kobo.3.3">Lots of IT problems can be related </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to time.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In the previous chapter, we talked about business alignment and the importance of basing the structure on business concerns. </span><span class="koboSpan" id="kobo.5.2">This must also be applied to taking time as a parameter of the equation for a good information system: if the business feature is a one-shot/disposable one, its technical implementation will be no more complex than a prototype, quickly coded and soon discarded after use. </span><span class="koboSpan" id="kobo.5.3">On the other hand, for a feature that will be used for decades in production, you must carefully hone the design and polish the implementation, with as few moving parts as possible, since a good architect knows that maintaining such a module will eventually cost much more than its initial development (see, for example, </span><a href="https://natemcmaster.com/blog/2023/06/18/less-code/"><span class="koboSpan" id="kobo.6.1">https://natemcmaster.com/blog/2023/06/18/less-code/</span></a><span class="koboSpan" id="kobo.7.1"> on this issue). </span><span class="koboSpan" id="kobo.7.2">The code’s quality and its ease of maintenance (hence the developer’s dreaded activity of documentation) will be much more important than the capacity to quickly deliver the feature for </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">time-to-market reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">This chapter will analyze this problem of time adequation in information systems since most of them are designed with a time-fixed goal and rarely with evolution in time. </span><span class="koboSpan" id="kobo.9.2">This is why the majority of them see their performance quickly degrade in time and also why when their construction is too long, the result is not even in conformity to the expressed needs, hence the emergence of Agile software. </span><span class="koboSpan" id="kobo.9.3">The concept of technical debt will be explained, as well as the notion of coupling. </span><span class="koboSpan" id="kobo.9.4">Hopefully, by the end of this chapter, you will have improved your critical thinking of what needs a </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Proof of Concept</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">PoC</span></strong><span class="koboSpan" id="kobo.13.1">) approach and what needs strong, </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">evolutive, design.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">We’ll cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">The impact of time on systems due to </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">functional change</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">How the Agile approach aims to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">the problem</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">The concept of </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">technical debt</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">An experience-proven blueprint method for </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">information systems</span></span></li>
</ul>
<h1 id="_idParaDest-80"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.25.1">The impact of time on systems due to functional change</span></h1>
<p><span class="koboSpan" id="kobo.26.1">One of the most </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.27.1">difficult things to do when designing systems is to consider time. </span><span class="koboSpan" id="kobo.27.2">After all, it is already hard to picture how something complex should look at a given moment. </span><span class="koboSpan" id="kobo.27.3">Taking time into account requires an additional depth of thought, which can make this difficult. </span><span class="koboSpan" id="kobo.27.4">Moreover, time variations happen in every aspect as the system evolves, but it should also take into account time in its functioning, just like </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">another variable.</span></span><a id="_idTextAnchor124"/></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.29.1">A bit of fun with ill-placed comparisons</span></h2>
<p><span class="koboSpan" id="kobo.30.1">Here are a few sentences you may have heard in your everyday life concerning industries other </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">than computers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.32.1">The repairman changed my car engine this weekend; it is now ready for another </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">10 years</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">I took generic pills instead of the commercial brand: they are less expensive and I did not notice </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">any difference</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Since we started regularly maintaining the furnace, we haven’t had any failures during </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the winter</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">The dimensions of the parts evolved a bit, but we just had to change the parameters on the CNC machine; there was no need for the machining expert for such a </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">small change</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">Now, let’s try and transpose this to the IT industry and see if we can hear the same expressions without at least a wry smile or a </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">smirking face:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.42.1">We changed the ERP this weekend; everything seemed to work quite well on </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Monday morning</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">I used some free software as a replacement for my commercial suite: less expensive and since it was 100% compatible, everything works exactly </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">as before</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Since we regularly maintain our information system, we never have any major failures </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">or bugs</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">The business people need to adjust the system due to regulatory systems but, since it is just business rules, they do not need the IT team for such a </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">small change</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.50.1">Do any of these sentences sound realistic? </span><span class="koboSpan" id="kobo.50.2">If you happen to have the slightest experience in information systems, you will know that they aren’t, and even sound humorous. </span><span class="koboSpan" id="kobo.50.3">Nothing could be further from reality than these utopic sentences. </span><span class="koboSpan" id="kobo.50.4">The equivalent sentences should be more like </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.52.1">Management has decided to change the core ERP; we expect the information system to have a stabilization period of at least 6 months, and the initial project with analysis, deployment, and training will certainly take at least </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">a year.</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">I switched to open source to eliminate license costs, but since I had to adjust most of my processes, I lost a few functionalities and experts are hard to find on this technology, I am not sure the TCO will be lower in </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">the end.</span></span></li>
<li><span class="koboSpan" id="kobo.56.1">Due to new cybersecurity compliance rules, we made the entire IT team push updates to software applications that are disseminated everywhere in the information system; we hope most of the servers are covered but know that we still have a high level of risk on the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">employees’ workstations.</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">“This new GDPR will oblige us to release a brand-new version of the software and adjust most of the data streams in the information system; IT will certainly spend most of its non-maintenance time on this for the next </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">6 months.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.60.1">These versions are </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.61.1">way more realistic but sound like a desperate evaluation of the situation. </span><span class="koboSpan" id="kobo.61.2">Where does such a catastrophic capacity of the information systems come from? </span><span class="koboSpan" id="kobo.61.3">As explained in </span><a href="B21293_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.62.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.63.1">, information systems are not industrialized yet. </span><span class="koboSpan" id="kobo.63.2">But if you pay closer attention to these sentences, you will realize that they all bear the notion of evolution in time. </span><span class="koboSpan" id="kobo.63.3">And this is what makes them sound silly. </span><span class="koboSpan" id="kobo.63.4">If time was taken out of the equation, they may </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">look fine:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.65.1">The ERP we currently use </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">works correctly</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">I am using free software and it works </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">as expected</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">I am using the latest version; everything seems to be fine (</span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">for now)</span></span></li>
<li><span class="koboSpan" id="kobo.71.1">We have set up the software with initial rules (and we hope we don’t have to change them in </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">the future)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.73.1">In short, IT can work and provide great services but most of the time, this is when time passes and IT has got to evolve when </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">problems arise</span><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.75.1">.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.76.1">Consequences in the software world</span></h2>
<p><span class="koboSpan" id="kobo.77.1">The preceding</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.78.1"> comparisons may seem anecdotal, but they bear some reality as change is the only constant in life, and thus in information systems. </span><span class="koboSpan" id="kobo.78.2">A fun story I once heard stated that a perfectly stable information system is possible but needs three components: a human, a computer, and a dog. </span><span class="koboSpan" id="kobo.78.3">The computer does the work, the human feeds the dog, and the dog protects the computer from the human </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">touching it.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">Again, despite the humorous approach, there is some truth in this joke: the fact that the perfect system can be considered so because it is stable (the dog preventing the human from causing change, and consequently chaos). </span><span class="koboSpan" id="kobo.80.2">The computer can do a perfect job because it does not need to change what it has been programmed to do. </span><span class="koboSpan" id="kobo.80.3">Humor put aside, the consequences of time and evolution on information systems can be described formally and various concepts are associated with their different categories, all of which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">describe here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.82.1">The first concept associated with time in IT – and this one is well-known by anyone using computers – is the notion of software upgrades. </span><span class="koboSpan" id="kobo.82.2">As time goes by, a piece of software, whatever quality efforts are put into its design and development, will have to undergo regular changes of versions and at least security patches to remain fully operational. </span><span class="koboSpan" id="kobo.82.3">A software application is a complex system in itself, with sometimes millions of lines of code. </span><span class="koboSpan" id="kobo.82.4">If we go on with comparisons with the mechanical industry (sorry about coming back on this one, which certainly comes from my academic background in mechanical systems), that means a standard industry-grade application is closer in complexity to a commercial airplane than a standard automobile. </span><span class="koboSpan" id="kobo.82.5">No wonder it has to be upgraded and adjusted during its lifetime, just like airliners necessitate heavy maintenance. </span><span class="koboSpan" id="kobo.82.6">The difficulty comes from the fact that most applications are designed in a way that is not as modular as we would expect, and unexpected dependencies happen very often, making the application work as a cohesive entity. </span><span class="koboSpan" id="kobo.82.7">If you take a Rafale war aircraft, the engines can be changed by two mechanics in a few hours because the whole plane has been designed with this constraint. </span><span class="koboSpan" id="kobo.82.8">How about your ERP software? </span><span class="koboSpan" id="kobo.82.9">Is there any way you could switch the authorization engine in a few hours? </span><span class="koboSpan" id="kobo.82.10">Most certainly not... </span><span class="koboSpan" id="kobo.82.11">This is why the majority of software applications have a limited life expectancy: after many version upgrades, the overall quality always degrades and, in time, the application becomes less adapted to the business. </span><span class="koboSpan" id="kobo.82.12">Sure, some applications stay in business for more than 10 years, sometimes 20 or even more. </span><span class="koboSpan" id="kobo.82.13">But ask the users if the reason is that the software is perfect and if they love it and you will always get the same answer: the piece of software is still here simply because it is way too dangerous to try and </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">remove it!</span></span></li>
<li><span class="koboSpan" id="kobo.84.1">The second kind of</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.85.1"> impact of time on information systems is not on the software part but due to the business itself. </span><span class="koboSpan" id="kobo.85.2">As stated at the very beginning of this chapter, information systems are live entities, and they evolve continuously because business itself evolves. </span><span class="koboSpan" id="kobo.85.3">New strategies, regulation changes, large company reorganizations, fusion with an acquired company, selling of a business unit, and so on – there are so many factors that can move around the uses of the information systems that there is almost no way that they can remain stable for a long time, even in very stable business domains. </span><span class="koboSpan" id="kobo.85.4">In addition, on top of law-related regulations, many business rules are specific to companies and this makes it hard to produce applications that can truly pretend to reach the “one size fits all” state. </span><span class="koboSpan" id="kobo.85.5">Even with the best intention to keep things simple, companies often end up tweaking the software applications they bought, or integrating them with dedicated connectors or custom code, for them to comply with their way of doing business, simply because it costs less (at least at first) to do so, rather than reorganizing the corresponding function. </span><span class="koboSpan" id="kobo.85.6">But this is a trap and is where time comes into the game again: as time goes by, this specificity will cost more and more. </span><span class="koboSpan" id="kobo.85.7">First, every new major version of the application may make it fail, and money will be spent on keeping the specific code compatible with the new version. </span><span class="koboSpan" id="kobo.85.8">Most of the time, this was not fully budgeted, which means the overall cost grows and grows in time, sometimes ending up costing much more than initially adjusting the processes to the software. </span><span class="koboSpan" id="kobo.85.9">There is also a part of psychology in it: functional experts would feel bad adjusting their way of doing simply because some piece of code from an external editor thinks it is better to do it another way. </span><span class="koboSpan" id="kobo.85.10">What do they know about </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">their job?</span></span></li>
<li><span class="koboSpan" id="kobo.87.1">The third link to time in information systems is neither on software nor on functions, but on how the software is adapted to the business functions. </span><span class="koboSpan" id="kobo.87.2">This can be done through integration, customization, adjustment of application parameters, adapting the way the application interoperates with other parts of the software, and more. </span><span class="koboSpan" id="kobo.87.3">The link to time is a bit more subtle here, but all these ways remain mostly specialists’ jobs. </span><span class="koboSpan" id="kobo.87.4">And since experts are rare, it is very common that this step in a software project takes more time than accounted for. </span><span class="koboSpan" id="kobo.87.5">Changing a parameter is quick but analyzing all possible impacts in a complex system needs a good understanding of it (we talked about the need for a map of the information system in </span><a href="B21293_03.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.88.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.89.1">) and can take a lot of time. </span><span class="koboSpan" id="kobo.89.2">This is one of the reasons why </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.90.1">ERP projects – a well-known example – take so much time in a company (despite everything a commercial can tell you about it, there is no way in practice to reduce this time below 6 months at the very least). </span><span class="koboSpan" id="kobo.90.2">Another consequence of this is vendor lock-in: as more and more parameters get changed from their default values, as more and more connectors or integrations are added to the system, it becomes more and more difficult to change the software for other vendors. </span><span class="koboSpan" id="kobo.90.3">After a given amount of time, the application is so engrained in the system data streams that customizing a new application would take a huge effort (particularly since documentation is not the best asset of these projects), hence the stopped evolution of some </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">IT capabilities.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.92.1">All these have the</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.93.1"> consequence that the company using the information system is, in a way, dispossessed from its business processes as there are so many ways IT stands in the way and can prevent rapid evolution. </span><span class="koboSpan" id="kobo.93.2">Sure, IT helps automate processes and, once set in place, can provide interesting gains. </span><span class="koboSpan" id="kobo.93.3">But the effort to make it work – and in particular to keep it working in time – might not make it very interesting (remember the Gartner statistics showing that 70% of the IT budget goes into </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">maintenance alone!)</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Finally, </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">technical debt</span></strong><span class="koboSpan" id="kobo.97.1"> is also</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.98.1"> a concept that is strongly associated with time passing by. </span><span class="koboSpan" id="kobo.98.2">As it turns out, it is very much like entropy and tends to always grow with time. </span><span class="koboSpan" id="kobo.98.3">But this one is so important that we will analyze it in its very own section later in this chapter. </span><span class="koboSpan" id="kobo.98.4">For now, we are going to look at how Agile practices can help us deal </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">with</span><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.100.1"> time.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.101.1">How the Agile approach aims at solving the time problem</span></h1>
<p><span class="koboSpan" id="kobo.102.1">Agile has lots to do with time management, so it may help us deal with the time issues around information systems. </span><span class="koboSpan" id="kobo.102.2">To explain how, we will go back to what Agile is and then observe different ways it can solve the time-based complexity we need </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">to</span><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.104.1"> tame.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.105.1">A metaphor to explain Agile</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.106.1">Agile</span></strong><span class="koboSpan" id="kobo.107.1"> is</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.108.1"> about taking the time factor into account. </span><span class="koboSpan" id="kobo.108.2">In a V-cycle development process, everything is planned and time passing by is only supposed to make things go forward in the process. </span><span class="koboSpan" id="kobo.108.3">The Agile approach recognizes that time is itself a factor in the project, and it </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">appears everywhere:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.110.1">There is time negotiation because quality should not be compromised, and adding resources does not make a software project get quicker (“five cooks do not bake a cake in 10 minutes instead of 50”). </span><span class="koboSpan" id="kobo.110.2">So, the only way to adjust to hazards is to increase the time or reduce the functional scope (which comes back again to increasing time if the client still wants the complete initially-requested perimeter to be realized by the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the project).</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">Time is one of the major decisions in organizing an </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.113.1">Agile project: how long should the sprints be if you work with Agile? </span><span class="koboSpan" id="kobo.113.2">What cadence should be used if you use a Kanban approach? </span><span class="koboSpan" id="kobo.113.3">At what frequency should we organize stabilization sprints? </span><span class="koboSpan" id="kobo.113.4">How quick should continuous integration be to be efficient? </span><span class="koboSpan" id="kobo.113.5">How sustainable in time is the rhythm used by </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">the team?</span></span></li>
<li><span class="koboSpan" id="kobo.115.1">Filling a sprint is a negotiation around time available, and how estimates of time to be taken by backlog tasks should be done and added up to fill </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">the sprint.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.117.1">One of the best metaphors I have found to explain Agile software development to my customers or students also talks very much about time. </span><span class="koboSpan" id="kobo.117.2">The idea is to compare two ways of shooting an arrow at a target: the usual way is to aim at the target, carefully accounting for the wind and the distance to the target and, when everything is fine, shooting the arrow and hoping there will not be a sudden gust of wind, that we have estimated correctly the angle, and more. </span><span class="koboSpan" id="kobo.117.3">Guess what? </span><span class="koboSpan" id="kobo.117.4">If the target is far enough, hitting the bull’s eye is pretty much a question of luck, in these conditions. </span><span class="koboSpan" id="kobo.117.5">This is what the V-cycle is about: carefully planning for the project development in time, considering as many initial conditions as possible, and eventually launching the project, hoping that nothing will get it out of target... </span><span class="koboSpan" id="kobo.117.6">Sadly, there will always be external changes in conditions, customers changing their minds, a team being sick, an important dependency not being released on time, and </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Meet the Agile </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.120.1">way to hit the bull’s eye at every shot, or at least with a considerably higher probability: you must take the arrow in your hand, walk to the target against the changing winds, correct your path if the target moves, and eventually plant the arrow in the target when you’re close enough. </span><span class="koboSpan" id="kobo.120.2">Sure, walking to the target with an arrow in your hand takes way longer than the flight of the arrow once it’s been shot. </span><span class="koboSpan" id="kobo.120.3">But are you sure it is going to take longer than hitting many arrows in the wind to eventually have one reaching the target, not even in the middle? </span><span class="koboSpan" id="kobo.120.4">The difference lies in the conditions of the project. </span><span class="koboSpan" id="kobo.120.5">If everything is stable, no external dependencies are there, and you are in a fully controlled context, maybe planning everything in advance will be a bit quicker than adjusting step by step. </span><span class="koboSpan" id="kobo.120.6">However, the vast majority of software projects do not belong to this utopic situation. </span><span class="koboSpan" id="kobo.120.7">Most of them are developed in extremely changing contexts, with </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">hazards ev</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.122.1">erywhere.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.123.1">Back to the concept of emerging architecture</span></h2>
<p><span class="koboSpan" id="kobo.124.1">In </span><a href="B21293_03.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.125.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.126.1">, emerging code architecture</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.127.1"> was quickly cited and I said we would come back to this. </span><span class="koboSpan" id="kobo.127.2">Now is the right moment to do so. </span><span class="koboSpan" id="kobo.127.3">Since we talked about Agile development and we are in the middle of a discussion about time, let’s look at two things that are closely related to emerging architecture. </span><span class="koboSpan" id="kobo.127.4">This concept is about achieving a good architecture </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">without aiming at it in advance, with schemas and plans</span></strong><span class="koboSpan" id="kobo.129.1">, by refining the architecture along the development of a software project and refactoring the code structure at every step of iterative development. </span><span class="koboSpan" id="kobo.129.2">Without aiming at it in advance... </span><span class="koboSpan" id="kobo.129.3">does this remind you of something? </span><span class="koboSpan" id="kobo.129.4">This is the metaphor we used previously to explain the Agile approach to hit the target of a software project. </span><span class="koboSpan" id="kobo.129.5">Again, time is the concept that allows us to reach an agreement between architecture (in its meaning of structuring in advance) and the impossibility of knowing a complex business domain before working with it (thus needing to advance with the arrow in your hand and readjusting the path). </span><span class="koboSpan" id="kobo.129.6">This opposition and its resolution are so important that they need a </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">dedicate</span><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.131.1">d section.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.132.1">Apparent opposition between architecture and Agile methods</span></h2>
<p><span class="koboSpan" id="kobo.133.1">A decade ago, when I started understanding the principles of Agile software and applying them to the technical team I was leading, it was hard for me to understand why a typical Scrum team would be developers, testers, a product owner, and a Scrum master. </span><span class="koboSpan" id="kobo.133.2">How come there was no architect in there? </span><span class="koboSpan" id="kobo.133.3">As it was my business card title at this time, I took it personally. </span><span class="koboSpan" id="kobo.133.4">This was a bit disturbing since, at the same time, I was realizing the huge value Agile had compared to the old way we were using </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">by then.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">After discussing this with many Agile leaders who brought the concept to France, I eventually gave a conference in 2013 specifically on the subject of how to bring together architecture and Agile methods (French version: </span><a href="https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/"><span class="koboSpan" id="kobo.136.1">https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/</span></a><span class="koboSpan" id="kobo.137.1">). </span><span class="koboSpan" id="kobo.137.2">After exposing the many contradictions and how an “ivory tower” architect would have a hard time in short iterations, I ended up explaining a possible way to conciliate the utility of “seeing in advance” and “acting in short iterations and adjusting the vision”. </span><span class="koboSpan" id="kobo.137.3">Like most patterns, which are not invented but discovered independently by many people, this concept of emerging architecture is simply the result of any work trying to erase the contradiction </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">stated previously.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Again, time is the great equation solver here: </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">architecture and short iterations are not opposed if you set the time horizon of architecture to only a few iterations.</span></strong><span class="koboSpan" id="kobo.141.1"> This way, the probability that the target moves a lot is strongly reduced, and the architecture remains useful because it helps structure the development of these </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">few iterations.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">This solves the difficulty for the architect as their job remains necessary, even if it changes quite a lot if you consider the job is to think long shots ahead. </span><span class="koboSpan" id="kobo.143.2">But then again, even before Agile, architects in ivory towers (imagining a long time ahead without a grasp of reality and giving plans to the teams... </span><span class="koboSpan" id="kobo.143.3">that will not follow them) were largely seen </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">as pointless.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">It also helps us understand the concept of </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.146.1">emerging architecture, which states that, if refactoring is done correctly at the end of each sprint, the final structure of the code will be perfectly adequate for the functional needs... </span><span class="koboSpan" id="kobo.146.2">just like a perfect architectural vision (a long-shot of an arrow in the center of the target, in our metaphor) would have done in pure theory (but is practically impossible except for very </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">small projects).</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">In addition to time, semantics also helps remove the contradiction exposed previously. </span><span class="koboSpan" id="kobo.148.2">The word </span><em class="italic"><span class="koboSpan" id="kobo.149.1">architecture</span></em><span class="koboSpan" id="kobo.150.1"> is</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.151.1"> used in two </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">different ways:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.153.1">Architecture as </span><em class="italic"><span class="koboSpan" id="kobo.154.1">the emerging global shape of a project</span></em><span class="koboSpan" id="kobo.155.1"> is about the structure of the code produced by </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">the team</span></span></li>
<li><span class="koboSpan" id="kobo.157.1">Architecture as </span><em class="italic"><span class="koboSpan" id="kobo.158.1">the act of envisioning a structure</span></em><span class="koboSpan" id="kobo.159.1"> in the application (or even higher, in the information system as a whole) is about trying to reach this structured state by initially thinking and acting on </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">the system</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.161.1">This means that this theoretical contradiction can be overcome. </span><span class="koboSpan" id="kobo.161.2">But that does not mean that there is no practical impact, and I will show you one because it will help us go back to the notion of aligning the technical aspects with the business ones. </span><span class="koboSpan" id="kobo.161.3">But before that, I will add an </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">extern</span><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.163.1">al analysis.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.164.1">The position of famous architects</span></h2>
<p><span class="koboSpan" id="kobo.165.1">Just like for any scientific discipline, we software architects save a lot of time “sitting on the shoulders of giants,” which in our case involves reflecting on the state of the art established by real experts of the subject. </span><span class="koboSpan" id="kobo.165.2">Martin Fowler is certainly one of the best references in software architecture. </span><span class="koboSpan" id="kobo.165.3">On this question of opposition between “hack, code, and fix” and “big upfront design”, I strongly recommend reading the excellent article at </span><a href="https://www.martinfowler.com/articles/designDead.html"><span class="koboSpan" id="kobo.166.1">https://www.martinfowler.com/articles/designDead.html</span></a><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">The willingly-provocative title </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Is Design Dead?</span></em><span class="koboSpan" id="kobo.169.1"> hides the real background subject, which is precisely what we’re talking </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">about here.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Martin Fowler’s response to the opposition to architecture is simply to </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">only apply design to increase the capacity of the system to evolve</span></strong><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">As usual, there is no “true or false” answer between the two </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.174.1">extremes, namely </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">eXtreme Programming</span></strong><span class="koboSpan" id="kobo.176.1"> (which explicitly admits its extreme character) and </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">Big Up Front Design</span></strong><span class="koboSpan" id="kobo.178.1"> (which</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.179.1"> often does not admit or even recognize its extreme character and quickly produces “ivory </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">tower architects”).</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">This is where the job of the architect becomes an art as they need to proceed with good skills to obtain a subtle balance using some up front design without imposing unmovable limits, but still providing healthy guidelines that will truly help developers produce faster features </span><em class="italic"><span class="koboSpan" id="kobo.182.1">in the long term</span></em><span class="koboSpan" id="kobo.183.1"> (and not get blocked by software entropy, as described in Martin </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">Fowler’s article).</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Since, in addition, change is the only constant in software development, there is no use in writing what will be out of target due to functional changes in advance, but that does not mean the architect’s job is removed: on the contrary, it is about </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">easing the evolutions in the future</span></strong><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">Architecture is not about UML or code frameworks but about guidelines on the way the system should be structured: what are its fixed points, what are the articulations around which it moves; where should we focus on quality, where can we afford disposable code since the business evolves so quickly that investing on solidity is pointless? </span><span class="koboSpan" id="kobo.187.3">Sometimes, heavy architecture efforts can be justified precisely to accommodate an important module to change very frequently. </span><span class="koboSpan" id="kobo.187.4">This is, for example, the case of using </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.188.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">business rules management system</span></strong><span class="koboSpan" id="kobo.190.1"> (we will come back to this in more detail in </span><a href="B21293_05.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.191.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.192.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">The same applies to coding patterns: the mere fact of working correctly, and refactorizing your code continuously, will naturally bring patterns in your code, even if you did not know them in advance (I told you that craftsmanship was not dead!). </span><span class="koboSpan" id="kobo.193.2">An excellent bit of evidence of this, if you have not experienced it already by yourself in a coding activity, is that, when you read a lot of code (which very few people like to do, even though most great writers have been hungry readers beforehand) or when you follow groups of students, you will realize that these patterns are often discovered anew. </span><span class="koboSpan" id="kobo.193.3">This is the very definition of patterns since they are universal and, however, they’re found, if you structure your code correctly, the context will make you end up using the right pattern for this </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">p</span><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.195.1">recise problem.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.196.1">Thinking ahead with function contracts</span></h2>
<p><span class="koboSpan" id="kobo.197.1">Previously, I talked about a </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.198.1">practical example to illustrate the opposition on long-term and emerging architecture that we talked about before letting the expert (Martin Fowler) speak. </span><span class="koboSpan" id="kobo.198.2">The example I am talking about comes from my own professional experience and is a diagram I have created for a complex scenario of interoperation between several applications to implement a functional process. </span><span class="koboSpan" id="kobo.198.3">When analyzing the business needs at the beginning of the project (or rather their initial expression, because they change alongside the project), I </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.199.1">created the following </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">stream diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.201.1"><img alt="Figure 4.1 – Example of a data stream" src="image/B21293_04_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">Figure 4.1 – Example of a data stream</span></p>
<p><span class="koboSpan" id="kobo.203.1">Following </span><a href="B21293_03.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.204.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.205.1">, you should </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.206.1">normally recognize the duality between the function and the software implementation, and in particular, the essential recommendations that dependencies should point to level 2 instead of directly to level 3, which would result in point-to-point interoperation, creating a “hard coupling” of software solutions (we will come back to this expression shortly if you do not know what </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">it means).</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Even if we use machine </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.209.1">symbols, the bottom layer is really about software servers, hence layer 3. </span><span class="koboSpan" id="kobo.209.2">The intermediate zone is also part of the software layer as it contains connectors destined to transform API calls into proprietary calls if needed. </span><span class="koboSpan" id="kobo.209.3">The orchestration layer at the top shows how functional tasks expressed by API contracts are put together to create fine-grained processes. </span><span class="koboSpan" id="kobo.209.4">It can mostly be considered as layer 2 in the CIGREF map, with some touches of </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">layer 1.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">The reason I’m showing this schema is twofold. </span><span class="koboSpan" id="kobo.211.2">First, it illustrates when architecture goes too far and how emerging architecture can help save time: I drew this when I was a young architect, not fully aware of the concept of emerging architecture and it went too far. </span><span class="koboSpan" id="kobo.211.3">Sure, it helped to have a project vision, but in the end, almost none of the connectors and data streams worked the way I envisioned they would and time was </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">wasted there.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">Secondly, this schema provides more detail on the interaction between layers 2 and 3 of the CIGREF map, showing they are about API contracts (and we are not talking about API implementations with code, just contracts, which are lists of functional capabilities expressed in precise, technical terms). </span><span class="koboSpan" id="kobo.213.2">This is where it becomes particularly interesting because, despite the technical implementation not being (at all) the one envisioned and despite the orchestration of the streams having changed many times since the original blueprint, </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">it turned out the API contracts have remained unchanged for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.215.1">many years.</span></strong></span></p>
<p><span class="koboSpan" id="kobo.216.1">I cannot tell you how much satisfaction it has brought me to realize this a few years after the project. </span><span class="koboSpan" id="kobo.216.2">When thinking about the code, my initial vision was a failure and a very small portion of it had been implemented. </span><span class="koboSpan" id="kobo.216.3">When thinking about orchestration, the way the APIs are glued together has changed due to modifications in the processes and the business rules. </span><span class="koboSpan" id="kobo.216.4">But the API contracts I designed with the business-knowledgeable people were still there years after, basically unchanged, and their extreme alignment with the business had allowed all these changes to happen with very limited impact in code </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">or customization.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">In short, code architecture should be limited to a few iterations. </span><span class="koboSpan" id="kobo.218.2">But business alignment architecture is an investment worth doing, even at the very beginning of the project, because its value will </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">not decay.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">This is why </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.221.1">contract-first API design (again, I am not talking about API implementation, but solely the definition of the contract) is so important: the contracts can be established with pure functional knowledge, leaving every technical aspect outside, thus ensuring a very stable base for the definition of business modules and their dependencies that will serve as a strong foundation for the software implementations to </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">come afterward.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">We will come back to this notion of contract-first thinking in </span><em class="italic"><span class="koboSpan" id="kobo.224.1">Chapters 8</span></em><span class="koboSpan" id="kobo.225.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.226.1">9</span></em><span class="koboSpan" id="kobo.227.1"> but for now, please just keep in mind that the time horizon has an impact on architecture in its two meanings. </span><span class="koboSpan" id="kobo.227.2">For technical architecture, the time horizon should be limited for “the arrow to reach the target.” </span><span class="koboSpan" id="kobo.227.3">But for the functional architecture, the time horizon does not stand any limit because in this case, what we are doing is getting to know where the target is. </span><span class="koboSpan" id="kobo.227.4">This is a prerequisite at even just thin</span><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.228.1">king of </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">hitting it!</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.230.1">The concept of technical debt</span></h1>
<p><span class="koboSpan" id="kobo.231.1">Technical debt </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.232.1">may be one of the most discussed concepts related to IT management in the past decade. </span><span class="koboSpan" id="kobo.232.2">As the quality of software is a fundamental goal of this book, it is something we have </span><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.233.1">to </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">clearly describe.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.235.1">The general definition of technical debt</span></h2>
<p><span class="koboSpan" id="kobo.236.1">If you are reading this book, you are certainly interested in software quality and how to architect things correctly, so you most certainly have a good grasp of the concept of technical debt, or at least have been exposed to it. </span><span class="koboSpan" id="kobo.236.2">Nonetheless, I will give a quick definition of it so that you can try and </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">formalize it.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.238.1">What is technical debt?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.239.1">Technical debt</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.240.1"> is the amount of accidental complexity you have allowed to enter your project, together with its increase in </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">intrinsic complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Let’s decompose this a little. </span><span class="koboSpan" id="kobo.242.2">When you develop a software project, it always aims at producing a function on a given business domain perimeter. </span><span class="koboSpan" id="kobo.242.3">There is an inner, definite, stable complexity that comes from the domain you are trying to address: it is much simpler to print an address on an envelope than to optimize the flights for an </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">international airport.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.244.1">Or is it? </span><span class="koboSpan" id="kobo.244.2">Just as a side note, take great care to always know exactly what we are talking about when business needs are expressed, and if you cannot, do not hesitate to formulate caveats about what can and will be done. </span><span class="koboSpan" id="kobo.244.3">Explaining the functional needs with a simple sentence does not necessarily mean that the objective is itself simple, and much can be hidden behind this. </span><span class="koboSpan" id="kobo.244.4">In this example, you should immediately have the reflex of asking how the addresses should be printed, if there are different envelope formats to support it, what the international address is, if there are some norms and standards to respect, how the data will be provided, and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.245.1">so on...</span></em></span></p>
<p><span class="koboSpan" id="kobo.246.1">This first type of complexity is often</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.247.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">intrinsic complexity</span></strong><span class="koboSpan" id="kobo.249.1"> because it comes with the functional business domain you want to address and there is no way to escape it. </span><span class="koboSpan" id="kobo.249.2">Short of doing less than your client expects, there is no way you can reduce this. </span><span class="koboSpan" id="kobo.249.3">This does not mean you should take all this complexity right away: remember the Agile approach to cutting projects into small, manageable chunks that will be dealt with one at a time (“How do you eat an elephant? </span><span class="koboSpan" id="kobo.249.4">One bite at a time”). </span><span class="koboSpan" id="kobo.249.5">And if your customer wants you to go all the way to treat the complete business domain function and complexity, you will simply add as many sprints as needed to reach the desired level of intrinsic complexity. </span><span class="koboSpan" id="kobo.249.6">It will only take longer and, thus, be </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">more expensive.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">Now, let’s cover the second type of complexity: the accidental one. </span><span class="koboSpan" id="kobo.251.2">For this, let’s take the first example of expressed functional need, namely printing addresses on envelopes. </span><span class="koboSpan" id="kobo.251.3">To keep this short, suppose we only have to print standard addresses with four lines on a standard A5 format envelope, that the data for the addresses is provided in any format we want, and that the hardware part (a special printer for envelopes) is taken care of. </span><span class="koboSpan" id="kobo.251.4">How could we, as developers, implement this </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">requested function?</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">One of the simplest ways that comes to mind is to use the fusion function of an Office Word application, consuming the XML data from the integrated assistant, and saving the file for future uses by </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">But there is (way!) more than one way to implement a function with software and you may very well find yourself using a Java application that has been created from scratch to read addresses from any format, create a PDF document, and send it to the printer. </span><span class="koboSpan" id="kobo.255.2">It is not that complicated, but there are already more moving parts than in the first technical solution... </span><span class="koboSpan" id="kobo.255.3">and their maintenance is yours, instead of the Office editor’s! </span><span class="koboSpan" id="kobo.255.4">You will have to take care of the Java runtime with a version compatibility issue. </span><span class="koboSpan" id="kobo.255.5">The PDF generation can be a little tricky too. </span><span class="koboSpan" id="kobo.255.6">And maybe the developers will have left a few TODOs in the code, indicating that some corner cases need to be solved in the future. </span><span class="koboSpan" id="kobo.255.7">In the end, though not extremely complicated, this solution is more technically complex than the first one we proposed, though it reaches the same objectives in </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">functional terms.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">The delta is what we call accidental complexity in that this is the complexity that – contrary to the functional one – could have been avoided. </span><span class="koboSpan" id="kobo.257.2">It is sometimes confused with technical complexity, but this is not the right wording. </span><span class="koboSpan" id="kobo.257.3">There will always be some kind of technical complexity to implement a function: concrete execution cannot come from nowhere and there must be some kind of software to execute a function. </span><span class="koboSpan" id="kobo.257.4">Accidental complexity is, as its name suggests, the level of technical complexity that sits on top of the minimal necessary effort to implement the functional need. </span><span class="koboSpan" id="kobo.257.5">Therefore, it is considered an accident because things could have been done without it, and it is there because of exter</span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.258.1">nal, </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">unwanted reasons.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.260.1">Causes of technical debt and its relation to time</span></h2>
<p><span class="koboSpan" id="kobo.261.1">What are these </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.262.1">unwanted reasons? </span><span class="koboSpan" id="kobo.262.2">Well, there are so many of them that it would be difficult to list them all: laziness, lack of time to reach the appropriate quality, lack of training, the tendency that we all have to use a well-known technology rather than one that would be a better fit but would have to been learned first (“when all you have is a hammer, every problem looks like a nail”), lack of technical watch, with the result that we simply do not know about the mere existence of a better way to do things, </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">On top of these reasons, there is another one that has a deeper reach, namely that most technical experts, deep inside of them, actually </span><em class="italic"><span class="koboSpan" id="kobo.265.1">love</span></em><span class="koboSpan" id="kobo.266.1"> complexity. </span><span class="koboSpan" id="kobo.266.2">I often compare developers to gases (without malice: I am one myself, have been for decades, and still fall out in this trap): they will always occupy all the space you </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">give them.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.268.1">This is another similarity with thermodynamics since I was talking about entropy as a metaphor for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.269.1">technical debt.</span></em></span></p>
<p><span class="koboSpan" id="kobo.270.1">Let me give you a (not so unrealistic) example. </span><span class="koboSpan" id="kobo.270.2">Form a million-dollar team with software experts, asking them to create a function that calculates the sum of two integers, and you have a high probability that none of them proposes to simply use </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Int32.Add</span></strong><span class="koboSpan" id="kobo.272.1">. </span><span class="koboSpan" id="kobo.272.2">They will work under the hypothesis that you know what you are doing: since you set up such a great team and budget, you must have elevated goals of creating a high-performance function to add integers with virtually no limits in size, working in all conditions with </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">predictable outcomes.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">This is because developers are engineers and rarely business people. </span><span class="koboSpan" id="kobo.274.2">If they were, the first one you contacted in the team would tell you that you need no other hire and that they will take the whole job by themselves for only half the million dollars. </span><span class="koboSpan" id="kobo.274.3">Following this, they would put together a complex piece of machinery that simply calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Int32.Add</span></strong><span class="koboSpan" id="kobo.276.1">, makes you wait for a few months to hide the extreme simplicity of it, and delivers the end product to </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">you afterward.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">One of the key findings is to always give some boundary constraints to your developer teams; otherwise, they will add accidental complexity, sometimes even a large amount of it... </span><span class="koboSpan" id="kobo.278.2">and it is always a pain to know your best customer’s business process is blocked by a bug in a function that was added “in case we need it in the future” by an </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">overzealous developer.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">This first set of reasons for technical debt is quite critical of the developers but wait – there’s something to say about functional </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">people too!</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">How about laziness in explaining the precise need? </span><span class="koboSpan" id="kobo.282.2">Lack of communication with the developers? </span><span class="koboSpan" id="kobo.282.3">Extreme reliance on them to figure out the technical complexity (previously, I talked about the danger of a one-sentence business needing expression: it often hides a lack of understanding by the requester itself)? </span><span class="koboSpan" id="kobo.282.4">Lack of availability to test the results and adjust the functional request? </span><span class="koboSpan" id="kobo.282.5">The list could go on, as well as picking on our beloved product owners. </span><span class="koboSpan" id="kobo.282.6">It is not because they are not technical themselves that functional actors cannot cause </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">accidental complexity!</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">All these changes in the</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.285.1"> functional definition of what should be done have a huge toll on technical implementations: we do not change code like we change a wheel on a car! </span><span class="koboSpan" id="kobo.285.2">There are links between the functions, and the overall complexity of code escapes the human brain’s capacity after a few lines only. </span><span class="koboSpan" id="kobo.285.3">So, if indications change all the time, the result will undoubtedly be some low-quality code cutting corners on quality, full of “temporary” workarounds (who are we kidding? </span><span class="koboSpan" id="kobo.285.4">We all know they will stay there until the application end of life), </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">TODO</span></strong><span class="koboSpan" id="kobo.287.1"> indications for a hypothetical colleague to magically appear later and refactor the dumb incomplete code into a marvelous elegant new version, and so on. </span><span class="koboSpan" id="kobo.287.2">I am not even talking about dead code that will bloat applications forever, simply because the complexity – and lack of documentation – just makes it so risky to remove it an</span><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.288.1">d create </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">side effects...</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.290.1">Technical debt’s relation to time</span></h2>
<p><span class="koboSpan" id="kobo.291.1">Why, why, why is there so </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.292.1">much junk code in today’s software industry? </span><span class="koboSpan" id="kobo.292.2">Well... </span><span class="koboSpan" id="kobo.292.3">time, again. </span><span class="koboSpan" id="kobo.292.4">Technical debt is another concept that’s strongly related to time. </span><span class="koboSpan" id="kobo.292.5">Try to operate a root cause analysis on the aforementioned symptoms and, after a few consecutive “whys,” you will almost always reach the same answer: “not enough time.” </span><span class="koboSpan" id="kobo.292.6">Lack of junior training? </span><span class="koboSpan" id="kobo.292.7">We do not have the time. </span><span class="koboSpan" id="kobo.292.8">Lack of product owner availability? </span><span class="koboSpan" id="kobo.292.9">They do not have the time. </span><span class="koboSpan" id="kobo.292.10">Absence of documentation? </span><span class="koboSpan" id="kobo.292.11">We do not have </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the time...</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">Time also appears in another way in technical debt: as mentioned previously, technical debt, like entropy, always grows. </span><span class="koboSpan" id="kobo.294.2">And like entropy, there may be some special places where disorder is locally reducing, but this is always by consuming energy and growing disorder in other places, which makes entropy grow in the </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">whole system.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Technical debt is the reason why there is such a small portion of software applications that can still run fine after more than a decade. </span><span class="koboSpan" id="kobo.296.2">Casual observers may think this is because software is a world of fast changes, but when you think of it, change is not that quick. </span><span class="koboSpan" id="kobo.296.3">Java was the thing of the 90s, .NET came a decade later, the 2010s saw the use of JavaScript rise to things it was not made for, and the 2020s marked a few attempts at new languages with none marking its time for now – not such a tremendous rate of change... </span><span class="koboSpan" id="kobo.296.4">So, why do we change software so quickly? </span><span class="koboSpan" id="kobo.296.5">Simply because they are so full of technical debt we cannot maintain them in a costly </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">manner anymore!</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">This is another link to time that technical debt exposes: as time goes by and technical debt grows, the time toll it takes on the project by slowing down development goes up. </span><span class="koboSpan" id="kobo.298.2">This is why technical debt is called this: just like financial debt, you must pay the interest, so long as you keep some borrowed capital. </span><span class="koboSpan" id="kobo.298.3">The higher the capital borrowed (the depth of your technical debt, which is related to the number of times you have been cutting corners in your development process), the higher the interest (the additional time it takes to add</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.299.1"> a feature to </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">your application).</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">And since we’re talking about a linear relationship between the level of debt and the time it eats away at software development, that means there is a rate, just like in financial loans. </span><span class="koboSpan" id="kobo.301.2">Now is a good time to analyze</span><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.302.1"> this rate in </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">more detail.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.304.1">Debt or usury?</span></h2>
<p><span class="koboSpan" id="kobo.305.1">Many of us make loans, at least once in our lives, to buy a house. </span><span class="koboSpan" id="kobo.305.2">And it makes sense to pay a few percent of the amount obtained compared to the advantages we can draw from them: owning the house at the end of the loan, not paying rent anymore, and more. </span><span class="koboSpan" id="kobo.305.3">Depending on the economic context (and individual preferences also take a great part in the choice), there may be some cases where it is better to rent and not buy but, in the longer term, building some capital </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">always wins.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">However, this only holds true because the rate is small enough! </span><span class="koboSpan" id="kobo.307.2">How comfortable would you be if you had to borrow money at a rate of 10%, 20%, or even 50% interest per year? </span><span class="koboSpan" id="kobo.307.3">In this case, of course, nobody would ever borrow some money as, 2 years later only, the loan would have cost as much as the capital: in this case, you are way better off holding off your purchase for 2 years and </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">buying cash.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">Except there are cases where you cannot do this. </span><span class="koboSpan" id="kobo.309.2">Sure, you can rent a place to live instead of buying it. </span><span class="koboSpan" id="kobo.309.3">But how about when you need money to eat or have a temporary shelter because of a hard incident in your life? </span><span class="koboSpan" id="kobo.309.4">Without regulation, the banks could increase their rates as much as they want, and, in some cases, you would be obliged to take the loan anyway because your life depends on it. </span><span class="koboSpan" id="kobo.309.5">In this situation, you would have to reimburse this when your situation improves, but the rate is so high that it would eat up everything you have saved and you would end up contracting another loan, in a never-ending poverty loop. </span><span class="koboSpan" id="kobo.309.6">This is to avoid the situation that, for centuries, banks and even individual actors performing financial operations have been limited by governments through what is called </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.310.1">the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.311.1">usury rate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">If you do not know this financial term, usury refers to lending money at such a high rate that it makes it practically impossible to reimburse the capital. </span><span class="koboSpan" id="kobo.313.2">Society improvement is why it is now illegal in most countries, where maximum rates are fixed. </span><span class="koboSpan" id="kobo.313.3">For example, in France, at the time of writing, the usury rate was 5.33%, which means that banks are not allowed to lend money at a rate higher than </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">this value.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">Now, let’s go back to technical debt </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.316.1">and evaluate the rate at which we borrow. </span><span class="koboSpan" id="kobo.316.2">This isn’t very hard to find since the Gartner study on the cost of maintenance in information systems has already been cited twice previously: it is a flabbergasting 70% of the IT budget! </span><span class="koboSpan" id="kobo.316.3">Okay, this does not account for a 70% interest rate in technical debt, because you should also count the benefits the IT systems offer the company and the cost of doing otherwise. </span><span class="koboSpan" id="kobo.316.4">I will let you do the calculation as this can vary depending on your organization’s context. </span><span class="koboSpan" id="kobo.316.5">But all in all, there’s a chance that you will reach a figure that you would, by no means, tolerate from your bank on a financial loan, and that will be </span><em class="italic"><span class="koboSpan" id="kobo.317.1">way</span></em><span class="koboSpan" id="kobo.318.1"> higher than the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">usury rate.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">So, why should we tolerate this? </span><span class="koboSpan" id="kobo.320.2">Reasons for the situation have already been cited previously; now is the time to lay a few solution paths to get rid of excessive technical debt. </span><span class="koboSpan" id="kobo.320.3">This is what we wi</span><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.321.1">ll do in the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">coming section.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.323.1">Ways to balance technical debt</span></h2>
<p><span class="koboSpan" id="kobo.324.1">People often talk about </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.325.1">fighting technical debt or suppressing it. </span><span class="koboSpan" id="kobo.325.2">This is not the right wording as it bears the meaning that technical debt (and thus accidental complexity) should be downed to zero. </span><span class="koboSpan" id="kobo.325.3">This sounds like a hard thing to obtain as perfection costs a lot of money: in fact, your goal should not be removing all technical debt but rather keeping it in control, just like you should not try and find a 0% interest rate loan (you never will) but rather find the right rate that allows your project to be more cost-effective, balancing the interest rate, the amount and duration of the loan, </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">So, a bit of technical debt is acceptable. </span><span class="koboSpan" id="kobo.327.2">If you have to roll out this feature in time for the yearly seminar with all the customers, who will care that you did not put logging in place for the occasion? </span><span class="koboSpan" id="kobo.327.3">The only really important part is that you have placed a ticket in the development tool and the product owners agreed that it will be done in a coming sprint, before putting the feature into production. </span><span class="koboSpan" id="kobo.327.4">If they come back on their promise and try to delay this “technical” ticket and make a fuss about it, remind them of the consequences, send an email explaining how this will impact the future, ask for their written agreement of responsibility, escalate it to the big boss... </span><span class="koboSpan" id="kobo.327.5">whatever it takes to get this feature back on track! </span><span class="koboSpan" id="kobo.327.6">Otherwise, it will be your responsibility that technical debt starts </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">to grow.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">Of course, the best way will always be simply to not let the technical debt slip away. </span><span class="koboSpan" id="kobo.329.2">Sure, it may sound easier to say than to do, but knowing how the problem can arise is already a great step forward. </span><span class="koboSpan" id="kobo.329.3">Remember that the mere concept of “technical debt” was not known or formalized in the 2000s; now, even non-technical managers working in IT or software development may have heard about it. </span><span class="koboSpan" id="kobo.329.4">This is already a big improvement and lets you make an educated point to them, explaining how reduced delays and lack of training or time for documentation and quality will end up in slow development in a few months. </span><span class="koboSpan" id="kobo.329.5">Again, if you are a technical lead or a CTO, controlling the technical debt is one of your first and most </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">important duties.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">But you may be in a situation where the technical debt of a software application is already high – either because you have let it slip in the past (silly you) or because you are responsible for a piece of software that was already in a bad state. </span><span class="koboSpan" id="kobo.331.2">First of all, make it abundantly clear – if it is not perfectly known by stakeholders – that the situation is bad: you wouldn’t imagine how long bad software teams can invent pretexts for their inability to deliver, and you do need to have the capacity to improve the situation. </span><span class="koboSpan" id="kobo.331.3">If you accept the job but do not quickly issue warnings about the unstable situation, everyone will assume the software is fine. </span><span class="koboSpan" id="kobo.331.4">And you will not be able to alert about its state later, because, as you are a technical expert, everyone will logically consider that you should have seen it before, particularly if it is such a mess as you describe. </span><span class="koboSpan" id="kobo.331.5">You might even find some inconsiderate former owners ready to swear that the software was perfectly fine before they handed it over to </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">your team!</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">In this case, establish a map of the technical debt in the application (using the CIGREF four-layer map, not forgetting that technical debt can even come from badly designed processes or ill-defined functions, with incorrect governance). </span><span class="koboSpan" id="kobo.333.2">There might be some places where a bit of technical debt is acceptable. </span><span class="koboSpan" id="kobo.333.3">There will be some others where it eats most of the maintenance time and budget and where it has to be urgently taken care of. </span><span class="koboSpan" id="kobo.333.4">When evaluating the risks of correcting this, lots of people who have participated in the initial mess will tell you that the impacts will be so high that trying to correct the software will not work, and maybe even that they already tried and it failed. </span><span class="koboSpan" id="kobo.333.5">In this case, make your best estimations and ask for managers to decide and take ownership. </span><span class="koboSpan" id="kobo.333.6">When announcing that rewriting the concerned feature will cost 100,000 dollars and will come with a 20% risk of impact worth 200,000 dollars more, everybody around the table will certainly frown... </span><span class="koboSpan" id="kobo.333.7">but if you also explain that this software has cost the company 40,000 dollars every year for the last decade, thus already sending 400,000 dollars down the drain, the decision makers will be quick to perform the calculation and give you </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">a go.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">This means you may</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.336.1"> reimburse some of the capital (in the metaphor of financial loans) by removing technical debt, even if it is generally difficult to explain the benefits of this to the managers. </span><span class="koboSpan" id="kobo.336.2">After all, the business impact is not immediately perceivable and no customers are complaining that the software doesn’t work. </span><span class="koboSpan" id="kobo.336.3">So, again, you really must put a strong case together by evaluating how much time technical debt costs you, what features could have been done for your customers’ delight at the same time, and how much time it will take to reimburse the debt and bring the application to a sound level of quality, without forgetting the impact analysis – there is always a risk in “changing the eng</span><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.337.1">ine while the car </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">is running.”</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.339.1">The Big Bang temptation</span></h2>
<p><span class="koboSpan" id="kobo.340.1">How about the </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.341.1">Big Bang approach? </span><span class="koboSpan" id="kobo.341.2">You know – throwing it all away and restarting a new, fresh, clean product. </span><span class="koboSpan" id="kobo.341.3">The dream of all engineers... </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">If you think about it, this is not the right situation. </span><span class="koboSpan" id="kobo.342.2">If it happens without you being able to prevent it, then this is for the best.</span></strong><span class="koboSpan" id="kobo.343.1"> Let me explain this: the Big Bang approach, however seductive it may be, is </span><em class="italic"><span class="koboSpan" id="kobo.344.1">never</span></em><span class="koboSpan" id="kobo.345.1"> the right one. </span><span class="koboSpan" id="kobo.345.2">If you have a technical debt problem in your software, this is because your development process is wrong. </span><span class="koboSpan" id="kobo.345.3">So, if you start another application hoping it will be better than the previous one without fixing the process, you will simply lose a few years and reach the same state. </span><span class="koboSpan" id="kobo.345.4">If you know what was wrong in the process and have corrected it, the application will improve, so there is no use in throwing </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">it anymore.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">Does this mean that the</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.348.1"> Big Bang never happens? </span><span class="koboSpan" id="kobo.348.2">No, of course. </span><span class="koboSpan" id="kobo.348.3">Even if it is not a good idea, people still try to do it... </span><span class="koboSpan" id="kobo.348.4">and fail. </span><span class="koboSpan" id="kobo.348.5">But a clean slate is such an appealing idea that application owners, even though poor in marketing in all other aspects, will go to great lengths to obtain an agreement and budget from the stakeholders. </span><span class="koboSpan" id="kobo.348.6">They will do so by promising increased performance, providing better time-to-market for future features and ease of improvement, and so many other qualities that participants will eventually wonder why this had not been proposed earlier. </span><span class="koboSpan" id="kobo.348.7">And again, they will fail. </span><span class="koboSpan" id="kobo.348.8">This is not me saying this, but a return on experience that you will find from about everyone with experience with these kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">of projects.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">There are a few exceptions, like in any rule, and some Big Bang projects have indeed succeeded. </span><span class="koboSpan" id="kobo.350.2">I have noticed this in projects where the Big Bang was not intended by the teams but experienced through the fact that the old project simply collapsed down on its weight. </span><span class="koboSpan" id="kobo.350.3">In France, where I live, we have had many cases of such huge government projects where the failure was so big that there was nothing to be saved from the project and new software companies had to restart from scratch. </span><span class="koboSpan" id="kobo.350.4">The “Louvois” project (managing soldiers’ salaries) comes to mind, with millions of euros being thrown away with the project. </span><span class="koboSpan" id="kobo.350.5">To come back to what I said before about shared responsibilities in these events, technical problems were abundant in this project, but there was also a huge lack of functional feature descriptions and almost no cutting down of the project, which led</span><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.351.1"> to this </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">industrial catastrophe.</span></span></p>
<h3><span class="koboSpan" id="kobo.353.1">The different types of coupling</span></h3>
<p><span class="koboSpan" id="kobo.354.1">Coupling</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.355.1"> between applications is the last concept we well talk about concerning time... </span><span class="koboSpan" id="kobo.355.2">Just like technical debt is a little too much of something that must exist (technical complexity, to implement functional complexity), coupling is the name given to a dependency that is a little stronger than what’s needed from a functional point </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">of view.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">Let’s</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.358.1"> consider an example: you want to send a contract with an electronic signature to one of your customers. </span><span class="koboSpan" id="kobo.358.2">Of course, the contract module will have a dependency on the electronic signing application, as well as on the module providing the information you need about this customer (namely, their financial or legal contact email address). </span><span class="koboSpan" id="kobo.358.3">But there are dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">and dependencies...</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Imagine that the first one has been very well designed, and you can simply send a contract for a signature by calling an API in your information system that will then take care of everything. </span><span class="koboSpan" id="kobo.360.2">You do not even need to know what company will do the actual work, nor how this will be legally binding: you simply call the API and if it returns an OK (</span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">HTTP 200</span></strong><span class="koboSpan" id="kobo.362.1">, in technical terms), you are fine. </span><span class="koboSpan" id="kobo.362.2">This kind of dependency is a low-coupled one: things may change in the implementation, with your company preferring another electronic signature vendor, or routing the documents to sign in different ways, depending on who is calling the API: you do not care as you simply call something such as </span><a href="https://mycompany.com/document-sign"><span class="koboSpan" id="kobo.363.1">https://mycompany.com/document-sign</span></a><span class="koboSpan" id="kobo.364.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">POST</span></strong><span class="koboSpan" id="kobo.366.1"> command. </span><span class="koboSpan" id="kobo.366.2">This is all you know; whatever happens behind the scenes is not your concern. </span><span class="koboSpan" id="kobo.366.3">You still depend on the function’s completion to get your contract signed but this dependency is very flexible and you may never have to change anything in the way you call the function; the coupling you are subject to </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">is low.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">Now, let’s take the second dependency and imagine something at the other end of the spectrum: you need to get the email of the financial or legal contact for the customer, and to do this, you must know the customer ID. </span><span class="koboSpan" id="kobo.368.2">Sadly, this is not the same identification as the one you use internally in your service. </span><span class="koboSpan" id="kobo.368.3">So, first, you will have to call the service in charge of customer references to know the exact identification to use. </span><span class="koboSpan" id="kobo.368.4">When you have this information, you will have to dive deep into a folder shared through its IP number and go down the folder structure, starting with the year the consumer was recorded (it looks like it’s the first two numbers of the identifier you got, but you’re not sure), then a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Contact</span></strong><span class="koboSpan" id="kobo.370.1">, and final a folder with the kind of contact, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">FIN</span></strong><span class="koboSpan" id="kobo.372.1"> for finance and </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">JUR</span></strong><span class="koboSpan" id="kobo.374.1"> for legal. </span><span class="koboSpan" id="kobo.374.2">There, you will eventually find a Word document in which you will have to skip through some useless information before you finally get to page 2, where you find the email address you have been looking for all </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">this time.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">This sounds far-fetched but this is a real-world example I have seen during my consulting years (admittedly, though, it was one of the worst information systems I have ever seen in the 15 years I was working on customer systems). </span><span class="koboSpan" id="kobo.376.2">And we’re not even done yet! </span><span class="koboSpan" id="kobo.376.3">Some customers had multiple identifiers; and when they were deleted and re-entered in the database, their identifiers were recovered... </span><span class="koboSpan" id="kobo.376.4">but their data was in the folder corresponding to the renewal year instead of the initial creation year. </span><span class="koboSpan" id="kobo.376.5">At some point, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Contact</span></strong><span class="koboSpan" id="kobo.378.1"> folder was renamed </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">CONTACTS</span></strong><span class="koboSpan" id="kobo.380.1">, ruining the few attempts at automating information recovery, and the codes for the types of contacts were changed. </span><span class="koboSpan" id="kobo.380.2">Finally, the Word documents in the folders evolved in their format and the email address was not to be found at the same place, leaving people wondering if the new location contained the right data or if it was about new email information. </span><span class="koboSpan" id="kobo.380.3">All this useless complexity made this dependency on an email address one with a huge strong coupling (again, this is the worst example I </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">have seen).</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">Of course, low-coupling is generally better but, just like for technical debt, it is OK to have some coupling and the important thing is to control it. </span><span class="koboSpan" id="kobo.382.2">There might be some places where extremely strong coupling is not a concerning issue. </span><span class="koboSpan" id="kobo.382.3">For example, tight coupling to a budget structure is usually not a big deal because these structures are regulatory imposed and they change with a frequency calculated in decades. </span><span class="koboSpan" id="kobo.382.4">So, it’s no big deal if you have to radically review your processes and software applications in this case. </span><span class="koboSpan" id="kobo.382.5">On the other hand, you will want low coupling if you use a commercial dependency from a provider that tends to increase their license price when they realize you do a fair deal of business with their tools (you most certainly know of such editors). </span><span class="koboSpan" id="kobo.382.6">In this case, showing your CEO/CFO that you have made it possible to switch providers with a few changes of parameters and a small migration procedure will make you their beloved CTO partner as they will return to negotiations with the supplier having extremely strong arguments and an easy escape door if the latter will not change its </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">pricing policy.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">Finally, coupling is</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.385.1"> also related to time. </span><span class="koboSpan" id="kobo.385.2">There are lots of kinds of coupling, but there is a category of coupling that is chronologically measured. </span><span class="koboSpan" id="kobo.385.3">If, to proceed with a task in module A, you need a piece of information that comes from module B, the dependency is synchronous (and you will certainly find it is implemented through a synchronous call such as an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">GET</span></strong><span class="koboSpan" id="kobo.387.1"> call). </span><span class="koboSpan" id="kobo.387.2">If your process in module A can continue freely after it has called a function in module B, the dependency is asynchronous (and you will certainly see it as, for example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">POST</span></strong><span class="koboSpan" id="kobo.389.1"> API that returns a callback URL that you may call afterward to see if the job is done – or even better, you can register a webhook to get informed once the job is terminated; this will send you another URL you can contact to get the result of the external task). </span><span class="koboSpan" id="kobo.389.2">In </span><a href="B21293_17.xhtml#_idTextAnchor608"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.390.1">Chapter 17</span></em></span></a><span class="koboSpan" id="kobo.391.1">, we will come back to this approach and, in particular, explain the difference between orchestration and choreography and when to use each of them – as always, there is no true or false here and the right technology depends on the exact functional need and its context. </span><span class="koboSpan" id="kobo.391.2">Ideally, both approaches are used in a good information system, each in the context where they are the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">preferred solution.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">At this point, you should now have a clear understanding of technical debt and how it affects the evolution of information systems. </span><span class="koboSpan" id="kobo.393.2">As time goes by and technical debt cumulates, IT assemblies slow down in their evolution and sometimes their sheer functioning because of technical debt. </span><span class="koboSpan" id="kobo.393.3">What can we do about this? </span><span class="koboSpan" id="kobo.393.4">Well, this </span><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.394.1">is the subject of the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">next section.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.396.1">An experience-proven blueprint method for information systems</span></h1>
<p><span class="koboSpan" id="kobo.397.1">In this last section, I would like to explain a method I have been using to create blueprints of information systems</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.398.1"> evolution that I have been perfecting in the past few years with several industrial customers. </span><span class="koboSpan" id="kobo.398.2">There’s nothing special in there, nor particularly innovative, as it is just applying common sense to reach function targets... </span><span class="koboSpan" id="kobo.398.3">but it is formalized enough so that I can imagine you finding value in the description of the </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">steps used.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">The full method is quite elaborate and would need a dedicated book, so I will concentrate on a case that is precisely the subject of the chapter, namely dealing with time and technical debt. </span><span class="koboSpan" id="kobo.400.2">The example I’ll use will involve extracting a monolith software application ridden with technical debt but sadly used as the core of the customer company’s business (yes, a worst-case scenario). </span><span class="koboSpan" id="kobo.400.3">A multi-year planned blueprint had to be created to extract this dependency while limiting the impacts on the daily business. </span><span class="koboSpan" id="kobo.400.4">The following sections explain how this has been done, concentrating on the method and not showing the exact actions, to maintain </span><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.401.1">the confidentiality of </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">the customer.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.403.1">It all starts with... </span><span class="koboSpan" id="kobo.403.2">mapping!</span></h2>
<p><span class="koboSpan" id="kobo.404.1">As explained in </span><a href="B21293_03.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.405.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.406.1">, we have to start with a formalized mapping</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.407.1"> of the problem, and the CIGREF map was</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.408.1"> established around the perimeter to be studied. </span><span class="koboSpan" id="kobo.408.2">As the problem was on the functional and software layers, the processes were not represented at all and the fourth layer regarding hardware infrastructure just skirted over because all we needed there was the global cost of associated machines. </span><span class="koboSpan" id="kobo.408.3">The result was the following structure, where you can spot the top-left large white square in the software layer (this was the monolith subject </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">we studied):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 4.2 – The evolution of the preciseness in maps" src="image/B21293_04_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 4.2 – The evolution of the preciseness in maps</span></p>
<p><span class="koboSpan" id="kobo.412.1">This is something so</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.413.1"> important that</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.414.1"> I want to stress it again: </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">only the parts related to the study have been mapped</span></strong><span class="koboSpan" id="kobo.416.1">. </span><span class="koboSpan" id="kobo.416.2">Remember this graph from the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">previous chapter?</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.418.1"><img alt="Figure 4.3 – Example of a real-world map with reduced content" src="image/B21293_04_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.419.1">Figure 4.3 – Example of a real-world map with reduced content</span></p>
<p><span class="koboSpan" id="kobo.420.1">It was applied there because, with 20 software applications or so, it was only a small part of the whole information system of this company. </span><span class="koboSpan" id="kobo.420.2">As for the business capability map, it was more exhaustive, but this is only because we needed the whole perimeter for another project. </span><span class="koboSpan" id="kobo.420.3">As you can see, only a few of these functions were related to the software applications under study (following the lines between layer 2 and </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">layer 3).</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Back on the giants’ shoulders, I will simply</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.423.1"> recall that what Martin Fowler states about </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.424.1">classes applies perfectly to functions and software applications mapping: Martin recommends not to draw all classes in UML diagrams, only important ones. </span><span class="koboSpan" id="kobo.424.2">He then goes on to explain that the main problem with diagrams is that people drawing them try to make them comprehensive. </span><span class="koboSpan" id="kobo.424.3">Diagrams should help us understand concise and clear information, while only the code should be </span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.425.1">the source of </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">comprehensive information.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.427.1">Finding the atomic actions</span></h2>
<p><span class="koboSpan" id="kobo.428.1">Since extracting the </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.429.1">monolith at once and changing it for a new </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.430.1">application was not possible (remember, “No Big Bang... </span><span class="koboSpan" id="kobo.430.2">ever”), we had to devise a way to progressively extract functions from the application and migrate them, step by step, and with limited impact on new, modern implementations. </span><span class="koboSpan" id="kobo.430.3">But in which order? </span><span class="koboSpan" id="kobo.430.4">This is where the map will help, showing the modules and their dependencies. </span><span class="koboSpan" id="kobo.430.5">From here on, I will use arbitrary schemas to better explain the approach, even if they deviate from what happened in this project. </span><span class="koboSpan" id="kobo.430.6">Let’s imagine that the three important features we need to “rescue” are based on five software modules with the following dependencies (beware, there are functional implementations – links between layer 2 and layer 3, and technical couplings – links inside </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">layer 3):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.432.1"><img alt="Figure 4.4 – Simple example of functions and their implementations" src="image/B21293_04_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.433.1">Figure 4.4 – Simple example of functions and their implementations</span></p>
<p><span class="koboSpan" id="kobo.434.1">Once we’ve done this, we</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.435.1"> can use the information provided to draw two </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.436.1">chronological approaches (this is where the time relationship is the most present in this section). </span><span class="koboSpan" id="kobo.436.2">This first one could be, for example, to try and get the first functions out as quickly as possible (</span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">time-to-market strategy):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.438.1"><img alt="Figure 4.5 – Scenario with time-to-market priority" src="image/B21293_04_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.439.1">Figure 4.5 – Scenario with time-to-market priority</span></p>
<p><span class="koboSpan" id="kobo.440.1">In this case, the duty of rewriting the engine that features (or functions) 1 and 2 eventually depends on is left for later, but at least function 3 is quickly available in its new implementation. </span><span class="koboSpan" id="kobo.440.2">The problem with this approach is that, since it leaves the technical debt for later, the development process will remain slow and features will be harder to release until the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">This calls for another </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.443.1">approach where technical debt will be addressed first. </span><span class="koboSpan" id="kobo.443.2">The advantage is that features will flow quickly in the future. </span><span class="koboSpan" id="kobo.443.3">However, the shortcoming of this alternative approach is that it will take some time before we see the result (and as explained previously, this is where you’d better have a strong business case to convince the stakeholders to finance this investment). </span><span class="koboSpan" id="kobo.443.4">This second approach </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.444.1">can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.446.1"><img alt="Figure 4.6 – Scenario with TCO priority" src="image/B21293_04_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.447.1">Figure 4.6 – Scenario with TCO priority</span></p>
<p><span class="koboSpan" id="kobo.448.1">To sum up the advantages and drawbacks of each approach, it is better to superimpose the two diagrams, which puts forward the main differences, noted here by letters A </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">and B:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.450.1"><img alt="Figure 4.7 – Graphical difference between the two scenarios" src="image/B21293_04_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.451.1">Figure 4.7 – Graphical difference between the two scenarios</span></p>
<p><span class="koboSpan" id="kobo.452.1">The delta marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">A</span></strong><span class="koboSpan" id="kobo.454.1"> shows</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.455.1"> the difference between </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">initial</span></strong><span class="koboSpan" id="kobo.457.1"> time-to-market. </span><span class="koboSpan" id="kobo.457.2">This happens to be an important criterion in lots of businesses because customers need to be truly convinced that you are going forward. </span><span class="koboSpan" id="kobo.457.3">Whatever the trusty relationship you have with your customers – or internal users, by the way – it is hard to let them without any demonstration of what you have been doing for months, and </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.458.1">business owners know it. </span><span class="koboSpan" id="kobo.458.2">In the first scenario, feature 3 arrives sooner on the market, and may then participate in the financial investment for the rest of the project. </span><span class="koboSpan" id="kobo.458.3">In the second one, the first feature to be released not only arrives later but is not the same, which can make a great difference depending on what is most important for </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the users.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">The delta marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">B</span></strong><span class="koboSpan" id="kobo.462.1"> shows the difference in total time spent on the project: while scenario number 2 shows the first results less quickly than scenario number 1, it solves more technical debt at the beginning of the project, which will make for easier and quicker developments for the remaining time. </span><span class="koboSpan" id="kobo.462.2">This is something that should be taken into account because a development team costs a lot of money. </span><span class="koboSpan" id="kobo.462.3">Depending on the complexity of the project, this delta may become very important (note that in the preceding diagram, the scales are completely arbitrary and do not represent anything representative as it </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.463.1">depends on</span><a id="_idIndexMarker264"/> <span class="No-Break"><span class="koboSpan" id="kobo.464.1">your project).</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Now that we have established the two basic scenarios, we </span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.466.1">will dive into something a bit </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">more realistic.</span></span></p>
<h3><span class="koboSpan" id="kobo.468.1">Prioritizing the actions based on business criteria</span></h3>
<p><span class="koboSpan" id="kobo.469.1">It is a used </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.470.1">trick, but presenting two extreme alternatives often helps in getting stakeholders to choose an intermediate approach. </span><span class="koboSpan" id="kobo.470.2">There are good chances that the decision will not be between the two extreme approaches that have been explained previously but for a compromise somewhere in the middle. </span><span class="koboSpan" id="kobo.470.3">But then again, how do you adjust the cursor? </span><span class="koboSpan" id="kobo.470.4">What criteria can you use </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">for this?</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">Some criteria immediately come to mind for any business-savvy software architect, namely gross income/turnover and profitability rate. </span><span class="koboSpan" id="kobo.472.2">Often, I let the third criterion be something vague that stakeholders evaluate in terms of importance to the strategy of the company (they know more about this than any IT person). </span><span class="koboSpan" id="kobo.472.3">What is important at this point of the project is that these criteria should be evaluated fast, in a “planning poker” mode, and that they remain limited in number. </span><span class="koboSpan" id="kobo.472.4">I use levels of one to three stars for each of the criteria, and no more than three criteria as a whole. </span><span class="koboSpan" id="kobo.472.5">This is generally enough to find out what the best </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">scenario is.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">To come back to something a bit more realistic, here is an example of such a decision table that I have created with another company I advised (some entries have been deleted or renamed as they would have revealed </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">too much):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.476.1"><img alt="Figure 4.8 – Prioritization of projects through the chosen criteria" src="image/B21293_04_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.477.1">Figure 4.8 – Prioritization of projects through the chosen criteria</span></p>
<p><span class="koboSpan" id="kobo.478.1">Interestingly, in this case, you</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.479.1"> will note that the criteria were not the “standard” ones proposed previously. </span><span class="koboSpan" id="kobo.479.2">Here, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.481.1">The number of processes improved (in layer 1 of </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">the map)</span></span></li>
<li><span class="koboSpan" id="kobo.483.1">The estimated impact on overall productivity (this was an industrial </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">production company)</span></span></li>
<li><span class="koboSpan" id="kobo.485.1">The estimated impact on growth (they were operated on a rapidly consolidating market, where small companies were bought by bigger ones, so quickly growing was of utmost importance </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">to flourish)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.487.1">Also, a column was added to the traditional estimated weight of the project and delay estimates, namely for the impact and risks associated with the project (which is a sound approach and should be done for any such projects). </span><span class="koboSpan" id="kobo.487.2">To stress the fact that ease of elaboration of such projects is much more important than completeness and exact respect of the methodology, here is what the table initially resembled, after the 2 hours of analysis directly on </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">a whiteboard.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">You can find this whiteboard image on </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg"><span class="No-Break"><span class="koboSpan" id="kobo.491.1">https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg</span></span></a></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.492.1">A few last words on time, semantics, and alignment</span></h1>
<p><span class="koboSpan" id="kobo.493.1">Why a complete chapter on the importance of time in software development? </span><span class="koboSpan" id="kobo.493.2">You might have wondered this and I hope that I have convinced you, not of the importance of time, which is a given in any project, but rather of the fact that lots of problems in software development and information systems design should be watched across the prism of </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">time management.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">It often happens that, taking it for granted as it passes by without anything we can do about it, we forget about time in our activities of design, not taking into account the perspective of the future. </span><span class="koboSpan" id="kobo.495.2">How many information systems were born ill because they were designed to solve today’s problems, without thinking of how business will evolve in the future? </span><span class="koboSpan" id="kobo.495.3">Technical evolution, sure, we can handle them, and we do more than we should sometimes by preparing the system for the next framework, the future technology, and so on. </span><span class="koboSpan" id="kobo.495.4">But this is not the issue! </span><span class="koboSpan" id="kobo.495.5">The important thing is the business domain functions: they are changing as well and the information system has got to remain aligned with the business, not to some technical evolution that may be a fad in a </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">few years.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">Time</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.498.1"> is also often forgotten when we tend to analyze concepts as stable, simply because we do not use a broad enough time spectrum to explain them. </span><span class="koboSpan" id="kobo.498.2">Lots of concepts evolve while seemingly being extremely stable. </span><span class="koboSpan" id="kobo.498.3">In </span><a href="B21293_03.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.499.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.500.1">, I explained how the concept of “customer” is a business rule and not a stable entity: a customer can be anyone who bought something in the past 12 months for commerce while being anyone who has done so in the past 24 months for marketing. </span><span class="koboSpan" id="kobo.500.2">And maybe maintenance will have a list of customers based on who has got a running guarantee. </span><span class="koboSpan" id="kobo.500.3">These rules, like any business rules, can change in time. </span><span class="koboSpan" id="kobo.500.4">At some point, maybe the big boss will get tired of commerce and marketing not communicating the same numbers and evolution rate of customers and will force them to adopt a common definition; maybe the guarantee duration will change, which will affect the maintenance list of customers. </span><span class="koboSpan" id="kobo.500.5">Who knows? </span><span class="koboSpan" id="kobo.500.6">One thing is sure: if you have not considered time, you will </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">have trouble.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">A small anecdote – that I hope you will find revealing of the importance of time – to conclude this chapter: I happened to advise an organization that, through fusion with another one, had to change their logo. </span><span class="koboSpan" id="kobo.502.2">Since these organizations were subject to political changes after elections, the people there wanted to make it easier to adjust their logo in the future because this operation was extremely long and boring: the logo had to be changed in every message template from every application of the information system that would produce documents, and we were talking about thousands of templates and months of work to adjust the logo everywhere. </span><span class="koboSpan" id="kobo.502.3">The initial approach was to propagate a server share path everywhere: this way, changing the logo would automatically happen everywhere when the files were modified. </span><span class="koboSpan" id="kobo.502.4">Luckily, we had time to think about it a bit more and it was decided to switch the approach to a URL exposing the logo resource in different formats through content negotiation, and using an additional URL query parameter to indicate the reference time for which the logo was to be sent. </span><span class="koboSpan" id="kobo.502.5">This way, most applications who simply created documents along the way did not have to care about passing this parameter and would get the latest logo bitmap resource; but for the few legally-constrained applications that had to be able to fusion a letter at a given time in the past with the exact pixel-perfect form, it remained possible to do so without the new logo appearing on a old letter, which would have cause trouble. </span><span class="koboSpan" id="kobo.502.6">Today, this organization has equipped itself with an archive-capable content management solution, which now solves the problem in a much better way. </span><span class="koboSpan" id="kobo.502.7">Technical evolution took care of the functional need in a new way. </span><span class="koboSpan" id="kobo.502.8">Again, it was only a question </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">of time!</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">Here’s one last note about the</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.505.1"> importance of time and technical debt in information systems: there can be things even worse than technical debt, in what we</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.506.1"> could call “functional debt” or, more precisely, “semantics debt.” </span><span class="koboSpan" id="kobo.506.2">This will be the subject of </span><a href="B21293_09.xhtml#_idTextAnchor318"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.507.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">But for now, we are going to end the theoretical part of this book with something that is extremely theoretical: a perfect </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">information system!</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.510.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.511.1">In this chapter, we have shown how time influences everything in the analysis of an information system since it is a living entity that evolves throughout its use. </span><span class="koboSpan" id="kobo.511.2">Time is so current in our daily lives that it is often forgotten when structuring an information system, but it is the key to designing it in such a way that it will stand the test of time and have a </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">reduced TCO.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">The Agile approach is one of the first methods that dealt with this time-related reality, and it has radically changed how software is created and handled. </span><span class="koboSpan" id="kobo.513.2">The same approach can be applied to systems as a whole set of applications working together, which means the technical debt can be handled globally and kept under control. </span><span class="koboSpan" id="kobo.513.3">This notion of technical debt is not well named and, as a future chapter will show, semantics is very important, so I would recommend keeping this in mind at all times and, if possible, adjusting the naming, as was proposed in </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">The rest of this book contains lots of recipes to help you reduce this technical debt or at least keep it to an acceptable level. </span><span class="koboSpan" id="kobo.515.2">But in the next chapter, we will try and imagine a perfect information system, with little or no debt </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">or coupling.</span></span></p>
</div>
</body></html>