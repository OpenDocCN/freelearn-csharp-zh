- en: Building the Data Access Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from this chapter, we are going to walk through the concrete implementation
    of the web service part using .NET Core. We will cover some key aspects of developing
    real web servicesâ€”from the design of the data access layer to the implementation
    of the HTTP routes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by defining the data access part. The data access
    part is necessary to store information in a database or data source, and it is
    usually one of the most delicate parts of an application. We will be focusing
    on the implementation of a catalog web service. Additionally, we will explore
    different third-party tools for accessing our data and explain how to set up a
    project and implement a data domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing project entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a data access layer using EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a data access layer using Dapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a data layer using the in-memory database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in this chapter is available from the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like previous chapters, we can start by creating a new project using the
    web API template. Let''s open the terminal and execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first `dotnet new` command creates a new solution file named `Catalog.API`.
    The second `dotnet new` instruction creates a new web API project in the `src`
    folder. Finally, the last `dotnet sln` command adds the project to our solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting filesystem structure looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `src` folder will contain all our code and the additional projects we will
    add in the book. Later on in this chapter, we will also add a `tests` folder that
    will contain all the tests for our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the domain model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the *Data transfer* section in [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*, the *domain model* is the representation
    of the data handled by our service. Thinking about a *catalog web service* for
    a music store, the primary data we need to process includes the *entities* used
    by the API*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To guarantee reusability and loose coupling, we are going to define the domain
    model of the servicein a separate project. First of all, let''s create a new `Catalog.Domain`
    project inside the `src` folder by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The above command also specifies the `netstandard2.1` version as target framework.
    Furthermore, after creating the `Catalog.Domain` project, we need to add it to
    our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction adds a reference to the `Catalog.Domain` project to
    the `Catalog.API.sln` file. Therefore, we are now ready to design and implement
    the entities of our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Designing entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now proceed with the design phase of the entities we need for this implementation.
    Let's start with the `Item` class, which will be the central entity in our domain
    model. It is a representation of a music album, and it contains all the attributes
    and characteristics related to albums, including the *description*, *name*, *release*
    *date*, and *format.* The entity will also provide some additional information
    that is usually present in a catalog, such as available stock, a picture, and
    the price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by designing a diagram to describe our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1390bf3f-dc67-4333-908f-e1df3a3fc65f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This diagram defines the entities involved in the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Item` is the primary entity in our claim. It contains all the information
    about the album and the references to the *artist* and the *genre*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Artist` entity represents the artist associated with the album.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Genre` entity represents the music genre associated with the album.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Money` entity represents the price of the album. This is a complex type
    that contains the amount of *money* and the *currency* it is in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have defined which properties and objects are included in the catalog
    service, let''s start by implementing the entities as concrete types. All domain
    models are conventionally stored in the `Entities` folder in the `Catalog.Domain`
    project. The first type we are creating is the `Item` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, we can see that the definition of the `Item` class contains some references
    to the other types. It is crucial to note that the implementation uses the `Guid`
    type to specify `Id`. The primary purpose of that approach is to avoid conflicts
    in the event of a merger between two different data sources or catalogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by defining the related entities of our domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For representational purposes, the following classes are implemented in the
    same fragment of code. Note that they are defined in different files: `Artist.cs`,
    `Genre.cs`, and `Price.cs`.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code defines the related entities contained in our domain model*.*
    The `Artist` class represents an artist related to an album. It includes `Guid
    id` and `ArtistName`. In the same way, the `Genre` class is another category type
    that represents the genre of a specific album. Finally, the `Price` class represents
    the price (and the currency) of the product.
  prefs: []
  type: TYPE_NORMAL
- en: Data access using ORMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data access is the part of our service that helps us to perform reading or writing
    operations on the data source. The data access section is usually combined with
    an ORM. In general, we can define an ORM as an object-relational mapping tool
    for converting relational data between incompatible type systems using an object-oriented
    programming approach.
  prefs: []
  type: TYPE_NORMAL
- en: ORM tools or packages are a bridge between a data source and a web application.
    They map the information represented in relational tables into classes and, consequently,
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET ecosystem, we can choose between a vast number of different ORMs.
    The one that is officially maintained by Microsoft is EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core is an open source ORM powered by Microsoft and the community. It is
    the default ORM used in .NET Core applications and web services. In this chapter,
    we will also have an overview of **Dapper**, an open source micro-ORM powered
    by Stack Exchange and the community. Both EF Core and Dapper are distributed as
    NuGet packages, and, in general, they are very well integrated with the .NET Core
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the right tool for the job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EF Core and Dapper provide an abstraction level over our data source. Nevertheless,
    both of them have some pros and cons. It is essential to bear in mind that, for
    every project we are working on, we should seek to find the right tool for the
    job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze some pros and cons for these two libraries. Before that, we
    should take a quick look at some demo queries in order to understand the differences
    between the two. The following snippet describes a sample query using EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we search for every `Item` entity with a corresponding
    description. Let''s proceed by taking a Dapper query as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, EF Core provides a high level of abstraction over our data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, EF Core, by default, allows developers to query data using collections
    (integrated with LINQ). This type of approach is quick and easy, but it comes
    at a cost: EF Core translates queries into the SQL language, and, sometimes, it
    produces SQL queries that are not optimized. EF Core also encourages a code-first
    approach over the database, which means that all the entities that are present
    on the database side are generated using C# code. This may seem easy when you
    have a single object, but it can present maintainability problems when you have
    complex entities.'
  prefs: []
  type: TYPE_NORMAL
- en: In complex entities, or applications that use the code-first approach, the code
    that generates database entities is usually implemented in a separate project
    and repository to avoid tight coupling between the database and the entire solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common problem with EF Core, though, is the early fetching of resources.
    For example, consider a query such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces a SQL query similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, despite the fact we use the `Where` clause, earlier the `ToList`
    method evaluated the query without considering the `Where` clause. To get a better
    result, we should execute the `Where` statement before the evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This kind of procedure is better both for performance and network reasons. It
    may seem simple enough, but it is quite common that these kinds of error are introduced
    in the codebase in distributed teams, and they can be quite tricky to spot in
    the code review process.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of Dapper, which is a micro-ORM, the abstraction level changes. Dapper
    provides more *transparent* access to the data source. It guarantees, by default,
    a clear way to query your data by using plain SQL or stored procedures. Consequently,
    it also ensures better performance. On the other hand, it is tightly coupled with
    the data source, because it executes queries using the data source query language.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, this chapter will cover both EF Core and Dapper libraries. To choose
    between them, you should consider the skills already present in your team and
    how the service can be performance-optimized. If your team has a strong knowledge
    of SQL, you may proceed by implementing stored procedures instead of using EF
    Core. On the other hand, if your team doesn't already have SQL skills, you should
    consider using EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a data access layer using EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to build a data access layer using the
    repository pattern and EF Core. The **repository pattern** is an additional abstraction
    over our data source. It provides reading and writing operations on data.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the repository pattern and unit of work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we need to define some interfaces in the `Catalog.Domain`
    project. Let''s proceed by setting a generic interface to determine the unit of
    work of our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`IUnitOfWork` defines two methods: `SaveChangesAsync` and `SaveEntitiesAsync`.
    These two methods are used to save changes in our collection to the database effectively.
    These methods are both asynchronous: they return a `Task` type and they accept
    a `CancellationToken` type as a parameter. The `CancellationToken` parameter provides
    a way to stop pending asynchronous operations.'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the repository pattern is implemented in such a way that, when
    you update or create new elements in a collection, those changes are automatically
    saved to the database. I prefer to keep the effective saving operation separate
    from the reading and writing part. This can be achieved using the unit of work
    approach. Therefore, the repository allows the higher layers to perform get, create,
    and update operations on the memory collection, while the *unit of work*implements
    a way to transfer those changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by defining an `IRepository` interface at the same folder level
    as the `IUnitOfWork` interface defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `IRepository` does not implicitly use the `IUnitOfWork` interface.
    Additionally, it exposes the `UnitOfWork` instance as a property of the class.
    This approach guarantees that all the consumers of the `IRepository` interface
    must explicitly update the database by calling the `SaveChangesAsync` or `SaveEntitiesAsync`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to define the `IItemRepository` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The interface extends the `IRepository` class and refers to the `Item` entity
    that was defined previously. `IItemRepository` defines reading and writing operations
    over our data source. You may notice that the `Add`, `Update`. This is because
    they only act on the collection stored in the memory of the application, and the
    effective saving operation is performed by the unit of work.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our repository to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have defined the `IItemRepository` interfaces and all the abstractions
    in the domain project, we should continue by creating the classes that will represent
    the concrete implementation of the previously defined abstractions. We will also
    create a new `Catalog.Infrastructure` project containing all the implementations
    of our repositories and the classes that represent the layer between our service
    and the database. Let''s create the `Catalog.Infrastructure` project by executing
    the following commands in the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once finished, the folder structure for our solution looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Before proceeding with the implementation of `IItemRepository`, we need to
    add the `Microsoft.EntityFrameworkCore` NuGet package to the `Catalog.Infrastructure`
    project by executing the following command inside the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can proceed by adding the reference to the `Catalog.Domain`
    project into the infrastructure project, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: DbContext definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DbContext` is one of the abstractions between our application and the database.
    It enables us to interact with, and perform operations over, data. A `DbContext`
    implementation is also the representation of a session between our application
    and the database, and it can be used to query and save the instances of the application
    entities into our data source. Let''s take a quick look at the `DbContext` implementation
    in the `Catalog.Infrastructure` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After taking a quick look at the code, we should mention the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CatalogContext` class represents our unit of work; therefore, it implements
    the `IUnitOfWork` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses the `DbSet<Item>` type to represent the collection of `Item` instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor of the `CatalogContext` class accepts a mandatory argument,
    which represents `DbContextOptions`. These options are used to specify some key
    information about the connection with the database. This includes the database
    provider to be used, the connection string to that database, and all the tracking
    policies used by the ORM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CatalogContext` class also implements `SaveEntitiesAsync`, which calls
    the `SaveChangesAsync` method derived by the `DbContext` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have `CatalogContext`, we can continue by implementing the `IItemRepository`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following subsection focuses on building the concrete implementation of
    the `IItemRepository` interface. It is vital to note that the `IItemRepository`
    interface is located in the `Catalog.Domain` project and the implementation of
    `ItemRepository` is in the `Catalog.Infrastructure` project*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have built the `DbContext` class, we can proceed by implementing the
    concrete `ItemRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code implements the CRUD operations previously defined in the
    `IItemRepository` interface. It also exposes `CategoryContext` using the `IUnitOfWork`
    interface. This kind of approach guarantees that the consumer of `IItemRepository`
    can modify and query our collections and also update the data source with the
    corresponding changes. Let''s walk-through the methods implemented in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GetAsync()` method uses the context to retrieve the collection of `Items`
    entities. The method uses the `AsNoTracking()` method explicitly in order to prevent
    the tracking of entities. This extension method can be used every time you don't
    need to perform writing operations on entities, and it is meant for read-only
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetAsync(Guid id)` overloads the previously mentioned method, and it uses
    `AsNoTracking()` for the same purpose described previously. This method also gets
    details of the related entities (`Genre` and `Artist`) by using the `Include()`
    extension method provided by EF Core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Add(Item entity)` method uses the context to add the entity passed as a
    parameter and it returns the added entity to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Edit` method updates the target entity from the context and sets `EntityState.Modified`.
    This approach guarantees that, once the entity is in a modified state, it will
    be updated at the saving step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding code doesn't implement the `Delete` method. This is because the
    delete process will be implemented later on in the book. We will essentially perform
    a soft deletion of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming entities into a SQL schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EF Core encourages the code-first approach in our services. The **code-first**
    technique consists of defining some entity classes in C# and using them to generate
    tables on the database side. The same approach is applied to all the relationships
    and constraints that are usually present in a SQL ecosystem, such as the index,
    the primary keys, andthe foreign keys. This section demonstrates how to use this
    kind of approach to generate the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s start by taking back our `Item.cs` entity and adding an
    ID that represents the relationship with the other entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code describes the *many-to-one* relationship between the `Item`
    class and the `Artist` class and between the `Item` class and the `Genre` class.
    Additionally, both the `Artist` and `Genre` entities have a collection that refers
    to a collection of `Item` entities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue by implementing the constraints of our `Item` entity using the
    Fluent API approach. In general, EF Core ORM implements the Fluent API's technique
    to help us to deal with the constraint's definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the Fluent API, also called the **Fluent interface**, is a method
    for composing object-oriented APIs that are essentially based on method chaining.
    The chain between methods produces source code that is very close to written prose;
    for example, `myList.First().Items.Count().ShouldBe(2)`*.* You can see how readable
    this example is; it can be understood by anyone. Most EF Core constraints are
    usually built using this kind of approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by adding a new folder called `SchemaDefinitions` inside our
    `Catalog.Infrastructure` project. The folder will contain all the schema definitions
    implemented for the application and all the definitions of the constraints between
    the entities. For example, in the case of the `Item` entity, we need to create
    a new `ItemEntitySchemaDefinition` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the schema definition of the `Item` entity constraints. The class implements
    the `IEntityTypeConfiguration<T>` interface exposed by the `Microsoft.EntityFrameworkCore.SqlServer`
    package. It is necessary to add a new reference to the `Catalog.Infrastructure`
    project by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The package provides an extension method to interact with a SQL server database:
    the `Configure` method implementation defines rules, which will be applied to
    the `Item` entity. Because of the Fluent API approach, it is easy to understand
    these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ToTable` method is used to define the name of the SQL table explicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HasKey` method sets the property as the primary key for this entity type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IsRequired` method is used to mark all the required features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core provides different *out-of-box* configurations for our properties; a
    complete list is available at [https://docs.microsoft.com/en-us/ef/core/modeling/](https://docs.microsoft.com/en-us/ef/core/modeling/).
    These properties can be combined to obtain a better result regarding the correct
    representation of our domain model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Configure` method also adds some additional constraints to the *one-to-many*
    relationship between the `Item` entity and the `Artist` and `Genre` entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This snippet specifies the relationships of the `Item` entity. Note that we
    follow a fluent approach. In this specific case, we are defining a 1-N relationship
    between the `Item` class and the `Artist` and `Genre` classes, by specifying `GenreId`
    and `ArtistId` as the foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: Custom conversions using the Fluent API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EF Core also provides a way to add custom conversions*.* This approach may
    be useful for providing a custom representation of complex entities. As an example,
    let''s take the following snippet of code declared in `ItemEntitySchemaDefinition`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HasConversion` method offers a way to customize data inserted into the
    database. This method serializes the `Price` field, which is of the `Price` type,
    into a string by using the following format: `34.05:EUR`. On the other hand, when
    the `Price` data is read from the database, the string is deserialized into the
    `Price` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the schema definition on the current data context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To utilize the schema implemented in the `ItemEntitySchemaDefinition` class,
    we should apply it in the `OnModelCreating` method contained in the `CatalogContext`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `ApplyConfiguration` extension method to apply configurations
    to the SQL schema during the runtime execution. It is important to note that the
    `OnModelCreating` method implemented in the class always calls the `base.OnModelCreating`
    method of the parent class, in order to preserve the behavior of the extended
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a schema for the Artist and Genre entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding process can also be applied to the `Artist` and `Genre` entities.
    The following code shows the definitions of the two entities in the `Catalog.Domain.Entities`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, we can add two files to the `Catalog.Infrastructure` project
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GenreEntitySchemaConfiguration.cs` file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `GenreEntitySchemaConfiguration` and `ArtistEntitySchemaConfiguration`
    define the keys for our tables using the `HasKey` method. As we have already discussed,
    they use the same fluent approach applied to the `ItemEntitySchemaConfiguration`
    class defined previously. Also, we need to include `GenreEntitySchemaConfiguration`
    and `ArtistEntitySchemaConfiguration` in the `OnModelCreating` method of the `CatalogContext`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I've omitted the full definition of the `CatalogContext` class for brevity.
    The significant change is the extension of the `OnModelCreating` method by applying
    the configuration for the `GenreEntitySchemaConfiguration` and `ArtistEntitySchemaConfiguration`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Executing migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step in implementing data access using EF Core is to connect a `DbContext`
    instance to the database and run the migrations using the command exposed by the
    .NET CLI. Before doing that, we need to have a working database in our local environment.
    To keep our local development environment as lightweight as possible, this example
    will use a Docker image of Microsoft SQL Server on Linux. It is possible to get
    the Docker image here: [https://hub.docker.com/r/microsoft/mssql-server-linux/](https://hub.docker.com/r/microsoft/mssql-server-linux/).
    If you don''t have any previous experience with Docker, you can follow this guide
    to install and set it up on your local machine: [https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017).'
  prefs: []
  type: TYPE_NORMAL
- en: Containers are an excellent way to quickly set up your local environment without
    the need to configure a lot of different tools and systems. Nowadays, Microsoft
    is investing a lot in simplifying their systems and processes, both for developers
    and cloud systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running our SQL instance, let''s create a new database called `Store`*,*
    by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A valid alternative to the CLI is to use a SQL editor. One recommended tool
    is the `mssql` extension for VS Code: [https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017).
    Otherwise, you can download this cross-platform SQL editor based on VS Code: [https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017).'
  prefs: []
  type: TYPE_NORMAL
- en: Once we get Microsoft SQL Server working in our local environment, we can proceed
    by connecting our service with the database. The `Startup` class already present
    in the `Catalog.API` project will define the connection string and the provider
    used by our service. As we will see, all the migration classes will also be stored
    in the same project. This kind of approach guarantees a unique entry point, `Catalog.API`,
    for our .NET CLI instructions, without being tightly coupled with the database
    logic (`Catalog.Infrastructure`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding further, we need to add the `Catalog.Infrastructure` project
    as a reference for the API project by using the following command in the API project
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The API project also requires you to refer to the `Microsoft.EntityFrameworkCore.Design`
    NuGet package, which shares design-time components for EF Core tools. We can add
    the latest version of the package by executing the following CLI instruction into
    the `Catalog.API` project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can proceed by adding the database connection in the `Startup`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `ConfigureServices` method contains the initialization of the SQL connection.
    First of all, it adds the services required by the SQL provider using `AddEntityFameworkSqlServer`.
    Following that, it adds `CatalogContext`, utilizing the `AddContext<T>` generic
    method by passing an action method of the `Action<DbContextOptionsBuilder>` type.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the action method configures the SQL Server provider by using the `UseSqlServer`
    extension method and passing the connection string for our database. The `MigrationsAssembly`
    method defines where the assemblies should be stored. In this case, it specifies
    that all migrations will be stored in our `Catalog.API` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep our `Startup` class clean and readable, we may create a custom extension
    method to initialize the connection to the `Catalog` database. Let''s create a
    new folder called `Extensions` in our `Catalog.API` project*,* add a new `DatabaseExtension`
    class, and move our code into a new `AddCatalogContext` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the `Startup` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `Startup` class is ready, execute `migrations` in the `Catalog.API`
    project folder using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command generates the `Migration` folder and two different files
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{timestamp}_InitMigration.cs`: This class creates the tables, constraints,
    and indexes present in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogContextModelSnapshot.cs`: This is formed only on the first migration
    command and represents the current state of the entities of the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every migration class, including the one we just generated, has the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The class contains two methods: `Up` and `Down`. The `Up` method is called
    during the generation of the database schema. The `Down` method is called during
    the deletion of the schema.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated tables and SQL entities are created under the `catalog` schema.
    The `dotnet ef` CLI tool will create a new migration class each time we execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The schema of the database will be refreshed every time we run the EF Core
    update process Core inside our project folder. Therefore, we can proceed by executing
    the following CLI command in the `Catalog.API` project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates the SQL schema using the migrations stored in
    the `Migration` folder of the project: it will connect to the database specified
    in the connection string, which is stored in the `AddCatalogContext()` extension
    method. In the next section, we will examine how to move the specified connection
    string into the `appsettings.json` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the configuration part
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 2](6127f023-703b-42e3-a76e-b70a7b110b90.xhtml), *Overview
    of ASP.NET Core*, the `appsettings.json` file usually contains the application
    settings. The connection strings are typically stored in that file. Therefore,
    that kind of approach makes our service more reusable and configurable, especially
    when it is already running in a staging or production environment. Let''s move
    the connection string from the `AddCatalogContext` method to the `appsettings.json`
    file in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we can read the connection string and pass it to `AddCatalogContext`
    as a parameter using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we need to change the signature of the `AddCatalogContext` extension
    method by adding a `connectionString` parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can pass the newly defined `connectionString` parameter to the `UseSqlServer`
    extension method. In the next section, we will go on to test the repository logic
    implemented in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the EF Core repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section covers some common testing practices used to test .NET Core applications.
    More specifically, it focuses on testing the repository part of the application.
    First of all, let''s create a new test project by executing the following commands
    in the root folder of the project (the same folder as the `.sln` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we have created a new `tests` directory, which will contain all
    the test projects of the service. We also created a new `Catalog.Infrastructure.Tests`
    project using the `xunit` template.
  prefs: []
  type: TYPE_NORMAL
- en: '`xunit` is a very popular test framework in the .NET ecosystem, and it is the
    default choice for testing in .NET Core framework templates. Because we created
    our project using the `xunit` template, the `Catalog.Infrastructure.Tests.csproj`
    file will contain references to the `xunit` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: These packages allow us to run unit tests by using the `dotnet test` CLI instruction
    in the test project folder at the solution level, or by using test runner tools
    integrated into our preferred IDE, such as Visual Studio or Rider.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding data using DbContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue by looking at another EF Core feature, which allows us to seed
    data. The seeding data technique facilitates testing environments to get a **default**
    snapshot of our integration test database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through an example of database seeding using .NET Core. First of
    all, let''s create a new `Data` folder and add the JSON files that contain the
    test records. For brevity, I''ve included both the `artist.json` file and the
    `genre.json` file in the same snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned files contain data related to the `Genre` and `Artist` entities.
    In the same way, we can proceed by creating a new `item.json` file containing
    information about the `Item` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'These files hold some seed data to add to our database before each test. To
    read them, we need to include the `Newtonsoft.Json` package in the `Catalog.Infrastructure.Tests`
    project using the following command in the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also ensure that the JSON files are copied to the `bin` folder during
    the compilation step by adding the following code to `Catalog.Infrastructure.Tests.csproj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement a method to read data from JSON and serialize
    it in our database context. Also, we should add the `Microsoft.EntityFrameworkCore`
    NuGet package to the test project using the following CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned package will provide the EF Core `ModelBuilder` type, which
    is used to generate the mock data used by our tests. Since we will use some of
    the code implemented in the `Catalog.Infrastructure` project, we should also add
    a reference to the test project using the following command in the root of the
    solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can create a new extension method, named `Seed<T>`, inside a
    new `Extensions` folder in the `Catalog.Infrastructure.Tests` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: EF Core 2.1 has introduced a new way to perform data seeding in our database
    by exposing the `HasData<T>` method. The preceding code allows us to read a JSON
    file and serialize it into entities referred by `modelBuilder`. This approach
    provides a way to seed our mock database using the data written in the JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can proceed by creating a new context in the `Catalog.Infrastructure.Tests`
    project named `TestCatalogContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, `TestCatalogContext` class extends the `CatalogContext` class present
    in the `Catalog.Infrastructure` project, and overrides the `OnModelCreating` method
    to call the `Seed<T>` extension method on our entities. Consequently, when a consumer
    initializes the database using `TestCatalogContext`, it will have all the prepopulated
    data written in the JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Note here that the `TestCatalogContext` extends the `DbContextOptions<CatalogContext>`
    option in the constructor in order to initialize the `CatalogContext` base class.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the testing class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s proceed by creating a new testing class in our `Catalog.Infrastructure.Tests`
    project called `ItemRepositoryTests`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `Xunit` framework identifies test classes using the `Fact` attribute. Every
    class that contains a method that has the `Fact` attribute or, as we'll see later
    in this section, the `Theory` attribute, will be considered as a test by the unit
    test runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by adding our first test method. This checks the `GetAsync`
    method of the `ItemRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This code initializes a new `Options` object using `DbContextOptionsBuilder<T>`,
    which is of the `CatalogContext` type. It also uses the `UseInMemoryDatabase`
    extension method to create a new in-memory database instance with a given name.
    Since `DbContext` is extended by the `CatalogContext` class, which implements
    the `IAsyncDisposable` type, it is possible to use the `await using var` keywords.
    This approach avoids any type of nesting and provides a cleaner way of reading
    code, by avoiding the any use of nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the code, it is necessary to add the following package to the `Catalog.Infrastructure.Tests`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UseInMemoryDatabase` extension method is useful for configuring a new
    in-memory database instance. It is important to note that it is not designed to
    be a relational database. Furthermore, it doesn''t perform any database integrity
    checks or constraint checks. For more appropriate testing, we should use the in-memory
    version of SQLite. You can find more information about the SQLite provider in
    the following documentation: [https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite).'
  prefs: []
  type: TYPE_NORMAL
- en: After the creation of a new `Options` object, the `should_get_data` method creates
    a new instance of `TestCatalogContext`, and calls the `EnsureCreated()` method,
    which ensures that the context exists in the in-memory database. The `EnsureCreate`
    method also implicitly calls the `OnModelCreating` method. After that, the test
    initializes a new `ItemRepository` by using the context and executes the `GetAsync`
    method. Finally, it checks the result using `result.ShouldNotBeNull()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all test examples in this book use `Shouldly` as an assertion framework.
    `Shouldly` focuses on giving error messages that are concise and straightforward
    when an assertion fails. It is possible to avoid the use of `Shouldly` by using
    the default assertion framework built-in to .NET Core. You can find more information
    about `Shouldly` from the following link: [https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly).
    It is possible to add the `Shouldly` package executing the following CLI instruction
    in the `Catalog.Infrastructure.Tests` project: `dotnet add package Shouldly`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by implementing tests for all the methods implemented in the
    `ItemRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet defines tests that cover the `GetAsync` methods. The
    first method, `should_get_data`, tests the `GetAsync()` overload with no parameters,
    while the second method tests the `GetAsync(guid id)` overload. In both cases,
    we use `InMemoryDatabase` to emulate the underlying data source. In the same `ItemRepositoryTests`
    class, it is also possible to define test cases related to create/update actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `ItemRepositoryTests` class provides test coverage for all CRUD
    methods implemented by the `ItemRepository` class. The `should_get_data`, `should_returns_null_with_id_not_present`,
    and `should_return_record_by_id` methods execute the `GetAsync` method and check
    whether the result is what we expect. The `should_add_new_item` and `should_update_item`
    test cases provide test coverage for the `ItemRepository.Add` and `ItemRepository.Update`
    methods. Both the tests initialize a new record of type `Item` and they update
    the database through the methods exposed by the `ItemRepository` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we can run our tests by executing the following command in the
    `Catalog.Infrastructure.Tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command executes tests implemented in the project. Therefore,
    the result will be a report with a list of tests that have succeeded. As an alternative,
    we can also choose to run tests using the tests runner provided by the IDE. Now
    that we have completed the data access part using EF Core combined with the code-first
    approach, we can also take a quick look at Dapper, and how it can be useful by
    providing a more lighter way to access data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a data access layer using Dapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another standard tool that provides a way to implement a data access layer is
    Dapper. We have already taken an overview of Dapper*,* butthis section will cover
    in more detail how to deal with this package and how to use it to implement a
    data access layer. The following process will be more SQL-heavy. We will also
    demonstrate how you can deal with some stored CRUD procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Note that EF Core also provides a way to query data sources by using stored
    procedures. Moreover, it exposes methods such as `DbSet<TEntity>.FromSql()` or
    `DbContext.Database.ExecuteSqlCommand()`. So, why use Dapper? As mentioned previously,
    Dapper is a micro-ORM that is simple and faster than EF Core. EF is more of a
    multipurpose ORM, and it adds a discrete overhead on each operation performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting, let''s create another project inside the `src` folder called
    `Catalog.InfrastructureSP`, by launching the following command inside the `src`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the `Catalog.InfrastructureSP` project, we need to add it to
    our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command includes the `Catalog.InfrastructureSP` project in the
    solution. Once we have set up our new project containing all the alternative implementation
    of the data access layer, we can proceed by implementing the core part of the
    project using a SQL-first approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating stored CRUD procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the current example, we use some stored procedures that implement create*,*
    read*,* and update operations. In this book, we will not go into much detail about
    the SQL server programming model, but it is essential to understand that the code-first
    approach is not the only way to proceed. Stored procedures are an excellent way
    to implement interactions between services and a database.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures are the best way to interact with databases. Developers can
    proceed by executing complex queries and calling the procedure name. This modular
    approach provides some benefits in terms of permission configuration, faster network
    traffic, and faster execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create stored procedures to read data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The first snippet of code defines the `GetAllItems` stored procedure. It returns
    the whole collection of items. For demonstration purposes, the procedure doesn''t
    include any performance optimization. When we perform a `select` query on a large
    table, with a lot of records, it is necessary, at least, to insert a top statement
    to avoid long-running queries and timeout problems. Moreover, in a real-world
    application, it is uncommon to see a query without a specific filter. Let''s continue
    by creating the `GetItemById` procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: These two procedures are quite simple. The first one selects all the records
    from the `catalog. Item` table. The second one accepts an `Id` as the parameter
    and allows us to retrieve just the corresponding record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement operations to do with creating and updating a
    record. Both implementations are quite simple â€“ the `InsertItem` and `UpdateItem`
    stored procedures wrap `insert` and `update` SQL statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InsertItem` stored procedure executes a simple `insert` statement on the
    database by accepting data as parameters of the stored procedure. Let''s proceed
    by defining the `UpdateItem` stored procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that both operations use the `output` statement to retrieve the inserted,
    or updated, record as a result of the execution. In that way, we can retrieve
    the updated record from our repository pattern without extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft SQL Server provides a way to return inserted or deleted data using
    the *output* operator. It returns information from, or expressions based on, each
    row affected by an `INSERT`, `UPDATE`, `DELETE`, or `MERGE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to get these scripts working, it is necessary to execute them in our
    database. I suggest using the previously mentioned SQL Operations Studio tool
    or another SQL client to run these scripts in the `Catalog` database.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the IItemRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Implementing the data access layer using EF Core* section, we used two
    different interfaces to get the jobs done: `IItemRepository`, which contains all
    the CRUD operations, and `IUnitOfWork`, which covers the unit of work pattern.
    For each CRUD operation, we need to call the `IUnitOfWork` interface to save our
    changes in the database. On the other hand, the application of Dapper as a micro-ORM
    doesn''t need to provide a unit of work interface because ORM executes queries
    directly on the database using the stored procedures. For that reason, we don''t
    need to implement the `IRepository` interface anymore and, consequently, we will
    not implement the `IUnitOfWork` interface either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a first step, we should remove the `IRepository` interface implementation
    from our `IItemRepository` interface. Also, in this case, we can see the real
    power of dependency inversion: `Catalog.Domain` does not depend on `Catalog.Infrastructure`*.*
    It can also change the contract and requirements, and it forces `Catalog.Infrastructure`
    to alter its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add Dapper to our `Catalog.InfrastructureSP` project by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s proceed by implementing the `IItemRepository` interface using the `ItemRepository`
    class in the `Catalog.InfrastructureSP` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: To initialize our concrete class, it is necessary to pass `connectionString`
    to the SQL database in the constructor of the `ItemRepository` class.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Dapper approach is entirely different from EF Core. It doesn't
    add any particular overhead to our data source; it merely executes the aforementioned
    stored procedures by filling the requested parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter described you how to build a data access layer using EF Core and
    Dapper. It also showed you how to build unit tests using the in-memory database,
    and how to execute migrations with EF Core. I want to reiterate that the choice
    between EF Core and Dapper depends on different parameters: what kind of service
    we are building, the skills of our team members, and the type of infrastructure
    we''re using.'
  prefs: []
  type: TYPE_NORMAL
- en: The topics covered in this chapter provide the necessary knowledge to access
    data sources in .NET Core, using a code-first approach and also the stored-procedure
    approach. The chapter covered the use of technologies such as EF Core and Dapper.
    Additionally, it showed you how to test the data access layer using the in-memory
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will demonstrate how to implement handlers and the logic
    of our services.
  prefs: []
  type: TYPE_NORMAL
