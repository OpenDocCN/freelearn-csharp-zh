- en: '*Chapter 14*: Multi-Threaded Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 14 章*：多线程编程'
- en: In this chapter, you will learn about **multi-threaded programming**. You will
    learn what threads are and about background and foreground threads. Then, you
    will learn how to pass data into threads before you run them. You will also learn
    how to pause, interrupt, destroy, schedule, and cancel threads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习关于 **多线程编程** 的内容。你将了解线程是什么，以及后台和前台线程。然后，你将学习在运行线程之前如何将数据传递给线程。你还将学习如何暂停、中断、销毁、调度和取消线程。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Understanding threads and threading**: This section covers the life cycle
    of threads.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解线程和线程化**：本节涵盖了线程的生命周期。'
- en: '**Creating threads with and without parameters**: This section provides examples
    of thread creation with and without parameters.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建带参数和不带参数的线程**：本节提供了带参数和不带参数创建线程的示例。'
- en: '**Pausing and interrupting threads**: This section covers how to pause and
    interrupt threads.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂停和中断线程**：本节涵盖了如何暂停和中断线程。'
- en: '**Destroying and canceling threads**: This section covers destroying and canceling
    threads.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销毁和取消线程**：本节涵盖了销毁和取消线程。'
- en: '**Scheduling threads**: This section covers how to schedule threads.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度线程**：本节涵盖了如何调度线程。'
- en: '**Thread synchronization and locks**: This section covers how to synchronize
    threads, protect resources, and prevent deadlocks and race conditions.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程同步和锁**：本节涵盖了如何同步线程、保护资源以及防止死锁和竞态条件。'
- en: 'By the end of this chapter, you will have gained the following skills:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握以下技能：
- en: You will understand threads and threading.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将理解线程和线程化。
- en: You will be able to create threads with and without parameters.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够创建带参数和不带参数的线程。
- en: You will be able to pause and interrupt threads.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够暂停和中断线程。
- en: You will be able to destroy and cancel threads.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够销毁和取消线程。
- en: You will be able to schedule threads.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够调度线程。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To ensure that you benefit from this chapter, you should have the following
    requirements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你从本章中受益，你应该满足以下要求：
- en: Visual Studio 2022
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: 'The book’s source code from the following link: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从以下链接获取本书的源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14)。
- en: Understanding threads and threading
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线程和线程化
- en: 'In this section, we will understand the life cycle of threads. Threads in C#
    have a life cycle as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解线程的生命周期。C# 中的线程具有以下生命周期：
- en: '![Figure 14.1 – The thread life cycle'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.1 – 线程生命周期'
- en: '](img/B16617_Figure_14.1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_14.1.jpg)'
- en: Figure 14.1 – The thread life cycle
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 线程生命周期
- en: When started, threads enter the `Suspend` method, and calling the `Resume` method
    resumes a thread.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程启动时，它们进入 `Suspend` 方法，调用 `Resume` 方法可以恢复线程。
- en: When the `Monitor.Wait(object obj)` method is called, the thread enters the
    `wait` state. A waiting thread will continue when the `Monitor.Pulse(object obj)`
    method is called, and you can make threads sleep by calling the `Thread.Sleep(int
    millisecondsTimeout)` method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `Monitor.Wait(object obj)` 方法时，线程进入 `wait` 状态。当调用 `Monitor.Pulse(object
    obj)` 方法时，等待的线程将继续，你可以通过调用 `Thread.Sleep(int millisecondsTimeout)` 方法使线程休眠。
- en: When you call the `Thread.Join()` method, it causes the thread to enter the
    `wait` state. The waiting thread will then continue once the dependent threads
    have completed running. If any dependent threads are canceled, the thread is aborted
    and enters the `stop` state. Once a thread has been completed or canceled, you
    cannot restart it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `Thread.Join()` 方法时，它会导致线程进入 `wait` 状态。一旦依赖的线程完成运行，等待的线程将继续。如果任何依赖的线程被取消，线程将被中止并进入
    `stop` 状态。一旦线程完成或取消，就无法重新启动它。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `SYSLIB0006` compile-time warning will be raised by projects that target
    .NET 5 or higher if they call any of the `Thread.Abort` APIs. Microsoft recommends
    that you abort the `running` unit of work using `CancellationToken` instead. The
    `Thread.Abort` APIs are now obsolete.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目针对 .NET 5 或更高版本，并且调用任何 `Thread.Abort` API，将引发 `SYSLIB0006` 编译时警告。Microsoft
    建议您使用 `CancellationToken` 来中止 `running` 单元工作。`Thread.Abort` API 现已过时。
- en: In the next section, we will look at creating background and foreground threads
    with and without parameters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何创建带参数和不带参数的背景和前台线程。
- en: Creating threads and using parameters
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线程和使用参数
- en: 'In this section, we look at the creation of threads. First, we will see how
    to create parameterless threads in the foreground and the background. Let’s define
    both foreground and background threads as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨线程的创建。首先，我们将看到如何在前台和后台创建无参数线程。让我们如下定义前台和后台线程：
- en: '`Main` method be complete and the foreground thread is still running, the process
    will remain active until the foreground thread terminates.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Main`方法已经完成而前台线程仍在运行，进程将保持活动状态，直到前台线程终止。
- en: '**Background threads**: Background threads are created in the same way as foreground
    threads. The main difference is that you must explicitly set the thread to run
    in the background.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台线程**：后台线程的创建方式与前台线程相同。主要区别在于你必须明确设置线程以在后台运行。'
- en: 'The following code shows how to create and run a foreground thread:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何创建和运行一个前台线程：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create and run a background thread, you run the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并运行一个后台线程，你可以运行以下代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Both versions of the code that generates foreground and background threads,
    that you have just seen, create threads without using parameters. The following
    code shows you how to create a thread using parameters:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的生成前台和后台线程的两种代码版本都没有使用参数来创建线程。以下代码展示了如何使用参数创建线程：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in the preceding code, the thread is used to sum two numbers
    and return the result. The thread calls the `Add` method and passes the two integers
    to be added. Both the method call and the result are placed within an anonymous
    function passed into the thread’s constructor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，线程用于计算两个数字的和并返回结果。线程调用`Add`方法并将要相加的两个整数传递给它。方法调用和结果都放置在传递给线程构造函数的匿名函数中。
- en: Creating multiple threads can be costly on performance. The performance of multiple-thread
    creation can be improved by using thread pools. Thread pools improve performance
    in multi-threaded applications by limiting the number of threads that should be
    created and managed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个线程可能会对性能造成影响。可以通过使用线程池来提高多线程创建的性能。线程池通过限制应该创建和管理的线程数量来提高多线程应用程序的性能。
- en: When a new thread is created using a thread pool, it is kept there until it
    is needed. When required, the thread will run and complete its task. Once the
    task is completed, the thread will return to the thread pool for later reuse.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用线程池创建新线程时，它会被保留在那里，直到需要它。当需要时，线程将运行并完成其任务。一旦任务完成，线程将返回到线程池以供以后重用。
- en: 'You can create a thread in a thread pool as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式在线程池中创建线程：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The thing to note when using a thread pool is that when first used, they have
    no history, but over time, they tune themselves to improve thread pool performance.
    For applications that use a large number of threads and put a heavy load on the
    CPU, it is possible that they will encounter a high startup cost. Threads have
    to be created and made available to the thread pool. This can cause the thread
    pool to have to wait until those threads are made available. A performance tweak
    you can make at startup is to set the minimum number of threads. The following
    code shows how to set the minimum number of threads:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程池时要注意的是，首次使用时，它们没有历史记录，但随时间推移，它们会调整自己以提高线程池性能。对于使用大量线程并对CPU造成重负载的应用程序，它们可能会遇到高昂的启动成本。线程必须被创建并可供线程池使用。这可能导致线程池必须等待直到那些线程可用。在启动时可以进行的一种性能调整是设置最小线程数。以下代码展示了如何设置最小线程数：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `WorkerThreads` value is the minimum number of worker threads created on
    demand by the `ThreadPool`. The `CompletionPortThreads` value is the number of
    asynchronous I/O threads created on demand by the `ThreadPool`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkerThreads`值是`ThreadPool`按需创建的最小工作线程数。`CompletionPortThreads`值是`ThreadPool`按需创建的异步I/O线程数。'
- en: 'In addition to setting the minimum number of threads, you can set the maximum
    number of threads as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置最小线程数之外，你还可以设置最大线程数，如下所示：
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In order for these settings to help with application performance, you need to
    set them correctly. Otherwise, you can end up creating too many threads and overscheduling
    tasks. This will reduce performance by increasing context switching, which will
    put more load on the CPU. The `ThreadPool` is intelligent enough to switch to
    an algorithm that will reduce the amount of work the CPU has to do once it gathers
    a history.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这些设置有助于应用程序性能，您需要正确设置它们。否则，您可能会创建过多的线程并过度调度任务。这将通过增加上下文切换来降低性能，这将增加CPU的负载。`ThreadPool`足够智能，一旦收集到历史数据，就会切换到一种算法，以减少CPU需要完成的工作量。
- en: Before settings these values, it is a good idea to use performance monitoring
    to monitor the thread usage and context switching of your application. You can
    use performance counters tracing using the Contextual Visualizer, which is discussed
    in the following chapter. You can also use the `ThreadPool.GetMaxThreads` and
    `ThreadPool.GetMinThreads` methods to help you analyze the optimal values for
    setting the minimum and maximum numbers of worker threads and completion port
    threads.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置这些值之前，使用性能监控来监控应用程序的线程使用和上下文切换是一个好主意。您可以使用上下文可视化器进行性能计数器跟踪，这将在下一章中讨论。您还可以使用`ThreadPool.GetMaxThreads`和`ThreadPool.GetMinThreads`方法来帮助您分析设置最小和最大工作线程以及完成端口线程的最佳值。
- en: You can also set a thread’s priority. However, you have to be very careful about
    setting a thread priority as it can have a negative impact on other threads and
    other applications. Setting threads to a higher priority can starve lower priority
    threads, resulting in them rarely running.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以设置线程的优先级。然而，您必须非常小心地设置线程优先级，因为它可能对其他线程和其他应用程序产生负面影响。将线程设置为更高的优先级可能会导致低优先级线程饥饿，从而使其很少运行。
- en: Only when a fast response is required for an event, such as an exception, should
    you consider changing thread priority to a high value. When race conditions are
    encountered, you can legitimately lower a thread’s priority. Threads that do not
    run for a while because of their lower priority will run at some point. This is
    because the dynamic priority of a thread is increased by Windows the longer it
    goes without running.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要快速响应事件时，例如异常，您才应考虑将线程优先级更改为高值。当遇到竞态条件时，您可以合法地降低线程的优先级。由于优先级较低而一段时间没有运行的线程最终会运行。这是因为线程的动态优先级会随着Windows在没有运行的情况下时间的增加而提高。
- en: If you do change the priority of a thread, its priority will be reset on entry
    back into the pool. However, a thread may be used for several tasks. In this case,
    the thread will not return to the pool until these tasks are completed. If the
    priority is set incorrectly, then this can degrade both application performance
    and system-wide performance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实更改了线程的优先级，那么在返回到池中时，其优先级将被重置。然而，一个线程可能用于多个任务。在这种情况下，线程将不会返回到池中，直到这些任务完成。如果优先级设置不正确，这可能会降低应用程序性能和系统性能。
- en: We now understand how to create and run threads. Let’s turn our attention to
    pausing and interrupting threads.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了如何创建和运行线程。让我们将注意力转向暂停和中断线程。
- en: Pausing and interrupting threads
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停和中断线程
- en: In this section, we will look at pausing and interrupting threads. An example
    of why you would need to pause or interrupt a thread is if the code running is
    a debugger. If a thread is executing and it hits a breakpoint, it would need to
    be paused.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨暂停和中断线程。您需要暂停或中断线程的一个例子是，如果正在运行的代码是调试器。如果一个线程正在执行并且遇到断点，它需要被暂停。
- en: The most common way to pause/delay a thread is to call `Thread.Sleep(millisecondsDuration)`,
    but this may freeze the main thread and your users may think your program has
    stopped working, leading them to terminate it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停/延迟线程最常见的方法是调用`Thread.Sleep(millisecondsDuration)`，但这可能会冻结主线程，您的用户可能会认为您的程序已停止工作，从而导致他们终止它。
- en: A better way to delay a thread is to let `Task.Delay(TimeSpan)` run in the background.
    This will allow the thread to work in the background and prevent the delayed thread
    from stopping the main thread from doing its work.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟线程的更好方法是让`Task.Delay(TimeSpan)`在后台运行。这将允许线程在后台工作，并防止延迟的线程停止主线程执行其工作。
- en: 'The following code shows how to delay a thread:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何延迟线程：
- en: '[PRE29]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We create the task with a time delay of five seconds. The loop keeps running
    until the time delay has been completed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有五秒延迟的任务。循环会一直运行，直到延迟完成。
- en: The `Interrupt` method is called to interrupt a thread that is in a blocked
    state of `wait`, `sleep`, or `join`. When the method is called, `ThreadInterruptedException`
    is raised. This exception is not raised when calling the `Interrupt` method on
    a thread not in a blocked state.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Interrupt`方法来中断处于`wait`、`sleep`或`join`阻塞状态的线程。当方法被调用时，会引发`ThreadInterruptedException`异常。当在非阻塞状态的线程上调用`Interrupt`方法时，不会引发此异常。
- en: Destroying and canceling threads
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁和取消线程
- en: Aborting threads is not a good idea as you don’t always know the state of a
    thread. It can be made worse if the thread is part of a static constructor. Using
    `Thread.Abort` to abort a thread is one of the main reasons for application crashes.
    The `Thread.Abort` APIs are now obsolete. So, you are encouraged to use the cooperative
    cancellation pattern to periodically check for cancellations using `CancellationToken`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 终止线程不是一个好主意，因为您并不总是知道线程的状态。如果线程是静态构造函数的一部分，情况可能会变得更糟。使用`Thread.Abort`来终止线程是导致应用程序崩溃的主要原因之一。`Thread.Abort`
    API现在已过时。因此，建议您使用协作取消模式，定期使用`CancellationToken`检查取消操作。
- en: 'Under normal circumstances, when a thread is aborted, it is destroyed. The
    cancellation of a thread also destroys the thread. Let’s write some sample code
    that demonstrates the usage of `CancellationToken` to cancel a synchronous operation
    when it times out, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，当一个线程被终止时，它将被销毁。线程的取消也会销毁线程。让我们编写一些示例代码，演示如何使用`CancellationToken`在超时时取消同步操作，如下所示：
- en: Start a new .NET 6 console application and call it CH14_Multithreading.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的.NET 6控制台应用程序，并将其命名为CH14_Multithreading。
- en: 'In the *Program.cs* file of the *CH14_Multithreading* project, add the following
    method:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CH14_Multithreading`项目的`Program.cs`文件中，添加以下方法：
- en: '[PRE44]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This method receives a method to execute over a specified timeout period and
    returns a result. `SleepyMethod` is executed, but if it exceeds the timeout value,
    then `TaskCanceledException` is raised and then `CancellationTokenSource` is disposed
    of.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收一个在指定超时期间执行的方法，并返回一个结果。`SleepyMethod`被执行，但如果它超过了超时值，则引发`TaskCanceledException`异常，然后`CancellationTokenSource`被释放。
- en: 'Add the `SleepyMethod` code as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式添加`SleepyMethod`代码：
- en: '[PRE45]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `SleepMethod` accepts `CancellationToken` as a parameter. It then loops
    ten times. During each iteration, it sleeps for half a second. Then, it checks
    to see whether cancellation has been requested. If cancellation has been requested,
    then `TaskCanceledException` is raised. Otherwise, the value of the method is
    returned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`SleepMethod`接受`CancellationToken`作为参数。然后它循环十次。在每次迭代中，它睡眠半秒钟。然后，它检查是否已请求取消。如果已请求取消，则引发`TaskCanceledException`异常。否则，返回方法的值。'
- en: 'Add the `SynchronousThreadCancelation` method as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式添加`SynchronousThreadCancelation`方法：
- en: '[PRE46]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This method creates a timeout value of three-quarters of a second. It then
    calls the `TryCallWithTimeout` method, which returns a Boolean value. The parameters
    passed into the `TryCallWithTimeout` method are the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建了一个持续时间为三分之四秒的超时值。然后调用`TryCallWithTimeout`方法，该方法返回一个布尔值。传递给`TryCallWithTimeout`方法的参数如下：
- en: '`SleepyMethod`: The name of the method to be executed'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SleepyMethod`：要执行的方法的名称'
- en: '`timoutTimeSpan`: The duration the method is to run for before it times out'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timoutTimeSpan`：方法运行前要运行的时间长度，直到超时'
- en: '`result`: Contains the result of `CancellationToken`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`：包含`CancellationToken`的结果'
- en: Once the call has been made, the name of the called method and its call result
    are sent to the console. In this code, we are not writing the result to the console
    window, but you can modify the code to do so.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用完成，被调用方法的名称及其调用结果将被发送到控制台。在此代码中，我们没有将结果写入控制台窗口，但您可以修改代码来实现这一点。
- en: 'At the top of the class, update the code as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在班级顶部，更新代码如下：
- en: '[PRE47]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code calls our method and is an example of the cancellation of
    a synchronous operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码调用我们的方法，是取消同步操作的一个示例。
- en: 'Run the preceding code and the result should look something like the following:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码，结果应该类似于以下内容：
- en: '![Figure 14.2 – Console output for our program showing that the thread was
    canceled'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 – 程序的输出控制台，显示线程被取消]'
- en: '](img/B16617_Figure_14.2.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 – 显示线程被取消的程序的输出控制台](img/B16617_Figure_14.2.jpg)'
- en: Figure 14.2 – Console output for our program showing that the thread was canceled
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 程序的输出控制台，显示线程被取消
- en: This concludes the topic of canceling and destroying threads. Let’s now look
    at scheduling threads.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了取消和销毁线程的主题。现在让我们看看线程的调度。
- en: Scheduling threads
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程调度
- en: The `Thread.Start` method schedules a `Thread` to start. You can overload this
    method with different parameters. We will look at two examples in this section.
    The first example will call the `Thread.Start()` method without passing any parameters,
    and the second will call `Thread.Start(object)`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Start`方法安排一个`Thread`开始执行。你可以通过不同的参数重载这个方法。在本节中，我们将查看两个示例。第一个示例将调用不带任何参数的`Thread.Start()`方法，第二个示例将调用`Thread.Start(object)`。'
- en: 'We will now write the code as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将按照以下方式编写代码：
- en: 'Add a class called `Job` as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Job`的类，如下所示：
- en: '[PRE48]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This class provides two methods that will be used in our `Thread` scheduling
    examples. The `Execute` method is used with the parameterless `Thread.Start` method,
    and the `PrintMessage` function is used with the `Thread.Start` method that takes
    parameters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了两个方法，这些方法将在我们的`Thread`调度示例中使用。`Execute`方法与无参数的`Thread.Start`方法一起使用，而`PrintMessage`函数与接受参数的`Thread.Start`方法一起使用。
- en: 'In the `Program.cs` class, add the `SheduleThreadWithoutParameters` method
    as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`类中，添加`SheduleThreadWithoutParameters`方法如下：
- en: '[PRE49]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, we create a new instance of the `Job` class. Then, we
    create a new `Thread` passing a new `ThreadStart` instance into its constructor.
    Into the `ThreadStart` constructor, we pass `object.method` that we wish to execute,
    and then we start the thread.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个新的`Job`类实例。然后，我们创建了一个新的`Thread`，通过将其构造函数中的`new ThreadStart`实例传递给构造函数。在`ThreadStart`构造函数中，我们传递`object.method`，这是我们希望执行的，然后我们启动线程。
- en: 'Add the `ScheduleThreadWithParameters` method as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ScheduleThreadWithParameters`方法如下：
- en: '[PRE50]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we created a new `Job` instance and two threads by calling
    the `ParameterizedThreadStart` class for each thread to execute a parameterized
    method on an object. We then start each of the threads.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过调用每个线程的`ParameterizedThreadStart`类来创建一个新的`Job`实例和两个线程，以便在每个线程上执行一个参数化方法。然后我们启动每个线程。
- en: 'Add a call to each of the methods at the top of the class and then run the
    preceding code. Your console should look like the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部添加对每个方法的调用，然后运行前面的代码。你的控制台应该看起来像以下这样：
- en: '![14.3 – Our parameterized thread output'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![14.3 – 我们的参数化线程输出'
- en: '](img/B16617_Figure_14.3.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![B16617_Figure_14.3.jpg](img/B16617_Figure_14.3.jpg)'
- en: 14.3 – Our parameterized thread output
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 14.3 – 我们的参数化线程输出
- en: Thread synchronization and locking
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步和锁定
- en: When using multiple threads in an application, you have to consider thread synchronization
    and locking. If you don’t, you can end up with race conditions and deadlocks.
    There are several ways to synchronize threads. You can use interlocked methods
    and synchronization objects, such as `Monitor`, `Semaphore`, and `ManualResetEvent`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中使用多个线程时，你必须考虑线程同步和锁定。如果不这样做，你可能会遇到竞态条件和死锁。有几种同步线程的方法。你可以使用互锁方法和同步对象，如`Monitor`、`Semaphore`和`ManualResetEvent`。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In [*Chapter 8*](B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152), *Threading
    and Concurrency*, in the *Clean Code in C#* book, we provide a detailed discussion
    on threads covering using threads, thread safety, parallel threads using semaphores,
    thread synchronization and preventing deadlocks, and race conditions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在《C#中的整洁代码》一书的[*第8章*](B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152)《线程和并发》中，我们详细讨论了线程，包括使用线程、线程安全、使用信号量进行并行线程、线程同步和防止死锁，以及竞态条件。
- en: 'To synchronize your code, you can use a lock object as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同步你的代码，你可以使用一个锁对象，如下所示：
- en: '[PRE51]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When the locked code is entered, all of the other threads are barred from accessing
    the locked code. The only downside to this is that you can end up with a deadlock.
    This can be overcome by using a mutex as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入被锁定的代码时，其他所有线程都被禁止访问被锁定的代码。这种方法的唯一缺点是可能会导致死锁。可以通过使用互斥锁来克服这个问题，如下所示：
- en: '[PRE62]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The preceding code declares a `Mutex` class-level variable. The code that needs
    protecting is then wrapped in a `try/catch` block. The current thread is blocked
    by the `WaitOne()` method until the wait handle receives a signal. `True` is then
    returned from the `WaitOne()` method upon a `Mutex` being signaled. The `Mutex`
    is then owned by the calling thread that can access protected resources. Once
    the protected resources are finished, the `Mutex` is released by calling `ReleaseMutext()`.
    Always call the `ReleaseMutext()` method in the final block to prevent resources
    from remaining locked if an exception is encountered.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码声明了一个 `Mutex` 类级变量。需要保护的代码随后被包裹在 `try/catch` 块中。当前线程通过 `WaitOne()` 方法被阻塞，直到等待句柄收到信号。当
    `Mutex` 被信号时，`WaitOne()` 方法返回 `True`。然后，`Mutex` 由调用线程拥有，可以访问受保护的资源。一旦受保护的资源完成，通过调用
    `ReleaseMutex()` 释放 `Mutex`。始终在最终块中调用 `ReleaseMutex()` 方法，以防止在遇到异常时资源保持锁定。
- en: 'Race conditions happen when the same resource is accessed by multiple threads
    that produce different outcomes based on their timings. A race condition can be
    avoided by using code such as the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程访问同一资源并基于它们的时序产生不同结果时，会发生竞态条件。可以通过使用如下代码来避免竞态条件：
- en: '[PRE78]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `Task` runs `Method1()` and then continues with `Method2()`. We then `Wait()`
    for the `Task` to complete its execution of `Method1()` and `Method2()` before
    continuing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 在运行 `Method1()` 后继续执行 `Method2()`。然后我们使用 `Wait()` 等待 `Task` 完成 `Method1()`
    和 `Method2()` 的执行，再继续。'
- en: That concludes our look at multi-threaded programming. As you can see, there
    is not much to scheduling threads. Let’s summarize what we have learned in this
    chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对多线程编程的探讨。正如你所见，线程调度并没有太多内容。让我们总结一下本章我们学到了什么。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have come to an understanding of threads and the thread
    life cycle. We built some sample code that shows how to create threads with and
    without parameters. We also looked at running threads in the foreground and background.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了线程和线程生命周期。我们构建了一些示例代码，展示了如何带参数和不带参数创建线程。我们还探讨了在前台和后台运行线程。
- en: Next, we looked at pausing and interrupting threads. Then, we moved on to destroying
    and canceling threads. You no longer use `Thread.Abort` in your code. `Thread.Abort`
    has been responsible for applications crashing at runtime. Instead, you use cancellation
    tokens. Canceling threads also destroys them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了暂停和中断线程。然后，我们转向了销毁和取消线程。你不再在代码中使用 `Thread.Abort`。`Thread.Abort` 导致应用程序在运行时崩溃。相反，你使用取消令牌。取消线程也会销毁它们。
- en: We looked at scheduling threads with and without parameters. In the next chapter,
    we will be looking at parallel programming.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了带参数和不带参数的线程调度。在下一章中，我们将探讨并行编程。
- en: Finally, we looked at thread synchronization and locking using lock objects
    and mutexes and learned how to avoid deadlocks and race conditions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用锁对象和互斥锁进行线程同步和锁定，并学习了如何避免死锁和竞态条件。
- en: It is now time to answer some questions to see how well you have retained the
    knowledge in this chapter. Once you have completed the questions, the *Further
    reading* section provides some external sources to further your knowledge on threads
    and multi-threaded programming.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回答一些问题，以检验你对本章知识的掌握程度。一旦你完成了这些问题，*进一步阅读*部分提供了一些外部资源，以进一步扩展你对线程和多线程编程的知识。
- en: Questions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What states can a thread be in?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程可以处于哪些状态？
- en: Which part of the `Thread.Abort` API do you use to terminate a thread?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在 `Thread.Abort` API 的哪个部分使用来终止线程？
- en: Which two locations can a thread be executed in?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程可以在哪两个位置执行？
- en: What is the correct way to terminate a thread?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确终止线程的方法是什么？
- en: What method is used to schedule a thread?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哪种方法来调度线程？
- en: Further reading
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Managing and implementing multi-threading: [https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process](https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和实现多线程：[https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process](https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process)
- en: )
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Pausing and interrupting threads: [https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads](https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停和中断线程：[https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads](https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads)
- en: )
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'How to terminate a thread in C#: [https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/](https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C#中终止线程：[https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/](https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/)
- en: )
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'How to destroy threads in C#: [https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash](https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C#中销毁线程：[https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash](https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash)
- en: 'How to schedule threads in C#: [https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20](https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C#中安排线程的执行：[https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20](https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20)
- en: 'Understanding threads and the threading process: [https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process](https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程和线程过程：[https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process](https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process)
- en: )
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'How to pause code execution in C#: [https://csharpsage.com/c-delay/](https://csharpsage.com/c-delay/
    )'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C#中暂停代码执行：[https://csharpsage.com/c-delay/](https://csharpsage.com/c-delay/)
- en: 'Pausing and interrupting threads: [https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads](https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停和中断线程：[https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads](https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads)
