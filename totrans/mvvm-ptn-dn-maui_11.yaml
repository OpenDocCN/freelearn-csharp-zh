- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating MVVM-Friendly Controls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MVVM友好的控件
- en: Up to this point, we’ve navigated through a wide spectrum of topics in MVVM
    and .NET MAUI – from the fundamental design pattern to data binding, navigation,
    and even working with remote data. Now, let’s dig into another important topic
    – **custom controls**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经浏览了MVVM和.NET MAUI的广泛主题——从基本设计模式到数据绑定、导航，甚至处理远程数据。现在，让我们深入探讨另一个重要主题——**自定义控件**。
- en: Sometimes, the built-in controls might fall short in catering to specific user
    interface requirements or unique design elements. As a consequence, you’ll need
    to create your own by combining individual UI elements into a single, more effective
    unit. Making these elements MVVM-friendly and reusable throughout your app is
    our goal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，内置控件可能无法满足特定的用户界面要求或独特的设计元素。因此，你需要通过将单个UI元素组合成一个更有效的单元来创建自己的控件。使这些元素在应用程序中成为MVVM友好和可重复使用的是我们的目标。
- en: 'In this chapter, we’ll focus on the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下内容：
- en: Building a custom control with bindable properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可绑定属性构建自定义控件
- en: Enabling interactions on custom controls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义控件上启用交互
- en: Working with control templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与控件模板一起工作
- en: By the end of this chapter, you’ll know how to make custom controls that not
    only look good but are also easy to manage in an MVVM setup. Ready to dive in?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何创建既美观又易于在MVVM设置中管理的自定义控件。准备好深入研究了？
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We’ll continue to enhance the *Recipes!* app by diving into custom controls
    and control templates, all designed with an MVVM architecture in mind. To follow
    along with the code, make sure to visit the GitHub repository at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11).
    The `Start` folder has the initial code set up to begin this chapter, while the
    `Finish` folder contains the completed code for your reference.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过深入研究自定义控件和控制模板来增强*食谱*应用，所有这些都是在考虑MVVM架构的情况下设计的。为了跟随代码，请确保访问GitHub仓库[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11)。`Start`文件夹包含开始本章所需的初始代码设置，而`Finish`文件夹包含供您参考的完成代码。
- en: Building a custom control with bindable properties
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可绑定属性构建自定义控件
- en: Building a feature-rich application often requires more than just the standard
    set of UI controls. When you have a combination of controls appearing together
    across multiple parts of your application – such as an input field with a list
    of validation errors or a button that’s always used with an activity indicator
    – it makes sense to package these into custom controls. These custom, reusable
    elements not only make the code base more maintainable but also align perfectly
    with MVVM architecture when made bindable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 构建功能丰富的应用程序通常需要不仅仅是标准的UI控件集。当你有多个部分中一起出现的控件组合——例如，一个带有验证错误列表的输入字段或总是与活动指示器一起使用的按钮——将这些组合成自定义控件是有意义的。这些自定义的可重复使用元素不仅使代码库更易于维护，而且当它们可绑定时，与MVVM架构完美契合。
- en: The focus of this section is not only to create custom controls but also to
    make them “bindable,” seamlessly integrating them into our MVVM architecture.
    By crafting controls that are bindable, you enable straightforward communication
    with your ViewModel. This is key to ensuring that the UI is always up to date
    with an application’s data and logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的重点不仅是创建自定义控件，还要使它们“可绑定”，无缝地集成到我们的MVVM架构中。通过制作可绑定的控件，你可以实现与ViewModel的简单通信。这是确保UI始终与应用程序的数据和逻辑保持同步的关键。
- en: So, how do we achieve this?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现这一点？
- en: Over the next few pages, we’ll see how to combine existing controls into a custom,
    bindable control. We’ll also discuss how to add custom properties and behavior
    to controls, ensuring they can effortlessly fit into an MVVM-based application
    architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将看到如何将现有控件组合成自定义的可绑定控件。我们还将讨论如何向控件添加自定义属性和行为，确保它们可以无缝地融入基于MVVM的应用程序架构。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While we will be creating a custom control in XAML throughout this chapter,
    it’s important to note that everything we do can also be done entirely in code
    if preferred.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本章的整个过程中使用XAML创建自定义控件，但重要的是要注意，我们所做的所有事情也可以完全通过代码完成，如果需要的话。
- en: As we dive into creating custom controls with data binding capabilities, it’s
    important to recall the concept of a binding target, which we covered in [*Chapter
    3*](B20941_03.xhtml#_idTextAnchor051), *Data Binding Building Blocks in .NET MAUI*.
    In .NET MAUI, a binding target is typically a `BindableProperty` on a UI element
    or another `BindableObject`. To make our custom controls serve as effective binding
    targets, they need to inherit from `BindableObject`. Additionally, any properties
    that we intend to bind must be of type `BindableProperty`. This ensures that our
    custom controls will integrate seamlessly into the MVVM data-binding architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入创建具有数据绑定功能的自定义控件时，重要的是要回忆起我们在 [*第 3 章*](B20941_03.xhtml#_idTextAnchor051)，*在
    .NET MAUI 中的数据绑定构建块* 中讨论的绑定目标的概念。在 .NET MAUI 中，绑定目标通常是 UI 元素上的 `BindableProperty`
    或另一个 `BindableObject`。为了使我们的自定义控件作为有效的绑定目标，它们需要从 `BindableObject` 继承。此外，我们打算绑定的任何属性都必须是
    `BindableProperty` 类型。这确保了我们的自定义控件将无缝集成到 MVVM 数据绑定架构中。
- en: Implementing FavoriteControl
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 FavoriteControl
- en: In our *Recipes!* app, displaying whether a recipe is marked as a favorite or
    not is a recurring theme. The “favorite” icon appears across various parts of
    our app. Each time this icon appears, it behaves the same way – changing colors
    when the recipe is marked as a favorite. Instead of repeating the same code everywhere,
    we can encapsulate this pattern into a reusable `FavoriteControl`. By doing so,
    we make our code more maintainable and pave the way for future improvements –
    such as additional gestures or animations – without needing to alter multiple
    sections of the code base.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *Recipes!* 应用中，显示一个菜谱是否被标记为收藏是一个常见的主题。该“收藏”图标出现在我们应用的各个部分。每次这个图标出现时，它的行为都是相同的——当菜谱被标记为收藏时改变颜色。为了避免在各个地方重复相同的代码，我们可以将这种模式封装成一个可重用的
    `FavoriteControl`。通过这样做，我们使代码更易于维护，并为未来的改进——例如添加更多手势或动画——铺平了道路，而无需修改代码库的多个部分。
- en: 'Let’s go ahead and look at the steps needed to create our `FavoriteControl`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看创建我们的 `FavoriteControl` 所需的步骤：
- en: In the `Controls` folder in the `Recipes.Mobile` project and select **Add**
    | **New Item…**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recipes.Mobile` 项目的 `Controls` 文件夹中，选择 **添加** | **新建项…**。
- en: Select `FavoriteControl.xaml` as the name of the new item. Click **Add**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新项目的名称选为 `FavoriteControl.xaml`。点击 **添加**。
- en: '![Figure 11.1: Select ContentView from the dialog](img/B20941_11_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：从对话框中选择 ContentView](img/B20941_11_01.jpg)'
- en: 'Figure 11.1: Select ContentView from the dialog'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：从对话框中选择 ContentView
- en: 'By following these steps, two new files will be created – `FavoriteControl.xaml`
    and its code-behind file, `FavoriteControl.xaml.cs`, as shown in *Figure 11**.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤，将创建两个新的文件——`FavoriteControl.xaml` 和其代码后文件 `FavoriteControl.xaml.cs`，如图
    *11.2* 所示：
- en: '![Figure 11.2: Files making up FavoriteControl](img/B20941_11_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：组成 FavoriteControl 的文件](img/B20941_11_02.jpg)'
- en: 'Figure 11.2: Files making up FavoriteControl'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：组成 FavoriteControl 的文件
- en: 'The generated `FavoriteControl` inherits the `ContentView` class, which itself
    is a descendant of `BindableObject`. This allows `FavoriteControl` to define `BindableProperties`,
    which is essential to make the control bindable. Speaking of which, `FavoriteControl`
    should contain a `BindableProperty` called `IsFavoriteProperty` and an `IsFavorite`
    property of type `bool`. The following code snippet shows what this looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `FavoriteControl` 继承自 `ContentView` 类，而 `ContentView` 本身是 `BindableObject`
    的子类。这使得 `FavoriteControl` 能够定义 `BindableProperties`，这对于使控件可绑定至关重要。说到这里，`FavoriteControl`
    应该包含一个名为 `IsFavoriteProperty` 的 `BindableProperty` 和一个类型为 `bool` 的 `IsFavorite`
    属性。以下代码片段显示了它的样子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining a `BindableProperty` can be confusing or unclear at first. If this
    concept is still vague, [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051), *Data
    Binding Building Blocks in .NET MAUI*, covers it in more depth.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `BindableProperty` 可能一开始会让人感到困惑或不清楚。如果这个概念仍然模糊，请参阅 [*第 3 章*](B20941_03.xhtml#_idTextAnchor051)，*在
    .NET MAUI 中的数据绑定构建块*，它对此进行了更深入的介绍。
- en: With this in place, we can dive into XAML and start working on the visual layer
    of this `FavoriteControl`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以深入 XAML 并开始工作于这个 `FavoriteControl` 的视觉层。
- en: Data binding in a custom control
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义控件中的数据绑定
- en: When building a custom control, it’s recommended to design it so that it doesn’t
    depend on its `BindingContext`, which it inherits from its parent page or control.
    Instead of depending on its `BindingContext`, the custom control should be self-contained
    and interact directly with its own bindable properties. This approach makes your
    control more modular and reusable, freeing it from dependencies on any specific
    ViewModel or data source. Element binding or relative binding is instrumental
    in achieving this independence. However, it’s worth noting that using data binding
    within the control is not mandatory. Handling all the logic and value assignments
    programmatically in the control’s code-behind is also a solid approach. This mostly
    depends on personal preference.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自定义控件时，建议设计它，使其不依赖于其`BindingContext`，这是从其父页面或控件继承而来的。自定义控件不应依赖于其`BindingContext`，而应该是自包含的，并直接与其自己的可绑定属性交互。这种方法使您的控件更加模块化和可重用，使其摆脱对任何特定ViewModel或数据源的依赖。元素绑定或相对绑定是实现这种独立性的关键。然而，值得注意的是，在控件中使用数据绑定不是强制性的。在控件的后台代码中程序化处理所有逻辑和值赋值也是一个可靠的方法。这主要取决于个人偏好。
- en: 'Let’s have a look at how to define the control’s appearance and see how we
    can efficiently bind to its `IsFavorite` property:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义控件的外观，以及我们如何有效地绑定到其`IsFavorite`属性：
- en: 'Open the `FavoriteControl.xaml` file, and add the following `local` and `toolkit`
    XML namespaces and the `x:Name` attribute:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FavoriteControl.xaml`文件，并添加以下`local`和`toolkit` XML命名空间以及`x:Name`属性：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <ContentView.Resources>
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ContentView.Resources>
- en: <toolkit:BoolToObjectConverter
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <toolkit:BoolToObjectConverter
- en: x:Key="isFavoriteToColorConverter"
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x:Key="isFavoriteToColorConverter"
- en: x:TypeArguments="Color"
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x:TypeArguments="Color"
- en: FalseObject="#E9E9E9E9"
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FalseObject="#E9E9E9E9"
- en: TrueObject="#FF0000" />
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TrueObject="#FF0000" />
- en: </ContentView.Resources>
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </ContentView.Resources>
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we can add the `Image` control to display the `"favorite.png"` icon.
    We also want this Image control to match the dimensions specified for `FavoriteControl`.
    Here’s how to set this up:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加`Image`控件来显示`"favorite.png"`图标。我们还想让这个Image控件与为`FavoriteControl`指定的尺寸相匹配。以下是设置此控件的步骤：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, to control the tint of the `Image`, depending on the favorite status,
    we use `IconTintColorBehavior`, as shown here:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了根据收藏状态控制`Image`的色调，我们使用`IconTintColorBehavior`，如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This setup closely mirrors what we used on `RecipesOverviewPage` and `RecipeDetailPage`.
    The key difference lies in the source of the binding. Here, we bind directly to
    the `IsFavorite` property we just created. We achieve this using element binding
    (via `x:Reference root`), which refers back to `FavoriteControl` itself. This
    is necessary because relative binding isn’t suitable here. Behaviors, unlike other
    UI elements, are not part of the visual tree, so they can’t perform relative binding
    or find ancestors in the same way that other elements can.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个设置与我们在`RecipesOverviewPage`和`RecipeDetailPage`上使用的设置非常相似。关键区别在于绑定的来源。在这里，我们直接绑定到我们刚刚创建的`IsFavorite`属性。我们通过元素绑定（通过`x:Reference
    root`）实现这一点，它引用回`FavoriteControl`本身。这是必要的，因为相对绑定在这里不适用。与其它UI元素不同，行为不是视觉树的一部分，因此它们不能像其他元素那样执行相对绑定或查找祖先。
- en: 'With these steps completed, we’ve successfully created our first custom control,
    `FavoriteControl`. Now, we can go ahead and replace the existing image and `IconTintColorBehavior`
    setup, used to indicate favorite recipes on both `RecipesOverviewPage` and `RecipeDetailPage`,
    with this custom control. Let’s do this in the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们已经成功创建了第一个自定义控件`FavoriteControl`。现在，我们可以继续用这个自定义控件替换现有的图像和`IconTintColorBehavior`设置，这些设置用于在`RecipesOverviewPage`和`RecipeDetailPage`上指示收藏的菜谱。让我们按以下步骤进行：
- en: 'Go to `RecipesOverviewPage` and add an `xml` namespace, referring to the namespace
    containing the newly created `FavoriteControl`, as shown here:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`RecipesOverviewPage`并添加一个`xml`命名空间，引用包含新创建的`FavoriteControl`的命名空间，如下所示：
- en: The XML namespace (`xmlns:toolkit`) pointing to the .NET MAUI Community Toolkit
    can be removed, as we won’t be using any of its functionalities anymore on this
    page. This is now encapsulated in our custom control.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向.NET MAUI社区工具包的XML命名空间(`xmlns:toolkit`)可以删除，因为我们不会在这个页面上再使用其任何功能。现在，这些功能都封装在我们的自定义控件中。
- en: Remove the `Image` UI element along with its associated behavior, which until
    now served as the favorite indicator for a recipe.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Image` UI元素及其相关行为，这些行为直到现在一直作为菜谱的收藏指示器。
- en: 'In place of the deleted `Image`, insert the `FavoriteControl` we just created.
    Here’s how to do it:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们刚刚创建的`FavoriteControl`替换删除的`Image`。以下是这样做的方法：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The layout properties such as margin, size, visibility, and alignment options
    are unchanged from the removed `Image`. Also, observe how easily we can bind the
    `IsFavorite` property of our `FavoriteControl` to the corresponding `IsFavorite`
    property on the page’s `BindingContext`.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布局属性，如边距、大小、可见性和对齐选项，与删除的`Image`保持不变。同时，观察我们如何轻松地将`FavoriteControl`的`IsFavorite`属性绑定到页面`BindingContext`上的相应`IsFavorite`属性。
- en: 'For `RecipeDetailPage`, we can follow a similar approach. Include an XML namespace
    that points to `Recipes.Mobile.Controls` and swap out the `Image`, which previously
    signaled whether the recipe was a favorite, with the newly created `FavoriteControl`.
    This is what the result looks like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RecipeDetailPage`，我们可以采取类似的方法。包含一个指向`Recipes.Mobile.Controls`的XML命名空间，并用新创建的`FavoriteControl`替换之前表示是否为收藏的`Image`。这就是结果的样子：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**By consolidating the favorite indicator into a single, reusable `FavoriteControl`,
    we’ve achieved multiple objectives. Firstly, we’ve centralized the code, making
    it easier to manage and update. Secondly, this control can now be used consistently
    across different pages of the app, ensuring a uniform user experience. Finally,
    by doing so, we’ve also enhanced the readability and maintainability of our code
    base. *Figure 11**.3* shows `FavoriteControl` on different pages of the app. Although
    nothing has visibly changed for the user, the code and its maintainability profit
    immensely from this reusable control.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过将收藏指示器合并成一个单一的可重用`FavoriteControl`，我们实现了多个目标。首先，我们集中了代码，使其更容易管理和更新。其次，这个控件现在可以一致地应用于应用的不同页面，确保了统一的用户体验。最后，通过这样做，我们还提高了代码库的可读性和可维护性**。图11.3*展示了应用不同页面上的`FavoriteControl`。尽管对用户来说没有明显的变化，但代码及其可维护性从这种可重用控件中获得了巨大的收益。'
- en: '![Figure 11.3: FavoriteControl on different pages](img/B20941_11_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：不同页面上的FavoriteControl](img/B20941_11_03.jpg)'
- en: 'Figure 11.3: FavoriteControl on different pages'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：不同页面上的FavoriteControl
- en: Let’s see how we can improve this control a bit more, making the app more attractive
    to the user.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何进一步改进这个控件，使应用对用户更具吸引力。
- en: Animating state changes
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态变化动画
- en: As a quick example of reacting to state changes, let’s explore how to add a
    subtle animation to `FavoriteControl` whenever the `IsFavorite` property changes.
    We’ll use the `propertyChanged` delegate method of `IsFavoriteProperty` to trigger
    this animation. Let’s dive in!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对状态变化做出快速反应的一个例子，让我们来看看如何在`IsFavorite`属性变化时给`FavoriteControl`添加一个微妙的动画。我们将使用`IsFavoriteProperty`的`propertyChanged`委托方法来触发这个动画。让我们深入探讨吧！
- en: 'Modify `IsFavoriteProperty` by adding a `propertyChanged` delegate, like this:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个`propertyChanged`委托，修改`IsFavoriteProperty`，如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this modification, the static `OnIsFavoriteChanged` method will be invoked
    each time the value of the `IsFavorite` property changes. The `BindableObject`
    that gets passed in is the instance on which `BindableProperty` is set. In this
    case, it will be an instance of `FavoriteControl`. The `oldValue` and `newValue`
    parameters are self-explanatory, as they provide the previous and new values of
    the property, respectively.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过这次修改，每当`IsFavorite`属性的值发生变化时，静态的`OnIsFavoriteChanged`方法将被调用。传入的`BindableObject`是设置`BindableProperty`的实例。在这种情况下，它将是一个`FavoriteControl`的实例。`oldValue`和`newValue`参数是自解释的，因为它们分别提供了属性的旧值和新值。
- en: 'Next, let’s add the animation we want to play when the control’s state changes.
    Here’s how we can add it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加当控件状态变化时要播放的动画。以下是添加动画的方法：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `AnimateChange` method will scale the `Image` holding the icon to 1.5 times
    its size over a period of 100 milliseconds. Afterward, it will be scaled down
    again to its original size over the same amount of time.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AnimateChange`方法将在100毫秒内将持有图标的`Image`缩放到1.5倍大小。之后，它将在相同的时间内再次缩放到原始大小。'
- en: 'Finally, we need to call this method from the static `OnIsFavoriteChanged`
    method. The following code block shows how this can be done:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要从静态的`OnIsFavoriteChanged`方法中调用这个方法。以下代码块展示了如何实现这一点：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The bindable parameter can safely be cast to `FavoriteControl`, allowing us
    to call the `AnimateChange` method, triggering the animation.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可绑定参数可以安全地转换为`FavoriteControl`，这样我们就可以调用`AnimateChange`方法，触发动画。
- en: Run the app to see the changes in action! You’ll observe a subtle animation
    on the `RecipeDetailPage` each time a recipe is toggled as a favorite. Introducing
    this custom control brings the convenience of unified animations across the application.
    Any modification made to the animation within the custom control gets automatically
    reflected everywhere it’s used. Without such a control, we’d need to manually
    update the animation at each individual instance throughout the app. Overlooking
    even a single instance would lead to inconsistent behavior. Thus, custom controls
    ensure both consistency and streamlined maintainability.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序以查看实际变化！每次将食谱切换为收藏时，你会在`RecipeDetailPage`上观察到细微的动画。引入这个自定义控件带来了应用程序中统一动画的便利。对自定义控件内动画的任何修改都会自动反映到其使用的每个地方。如果没有这样的控件，我们就需要手动更新应用程序中每个实例的动画。忽略任何一个实例都可能导致行为不一致。因此，自定义控件确保了一致性和维护的简化。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This example underscores an important point – even when you’re fully committed
    to using the MVVM pattern, there will be scenarios where writing code in the code-behind
    is not just acceptable but necessary. This is especially true when creating custom
    controls, where using code-behind is not only inevitable but also perfectly appropriate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子强调了重要的一点——即使你完全致力于使用MVVM模式，也仍然会有一些情况下在代码后编写代码不仅是可以接受的，而且是必要的。这在创建自定义控件时尤其如此，使用代码后不仅不可避免，而且非常合适。
- en: Next, let’s explore how to add interactions to a custom control by leveraging
    commanding, thereby further aligning it with MVVM concepts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨如何通过利用命令来添加自定义控件的交互，从而进一步与MVVM概念保持一致。
- en: Enabling interactions on custom controls
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在自定义控件上启用交互
- en: In real-world applications, controls often serve dual roles – they both display
    data and allow users to interact with it. In this section, we’ll further enhance
    our `FavoriteControl` to not only support user interactions through `IsFavoriteChangedCommand`
    but also to facilitate two-way data binding. These features will make the control
    more interactive and further align it with MVVM concepts. We want to allow users
    to tap the `Image` on the `FavoriteControl`. When `FavoriteControl`’s `IsEnabled`
    property is set to `true`, the `IsFavorite` property will be updated and `IsFavoriteChangedCommand`
    will be executed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，控件通常扮演双重角色——它们既显示数据，也允许用户与之交互。在本节中，我们将进一步增强我们的`FavoriteControl`，使其不仅支持通过`IsFavoriteChangedCommand`进行用户交互，而且还要便于双向数据绑定。这些特性将使控件更具交互性，并进一步与MVVM概念保持一致。我们希望允许用户点击`FavoriteControl`上的`Image`。当`FavoriteControl`的`IsEnabled`属性设置为`true`时，`IsFavorite`属性将被更新，并且`IsFavoriteChangedCommand`将被执行。
- en: Let’s take a look at the first part of this functionality – updating the `IsFavorite`
    property when a user taps on the image and making sure the value bound to this
    property gets updated as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个功能的第一个部分——当用户点击图片时更新`IsFavorite`属性，并确保绑定到这个属性的值也得到更新。
- en: User actions and reflecting state
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户操作和状态反映
- en: 'To start with, let’s add the ability for users to toggle their favorite state
    by tapping on the control. This user action will then update the `IsFavorite`
    property of the control, which, in turn, will reflect back to update the bound
    property. The following steps show how to achieve this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加用户通过点击控件来切换收藏状态的能力。然后，这个用户操作将更新控件的`IsFavorite`属性，反过来，它将反映回更新绑定的属性。以下步骤展示了如何实现这一点：
- en: 'Add a `GestureRecognizer` to the `FavoriteControl`’s `ContentView`, as shown
    here:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，将`GestureRecognizer`添加到`FavoriteControl`的`ContentView`中：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A `GestureRecognizer` allows you to handle user interaction events, such as
    tapping, pinching, and swiping, on a UI element. By adding a `TapGestureRecognizer`
    to the `ContentView`, we effectively instruct the application to listen for a
    tap event on this control.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GestureRecognizer`允许你在UI元素上处理用户交互事件，例如点击、捏合和滑动。通过向`ContentView`添加`TapGestureRecognizer`，我们有效地指示应用程序监听此控件上的点击事件。'
- en: 'Here’s the `TapGestureRecognizer_Tapped` event handler in the code-behind:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是代码后部的`TapGestureRecognizer_Tapped`事件处理程序：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method will be triggered when a user taps on the `FavoriteControl`.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户点击`FavoriteControl`时，将触发此方法。
- en: 'Now, let’s implement the logic needed to update the `IsFavorite` property in
    the `TapGestureRecognizer_Tapped` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`TapGestureRecognizer_Tapped`方法中实现更新`IsFavorite`属性的逻辑：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note how we first check the `IsEnabled` property before updating the `IsFavorite`.
    It’s crucial for custom controls to behave consistently with developers’ expectations.
    In this case, setting the `IsEnabled` property of a `VisualElement` to `false`
    should disable the control. As a result, we check the `IsEnabled` property before
    toggling the value of `IsFavorite`.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们首先检查 `IsEnabled` 属性，然后再更新 `IsFavorite`。对于自定义控件来说，与开发者的期望保持一致的行为至关重要。在这种情况下，将
    `VisualElement` 的 `IsEnabled` 属性设置为 `false` 应该会禁用控件。因此，我们在切换 `IsFavorite` 的值之前会检查
    `IsEnabled` 属性。
- en: 'If we run the app and navigate to `RecipeDetailPage` at this point, tapping
    `FavoriteControl` should update its state. The animation we defined earlier also
    plays as a reaction to the `IsFavorite` property being updated. However, the state
    change is not reflected on the ViewModel. You might wonder why this is the case.
    It’s because `IsFavoriteProperty` has a default binding mode of `OneWay`. That’s
    why the updated value doesn’t flow from the control back to the ViewModel. This
    can easily be adjusted – change the `IsFavoriteProperty`’s default binding mode
    to `TwoWay`, or update the binding statement on the `RecipeDetailPage` and explicitly
    set it to `TwoWay`. Here’s what the first approach – updating the default binding
    mode – looks like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序并导航到 `RecipeDetailPage`，触摸 `FavoriteControl` 应该会更新其状态。我们之前定义的动画也会作为对
    `IsFavorite` 属性更新的反应播放。然而，状态变化并没有反映在 ViewModel 上。你可能想知道为什么会出现这种情况。这是因为 `IsFavoriteProperty`
    具有默认的绑定模式 `OneWay`。这就是为什么更新后的值不会从控件流向 ViewModel。这很容易调整——将 `IsFavoriteProperty`
    的默认绑定模式更改为 `TwoWay`，或者更新 `RecipeDetailPage` 上的绑定语句并显式将其设置为 `TwoWay`。以下是第一种方法——更新默认绑定模式——的示例：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, we can leave the default binding mode to `OneWay` and update
    the binding statement on `RecipeDetailPage`, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以保留默认的绑定模式为 `OneWay`，并在 `RecipeDetailPage` 上更新绑定语句，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Either way, the `IsFavorite` property on the `FavoriteControl` will now reflect
    its state on the ViewModel. How can we verify this? By adding breakpoints in code
    of course, but also by simply tapping the control – note how the visibility of
    the `IsFavorite` property on the ViewModel.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，`FavoriteControl` 上的 `IsFavorite` 属性现在将反映其在 ViewModel 中的状态。我们如何验证这一点呢？当然是通过在代码中添加断点，但也可以通过简单地触摸控件——注意
    ViewModel 中 `IsFavorite` 属性的可见性。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When defining a bindable property, it’s crucial to select the `defaultBindingMode`
    that aligns best with the control’s primary intended behavior or the binding mode
    that will be most commonly used. In the rare instances where different behavior
    is required, the developer can always override the default by specifying a different
    binding mode in the binding statement.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义可绑定属性时，选择与控件的主要预期行为或最常用的绑定模式最一致的 `defaultBindingMode` 是至关重要的。在需要不同行为的不常见情况下，开发者可以通过在绑定语句中指定不同的绑定模式来覆盖默认设置。
- en: '`IsFavorite` property won’t result in the underlying model being updated. Let’s
    delve into how we can incorporate commands into our `FavoriteControl` to make
    it even more versatile.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFavorite` 属性不会导致底层模型更新。让我们深入了解如何将命令集成到我们的 `FavoriteControl` 中，使其更加灵活。'
- en: Adding command-based interactions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加基于命令的交互
- en: Let’s further enhance our `FavoriteControl` by exposing a command property –
    `ToggledCommand`. This command will be invoked whenever the `IsFavorite` property
    is toggled via a tap gesture on the control. To make this even more robust, the
    command will send the updated `IsFavorite` bool value as a parameter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步增强我们的 `FavoriteControl`，通过公开一个命令属性——`ToggledCommand`。当通过在控件上轻触手势切换 `IsFavorite`
    属性时，将调用此命令。为了使其更加健壮，该命令将发送更新的 `IsFavorite` 布尔值作为参数。
- en: 'Adding command-based interactions to custom controls is pretty straightforward,
    as the following steps show:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于命令的交互添加到自定义控件中非常简单，以下步骤展示了如何操作：
- en: 'It all starts by adding a `BindableProperty` and a property of type `ICommand`.
    This code block shows how to add the `ToggledCommand` property and its corresponding
    `BindableProperty` to our `FavoriteControl`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有操作都从添加一个 `BindableProperty` 和一个类型为 `ICommand` 的属性开始。此代码块展示了如何将 `ToggledCommand`
    属性及其对应的 `BindableProperty` 添加到我们的 `FavoriteControl` 中：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we can call the command’s `Execute` method whenever the user has tapped
    the control and, thus, has updated the `IsFavorite` property. Here’s what the
    updated `TapGestureRecognizer_Tapped` method looks like:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以在用户触摸控件并更新 `IsFavorite` 属性时调用命令的 `Execute` 方法。以下是更新后的 `TapGestureRecognizer_Tapped`
    方法：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that we’re using the null-conditional operator (`?`) to prevent a `NullReferenceException`
    in case `ToggledCommand` is null.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用空条件运算符（`?`）来防止在`ToggledCommand`为null时出现`NullReferenceException`。
- en: 'The following code block shows the `FavoriteToggledCommand` that we can add
    to the `RecipeDetailViewModel`, and which we will bind to the `ToggledCommand`
    of the `FavoriteControl`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块显示了我们可以添加到`RecipeDetailViewModel`中的`FavoriteToggledCommand`，并将其绑定到`FavoriteControl`的`ToggledCommand`：
- en: '[PRE17]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let’s add the `FavoriteToggled` method, which is called by `FavoriteToggledCommand`.
    Here’s what it looks like:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加`FavoriteToggled`方法，这个方法由`FavoriteToggledCommand`调用。下面是这个方法的示例：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ToggledCommand` of the `FavoriteControl` sends the updated `isFavorite`
    value as a parameter. We can use this parameter to decide what method to call
    on the `favoritesService`.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FavoriteControl`的`ToggledCommand`将更新的`isFavorite`值作为参数发送。我们可以使用这个参数来决定在`favoritesService`上调用哪个方法。'
- en: 'With this in place, we can also quickly refactor the existing `AddAsFavorite`
    and `RemoveAsFavorite` methods in order to avoid code duplication, as shown here:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此基础上，我们还可以快速重构现有的`AddAsFavorite`和`RemoveAsFavorite`方法，以避免代码重复，如下所示：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `UpdateIsFavorite` method is added. This method takes in the new value that
    the `IsFavorite` property should get. It assigns this value to the property and
    calls the `FavoriteToggled` method that we just introduced. From the `AddAsFavorite`
    and `RemoveAsFavorite` methods, this new `UpdateIsFavorite` method can now be
    called, passing in just a `bool` value.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加了`UpdateIsFavorite`方法。这个方法接受`IsFavorite`属性应该获取的新值。它将这个值赋给属性，并调用我们刚刚引入的`FavoriteToggled`方法。从`AddAsFavorite`和`RemoveAsFavorite`方法中，现在可以调用这个新的`UpdateIsFavorite`方法，只需传递一个`bool`值。
- en: 'The only thing that is left to do is to bind `FavoriteToggledCommand` of `RecipeDetailViewModel`
    to the `ToggledCommand` property of the `FavoriteControl` on the `RecipeDetailPage`.
    Here’s how:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是将`RecipeDetailViewModel`的`FavoriteToggledCommand`绑定到`RecipeDetailPage`上`FavoriteControl`的`ToggledCommand`属性。下面是如何做的：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we run the app now, we’ll see that not only does the `IsFavorite` property
    updates when the `FavoriteControl` is tapped but the bound `FavoriteToggledCommand`
    is also invoked, allowing for seamless interaction and data updates in our application.
    This completes the integration of a very basic command-based interaction into
    our custom control. Let’s continue and make the control better and more intuitive
    for both the users of our app and other developers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们会看到当点击`FavoriteControl`时，不仅`IsFavorite`属性会更新，而且绑定的`FavoriteToggledCommand`也会被调用，这使得我们的应用程序中的交互和数据更新更加无缝。这完成了将基于命令的基本交互集成到我们的自定义控件中。让我们继续，使控件对应用程序的用户和其他开发者来说都更好、更直观。
- en: Improving developer and user experience
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升开发者和用户体验
- en: While the previous example provided a foundational understanding of how to integrate
    command-based interactions into our custom control, it merely scratched the surface.
    Developers aiming to integrate this control across diverse use cases and the end-users
    who will interact with it both anticipate a solution that’s more polished and
    adaptable. For instance, we could enhance the user experience by providing visual
    cues that indicate the control is clickable. On the developer side, we want our
    control to be predictable; developers expect things to work in a certain way.
    Ideally, our control should adhere to the bound command’s `CanExecute` method
    and adjust its behavior accordingly. In my experience, poorly designed or inadequately
    thought-through controls have often created headaches for both myself and my colleagues.
    The goal is to make a custom control intuitive enough that it doesn’t require
    extensive explanation for straightforward tasks. Let’s see how we can bring our
    `FavoriteControl` to another level!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子提供了如何将基于命令的交互集成到我们的自定义控件中的基础理解，但它只是触及了表面。旨在将此控件集成到各种用例中的开发者和将与之交互的最终用户都期待一个更加精致和适应性强的解决方案。例如，我们可以通过提供指示控件可点击的视觉提示来增强用户体验。在开发者方面，我们希望我们的控件是可预测的；开发者期望事情以某种方式工作。理想情况下，我们的控件应该遵循绑定命令的`CanExecute`方法并根据其行为进行调整。根据我的经验，设计不佳或思考不周全的控件经常给我和我的同事带来了麻烦。目标是使自定义控件足够直观，以至于对于简单任务不需要详细的解释。让我们看看我们如何将`FavoriteControl`提升到另一个层次！
- en: 'Let’s first introduce a new property called `IsInteractive` to `FavoriteControl`.
    This property will be set to `true` when the `IsEnabled` property of the control
    is set to `true`, the `ToggleCommand` is set, and its `CanExecute` method returns
    `true`. In all other situations, the value of the `IsInteractive` property needs
    to be `false`. This property can then be checked inside the control prior to executing
    an action. Let’s go through this step by step:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先向`FavoriteControl`引入一个新的属性`IsInteractive`。当控制器的`IsEnabled`属性设置为`true`，`ToggleCommand`被设置，并且其`CanExecute`方法返回`true`时，此属性将被设置为`true`。在所有其他情况下，`IsInteractive`属性的值需要为`false`。然后可以在执行动作之前在控件内部检查此属性。让我们一步一步来：
- en: 'Add the `IsInteractive` property to `FavoriteControl`, as shown here:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IsInteractive`属性添加到`FavoriteControl`中，如下所示：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code snippet shows the `UpdateIsInteractive` method. This method
    is responsible for setting the `IsInteractive` property:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`UpdateIsInteractive`方法。此方法负责设置`IsInteractive`属性：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the `TapGestureRecognizer_Tapped` method, as shown in the next code
    block:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`TapGestureRecognizer_Tapped`方法，如下代码块所示：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By updating the code that is shown here, we only allow the `IsFavorite` property
    to be toggled when the `IsInteractive` property is set to `true`. This means the
    control is enabled, its `ToggleCommand` is set, and the `ToggleCommand`’s `CanExecute`
    method returns `true`.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过更新此处显示的代码，我们只允许在`IsInteractive`属性设置为`true`时切换`IsFavorite`属性。这意味着控件已启用，其`ToggleCommand`已设置，并且`ToggleCommand`的`CanExecute`方法返回`true`。
- en: 'Next, we need to make sure that the `UpdateIsInteractive` method is called
    when its value needs updating. That’s the case in the following three situations:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保在需要更新其值时调用`UpdateIsInteractive`方法。以下三种情况就是这种情况：
- en: When the value of the `IsEnabled` property changes
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`IsEnabled`属性的值发生变化时
- en: When the `ToggleCommand` property is updated
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`ToggleCommand`属性被更新时
- en: When the `CanExecuteChanged` event of the command is triggered
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当命令的`CanExecuteChanged`事件被触发时
- en: 'In the following steps, we’ll put everything in place so that the `UpdateIsInteractive`
    method is called in the aforementioned situations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将确保在上述情况下调用`UpdateIsInteractive`方法：
- en: 'In the `FavoriteControl` class, override the `OnPropertyChanged` method. This
    method gets called by the control’s properties in order to trigger the `PropertyChanged`
    event, just like we typically have in our ViewModels. Let’s see what we can do
    with it:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FavoriteControl`类中，重写`OnPropertyChanged`方法。此方法由控件属性调用，以触发`PropertyChanged`事件，就像我们在ViewModel中通常做的那样。让我们看看我们能用它做什么：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whenever the passed-in `propertyName` matches the `IsEnabled` property, we want
    to trigger the `UpdateIsInteractive` method. This ensures that whenever the `IsEnabled`
    property is updated, the `IsInteractive` property gets re-evaluated.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当传入的`propertyName`与`IsEnabled`属性匹配时，我们希望触发`UpdateIsInteractive`方法。这确保了每当`IsEnabled`属性被更新时，`IsInteractive`属性会重新评估。
- en: 'Next, we move on to make sure that the `IsInteractive` property gets updated
    when `ToggledCommand` is updated. Let’s start by adding a `propertyChanged` delegate
    to `ToggledCommandProperty`, as shown here:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们继续确保当`ToggledCommand`被更新时，`IsInteractive`属性也会被更新。让我们首先向`ToggledCommandProperty`添加一个`propertyChanged`委托，如下所示：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `ToggledCommandChanged` method is called when the value of the command is
    updated. This is the ideal place to call the `UpdateIsInteractive` method so that
    the `IsInteractive` property gets updated, based on the new `ToggledCommand`.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当命令的值被更新时，会调用`ToggledCommandChanged`方法。这是调用`UpdateIsInteractive`方法的理想位置，以便根据新的`ToggledCommand`更新`IsInteractive`属性。
- en: 'Finally, our `IsInteractive` property isn’t solely reliant on the `IsEnabled`
    property and the presence of the `ToggledCommand`. It also takes into account
    the `CanExecute` method of the defined command. To achieve this, we need to listen
    for changes in the command’s `CanExecute` state by subscribing to its `CanExecuteChanged`
    event. Here’s how we can update the `ToggleCommandChanged` method for that purpose:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的`IsInteractive`属性不仅依赖于`IsEnabled`属性和`ToggledCommand`的存在，还考虑了定义的命令的`CanExecute`方法。为了实现这一点，我们需要通过订阅其`CanExecuteChanged`事件来监听命令`CanExecute`状态的变化。以下是我们可以如何更新`ToggleCommandChanged`方法：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After setting the new command, we’re not just subscribing to its `CanExecuteChanged`
    event; we’re also making sure to unsubscribe from the same event on the previous
    command. This is crucial to ensure that our control only reacts to the current
    command’s `CanExecute` state. The `CanExecuteChanged` event handler merely calls
    the `UpdateIsInteractive` method, as shown here:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置新命令后，我们不仅订阅了其`CanExecuteChanged`事件；我们还确保从上一个命令的事件中取消订阅。这对于确保我们的控件只对当前命令的`CanExecute`状态做出反应至关重要。`CanExecuteChanged`事件处理程序仅调用`UpdateIsInteractive`方法，如下所示：
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In summary, the `IsInteractive` property serves as the gateway for user interactions
    with the control. Its state is determined by a combination of factors – the `IsEnabled`
    property of the control, the presence of a command, and that command’s `CanExecute`
    method. Importantly, the `IsInteractive` state is dynamically re-evaluated every
    time any of these contributing factors change.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`IsInteractive`属性是用户与控件交互的门户。其状态由多种因素决定——控件的`IsEnabled`属性、命令的存在以及该命令的`CanExecute`方法。重要的是，每当这些影响因素中的任何一个发生变化时，`IsInteractive`状态都会动态重新评估。
- en: 'Let’s see this in action! For demo purposes, let’s add a maximum number of
    times the favorite state of a recipe can be toggled via `FavoriteControl`. The
    `canExecute` delegate of the `FavoriteToggledCommand` on the `RecipeDetailViewModel`
    should return `true` as long as this number is not exceeded. Let’s see how we
    can implement this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个效果！为了演示目的，让我们添加一个最大次数，通过`FavoriteControl`可以切换菜谱的收藏状态。只要这个数字没有超过，`RecipeDetailViewModel`上的`FavoriteToggledCommand`的`canExecute`委托应返回`true`。让我们看看我们如何实现这一点：
- en: 'Let’s start by adding the following two fields to `RecipeDetailViewModel`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向`RecipeDetailViewModel`添加以下两个字段开始：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, update the `FavoriteToggledCommand` so that it includes the `canExecute`
    predicate, as shown here:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`FavoriteToggledCommand`，使其包括`canExecute`谓词，如下所示：
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: private async Task FavoriteToggled(bool isFavorite)
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private async Task FavoriteToggled(bool isFavorite)
- en: '{'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '...'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: updateCount++;
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: updateCount++;
- en: FavoriteToggledCommand.NotifyCanExecuteChanged();
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FavoriteToggledCommand.NotifyCanExecuteChanged();
- en: '}'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this in place, we can run the app and see how the `FavoriteControl` reacts
    to the `ToggleCommand`’s `CanExecute` method. Go to the detail page of a recipe
    and press the `FavoriteControl` a couple of times. You’ll notice the favorite
    state will be updated until you’ve clicked five times. After that, the `ToggleCommand`’s
    `CanExecute` method returns `false`, resulting in `IsInteractive` being set to
    `false` as well. Any following interactions with the control will be ignored because
    of this. Additionally, on the `RecipesOverviewPage`, you’ll find that `FavoriteControl`
    is not tappable due to the absence of a defined `ToggleCommand`. Both scenarios
    illustrate that the controls behave as expected!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置完成后，我们可以运行应用程序并查看`FavoriteControl`如何对`ToggleCommand`的`CanExecute`方法做出反应。转到菜谱的详细页面，并按下`FavoriteControl`几次。你会注意到收藏状态将被更新，直到你点击五次。之后，`ToggleCommand`的`CanExecute`方法返回`false`，导致`IsInteractive`也被设置为`false`。由于这个原因，任何后续与控件的交互都将被忽略。此外，在`RecipesOverviewPage`上，你会发现`FavoriteControl`不可触摸，因为没有定义`ToggleCommand`。这两个场景都说明了控件的行为符合预期！
- en: 'Now that we’ve established how the `IsInteractive` property works, let’s turn
    our attention to leveraging it for a more intuitive user experience. Specifically,
    we’ll explore how to use this property to provide a visual cue that indicates
    whether or not the control is tappable. There’s not that much we can do about
    our `FavoriteControl` to make it really clear that it’s tappable. For the purposes
    of this demo, we’ll add a simple indicator – a black border around the heart icon
    when it’s tappable. Here’s how we can do this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`IsInteractive`属性的工作原理，让我们将注意力转向如何利用它来提供更直观的用户体验。具体来说，我们将探讨如何使用这个属性来提供视觉提示，指示控件是否可触摸。关于我们的`FavoriteControl`，我们无法做太多来使其非常清楚地表明它是可触摸的。为了演示的目的，我们将在可触摸时在心形图标周围添加一个简单的指示器——一个黑色边框。以下是我们可以如何做到这一点：
- en: 'Open the `FavoriteControl.xaml` file and surround the existing `Image` control
    with `Grid`, as shown in the following snippet:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FavoriteControl.xaml`文件，并将现有的`Image`控件用`Grid`包围，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <Grid>
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Grid>
- en: <Image
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Image
- en: HeightRequest="{Binding HeightRequest,
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HeightRequest="{Binding HeightRequest,
- en: Source={x:Reference icon}}"
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Source={x:Reference icon}}"
- en: WidthRequest="{Binding WidthRequest,
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WidthRequest="{Binding WidthRequest,
- en: Source={x:Reference icon}}"
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Source={x:Reference icon}}"
- en: IsVisible="{Binding IsInteractive,
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IsVisible="{Binding IsInteractive,
- en: Source={RelativeSource
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Source={RelativeSource
- en: AncestorType={x:Type
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AncestorType={x:Type
- en: local:FavoriteControl}}}"
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: local:FavoriteControl}}}"
- en: Scale="1.2"
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scale="1.2"
- en: Source="{Binding Source,
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Source="{Binding Source,
- en: Source={x:Reference icon}}" />
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Source={x:Reference icon}}" />
- en: <Image x:Name="icon" ...>
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Image x:Name="icon" ...>
- en: '...'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: </Image>
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </Image>
- en: </Grid>
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </Grid>
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, it’s crucial not to forget to trigger the `PropertyChanged` event for
    the `IsInteractive` property whenever it is updated. Otherwise, the binding engine
    wouldn’t be notified about the updated value. The following snippet shows how
    we can update the `UpdateIsInteractive` method to do that:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，不要忘记在`IsInteractive`属性更新时触发`PropertyChanged`事件。否则，绑定引擎不会通知更新后的值。以下代码片段显示了如何更新`UpdateIsInteractive`方法来实现这一点：
- en: '[PRE33]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When running the app now and navigating to a `RecipeDetailPage`, you should
    see a black border around the favorite icon, indicating that the control is interactive.
    This border isn’t visible on the `RecipeOverviewPage` because of the absence of
    a `ToggledCommand`. Moreover, when tapping `FavoriteControl` on a `RecipeDetailPage`
    a few times, after the fifth time, the border will disappear because `FavoriteToggledCommand`’s
    `CanExecute` method returns `false`. This visual cue informs a user that the control
    is no longer interactive. *Figure 11**.4* shows the `FavoriteControl` on the `RecipeDetailPage`
    in all its different states:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在运行应用程序并导航到`RecipeDetailPage`时，你应该看到收藏图标周围有一个黑色边框，这表明控制是交互式的。由于缺少`ToggledCommand`，这个边框在`RecipeOverviewPage`上不可见。此外，在`RecipeDetailPage`上连续几次轻触`FavoriteControl`后，第五次触摸后边框将消失，因为`FavoriteToggledCommand`的`CanExecute`方法返回`false`。这个视觉提示告知用户控制不再交互。*图11.4*显示了`RecipeDetailPage`上`FavoriteControl`的所有不同状态：
- en: '![Figure 11.4: FavoriteControl in different states](img/B20941_11_04.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4：FavoriteControl在不同状态](img/B20941_11_04.jpg)'
- en: 'Figure 11.4: FavoriteControl in different states'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：FavoriteControl在不同状态
- en: Now that we’ve fine-tuned the user and developer experience, let’s take it a
    step further by making our control’s design as adaptable as its functionality.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经优化了用户和开发者的体验，让我们更进一步，使我们的控制设计与其功能一样适应性强。
- en: Working with control templates
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与控制模板一起工作
- en: So far, we’ve been dealing with a hardcoded look and feel, but what if we want
    to offer more flexibility without forcing developers to rewrite or extend our
    control? By supporting control templates, we can expose the structure of our control’s
    visual tree, enabling both styling and structural changes while retaining its
    core functionality. This is an excellent way to ensure that our custom control
    seamlessly fits into a diverse array of user interfaces, providing an even greater
    degree of customization.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理硬编码的外观和感觉，但如果我们想提供更多的灵活性，而不强迫开发者重写或扩展我们的控制，那会怎么样呢？通过支持控制模板，我们可以暴露我们控制视觉树的结构，允许进行样式和结构上的更改，同时保留其核心功能。这是确保我们的自定义控制能够无缝地融入各种用户界面，提供更高程度的定制化的绝佳方式。
- en: You might wonder how this is relevant to MVVM. Consider the following – a control
    template serves to separate the logic and behavior of a control from its visual
    representation, much like how MVVM achieves loose coupling between the ViewModel
    and the View. In this sense, the control effectively serves as a ViewModel for
    the control template. It exposes properties that the template binds to. The control
    template, in turn, can be considered as the View. So, just like we are used to,
    we can use data binding in the control template and use a relative binding source
    set to `TemplatedParent` to bind to the properties of the control that the template
    is applied to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这与MVVM有什么关系。考虑以下情况——一个控制模板的作用是将控制逻辑和行为与其视觉表示分离，就像MVVM如何实现ViewModel和View之间的松耦合。从这个意义上讲，控制实际上充当了控制模板的ViewModel。它暴露了模板绑定到的属性。反过来，控制模板可以被视为View。因此，就像我们习惯的那样，我们可以在控制模板中使用数据绑定，并使用设置为`TemplatedParent`的相对绑定源来绑定到模板应用到的控制属性。
- en: TemplateBinding and TemplatedParent
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 模板绑定和模板父级
- en: In the upcoming examples, we’ll use binding statements with their `RelativeSource`
    set to `TemplatedParent`. It’s worth noting that this approach performs the same
    function as the now-obsolete `TemplateBinding` markup extension. Essentially,
    setting `RelativeSource` to `TemplatedParent` manually accomplishes what `TemplateBinding`
    used to do automatically, creating a binding whose source is the control to which
    the template is applied. However, since .NET 7, the `TemplateBinding` markup extension
    has been marked as “obsolete.”
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用绑定语句，并将它们的 `RelativeSource` 设置为 `TemplatedParent`。值得注意的是，这种方法与现在已废弃的
    `TemplateBinding` 标记扩展执行相同的功能。本质上，手动将 `RelativeSource` 设置为 `TemplatedParent` 完成了
    `TemplateBinding` 以前自动完成的事情，创建了一个源为应用模板的控件的绑定。然而，从 .NET 7 开始，`TemplateBinding`
    标记扩展已被标记为“已废弃”。
- en: I want to quickly discuss control templates, as they reflect the MVVM philosophy.
    Whether you’re extending the visuals of existing controls or creating new ones
    from scratch, knowing how to properly structure and utilize control templates
    will make your development process more efficient and your applications more maintainable.
    I also think that being proficient in the aspects of XAML and data binding directly
    contributes to effectively applying the MVVM pattern in your projects. Without
    further ado, let’s dive in!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我想快速讨论一下控件模板，因为它们反映了 MVVM 哲学。无论你是扩展现有控件的外观还是从头创建新的控件，了解如何正确构建和利用控件模板都将使你的开发过程更高效，并使你的应用程序更易于维护。我还认为，精通
    XAML 和数据绑定的方面直接有助于在项目中有效地应用 MVVM 模式。无需多言，让我们深入探讨！
- en: 'The next steps show how to define a control template and apply it to the `FavoriteControl`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将展示如何定义一个控件模板并将其应用到 `FavoriteControl` 上：
- en: 'On `RecipeDetailPage`, we can add a `ControlTemplate` to the page’s `Resource`s,
    as shown in the following snippet:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecipeDetailPage` 中，我们可以向页面的 `Resource`s 添加一个 `ControlTemplate`，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note how this template uses `TemplatedParent` as `RelativeSource` in its binding
    statements. By doing this, we bind to the public properties exposed by the control
    where this template will be applied, as we will see later on.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个模板在其绑定语句中使用 `TemplatedParent` 作为 `RelativeSource`。通过这样做，我们绑定到控制公开的属性，这些属性将在应用此模板的控件中暴露，正如我们稍后将要看到的。
- en: 'The following code snippet shows how we can use the key associated with the
    `ControlTemplate` (`FavoriteTemplate`), together with the `StaticResource` Markup
    extension, to assign it as the template of our `FavoriteControl`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何使用与 `ControlTemplate` 关联的键（`FavoriteTemplate`），结合 `StaticResource`
    标记扩展，将其分配为我们的 `FavoriteControl` 的模板：
- en: '[PRE35]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'While maintaining the functionality of the `FavoriteControl`, this template
    gives an entirely different look to the control, as you can see in *Figure 11**.5*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持 `FavoriteControl` 功能的同时，这个模板给控件带来了完全不同的外观，正如你在 *图 11.5* 中可以看到的那样：
- en: '![Figure 11.5: FavoriteControl with an alternative template](img/B20941_11_05.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：使用替代模板的 FavoriteControl](img/B20941_11_05.jpg)'
- en: 'Figure 11.5: FavoriteControl with an alternative template'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：使用替代模板的 FavoriteControl
- en: 'However, there is one thing missing. Remember the animation we had on the original
    control? The animation was triggered by the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里缺少了一样东西。还记得原始控件上的动画吗？动画是由以下代码触发的：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The original visual tree of the control is replaced by the new visual tree defined
    in the `ControlTemplate`. Therefore, the original elements are not visible and
    are not part of the current visual tree. However, those original elements do still
    exist in memory if you have references to them in your code-behind. Even though
    they are detached from the visual tree and are not visible, you can still interact
    with them using code. They just won’t have any impact on what a user sees because
    they are not in the visual tree anymore. As a result, the code responsible for
    the animation won’t crash, but there won’t be any visual effect on the screen.
    Let’s see how we can access visual elements defined on a `ControlTemplate`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 控件的原生视觉树被 `ControlTemplate` 中定义的新视觉树所替换。因此，原始元素不再可见，并且不是当前视觉树的一部分。然而，如果你在代码后端有对这些原始元素的引用，它们仍然存在于内存中。尽管它们已经从视觉树中分离出来且不可见，但你仍然可以使用代码与它们交互。它们只是不会对用户看到的内容产生影响，因为它们不再在视觉树中。因此，负责动画的代码不会崩溃，但屏幕上不会有任何视觉效果。让我们看看我们如何访问在
    `ControlTemplate` 上定义的视觉元素。
- en: Accessing elements from a template
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模板中访问元素
- en: Traditionally, when working with custom controls, UI elements are defined directly
    within the control. These controls, when given an `x:Name` attribute, can be accessed
    and manipulated from the control’s code-behind, which is a perfectly valid approach
    to defining and working with custom controls. However, when fully embracing the
    power of control templates, the need for directly defined UI elements lessens.
    Instead, the default appearance of the control should ideally be encapsulated
    within a `ControlTemplate`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，当与自定义控件一起工作时，UI元素直接在控件内部定义。这些控件在赋予`x:Name`属性后，可以从控件的代码隐藏文件中访问和操作，这是一种定义和使用自定义控件的完全有效的方法。然而，当完全拥抱控件模板的力量时，直接定义UI元素的需求减少。相反，控件的理想默认外观应封装在`ControlTemplate`中。
- en: 'For illustration, let’s consider `FavoriteControlTemplated`, which is a variant
    of `FavoriteControl`. Unlike the original, this version doesn’t have UI elements
    defined directly within it. Instead, its default appearance is declared in a `ControlTemplate`,
    defined in the control’s `Resources`. Here’s how it looks in XAML:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们考虑`FavoriteControlTemplated`，它是`FavoriteControl`的一个变体。与原始版本不同，这个版本没有在内部直接定义UI元素。相反，它的默认外观在`ControlTemplate`中声明，定义在控件的`Resources`中。以下是它在XAML中的样子：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see in the next code block, in the constructor of the `FavoriteControlTemplated`
    class, a default template is assigned when no other template is specified:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下一个代码块中可以看到的，在`FavoriteControlTemplated`类的构造函数中，如果没有指定其他模板，则会分配一个默认模板：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the `ControlTemplate` property is null, it means the developer hasn’t specified
    a different template. In that case, the default template from the control’s `Resources`
    is retrieved and assigned.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ControlTemplate`属性为null，这意味着开发者没有指定不同的模板。在这种情况下，会检索并分配控件`Resources`中的默认模板。
- en: 'The `OnApplyTemplate` method is called when the control template is fully loaded.
    This is where the `GetTemplateChild` method can be used to access specific elements
    within the template, like `Image` in our template, which we assigned the name
    `scalableContent`. The following snippet shows how we use the `GetTemplateChild`
    method to get a `VisualElement` named `scalableContent`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当控件模板完全加载时，会调用`OnApplyTemplate`方法。这是使用`GetTemplateChild`方法访问模板中特定元素的地方，例如我们模板中的`Image`，我们将其命名为`scalableContent`。以下代码片段显示了如何使用`GetTemplateChild`方法获取名为`scalableContent`的`VisualElement`：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once a `VisualElement` with the name `scalableContent` is retrieved, it can
    be manipulated programmatically. For example, in the `AnimateChange` method, scaling
    animations can be applied to it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到名为`scalableContent`的`VisualElement`，就可以对其进行程序化操作。例如，在`AnimateChange`方法中，可以对其应用缩放动画：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By adopting control templates and leveraging methods such as `GetTemplateChild`,
    we can maintain a clean separation between the logic and visual representation
    of our control, allowing more flexible and reusable components.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用控件模板并利用`GetTemplateChild`等方法，我们可以保持控件逻辑和视觉表示之间的清晰分离，从而允许更灵活和可重用的组件。
- en: 'Let’s update the `FavoriteTemplate` we created earlier on `RecipeDetailPage`
    by giving a certain UI element the name `scalableContent`, using `FavoriteControlTemplated`
    instead of `FavoriteControl`. Here’s how:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新在`RecipeDetailPage`上创建的`FavoriteTemplate`，通过给某个UI元素命名为`scalableContent`，使用`FavoriteControlTemplated`而不是`FavoriteControl`。以下是操作步骤：
- en: 'On `RecipeDetailPage`, update the `FavoriteTemplate`, as shown here:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RecipeDetailPage`上更新`FavoriteTemplate`，如下所示：
- en: '[PRE41]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By assigning `scalebleContent` as the name of the `Switch` control, it can be
    picked up later by the `FavoriteControlTemplated` control and have animations
    applied to it.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将`scalebleContent`作为`Switch`控件的名称，它可以在以后被`FavoriteControlTemplated`控件拾取，并对其应用动画。
- en: 'As shown in the next code block, let’s use the `FavoriteControlTemplated` custom
    control instead of the `FavoriteControl` from earlier:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下一个代码块所示，让我们使用`FavoriteControlTemplated`自定义控件而不是之前的`FavoriteControl`：
- en: '[PRE42]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you run the app at this stage, you’ll notice the updated favorite indicator.
    When we tap the control, you’ll notice the `Switch` is scaled. This is because
    it was named `scalableContent` in the template. If you update `RecipeDetailPage`
    and leave out the assignment of the `ControlTemplate` property (`ControlTemplate="{StaticResource
    FavoriteTemplate}"`) and run the app again, you’ll see the visualization using
    the hearts we had earlier. That’s because when no `ControlTemplate` is assigned
    explicitly, the control will load the default control template.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在这个阶段运行应用程序，你会注意到更新的收藏指示器。当我们点击控件时，你会注意到`Switch`被缩放了。这是因为它在模板中命名为`scalableContent`。如果你更新`RecipeDetailPage`并省略对`ControlTemplate`属性的赋值（`ControlTemplate="{StaticResource
    FavoriteTemplate}"`）然后再次运行应用程序，你会看到我们之前使用的心形可视化。那是因为当没有明确分配`ControlTemplate`时，控件将加载默认的控件模板。
- en: It’s worth noting that any control template that includes an element named `scalableContent`
    will be compatible with this code. In other words, as long as the template has
    a UI element with the name `scalableContent`, our `FavoriteControlTemplated` class
    will be able to retrieve it and apply the scaling animation. However, what if
    there’s no `scalableContent` element in the template? No worries – the control
    is designed to degrade gracefully. If the element isn’t found, all functionalities
    of the control will remain intact; only the animation will be absent. This flexibility
    allows developers to create a wide array of visual styles while the behavior of
    the control remains intact.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，任何包含名为`scalableContent`的元素的控件模板都将与此代码兼容。换句话说，只要模板中有一个名为`scalableContent`的UI元素，我们的`FavoriteControlTemplated`类就能检索到它并应用缩放动画。然而，如果模板中没有`scalableContent`元素呢？不用担心——控件被设计成能够优雅降级。如果找不到该元素，控件的所有功能都将保持完整；只是动画将不存在。这种灵活性允许开发者创建各种视觉风格，同时保持控件的行为不变。
- en: The principle of separation of concerns is central to MVVM and vital to creating
    maintainable software. When you’re crafting custom controls, this same principle
    can be extended through the use of control templates. However, it’s worth mentioning
    that fully implementing control templates may not always be necessary. For simpler
    controls that are unique to your application and maintain a consistent appearance,
    directly defining UI elements within the control itself is both a practical and
    valid approach. This allows you to balance complexity with flexibility, enabling
    you to choose the approach that best suits your project’s specific requirements.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离原则是MVVM的核心，对于创建可维护的软件至关重要。当你正在创建自定义控件时，这个原则可以通过使用控件模板来扩展。然而，值得注意的是，并非总是需要完全实现控件模板。对于你应用程序中独特且保持一致外观的简单控件，直接在控件内部定义UI元素既实用又有效。这允许你平衡复杂性与灵活性，使你能够选择最适合你项目特定需求的方法。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the powerful possibilities offered by custom controls
    and control templates in .NET MAUI, all within the context of the MVVM architecture.
    From understanding the basics of custom controls to creating bindable properties,
    we’ve delved into the intricacies of data binding on custom controls. We also
    explored how to add interactivity to our control and how commands can be exposed
    and dealt with. Furthermore, we dived deep into the flexibility and scalability
    offered by control templates. Collectively, these techniques enhance reusability
    and adhere to the principles of separation of concerns. Mastering the art of creating
    UIs – whether through XAML or code-behind – and understanding how to craft MVVM-friendly
    controls with bindable properties and commands contributes tremendously to being
    proficient in MVVM. Whether it’s a simple control with a hardcoded appearance
    or a complex, template-driven control, the key takeaway is understanding when
    and how to appropriately apply these approaches to create maintainable, adaptable,
    and highly customizable UI components.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了.NET MAUI中自定义控件和控制模板提供的强大可能性，所有这些都是在MVVM架构的背景下进行的。从理解自定义控件的基础到创建可绑定属性，我们深入研究了自定义控件上的数据绑定复杂性。我们还探讨了如何为我们的控件添加交互性以及如何公开和处理命令。此外，我们还深入研究了控制模板提供的灵活性和可扩展性。这些技术的综合运用提高了可重用性，并遵循了关注点分离的原则。掌握创建UI的艺术——无论是通过XAML还是代码后置——以及了解如何使用可绑定属性和命令创建MVVM友好的控件，对精通MVVM贡献巨大。无论是具有硬编码外观的简单控件还是复杂、模板驱动的控件，关键是要理解何时以及如何恰当地应用这些方法来创建可维护、可适应且高度可定制的UI组件。
- en: In the next chapter, we’ll explore localization within the context of MVVM,
    enabling our UI components to be not only flexible and maintainable but also globally
    adaptable.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在MVVM的背景下进行本地化，使我们的UI组件不仅灵活且易于维护，而且能够全球适应。
- en: Further reading
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: 'Create a custom control using handlers: [https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create](https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用处理程序创建自定义控件：[https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create](https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create)
- en: 'Customize controls with handlers: [https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize](https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用处理程序自定义控件：[https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize](https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize)
- en: 'More about control templates: [https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate](https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于控制模板的信息：[https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate](https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate)
- en: 'Bind to a templated parent: [https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent](https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent)**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到模板化父级：[https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent](https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent)
