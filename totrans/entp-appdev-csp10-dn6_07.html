<html><head></head><body>
		<div><h1 id="_idParaDest-103"><em class="italic"><a id="_idTextAnchor445"/>Chapter 5</em>: Dependency Injection in .NET 6</h1>
			<p>A big issue that an enterprise application can face is the complexity of wiring different elements together and managing their lifetimes. To address this, we use the <strong class="bold">inversion of control</strong> (<strong class="bold">IoC</strong>) principle, which recommends removing the dependency between objects. By delegating the flow of control, IoC makes the program extensible and increases the modularity. Events, callback delegates, the observer pattern, and <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) are some of the ways to achieve IoC.</p>
			<p>In this chapter, we will learn about the following:</p>
			<ul>
				<li>What is DI?</li>
				<li>DI in ASP.NET Core 6</li>
				<li>Managing application services</li>
				<li>Using third-party containers</li>
			</ul>
			<p>By the end of this chapter, you'll have a good idea about DI and how it's leveraged in .NET 6 applications, the types of scopes provided in ASP.NET Core 6, and how to leverage them in your projects.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor446"/>Technical requirements</h1>
			<p>The code used in this chapter can be found here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor447"/>What is DI?</h1>
			<p>DI is a technique <a id="_idIndexMarker354"/>in which an object receives objects that it depends on. The DI pattern fulfills the DI principle covered as part of the <strong class="bold">single-responsibility principle, open-closed principle, Liskov substitution principle, interface segregation principle, and dependency inversion principle</strong> (<strong class="bold">SOLID</strong>) design <a id="_idIndexMarker355"/>principles in <a href="B18507_01_Epub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing and Architecting the Enterprise Application</em>. With the use of DI, code will be more maintainable, readable, testable, and extensible.</p>
			<p>DI is one of the most well-known methods to help achieve better maintainable code. DI has three entities involved, as shown in the following diagram: </p>
			<div><div><img src="img/Figure_5.1_B18507.jpg" alt="Figure 5.1 – DI relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – DI relationship</p>
			<p>The <code>IOrderRepository</code> is responsible for <code>Order</code> entity. .NET IoC container (<code>IOrderRepository</code> (<code>OrderController</code> (client). </p>
			<p><strong class="bold">IoC container</strong> (also <a id="_idIndexMarker360"/>known as <strong class="bold">DI Container</strong>) is a framework for implementing <a id="_idIndexMarker361"/>automatic DI. In <em class="italic">Figure 5.1</em>, this is referred to as <strong class="bold">Injector</strong>. It is responsible for creating or referencing a dependency and injecting it into <strong class="bold">Client</strong>.</p>
			<p>Now that we have learned what DI is, let's learn about the types of DI.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor448"/>Types of DI</h2>
			<p>There are <a id="_idIndexMarker362"/>multiple ways a service can be injected into a dependency. Based on the way a service is injected into the client object, DI is categorized into three types, as outlined here:</p>
			<ul>
				<li><code>IWeatherProvider</code> dependency is injected through the constructor parameter:<pre>    public class WeatherService
    {
        private readonly IweatherProvider
            weatherProvider;
<strong class="bold">        public WeatherService(IWeatherProvider</strong>
<strong class="bold">            weatherProvider)</strong>
<strong class="bold">                =&gt; this.weatherProvider =</strong>
<strong class="bold">                    weatherProvider;</strong>
        public WeatherForecast GetForecast(string
            location) =&gt;
            this.weatherProvider.
                GetForecastOfLocation (location);   
    }</pre></li>
			</ul>
			<p>In the preceding example, <code>WeatherService</code> is dependent on <code>IWeatherProvider</code>, which is injected via a constructor parameter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For an implementation of the <code>WeatherProvider</code> service, refer to the sample code from GitHub, which can be found at the following link: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs</a>.</p>
			<p><code>IWeatherProvider</code> dependency is not set while initializing <code>WeatherService2</code>. It is set via the <code>WeatherProvider</code> property post object initialization:</p>
			<pre>    public class WeatherService2
    {
        private IWeatherProvider _weatherProvider;
<strong class="bold">        public IWeatherProvider WeatherProvider</strong>
<strong class="bold">        {</strong>
<strong class="bold">            get =&gt; _weatherProvider == null ?</strong>
<strong class="bold">                        throw new</strong>
<strong class="bold">                            InvalidOperationException(</strong>
<strong class="bold">                            "WeatherService is not</strong>
<strong class="bold">                            initialized")</strong>
<strong class="bold">                    : _weatherProvider;</strong>
<strong class="bold">            set =&gt; _weatherProvider = value;</strong>
<strong class="bold">        }</strong>
        public WeatherForecast GetForecast(string
            location) =&gt;
            this.WeatherProvider.
                GetForecastOfLocation(location);
    }</pre>
			<ul>
				<li><code>IWeatherProvider</code> dependency is injected as a method parameter wherever required.</li>
			</ul>
			<p>In the following code snippet, the <code>IWeatherProvider</code> service is injected into <code>WeatherService</code> via the <code>GetForecast</code> method:</p>
			<pre>    public class WeatherService
    {
       <strong class="bold">public WeatherForecast GetForecast(</strong>
<strong class="bold">           string location, IWeatherProvider</strong>
<strong class="bold">           weatherProvider)</strong>
        {
            if(weatherProvider == null)
            {
                throw new ArgumentNullException(
                    nameof(weatherProvider));
            }
            return weatherProvider.
                GetForecastOfLocation (location);
        }
    }</pre>
			<p>Here are some suggestions to help in choosing the type of DI:</p>
			<ul>
				<li>Use constructor injection when the class has a dependency without which the functionality won't work. </li>
				<li>Use constructor <a id="_idIndexMarker369"/>injection when the dependency is used in multiple functions in the class.</li>
				<li>Use property injection when the dependency can change after the class is instantiated. </li>
				<li>Use method injection when the implementation of the dependency changes with every call.</li>
			</ul>
			<p>In most cases, constructor injection will be used for clean and decoupled code, but depending on the need, we will also leverage method and property injection techniques.</p>
			<p>We have now learned the concepts of DI. Let's dive into what .NET 6 offers to achieve DI.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor449"/>DI in ASP.NET Core 6</h1>
			<p>.NET 6 comes <a id="_idIndexMarker370"/>with a built-in IoC container <a id="_idIndexMarker371"/>framework, which simplifies DI. This comes with the <code>Microsoft.Extensions.DependencyInjection</code> NuGet package and the ASP.NET Core 6 framework itself relies heavily on this. To support DI, a container needs to support three basic actions on objects/services, as outlined here:</p>
			<ul>
				<li><strong class="bold">Registering</strong>: The <a id="_idIndexMarker372"/>container should have provisions to register dependencies. This will help to map the correct type to a class so that it can create the right dependency instance.</li>
				<li><strong class="bold">Resolving</strong>: The <a id="_idIndexMarker373"/>container should resolve dependencies by creating a dependency object and injecting it into the dependent instance. IoC container manages the creation of registered objects by passing in all the required dependencies.</li>
				<li><strong class="bold">Disposing</strong>: The <a id="_idIndexMarker374"/>container is responsible for managing the lifetime of dependencies created through it.</li>
			</ul>
			<p>In .NET 6, the following terms are used:</p>
			<ul>
				<li><strong class="bold">Service</strong>: Refers <a id="_idIndexMarker375"/>to a dependency managed by a container</li>
				<li><code>IConfiguration</code>, <code>ILoggerFactory</code>, <code>IWebHostEnvironment</code>, and so on</li>
				<li><code>IWeatherProvider</code> service that we used in the previous section</li>
			</ul>
			<p>For the application to start, the ASP.NET Core 6 framework injects a few dependencies, which are <a id="_idIndexMarker378"/>referred to as <code>WebApplicationBuilder</code> is injected with the required framework services such as <code>IConfiguration</code> and <code>IWebHostEnvironment</code>. When you try printing the registered services, as shown in the following code snippet (refer to the code from <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16</a>), we can list the framework services registered:</p>
			<pre class="source-code">foreach(var i in builder.Services.AsEnumerable())</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    Console.WriteLine($"{i.Lifetime} - {i.ServiceType.ToString()}");</pre>
			<pre class="source-code">}</pre>
			<p>In ASP.NET Core 6.0, the <code>IWebHostEnvironment</code> framework service is available from the <code>builder.Environment</code> property. Similarly, the configuration is available from the <code>builder.Configuration</code> property.</p>
			<p>ASP.NET Core 6 Runtime instantiates all the required framework services and registers them with IoC container. Starting with ASP.NET Core 6, they are available through properties of <code>WebApplication</code> and <code>WebApplicationBuilder</code> in <code>Program.cs</code>. These framework services can be injected into controllers and other services through any of the DI types we discussed in the previous section.</p>
			<p>Application <a id="_idIndexMarker379"/>services are services injected <a id="_idIndexMarker380"/>into the container by the developer. These services will be registered using the <code>Services</code> property of <code>WebApplicationBuilder</code>. The following code snippet shows how to register the <code>IWeatherProvider</code> application service with the container:</p>
			<pre class="source-code">builder.Services.AddScoped&lt;IWeatherProvider, WeatherProvider&gt;();</pre>
			<p>In the next section, we will learn about the lifetime of these services and how they are managed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, to learn about the code present in the <code>Program.cs</code> file.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor450"/>Understanding service lifetimes</h2>
			<p>When you register a service with a specified lifetime, the container will automatically dispose of the object according to the lifetime specified. There are three types of lifetimes available to use with Microsoft DI Container, as outlined here:</p>
			<ul>
				<li><code>AddTransient</code> extension method is used to register with this lifetime, as illustrated in the following code snippet: <pre><strong class="bold">public static</strong> IServiceCollection AddTransient(<strong class="bold">this</strong>
<strong class="bold">   </strong> IServiceCollection services, Type serviceType);</pre><p class="callout-heading">Note</p><p class="callout">A transient lifetime is normally used for stateless, lightweight services.</p></li>
				<li><code>ServiceProvider</code> is disposed of on application shutdown. The <code>AddSingleton</code> extension method is used to register with this lifetime, as illustrated in the following code snippet:<pre><strong class="bold">public static</strong> IServiceCollection AddSingleton(<strong class="bold">this</strong>
<strong class="bold">   </strong> IServiceCollection services, Type serviceType);</pre></li>
				<li><code>DbContext</code> are registered with a scoped lifetime. The <code>AddScoped</code> extension method is used to register with the scoped lifetime <a id="_idIndexMarker388"/>scope, as illustrated in the following code snippet:<pre><strong class="bold">public static</strong> IServiceCollection AddScoped(<strong class="bold">this</strong>
<strong class="bold">   </strong> IServiceCollection services, Type serviceType);</pre></li>
			</ul>
			<p>The lifetime type needs to be chosen wisely in application development. A service should not depend on a service that has a shorter life span than its own; for example, a service registered as a singleton should not depend on a service that is registered as transient. The following table shows which lifetimes can safely depend on which other lifetime scopes:</p>
			<div><div><img src="img/Table_5.1.jpg" alt="Figure 5.1 – DI relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.1 – Lifetime dependency</p>
			<p>As a <a id="_idIndexMarker389"/>developer, you need not worry about scope validation. Built-in scope validation is done in ASP.NET Core 6 when the environment is set to <code>InvalidOperationException</code> is thrown while building the application. This can be explicitly turned on by enabling <code>ValidateScopes</code> options for all environment configurations while registering <code>ServiceProvider</code>, as shown in the following code snippet. Here, while creating a host builder, <code>ValidateScopes</code> is set to <code>true</code> to turn on the scope validation:</p>
			<pre class="source-code">builder.Host.UseDefaultServiceProvider(opt =&gt; { opt.ValidateScopes = true; }); </pre>
			<p>Let's create an ASP.NET Core 6 web application to understand the service lifetime. We will be creating different services and registering them with the singleton, scoped, and transient lifetime scopes and observing how they behave. Proceed as follows:</p>
			<ol>
				<li>Create a <a id="_idIndexMarker390"/>new ASP.NET Core web application (<code>DISampleWeb</code>.</li>
				<li>Create a new project folder with the name <code>Services</code> and add three classes: <code>ScopedService</code>, <code>SingletonService</code>, and <code>TransientService</code>. Add the following code (all these services will be the same without any real code in them; we just register them with different lifetime scopes as per their name):<pre>public interface IScopedService {     }
public class ScopedService : IScopedService {    }</pre></li><li><code>SingletonService.cs</code>: This class will be registered with the singleton lifetime <a id="_idIndexMarker393"/>scope, as illustrated in the following code snippet:<pre>public interface ISingletonService   {    }
public class SingletonService : ISingletonService {  }</pre></li><li><code>TransientService.cs</code>: This class will be registered with the transient lifetime <a id="_idIndexMarker394"/>scope, as illustrated in the following code snippet:<pre>public interface ITransientService   {    }
public class TransientService : ITransientService{   }</pre></li></ul></li>
				<li>Now, register these services in <code>Program.cs</code> with <code>IServiceCollection</code>, as shown here:<pre>//Register as Scoped
builder.Services.AddScoped&lt;IScopedService,ScopedService&gt;();
//Register as Singleton
builder.Services.AddSingleton&lt;ISingletonService,SingletonService&gt;();
//Register as Transient
builder.Services.AddTransient&lt;ITransientService,TransientService&gt;();</pre></li>
			</ol>
			<p>The collection of service descriptors, <code>IServiceCollection</code>, is exposed via the <code>Services</code> property of <code>WebApplicationBuilder</code>.</p>
			<ol>
				<li value="4">Now, add the <code>HomeViewModel</code> model class under the <code>Models</code> folder, which will be <a id="_idIndexMarker395"/>used to show data retrieved from the services registered previously. The following code snippet illustrates how to do this:<pre>public class HomeViewModel
{
        public int Singleton { get; set; }
        public int Scoped { get; set; }
        public int Scoped2 { get; internal set; }
        public int Transient { get; set; }
        public int Transient2 { get; internal set; }
}</pre></li>
			</ol>
			<p>Since we registered <code>ScopedService</code>, <code>SingletonService</code>, and <code>TransientService</code> with ASP.NET Core 6 IoC container, we will get these services via constructor injection.</p>
			<ol>
				<li value="5">Now, we will add code to get these services in <code>HomeController</code> and <code>Views</code> to show data retrieved from these objects on the home page. Modify the home controller to get two instances of <code>ScopedService</code> and <code>TransientService</code> and set <code>ViewModel</code> with the object hash code of the service object. The solution structure is shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_5.2_B18507.jpg" alt="Figure 5.2 – Solution structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Solution structure</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>GetHashCode</code> method <a id="_idIndexMarker396"/>returns the hash code of the object. This will change per instance.</p>
			<ol>
				<li value="6">Modify <a id="_idIndexMarker397"/>the constructor of <code>HomeController</code> to accept the registered services and define private fields to reference service instances, as follows:<pre>private readonly ILogger&lt;HomeController&gt; _logger;
private readonly IScopedService scopedService;
private readonly IScopedService scopedService2;
private readonly ISingletonService singletonService;
private readonly ITransientService transientService;
private readonly ITransientService transientService2;
public HomeController(ILogger&lt;HomeController&gt; logger,
IScopedService scopedService,
IScopedService scopedService2,
ISingletonService singletonService,
ITransientService transientService,
ITransientService transientService2)
{
     this._logger = logger;
     this.scopedService = scopedService;
     this.scopedService2 = scopedService2;
     this.singletonService = singletonService;
     this.transientService = transientService;
     this.transientService2 = transientService2;
}</pre></li>
				<li>Now, modify <a id="_idIndexMarker398"/>the <code>Index</code> method under <code>HomeController</code> to set <code>HomeViewModel</code>, as follows:<pre>public IActionResult Index()
{
      var viewModel = new HomeViewModel
     {
         Scoped = scopedService.GetHashCode(),
         Scoped2 = scopedService2.GetHashCode(),
         Singleton = singletonService.GetHashCode(),
         Transient = transientService.GetHashCode(),
         Transient2 = transientService2.GetHashCode(),
      };
      return View(viewModel);
}</pre></li>
				<li>Next, modify <code>Index.cshtml</code> under the <code>~/Views/Home</code> folder to show <code>HomeViewModel</code> on <a id="_idIndexMarker399"/>the page, as follows:<pre>@model HomeViewModel
@{
    ViewData["Title"] = "Home Page";
}
&lt;h2 class="text-success"&gt;Singleton.&lt;/h2&gt;
&lt;p&gt;
        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Singleton
&lt;/code&gt;
&lt;/p&gt;
&lt;h2 class="text-success"&gt;Scoped instance 1&lt;/h2&gt;
&lt;p&gt;
        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Scoped&lt;/code&gt;
&lt;/p&gt;
&lt;h2 class="text-success"&gt;Scoped instance 2&lt;/h2&gt;
&lt;p&gt;
        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Scoped2&lt;/code&gt;
&lt;/p&gt;
&lt;h2 class="text-success"&gt;Transient instance 1&lt;/h2&gt;
&lt;p&gt;
        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Transient&lt;/code&gt;
&lt;/p&gt;
&lt;h2 class="text-success"&gt;Transient instance 2&lt;/h2&gt;
&lt;p&gt;
        &lt;strong&gt;ID:&lt;/strong&gt; &lt;code&gt;@Model.Transient2&lt;/code&gt;
&lt;/p&gt;</pre></li>
				<li>Now, run <a id="_idIndexMarker400"/>the application. You will see an output like this:</li>
			</ol>
			<div><div><img src="img/Figure_5.3_B18507.jpg" alt="Figure 5.3 – Sample output on the first run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Sample output on the first run</p>
			<p>If we observe the output, the <code>ScopedService</code> are the same. This is because only one object for <code>IScopedService</code> is created per request scope. Please note the IDs may be different when you run the code as they are generated at runtime.</p>
			<p>The IDs of the transient service are different for both services. As we learned, this is because a new instance is created for every request to IoC container.</p>
			<ol>
				<li value="10">Now, refresh <a id="_idIndexMarker401"/>the page again. You'll see an output that looks something like this:</li>
			</ol>
			<div><div><img src="img/Figure_5.4_B18507.jpg" alt="Figure 5.4 – Sample output on the second run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Sample output on the second run</p>
			<p>If we compare the outputs in both <em class="italic">Figure 5.3</em> and <em class="italic">Figure 5.4</em>, we will notice that the ID of <code>SingletonService</code> did not change—this is because only one object is created for a singleton object per lifetime of the application. Up until now, we have seen how the service lifetime is managed based on the registration. It is also important to understand when objects are to be disposed of. In the next section, we will learn about the disposal of services.</p>
			<h3>Disposal of services</h3>
			<p>As we learned earlier in this chapter, the disposal of objects is the responsibility of the IoC container framework. The container calls the <code>Dispose</code> method on those services that implement <code>IDisposable</code>. Services created by the container should never be disposed of by the developer explicitly. Similarly, developers are responsible for disposing of instances created by them.</p>
			<p>Consider the <a id="_idIndexMarker402"/>following code snippet, where the <code>SingletonService</code> instance is registered with the singleton scope:</p>
			<pre class="source-code">var _disposableSingletonService= new DisposableSingletonService();</pre>
			<pre class="source-code">// Registering an instance of a class with singleton lifetime</pre>
			<pre class="source-code">builder.Services.AddSingleton&lt;IDisposableSingletonService&gt;(_disposableSingletonService);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">For a simple implementation of <code>DisposableSingletonService</code>, refer to the code at the following link: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs</a>.</p>
			<p>In the preceding code snippet, we created an object of <code>DisposableSingletonService</code> and registered it with IoC container. The service instance is not created by the container. In this case, IoC Container does not dispose of the object; it is the developer's responsibility to dispose of it. We can dispose of objects when an <code>ApplicationStopping</code> event is fired from <code>IHostApplicationLifetime</code>, which is exposed through the <code>Lifetime</code> property of <code>WebApplication</code>, as shown in the following code snippet:</p>
			<pre class="source-code">app.Lifetime.ApplicationStopping.Register(() =&gt; {</pre>
			<pre class="source-code">    _disposableSingletonService.Dispose();</pre>
			<pre class="source-code">});</pre>
			<p>In the preceding code snippet, <code>IHostApplicationLifetime</code> is injected by the runtime into <code>WebApplication</code>. This interface allows consumers to be notified of <code>ApplicationStarted</code>, <code>ApplicationStopped</code>, and <code>ApplicationStopping</code> application lifetime events. To dispose of the singleton object, we will call a Dispose() method by registering to the <code>ApplicationStopping</code> lifetime event.</p>
			<p>A new addition in .NET 6 to DI is the support of <code>IAsyncDisposable</code> for scopes. A new <code>CreateAsyncScope</code> extension method is added to <code>IServiceProvider</code> to support the <a id="_idIndexMarker403"/>creation of an asynchronous service scope, and an <code>AsyncServiceScope</code> wrapper is added, which implements <code>IAsyncDisposable</code>. The following code disposes of the scopes asynchronously:</p>
			<pre class="source-code">// Refer AsyncDisposableScope sample code for the implementation</pre>
			<pre class="source-code">await using (var scope = provider.CreateAsyncScope())</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    var foo = scope.ServiceProvider.GetRequiredService&lt;IWeatherProviderAsync&gt;();</pre>
			<pre class="source-code">} </pre>
			<p>Going forward, if the <a id="_idIndexMarker404"/>dependency <code>CreateAsyncScope</code> wherever you are creating scopes manually. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to the <a id="_idIndexMarker405"/>following Microsoft documentation to learn more about DI guidelines: </p>
			<p class="callout"><a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines">https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines</a></p>
			<p>Up until now, we have looked at service lifetimes and how they are disposed of in .NET 6. In the next section, we will learn about managing application services.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor451"/>Managing application services</h2>
			<p>In ASP.NET Core 6, when a request is received by <code>MvcMiddleware</code>, routing is used to select a <a id="_idIndexMarker406"/>controller and action method. <code>IControllerActivator</code> creates an instance of the controller and loads constructor arguments from DI Container.</p>
			<p>In the <em class="italic">Understanding service lifetimes</em> section, we saw how application services are registered and how their lifetimes are managed. In the example, the services were injected through a constructor, which is known as constructor injection. In this section, we will see how to achieve method injection and go through different ways application services can be registered and accessed in ASP.NET Core 6 IoC container.</p>
			<h3>Accessing registered services via method injection</h3>
			<p>In <a id="_idIndexMarker407"/>the previous sections, we saw how the dependency service is injected into the controller constructor <a id="_idIndexMarker408"/>and the reference is stored in a local field that is used to call a method/<strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) of the dependency.</p>
			<p>Sometimes, we don't want the dependency service to be available in all actions of the controller. In such scenarios, the service can be injected via method injection. This is done by making a parameter with the <code>[FromServices]</code> attribute, as shown in the following example:</p>
			<pre class="source-code">public IActionResult Index(<strong class="bold">[FromServices]</strong> ISingletonService singletonService2)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">}</pre>
			<p>Minimal APIs introduced in ASP.NET Core 6 allow us to request DI services in route handlers without explicitly marking them with the <code>[FromServices]</code> attribute, as illustrated here:</p>
			<pre class="source-code">app.MapGet("/", (ISingletonService service) =&gt; service.DoAction());</pre>
			<p>You might be wondering how the runtime differentiates injected services from other parameters. To achieve that, .NET6 introduced a new <code>IServiceProviderIsService</code> interface, which helps to identify that a given service <a id="_idIndexMarker409"/>type is registered in the DI container without creating an instance of it.</p>
			<p>In the next section, we will see the registration of multiple instances for the same service type and how to access them.</p>
			<h3>Registering multiple instances</h3>
			<p>For a given <a id="_idIndexMarker410"/>interface, we can register multiple implementations with the IoC container. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If more than one implementation is registered with the same service type, the last registration will take precedence over all previous registrations.</p>
			<p>Consider the following service registration, where the <code>IWeatherForecastService</code> service is registered with two implementations—<code>WeatherForecastService</code> and <code>WeatherForecastServiceV2</code>:</p>
			<pre class="source-code">services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
			<pre class="source-code">services.AddScoped&lt;IWeatherForecastService, WeatherForecastServiceV2&gt;();</pre>
			<p>Now, when there is a request for an instance of <code>IWeatherForecastService</code> from the controller, an instance of <code>WeatherForecastServiceV2</code> will be served, as illustrated in the following code snippet:</p>
			<pre class="source-code">private readonly IWeatherForecastService weatherForecastService;</pre>
			<pre class="source-code">public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger, IWeatherForecastService weatherForecastService)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      _logger = logger;</pre>
			<pre class="source-code">      this.weatherForecastService = weatherForecastService;</pre>
			<pre class="source-code">}</pre>
			<p>In the <a id="_idIndexMarker411"/>previous example, it might appear that the registration of <code>WeatherForecastV2</code> is overwriting the previous registration of <code>WeatherForecastService</code>. However, ASP.NET Core 6 IoC container will have all registrations of <code>IWeatherForecastService</code>. To get all registrations, fetch the service as <code>IEnumerable</code>, as follows:</p>
			<pre class="source-code">private readonly IEnumerable&lt;IWeatherForecastService&gt; weatherForecastServices;</pre>
			<pre class="source-code">public WeatherForecastController(</pre>
			<pre class="source-code">ILogger&lt;WeatherForecastController&gt; logger, IEnumerable&lt;IWeatherForecastService&gt; weatherForecastServices)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   _logger = logger;</pre>
			<pre class="source-code">   this.weatherForecastServices = weatherForecastServices;</pre>
			<pre class="source-code">}</pre>
			<p>This may be useful in scenarios such as executing a <code>Services</code> property of <code>WebApplicationBuilder</code>. So, in the future, when there is an addition of a rule or the removal of an existing rule, the change will only be to inject a new service into the <code>Services</code> property.</p>
			<h3>Using TryAdd</h3>
			<p>In this <a id="_idIndexMarker412"/>section, we will learn about how we can avoid accidentally overriding already registered services.</p>
			<p>The <code>TryAdd</code> extension method registers services only when no registration exists for the same service. The <code>TryAdd</code> extension method is available for all lifetime scopes (<code>TyrAddScoped</code>, <code>TryAddSingleton</code>, and <code>TryAddTransient</code>).</p>
			<p>With the service registration shown in the following code snippet, when there is a request for <code>IWeatherForecastService</code>, IoC container serves <code>WeatherForecastService</code>, not <code>WeatherForecastServiceV2</code>:</p>
			<pre class="source-code">services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
			<pre class="source-code">services.TryAddScoped&lt;IWeatherForecastService, WeatherForecastServiceV2&gt;();</pre>
			<p>To overcome <a id="_idIndexMarker413"/>side effects that might occur with duplicate registrations, it is always recommended to use <code>TryAdd</code> extension methods to register a service.</p>
			<p>Now, let's see how to replace an already registered service.</p>
			<h3>Replacing an existing registration</h3>
			<p>ASP.NET <a id="_idIndexMarker414"/>Core 6 IoC container provides a way to replace existing registrations. In the following example, <code>IWeatherForecastService</code> is initially registered with <code>WeatherForecastService</code>. It is then replaced with <code>WeatherForecastServiceV2</code>:</p>
			<pre class="source-code">builder.Services.TryAddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</pre>
			<pre class="source-code">builder.Services.Replace(ServiceDescriptor.Scoped&lt;IWeatherForecastService, WeatherForecastServiceV2&gt;());</pre>
			<p>As with the <code>Replace</code> instance of <code>WeatherForecastServiceV2</code>, an implementation is served to the constructor of <code>WeatherForecastController</code>. In the following code snippet, unlike in the <em class="italic">Registering multiple instances</em> section, we will only see one object in the <code>weatherForecastService</code> constructor variable:</p>
			<pre class="source-code">public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger, IEnumerable&lt;IWeatherForecastService&gt; weatherForecastService)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">      _logger = logger;</pre>
			<pre class="source-code">      this.weatherForecastService = weatherForecastService;</pre>
			<pre class="source-code">}</pre>
			<p>Till now in this section, we have learned about registering and replacing services with the IoC container. There may be times when we need to delete current registrations. Consider <a id="_idIndexMarker415"/>a scenario where you wish to utilize services and registrations from a library but you don't have access to its source code. If you reimplement some of the interfaces from that library and reregister them with the container, you might see some unexpected behavior. In the next section, we will see how to remove a registered service.</p>
			<h3>Removing an existing registration</h3>
			<p>To remove <a id="_idIndexMarker416"/>an existing registration,  ASP.Net Core 6 IoC container provides the <code>Remove</code> extension. You can use the <code>RemoveAll</code> method to remove all registrations related to a service, as seen in the following code snippet:</p>
			<pre class="source-code">services.RemoveAll&lt;IWeatherForecastService&gt;();</pre>
			<p>In the following code snippet, the <code>Remove</code> method removes the registration of the <code>WeatherForecastService</code> implementation from the container:</p>
			<pre class="source-code">//Removes the first registration of IWeatherForecastService           </pre>
			<pre class="source-code">Builder.Services.Remove(ServiceDescriptor.Scoped&lt;IWeatherForecastService, WeatherForecastService&gt;());</pre>
			<p>Up until now, we have seen how we work with complex services, but when it comes to generic open types, it will be difficult to register every generic constructed type. In the next section, we will learn how to deal with generic open-type services.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn more about generic types, you can refer to the following website: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types</a>.</p>
			<h3>Registering generics</h3>
			<p>This section will introduce you to dealing with generic-type services with DI.</p>
			<p>In the <a id="_idIndexMarker417"/>case of generic types, it does not make sense to register the service for each type of implementation that is in use. ASP.NET Core 6 IoC container provides a way to simplify the registration of the generic type. One such type that is already provided by the framework itself is <code>ILogger</code>, as illustrated in the following code snippet:</p>
			<pre class="source-code">Builder.Services.TryAdd(ServiceDescriptor.Singleton(typeof(ILogger&lt;&gt;), typeof(Logger&lt;&gt;))); </pre>
			<p class="callout-heading">Note</p>
			<p class="callout">For your reference, you may visit the following link: <a href="https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs">https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs</a>.</p>
			<p>Another use case for generics is with a generic repository pattern used with the data access layer.</p>
			<p>With all the registrations we have, the <code>ConfigureServices</code> method can grow big and can no longer be readable. The next section will help you learn how to address that.</p>
			<h3>Extension methods for code readability</h3>
			<p>The pattern that is followed in the ASP.NET Core 6 framework to make code look more readable <a id="_idIndexMarker418"/>is to create an extension method with a logical grouping of service registrations. The following code tries to group and register notification-related services using an extension method. General practice is to use the <code>Microsoft.Extensions.DependencyInjection</code> namespace to define service registration extension methods. This will make the developer use all the functionality related to DI just by using the <code>Microsoft.Extensions.DependencyInjection</code> namespace.</p>
			<p>In the following code snippet, notification-related services were registered with <code>AddNotificationServices</code>:</p>
			<pre class="source-code">namespace Microsoft.Extensions.DependencyInjection</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public static class NotificationServicesServiceCollectionExtension</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   public static IServiceCollection AddNotificationServices(this IServiceCollection services)</pre>
			<pre class="source-code">  {</pre>
			<pre class="source-code">       <strong class="bold">services.TryAddScoped&lt;INotificationService, EmailNotificationService&gt;();</strong></pre>
			<pre class="source-code"><strong class="bold">       services.TryAddScoped&lt;INotificationService, SMSNotificationService&gt;();</strong></pre>
			<pre class="source-code"><strong class="bold">        return services;</strong></pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Now <a id="_idIndexMarker419"/>that the extension method is created, we can use the <code>AddNotificationServices</code> method to register notification services under <code>ConfigureServices</code>. This will make <code>ConfigureServices</code> become more readable. The code is illustrated here:</p>
			<pre class="source-code">builder.Services.AddNotificationServices();</pre>
			<p>We have seen how to inject services into controllers and other classes. In the next section, we will learn how to inject services into views.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor452"/>DI in Razor Pages</h2>
			<p>The purpose of views in MVC is to display data. Most of the time, data displayed in views is <a id="_idIndexMarker420"/>passed from the controller. Passing <a id="_idIndexMarker421"/>all required data from controllers is recommended <a id="_idIndexMarker422"/>considering the <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>) principle, but there may be cases where we want to view specific services from pages such as localization and telemetry services. Using DI supported by Razor views, we can inject such services into views.</p>
			<p>To learn about injecting services into views, let's modify the <code>DISampleWeb</code> application that we created in previous chapters. We will be modifying the <code>DISampleWeb</code> application to display additional content on the home page if a flight flag is set. Add the <code>isFlightOn</code> configuration, as shown in the following code snippet, to <code>appsettings.json</code>:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "AllowedHosts": "*",</pre>
			<pre class="source-code"><strong class="bold">  "isFlightOn": "true"</strong></pre>
			<pre class="source-code">}</pre>
			<p>Now, modify the index view under <code>Home</code> to display the content under <code>Flight</code>, as shown in the following code snippet:</p>
			<pre class="source-code">@using Microsoft.Extensions.Configuration</pre>
			<pre class="source-code">@inject Iconfiguration Configuration</pre>
			<pre class="source-code">@{</pre>
			<pre class="source-code">   string isFlightOn = Configuration["isFlightOn"];</pre>
			<pre class="source-code">   if (string.Equals(isFlightOn, "true", StringComparison.OrdinalIgnoreCase))</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">       &lt;h1&gt;</pre>
			<pre class="source-code">        &lt;strong&gt;Flight content&lt;/strong&gt;</pre>
			<pre class="source-code">       &lt;/h1&gt;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <code>Iconfiguration</code> service, which provides the functionality of reading the configuration file, is injected into the Razor view using the <code>@inject</code> keyword. The injected <a id="_idIndexMarker423"/>configuration service is used to get the <a id="_idIndexMarker424"/>configuration and display additional content based on the settings. We can inject any service registered with <code>IserviceCollection</code> into Razor views using the <code>@inject</code> keyword.</p>
			<p>Up until now, we have seen how we can leverage the .NET 6 built-in IoC container. In the next section, we will learn about leveraging third-party containers.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor453"/>Using third-party containers</h1>
			<p>Though the built-in container is sufficient for most of our scenarios, .NET 6 provides a way to <a id="_idIndexMarker425"/>integrate with third-party containers that can be leveraged if need be.</p>
			<p>Let's have a closer look at how the framework wires up the services. When the <code>Startup</code> class is registered with <code>HostBuilder</code> in <code>Program.cs</code>, .NET Framework uses reflection to identify and call the <code>Configure</code> and <code>ConfigureServices</code> methods.</p>
			<p>Here is a snippet from the <code>LoadMethods</code> method of the <code>StartupLoader</code> class in ASP.NET Core 6 (refer to the code from <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs">https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs</a>):</p>
			<pre class="source-code">public static StartupMethods LoadMethods(IServiceProvider hostingServiceProvider, [DynamicallyAccessedMembers(StartupLinkerOptions.Accessibility)] Type startupType, string environmentName, object? instance = null)</pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">    var configureMethod = FindConfigureDelegate(startupType, environmentName);</pre>
			<pre class="source-code">    var servicesMethod = FindConfigureServicesDelegate(startupType, environmentName);</pre>
			<pre class="source-code">    var configureContainerMethod = FindConfigureContainerDelegate(startupType, environmentName);</pre>
			<pre class="source-code">     -----------------------</pre>
			<pre class="source-code">}</pre>
			<p>From the <a id="_idIndexMarker426"/>preceding code snippet, we can see that the first two methods, <code>FindConfigureDelegate</code> and <code>FindConfigureServicesDelegate</code>, are to find the <code>Configure</code> and <code>ConfigureServices</code> methods.</p>
			<p>The last line is for <code>ConfigureContainer</code>. We can define a <code>ConfigureContainer</code> method in the <code>Startup</code> class to configure the services into a third-party container.</p>
			<p>Here are some of the popular DI frameworks available for ASP.NET Core 6:</p>
			<ul>
				<li><strong class="bold">Unity</strong>: Unity <a id="_idIndexMarker427"/>was initially built by Microsoft <a id="_idIndexMarker428"/>and is currently open sourced. This is one of the oldest <a id="_idIndexMarker429"/>DI containers for .NET. The documentation is available at the following link: <a href="http://unitycontainer.org/">http://unitycontainer.org/</a>.</li>
				<li><strong class="bold">Autofac</strong>: This <a id="_idIndexMarker430"/>is one of the most <a id="_idIndexMarker431"/>popular DI containers. It has comprehensive documentation <a id="_idIndexMarker432"/>available at the following link: <a href="https://autofaccn.readthedocs.io/en/latest/index.html">https://autofaccn.readthedocs.io/en/latest/index.html</a>.</li>
				<li><strong class="bold">Simple Injector</strong>: This <a id="_idIndexMarker433"/>is one <a id="_idIndexMarker434"/>of the late entrants on the list. The documentation <a id="_idIndexMarker435"/>can be found at the following link: <a href="https://simpleinjector.readthedocs.io/en/latest/index.html">https://simpleinjector.readthedocs.io/en/latest/index.html</a>.</li>
				<li><strong class="bold">Castle Windsor</strong>: This <a id="_idIndexMarker436"/>is one <a id="_idIndexMarker437"/>of the oldest DI frameworks available for .NET. See <a id="_idIndexMarker438"/>its documentation at the following link: <a href="http://www.castleproject.org/projects/windsor/">http://www.castleproject.org/projects/windsor/</a>.</li>
			</ul>
			<p>Though there are a few differences between these frameworks, there is generally feature parity. It is mostly the developer's experience that determines the choice of framework.</p>
			<p>In the next section, let's see how to leverage the Autofac third-party IoC container.</p>
			<h3>Autofac IoC container</h3>
			<p>Autofac is one <a id="_idIndexMarker439"/>of the most popular IoC containers among the developer community. As with any other IoC container, it manages dependencies between <a id="_idIndexMarker440"/>classes so that applications remain easy to change as they grow in complexity and size. Let's learn how to use Autofac to register the same <code>WeatherProvider</code> service that we used earlier in this chapter. Proceed as follows:</p>
			<ol>
				<li value="1">Create a new project using the ASP.NET Core web API template and name it <code>AutofacSample</code>.</li>
				<li>Add the <code>Autofac.Extensions.DependencyInjection</code> NuGet package reference to the <code>AutofacSample</code> project, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_5.5_B18507.jpg" alt="Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package</p>
			<ol>
				<li value="3">We need to register <code>AutofacServiceProviderFactory</code> with <code>ConfigureHostBuilder</code> so that the runtime will use the Autofac IoC container. In <code>Program.cs</code>, register the Autofac SP factory, as shown in the following code snippet:<pre>builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());</pre></li>
				<li>Now, let's register the <code>IWeatherProvider</code> service that we used in the <em class="italic">Types of DI</em> section with the Autofac container. Call the <code>ConfigureContainer</code> method on the <code>ConfigureHostBuilder</code> property of <code>WebApplicationBuilder</code> in <code>Program.cs</code> to register <code>IWeatherProvider</code> with the <code>WeatherProvider</code> implementation, as follows:<pre>builder.Host.ConfigureContainer&lt;ContainerBuilder&gt;(builder =&gt;
{
    builder.RegisterType&lt;WeatherProvider&gt;()
                    .As&lt;IWeatherProvider&gt;();
});</pre></li>
				<li>Similar to the <a id="_idIndexMarker441"/>default .NET IoC container, we get the <code>IWeatherForecast</code> service injected into the <code>WeatherForecastController</code> controller, as shown in the following code snippet:<pre>public class WeatherForecastController : ControllerBase
{
        private readonly ILogger&lt;WeatherForecastController&gt; _logger;
        <strong class="bold">private readonly IWeatherProvider weatherProvider;</strong>
        public WeatherForecastController( ILogger&lt;WeatherForecastController&gt; logger,
<strong class="bold">IWeatherProvider weatherProvider</strong>)
        {
            _logger = logger;
            <strong class="bold">this.weatherProvider = weatherProvider;</strong>
        }
        [HttpGet]
        public IEnumerable&lt;WeatherForecast&gt; Get()
        {
            <strong class="bold">return weatherProvider.GetForecast();</strong>
        }
}</pre></li>
			</ol>
			<p>Now, when <a id="_idIndexMarker442"/>you run the project and navigate to the <code>https://localhost:7184/WeatherForecast</code> <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>), you will <a id="_idIndexMarker443"/>see the output in the browser, as follows:</p>
			<div><div><img src="img/Figure_5.6_B18507.jpg" alt="Figure 5.6 – Final output for the container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Final output for the container</p>
			<p>In the previous example, we have seen the use of the third-party Autofac IoC container in place of the default container provided by .NET 6.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor454"/>Summary</h1>
			<p>This chapter introduced you to the concepts of DI, which helps to write loosely coupled, more testable, and more readable code. This chapter covered the types of DI and how they are supported in ASP.NET Core 6. We have also seen how object lifetime is managed with different types of registrations. This chapter also introduced you to some of the popular third-party IoC containers available to further explore. We will be using the concepts learned in this chapter to build our e-commerce application. In <a href="B18507_15_Epub.xhtml#_idTextAnchor1803"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing</em>, we will also see how DI can help with testability.</p>
			<p>As recommended in <a href="B18507_01_Epub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing and Architecting the Enterprise Application</em>, under the <em class="italic">Separation of concerns/single - responsibility architecture</em> section, we always try to have services registered via interfaces. This will help with changing the concrete implementation at any time without changing the client implementation.</p>
			<p>In the next chapter, we will learn how to configure .NET 6 and understand the different configurations while learning how to build a custom one.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor455"/>Questions</h1>
			<ol>
				<li value="1">Which of the following is not a framework service?</li>
			</ol>
			<p>a. <code>IConfiguration</code></p>
			<p>b. <code>IApplicationBuilder</code></p>
			<p>c. <code>IWeatherService</code></p>
			<p>d. <code>IWebHostEnvironment</code></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="2">True or false: DI is one of the mechanisms to achieve IoC.</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="3">True or false: An injected service can depend on a service that has a shorter life span than its own.</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="4">Which of the following is not a valid lifetime scope of ASP.<a id="_idTextAnchor456"/><a id="_idTextAnchor457"/><a id="_idTextAnchor458"/><a id="_idTextAnchor459"/><a id="_idTextAnchor460"/><a id="_idTextAnchor461"/><a id="_idTextAnchor462"/><a id="_idTextAnchor463"/><a id="_idTextAnchor464"/><a id="_idTextAnchor465"/><a id="_idTextAnchor466"/><a id="_idTextAnchor467"/><a id="_idTextAnchor468"/><a id="_idTextAnchor469"/><a id="_idTextAnchor470"/>NET Core 6 IoC container?</li>
			</ol>
			<p>a. Scoped</p>
			<p>b. Singleton</p>
			<p>c. Transient</p>
			<p>d. Dynamic</p>
			<p><strong class="bold">Answer: d</strong></p>
		</div>
	</body></html>