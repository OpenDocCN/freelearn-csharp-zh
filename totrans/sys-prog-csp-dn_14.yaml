- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: The One with the Linux Leaps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux飞跃篇
- en: '*Systems Programming in C#* *on Linux*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Linux上使用C#进行系统编程*'
- en: I remember the time when only the really cool kids worked on Linux. Windows
    was for serious people. That was where the work was done. Sure, many servers ran
    Unix or Linux, but those working on those platforms were considered somewhat weird.
    They usually had beards, wore sandals, and spoke a language none of the rest of
    the people had ever heard.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得只有真正酷炫的孩子才会使用Linux。Windows是严肃人士的选择。那里才是工作的场所。当然，许多服务器运行Unix或Linux，但那些平台上工作的人被认为有些奇怪。他们通常有胡须，穿凉鞋，说一种其他人从未听过的语言。
- en: OK, maybe I am exaggerating. Perhaps this shows how I felt about Linux or how
    intimidated I was by that operating system and its users. Linux has always been
    considered a more mature but complex operating system. It is more secure, faster,
    and better to maintain. It is also more complicated to use. Most of the work is
    done in the command line, although graphical user interfaces exist.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许我有点夸张。这可能表明了我对Linux的感受，或者我有多么被那个操作系统及其用户吓到。Linux一直被认为是一个更成熟但更复杂的操作系统。它更安全，速度更快，维护性更好。但使用起来也更复杂。大部分工作都是在命令行中完成的，尽管也存在图形用户界面。
- en: These days, things are different. Linux is everywhere. And for good reasons,
    too – Linux is an excellent operating system to run your system in the current
    online, connected world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，情况不同了。Linux无处不在。而且有很好的理由——在当前这个在线、互联的世界中，Linux是一个出色的操作系统来运行你的系统。
- en: With the introduction of **.NET Core** and **.NET 5**, developers who traditionally
    only used Windows can also compile their code to run on Linux. And that opens
    up a whole new world.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**.NET Core**和**.NET 5**的引入，那些传统上只使用Windows的开发者也可以将他们的代码编译在Linux上运行。这开辟了一个全新的世界。
- en: Of course, there are downsides. Linux is more complex than Windows, especially
    if you have worked on Windows for a long time. Even though .NET can run on Linux,
    not all the classes and tools you might be used to are available.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有缺点。Linux比Windows复杂，尤其是如果你长时间在Windows上工作。尽管.NET可以在Linux上运行，但并不是你习惯的所有类和工具都可用。
- en: This chapter is meant to help you get on your way should you want to run your
    .NET applications on Linux. Don’t worry – I do not want you to start wearing sandals
    or become a typical 1970s-type developer. That is entirely optional. So, let’s
    get your inner penguin out and start hacking on Linux!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这章旨在帮助你入门，如果你想在Linux上运行你的.NET应用程序。别担心——我不想让你开始穿凉鞋或成为一个典型的1970年代类型的开发者。这完全是可选的。所以，让我们释放你内心的企鹅，开始在Linux上编程！
- en: 'In this chapter, we will ask the following questions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提出以下问题：
- en: What is Linux?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Linux？
- en: How do I do basic things in Linux?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何在Linux中做基本的事情？
- en: How do I develop for Linux?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何为Linux进行开发？
- en: How do I deploy to Linux?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何部署到Linux？
- en: How can I write background services for Linux?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何为Linux编写后台服务？
- en: This chapter contains some history, some theory, and a lot of practical information
    and samples. Are you ready to follow along?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含一些历史，一些理论，以及大量的实用信息和示例。你准备好了吗？
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will find all the code in this chapter in our repository at this URL: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下URL的我们的仓库中找到本章的所有代码：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14)。
- en: If you want to follow along, you need a Linux machine. But during development,
    you actually do not need that. All you need is WSL. **WSL** stands for **Windows
    Subsystem for Linux**. The official name is WSL2, as we are at version 2 these
    days, but let’s stick with WSL here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟上，你需要一台Linux机器。但在开发过程中，你实际上并不需要。你只需要WSL。**WSL**代表**Windows Subsystem for
    Linux**。官方名称是WSL2，因为我们现在处于版本2，但在这里我们还是用WSL。
- en: WSL is a lightweight virtual machine that runs a Linux distribution (I will
    explain what that is later on) on your Windows machine. You can quickly move to
    that machine and use it like a “real” Linux machine. You can even deploy directly
    from Visual Studio and debug your apps on WSL.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: WSL是一个轻量级的虚拟机，可以在你的Windows机器上运行Linux发行版（我稍后会解释这是什么）。你可以快速切换到这台机器，就像使用“真正的”Linux机器一样。你甚至可以直接从Visual
    Studio部署并调试你的应用程序在WSL上。
- en: 'To install WSL, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装WSL，请按照以下步骤操作：
- en: In Powershell, use the `wsl --install` command (you have to be an administrator
    to do this). Be aware that this might take a couple of gigabytes of hard disk
    space on your machine.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Powershell 中，使用 `wsl --install` 命令（你必须是一位管理员才能这样做）。请注意，这可能会占用你机器上几吉字节的空间。
- en: 'And that’s it. No *step 2*. You can now go to the `Ubuntu`. That looks like
    this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。没有 *第二步*。你现在可以进入 `Ubuntu`。看起来是这样的：
- en: "![Figure 1\uFEFF4.1: Running Ubuntu from the Windows Start menu](img/B20924_15_1.jpg)"
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4.1：从 Windows 开始菜单运行 Ubuntu](img/B20924_15_1.jpg)'
- en: 'Figure 14.1: Running Ubuntu from the Windows Start menu'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：从 Windows 开始菜单运行 Ubuntu
- en: Alternatively, you can install other versions of Linux, but I will use **Ubuntu
    20.04** in this book. What you pick doesn’t matter; just do what you feel most
    comfortable with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以安装其他版本的 Linux，但在这本书中，我将使用 **Ubuntu 20.04**。你选择什么并不重要；只要做你感到最舒服的事情即可。
- en: Alternatively, you can create a virtual machine using HyperV, deploy a Docker
    container with Linux, get a second machine to install Linux on, or run Linux from
    a bootable USB stick. The choice is yours.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 HyperV 创建虚拟机，部署带有 Linux 的 Docker 容器，获取第二台安装 Linux 的机器，或者从可启动的 USB 驱动器运行
    Linux。选择权在你。
- en: An overview of Linux
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 概述
- en: Before discussing how to program for Linux, we should discuss what it is. The
    short answer is that it is an operating system. While that is absolutely true,
    it does not sufficiently explain all that Linux can do. I can say that a bike
    is a transporting device, but that also applies to the Saturn 5 rocket that took
    astronauts to the moon. We need a bit more information.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何为 Linux 编程之前，我们应该讨论它是什么。简短的答案是它是一个操作系统。虽然这是绝对正确的，但它并没有充分解释 Linux 可以做什么。我可以说自行车是一种交通工具，但这同样适用于将宇航员送往月球的土星
    5 号火箭。我们需要更多的信息。
- en: A short history of Linux
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 简史
- en: 'The history of Linux is quite fascinating. Understanding the timeline and circumstances
    under which it was developed can help you appreciate some of the design decisions
    and choices. So, here is a short timeline of the history of Linux:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的历史非常引人入胜。了解其开发的时间和背景可以帮助你欣赏一些设计决策和选择。因此，以下是 Linux 历史的简要时间线：
- en: '**Early beginnings**'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**早期开始**'
- en: In 1983, Richard Stallman announced the GNU Project. The idea was to create
    a free Unix-like operating system. Unix was the leading operating system in those
    days. The GNU Project developed many components, but one key piece, the kernel,
    was missing.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1983 年，Richard Stallman 宣布了 GNU 项目。想法是创建一个免费的类 Unix 操作系统。Unix 是当时领先的操作系统。GNU
    项目开发了众多组件，但一个关键部分，内核，是缺失的。
- en: In 1987, Andrew S. Tanenbaum created Minix. Minix was a Unix-like system. It
    was intended for educational purposes and was very popular among students. One
    of them was a young man named Linus Torvalds.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1987 年，Andrew S. Tanenbaum 创建了 Minix。Minix 是一个类 Unix 系统。它旨在教育目的，并且在学生中非常受欢迎。其中之一是一个名叫
    Linus Torvalds 的年轻人。
- en: '**The birth** **of Linux**'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Linux 的诞生**'
- en: In 1991, Linus Torvalds, a student at the University of Helsinki in Finland,
    started developing his kernel. It was just a hobby; he wanted to have something
    to do. On August 25, 1991, he announced his project in a newsgroup posting, seeking
    input from others. This is what later became the Linux kernel.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1991 年，芬兰赫尔辛基大学的 Linus Torvalds 学生开始开发他的内核。这只是个爱好；他想要有事情做。1991 年 8 月 25 日，他在一个新闻组帖子中宣布了他的项目，寻求他人的意见。这就是后来成为
    Linux 内核的东西。
- en: On 5th October, 1991, Torvalds released version 0.02 of Linux. It could run
    Bash (a terminal) and GCC (a C-compiler).
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1991 年 10 月 5 日，Torvalds 发布了 Linux 的 0.02 版本。它可以运行 Bash（一个终端）和 GCC（一个 C 编译器）。
- en: '**Development** **and growth**'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发展和增长**'
- en: In 1992, Linux was released under the GNU **General Public License** (**GPL**),
    allowing anyone to use, modify, and distribute the software.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1992 年，Linux 在 GNU **通用公共许可证**（**GPL**）下发布，允许任何人使用、修改和分发该软件。
- en: In the mid 1990s, Linux snowballed in popularity. Distributions, such as Slackware
    and Debian, were both released in 1993.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1990 年代中期，Linux 的受欢迎程度迅速增长。Slackware 和 Debian 这样的发行版都在 1993 年发布。
- en: In 1994, Linux version 1.0 was released. It was a significant milestone; this
    was the first stable release.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1994 年，Linux 1.0 版本发布。这是一个重要的里程碑；这是第一个稳定版本。
- en: '**Commercial and** **community expansion**'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**商业和** **社区扩展**'
- en: In 1996, Tux the Penguin was chosen as the official Linux mascot.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1996 年，Tux企鹅被选为官方 Linux 图标。
- en: The late 1990s saw companies such as Red Hat and SUSE begin to offer commercial
    Linux distributions. Since these also included support, this was the moment enterprises
    jumped on board.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1990年代末，像红帽和SUSE这样的公司开始提供商业Linux发行版。由于这些发行版还包括支持，这是企业纷纷加入的时刻。
- en: In 1999, IBM announced support for Linux.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1999年，IBM宣布支持Linux。
- en: '**The 21st century and** **mainstream adoption**'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**21世纪和** **主流采用**'
- en: In 2001, version 2.4 of the Kernel was released, including USB, PC cards, and
    other hardware support.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2001年，内核的2.4版本发布，包括USB、PC卡和其他硬件支持。
- en: 2002–2003 saw major companies such as HP and Dell offering Linux on their servers.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2002-2003年，惠普和戴尔等大型公司开始在他们的服务器上提供Linux。
- en: In 2004, Canonical released its Linux distribution, which was way more user-friendly.
    This enabled the general public to use it as well.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2004年，Canonical发布了其Linux发行版，它更加用户友好。这使得普通公众也能使用它。
- en: In 2005, Linus Torvalds released a side project called Git. Yes, that Git. The
    tool you probably use every day. Git was an essential tool for Linux development.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2005年，林纳斯·托瓦兹发布了一个名为Git的侧项目。是的，就是那个Git。你可能每天都在使用的工具。Git是Linux开发的一个关键工具。
- en: '**The** **modern era**'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现代时代**'
- en: In 2011, Linux was the dominant operating system in the server market. It powers
    the majority of web servers, including those of major companies such as Google,
    Amazon, and Facebook.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2011年，Linux成为服务器市场的主导操作系统。它为包括谷歌、亚马逊和Facebook等大型公司的多数网站服务器提供动力。
- en: In 2013, Google released Android, a mobile, Linux-based smartphone operating
    system.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2013年，谷歌发布了Android，这是一个基于Linux的移动智能手机操作系统。
- en: In the 2020s, Linux continues to dominate the server space, cloud infrastructure,
    supercomputing, and IOT devices.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2020年代，Linux继续主导服务器空间、云基础设施、超级计算和物联网设备。
- en: One of the key factors that led to the success of Linux was its open source
    nature. Everybody can look at the sources, download them, adopt them, and do whatever
    they want. And it is and always will be for free.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 导致Linux成功的关键因素之一是其开源性质。每个人都可以查看源代码，下载它们，采用它们，并做他们想做的事情。而且它始终是免费的。
- en: Will all this in mind, it is no wonder that we, as system programmers, also
    need to learn about Linux.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们作为系统程序员，也需要了解Linux，这毫不奇怪。
- en: What is Linux?
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Linux？
- en: The name Linux itself can be confusing at times. Let me shed some light on that
    and help you clarify things.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Linux这个名字有时可能会让人困惑。让我来澄清一下，并帮助你弄清楚。
- en: The Linux kernel
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux内核
- en: 'The **Linux kernel** is the heart of what we call Linux. It is the core of
    the operating system. The kernel manages the systems’ hardware and resources,
    such as memory and CPUs. Some of the key responsibilities of the Kernel are as
    follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux内核**是我们所说的Linux的核心。它是操作系统的核心。内核管理系统的硬件和资源，如内存和CPU。内核的一些关键职责如下：'
- en: '**Process management**: It decides which process runs and for how long'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程管理**：它决定哪个进程运行以及运行多长时间'
- en: '**Memory management**: It keeps track of every byte in the systems’ memory
    and manages the allocation and deallocation of memory space'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：它跟踪系统内存中的每一个字节，并管理内存空间的分配和释放'
- en: '**Device management**: It manages communications with all devices attached
    to the system'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备管理**：它管理与系统连接的所有设备的通信'
- en: '**System calls**: It also provides an interface between the aforementioned
    systems and the applications that want to use them'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统调用**：它还提供了一个上述系统和希望使用它们的应用程序之间的接口'
- en: The kernel is comparable with the **Windows** **NT kernel**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内核可以与**Windows NT内核**相媲美。
- en: Other components
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他组件
- en: 'Linux usually comes with a set of other components as well. Some of the most
    commonly found components are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通常还附带一系列其他组件。以下是一些最常见的组件：
- en: '**System libraries**: These are essential collections of functions that programs
    can use to perform tasks, such as file handling and mathematical computations.
    A good example is the GNU C library, the foundation for most C or C++ programs.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统库**：这些是程序可以用来执行任务（如文件处理和数学计算）的必要函数集合。一个好的例子是GNU C库，它是大多数C或C++程序的基础。'
- en: '`init` program. This program manages system startup. Other examples are Bash,
    a shell program, and various command-line tools.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`程序。这个程序管理系统启动。其他例子包括Bash，一个shell程序，以及各种命令行工具。'
- en: '**Daemons**: These are background services that perform various tasks, such
    as handling print jobs, managing network connections, or scheduling tasks.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程**：这些是在后台执行各种任务的背景服务，例如处理打印作业、管理网络连接或安排任务。'
- en: Bash? What is that?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 是什么？
- en: Names of software or parts in Linux differ from the names you’ll find in Windows.
    Windows is more serious in its naming, while Linux is more playful. **Bash**,
    for instance, stands for **Bourne Again Shell**, named after its creator, Stephen
    Bourne. He wanted to create a better shell than the most used shell back then
    – the Thompson shell. So he merged “born again” with his own surname and came
    up with this new name. You’ll find these kinds of names a lot when working with
    Linux!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中软件或部分的名称与你在 Windows 中找到的名称不同。Windows 在命名上更为严肃，而 Linux 则更为俏皮。例如，**Bash**
    代表 **Bourne Again Shell**，以其创造者 Stephen Bourne 命名。他希望创造一个比当时最常用的 shell（Thompson
    shell）更好的 shell。因此，他将“再生”与自己的姓氏合并，得出了这个新名字。当你与 Linux 一起工作时，你会经常发现这类名称。
- en: There are a lot more components, and sometimes, the choice of where to place
    components might seem arbitrary. But in general, this distinction works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多更多的组件，有时，选择放置组件的位置可能看起来是随意的。但总的来说，这种区分是有效的。
- en: Added software
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加的软件
- en: When you install Linux, you often get a lot more software. These are the user-facing
    programs and the software that the users interact with. There are command-line-based
    programs and GUI-based programs. Which ones are distributed depends on what package
    you have downloaded or purchased.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Linux 时，你通常会获得很多软件。这些是面向用户的程序以及用户与之交互的软件。有基于命令行的程序和基于图形用户界面的程序。哪些被分发取决于你下载或购买的是哪个软件包。
- en: Distributions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发行版
- en: A Linux `Ubuntu` in the Windows Store and click **Get**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 商店中找到 Linux `Ubuntu` 并点击 **获取**。
- en: 'Hundreds of distros are available, mostly for free, but some you have to pay
    for. The following table is a list of the most used distros, grouped by usage
    category:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百个发行版可供选择，大多数是免费的，但有些需要付费。以下表格是按使用类别分组的最常用发行版的列表：
- en: '| **Category** | **Distribution** | **Description** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **发行版** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **General** **desktop use** | Ubuntu | Known for its user-friendliness, large
    community, and robust support |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **通用** **桌面使用** | Ubuntu | 以其用户友好性、庞大社区和强大的支持而闻名 |'
- en: '|  | Linux Mint | Based on Ubuntu, popular due to its ease of use and traditional
    desktop environment |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  | Linux Mint | 基于 Ubuntu，因其易用性和传统的桌面环境而受欢迎 |'
- en: '|  | Fedora | Known for its cutting-edge features and close relationship with
    Red Hat |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  | Fedora | 以其前沿特性和与 Red Hat 的紧密关系而闻名 |'
- en: '| **Lightweight** | Lubuntu | A lighter, faster, and energy-saving variant
    of Ubuntu that uses LXQt |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **轻量级** | Lubuntu | Ubuntu 的一个更轻、更快、节能的变体，使用 LXQt |'
- en: '|  | Xubuntu | An official Ubuntu variant that uses the XFCE desktop environment
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  | Xubuntu | 一种官方的 Ubuntu 变体，使用 XFCE 桌面环境 |'
- en: '|  | Puppy Linux | Extremely lightweight, designed to run on older hardware
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  | Puppy Linux | 极其轻量级，设计用于在较旧的硬件上运行 |'
- en: '| **Privacy** **and security** | Tails | Aimed at preserving privacy and anonymity,
    based on Debian |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **隐私** **和安全** | Tails | 以保护隐私和匿名性为目标，基于 Debian |'
- en: '|  | Qubes OS | Focuses on security through isolation, using virtual machines
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  | Qubes OS | 通过隔离来关注安全性，使用虚拟机 |'
- en: '|  | Kali Linux | Designed for penetration testing and security auditing |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  | Kali Linux | 设计用于渗透测试和安全审计 |'
- en: '| **Server** **and enterprise** | CentOS/AlmaLinux/Rocky Linux | Community-supported
    rebuilds of **Red Hat Enterprise** **Linux** (**RHEL**) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **服务器** **和企业** | CentOS/AlmaLinux/Rocky Linux | 由社区支持的 Red Hat Enterprise
    Linux (RHEL) 的重建版本 |'
- en: '|  | Ubuntu Server | The server edition of Ubuntu, known for its ease of use
    and broad support |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  | Ubuntu Server | Ubuntu 的服务器版本，以其易用性和广泛的支持而闻名 |'
- en: '|  | Debian | Known for its stability and robustness, often used on servers
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  | Debian | 以其稳定性和健壮性而闻名，常用于服务器 |'
- en: '| **Development** | Arch Linux | Favored by developers for its simplicity and
    control |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **开发** | Arch Linux | 开发者因其简洁性和控制性而青睐 |'
- en: '|  | Fedora | Offers cutting-edge software and technologies |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  | Fedora | 提供前沿的软件和技术 |'
- en: '|  | openSUSE | Known for its developer-friendly tools and YaST configuration
    tool |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  | openSUSE | 以其开发者友好的工具和 YaST 配置工具而闻名 |'
- en: '| **Media** **production** | Ubuntu Studio | Specifically tailored for audio,
    video, and graphic design |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **媒体** **制作** | Ubuntu Studio | 专门针对音频、视频和图形设计定制 |'
- en: '|  | AV Linux | Custom-built for multimedia content creators |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  | AV Linux | 为多媒体内容创作者定制构建 |'
- en: '|  | Fedora Design Suite | Comes with a range of open source creative applications
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  | Fedora Design Suite | 随带一系列开源创意应用程序 |'
- en: '| **Education** | Edubuntu | An Ubuntu flavor designed for use in classrooms
    and educational environments |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **教育** | Edubuntu | 一种为教室和教育环境设计的Ubuntu版本 |'
- en: '|  | Kano OS | Designed for use with the Kano computer kit, aimed at teaching
    kids how to code |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  | Kano OS | 为Kano电脑套件设计，旨在教授孩子们如何编程 |'
- en: '|  | Debian Edu/Skolelinux | A custom Debian Pure Blend, designed for educational
    use |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  | Debian Edu/Skolelinux | 一种定制的Debian纯净混合版本，专为教育用途设计 |'
- en: '| **Gaming** | SteamOS | Developed by the Valve Corporation for gaming consoles
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **游戏** | SteamOS | 由Valve公司为游戏机开发 |'
- en: '|  | Ubuntu GamePack | Comes pre-installed with many games and emulators |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  | Ubuntu GamePack | 预装了许多游戏和模拟器 |'
- en: '|  | Lakka | A lightweight Linux distribution that transforms a small computer
    into a full-blown game console |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  | Lakka | 一种轻量级的Linux发行版，可以将小型计算机转变为完整的游戏机 |'
- en: '| **Special** **Purpose** | Raspberry Pi OS (formerly Raspbian) | Optimized
    for the Raspberry Pi hardware |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **特殊用途** | Raspberry Pi OS（以前称为Raspbian） | 优化用于Raspberry Pi硬件 |'
- en: '|  | Clear Linux | Developed by Intel, optimized for performance and security
    on Intel hardware |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  | Clear Linux | 由英特尔开发，针对英特尔硬件的性能和安全性进行优化 |'
- en: '|  | Tiny Core Linux | An extremely small, highly modular, and flexible Linux
    distribution |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  | Tiny Core Linux | 一种极小、高度模块化和灵活的Linux发行版 |'
- en: 'Table 14.1: Some of the available Linux distros'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1：一些可用的Linux发行版
- en: As you can see, there is a distro tailored just for you. However, remember that
    the kernel is probably the same or at least very similar for all of them. The
    biggest difference between the distros is the added software and the configuration
    you get out of the box.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有一个针对你定制的发行版。然而，请记住，内核对于所有这些可能都是相同的，或者至少非常相似。发行版之间最大的区别是提供的软件和开箱即得的配置。
- en: A quick primer to use Linux
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Linux的快速入门指南
- en: In the early days of my career, I knew I was very good with computers. They
    held no surprises for me. I knew how to control them; I was the master of the
    machine. That lasted until I sat behind my first Linux machine. That was when
    I realized I only knew a lot about Windows and how to use that platform. I was
    at a loss. I could not even get the contents of a directory on the screen.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯早期，我知道我对电脑非常在行。它们对我来说没有惊喜。我知道如何控制它们；我是机器的主人。这种情况一直持续到我第一次坐在Linux机器后面。那时我意识到我只了解Windows以及如何使用该平台。我感到迷茫。我甚至无法在屏幕上获取目录的内容。
- en: To my defense, this was in the early 1990s. Linux was just released, and we
    did not have the wealth of information online that we have today. The World Wide
    Web had just been invented, search engines did not exist, and information was
    hard to find. Today, things are more straightforward – there are tons of sources
    out there that can help you get up to speed with something new.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自我辩护，这发生在20世纪90年代初。Linux刚刚发布，我们没有今天这样丰富的在线信息。万维网刚刚被发明，搜索引擎不存在，信息很难找到。今天，事情更加简单——有大量的资源可以帮助你快速掌握新事物。
- en: I’m going to help you learn some of the basics so that you can play around with
    Linux without pulling your hair out. I am not going to discuss any of the available
    GUI systems. There are plenty of them, and some of them are very good. But using
    them is as easy as using Windows. Honestly, real work happens when you are on
    a command line. So, that is what I focus on from now on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我将帮助你学习一些基础知识，这样你就可以在Linux系统上随意操作而不会感到烦恼。我不会讨论任何可用的图形用户界面系统。它们有很多，其中一些非常好。但是使用它们就像使用Windows一样简单。说实话，真正的工作是在命令行上完成的。所以，从现在开始，我将专注于这一点。
- en: 'I also assume you have figured out how to install WSL on your machine and can
    open a Terminal. I also have a tip – install the Windows Terminal from the Windows
    Store. The Windows Terminal is an excellent tool for opening different shells,
    including Linux ones. This is what it looks like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我还假设你已经知道了如何在你的机器上安装WSL并可以打开一个终端。我还有一个建议——从Windows Store安装Windows Terminal。Windows
    Terminal是一个打开不同shell（包括Linux shell）的出色工具。它看起来是这样的：
- en: "![Figure 1\uFEFF4.2: A Terminal application opening a new Linux shell](img/B20924_15_2.jpg)"
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2：一个终端应用程序打开新的Linux shell](img/B20924_15_2.jpg)'
- en: 'Figure 14.2: A Terminal application opening a new Linux shell'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：一个终端应用程序打开新的Linux shell
- en: You can open multiple windows, each with its shell. You can open a PowerShell
    window next to a Ubuntu window and even the old-style Command Prompt. You have
    everything you need ready at your fingertips.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开多个窗口，每个窗口都有自己的shell。你可以在Ubuntu窗口旁边打开一个PowerShell窗口，甚至还可以打开旧式的命令提示符。你需要的一切都随时可用。
- en: Casing – beware!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大小写——小心！
- en: Before we dive into the commands, there is one thing you should know – *Linux
    is case-sensitive; Windows is not*. Trust me – this has tripped up many people
    in the past and will probably confuse people in the future. So, keep this in mind.
    A directory can have two files with the same name that only differ in casing.
    It is possible to have the `MyAwesomeApp` and `myAwesomeApp` files in the same
    place. If you come from a Windows background, you will often make this mistake;
    you cannot find a file that you know is there, which I see a lot. Check your casing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入命令之前，有一件事你应该知道——*Linux 是大小写敏感的；Windows 不是*。相信我——这曾经让很多人陷入困境，将来可能会让更多的人感到困惑。所以，请记住这一点。一个目录可以有两个大小写不同的同名文件。在同一个地方可以有
    `MyAwesomeApp` 和 `myAwesomeApp` 文件。如果你来自 Windows 背景，你经常会犯这个错误；你找不到你知道存在的文件，我经常看到这种情况。检查你的大小写。
- en: If you have chosen a Terminal, open the shell for Linux. Now, you are ready
    to try out some commands!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了终端，打开 Linux 的 shell。现在，你准备好尝试一些命令了！
- en: Basic commands
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本命令
- en: I want to give you a list of the most used Linux commands with their equivalents
    on Windows. But before diving into those lists, I want to share the best command
    – `man`. This keyword opens the manual pages for any command you want to learn
    more about. For instance, the equivalent of `dir` on Windows is `ls`. Type `man
    ls` and press *Enter* to learn more about it. Doing this results in pages and
    pages of information about the command, parameters, and examples. This works for
    almost all commands.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你一个最常用 Linux 命令及其在 Windows 上的等价命令的列表。但在深入这些列表之前，我想分享最好的命令——`man`。这个关键字可以打开任何你想要了解更多信息的命令的手册页面。例如，Windows
    上 `dir` 的等价命令是 `ls`。输入 `man ls` 并按 *Enter* 键来了解更多信息。这样做会产生关于命令、参数和示例的页页信息。这几乎适用于所有命令。
- en: Basic navigation and file management
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本导航和文件管理
- en: 'Navigating the filesystem is probably essential when using an OS. For Linux,
    you should know these commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用操作系统时，导航文件系统可能是必不可少的。对于 Linux，你应该知道这些命令：
- en: '| **Task** | **Windows command** | **Linux command** | **Description** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **Windows 命令** | **Linux 命令** | **描述** |'
- en: '| **List** **directory contents** | `dir` | `ls` | Lists files and directories
    in the current path |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **列出目录内容** | `dir` | `ls` | 列出当前路径中的文件和目录 |'
- en: '| **Change directory** | `cd` | `cd` | Changes the current directory |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **更改目录** | `cd` | `cd` | 更改当前目录 |'
- en: '| **Print** **working directory** | `cd` | `pwd` | Displays the current directory
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **打印** **工作目录** | `cd` | `pwd` | 显示当前目录 |'
- en: '| **Copy files** | `copy` | `cp` | Copies files |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **复制文件** | `copy` | `cp` | 复制文件 |'
- en: '| **Move/rename files** | `move` | `mv` | Moves or renames files |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **移动/重命名文件** | `move` | `mv` | 移动或重命名文件 |'
- en: '| **Delete files** | `del` or `erase` | `rm` | Removes files |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **删除文件** | `del` 或 `erase` | `rm` | 删除文件 |'
- en: '| **Delete directories** | `rmdir` or `rd` | `rmdir` or `rm -r` | Removes directories
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **删除目录** | `rmdir` 或 `rd` | `rmdir` 或 `rm -r` | 删除目录 |'
- en: '| **Create directories** | `mkdir` | `mkdir` | Creates directories |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **创建目录** | `mkdir` | `mkdir` | 创建目录 |'
- en: 'Table 14.2: Navigation and file management commands'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2：导航和文件管理命令
- en: The commands work more or less as you would expect. So, try them!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的工作方式大致如你所期望。所以，试试它们！
- en: File viewing and editing
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件查看和编辑
- en: 'If you want to learn more about the contents of a file or edit the contents,
    these commands are there to do just that:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于文件内容的信息或编辑文件内容，这些命令正是为此而设计的：
- en: '| **Task** | **Windows c****ommand** | **Linux command** | **Description**
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **Windows 命令** | **Linux 命令** | **描述** |'
- en: '| **View** **file contents** | `type` | `cat` | Displays file contents |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **查看文件内容** | `type` | `cat` | 显示文件内容 |'
- en: '| **Edit files** | `notepad` | `nano`, `vi`, or `vim` | Edits files |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **编辑文件** | `notepad` | `nano`, `vi`, 或 `vim` | 编辑文件 |'
- en: '| **View file** **contents (paged)** | `more` | `less` | Views file contents
    page by page |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **分页查看文件内容** | `more` | `less` | 分页查看文件内容 |'
- en: 'Table 14.3: File viewing and editing'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.3：文件查看和编辑
- en: A word of warning – if you start using VI or VIM for the first time, ensure
    that you have a web page open with the commands to use in those tools. Working
    with those tools can be pretty complicated when you have no experience with them!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点警告——如果你第一次开始使用 VI 或 VIM，确保你有一个打开的网页，上面有这些工具中要使用的命令。如果你没有这些工具的经验，使用这些工具可能会相当复杂！
- en: System information and processes
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统信息和进程
- en: 'If you want to learn more about the system you are on or are keen to learn
    about the running processes, give these commands a try:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于你所使用的系统或对正在运行的过程感兴趣，可以尝试以下命令：
- en: '| **Task** | **Windows command** | **Linux command** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **Windows命令** | **Linux命令** | **描述** |'
- en: '| **Display** **system info** | `systeminfo` | `uname -a` | Displays system
    information |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **显示** **系统信息** | `systeminfo` | `uname -a` | 显示系统信息 |'
- en: '| **Display** **process info** | `tasklist` | `ps` | Lists running processes
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **显示** **进程信息** | `tasklist` | `ps` | 列出正在运行的进程 |'
- en: '| **Kill processes** | `taskkill` | `kill` | Terminates processes |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **终止进程** | `taskkill` | `kill` | 终止进程 |'
- en: '| **Show** **disk usage** | `dir` `or chkdsk` | `df` | Displays disk space
    usage |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **显示** **磁盘使用情况** | `dir` `或 chkdsk` | `df` | 显示磁盘空间使用情况 |'
- en: '| **Show** **file size** | `dir` | `du` | Displays file and directory sizes
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **显示** **文件大小** | `dir` | `du` | 显示文件和目录大小 |'
- en: 'Table 14.4: System information and process commands'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.4：系统信息和进程命令
- en: These commands are invaluable when you start to write your own software on Linux.
    Running these commands gives you a lot of information that you might need later
    on!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在Linux上编写自己的软件时，这些命令非常有价值。运行这些命令会给你提供很多你可能以后需要的信息！
- en: Network commands
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络命令
- en: 'As system programmers, we often work with networks or have our software communicate
    over networks. In those cases, it is good to know how to learn more about the
    network on our systems. These are commands that can help you:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统程序员，我们经常与网络一起工作，或者让我们的软件通过网络进行通信。在这些情况下，了解我们系统上的网络情况是很好的。以下是一些可以帮助你的命令：
- en: '| **Task** | **Windows command** | **Linux command** | **Description** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **Windows命令** | **Linux命令** | **描述** |'
- en: '| **Ping** | `ping` | `ping` | Checks network connectivity |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **Ping** | `ping` | `ping` | 检查网络连接 |'
- en: '| **IP configuration** | `ipconfig` | `ifconfig` or `ip` | Displays or configures
    IP network settings |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **IP配置** | `ipconfig` | `ifconfig` 或 `ip` | 显示或配置IP网络设置 |'
- en: '| **Trace route** | `tracert` | `traceroute` | Traces the path to a network
    host |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **跟踪路由** | `tracert` | `traceroute` | 跟踪到网络主机的路径 |'
- en: 'Table 14.5: Networking commands'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.5：网络命令
- en: Most of these commands are similar to their Windows counterparts, so you should
    have no problem remembering and using them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些命令与Windows的对应命令类似，所以你应该没有问题记住并使用它们。
- en: Package management
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包管理
- en: 'Many distros come packed with software, but it is very likely your distro might
    miss something that you may find invaluable. But don’t worry – Linux has tools
    to install them. This is a short list of some of them:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 许多发行版都预装了软件，但你的发行版可能缺少一些你可能认为非常有价值的东西。但别担心——Linux有工具可以安装它们。以下是一些简短的列表：
- en: '| **Task** | **Windows command** | **Linux c****ommand** | **Description**
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **Windows命令** | **Linux c****ommand** | **描述** |'
- en: '| **Install software** | Varies (e.g., `msiexec`) | `apt-get install`, `yum
    install`, or `dnf install` | Installs software packages |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **安装软件** | 多种方式（例如，`msiexec`） | `apt-get install`，`yum install` 或 `dnf install`
    | 安装软件包 |'
- en: '| **Update software** | Windows Update | `apt-get update` or `apt-get upgrade`
    | Updates software packages |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **更新软件** | Windows Update | `apt-get update` 或 `apt-get upgrade` | 更新软件包
    |'
- en: '| **Remove software** | Varies (e.g., Control Panel) | `apt-get remove`, `yum
    remove`, or `dnf remove` | Removes software packages |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **卸载软件** | 多种方式（例如，控制面板） | `apt-get remove`，`yum remove` 或 `dnf remove` |
    卸载软件包 |'
- en: 'Table 14.6: Package management commands'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.6：包管理命令
- en: You will run into these commands a lot more later on in this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章后面遇到这些命令更多。
- en: Elevated privileges
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升权限
- en: Linux is built around security. One of the effects is that you are more or less
    forced to run all the commands as a regular user. You are not an administrator,
    even though you logged in as one. You cannot do everything you want.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Linux围绕安全性构建。其中一个影响是，你或多或少被迫以普通用户身份运行所有命令。即使你以管理员身份登录，你也不是管理员。你不能做你想做的所有事情。
- en: You can easily change that. You can give yourself root privileges using the
    `su` command, meaning **super-user**. **Root** here means you are at the top level
    of all user rights; you can do anything you want. However, don’t do that. I have
    rarely had a reason to become the root of my systems. In the Linux community,
    becoming root is frowned upon.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地改变这一点。你可以使用`su`命令给自己赋予root权限，意味着**超级用户**。这里的**root**意味着你处于所有用户权限的最高级别；你可以做任何你想做的事情。然而，不要这样做。我很少有过成为系统root的理由。在Linux社区中，成为root是不受欢迎的。
- en: If you need to elevate your rights to do something, use the `sudo` command.
    This command stands for `sudo`. If so, you give the command the root rights it
    might need once, and then the system immediately returns to the normal privilege.
    Only the command on that line can use these elevated privileges.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要提升权限来做某事，请使用 `sudo` 命令。这个命令代表 `sudo`。如果是这样，你一次就给了命令可能需要的根权限，然后系统立即返回到正常权限。只有那一行的命令可以使用这些提升的权限。
- en: The first time you use `sudo` in a session, you must supply the administrative
    password you entered when installing your distro. Your system remembers those
    credentials for the duration of the session, so you do not have to do that every
    time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话中第一次使用 `sudo` 时，你必须提供你在安装你的发行版时输入的管理员密码。你的系统会记住这些凭证，直到会话结束，所以你不必每次都这样做。
- en: 'Let me show you how that works. I use the `whoami` command, which provides
    information about the currently logged-in user. If I use that command, it returns
    my name. However, when I do that again, I add `sudo` before it, and it returns
    `root`. Immediately after that, it reverts to returning my name. This screenshot
    shows that in action:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我展示一下它是如何工作的。我使用 `whoami` 命令，该命令提供有关当前登录用户的信息。如果我使用该命令，它会返回我的名字。然而，当我再次这样做时，我在它前面添加了
    `sudo`，它会返回 `root`。紧接着，它又恢复到返回我的名字。这个截图显示了这一过程：
- en: "![Figure 1\uFEFF4.3: Sudo in action](img/B20924_15_3.jpg)"
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4.3：Sudo 在行动](img/B20924_15_3.jpg)'
- en: 'Figure 14.3: Sudo in action'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4.3：Sudo 在行动
- en: As you can see, it also asks me for my password. If I issue the same or another
    command and use `sudo`, it will use the cached credentials. But remember that
    this is only valid in this session. If I open another Terminal window and repeat
    the same exercise, the system will ask me for my password again.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它也会要求我输入密码。如果我发出相同的或另一个命令并使用 `sudo`，它将使用缓存的凭证。但请记住，这仅在当前会话中有效。如果我打开另一个终端窗口并重复相同的练习，系统将再次要求我输入密码。
- en: Using `sudo` is another example of how Linux makes things as secure as possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sudo` 是 Linux 如何使事情尽可能安全的另一个例子。
- en: It’s useful to know many more commands, but this at least gives you a starting
    point. Remember that `man` is your friend here!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多命令很有用，但这至少给你提供了一个起点。记住，`man` 是你的好朋友！
- en: Now that you can confidently find your way in your Linux distro, it’s time to
    see how we can work with the OS as developers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在你的 Linux 发行版中自信地找到自己的位置，是时候看看我们作为开发者如何与操作系统一起工作了。
- en: Developing for Linux
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Linux 开发
- en: One of the first pieces of software written for Linux was GCC, created in 1991\.
    `python3` command into the terminal, and you are ready to go. But we do not do
    Python; we do .NET. And that means we have another road to take.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Linux 编写的第一个软件之一是 GCC，它于 1991 年创建。在终端中输入 `python3` 命令，你就可以开始了。但我们不做 Python；我们做
    .NET。这意味着我们还有另一条路要走。
- en: Installing .NET on Linux
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 .NET
- en: I mentioned previously that Linux usually has a lot of development tools pre-installed.
    However, .NET is not one of those pre-installed environments. The good news is
    that it is not hard to install.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到 Linux 通常预装了很多开发工具。然而，.NET 不是这些预装环境之一。好消息是安装它并不难。
- en: Before I tell you how to get .NET on the system, I want to discuss my choice
    of development machines.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我告诉你如何将 .NET 安装到系统之前，我想讨论一下我选择开发机器的选择。
- en: I love Visual Studio. I think it is by far the best IDE available. There are
    others, and I know many people who prefer other tools over Visual Studio, but
    I am not one of them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我爱 Visual Studio。我认为它是目前最好的 IDE。当然，还有其他 IDE，我知道很多人更喜欢 Visual Studio 以外的工具，但我不属于他们。
- en: One of the IDEs that many people use is **Visual Studio Code**. And I agree
    with them that **VS Code** (to use its shorter name) is a great tool. However,
    I prefer the richness of the complete edition of Visual Studio when I work on
    a real-world system.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人使用的 IDE 之一是 **Visual Studio Code**。我同意他们的看法，**VS Code**（使用其简称）是一个伟大的工具。然而，当我处理现实世界系统时，我更喜欢
    Visual Studio 完整版的丰富性。
- en: If you prefer VS Code, you can use that, of course. You can install VS Code
    on many different platforms, including Linux. There are many tutorials online
    that tell you how to do this.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢 VS Code，当然可以使用它。你可以在许多不同的平台上安装 VS Code，包括 Linux。网上有许多教程告诉你如何做到这一点。
- en: I have bad and good news if you want to stay with Visual Studio.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要继续使用 Visual Studio，我有一个好消息和一个坏消息。
- en: The bad news is that you cannot install Visual Studio on a Linux machine. The
    good news is that you do not have to. You can install it on your Windows machine
    and then deploy and debug directly on the Linux system. And that is what we will
    do in the rest of this chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是您不能在Linux机器上安装Visual Studio。好消息是您不必这样做。您可以在Windows机器上安装它，然后直接在Linux系统上部署和调试。这正是本章剩余部分我们将要做的。
- en: However, to run .NET applications on your Linux system, you must have the Runtime.
    The Runtime contains all that is needed to run your .NET applications. This is
    great if you want to prepare your production system for your applications. But
    if you want to debug and test your applications on a Linux machine, you also need
    the **.NET SDK**. The SDK contains the Runtime, so you do not need to install
    both.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要在您的Linux系统上运行.NET应用程序，您必须拥有运行时。运行时包含运行您的.NET应用程序所需的一切。如果您想为您的应用程序准备生产系统，这真是太好了。但如果您想在Linux机器上调试和测试您的应用程序，您还需要**.NET
    SDK**。SDK包含运行时，因此您不需要安装两者。
- en: Installing the .NET Runtime
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装.NET运行时
- en: Let’s discuss installing the Runtime first. Again, you only need the Runtime
    on machines that will run your software. If you want to compile your code, you
    need the SDK.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论安装运行时。同样，您只需要在将运行您的软件的机器上安装运行时。如果您想编译您的代码，您需要SDK。
- en: Open a Terminal on your Linux distro (or a Ubuntu Terminal on your Windows machine).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Linux发行版上打开一个终端（或在Windows机器上的Ubuntu终端）。
- en: 'Enter the following commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE0]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first command updates all packages on your system. The second one installs
    the HTTPS transport software if it is not already there. It is probably already
    on your system, but this ensures that is the case. We need `https` to download
    the software.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令更新了您系统上的所有包。第二个命令如果尚未安装，则安装HTTPS传输软件。它可能已经在您的系统上，但这样做确保了这一点。我们需要`https`来下载软件。
- en: 'Microsoft ensures all their software is signed, so you can trust it. However,
    to verify that signature, you need to have their public key. This is how we get
    that key on our system:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 微软确保他们所有的软件都是签名的，因此您可以信任它。但是，为了验证这个签名，您需要拥有他们的公钥。这是我们在系统上获取这个密钥的方法：
- en: '[PRE1]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These commands get the keys and install them on our system. Now, we can use
    them to verify the downloads from Microsoft.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令获取密钥并将它们安装到我们的系统上。现在，我们可以使用它们来验证从微软的下载。
- en: 'This was all only preparation. Now, it is finally time to install the Runtime.
    This is how we do that:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切只是准备工作。现在，我们终于可以安装运行时了。这是我们的做法：
- en: '[PRE2]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we make sure everything is updated. Then, we get the Runtime package.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保一切都已经更新。然后，我们获取运行时包。
- en: 'And that’s it. If this command finishes, we can test it by running the command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。如果这个命令执行完毕，我们可以通过运行以下命令来测试它：
- en: '[PRE3]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should see the .NET 8 Runtime in the (concise) list of runtimes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在运行时列表中看到.NET 8运行时。
- en: Installing the SDK
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装SDK
- en: 'If you want to build and debug your Linux distro, you need more software. You
    must install the SDK. Fortunately, that process is almost the same as installing
    the Runtime. If you have installed the Runtime, you can enter the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想构建和调试您的Linux发行版，您需要更多的软件。您必须安装SDK。幸运的是，这个过程几乎与安装运行时相同。如果您已经安装了运行时，您可以输入以下命令：
- en: '[PRE4]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This set of commands first updates all packages and then installs the SDK.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这组命令首先更新所有包，然后安装SDK。
- en: If you haven’t installed the Runtime, you first have to repeat all the steps
    I showed you during the Runtime installation, except for the last one (the installation
    of the Runtime itself). You still need to update, get, and install the keys.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装运行时，您首先必须重复我在运行时安装过程中向您展示的所有步骤，除了最后一个步骤（运行时的安装本身）。您仍然需要更新、获取和安装密钥。
- en: 'Test the installation of the SDK by calling the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用以下命令来测试SDK的安装：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should now see a list of the SDKS – well, I say list, but you will probably
    only see one item.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到一个SDK列表——好吧，我说是列表，但您可能只会看到一个条目。
- en: 'You can further test the installation by doing a quick test, like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过进行快速测试来进一步测试安装，例如：
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This command creates a new console application. When that is done, do this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个新的控制台应用程序。当完成时，执行以下操作：
- en: '[PRE7]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This builds `.csproj` in the current folder. The result ends up in the `/bin/Debug/net8.0`
    folder. The program’s name is the same as the folder in which you placed your
    project. If you didn’t create a directory, it is the name of your user. In my
    case, the program is called `dvroegop`, so I can run it like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前文件夹中构建 `.csproj` 文件。结果最终位于 `/bin/Debug/net8.0` 文件夹中。程序名称与您放置项目的文件夹名称相同。如果您没有创建目录，则名称为您的用户名。在我的情况下，程序名为
    `dvroegop`，所以我可以像这样运行它：
- en: '[PRE8]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I can see a friendly `Hello, World` message, so apparently it all works!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以看到友好的 `Hello, World` 消息，所以显然一切正常！
- en: Running a .NET background worker on Linux
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 上运行 .NET 后台工作进程
- en: We have had enough theory for the moment, I think. Let’s get practical. Fire
    up Visual Studio and start a new background worker project. In the wizard, accept
    all defaults until the project is ready. In the code, we leave everything as it
    is, including the default template printing a message every second. Run it to
    see that it all works.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们现在已经足够理论了。让我们来点实际的。启动 Visual Studio 并开始一个新的后台工作进程项目。在向导中，接受所有默认设置，直到项目准备就绪。在代码中，我们保留一切原样，包括默认模板每秒打印一条消息。运行它以查看是否一切正常。
- en: If all goes well, you will have a new background worker running on Windows.
    Great! But we have seen tons of those already. Let’s move our program to Linux.
    To do that, we have to do a couple of things.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将在 Windows 上运行一个新的后台工作进程。太棒了！但我们已经看到了很多这样的例子。让我们将我们的程序移到 Linux。为此，我们必须做一些事情。
- en: Run your app in the WSL
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 WSL 中运行您的应用程序
- en: We can publish directly from Visual Studio to your WSL installation. To do that,
    do the following.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从 Visual Studio 发布到您的 WSL 安装。为此，请执行以下操作。
- en: 'Open your project, and go to the run menu. In the dropdown, you should see
    the option to deploy to WSL. This looks like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的项目，转到运行菜单。在下拉菜单中，您应该看到部署到 WSL 的选项。这看起来像这样：
- en: "![Figure 1\uFEFF4.4: Use WSL as your debugging environment in Visual Studio](img/B20924_15_4.jpg)"
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4.4：在 Visual Studio 中使用 WSL 作为调试环境](img/B20924_15_4.jpg)'
- en: 'Figure 14.4: Use WSL as your debugging environment in Visual Studio'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：在 Visual Studio 中使用 WSL 作为调试环境
- en: Select the **WSL** option in the dropdown.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单中选择 **WSL** 选项。
- en: If you have more than one distro installed in WSL, you might get a warning in
    Visual Studio that the default WSL does not have the correct SDK installed. If
    that is the case, just click the **Install** button to fix it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 WSL 中安装了多个发行版，您可能会在 Visual Studio 中收到警告，默认的 WSL 没有安装正确的 SDK。如果是这种情况，只需点击
    **安装** 按钮即可修复。
- en: 'The `launchSettings.json` file in the `Properties` folder of your project should
    also have the WSL option. This determines which distro Visual Studio will launch.
    If none is specified, it takes the default. In my case, I have both Ubuntu 20
    and Ubuntu 22 installed, so I have to make a choice. I can instruct Visual Studio
    to take version 22 by changing my `launchSettings.json` to look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目 `Properties` 文件夹中的 `launchSettings.json` 文件也应包含 WSL 选项。这决定了 Visual Studio
    将启动哪个发行版。如果没有指定，它将使用默认设置。在我的情况下，我安装了 Ubuntu 20 和 Ubuntu 22，所以我必须做出选择。我可以指示 Visual
    Studio 使用版本 22，通过将我的 `launchSettings.json` 修改如下：
- en: '[PRE9]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The distribution name is an empty string by default, resulting in Visual Studio
    using the default environment to run your system. Since I have specified my desired
    distro name, it uses that distro instead.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 发行版名称默认为空字符串，导致 Visual Studio 使用默认环境来运行您的系统。由于我已经指定了我的期望发行版名称，它将使用该发行版。
- en: You can change the default distro by opening a command prompt or using the PowerShell
    Terminal. Then, get the list of installed distros using this command.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开命令提示符或使用 PowerShell 终端来更改默认的发行版。然后，使用此命令获取已安装的发行版列表。
- en: '[PRE10]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will see the list of installed distros on your machine. On my machine,
    this looks like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到机器上安装的发行版列表。在我的机器上，这看起来像这样：
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, you can pick one to be the default by issuing this command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过发出此命令来选择一个作为默认选项：
- en: '[PRE12]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, you can specify whatever distro you want. I happen to like `Ubuntu-22.04`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以指定您想要的任何发行版。我恰好喜欢 `Ubuntu-22.04`。
- en: 'What happens is quite interesting. Visual Studio does a lot of work to ensure
    we do not have to worry about deployment. Here is a simplified overview of what
    happens when you click **Run** after you select WSL as your environment:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情非常有趣。Visual Studio 做了很多工作以确保我们不必担心部署。以下是您选择 WSL 作为环境后点击 **运行** 时发生的事情的简化概述：
- en: Visual Studio builds your project as a cross-platform system.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将您的项目构建为一个跨平台系统。
- en: Visual Studio then uses WSL to start up an instance of the subsystem.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio随后使用WSL启动子系统的一个实例。
- en: Using WSL, Visual Studio then copies all the output files to the subsystem.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用WSL，Visual Studio随后将所有输出文件复制到子系统。
- en: Visual Studio copies VSDBG, which is the remote debugger, to WSL.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio将远程调试器VSDBG复制到WSL。
- en: It sets up VSDBG, giving it the proper permissions and enabling network communication.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它设置了VSDBG，给它适当的权限并启用网络通信。
- en: Visual Studio then starts VSDBG in the WSL and attaches your application.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio随后在WSL中启动VSDBG并附加你的应用程序。
- en: Finally, Visual Studio attaches itself to the running VSDBG instance.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，Visual Studio会附加到正在运行的VSDBG实例。
- en: The result is that you can use the IDE just like you are used to. You can set
    breakpoints, break the application, inspect variables, read system information,
    and so on. You will see little difference between running your app locally and
    running it on the WSL.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你可以像使用习惯的IDE一样使用它。你可以设置断点、中断应用程序、检查变量、读取系统信息等等。你在本地运行你的应用程序和在WSL上运行它之间几乎看不到任何区别。
- en: Deploy your app to a Linux environment
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将你的应用程序部署到Linux环境中
- en: Running your application directly from Visual Studio is pretty cool. Still,
    ultimately, you want to deploy your app to the system. That’s not that hard to
    do.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从Visual Studio运行你的应用程序非常酷。然而，最终，你希望将你的应用程序部署到系统中。这并不难做到。
- en: In Visual Studio, right-click on your project and choose to publish.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，右键单击你的项目，并选择发布。
- en: Build a new publish profile like you are used to, with a tiny difference – set
    the target runtime to **linux-x64**. Setting this framework will ensure that your
    app runs on Linux!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 像你通常做的那样创建一个新的发布配置文件，只有一个细微的差别——将目标运行时设置为**linux-x64**。设置此框架将确保你的应用程序在Linux上运行！
- en: If you want, you can also deploy your app to your WSL distro. You can use a
    handy shortcut in Windows Explorer – navigate to the `\\wsl.localhost\Ubuntu-22.04\home\[username]\`
    folder. Make sure to replace `[username]` with your username from the WSL. You
    can create a new folder to act as the publish profile recipient.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以将你的应用程序部署到你的WSL发行版。你可以在Windows资源管理器中使用一个方便的快捷方式——导航到`\\wsl.localhost\Ubuntu-22.04\home\[username]\`文件夹。确保将`[username]`替换为你的WSL用户名。你可以创建一个新的文件夹作为发布配置文件接收者。
- en: You can enter that folder in the profile’s target location – that way, Visual
    Studio automatically sends all the artifacts to the right place. My profile settings
    look like this.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将该文件夹输入配置文件的目标位置——这样，Visual Studio就会自动将所有工件发送到正确的位置。我的配置设置看起来像这样。
- en: "![Figure 1\uFEFF4.5: A publish profile for a Linux/WSL target](img/B20924_15_5.jpg)"
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5：Linux/WSL目标的发布配置文件](img/B20924_15_5.jpg)'
- en: 'Figure 14.5: A publish profile for a Linux/WSL target'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：Linux/WSL目标的发布配置文件
- en: If you do this and then press the **Publish** button, your code ends up where
    it needs to be. Now, you can run the program from the WSL distro. Of course, if
    you have another Linux system running, you can use the same mechanism. If you
    can’t make a share, you can always publish it locally and then use a tool such
    as SCP to copy the files.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，然后按下**发布**按钮，你的代码最终会到达它需要的位置。现在，你可以从WSL发行版运行程序。当然，如果你有另一个正在运行的Linux系统，你可以使用相同的机制。如果你不能创建共享，你总是可以本地发布，然后使用如SCP之类的工具复制文件。
- en: I think we have discussed this matter enough. Next, let’s discuss developing
    for Linux!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们已经足够讨论这个问题了。接下来，让我们讨论Linux开发！
- en: Make your code cross-platform
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使你的代码跨平台
- en: The beauty of .NET is that it is cross-platform. The IL runs almost everywhere.
    If you build an application, it will work on your Windows and Linux machines.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: .NET的美丽之处在于它是跨平台的。IL几乎在所有地方都可以运行。如果你构建一个应用程序，它将在你的Windows和Linux机器上运行。
- en: Running an exe on Linux?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上运行exe文件？
- en: No, you cannot run your Windows `exe` on Linux. An EXE file is a typical Windows
    construct. The file layout is specific to that platform, and Linux systems have
    another way to handle executables. However, the compiler also produces a DLL file
    if you build your system. That file can be run with the `dotnet` command. So,
    if your system is called `MyAwesomeApp.exe`, you will also find a `MyAwesomeApp.dll`
    in the `Build` directory. On all supported platforms, you can run your application
    using the `dotnet MyAwesomeApp.dll command`, which works on Windows and Linux.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 不，你不能在Linux上运行你的Windows `exe`文件。EXE文件是典型的Windows结构。文件布局特定于该平台，而Linux系统有另一种处理可执行文件的方式。然而，如果你构建你的系统，编译器也会生成一个DLL文件。你可以使用`dotnet`命令运行该文件。所以，如果你的系统名为`MyAwesomeApp.exe`，你也会在`Build`目录中找到一个`MyAwesomeApp.dll`。在所有支持的平台上，你可以使用`dotnet
    MyAwesomeApp.dll`命令运行你的应用程序，这在Windows和Linux上都有效。
- en: But that doesn’t mean you can copy your binaries, run them, and expect everything
    to work fine. There are some caveats you should be aware of. But don’t worry –
    we’ll cover them one by one here.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不意味着您可以复制您的二进制文件，运行它们，并期望一切都能正常工作。有一些注意事项您应该知道。但别担心——我们在这里会逐一介绍它们。
- en: Permissions in Linux
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的权限
- en: Here is the first caveat – scripts and applications cannot run by default. They
    do not have the correct permissions. Each file has a set of permissions, telling
    the OS what it can do with it. These permissions differ per category. There are
    permissions for the user, a group, and others. The permissions themselves can
    be read, write, or execute. You use the `chmod` (`man chmod` to get all the inside
    information, but remember that to make your application runnable, you have to
    use the `chmod +x [yourapplicationname]` command. The `+x` part tells Linux you
    can execute it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个首要的注意事项——脚本和应用程序默认情况下无法运行。它们没有正确的权限。每个文件都有一组权限，告诉操作系统它可以对它做什么。这些权限按类别不同。有针对用户、组和其它人的权限。权限本身可以是读取、写入或执行。您使用`chmod`命令（使用`man
    chmod`获取所有内部信息，但请记住，为了使您的应用程序可运行，您必须使用`chmod +x [yourapplicationname]`命令。`+x`部分告诉Linux您可以执行它。
- en: Once you get the hang of it, you will find it is easy to switch between Windows
    and Linux. But to be completely honest, I have been known to try the `chmod` command
    on my Windows machine. Don’t tell anyone I confessed to this!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您掌握了它，您会发现切换到Windows和Linux之间非常容易。但说实话，我知道我曾在我的Windows机器上尝试过`chmod`命令。不要告诉任何人我承认了这一点！
- en: How code can help you
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码如何帮助您
- en: The people who made .NET have gone out of their way to make it as easy as possible
    for those who need to support multiple platforms. Whereas in the “old days,” you
    had to have a lot of compiler directives or even different versions of your code,
    you can now do a lot in code and have the system figure out how to handle things.
    Let’s look at some of them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 创建.NET的人已经尽力让那些需要支持多个平台的人尽可能容易。在“旧时代”，您需要很多编译器指令，甚至不同的代码版本，而现在您可以在代码中做很多事情，让系统找出如何处理这些事情。让我们看看其中的一些。
- en: Finding out where you run
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找您运行的位置
- en: 'Now and then, you want to know what platform a system runs on. There is a class
    called `OperatingSystem` that helps with that. It is a very simple class, but
    it can be tremendously powerful. Look at the following snippet:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您想知道系统运行在哪个平台上。有一个叫做`OperatingSystem`的类可以帮助您做到这一点。这是一个非常简单的类，但它可以非常强大。看看下面的代码片段：
- en: '[PRE13]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `OperatingSystem` class has many more methods like this, but I am sure you
    get the idea. You can also use this class to determine the software’s specific
    version of a platform if you need to know that. So, all the information you need
    is available.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperatingSystem`类有更多这样的方法，但我相信您已经明白了这个意思。如果您需要知道软件的特定平台版本，您也可以使用这个类来确定。所以，您需要的信息都在这里。'
- en: Paths and directories
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径和目录
- en: If you played around in WSL using the commands I gave you earlier in this chapter,
    you might have noticed that paths look quite different from what you may be used
    to.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本章前面给出的命令在WSL中尝试过，您可能会注意到路径看起来与您可能习惯的不同。
- en: 'For instance, the path to my home directory when I browse in Windows looks
    like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我在Windows中浏览时，我的家目录路径看起来是这样的：
- en: '[PRE14]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: My main drive is the C drive, with a `Users` folder with a subfolder, `dvroe`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我的主要驱动器是C驱动器，有一个`Users`文件夹，其中有一个子文件夹`dvroe`。
- en: 'In my Linux distro, my `home` folder can be found at this location:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Linux发行版中，我的`home`文件夹可以在以下位置找到：
- en: '[PRE15]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Apparently, it can be found by going to the root, then the `home` subfolder,
    and finally, to the `dvroegop` folder.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，可以通过进入根目录，然后是`home`子文件夹，最后是`dvroegop`文件夹来找到它。
- en: There is no mention of a drive. In addition, all the slashes are the other way
    around.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提到驱动器。此外，所有的斜杠方向都是相反的。
- en: Drives are available, but they are in a different place. Linux has a root path
    called `/mnt`. You can find a folder for all the drives on your machine in that
    folder. So, in Windows, the drive is the root of all paths; in Linux, it is a
    subfolder of `/mnt`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器可用，但它们的位置不同。Linux有一个根路径叫做`/mnt`。您可以在该文件夹中找到一个包含您机器上所有驱动器的文件夹。所以，在Windows中，驱动器是所有路径的根；在Linux中，它是`/mnt`的子文件夹。
- en: 'In your code, you should never need to worry about what kind of slashes to
    use or how to structure your path to contain the right drive. The `Path` class
    contains all the tools you need. Look at this code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，您永远不需要担心使用哪种斜杠或如何构建路径以包含正确的驱动器。`Path`类包含了您需要的所有工具。看看下面的代码：
- en: '[PRE16]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this sample, I combine two parts of a path. You should never do that. I just
    wanted to show you what happens if you use `DirectorySeparator`. A better way
    to do this is to use `Path.Combine()`, as I also show in this code. That way,
    you can be sure to always get the right results.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我合并了路径的两个部分。你永远不应该这样做。我只是想展示如果你使用`DirectorySeparator`会发生什么。更好的方法是使用`Path.Combine()`，就像我在代码中也展示的那样。这样，你可以确保始终得到正确的结果。
- en: A path separator versus a directory separator
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 路径分隔符与目录分隔符
- en: I have shown you both a path separator and a directory separator in the sample.
    Many developers use path separators and directory separators interchangeably,
    but they are different things in this case. A directory separator is a character
    that separates different parts of an entire directory name. For instance, the
    `c:\users\yourname\mydata` path contains the three `\` directory separators. A
    path separator is used if you need multiple directories in one string.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '我在示例中展示了路径分隔符和目录分隔符。许多开发者将路径分隔符和目录分隔符互换使用，但在这个情况下它们是不同的事物。目录分隔符是一个字符，用于分隔整个目录名的不同部分。例如，`c:\users\yourname\mydata`路径包含三个`\`目录分隔符。路径分隔符用于当你需要在字符串中包含多个目录时。 '
- en: A good example is the `%PATH%` environment variable, which shows all the directories
    that Windows uses to search for executables. They come in a long list separated
    by a path separator. In Windows and Linux, all these characters differ.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是`%PATH%`环境变量，它显示了Windows用于搜索可执行文件的所有目录。它们以路径分隔符分隔的长列表出现。在Windows和Linux中，所有这些字符都不同。
- en: 'A similar thing happens with line endings. Windows uses two characters – return
    and line feed `(''\r\n'')`. Linux uses line feed only – `(''\n'')`. If you want
    to be sure your code works everywhere, use this code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 行结束符的问题也会发生类似的情况。Windows使用两个字符——回车和换行`('\r\n')`。Linux只使用换行符`('\n')`。如果你想确保你的代码在所有地方都能工作，请使用以下代码：
- en: '[PRE17]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That solves this problem for you.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解决了你的问题。
- en: Writing services for Linux
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Linux编写服务
- en: This book has mentioned background processes quite a lot. We’ve seen how to
    write them and how to deploy them. But how does that work on Linux? Let’s find
    out!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书已经多次提到了后台进程。我们看到了如何编写它们以及如何部署它们。但在Linux上是如何工作的呢？让我们找出答案！
- en: A background service in Linux is called a **daemon**. This software runs in
    the background and doesn’t immediately interact with a user. That sounds like
    something we, as system programmers, should recognize.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的后台服务被称为**守护进程**。这种软件在后台运行，不会立即与用户交互。这听起来就像是我们作为系统程序员应该认识的东西。
- en: We can create a Worker Service in Visual Studio to write such software. Build
    it, then deploy it to a folder on your Linux distro.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Visual Studio中创建一个Worker Service来编写这样的软件。构建它，然后将其部署到Linux发行版上的一个文件夹中。
- en: The service description
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务描述
- en: Before you do that, add a new file to the project; this is the system description
    that Linux needs to register your services.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在你做那之前，向项目中添加一个新文件；这是Linux需要注册你的服务的系统描述。
- en: 'I called my file `crossplatformservice.service`. It looks like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的文件命名为`crossplatformservice.service`。它看起来像这样：
- en: '[PRE18]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Obviously, you should make sure the paths in this file correspond to your paths.
    I doubt you have a folder called `dvroegop' on your machine. Let’s investigate
    what this file does.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你应该确保这个文件中的路径与你的一致。我怀疑你的机器上没有名为`dvroegop`的文件夹。让我们调查一下这个文件的作用。
- en: The `Unit` section contains metadata and the dependencies for the service. A
    `Description` is a human-readable description.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit`部分包含服务的元数据和依赖项。`Description`是一个可读的描述。'
- en: '`After` specifies when the service should start. Here, we state that the service
    should start when the network has been initialized.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`After`指定了服务应该何时启动。在这里，我们声明服务应该在网络初始化后启动。'
- en: 'The `Service` section configures how the service should be run and managed.
    The parts of this section are explained in the following table:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service`部分配置了服务应该如何运行和管理。本节各部分的解释如下表所示：'
- en: '| **Element** | **Description** |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **元素** | **描述** |'
- en: '| `WorkingDirectory` | This is where the application will be executed. Can
    be used for relative path resolution. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `WorkingDirectory` | 这是应用程序将被执行的位置。可用于相对路径解析。|'
- en: '| `ExecStart` | This is the command used to start the service. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `ExecStart` | 这是启动服务的命令。|'
- en: '| `Restart` | Defines the restart policy. `always` means it always restarts
    after a crash or unexpected stop. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `Restart` | 定义重启策略。`always`表示在崩溃或意外停止后总是重启。|'
- en: '| `RestartSec` | This is the delay before restarting the service. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `RestartSec` | 这是重启服务前的延迟时间。|'
- en: '| `KillSignal` | This defines the signal used to terminate the service. `SIGINT`
    is the most used one; we’ll look into this later on. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `KillSignal` | 定义用于终止服务的信号。`SIGINT`是最常用的一个；我们稍后会探讨这个问题。|'
- en: '| `SyslogIdentifier` | Sets a name for the service’s log entries. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `SyslogIdentifier` | 为服务的日志条目设置一个名称。|'
- en: '| `User` | Runs the service as a specified user. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `User` | 以指定用户运行服务。|'
- en: '| `Environment` | Sets the environment variables needed for the service. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `Environment` | 设置服务所需的环境变量。|'
- en: 'Table 14.7: The service elements for a service description'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.7：服务描述的服务元素
- en: Finally, we have the `Install` section. This indicates how and when a service
    should be installed and started. The `WantedBy` element specifies the target to
    which this service should be linked. In our case, we used `multi-user.target`,
    which means it runs in a multi-user, non-graphical environment. This is typical
    for services such as ours.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`Install`部分。这表明服务应该如何以及何时安装和启动。`WantedBy`元素指定了此服务应链接到的目标。在我们的例子中，我们使用了`multi-user.target`，这意味着它在多用户、非图形环境中运行。这对我们这样的服务来说是典型的。
- en: Make sure you add this file to your deployment.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将此文件添加到您的部署中。
- en: Installing the service
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装服务
- en: We can install the service once you have the binaries and the service description
    file on your Linux distro. In a Terminal, do the following.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在Linux发行版上有了二进制文件和服务描述文件，我们就可以安装服务。在终端中，执行以下操作。
- en: 'Move the service description file to the correct directory. If you are in the
    publish directory on your distro, issue the following command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务描述文件移动到正确的目录。如果您在您的发行版的发布目录中，请发出以下命令：
- en: '[PRE19]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You need to use `sudo`; a regular user has no right to access that folder.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用`sudo`；普通用户没有权限访问该文件夹。
- en: 'Now, we have to restart the system manager configuration. Do that with this
    command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须重新启动系统管理器配置。使用以下命令执行此操作：
- en: '[PRE20]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the configuration is reloaded and has read our service description file,
    we can enable the service:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置重新加载并读取了我们的服务描述文件，我们就可以启用服务：
- en: '[PRE21]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The name `crossplatformservice` is the one that I used in the `SyslogIdentifier`
    setting in the description file.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`crossplatformservice`是在描述文件中的`SyslogIdentifier`设置中使用的。
- en: 'If the Linux system restarts, our service will also start. But you don’t have
    to reboot – you can also manually start the service to see whether everything
    works out fine. Do this with the following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Linux系统重启，我们的服务也将启动。但您不必重启——您也可以手动启动服务来查看一切是否正常。使用以下命令执行此操作：
- en: '[PRE22]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The results are probably disappointing; you see nothing. But you can verify
    if it all worked out by using this command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能令人失望；您什么也看不到。但您可以使用此命令来验证一切是否按预期进行：
- en: '[PRE23]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command returns the status, confirming that everything works as expected.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令返回状态，确认一切按预期进行。
- en: 'If you want more information, you can look in the log files. All logs are collected
    by Linux, and acquiring them is done with this command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多信息，可以查看日志文件。所有日志都由Linux收集，使用以下命令获取：
- en: '[PRE24]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command shows the last entries in the logs. Since many applications use
    the log, we can filter the results to only show the ones belonging to our service.
    That is what the -u parameter does.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示日志中的最后条目。由于许多应用程序使用日志，我们可以过滤结果，只显示属于我们服务的条目。这正是`-u`参数的作用。
- en: You should get the expected data on your screen to confirm that the service
    works!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在屏幕上看到预期的数据以确认服务正常工作！
- en: Uninstalling the service
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载服务
- en: You might want to get rid of the service on your development machine. That’s
    not too difficult; just reverse the steps we just took.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想从您的开发机器上删除服务。这并不太难；只需逆转我们刚才采取的步骤即可。
- en: 'First, stop the service:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，停止服务：
- en: '[PRE25]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, disable the service:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，禁用服务：
- en: '[PRE26]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remove the service description file:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除服务描述文件：
- en: '[PRE27]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After that, reload the daemon configuration:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，重新加载守护进程配置：
- en: '[PRE28]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And that’s it. To verify that the service really is deleted, use this command:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样。为了验证服务是否真的被删除，使用此命令：
- en: '[PRE29]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That last command should return an error, as our service no longer exists.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令应该返回错误，因为我们的服务已经不再存在。
- en: Handling signals
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理信号
- en: In the service description file, we told the system that our application could
    be stopped with the `SIGINT` signal. But that was not really true, as we haven’t
    done anything to process signals.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务描述文件中，我们告诉系统我们的应用程序可以通过`SIGINT`信号停止。但那其实并不准确，因为我们还没有做任何处理信号的操作。
- en: What are signals?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是信号？
- en: A signal can be compared to events on a Windows machine, or, if you remember
    from earlier chapters, instances of Windows messages. In other words, they are
    messages that are sent to your application. Some are predefined, while others
    are user-defined, meaning you can also use them to communicate between programs.
    In this case, we are talking about the two most used messages in Linux. That’s
    all there is to it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以与Windows机器上的事件相比较，或者如果你还记得前面的章节，Windows消息的实例。换句话说，它们是发送到您的应用程序的消息。有些是预定义的，而有些是用户定义的，这意味着您也可以使用它们在程序之间进行通信。在这种情况下，我们正在讨论Linux中最常用的两个消息。就是这样。
- en: Signals are ways for the operating system to send messages to your application
    or service. Two of the most used signals are `SIGINT` and `SIGTERM`. The first
    one, `SIGINT`, requests an interrupt – the OS wants to stop the service. The second,
    `SIGTERM`, is meant to stop the application immediately. I agree that it is hard
    to see the difference between these two, but there is logic here – `SIGINT` is
    usually a response to a user doing something, such as pressing *Ctrl* + *C*. You
    could say that a user is responsible for sending `SIGINT`. The `SIGTERM` signal
    is from the OS or other services if they think our service needs to be terminated.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是操作系统向您的应用程序或服务发送消息的方式。最常用的两个信号是`SIGINT`和`SIGTERM`。第一个，`SIGINT`请求中断——操作系统想要停止服务。第二个，`SIGTERM`旨在立即停止应用程序。我同意很难看出这两个之间的区别，但这里是有逻辑的——`SIGINT`通常是用户做出某种操作的响应，例如按*Ctrl*
    + *C*。你可以说是用户负责发送`SIGINT`。如果操作系统或其他服务认为我们的服务需要终止，则`SIGTERM`信号来自操作系统或其他服务。
- en: We must write code to handle these signals and make our application behave nicely.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写代码来处理这些信号，并使我们的应用程序表现得更好。
- en: To do that, we must import a NuGet package. In this case, we need `Mono.Posix.NETStandard`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须导入一个NuGet包。在这种情况下，我们需要`Mono.Posix.NETStandard`。
- en: 'Once you have done that, go to the `Worker` class and add the following method
    to that class:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这些，就去`Worker`类中，并添加以下方法到该类中：
- en: '[PRE30]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method does two things. First, it registers `eventhandler` for the “normal”
    `ProcessExit` event. This event is called when a process needs to terminate and
    is part of the .NET Runtime. In Linux, this is called when `SIGTERM` is used.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法做了两件事。首先，它为“正常”的`ProcessExit`事件注册了`eventhandler`。当进程需要终止且是.NET运行时的一部分时，会调用此事件。在Linux中，当使用`SIGTERM`时，会调用此事件。
- en: 'Next, we tell the system to listen to the `SIGINT` and `SIGTERM` signals. We
    create an array with these values and start a new background thread. All that
    the thread does is wait for those signals to arrive. When they do, it calls the
    `SignalHandler()` method. This method looks like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉系统监听`SIGINT`和`SIGTERM`信号。我们创建一个包含这些值的数组并启动一个新的后台线程。线程所做的只是等待这些信号的到来。当它们到来时，它调用`SignalHandler()`方法。这个方法看起来是这样的：
- en: '[PRE31]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method is simple enough – we write to the log that we received and then
    terminate the program.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法足够简单——我们写入日志表示我们已接收并终止程序。
- en: In the constructor of the `Worker` class, we add the call to `RegisterSignalHandlers()`,
    and then we are good to go.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Worker`类的构造函数中，我们添加了对`RegisterSignalHandlers()`的调用，然后我们就可以开始了。
- en: Run the program from Linux (not as a service, but as a regular program), press
    *Ctrl* + *C*, and note the messages telling you that we managed to capture the
    signal. Cool, isn’t it?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上运行程序（不是作为服务，而是作为常规程序），按*Ctrl* + *C*，并注意显示的消息，告诉我们我们已经成功捕获了信号。酷吧，不是吗？
- en: Summing up
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结一下
- en: Now, you should have all the knowledge to start working on Linux programs. Linux
    is the platform of choice for many services. Services, of course, are something
    we as system programmers work with all the time. Although a great platform, Linux
    has a steep learning curve. Many things are similar to what you are used to in
    Windows but differ slightly, whereas other things are entirely new or unique to
    the platform.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该有了开始编写Linux程序所需的所有知识。Linux是许多服务的首选平台。服务，当然，是我们作为系统程序员经常打交道的东西。虽然是一个伟大的平台，但Linux的学习曲线很陡峭。许多事情与你在Windows上习惯的相似，但略有不同，而其他事情则是全新的或该平台独有的。
- en: It takes time to learn it well. But with what we’ve discussed in this chapter,
    you are well on your way to feeling at home with Linux. We explored the history
    of the platform, and we discussed some of its most used commands. We discussed
    development and looked at how to write daemons for Linux.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 学好它需要时间。但通过本章我们讨论的内容，你已经走在熟悉Linux的道路上了。我们探讨了该平台的历史，并讨论了一些最常用的命令。我们讨论了开发，并查看如何为Linux编写守护进程。
- en: Let’s recap
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们回顾一下
- en: Sit back. Take a deep breath. You’ve made it. You’ve reached the end of the
    book. And I hope you learned a thing or two.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 休息一下。深呼吸。你已经做到了。你已经到达了这本书的结尾。我希望你学到了一些东西。
- en: 'Don’t underestimate what we’ve done. We’ve answered so many questions:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 不要低估我们所做的事情。我们已经回答了这么多问题：
- en: What is systems programming?
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统编程是什么？
- en: How do we use low-level APIs?
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用底层 API？
- en: How do we use the Win32 API?
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用 Win32 API？
- en: How can we make our software run faster?
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何让我们的软件运行得更快？
- en: How can we make our software memory efficient?
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何让我们的软件内存高效？
- en: What is I/O and how do we use it?
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 是什么？我们如何使用它？
- en: What is the best way to have systems communicate over a network?
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上进行系统通信的最佳方式是什么？
- en: How do we monitor and log what our systems are doing?
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何监控和记录系统正在做什么？
- en: What is the ultimate way to debug these low-level systems?
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试这些底层系统的最终方法是什么？
- en: How do we even deploy it all?
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们该如何部署所有这些内容？
- en: How do we work with Linux?
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何与 Linux 合作？
- en: That’s a lot of information! But you have taken the challenge. You can call
    yourself a specialist in writing fast-performing, memory-efficient, network-aware,
    secure, and cross-platform low-level system software. That’s a long title, but
    you deserve it!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有大量的信息！但你接受了挑战。你可以称自己为擅长编写快速执行、内存高效、网络感知、安全且跨平台的底层系统软件的专家。这是一个很长的头衔，但你当之无愧！
- en: And don’t forget – these newfound skills made you a better developer. These
    skills can be applied to all sorts of projects, not only systems programming.
    The basic principles stand and are applicable everywhere. I look forward to hearing
    from you and discovering what you are going to do with what you have learned.
    The best way to learn new techniques is to try them out. So, I urge you to try
    the samples and write awesome system software. I have faith in you!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 并且不要忘记——这些新获得的技能使你成为了一名更好的开发者。这些技能可以应用于各种项目，而不仅仅是系统编程。基本原理是站得住脚的，并且适用于任何地方。我期待着听到你的消息，了解你打算如何利用你所学的知识。学习新技术的最佳方式是尝试它们。所以，我敦促你尝试这些示例，编写出色的系统软件。我对你有信心！
