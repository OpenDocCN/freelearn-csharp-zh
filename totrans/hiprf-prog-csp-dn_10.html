<html><head></head><body>
		<div id="_idContainer141">
			<h1 id="_idParaDest-150"><em class="italic"><a id="_idTextAnchor152"/>Chapter 8</em>: File and Stream I/O</h1>
			<p>In this chapter, you will learn how to improve directory, file, and streaming performance. You will also learn how to efficiently enumerate directories, process small and large files, perform asynchronous operations, use local storage, handle exceptions, and work with memory efficiently.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li><strong class="bold">Understanding the various Windows file path formats</strong>: This section provides information on the different file path formats that you will encounter on the Windows operating system. Also covered is the 256-character file path limit on Windows, and techniques that cover how to remove this limitation.</li>
				<li><strong class="bold">Considering improved I/O performance</strong>: In this section, we will be benchmarking some code to see which method of coding performs fastest when it comes to calculating directory sizes and moving files. Plus, we will look at how to read and write files asynchronously.</li>
				<li><strong class="bold">Handling I/O operation exceptions</strong>: We will cover how to handle I/O exceptions in this section. You will learn how to handle exceptions so that performance is not negatively impacted. You will also learn when to recover from exceptions, as well as when to exit them to preserve data integrity when exceptions cannot be graciously recovered from.</li>
				<li><strong class="bold">Performing memory tasks efficiently</strong>: In this section, you will learn how to efficiently use memory when processing strings and dealing with objects. We will also discuss how to defragment the Large Object Heap.</li>
				<li><strong class="bold">Understanding local storage tasks</strong>: In this section, we will discuss the various options for local file storage, some problems that can arise in networked environments, and when users install software just for themselves when multiple people use the same software on the same computer.</li>
			</ul>
			<p>By the end of this chapter, you will be able to do the following:</p>
			<ul>
				<li>Understand the different Windows file path formats.</li>
				<li>Overcome the 256-character file path limit on Windows.</li>
				<li>Understand how hardware affects the performance of your code.</li>
				<li>Choose the best option for calculating directory sizes.</li>
				<li>Choose the best option for moving files.</li>
				<li>Read and write files asynchronously.</li>
				<li>Handle I/O and other exceptions effectively.</li>
				<li>Improve the performance of memory-based tasks.</li>
				<li>Understand what local file storage options are available to you.</li>
				<li>Understand the problems that can occur in networked environments, such as when applications that should be installed for all users on a single machine are installed only for the current user, and how to effectively resolve them.</li>
			</ul>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor153"/>Technical requirements</h1>
			<p>The following are the technical requirements for this chapter:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>The source code for this book: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08</a></li>
			</ul>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Understanding the various Windows file path formats</h1>
			<p>You probably already know that .NET provides managed code that hides interaction with the Windows APIs from <a id="_idIndexMarker801"/>the end user. So, it will come as no surprise that the System.IO namespace passes file path information to the Windows APIs to handle. The Windows APIs perform the required task, and then control is handed back to .NET.</p>
			<p>File paths in .NET can be absolute, relative, UNC paths, or DOS device paths. Non-Windows files and directories are case-sensitive. But on Windows, files and directories are case-insensitive. The following <a id="_idIndexMarker802"/>table provides examples of the different Windows file path formats:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B16617_Table_8.1.jpg" alt="Table 7.1 – Windows path format examples&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 7.1 – Windows path format examples</p>
			<p>By default, Windows can only accept paths with a length of 256. As a programmer, you have probably encountered the <strong class="source-inline">Destination Path Too Long</strong> warning when backing up your files or moving them. A situation that can often lead to this warning is developing web projects using node modules via NPM. NPM packages can have particularly long file <a id="_idIndexMarker803"/>paths that exceed 256 characters in length, which will lead to this exception being raised.</p>
			<p>You can remove the maximum path length limitation by either editing the registry or by editing the group policy. First, you will learn how to remove this limitation using the registry. Then, you will learn how to remove this limitation using the group policy.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor155"/>Removing the maximum path length limitation using the registry</h2>
			<p class="callout-heading">Note</p>
			<p class="callout">Always exercise caution when making changes to the registry.</p>
			<p>In this section, you <a id="_idIndexMarker804"/>will learn how to remove <a id="_idIndexMarker805"/>the file path limit of 260 <a id="_idIndexMarker806"/>characters by modifying the registry.</p>
			<p>In terms of performance, the <strong class="source-inline">MAX_PATH</strong> issue on Windows can waste your time. Copying many gigabytes of data can be very time-consuming. This can be made worse if a file copy fails after 28 minutes of you moving files between locations on different disks. </p>
			<p>So, with file management applications, for example, if a user is going to copy files between two locations that will raise a file length exception, it is best to warn the user and provide them with the option to restructure their files before they perform the copy, or offer to update the registry for them. This way, you can save the end user a lot of wasted time.</p>
			<p> To manually remove the <strong class="source-inline">MAX_PATH</strong> file path limit, follow these steps:</p>
			<ol>
				<li>Open <strong class="bold">Registry editor</strong>. You can do this by searching for <strong class="source-inline">regedit</strong>.</li>
				<li>Once you have opened the registry editor, navigate to the following key:<p class="source-code">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\</p><p class="source-code">FileSystem</p></li>
				<li>Identify the <strong class="bold">LongPathsEnabled</strong> key and set its value to <strong class="source-inline">1</strong>.</li>
				<li>If the key does not exist, then add it as a <strong class="bold">32-bit DWORD</strong> with a value of <strong class="source-inline">1</strong>.</li>
				<li>It may not be necessary, but it is a good idea to restart your computer for the changes to be picked up.</li>
			</ol>
			<p>You should now be <a id="_idIndexMarker807"/>able to process files <a id="_idIndexMarker808"/>with paths <a id="_idIndexMarker809"/>with over 260 characters. If you experience permission issues after performing the preceding steps, then open the registry editor as an administrator. If you still have problems, then see your system administrator. </p>
			<p>Now, let’s learn how to do this using the local group policy editor. </p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor156"/>Removing the maximum path length limitation using the group policy</h2>
			<p>You can also remove the file path limit of 260 characters by modifying the computer’s policy. You <a id="_idIndexMarker810"/>can do this with the <strong class="source-inline">gpedit.msc</strong> tool. This may be unavailable on some versions <a id="_idIndexMarker811"/>of Windows, or <a id="_idIndexMarker812"/>may not be available because of enterprise group policies that have been put in place. If you find that to be the case, then see your system administrator. Otherwise, follow these steps:</p>
			<ol>
				<li value="1">Open <strong class="bold">Local Group Policy Editor</strong>. You can do this by searching for <strong class="source-inline">gpedit.msc</strong>.</li>
				<li>Under <strong class="bold">Computer Configuration</strong>, navigate to <strong class="bold">Administrative Templates</strong> | <strong class="bold">System</strong> | <strong class="bold">Filesystem</strong>.</li>
				<li>There will be a setting called <strong class="bold">Enable Win32 long paths</strong> set to <strong class="source-inline">Not configured</strong> by default. Edit this setting by setting it to <strong class="source-inline">Enabled</strong>.</li>
				<li>It may not be necessary, but it is a good idea to restart your computer for the changes to be picked up.</li>
			</ol>
			<p>With <a id="_idIndexMarker813"/>that, we’ve <a id="_idIndexMarker814"/>learned how <a id="_idIndexMarker815"/>to overcome the limiting path situation on Windows by editing the registry and local group policy. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is really important to remove the file path limitation. There have been instances where critical backups on client and server computers have failed due to this limitation being in place. It can also break your development project when you’re working with third-party libraries.</p>
			<p>We will now look at some considerations that will help boost I/O operations.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/>Considering improved I/O performance</h1>
			<p>There are several common I/O tasks that we do often, such as traversing directories searching for files, adding, renaming, moving<a id="_idIndexMarker816"/> and deleting directories, adding, renaming, moving, and deleting files, password protecting files and directories, encrypting and decrypting files and directories, and compressing files and directories. We also transmit and load files synchronously, asynchronously, and via streams such as file streams and memory streams. Then, there are all the NoSQL and SQL data operations, all of which will be happening frequently on corporate networks, and streaming data and audio/visual content at work and home.</p>
			<p>When working with I/O, it is quite easy to completely slow a system down to the point that it becomes unusable while file reading and file writing is taking place. So, if you are going to be performing heavy I/O, you must keep the system where the work is being carried out fully operational and responsive for the end user and other processes.</p>
			<p>If your hardware is poor, then no matter how good your software is, it will more than likely be slow!</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you consider optimizing your software to improve the speed and performance of I/O operations, you need to make sure that the hardware in place is suited to the type of I/O you will be performing. Otherwise, you could be wasting your time trying to improve your software!</p>
			<p>When you’re dealing with hardware to speed up input and output operations, things to consider include the speed of your network card, whether or not you are using SSD disks, the number of CPUs, and the amount of RAM in use.</p>
			<p>You also need to consider what other software processes will be running on the target computers. Security <a id="_idIndexMarker817"/>software that’s performing real-time scanning can often be overlooked when it comes to application slowdowns. When this is the case, you can have your application added as an exception to the antivirus software so that real-time scanning no longer slows down your software.</p>
			<p>Another issue that’s encountered in the wild is running one or more backups over the network during critical times of operation. No matter how efficient your program is, if it is running on a backup server, its performance can be severely impacted by the running backup software and process. This can also be the case if your software is not on the backup server, but requires the network to run and then send and receive files and data. The following are things to consider:</p>
			<ul>
				<li>Change backup schedules to run at non-critical times.</li>
				<li>Install your software on a different server with a better overall performance.</li>
				<li>Check your network for bottlenecks and alleviate those bottlenecks.</li>
				<li>Make sure your network cards are fast enough and configured appropriately.</li>
				<li>Make sure your Ethernet cables are up to date. Cat-5 cables are fine for typical internet traffic, but if you are doing a lot of file and data operations over your network, then you will want to upgrade to Cat-6a/Cat-7 cables for increased performance. However, with Cat-7 cables, you need to be careful not to damage the foil shielding when you bend the cable.</li>
			</ul>
			<p>With web projects, it is important to reduce file size to speed up how files are transmitted and received over the internet. This helps reduce the overall page load time and results in happier customers. To improve the load performance of your web applications, enable the Windows Dynamic Content Compression feature. This will reduce the data’s size, thus increasing the response time from the user’s perspective. The need for data <a id="_idIndexMarker818"/>compression also applies to client/server applications, especially if the file and data sizes that are being transmitted are huge.</p>
			<p>Employ caching to improve network performance. Caching will store resources locally or keep them in memory for a certain period. Should such resources be requested again, then the locally stored resources will be checked and used instead of the network resources. This increases the access and load times of resources, and it also reduces network traffic. Cached resources will be updated if the resources have been updated, if the cache period has expired, or if the user has cleared their cache.</p>
			<p>The two most common data transfer mechanisms are XML and JSON. These are text files that store structured information. Parsers are required to extract information from such files so that the extracted data can be utilized in the applications. But not all XML and JSON parsers perform the same. It would be prudent to benchmark the performance of various XML and JSON parsers to help you choose the most efficient and performant one for your data processing needs.</p>
			<p>When you’re serializing and deserializing data, your objects and their hierarchies should match your JSON and XML formats so that processing is much faster.</p>
			<p>Microsoft recommends that developers shouldn't use BinaryFormatter for transferring binary data as it is unsafe and can lead to <strong class="bold">denial-of-service</strong> (<strong class="bold">DOS</strong>) attacks. .NET offers several in-box <a id="_idIndexMarker819"/>serializers that can handle untrusted data safely:</p>
			<ul>
				<li><strong class="source-inline">XmlSerializer</strong> and <strong class="source-inline">DataContractSerializer</strong> can serialize object graphs into and from XML. Do not confuse <strong class="source-inline">DataContractSerializer</strong> with <strong class="source-inline">NetDataContractSerializer</strong>.</li>
				<li><strong class="source-inline">BinaryReader</strong> and <strong class="source-inline">BinaryWriter</strong> for XML and JSON.</li>
				<li>The <strong class="source-inline">System.Text.Json</strong> APIs can serialize object graphs into JSON.</li>
			</ul>
			<p>Data types can vary in size as they can hold different data values, and data values can vary in length. Both number values and string values are variable in length. The bigger the number or string, the more bytes are saved to the file. The smaller the number or string, the fewer bytes are saved to the file. Likewise, with data type names, the longer the name, the more bytes are used, and the shorter the name, the fewer bytes are used.</p>
			<p>While writing one or two files occasionally, the size of bytes may not be an issue to the end user or your application’s performance. But when you move into the realms of batch file processing, the more bytes that have to be written per file, the longer batch processing will take to complete. </p>
			<p>Depending on your OS version, drivers, disk, and networking hardware, it is possible that copying or moving <a id="_idIndexMarker820"/>small files is more performance-heavy than moving around large files. You can optimize file transfer at the OS level under the hood by leveraging burst copy or similar techniques.</p>
			<p>As an example, you can have a lot of performance issues when moving around media files (photo/audio/video) or AI/ML datasets (usually text-based). If files are small (ranging from a few KBs to a few MBs), you can group them in ZIP files (without compression, if they’re media files) so that it results in bigger files that can be transferred faster.</p>
			<p>In the next section, we will be benchmarking three different methods for moving files. We will be using <strong class="source-inline">File.Copy</strong>, <strong class="source-inline">FileInfo.MoveTo</strong>, and obtaining <strong class="source-inline">FileInfo</strong> from the memory cache and using <strong class="source-inline">FileInfo.MoveTo</strong>. This will help us identify the quickest method to use in our applications, especially when large numbers of files need to be moved.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor158"/>Moving files</h2>
			<p>A common function in various enterprise applications is the need to move around large numbers of files. For <a id="_idIndexMarker821"/>example, a reporting function may require the amalgamation<a id="_idIndexMarker822"/> of last month’s sales figures from various teams to be entered into a data warehouse for report processing purposes. Those sales figures could reside in spreadsheets in various locations. Each spreadsheet would need to be moved to a central file storage location for further processing. The more files that you have in any file move operation, the more processing time will be required. So, it pays to know which method of moving a large number of files is the most performant in C#.</p>
			<p>With that in mind, we will write a simple application to benchmark three different ways of moving files. Each method that we write will vary in performance. Our method of choice will be the <a id="_idIndexMarker823"/>method that performs the fastest, and this will be identified in our benchmark<a id="_idIndexMarker824"/> summary report once we have run our compiled executable. Let’s start writing our benchmarks:</p>
			<ol>
				<li value="1">Start a new C# .NET 5 console application and name it <strong class="source-inline">CH08_FileAndStreamIO</strong>.</li>
				<li>Install the <strong class="source-inline">BenchmarkDotNet</strong> NuGet package.</li>
				<li>Add a new class called <strong class="source-inline">MovingFiles</strong> to the root of the project:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.IO;</p><p class="source-code">using System.Text;</p><p class="source-code">[MemoryDiagnoser]</p><p class="source-code">[Orderer(SummaryOrderPolicy.Declared)]</p><p class="source-code">[RankColumn]</p><p class="source-code">public class MovingFiles { }</p></li>
			</ol>
			<p>Our class is now set up to benchmark our methods and report on memory usage.</p>
			<ol>
				<li value="4">At the top of the class, add the following code (you can replace the <strong class="source-inline">Moonshine-3.0.0.exe</strong> file with a file of your own choosing):<p class="source-code">private Dictionary&lt;string, FileInfo&gt; _cache;</p><p class="source-code">private const string SOURCE_DIRECTORY = </p><p class="source-code">@"C:\Temp\Source\";</p><p class="source-code">private const string DESTINATION_DIRECTORY = </p><p class="source-code">@"C:\Temp\Destination\";</p><p class="source-code">private const string FILENAME = "Moonshine-3.0.0.exe";</p></li>
			</ol>
			<p>Here, we have declared a dictionary of <strong class="source-inline">FileInfo</strong> objects, which will act as our in-memory cache, and three constants for our source directory, destination directory, and filename. We will need these constants in the other methods we will be writing.</p>
			<ol>
				<li value="5">We need to have a procedure in place to prepare our code so that it can be benchmarked without exceptions<a id="_idIndexMarker825"/> being raised. If we don’t, our <a id="_idIndexMarker826"/>benchmarks will fail to execute more than once because the file will have been moved. Each time a benchmark runs, the moved file needs to be moved back to its original location. So, we are going to need a <strong class="source-inline">[GlobalSetup]</strong> method and a <strong class="source-inline">[GlobalCleanup]</strong> method. First, add the <strong class="source-inline">[GlobalSetup]</strong> method to the <strong class="source-inline">MovingFiles</strong> class. We will call the <strong class="source-inline">PreloadFilesAndCacheThem()</strong> method here:<p class="source-code">[GlobalSetup]</p><p class="source-code">public void PreloadFilesAndCacheThem()</p><p class="source-code">{</p><p class="source-code">var files = new DirectoryInfo(SOURCE_DIRECTORY)</p><p class="source-code">    .GetFileSystemInfos();</p><p class="source-code">_cache = new Dictionary&lt;string, FileInfo&gt;();</p><p class="source-code">foreach (var f in files)</p><p class="source-code">{</p><p class="source-code">    _cache.Add(f.FullName, f as FileInfo);</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This method is getting <strong class="source-inline">FileSystemInfo</strong> for each file in the source directory identified <a id="_idIndexMarker827"/>by the <strong class="source-inline">SOURCE_DIRECTORY</strong> string. Then, it<a id="_idIndexMarker828"/> instantiates <strong class="source-inline">_cache</strong> as a dictionary of <strong class="source-inline">FileInfo</strong> objects. After that, the list of files is iterated through, and the <strong class="source-inline">FileInfo</strong> object for the current file is added to <strong class="source-inline">_cache</strong>.</p>
			<ol>
				<li value="6">Add the <strong class="source-inline">PreMoveCheck() [GlobalCleanup]</strong> method:<p class="source-code">[GlobalCleanup]</p><p class="source-code">public void PreMoveCheck()</p><p class="source-code">{</p><p class="source-code">    if (File.Exists($"{SOURCE_DIRECTORY}{FILENAME}"))</p><p class="source-code">    if (</p><p class="source-code">        File.Exists(</p><p class="source-code">            $"{DESTINATION_DIRECTORY}{FILENAME}")</p><p class="source-code">    )</p><p class="source-code">    {</p><p class="source-code">        File.Delete(</p><p class="source-code">            $"{DESTINATION_DIRECTORY}{FILENAME}");</p><p class="source-code">    }</p><p class="source-code">if (</p><p class="source-code">    !File.Exists($"{SOURCE_DIRECTORY}{FILENAME}")  </p><p class="source-code">    &amp;&amp; File.Exists(</p><p class="source-code">        $"{DESTINATION_DIRECTORY}{ FILENAME}")</p><p class="source-code">)</p><p class="source-code">{</p><p class="source-code">    FileInfo fileinfo = </p><p class="source-code">        new FileInfo(</p><p class="source-code">            $"{DESTINATION_DIRECTORY}{FILENAME}") </p><p class="source-code">              fileinfo.MoveTo(</p><p class="source-code">                $"{SOURCE_DIRECTORY}{FILENAME}");</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>The cleanup code checks whether the file already exists in <strong class="source-inline">SOURCE_DIRECTORY</strong>. If it does, then <strong class="source-inline">DESTINATION_DIRECTORY</strong> is checked for the file. If it exists, it is deleted. If the file does not exist in <strong class="source-inline">SOURCE_DIRECTORY</strong> but exists in <strong class="source-inline">DESTINATION_DIRECTORY</strong>, then the file is moved from <strong class="source-inline">DESTINATION_DIRECTORY</strong> back into <strong class="source-inline">SOURCE_DIRECTORY</strong>.</li>
				<li>We need the <strong class="source-inline">[GlobalSetup]</strong> and <strong class="source-inline">[GlobalCleanup]</strong> methods because if they are <a id="_idIndexMarker829"/>not in place doing what they are doing, the benchmarks<a id="_idIndexMarker830"/> will fail because the file cannot be found.</li>
				<li>Add the <strong class="source-inline">FileCopy()</strong> method to the <strong class="source-inline">MovingFiles</strong> class:<p class="source-code">[Benchmark]</p><p class="source-code">public void FileCopy()</p><p class="source-code">{</p><p class="source-code">    PreMoveCheck();</p><p class="source-code">    File.Copy(</p><p class="source-code">    $"{SOURCE_DIRECTORY}{FILENAME}"</p><p class="source-code">    , $"{DESTINATION_DIRECTORY}{FILENAME}"</p><p class="source-code">);</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">FileCopy()</strong> method performs a <strong class="source-inline">PreMoveCheck()</strong> so that the file is in place, ready for the benchmark to run without failing. It then proceeds to copy the file from <strong class="source-inline">SOURCE_DIRECTORY</strong> to <strong class="source-inline">DESTINATION_DIRECTORY</strong>.</li>
				<li>Now, add the <strong class="source-inline">FileInfoMoveTo()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void FileInfoMoveTo()</p><p class="source-code">{</p><p class="source-code">    PreMoveCheck();</p><p class="source-code">    FileInfo fileinfo = new FileInfo(</p><p class="source-code">    $"{SOURCE_DIRECTORY}{FILENAME}"</p><p class="source-code">);</p><p class="source-code">fileinfo.MoveTo(</p><p class="source-code">    $"{DESTINATION_DIRECTORY}{FILENAME}"</p><p class="source-code">);</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">FileInfoMoveTo()</strong> method <a id="_idIndexMarker831"/>also performs <a id="_idIndexMarker832"/>a <strong class="source-inline">PreMoveCheck()</strong>, ensuring that the file is in place, ready for the move. Then, it creates a <strong class="source-inline">FileInfo</strong> object for the specified file and uses the <strong class="source-inline">MoveTo(string destinatation)</strong> method to move the file from <strong class="source-inline">SOURCE_DIRECTORY</strong> to <strong class="source-inline">DESTINATION_DIRECTORY</strong>.</li>
				<li>Add the <strong class="source-inline">FileInfoReadCacheAndMoveTo()</strong> method to the <strong class="source-inline">MovingFiles</strong> class:<p class="source-code">[Benchmark]</p><p class="source-code">public void FileInfoReadCacheAndMoveTo()</p><p class="source-code">{</p><p class="source-code">    PreMoveCheck();</p><p class="source-code">    FileInfo fileInfo = </p><p class="source-code">    _cache[$"{SOURCE_DIRECTORY}{FILENAME}"];</p><p class="source-code">if (fileInfo.Exists)</p><p class="source-code">    fileInfo.MoveTo(</p><p class="source-code">             $"{DESTINATION_DIRECTORY}{FILENAME}"</p><p class="source-code">    );</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">FileInfoReadCacheAndMoveTo()</strong> method performs a <strong class="source-inline">PreMoveCheck()</strong>. Then, it creates a <strong class="source-inline">FileInfo</strong> object from the <strong class="source-inline">FileInfo</strong> object stored in <strong class="source-inline">_cache</strong>. If the <strong class="source-inline">FileInfo</strong> object exists, it is then moved to <strong class="source-inline">DESTINATION_DIRECTORY</strong>.</li>
				<li>Add the following line of code to the <strong class="source-inline">Main</strong> method in the <strong class="source-inline">Program</strong> class:<p class="source-code">BenchmarkRunner.Run&lt;MovingFiles&gt;();</p></li>
				<li>Build <a id="_idIndexMarker833"/>the project in <strong class="source-inline">Release</strong> mode, and then run the executable<a id="_idIndexMarker834"/> from the command line. You should see the following benchmark summary report:</li>
			</ol>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B16617_Figure_8.1.jpg" alt="Figure 7.1 – The BenchmarkDotNet summary report for various file move operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – The BenchmarkDotNet summary report for various file move operations</p>
			<p>From the timings, we can see that the <strong class="source-inline">File.Copy(string source, string destination)</strong> method is the slowest method of moving files, followed by the <strong class="source-inline">FileInfo.MoveTo(string destination)</strong> method. </p>
			<p>The fastest file move operation is to extract <strong class="source-inline">FileInfo</strong> from the in-memory cache and then use <a id="_idIndexMarker835"/>the <strong class="source-inline">FileInfo.MoveTo(string destination)</strong> method to perform<a id="_idIndexMarker836"/> the move operation.</p>
			<p>In the next section, we will look at two different methods for calculating the size of all the files in a directory. We can then use the fastest method for when we need to calculate the size of directories, such as before doing a batch file move in an enterprise.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor159"/>Calculating directory sizes</h2>
			<p>When you’re batch processing files and directories, it can pay to know how large the sum of files is <a id="_idIndexMarker837"/>before moving them to a new location. This can help<a id="_idIndexMarker838"/> you determine the amount of time that it will take to copy the files, as well as whether the destination has space to store all the files. </p>
			<p>An example of some dialog that pops up when you’re copying or moving files is the Windows Explorer dialog. It traverses the files and directories to be moved or copied. As it does, it logs the total amount of bytes that are being used by the files and directories. Then, it provides a time estimate regarding how long it will take to move or copy those bytes. There are times when this process can take a very long time and be frustrating for the end user.</p>
			<p>Another reason to know about directory sizes is when you have critical business needs that are time-sensitive. Prolonged file move operations can be detrimental to the business’ time plan. In this section, we will calculate directory size by benchmarking two different methods. The method that performs the fastest is the one we would choose when calculating a directory’s size. Let’s begin:</p>
			<ol>
				<li value="1">Add a new class to the project called <strong class="source-inline">GettingFileSizes</strong> and configure it for benchmarking, as you did withthe <strong class="source-inline">MovingFiles</strong> class. Then, add the <strong class="source-inline">DIRECTORY</strong> constant to the top of the class:<p class="source-code">public const string DIRECTORY = @"C:\Windows\System32\";</p></li>
				<li>Add the <strong class="source-inline">GetDirectorySizeUsingGetFileSystemInfos()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public int GetDirectorySizeUsingGetFileSystemInfos()</p><p class="source-code">{</p><p class="source-code">DirectoryInfo directoryInfo = </p><p class="source-code">    new DirectoryInfo(DIRECTORY);</p><p class="source-code">FileSystemInfo[] fileSystemInfos = </p><p class="source-code">    directoryInfo.GetFileSystemInfos();</p><p class="source-code">int directorySize = 0;</p><p class="source-code">for (int i = 0; i &lt; fileSystemInfos.Length; i++)</p><p class="source-code">{</p><p class="source-code">    FileInfo fileInfo = </p><p class="source-code">        fileSystemInfos[i] as FileInfo;</p><p class="source-code">    if (fileInfo != null)</p><p class="source-code">        directorySize += (int)fileInfo.Length;</p><p class="source-code">}</p><p class="source-code">return directorySize;</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">GetDirectorySizeUsingGetFileSystemInfos()</strong> method creates a <a id="_idIndexMarker839"/>new <strong class="source-inline">DirectoryInfo</strong> object <a id="_idIndexMarker840"/>based on the directory defined in the <strong class="source-inline">DIRECTORY</strong> constant. Then, it gets an array of <strong class="source-inline">FileSystemInfo</strong> from the <strong class="source-inline">DirectoryInfo</strong> variable. The <strong class="source-inline">FileSystemInfo</strong> array is then iterated through and the <strong class="source-inline">directorySize</strong> variable is incremented. Once <strong class="source-inline">directorySize</strong> has been calculated, the value is returned to the caller.</li>
				<li>Add <a id="_idIndexMarker841"/>the <strong class="source-inline">GetDirectorySizeUsingArrayAndFileInfo()</strong> method <a id="_idIndexMarker842"/>to the <strong class="source-inline">MovingFiles</strong> class:<p class="source-code">[Benchmark]</p><p class="source-code">public int GetDirectorySizeUsingArrayAndFileInfo()</p><p class="source-code">{</p><p class="source-code">    string[] files = Directory.GetFiles(DIRECTORY);</p><p class="source-code">    int directorySize = 0;</p><p class="source-code">for (int i = 0; i &lt; files.Length; i++)</p><p class="source-code">{</p><p class="source-code">    directorySize += </p><p class="source-code">        (int)(new FileInfo(files[i]).Length);</p><p class="source-code">}</p><p class="source-code">return directorySize;</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">GetDirectorySizeUsingArrayAndFileInfo()</strong> method gets a string array of filenames for the given directory. The array is then iterated and <strong class="source-inline">directorySize</strong> is incremented by the current file size. Once the iteration is complete, <strong class="source-inline">directorySize</strong> is returned.</li>
				<li>Add the <strong class="source-inline">benchmark</strong> runner method to the <strong class="source-inline">Main</strong> method in the <strong class="source-inline">Program</strong> class, perform a <strong class="source-inline">Release</strong> build, and then run the executable from the command line. You will see the following report:</li>
			</ol>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B16617_Figure_8.2.jpg" alt="Figure 7.2 – The benchmark summary report for obtaining directory sizes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – The benchmark summary report for obtaining directory sizes</p>
			<p>As you can see, we used two different methods to calculate the size of the <strong class="source-inline">System32</strong> directory. The slowest method of calculating a directory size was our second method. So, for performance <a id="_idIndexMarker843"/>reasons, the best method for calculating the size<a id="_idIndexMarker844"/> of a directory is to get <strong class="source-inline">DirectoryInfo</strong> for the directory in question. Then, you can call <strong class="source-inline">GetFileSystemInfos()</strong> and iterate through the result, summing the length of the <strong class="source-inline">FileInfo</strong> objects. </p>
			<p>In the next section, we will look at asynchronous file operations.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor160"/>Accessing files asynchronously</h2>
			<p>Why should you <a id="_idIndexMarker845"/>access files asynchronously? Well, here are a few<a id="_idIndexMarker846"/> reasons that you might consider when using asynchronous file access:</p>
			<ul>
				<li>Your user interface thread will be more responsive as the file operation won’t block the user interaction if it takes a few seconds or longer to complete.</li>
				<li>An asynchronous process reduces the need for manually managed threads, making applications more scalable. ASP.NET and server-side applications are specific examples of applications that will benefit from asynchronous file processing.</li>
				<li>File access latency is also something you must consider. Computer resources such as the type of hard disk, network upload and download speeds, and real-time scanning by the security software, as well as file size, are all factors that can affect file access times.</li>
				<li>There is only a small overhead for using asynchronous tasks over threads.</li>
				<li>You can run asynchronous tasks in parallel.</li>
			</ul>
			<p>The <strong class="source-inline">FileStream</strong> class gives you the most control over file access operations. You can configure the class to execute I/O operations at the operating system level. By doing this, you avoid blocking thread pool threads. To execute I/O operations at the operating system level, you must specify one of the following in the constructor call:</p>
			<ul>
				<li><strong class="source-inline">useAsync=true</strong></li>
				<li><strong class="source-inline">options=FileOptions.Asynchronous</strong><p class="callout-heading">Note</p><p class="callout">This option can only be used with the <strong class="source-inline">StreamReader</strong> and <strong class="source-inline">StreamWriter</strong> classes when the stream that’s provided to them is one that was opened by the <strong class="source-inline">FileStream</strong> class.</p></li>
			</ul>
			<p>Now, let’s look at a <a id="_idIndexMarker847"/>very simple example of performing asynchronous<a id="_idIndexMarker848"/> file writing and reading. Let’s start by writing some text to a text file asynchronously. Then, we will read the text from the same file asynchronously.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/>Writing text to a file asynchronously</h2>
			<p>In this section, we <a id="_idIndexMarker849"/>will write some text to a text file asynchronously. There<a id="_idIndexMarker850"/> is a simpler way to perform this task but the method we will be using provides the most control and operates at the operating system level:</p>
			<ol>
				<li value="1">Add a new file to the <strong class="source-inline">CH08_FileAndStreamIO</strong> project called <strong class="source-inline">AsyncFileAccess</strong>.</li>
				<li>Add a new method called <strong class="source-inline">WriteTextToFileAsync(string text, string path)</strong> to the <strong class="source-inline">AsyncFileAccess</strong> class:<p class="source-code">public async Task WriteTextToFileAsync(</p><p class="source-code">string text, string path</p><p class="source-code">)</p><p class="source-code">{</p><p class="source-code">    byte[] encodeText = </p><p class="source-code">      Encoding.Unicode.GetBytes(text);</p><p class="source-code">    using var fileStream = new FileStream(</p><p class="source-code">        path, </p><p class="source-code">    FileMode.Create, </p><p class="source-code">    FileAccess.Write, </p><p class="source-code">    FileShare.None, </p><p class="source-code">    bufferSize: 4096, </p><p class="source-code">    useAsync: true</p><p class="source-code">);</p><p class="source-code">await fileStream.WriteAsync(</p><p class="source-code">    encodeText, 0, encodeText.Length</p><p class="source-code">);</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we pass a string of text in and the name of the file to write the text to. Then, we read all the text into a byte array. Next, we declare an asynchronous <strong class="source-inline">FileStream</strong> variable with a buffer size of 4,096 bytes, write the text asynchronously to the specified file, and wait for the operation to complete. The reason for <a id="_idIndexMarker851"/>using 4,096 bytes is that it is a power<a id="_idIndexMarker852"/> of two number and a memory page size. A page, memory page, or virtual page is a fixed-length contiguous block of virtual memory that’s described by a single entry in the page table. So, when the system chooses to swap out a page to disk, it can do so in one go without any overhead involved.</p>
			<ol>
				<li value="3">Add the <strong class="source-inline">ReadTextFromFileAsync(string path)</strong> method to the <strong class="source-inline">AsynFileAccess</strong> class:<p class="source-code">public async Task&lt;string&gt; ReadTextFromFileAsync(string </p><p class="source-code">    path)</p><p class="source-code">{</p><p class="source-code">StringBuilder sb = new StringBuilder();</p><p class="source-code">byte[] buffer = new byte[0x1000];</p><p class="source-code">int numberOfBytesToDecode;</p><p class="source-code">using var fileStream = new FileStream(</p><p class="source-code">        path,</p><p class="source-code">    FileMode.Open, </p><p class="source-code">    FileAccess.Read, </p><p class="source-code">    FileShare.Read,</p><p class="source-code">    bufferSize: 4096, </p><p class="source-code">    useAsync: true</p><p class="source-code">);</p><p class="source-code">    while (</p><p class="source-code">    (numberOfBytesToDecode = await fileStream.</p><p class="source-code">      ReadAsync(buffer, 0, buffer.Length)) != 0</p><p class="source-code">) </p><p class="source-code">    {</p><p class="source-code">        sb.AppendLine(Encoding.Unicode.GetString(</p><p class="source-code">        buffer, 0, numberOfBytesToDecode</p><p class="source-code">    ));</p><p class="source-code">}</p><p class="source-code">    return sb.ToString();</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we declare a <strong class="source-inline">StringBuilder</strong> for efficient string concatenation. Then, we <a id="_idIndexMarker853"/>declare and initialize a new byte<a id="_idIndexMarker854"/> array that will be our buffer and declare a <strong class="source-inline">numberOfBytesToDecode</strong> variable. A new <strong class="source-inline">FileStream</strong> object is instantiated.</p>
			<p>The <strong class="source-inline">numberOfBytesToDecode</strong> variable is set by awaiting the call to the <strong class="source-inline">ReadAsync</strong> method. This variable is set for each iteration of the <strong class="source-inline">For</strong> loop. For each iteration of the loop, we obtain the number of bytes to be decoded. Then, we append a line to the output, with the items taken from the buffer. Finally, we return the resulting string.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">DemonstrateAsyncFileOps()</strong> method to the <strong class="source-inline">AsyncFileAccess</strong> class:<p class="source-code">public async Task DemonstrateAsyncFileOps()</p><p class="source-code">{</p><p class="source-code">await WriteTextToFileAsync(</p><p class="source-code">         "Supercalifragilisticexpialidocious",</p><p class="source-code">        @"C:\Temp\File\film.txt"</p><p class="source-code">);</p><p class="source-code"> string text = await ReadTextFromFileAsync(</p><p class="source-code">    @"C:\Temp\File\film.txt"</p><p class="source-code">);</p><p class="source-code">Console.WriteLine($"The Text written was: {text}");</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">DemonstrateAsynFileOps()</strong> method writes some text to a file asynchronously by calling the asynchronous<a id="_idIndexMarker855"/> write operation. Then, it reads the text back asynchronously by calling <a id="_idIndexMarker856"/>the asynchronous read operation. The result is then printed to the console window.</p>
			<ol>
				<li value="5">Modify your <strong class="source-inline">Program</strong> class’s <strong class="source-inline">Main</strong> method as follows:<p class="source-code">static async Task Main(string[] args)</p><p class="source-code">{</p><p class="source-code">    AsyncFileAccess afa = new AsyncFileAccess();</p><p class="source-code">    await afa.DemonstrateAsyncFileOps();</p><p class="source-code">}</p></li>
			</ol>
			<p>This code creates a new instance of our <strong class="source-inline">AsyncFileAccess</strong> class, and then calls the <strong class="source-inline">DemonstrateAsyncFileOps()</strong> method. </p>
			<ol>
				<li value="6">Build and run <a id="_idIndexMarker857"/>your code. In your console window, you<a id="_idIndexMarker858"/> should see the following line printed out:<p class="source-code"><strong class="bold">The Text written was: Supercalifragilisticexpialidocious</strong></p></li>
			</ol>
			<p>As can be seen from our simple example, asynchronous file access is fairly straightforward. In the next section, we will look at how to handle I/O exceptions.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/>Handling I/O operation exceptions</h1>
			<p>When working <a id="_idIndexMarker859"/>with I/O operations, you can encounter several different exceptions. The base I/O exception is <strong class="source-inline">IOException</strong>. It pays to differentiate between the different I/O exceptions and to log them as this can help expedite problem resolution.</p>
			<p>The following table provides a breakdown of the various I/O exceptions that can be raised by your I/O operations. By trapping these specific exceptions, you can provide a more detailed exception log entry that helps with identifying the root source of the problem more easily:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B16617_Table_8.2.jpg" alt="Table 7.2 – Microsoft .NET I/O exceptions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 7.2 – Microsoft .NET I/O exceptions</p>
			<p>Now that you <a id="_idIndexMarker860"/>know about the kind of I/O exceptions that can be raised, you also need to know about the correct way to handle, log, and display such exceptions.</p>
			<p>As programmers, we need to write code that can detect malfunctioning code. Code that malfunctions leaves a computer program in an undefined state. This can lead to side effects that are <a id="_idIndexMarker861"/>unexpected and unpredictable. A computer program that is in an unpredictable state can lead to all manner of issues such as performance slowing down, application hangs, and invalid data, leading to incorrect information. This can lead to serious business and consumer issues, and that is not good.</p>
			<p>Therefore, your code needs to be fault-tolerant and should be able to handle faults appropriately. Exceptions should be handled so that data integrity remains intact. You should also bear in mind that there are two categories of exceptions that your computer program should be aware of:</p>
			<ul>
				<li><strong class="bold">Expected exceptions</strong> are exceptions <a id="_idIndexMarker862"/>that your computer program can recover from.</li>
				<li><strong class="bold">Unexpected exceptions</strong> are exceptions <a id="_idIndexMarker863"/>that your computer program is unable to recover from.</li>
			</ul>
			<p>The expected exceptions need to be handled silently. You know what has the potential to fail and why, so you can put defensive code in place to act against such code-raising exceptions in the first place. This is important, as you don’t want bubbling exceptions since this reduces application performance. In turn, a reduction in application performance impacts the user experience.</p>
			<p>Allowing exceptions to propagate through your computer program is expensive in terms of performance. With this in mind, best practice stipulates that it is better to handle exceptions at the point where they occur within your code for improved application performance.</p>
			<p>When you’re trapping for errors using a <strong class="source-inline">try/catch</strong> block, it is also a good practice to have multiple <strong class="source-inline">catch</strong> blocks. The only exceptions that would form the <strong class="source-inline">catch</strong> blocks are those that can be thrown by the current method. You would put the exception <strong class="source-inline">catch</strong> blocks in an order where the most specific exception is at the top, and then reduce to the least specific, which would be your bottom <strong class="source-inline">catch</strong> block. This helps make your code more readable to fellow programmers, and it also makes debugging your code for specific exceptions much easier.</p>
			<p>You can use exception filters to handle an exception when a specific condition is present. If the exception filter returns true, then the exception is handled. But if it returns false, the search for an exception handler continues. It is preferable to use exception filters instead of catching and rethrowing because filters leave the stack unharmed. If a later handler dumps the stack, you can see where the exception originally came from, rather than just the last place it was rethrown.</p>
			<p>When an unexpected exception occurs, it must be thrown because it can have a seriously detrimental effect on the predictability of your computer program. When unexpected exceptions occur, you should log the exception and exit to protect the integrity of your data.</p>
			<p>This is why using <strong class="source-inline">System.Exception</strong> is a bad idea in that it swallows all exceptions. Your methods should only trap for the exceptions that they expect to be raised. All unexpected exceptions should be handled by the application in such a way that the exception is logged and the program is exited. It is in the main application’s <strong class="source-inline">try/catch</strong> block that you would have your <strong class="source-inline">System.Exception</strong> catch block to catch unexpected exceptions. This block would handle all unexpected exceptions that are allowed to bubble up back to the main application code.</p>
			<p>When unexpected exceptions propagate back to the main application code’s exception <strong class="source-inline">catch</strong> block, you can extract the underlying base exception by calling <strong class="source-inline">Exception.GetBaseException()</strong>. This will get the original exception that was raised, causing any subsequent exceptions to also be raised. </p>
			<p>In my experience, I have found that IT professionals will often neglect to review the event log and application <a id="_idIndexMarker864"/>logs when troubleshooting. However, when they have drawn blanks and have asked for my help, this has usually been my first port of call. It may be that nothing gets logged in <strong class="bold">Event Viewer</strong>, and nothing gets logged by the application. But there are times when valuable information does get logged, and it can be a time-saver in terms of problem-solving and getting the application working again in a more stable manner.</p>
			<p>There are essentially three different locations where an exception can be logged:</p>
			<ul>
				<li><strong class="bold">Application log files</strong>: When an exception is encountered, it will be logged by the application to a text file, JSON file, or XML file.</li>
				<li><strong class="bold">Event Viewer</strong>: When an expected exception is encountered, this will be logged by the application to a named event log. When an unexpected exception is encountered such as an application hang, the system will log this exception in either the Windows Application Log or the Windows System Log.</li>
				<li><strong class="bold">The database</strong>: When an application is encountered, the application will log the exception to a database table.</li>
			</ul>
			<p>Whichever mechanism or mechanisms you choose is down to you and your application needs. However, you must make sure that the logs are well-formatted and that the data that’s provided is <a id="_idIndexMarker865"/>meaningful. Logs are no good if they are hard to read and contain lots of noise! </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Use a best practice that dictates managed and unmanaged resources should be correctly disposed of, especially if an application does crash. When providing tech support, I have often come across situations where applications have crashed and locked resources, and where resources have been kept alive in memory. This leads to bad user experiences and can lead to files, directories, and other resources not being accessible, and the application itself not being able to start up. Often, in these cases, the only options are to kill the application using Task Manager or restart the computer.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor163"/>Performing memory tasks efficiently</h1>
			<p>When benchmarking C# programs, you will see that sometimes, the objects that allocate the most memory <a id="_idIndexMarker866"/>will be faster than the methods that allocate fewer objects. A case in point is strings. Using formatted strings can allocate fewer memory interpolated strings. However, formatted strings can be slower than using interpolated strings. We are going to demonstrate this with a really simple piece of code:</p>
			<ol>
				<li value="1">Add a class to the <strong class="bold">CH08_FileAndStreamIO</strong> project called <strong class="source-inline">Memory</strong> and configure it for using <em class="italic">BenchmarkDotNet</em>.</li>
				<li>Add the <strong class="source-inline">ReturnFormattedString()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public string ReturnFormattedString()</p><p class="source-code">{</p><p class="source-code">return string.Format("{0} {1} {2} {3} {4} {5} {6} </p><p class="source-code">    {7} {8} {9}", "The", "quick", "brown", "fox", </p><p class="source-code">    "jumped", "over", "the", "lazy", "dog", "."</p><p class="source-code">);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method returns a formatted string. It is essentially one line and contains no named variables.</p>
			<ol>
				<li value="3">Add the <strong class="source-inline">ReturnInterpolatedString()</strong> method to the <strong class="source-inline">Memory</strong> class:<p class="source-code">[Benchmark]</p><p class="source-code">public string ReturnInterpolatedString()</p><p class="source-code">{</p><p class="source-code">    string thep = "The";</p><p class="source-code">    string quick = "quick";</p><p class="source-code">    string brown = "brown";</p><p class="source-code">    string fox = "fox";</p><p class="source-code">    string jumped = "jumped";</p><p class="source-code">    string over = "over";</p><p class="source-code">    string thel = "the";</p><p class="source-code">    string lazy = "lazy";</p><p class="source-code">    string dog = "dog";</p><p class="source-code">    string period = ".";</p><p class="source-code">return $"{thep} { quick } { brown } { fox } </p><p class="source-code">{jumped} {over} {thel} {lazy} {dog} {period}";</p><p class="source-code">}</p></li>
			</ol>
			<p>This method <a id="_idIndexMarker867"/>declares several strings and assigns values to them. It then returns the interpolated string. This method covers multiple lines and looks like it will be slower and use the most memory. However, the only way to know for sure is to run the benchmarks.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">BenchmarkRunner.Run&lt;Memory&gt;();</strong> call to your <strong class="source-inline">Main</strong> method, do a <strong class="source-inline">Release</strong> build, and then run the executable from the command line. The following screenshot shows the memory that was allocated and the time it took to perform each method:</li>
			</ol>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B16617_Figure_8.3.jpg" alt="Figure 7.3 – The Benchmark summary report comparing String.Format against interoperable strings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – The Benchmark summary report comparing String.Format against interoperable strings</p>
			<p>As you can see, even though we can declare multiple variables and allocate the most memory using our string interoperability method, it is much faster than doing the same thing with <strong class="source-inline">String.Format</strong>. If you have a lot of string processing to do, such as in batch report generation or document processing, then you can almost halve the time it takes to perform your string manipulations using string interoperability. The memory also never reaches generation 1, so it is dealt with efficiently by the garbage collector.</p>
			<p>Also, you need to reduce the amount of boxing and unboxing that you do. Every time you convert a value <a id="_idIndexMarker868"/>type into a reference type, it will be stored on the heap. And every time you convert a reference type into a value type, you place it on the stack. So, what are the performance implications for doing this? Boxing and unboxing are computationally expensive processes. The more computations that are required to perform a function, the slower the process will be. So, by eliminating unnecessary computations caused by boxing and unboxing, you speed up your application and can end up using less memory. So, when you can, try and use value types on the stack instead of reference types on the heap.</p>
			<p>Avoid code duplication in your objects. If you have multiple constructor overrides, then place the common code in the common constructor and do the same with your methods. A class with duplicate code will use more memory than the same class correctly coded to have no duplication. You should always look for ways to refactor your objects to reduce code bloat, and removing code duplication and reusing code is an easy way to do this.</p>
			<p>Memory fragmentation can be a major cause of performance issues for C# programs. Memory fragmentation occurs when objects are added to the heap, garbage is collected, and then other objects fill the <a id="_idIndexMarker869"/>available space. If you end up with free space between the objects in memory, then your memory has become fragmented. The GC will perform a compacting collection when it is most efficient to do so. Doing this manually should only be done after carefully investigating the scenario in question.  </p>
			<p>In C#, you can defragment the <strong class="bold">Large Object Heap</strong> (<strong class="bold">LOH</strong>) using the garbage collection settings that <a id="_idIndexMarker870"/>are available, as follows:</p>
			<pre class="source-code">GCSettings.LargeObjectHeapCompactionMode = </pre>
			<pre class="source-code">GCLargeObjectHeapCompactionMode.CompactOnce; </pre>
			<pre class="source-code">GC.Collect();</pre>
			<p>This code ensures that the objects on the LOH occupy a contiguous area of memory. All the free space that is <a id="_idIndexMarker871"/>located between objects in memory is removed and placed at the end of the allocated memory.</p>
			<p>You should also consider not using finalizers. An object will remain in memory longer if it uses finalizers. This will cause a build-up of memory usage. And a build-up of memory usage will lead to reduced performance by your applications.</p>
			<p>It is a best practice to dispose of objects and resources when you have finished with them. This helps prevent objects remaining in memory that are not being used, and also releases locks on resources such as files and directories.</p>
			<p>When utilizing disposable objects, you should always try and use the <strong class="source-inline">using</strong> statement. This is because when the block of code finishes, the object will automatically be disposed of. When you write a class that uses various disposable resources, even if it does not own those <a id="_idIndexMarker872"/>disposable resources, you should implement the disposable pattern.</p>
			<p>So far, we have looked at file and memory operations and how performance can be impacted. Now, let’s turn our attention to local storage tasks.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor164"/>Understanding local storage tasks</h1>
			<p>On Windows 10, there are <a id="_idIndexMarker873"/>several locations that you can use to store data locally. These are as follows:</p>
			<ul>
				<li><strong class="bold">Local</strong>: Located in the user’s <strong class="source-inline">AppData</strong> folder, this folder can contain settings, files, and folders. This folder is used for data that is not that easy to recreate or download. If you have backup applications that can back up a user’s <strong class="source-inline">AppData</strong> folder, then anything stored in the <strong class="source-inline">Local</strong> folder will be backed up.</li>
				<li><strong class="bold">Local Cache</strong>: Only files created using the <strong class="source-inline">ApplicationData.LocalCacheFolder</strong> property can be stored in the local cache. Items stored using the local cache will be persisted across sessions.</li>
				<li><strong class="bold">Roaming</strong>: Roaming profiles can be used by network users to store their local data on the server. This has the advantage that prudent network managers will ensure profiles are backed up regularly, so users will always have a restore point if they happen to lose data.</li>
				<li><strong class="bold">Temporary</strong>: Use the <strong class="source-inline">AppData\Temp</strong> folder for temporary data. It is a good idea to clean data in the <strong class="source-inline">Temp</strong> folder when you have finished with it. Application initialization and shutdown are good points to perform system housekeeping.</li>
				<li><strong class="bold">C:\ProgramData</strong>: This location is a best practice location for storing application data. However, this location does not always get backed up. So, it is always a good idea to provide an in-application way to ensure data is regularly backed up and stored in a safe location in case your computer dies, which does happen!</li>
			</ul>
			<p>It’s down to you regarding how and where you store your data. From my extensive experience providing IT support to schools, they can have some extremely complicated and very hardened systems security-wise. You cannot assume your application will be installed on the <strong class="source-inline">C:\</strong> drive, and you cannot assume you will have access to the <strong class="source-inline">C:\ProgramData</strong> folder.</p>
			<p>Many business and assessment hours have been lost by schools trying to install and run educational vendor software on such complicated systems. Often, this leads to remote technical support sessions. </p>
			<p>Another problem that can often arise is the use of the Microsoft VirtualStore. When a user installs software and they are presented with the question, <strong class="source-inline">Install for anyone who uses this computer</strong> or <strong class="source-inline">Install for Just Me</strong>, they tend to select the latter. On Windows 10 computers, <strong class="source-inline">Install for Just Me</strong> puts the stored data for the installed application into the user’s virtual store. But selecting <strong class="source-inline">Install for anyone who uses this computer</strong> will normally store application data in the <strong class="source-inline">C:\ProgramData\YOUR_APPLICATION</strong> folder.</p>
			<p>A telltale sign that a user has installed the software for only themselves to use is when multiple people log onto an office computer, and each person has a copy of the data. When this happens, multiple copies of the data exist. These copies can be found in each person’s virtual store.</p>
			<p>This is exactly what happened to me and my colleagues. We develop educational software that comes in standalone, network, and online formats. For our standalone customers, we offer <a id="_idIndexMarker874"/>a single-user license. The data for the application is stored in a Microsoft Access database. Originally a problem on Windows 7, which remains a potential problem on Windows 10, is users being given the prompt to install for just them or all users. When they install for all users, the Microsoft Access database can be found under <strong class="source-inline">C:\ProgramData\CompanyName\ProductName</strong>. All users who log onto the computer to use our software will see the same datasets. But should a user select to install only for themselves, then our software’s data will be stored under the user profile's VirtualStore</p>
			<p>The location of the Virtual Store is <strong class="source-inline">C:\Users\%USERNAME%\AppData\Local\VirtualStore</strong>. This is useful to know because it reduces your time locating the data for the various users under their profiles. The difficulty arises when the customer demands that the data be merged and stored in a central location. When this situation arises, uninstall the software and reinstall it, making sure that you select the option to <strong class="source-inline">Install for all users</strong>. Then, request the users stop using the software until you have provided them with the merged data. Information such as this may not increase the performance of your C# and .NET programs, but it certainly improves your performance when you’re providing technical support. And that can be a feather in your cap, as I have found to my benefit! And as programmers/technical support staff/software developers, we all go through personal <a id="_idIndexMarker875"/>performance reviews to see how well we are doing in our roles.</p>
			<p>Now that we have concluded the material for this chapter, let’s summarize what we have learned.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we started by looking at various file paths. There are four different types of file paths – absolute paths, relative paths, UNC paths, and DOS device paths. </p>
			<p>After discussing the various types of paths, we learned that, by default, Windows and Windows Server are limited to a complete file path length of 256 characters. In today’s world of open source and web-based software working across platforms, this maximum standard length on Windows computers can be very limiting. This can cause backup issues when you’re performing disk-to-disk backups, and deeply nested projects can blow the maximum file path length. To overcome this limitation, we learned how to remove the limit by accessing and modifying the registry.</p>
			<p>The next thing we looked at was the various considerations for improving disk I/O. We started looking at I/O performance considerations by considering the different hardware devices that can affect performance. Then, we benchmarked some code to find the most efficient ways of calculating directory sizes, moving files, and performing asynchronous file manipulation.</p>
			<p>The next thing we looked at was exception handling. We came to understand that bubbling up exceptions unnecessarily affects performance and that they should be caught and dealt with at the source. We also came to understand that we should not swallow exceptions by catching generic exceptions. Generic exceptions should only be a last resource for logging purposes before you close the application down due to encountering a non-recoverable exception.</p>
			<p>We then looked at memory tasks. After benchmarking <strong class="source-inline">string.Format</strong> and interpolated strings, where we learned how using interpolated strings almost doubled our <strong class="source-inline">performane.Next</strong>, we considered memory fragmentation, which can occur when we’re adding and removing objects of various sizes. We also learned how to compact fragmented memory to make it run more efficiently.</p>
			<p>Finally, we looked at local storage tasks. We discussed the various types of local storage available and their uses. Plus, we discussed the end user installation of our products, which can result in different logged-on users having their own sets of data. This problem arises when users choose to install for themselves instead of all users. Thus, each user has their copy of the application data stored against the profile in <strong class="source-inline">C:\Users\%USERNAME%\AppData\Local\VirtualStore</strong>.</p>
			<p>In the next chapter, we will look at networking. But before we do, see if you can answer the following questions. Then, improve your knowledge on the topic of I/O performance by looking at the <em class="italic">Further reading</em> section.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor166"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">What are the various Windows file path formats that you need to be aware of?</li>
				<li>How do you remove the 256-character limit for Windows file paths?</li>
				<li>Which method is the most efficient for calculating directory sizes?</li>
				<li>Which method is the most efficient for moving files?</li>
				<li>When should you catch exceptions using the <strong class="source-inline">Exception</strong> class?</li>
				<li>What is the base I/O <strong class="source-inline">Exception</strong> class?</li>
				<li>What file location options do you have for local storage?</li>
				<li>What is one of the potential pitfalls that may be encountered when users install your software?</li>
				<li>What is the Microsoft Virtual Store?</li>
				<li>Where is the Microsoft Virtual Store located?</li>
			</ol>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor167"/>Further reading</h1>
			<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li><em class="italic">File and Stream I/O</em>: <a href="https://docs.microsoft.com/dotnet/standard/io/">https://docs.microsoft.com/dotnet/standard/io/</a>.</li>
				<li><em class="italic">Pipes</em>: <a href="https://docs.microsoft.com/dotnet/standard/io/pipe-operations">https://docs.microsoft.com/dotnet/standard/io/pipe-operations</a>.</li>
				<li><em class="italic">Faster file move method other than File.Move</em>: <a href="https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move">https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move</a>.</li>
				<li><em class="italic">C# GetFileSystemInfos can get file sizes quickly</em>: <a href="https://thedeveloperblog.com/getfilesysteminfos">https://thedeveloperblog.com/getfilesysteminfos</a>.</li>
				<li><em class="italic">Performance of writing to a file in C#</em>: <a href="https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp">https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp</a>.</li>
				<li><em class="italic">Asynchronous File Processing</em>: https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/using-async-for-file-access#:~:text=%20Asynchronous%20file%20access%20(C#)%20%201%20Use,writing%2010%20text%20files.%20For%20each...%20More.</li>
				<li><em class="italic">How to iterate file directories with PLINQ</em>: <a href="https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3">https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3</a>.</li>
				<li><em class="italic">Handling I/O exceptions in .NET</em>: <a href="https://docs.microsoft.com/dotnet/standard/io/handling-io-errors">https://docs.microsoft.com/dotnet/standard/io/handling-io-errors</a>.</li>
				<li><em class="italic">Calling Windows 10 APIs from a desktop application</em>: https://blogs.windows.com/windowsdeveloper/2017/01/25/calling-windows-10-apis-desktop-application/#vZiZ96PlZUqTduts.97.</li>
				<li><em class="italic">Performance Improvements in .NET 6</em>: <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/">https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/</a>.</li>
				<li><em class="italic">Page (Computer Memory)</em>: <a href="https://en.wikipedia.org/wiki/Page_(computer_memory)">https://en.wikipedia.org/wiki/Page_(computer_memory)</a>.</li>
			</ul>
		</div>
	</body></html>