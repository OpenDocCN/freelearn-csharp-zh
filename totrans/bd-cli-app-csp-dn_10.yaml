- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Testing CLI Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命令行应用程序
- en: Testing is an important phase of any software development project. The purpose
    of testing is to ensure that the application we put into the hands of our users
    behaves as expected and doesn’t cause any harm to users (by leaking their personal
    information or by allowing malicious actors to take advantage of a security issue
    to harm users).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何软件开发项目的重要阶段。测试的目的是确保我们交付给用户的应用程序按预期运行，不会对用户造成任何伤害（通过泄露个人信息或允许恶意行为者利用安全漏洞来伤害用户）。
- en: 'In this chapter, we will discuss why testing is so important and explore different
    testing techniques and tools that will help us achieve this goal. More specifically,
    we will discuss the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论为什么测试如此重要，并探讨不同的测试技术和工具，这些技术和工具将帮助我们实现这一目标。具体来说，我们将讨论以下内容：
- en: Why testing is important
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么测试很重要
- en: Different types of tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的测试类型
- en: What to test, how to do it, and when to run these tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测试什么，如何进行测试，以及何时运行这些测试
- en: How to mock external dependencies when writing unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写单元测试时如何模拟外部依赖
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书配套的GitHub仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10)。
- en: Why is testing so important?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么测试如此重要？
- en: Over the years, testing has proven to be very valuable when it comes to providing
    great software and digital experiences to users. Any developer, team, or organization
    that is serious about their software development project and truly cares about
    their users and the experience they have when using their applications will invest
    in software testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的实践，测试在为用户提供优秀的软件和数字体验方面已被证明非常有价值。任何认真对待软件开发项目、真正关心用户及其使用应用程序体验的开发者、团队或组织都将投资于软件测试。
- en: Testing allows us to ensure that the applications we put into the hands of our
    users are of great quality, reliable, performant, and secure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使我们能够确保我们交付给用户的应用程序具有高质量、可靠性、性能和安全性。
- en: 'Here are some key benefits you can expect from testing your application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试您的应用程序时，您可以期待以下关键好处：
- en: '**Ensuring your application’s quality, usability, and reliability**: Testing
    ensures that the application behaves as expected, meets stakeholders’ needs, adheres
    to business requirements and technical specifications, and provides value to users.
    This helps increase user (and customer) satisfaction and prevents a poorly designed
    or developed application from having a negative impact on the organization’s reputation.
    This can, for example, be achieved by validating API responses and verifying the
    output formatting of the CLI application.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保您的应用程序质量、可用性和可靠性**：测试确保应用程序按预期运行，满足利益相关者的需求，遵守业务需求和技术规范，并为用户提供价值。这有助于提高用户（和客户）的满意度，并防止设计或开发不良的应用程序对组织的声誉产生负面影响。例如，这可以通过验证API响应和验证CLI应用程序的输出格式来实现。'
- en: '**Ensuring your application’s security and compliance**: Testing plays a crucial
    role in validating the security of the application. It helps identify potential
    vulnerabilities and weaknesses that could be exploited by malicious actors. It
    also ensures that the application complies with industry standards, regulations,
    and other critical requirements that an organization (or an industry) might be
    subject to.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保您的应用程序安全性和合规性**：测试在验证应用程序安全性方面发挥着至关重要的作用。它有助于识别可能被恶意行为者利用的潜在漏洞和弱点。它还确保应用程序符合行业标准、法规以及其他组织（或行业）可能面临的关键要求。'
- en: '**Acting as your application’s documentation**: If you have ever worked on
    IT projects, you know how hard it is to maintain accurate and up-to-date documentation.
    A by-product of software testing is that it also acts as live documentation for
    your application: you can run it at any time to understand the behavior of the
    application.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为您应用程序的文档**：如果您曾经参与过IT项目，您就知道维护准确和最新的文档是多么困难。软件测试的一个副产品是它也充当了您应用程序的实时文档：您可以在任何时间运行它来了解应用程序的行为。'
- en: '**Simplify the application’s evolution**: If you have ever worked on IT projects,
    you know how scary it is when you have to modify the code of an application that
    works fine. We even have a saying for that: “If it’s not broken, don’t fix it!”.
    However, by having an efficient suite of tests, modifying that code is way less
    scary because we know that we can rely on that test suite to ensure that we didn’t
    introduce any bug in the existing code and functionalities (we call these *regressions*).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化应用程序的演变**：如果你曾经参与过IT项目，你就知道当你不得不修改一个运行良好的应用程序的代码时是多么可怕。我们甚至为此有一个说法：“如果它没有坏，就不要修它！”然而，通过拥有一个高效的测试套件，修改代码就不再那么可怕了，因为我们知道我们可以依赖这个测试套件来确保我们没有在现有代码和功能中引入任何错误（我们称之为*回归*）。'
- en: '**Achieving cost savings and efficiency**: It is well-known that the cost of
    finding and fixing a bug in production might be 100 times more expensive than
    finding it and fixing it during the development or testing phase. This cost also
    includes the cost of loss of efficiency as the team has to stop working on new
    features and concentrate on fixing that bug.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现成本节约和效率**：众所周知，在生产环境中找到并修复一个错误可能比在开发或测试阶段找到并修复它要贵100倍。这种成本还包括效率损失的成本，因为团队必须停止开发新功能，集中精力修复那个错误。'
- en: This is not a book about testing!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于测试的书！
- en: During my career, I have coached and trained development teams, both for the
    organizations I worked for and for our customers, on testing and raising awareness
    about its importance. That’s why I couldn’t write a book about development without
    covering this topic.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我为我所工作的组织和我们的客户提供了开发和测试方面的指导和培训，以及提高对测试重要性的认识。这就是为什么我不能不涵盖这个主题就写一本关于开发的书籍。
- en: However, although we will provide very valuable information and guidance throughout
    this chapter, keep in mind that this is not a book about software testing. Hence,
    concepts such as test-driven development, behavior-driven development, and code
    coverage, will not be covered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们将在这一章中提供非常有价值的信息和指导，但请记住，这不是一本关于软件测试的书。因此，测试驱动开发、行为驱动开发和代码覆盖率等概念将不会涉及。
- en: That being said, I provide many references in [*Chapter 14*](B22400_14.xhtml#_idTextAnchor236)
    if you want to dig into this fascinating topic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你想要深入了解这个迷人的主题，我在[*第14章*](B22400_14.xhtml#_idTextAnchor236)中提供了许多参考资料。
- en: As you can see, there are various types of tests. Let’s highlight them!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有各种类型的测试。让我们突出它们！
- en: Types of tests
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There is a wide variety of test types. They can be classified into two categories:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类型多种多样。它们可以分为两大类：
- en: '**Functional tests**: This category of tests verifies that the application
    performs its intended function, according to its specifications. In other words,
    it ensures that the application does what it is supposed to do (what it has been
    designed for).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：这类测试验证应用程序是否按照其规格执行其预期功能。换句话说，它确保应用程序做它应该做的事情（它被设计来做什么）。'
- en: '**Non-functional tests**: This category of tests verifies that the application
    does what is intended to do in a way that meets user expectations and quality
    standards.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能测试**：这类测试验证应用程序是否以符合用户期望和质量标准的方式执行其预期功能。'
- en: 'Each of these categories is composed of various types of tests. This figure
    illustrates this relationship:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别都由各种类型的测试组成。这个图展示了这种关系：
- en: '![Figure 10.1 – Categories and types of software tests](img/B22400_10_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 软件测试的类别和类型](img/B22400_10_01.jpg)'
- en: Figure 10.1 – Categories and types of software tests
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 软件测试的类别和类型
- en: 'Let’s briefly describe each of these types of test:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要描述一下这些测试类型：
- en: '**Unit tests**: Here, we focus on testing methods in isolation (i.e., without
    relying on their dependencies such as databases or external services. To achieve
    this, we use *mocking* techniques (more on that later) to avoid relying on these
    dependencies. These tests are usually fast and provide immediate feedback. They
    therefore help ensure that a very specific portion of the code (a method) is doing
    exactly what it is intended to do. In the event that a bug is discovered, this
    type of test proves very useful as it narrows the issue down to the line of code
    that causes it! It is however important not to overuse mocks as it can lead to
    tests that do not represent reality, making them worthless.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在这里，我们专注于单独测试方法（即，不依赖于它们的依赖项，如数据库或外部服务。为了实现这一点，我们使用*模拟*技术（更多内容将在后面介绍）来避免依赖这些依赖项。这些测试通常很快，并提供即时反馈。因此，它们有助于确保代码的特定部分（方法）确实按预期执行。如果在测试中发现了错误，此类测试非常有用，因为它将问题缩小到导致错误的代码行！然而，重要的是不要过度使用模拟，因为这可能导致不反映现实的测试，使它们变得毫无价值。'
- en: '**Integration tests**: This type of test verifies the interactions between
    different components of the application, ensuring that the integrated parts work
    together as expected. It also helps ensure that the flow of data and communication
    between these components is correct and can surface integration issues, usually
    due to interface defects.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：此类测试验证应用程序不同组件之间的交互，确保集成部分按预期协同工作。它还帮助确保这些组件之间的数据流和通信是正确的，并且可以暴露集成问题，通常是由于接口缺陷引起的。'
- en: '**System tests**: This type of test verifies that the complete application
    meets the specified requirements. This covers end-to-end functionality and behavior
    and relies on external dependencies. These tests are performed in an environment
    that is similar to the production environment (usually the staging or pre-production
    environment).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：此类测试验证完整的应用程序是否符合指定的要求。这包括端到端的功能和行为，并依赖于外部依赖。这些测试在类似于生产环境的环境中执行（通常是预生产环境或测试环境）。'
- en: '**Acceptance tests**: This type of test validates that the application meets
    the users’ needs and business requirements. The main difference is that acceptance
    tests are usually performed by users or stakeholders and serve as a final approval
    before going to production.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：此类测试验证应用程序是否符合用户需求和业务要求。主要区别在于，验收测试通常由用户或利益相关者执行，并在投入生产前作为最终批准。'
- en: 'We just described the types of functional tests. Let’s now describe the types
    of non-functional tests:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述了功能测试的类型。现在让我们描述非功能测试的类型：
- en: '**Security tests**: This type of test is intended to reveal vulnerabilities
    and security breaches in the application and aims to protect users against data
    breaches, unauthorized access, and cyber-attacks in general.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全测试**：此类测试旨在揭示应用程序中的漏洞和安全漏洞，旨在保护用户免受数据泄露、未经授权的访问和一般网络攻击。'
- en: '**Performance tests**: This type of test is intended to identify performance
    issues and bottlenecks by measuring response times and resource usage and identifying
    scalability or capacity limits under various workloads.. This provides valuable
    insights into what parts of the application require special attention, such as
    redesigning or refactoring, in order to meet the performance requirements and
    users’ expectations.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：此类测试旨在通过测量响应时间和资源使用情况，以及在各种工作负载下识别可扩展性或容量限制来识别性能问题和瓶颈。这为需要特别关注的应用程序部分提供了宝贵的见解，例如重新设计或重构，以满足性能要求和用户期望。'
- en: '**Usability tests**: This type of test focuses on assessing the user-friendliness
    and ease of use of the application. This involves asking real users to test the
    application by completing tasks, gathering feedback and metrics along the way
    (such as the user experience in general, how easy it is to navigate the application,
    how long it takes to complete a task, and the user’s appreciation in general).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**：此类测试侧重于评估应用程序的用户友好性和易用性。这包括让真实用户通过完成任务来测试应用程序，在过程中收集反馈和指标（例如，用户体验总体情况、导航应用程序的难易程度、完成任务所需的时间以及用户的总体评价）。'
- en: '`interactive` command, which means that the terminal it is running in is compliant
    with the requirements. We should then ensure that it works as expected when these
    requirements are met and gracefully degrades (e.g., converts to text-based output)
    when they are not.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`交互式`命令，这意味着它运行的终端符合要求。然后我们应该确保当这些要求得到满足时，它按预期工作，并在它们不满足时优雅地降级（例如，转换为基于文本的输出）。'
- en: About usability tests
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于可用性测试
- en: As you may have guessed, usability tests are intended to be performed manually.
    While it may not always be possible to gather real users together to perform these
    tests, one way to achieve this goal in the context of a CLI application is by
    implementing a command in the CLI application that allows users to provide feedback.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，可用性测试旨在手动执行。虽然不一定总是能够聚集真实用户来执行这些测试，但在CLI应用程序的上下文中实现一个命令，允许用户提供反馈，是一种实现这一目标的方法。
- en: 'Here is, as an example, how the Azure CLI team does it: they provide a `survey`
    command that directs the user to an online form where they can provide feedback.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子，说明Azure CLI团队是如何做的：他们提供了一个`survey`命令，将用户引导到一个在线表单，他们可以在那里提供反馈。
- en: '![Figure 10.2 – Allowing users to provide feedback](img/B22400_10_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 允许用户提供反馈](img/B22400_10_02.jpg)'
- en: Figure 10.2 – Allowing users to provide feedback
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 允许用户提供反馈
- en: The pyramid of (software) testing
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试（软件）金字塔
- en: Many of you may not be familiar with the concepts of functional and non-functional
    tests, but you may be familiar with the pyramid of testing. It is worth mentioning
    that this pyramid includes many of the functional and non-functional types of
    test that we just discussed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人对功能测试和非功能测试的概念可能不太熟悉，但你们可能对测试金字塔很熟悉。值得一提的是，这个金字塔包括了我们在讨论中提到的许多功能测试和非功能测试类型。
- en: 'As a reminder, the pyramid of testing looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，测试金字塔看起来是这样的：
- en: '![Figure 10.3 – The pyramid of (software) testing](img/B22400_10_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 测试（软件）金字塔](img/B22400_10_03.jpg)'
- en: Figure 10.3 – The pyramid of (software) testing
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 测试（软件）金字塔
- en: The reason this is presented as a pyramid is to illustrate the quantity of tests
    to be expected at each step. The larger the step, the more tests it is expected
    to contain. As an example, a project is likely to have more unit tests than system
    tests and more system tests than UAT tests. This is due to the cost of creating
    and maintaining such tests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将其呈现为金字塔的原因是为了说明每个步骤预期的测试数量。步骤越大，预期的测试就越多。例如，一个项目可能比系统测试有更多的单元测试，比UAT测试有更多的系统测试。这是由于创建和维护此类测试的成本。
- en: It is important to keep in mind that what separates these various types of tests
    is their scope and their intent, not the frameworks or libraries used to implement
    them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，区分这些不同类型测试的是它们的范围和意图，而不是实现它们的框架或库。
- en: It is also important to keep in mind that you can create your own types of tests
    if you need to. Let me give you some examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点很重要，那就是要记住，如果你需要的话，你可以创建自己的测试类型。让我给你举几个例子。
- en: About custom types of tests
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于自定义测试类型
- en: In my career, I have worked with organizations that had their own custom types
    of tests that suited their needs and policies.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我与那些拥有适合其需求和政策的自定义测试类型的组织合作过。
- en: For example, some organizations may have *architectural tests*, which are tests
    written to ensure that an application (and its components) are developed following
    their architectural standards, such as what components can reference what components,
    ensure that every service class exposes an interface, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些组织可能有*架构测试*，这些测试是为了确保应用程序（及其组件）按照其架构标准开发，例如哪些组件可以引用哪些组件，确保每个服务类都公开了一个接口，等等。
- en: Another type of test I have seen can be referred to as *naming conventions tests*.
    These tests are meant to ensure that every component (such as classes, services
    or libraries) is named according to the organization’s naming conventions and
    standards.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我还见过另一种类型的测试，可以称为*命名约定测试*。这些测试的目的是确保每个组件（如类、服务或库）都按照组织的命名约定和标准命名。
- en: These two types of tests are intended to simplify the code review process and
    can be automated as part of validating a pull request.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的测试旨在简化代码审查过程，可以作为验证拉取请求的一部分进行自动化。
- en: 'We now have a better understanding of the various types of tests. The next
    logical question (the one that I get every time I discuss software testing with
    clients) is: *“What should we test?”* Let’s discuss this now.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对各种测试类型有了更好的理解。下一个合乎逻辑的问题（每次我与客户讨论软件测试时都会遇到的问题）是：“我们应该测试什么？”让我们现在讨论这个问题。
- en: What should we test?
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们应该测试什么？
- en: This is a great question!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题！
- en: 'It is easy to say that you should test every possible scenario in your application.
    However, we need to consider the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易说你应该测试应用程序中每个可能的场景。然而，我们需要考虑以下因素：
- en: How do you define “every scenario”?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何定义“每个场景”？
- en: Can you really test “every scenario”? How many tests does that mean?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你真的能测试“每个场景”吗？这意味着需要多少个测试？
- en: 'In a nutshell, your suite of tests should cover both of the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您的测试套件应该涵盖以下两个方面：
- en: '**The happy path**: This means testing the situation in which the required
    input for your application is provided and is in the expected format'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**愉快的路径**：这意味着测试在应用程序所需输入提供且格式正确的情况下的情况'
- en: '**The unhappy path**: Here, we test the behavior of the application under unexpected
    circumstances, such as input in the wrong format, user errors, network issues
    (when relying on external dependencies), the user canceling a task, and so on'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不愉快的路径**：在这里，我们测试应用程序在意外情况下的行为，例如输入格式错误、用户错误、网络问题（当依赖外部依赖项时）、用户取消任务等'
- en: 'Once again, this is not a book about software testing, but I would like to
    give you some guidance on what to test in different situations:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这不是一本关于软件测试的书，但我愿意给你一些在不同情况下应该测试什么的指导：
- en: '| **Input parameters** | Test both valid and invalid values.As an example,
    if a method takes only one integer parameter, and the range of valid values is
    between 1 and 100, we should also test it with values outside of this range, such
    as `-1`, `0`, and `2000` (we usually call these `"bonjour"` or `1.23`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **输入参数** | 测试有效和无效的值。例如，如果一个方法只接受一个整数参数，有效值的范围在1到100之间，我们也应该使用这个范围之外的值进行测试，例如`-1`、`0`和`2000`（我们通常称之为“bonjour”或`1.23`。
    |'
- en: '| **Lists** | When dealing with lists, we should ensure that the list only
    contains the expected elements, no more, no less. It is not sufficient to check
    the number of elements in the list because if a bug in the code inserts an element
    more than once or inserts inappropriate elements, the count could meet the expected
    value, but the list might not contain the appropriate elements. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **列表** | 在处理列表时，我们应该确保列表只包含预期的元素，不多也不少。仅检查列表中的元素数量是不够的，因为如果代码中的错误导致元素插入多次或插入不适当的元素，计数可能达到预期值，但列表可能不包含适当的元素。
    |'
- en: '| **Exceptions** | If the application throws exceptions, this should be tested
    too to ensure that the right type of exception is thrown and with the expected
    details. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **异常** | 如果应用程序抛出异常，这也应该被测试以确保抛出了正确的异常类型，并且具有预期的详细信息。 |'
- en: '| **Methods/services** **returned values** | It is easy to verify that a numerical
    or string value matches the expected value, but if the return value is an object
    (or a list of objects), we should verify that the values of all meaningful properties
    match the expected ones. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **方法/服务** **返回值** | 验证数值或字符串值与预期值匹配很容易，但如果返回值是一个对象（或对象列表），我们应该验证所有有意义的属性值与预期值匹配。
    |'
- en: '| **Methods/services** **behavior** | While most developers verify the returned
    values of their methods or services when implementing tests, they fail at verifying
    that these methods or services behave as expected.Verifying the behavior of a
    method or service means that we need to ensure that:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '| **方法/服务** **行为** | 虽然大多数开发者在实现测试时验证方法或服务的返回值，但他们未能验证这些方法或服务是否按预期行为。验证方法或服务的行为意味着我们需要确保：'
- en: The correct subsequent methods are called with the expected parameters. These
    could be logging or caching methods or calls to external dependencies such as
    database or external APIs for example.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的后续方法以预期的参数被调用。这些可能是日志记录或缓存方法，或者是对数据库或外部API等外部依赖项的调用。
- en: The state changes within the object, the class, or the service are accurate
    and expected.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象、类或服务内部的状态变化是准确且预期的。
- en: Side effects, such as database updates or changes to files, are accurate and
    expected.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如数据库更新或文件更改之类的副作用是准确且预期的。
- en: Idempotency occurs when appropriate, which means that if the same method is
    called more than once, it maintains the coherence of the system. Think of a method
    that performs a call to a payment gateway or to a reservation system. We certainly
    don’t want the customer to be charged twice for the same purchase, nor for multiple
    reservations to be made for the same appointment.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当适当的时候会发生幂等性，这意味着如果同一个方法被多次调用，它将保持系统的连贯性。想象一下一个执行对支付网关或预订系统的调用的方法。我们当然不希望顾客为同一笔购买支付两次费用，也不希望为同一预约做出多次预订。
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Figure 10.4 – What to test
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 需要测试的内容
- en: It is just as important to know what to test as it is to know what *not* to
    test.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 了解需要测试的内容和了解不需要测试的内容同样重要。
- en: What not to test
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不需要测试的内容
- en: You should not test external frameworks and libraries because this is the responsibility
    of their creators and maintainers. It is very likely that they have already been
    tested before you had a chance to use them. So, don’t do this, please!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该测试外部框架和库，因为这属于它们的创建者和维护者的责任。很可能在你有机会使用它们之前，它们已经被测试过了。所以，请不要这样做！
- en: Other code artifacts that do not need to be tested are model classes and **Data
    Transfer Objects** (**DTOs**) as they are supposed to only contain properties,
    not methods, since they do not perform any processing of any kind, only move data
    around.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其他不需要测试的代码组件是模型类和**数据传输对象**（**DTOs**），因为它们只应包含属性，而不是方法，因为它们不执行任何类型的处理，只是移动数据。
- en: 'Also, you may have heard that it is not recommended to test private methods.
    There is a heated debate about whether we should test private methods. My personal
    opinion is that you should not, for two main reasons:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能听说过不建议测试私有方法。关于我们是否应该测试私有方法，存在激烈的争论。我个人的观点是，你不应该测试，主要有两个原因：
- en: '**A private method is intended to be invoked by at least one public method**:
    Hence, when testing that public method, you are also testing the private one.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有方法是为了至少被一个公共方法调用**：因此，当测试那个公共方法时，你也在测试私有方法。'
- en: '`Object` to pass parameters to it. It is hence very easy to break these tests
    at runtime (they will compile, though) since the name of the method is usually
    passed as a string, and since every data type inherits from the `Object` class,
    if we change the data type or structure for a given parameter, it will still inherit
    from that same base class even though it is not expected by the private method
    anymore.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object`来传递参数给它。因此，在运行时很容易破坏这些测试（尽管它们可以编译），因为方法的名字通常作为字符串传递，并且由于每个数据类型都继承自`Object`类，如果我们更改给定参数的数据类型或结构，它仍然会继承那个相同的基类，即使私有方法不再期望它了。'
- en: Testing is a safety net
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试是一个安全网
- en: 'As I tell my customers and students, a test suite is like a safety net:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我告诉我的客户和学生一样，测试套件就像一个安全网：
- en: The more test cases you cover, the wider the safety net. If you fall from 30
    feet and your safety net is 2 inches by 2 inches, the chances are that it won’t
    help.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你覆盖的测试用例越多，安全网就越宽。如果你从30英尺的高度落下，而你的安全网只有2英寸乘2英寸，那么它可能不会有所帮助。
- en: On the other hand, if you have a safety net that is 50 feet by 50 feet but its
    meshes are 3 feet by 3 feet large, it won’t help either. What I mean here is that
    if you have an extensive test suite in terms of a number of tests, but these tests
    do not cover meaningful situations, your test suite is of no use.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果你有一个50英尺乘50英尺的安全网，但它的网眼是3英尺乘3英尺大的，那么它也不会有所帮助。我的意思是，如果你在测试套件的数量上非常广泛，但这些测试没有覆盖有意义的场景，那么你的测试套件就没有任何用处。
- en: So, we are now aware of the different types of tests, and we know what to test.
    But when should we run these tests? Let’s discuss this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经了解了不同类型的测试，也知道应该测试什么。但是，我们应该在什么时候运行这些测试呢？让我们来讨论这个问题。
- en: When should we run tests?
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们应该在什么时候运行测试？
- en: The various types of tests we discussed are intended to be run at different
    points during the development lifecycle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的各种类型的测试旨在在开发生命周期的不同阶段运行。
- en: 'An organization (or even a developer or a team) may have policies and preferences
    but, in general, the following recommendations are adopted by the industry:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组织（甚至是一个开发者或一个团队）可能有政策和偏好，但总的来说，以下建议被行业所采纳：
- en: '**Unit tests**: These tests are intended to be run during development. In other
    words, the developer should run them as they write the code. There are some IDEs
    (such as Visual Studio Enterprise) that even allow you to configure unit tests
    to be run in the background as you type your code! This has to be configured and
    used carefully as it might quickly become cumbersome. You have to, however, run
    them before committing your changes, and before creating or updating a pull request.
    Unit tests are also usually run as part of a CI/CD pipeline. For these reasons,
    unit tests should always be automated and are actually very easy to automate.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试旨在在开发期间运行。换句话说，开发者在编写代码时应运行它们。一些 IDE（如 Visual Studio Enterprise）甚至允许你配置单元测试在编写代码时在后台运行！这必须谨慎配置和使用，因为它可能会很快变得繁琐。然而，你必须在提交更改之前、在创建或更新拉取请求之前运行它们。单元测试通常也是
    CI/CD 管道的一部分。因此，单元测试应该始终自动化，实际上自动化起来非常容易。'
- en: '**Integration tests**: These tests are to be run after unit tests have passed
    (that is, run successfully).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试应在单元测试通过（即成功运行）后运行。'
- en: '**Smoke tests**: These tests should be run after a new build has been deployed
    and before QA testers engage in more extensive testing. For this reason, these
    tests are usually triggered by the CI/CD pipeline, right after the deployment
    operation is completed.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟测试**：这些测试应在新构建部署后、QA 测试人员开始更广泛的测试之前运行。因此，这些测试通常由 CI/CD 管道在部署操作完成后立即触发。'
- en: '**System tests**: These tests are run on a staging or pre-production environment,
    right before releasing the application to production. These tests are to be triggered
    after integration tests have passed.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：这些测试在发布应用程序到生产环境之前，在预发布或预生产环境中运行。这些测试应在集成测试通过后触发。'
- en: '**Regression tests**: These tests should be run at least before committing
    your changes. They should also be part of the CI/CD pipeline.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：这些测试至少应在提交更改之前运行。它们也应作为 CI/CD 管道的一部分。'
- en: '**Performance tests**: These should be run when new features (especially the
    ones dealing with external dependencies) or any significant code changes have
    been made.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：当添加新功能（尤其是处理外部依赖项的功能）或进行任何重大代码更改时，应该运行这些测试。'
- en: '**UAT tests**: These special tests are performed by users (or their representatives,
    such as stakeholders) and are intended to obtain final approval before releasing
    the application to production. Hence, these tests are usually manual.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户验收测试（UAT）**：这些特殊测试由用户（或其代表，如利益相关者）执行，目的是在将应用程序发布到生产之前获得最终批准。因此，这些测试通常是手动的。'
- en: As you may have noticed, we haven’t covered all the possible types of tests.
    We have only focused on the ones that are part of the pyramid of software testing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们并没有涵盖所有可能的测试类型。我们只关注了软件测试金字塔中的那些测试。
- en: Okay. Now that we understand the importance of software testing, and we know
    what to test, let’s implement testing into our CLI application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们了解了软件测试的重要性，也知道要测试什么，让我们将测试实现到我们的 CLI 应用程序中。
- en: Adding a test project to Bookmarkr
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将测试项目添加到 Bookmarkr
- en: In order to add a test project for our CLI application, I needed to make a slight
    change to the project structure, which was to extract the solution file (`.sln`)
    from the project directory and edit it to update the path to the `.csproj` file.
    This allows us to create a test project and add it to the solution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的 CLI 应用程序添加测试项目，我需要对项目结构进行一些微调，即从项目目录中提取解决方案文件（`.sln`），并编辑它以更新 `.csproj`
    文件的路径。这允许我们创建测试项目并将其添加到解决方案中。
- en: 'Next, let’s type the following command to create the test project:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们输入以下命令来创建测试项目：
- en: '[PRE0]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a new directory, named `bookmarkr.UnitTests`, in which the
    content of the test project will reside.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的目录，命名为 `bookmarkr.UnitTests`，其中将存放测试项目的所有内容。
- en: 'Right now, this directory only contains two files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个目录只包含两个文件：
- en: '`Bookmarkr.UnitTests.csproj`, which describes the project, its configuration,
    and its dependencies'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bookmarkr.UnitTests.csproj`，它描述了项目、其配置及其依赖项'
- en: '`UnitTest1.cs`, which acts as a sample test class'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnitTest1.cs`，它作为一个示例测试类'
- en: It is interesting to note that the `.csproj` file already references some testing
    libraries and frameworks, particularly the **MS Test** testing framework, which
    is the one we will be using throughout this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`.csproj` 文件已经引用了一些测试库和框架，特别是 **MS Test** 测试框架，这是我们将在本章中使用的框架。
- en: About testing frameworks
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试框架
- en: 'While there are many testing frameworks, the most common ones being **NUnit**,
    **xUnit**, and **MS Test**, we decided to use the latter for many reasons:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多测试框架，其中最常见的是**NUnit**、**xUnit**和**MS Test**，但我们决定使用后者，原因有很多：
- en: '- MS Test is Microsoft’s testing framework and is widely known and used'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '- MS Test是微软的测试框架，广为人知且广泛使用'
- en: '- MS Test has evolved over the years and has a rich feature set, such as built-in
    support for testing parallel code, data-driven testing, and test grouping capabilities'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '- MS Test在多年中不断发展，具有丰富的功能集，例如内置对并行代码测试、数据驱动测试和测试分组功能的支持'
- en: That being said, no matter what your preferred testing framework is, the concepts
    are similar and the one covered in this chapter will apply as well. The main difference
    will be in the keywords provided by each testing framework.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，无论你喜欢的测试框架是什么，概念都是相似的，本章中涵盖的内容也适用。主要区别将在于每个测试框架提供的关键字。
- en: It is also interesting to note that the test project is defined as *non-packable*.
    This means that this project will not be packaged and distributed as part of the
    application, which makes perfect sense.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有趣的是，测试项目被定义为*不可打包的*。这意味着该项目不会作为应用程序的一部分进行打包和分发，这在逻辑上是完全合理的。
- en: 'But before we go any further, let’s add the test project to the solution using
    this command (which has to be run at the same location as the `.``sln` file):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们继续之前，让我们使用以下命令将测试项目添加到解决方案中（该命令必须在`.sln`文件相同的目录下运行）：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, if we open the solution in Visual Studio, it will contain both the code
    and the test projects.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开Visual Studio中的解决方案，它将包含代码和测试项目。
- en: 'The next step is to make our test project reference the actual project. This
    is required so that we can test the actual code. So, let’s navigate to the test
    project’s directory and type this command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让我们的测试项目引用实际项目。这是必要的，这样我们才能测试实际代码。所以，让我们导航到测试项目的目录并输入以下命令：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is one last step we need to take before we start implementing unit tests,
    which is to define a structure for our test project.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现单元测试之前，我们还需要采取最后一步，即定义我们的测试项目结构。
- en: Structuring the test project
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试项目的结构
- en: Each developer, team, or organization will have preferences when it comes to
    structuring their test projects. In this section, I will introduce you to my way
    of structuring test projects, which I implemented during my career and found valuable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者、团队或组织在结构化他们的测试项目时都会有自己的偏好。在本节中，我将向你介绍我在职业生涯中实施并认为有价值的测试项目结构化方法。
- en: 'First, if your application is composed of multiple components and each component
    has its own Visual Studio project, you will want to create a separate unit tests
    project for each component while having a single integration tests project. This
    structure may be similar to this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你的应用程序由多个组件组成，并且每个组件都有自己的Visual Studio项目，你将希望为每个组件创建一个单独的单元测试项目，同时保留一个单独的集成测试项目。这种结构可能类似于以下内容：
- en: '![Figure 10.5 – Structure of test projects](img/B22400_10_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 测试项目的结构](img/B22400_10_04.jpg)'
- en: Figure 10.5 – Structure of test projects
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 测试项目的结构
- en: In this chapter, we will only focus on unit tests, but the same principles apply
    to integration tests. This is the reason why we only have a `bookmarkr.UnitTests`
    project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅关注单元测试，但同样的原则也适用于集成测试。这就是为什么我们只有一个`bookmarkr.UnitTests`项目的原因。
- en: However, if you create multiple test projects within the solution, remember
    to always use the same version of the testing framework across all projects to
    prevent side effects due to compatibility issues.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在解决方案中创建了多个测试项目，请记住始终在所有项目中使用相同的测试框架版本，以防止由于兼容性问题而产生的副作用。
- en: Now, let’s structure our unit tests project. Here, again, there are unlimited
    possibilities depending on personal choices and teams’/organizations’ policies.
    My approach is to have one test class for each code class. The test class will
    have the same name as the code class completed with the `Tests` suffix. I also
    like to replicate, in the test project, the same folder structure as in the code
    project as I find it easier to navigate in the test project because of the structure
    parity between the two projects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来构建我们的单元测试项目。在这里，同样，根据个人选择和团队/组织的政策，有无限的可能性。我的方法是为每个代码类创建一个测试类。测试类的名称将与代码类相同，并在后面加上`Tests`后缀。我还喜欢在测试项目中复制与代码项目相同的文件夹结构，因为我发现由于两个项目之间的结构对等性，这使得在测试项目中导航更容易。
- en: 'After applying these principles, the structure of our test project looks as
    follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些原则后，我们的测试项目结构如下：
- en: '![Figure 10.6 – Test project’s structure](img/B22400_10_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 测试项目的结构](img/B22400_10_05.jpg)'
- en: Figure 10.6 – Test project’s structure
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 测试项目的结构
- en: Now that the structure of our test project is set up, we can start implementing
    our unit tests. But wait! Are there any code artifacts that should not be tested?
    Yes, indeed!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了测试项目的结构，我们可以开始实现我们的单元测试。但是等等！是否有不应该被测试的代码工件？是的，确实有！
- en: Code artifacts that should not be tested
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不应该被测试的代码工件
- en: 'The following artifacts do not need to be tested since they do not perform
    any processing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这些工件不需要进行测试，因为它们不执行任何处理：
- en: '`Bookmark.cs` and `BookmarkConflictModel.cs` since they are only model classes
    and hence only serve the purpose of moving data around.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bookmark.cs`和`BookmarkConflictModel.cs`，因为它们只是模型类，因此只用于在数据之间移动。'
- en: '`Program.cs`: The purpose of this class is to configure the CLI application,
    configure logging, identify which command is the root command and build the command
    hierarchy.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program.cs`：这个类的作用是配置CLI应用程序，配置日志，识别哪个命令是根命令，并构建命令层次结构。'
- en: '`Helper.cs`: This helper class’s methods are used to format the text outputs
    using different colors and formatting. Hence, this class is more suitable for
    UI testing rather than unit testing. For this reason, it is excluded from unit
    testing. However, it could be tested as part of manual tests or end-to-end tests.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Helper.cs`：这个辅助类的方 法用于使用不同的颜色和格式来格式化文本输出。因此，这个类更适合UI测试而不是单元测试。因此，它被排除在单元测试之外。然而，它可以作为手动测试或端到端测试的一部分进行测试。'
- en: Keep in mind that even though we decided not to test these code artifacts for
    valid reasons, MS Test will tell us, as part of the test results, that these artifacts
    were not tested.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管我们出于有效的原因决定不测试这些代码工件，但MS Test会在测试结果中告诉我们这些工件没有被测试。
- en: 'We can inform MS Test that we have chosen not to test these artifacts using
    the `[ExcludeFromCodeCoverage]` attribute. This attribute is very flexible: it
    can be applied to the property, method, class, or even assembly level. This attribute
    also allows us to pass a string to justify our decision.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`[ExcludeFromCodeCoverage]`属性通知MS Test我们不打算测试这些工件。这个属性非常灵活：它可以应用于属性、方法、类，甚至程序集级别。此属性还允许我们传递一个字符串来解释我们的决定。
- en: 'As an example, this is how we will apply it to the `Program` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将如何将其应用于`Program`类：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are finally ready to start implementing some tests. Let’s dive in!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好开始实现一些测试了。让我们深入进去！
- en: Writing effective tests
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写有效的测试
- en: We will learn how to implement tests by writing tests for the `link` and the
    `import` commands.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为`link`和`import`命令编写测试来学习如何实现测试。
- en: The first thing we need to do is to add a test class for each command. We already
    have the folder structure in place, so let’s add the test classes. As I mentioned
    earlier, I find it useful to name my test classes after the actual classes with
    an added suffix of `Tests`. So, our test classes will be named `LinkCommandTests`
    and `ImportCommandTests`, respectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为每个命令添加一个测试类。我们已经有了文件夹结构，所以让我们添加测试类。正如我之前提到的，我发现将测试类命名为实际类名后加上后缀`Tests`很有用。因此，我们的测试类将被命名为`LinkCommandTests`和`ImportCommandTests`。
- en: 'Now, let me introduce you to the best practices of structuring a test class
    and its test methods (yes, we will talk about structure once again! 😊):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我向您介绍结构化测试类及其测试方法的最佳实践（是的，我们还将再次讨论结构！😊）：
- en: Using MS Test, a test class is decorated with the `[TestClass]` attribute. If
    you don’t provide this attribute, the class will not be considered a test class
    and the test methods it contains will not be run.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MS Test，一个测试类会被`[TestClass]`属性装饰。如果您不提供此属性，则该类将不会被考虑为测试类，它包含的测试方法也不会被执行。
- en: A test class usually consists of multiple test methods. The name of a test method
    should convey its intent. This is important since the test report will only present
    the names of the methods along with an icon indicating the result of this test
    method (pass, fail, skipped, and so on). The usual approach is that the name of
    test a method is composed of its name, its input parameters’ values, and the expected
    result. Examples of such names are `GetEmployeeById_ValidId_ReturnsTheExpectedEmployeeObject`
    and `GetEmployeeById_InvalidId_ThrowsEmployeeNotFoundException.`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类通常由多个测试方法组成。测试方法的名字应该传达其意图。这很重要，因为测试报告只会展示方法的名称以及一个图标来指示这个测试方法的测试结果（通过、失败、跳过等）。通常的做法是，测试方法的名称由其名称、输入参数的值和预期结果组成。这样的名称示例有`GetEmployeeById_ValidId_ReturnsTheExpectedEmployeeObject`和`GetEmployeeById_InvalidId_ThrowsEmployeeNotFoundException`。
- en: Using MS Test, a test method is decorated with the `[TestMethod]` attribute.
    If you don’t provide this attribute, the class will not be considered as a test
    method and will not be run.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MS Test，测试方法用`[TestMethod]`属性装饰。如果你不提供这个属性，类将不会被考虑为测试方法，并且不会被运行。
- en: A test method should test one and only one outcome (whether this is a result
    or a behavior). This is important since we need to be able to know that, if a
    test method fails, it is because it didn’t achieve the expected outcome (a result
    or a behavior). To achieve this, however, a test method may contain more than
    one assertion as long as these multiple assertions serve the purpose of validating
    that one outcome.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试方法应该只测试一个结果（无论是结果还是行为）。这很重要，因为我们需要能够知道，如果测试方法失败，那是因为它没有达到预期的结果（结果或行为）。然而，为了达到这个目的，一个测试方法可能包含多个断言，只要这些多个断言服务于验证一个结果的目的。
- en: 'To maximize clarity and readability, it is advised that a test method’s body
    be chunked into three parts (also known as the 3As):'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了最大化清晰度和可读性，建议将测试方法的主体分成三个部分（也称为3A）：
- en: '**Arrange**: where all the objects required to perform the test are instantiated
    and initialized.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：创建并初始化执行测试所需的所有对象。'
- en: '**Act**: where the code artifact to be tested is invoked and the result is
    gathered.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：调用要测试的代码工件并收集结果。'
- en: '**Assert**: where the obtained result (usually referred to as the “actual”
    result) is compared to the expected result. If both match, the test is considered
    to be a success. However, the test is considered to be a failure.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：将获得的结果（通常称为“实际”结果）与预期结果进行比较。如果两者匹配，则测试被认为是成功的。然而，如果两者不匹配，则测试被认为是失败的。'
- en: Armed with this new knowledge, we have everything we need to write our first
    test. Let’s start by writing tests for the `link` command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些新知识，我们拥有了编写第一个测试所需的一切。让我们从编写`link`命令的测试开始。
- en: Looking at the code of the `LinkCommand` class, we notice that it does not have
    any methods. However, we see that its constructor calls the `AddCommand` method
    to set the `LinkAddCommand` as a sub-command of `Linkcommand` (that is why `add`
    appears as a child of the `link` command).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`LinkCommand`类的代码，我们发现它没有任何方法。然而，我们看到它的构造函数调用了`AddCommand`方法来设置`LinkAddCommand`作为`Linkcommand`的子命令（这就是为什么`add`作为`link`命令的子命令出现）。
- en: In this case, our test method will not be verifying a result but rather a behavior.
    In this case, we want to verify that `LinkAddCommand` is actually a sub-command
    of `LinkCommand`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们的测试方法将不会验证结果，而是验证行为。在这种情况下，我们想要验证`LinkAddCommand`确实是`LinkCommand`的一个子命令。
- en: 'Here is the code for this test method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个测试方法的代码：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Although this code is self-explanatory and easy to understand, I wanted to
    point out a couple of key points:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码是自我解释的，并且容易理解，但我想要指出几个关键点：
- en: 'Notice the naming convention applied to the name of the test method. It clearly
    indicates its intent: we are testing the `LinkCommand` class, and our test consists
    of calling the class constructor and ensuring that `LinkAddCommand` is its only
    sub-command.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意应用到测试方法名称上的命名约定。它清楚地表明了其意图：我们正在测试`LinkCommand`类，并且我们的测试包括调用类构造函数并确保`LinkAddCommand`是其唯一的子命令。
- en: Notice that we applied the 3A principle to structure the body of the test method.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我们应用了3A原则来构建测试方法的主体。
- en: Notice that we performed three assertions to verify the expected behavior. Also,
    note the usage of `CollectionAssert`, which helps with asserting collections and
    their items. It is way more convenient than using `Assert` when dealing with lists
    and collections of elements. This is my little secret for you, as many developers
    are not aware of it or don’t naturally tend to use it 😉.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我们执行了三个断言来验证预期的行为。此外，请注意`CollectionAssert`的使用，它有助于断言集合及其项。当处理列表和元素集合时，它比使用`Assert`方便得多。这是我为你保留的小秘密，因为许多开发者可能不知道它或者不自然地倾向于使用它
    😉。
- en: We are now ready to run our tests. Let’s see how we do this.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好运行我们的测试了。让我们看看我们如何做到这一点。
- en: Running our tests
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的测试
- en: 'The .NET CLI provides a command for this purpose:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI为此提供了一个命令：
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will compile the code and the test project, discover the test classes
    and test methods, execute the tests, and return the results.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将编译代码和测试项目，发现测试类和测试方法，执行测试，并返回结果。
- en: 'Visual Studio Code also provides a **graphical user interface** (**GUI**) for
    listing and executing the tests. This pane can be displayed by clicking on the
    appropriate icon, as shown in the following figure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code还提供了一个用于列出和执行测试的**图形用户界面（GUI**）。可以通过点击相应的图标来显示此面板，如下面的图所示：
- en: '![Figure 10.7 – Running tests](img/B22400_10_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 运行测试](img/B22400_10_06.jpg)'
- en: Figure 10.7 – Running tests
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 运行测试
- en: This GUI also provides a visual identification of the states of the test methods.
    In the preceding screenshot, we can see that our test method has been completed
    successfully.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此GUI还提供了对测试方法状态的视觉识别。在前面的屏幕截图中，我们可以看到我们的测试方法已经成功完成。
- en: From this GUI, we can also debug tests! This is a fantastic capability that
    helps us understand why a test is failing by strategically applying breakpoints
    and re-executing it in debug mode.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图形用户界面（GUI）中，我们也可以调试测试！这是一个非常棒的功能，它通过策略性地应用断点并在调试模式下重新执行，帮助我们理解为什么测试失败。
- en: Excellent! We can implement more tests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以实现更多的测试。
- en: But wait!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！
- en: Have you noticed that we passed a `null` instance of the `BookmarkrService`
    as a parameter? This is fine since we are not relying on that parameter in the
    test we are conducting. But if we did (as we will when testing the `import` command),
    we would like to provide an instance for it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到我们传递了一个`null`实例的`BookmarkrService`作为参数？这没关系，因为我们正在进行的测试不依赖于该参数。但如果我们确实（就像我们在测试`import`命令时那样）需要它，我们希望为它提供一个实例。
- en: We obviously don’t want to use an actual instance of that service as it is a
    dependency of the command and it may also rely on an external dependency, such
    as a database where the bookmarks are stored.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然不想使用该服务的实际实例，因为它是该命令的依赖项，它也可能依赖于外部依赖项，例如存储书签的数据库。
- en: We will then need to provide a fake representation of it. This is where **mocks**
    come into play!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要提供它的一个假表示。这就是**模拟（mocks）**发挥作用的地方！
- en: Mocking external dependencies
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟外部依赖项
- en: Mocking is useful for simulating the behavior of dependencies without actually
    relying on them. This is powerful because it allows us to test our application
    in isolation from its environment. The reason we want to do this is to have tests
    that ensure that the application’s code works correctly, irrespective of the state
    of its dependencies.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（Mocking）在模拟依赖项的行为而不实际依赖它们时非常有用。这很强大，因为它允许我们在隔离其环境的情况下测试我们的应用程序。我们想要这样做的原因是，要确保应用程序的代码在依赖项的状态无关的情况下也能正确工作。
- en: The role of mocking
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟的作用
- en: Let me clarify this with an example. Let’s say you have a method that stores
    a bookmark in the database. You write a test method to verify that, and it fails.
    You run it again, and it passes. Can you tell, without investigating, whether
    this was due to a transient database connectivity problem or due to a bug in the
    code? You can’t! But if you remove the dependency (that is, the database) from
    the equation and the same behavior occurred, you can tell (with a high level of
    confidence) that this was due to a bug in the code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过一个例子来澄清这一点。假设你有一个将书签存储到数据库中的方法。你编写了一个测试方法来验证这一点，但它失败了。你再次运行它，它通过了。你能否在不调查的情况下判断这是由于瞬时的数据库连接问题还是由于代码中的错误？你不能！但如果从等式中移除依赖项（即数据库）并且出现了相同的行为，你就可以（有很高的信心）判断这是由于代码中的错误。
- en: It is worth mentioning that we usually write tests that take external dependencies
    out of the equation (namely, unit tests) and tests that take these external dependencies
    into account (such as integration or system tests). So, when facing such an issue,
    we can look at unit and integration or system tests to figure out if the problem
    is due to the dependency (such as a communication problem) or due to the code
    itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们通常编写将外部依赖排除在外的测试（即单元测试）和考虑这些外部依赖的测试（如集成或系统测试）。因此，当我们面临此类问题时，我们可以查看单元和集成或系统测试，以确定问题是由依赖（如通信问题）还是由代码本身引起的。
- en: How to mock an external dependency
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何模拟外部依赖
- en: As mentioned earlier, we can write our own fake implementation of a dependency
    that simulates the behavior of the real dependency, but the major drawback of
    this approach is that we have to maintain (and possibly rewrite) these implementations
    if the behavior of the real dependency changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以编写自己的模拟实现来模拟真实依赖的行为，但这种方法的主要缺点是，如果真实依赖的行为发生变化，我们必须维护（并可能重写）这些实现。
- en: It is wiser to rely on a mocking framework that will perform this task for us.
    What we need to do is to provide an interface for that dependency and the mocking
    framework will create a fake representation of it at runtime. We can also pass
    instructions to the mocking framework to configure the behavior of the fake dependency
    in a certain way, depending on the test we need to perform. For example, we can
    instruct the mocking framework to simulate a certain error or exception when invoking
    a dependency with some parameter values to verify the behavior of our application
    under these circumstances.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 依靠一个会为我们执行此任务的模拟框架更明智。我们需要做的是提供一个接口给那个依赖，模拟框架将在运行时创建其假表示。我们还可以向模拟框架传递指令，以根据我们需要执行的测试以某种方式配置假依赖的行为。例如，我们可以指示模拟框架在调用具有某些参数值的依赖时模拟特定的错误或异常，以验证在这些情况下应用程序的行为。
- en: About mocking frameworks
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模拟框架
- en: Just as there are many testing frameworks, there are also many mocking frameworks
    for you to choose from. One of the most commonly used ones, and my personal favorite,
    is **NSubstitute**. I like it because it is both powerful and easy to learn and
    use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如有许多测试框架一样，也有许多模拟框架供您选择。其中最常用的一种，也是我个人最喜欢的，是 **NSubstitute**。我喜欢它是因为它既强大又易于学习和使用。
- en: 'You can learn more about NSubstitute by visiting its website: [https://nsubstitute.github.io/help/getting-started/](https://nsubstitute.github.io/help/getting-started/).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问其网站了解更多关于 NSubstitute 的信息：[https://nsubstitute.github.io/help/getting-started/](https://nsubstitute.github.io/help/getting-started/)。
- en: Let’s mock the `BookmarkService` service using NSubstitute.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 NSubstitute 模拟 `BookmarkService` 服务。
- en: Mocking the BookmarkService service
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟 `BookmarkService` 服务
- en: 'The first thing we need to do is to add NSubstitute to the test project. We
    can achieve this by navigating to the directory of the test project and typing
    this command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将 NSubstitute 添加到测试项目中。我们可以通过导航到测试项目的目录并输入以下命令来实现这一点：
- en: '[PRE6]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s update the `LinkCommandTests` test class by mocking the `BookmarkService`
    service. The updated code is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过模拟 `BookmarkService` 服务来更新 `LinkCommandTests` 测试类。更新的代码如下：
- en: '[PRE7]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we haven’t done much here. We merely added a `using` statement
    for `NSubstitute` and instead of initializing the service to a `null` value, we
    asked `NSubstitute` to provide a simulation of it based on its interface (which
    is referred to as a *mock*). The result is a temporary, in-memory object built
    based on the structure of the `IBookmarkService` interface for which we can configure
    the behavior depending on the test we are performing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在这里并没有做太多。我们只是添加了一个 `using` 语句用于 `NSubstitute`，并且我们没有将服务初始化为 `null`
    值，而是要求 `NSubstitute` 根据其接口（被称为 *mock*）提供对其的模拟。结果是基于 `IBookmarkService` 接口结构构建的临时内存对象，我们可以根据所进行的测试配置其行为。
- en: If we now execute the test again, it still passes. Since we are not calling
    the service during our test, we do not need to configure its behavior. But we
    will need to do that for the upcoming test methods we are going to implement.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次执行测试，它仍然通过。由于我们在测试期间没有调用服务，我们不需要配置其行为。但我们将需要为即将实施的测试方法做这件事。
- en: Using the mock version of the BookmarkService service
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `BookmarkService` 服务的模拟版本
- en: Let’s start by creating a test class for the `import` command. We first create
    the `ImportCommandTests.cs` file in the `Commands\Import` directory. This file
    will contain all the test methods related to the `import` command.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个用于 `import` 命令的测试类。我们首先在 `Commands\Import` 目录中创建 `ImportCommandTests.cs`
    文件。此文件将包含所有与 `import` 命令相关的测试方法。
- en: 'Next, we lay out the base structure of the test class, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们概述测试类的基结构，如下所示：
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command has no subcommands, so we do not need to test that, or we can write
    a test that verifies this fact. If you want to do this, you can follow the same
    procedure as in the `LinkCommandTests` class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令没有子命令，因此我们不需要测试这一点，或者我们可以编写一个测试来验证这一事实。如果你想这样做，你可以遵循 `LinkCommandTests` 类中的相同程序。
- en: 'Before we start implementing tests, we need to identify the test cases we want
    to perform. In invite you to reflect on that, but in the meantime, here is a non-exhaustive
    list of test cases:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现测试之前，我们需要确定我们想要执行的测试用例。在此期间，请反思这一点，但以下是一个非详尽的测试用例列表：
- en: '`OnImportCommand` handler method will call the `Import` method of `BookmarkService`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnImportCommand` 处理方法将调用 `BookmarkService` 的 `Import` 方法。'
- en: '**Test case #2**: If the file name is invalid, an error message should be returned
    (for example, indicating that there is an forbidden character in the filename).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例 #2**：如果文件名无效，应返回一个错误消息（例如，指示文件名中存在非法字符）。'
- en: '**Test case #3**: If the file is not found, an error message, indicating that
    the file does not exist, should be returned.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例 #3**：如果文件未找到，应返回一个错误消息，指示文件不存在。'
- en: '**Test case #4**: When importing bookmarks, if no conflict is detected, the
    imported bookmarks are found in the local collection of bookmarks.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例 #4**：在导入书签时，如果没有检测到冲突，导入的书签应出现在本地书签集合中。'
- en: '`Log` method is also called.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也会调用 `Log` 方法。
- en: For the purpose of this chapter, we will only implement test cases 1 and 5\.
    The remaining test cases are left for you as a challenge.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的目的，我们只实现测试用例 1 和 5。其余的测试用例留给你作为挑战。
- en: However, before we can implement these test cases, some changes to the application’s
    code have to be made.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够实现这些测试用例之前，需要对应用程序的代码进行一些修改。
- en: Changes to the code must be made!
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必须对代码进行修改！
- en: 'Here is the idea: sometimes, changes to your code will have to be made so that
    the code can be testable. This is okay because some classes of the .NET framework
    aren’t testable by nature.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是思路：有时，你需要对代码进行修改，以便代码可以被测试。这是可以接受的，因为 .NET 框架中的一些类天生不可测试。
- en: In our situation, this is the case with the `FileInfo` class, which is a sealed
    class and exposes no interface, hence it cannot be overridden nor mocked.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这是 `FileInfo` 类的情况，它是一个密封类，不公开任何接口，因此不能被重写或模拟。
- en: 'Fortunately, there is a library that allows us to work around this limitation.
    We will then need to add the following NuGet package to both the application and
    the test projects:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个库允许我们绕过这个限制。然后我们需要将以下 NuGet 包添加到应用程序和测试项目中：
- en: '[PRE9]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the test project, we will also need to add this NuGet package, which will
    help with testing:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试项目，我们还需要添加这个 NuGet 包，这将有助于测试：
- en: '[PRE10]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will also need to make the following changes to the `ImportCommand` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对 `ImportCommand` 类进行以下修改：
- en: We will add a private property of type `IFileSystem`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个类型为 `IFileSystem` 的私有属性。
- en: We will initialize this property to an instance of the `FileSystem` class in
    the default constructor.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在默认构造函数中将此属性初始化为 `FileSystem` 类的实例。
- en: We will add a second constructor that will only be used for testing. This constructor
    will take an extra parameter, of type `IFileSystem`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个第二个构造函数，它将仅用于测试。此构造函数将接受一个额外的参数，类型为 `IFileSystem`。
- en: Finally, we will add an overload of the `OnImportCommand` handler method that
    takes an `IFileInfo` parameter and whose only purpose is to call the original
    version of the `OnImportCommand` method, passing an instance of `FileInfo` based
    on the `IFileInfo` object it received.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个 `OnImportCommand` 处理方法的重载版本，它接受一个 `IFileInfo` 参数，其唯一目的是调用原始版本的 `OnImportCommand`
    方法，并传递基于它接收到的 `IFileInfo` 对象的 `FileInfo` 实例。
- en: Invoking the `import` command once again, we find out that it still works as
    expected.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用 `import` 命令，我们发现它仍然按预期工作。
- en: We can now implement those test cases.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实施这些测试用例。
- en: Going back to implementing the test cases
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到实现测试用例
- en: 'Let’s start with test case 1\. Here is the associated test method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试用例1开始。以下是相关的测试方法：
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code deserves an explanation, so here we go:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码值得解释，所以下面我们就来解释一下：
- en: We first create a mock of the `BookmarkService`, as we did in the previous example.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`BookmarkService`的模拟，就像之前的例子一样。
- en: Then, we create a string representation of the JSON content for three bookmarks
    that will be needed for our test.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为测试所需的三本书签创建JSON内容的字符串表示。
- en: Next, and this is the reason why we performed the changes to the code that we
    described above, we create a mock of the filesystem and simulate the existence
    of a file named `bookmarks.json` that contains the JSON representation we created
    in the previous step.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，这也是我们为什么要对代码进行我们之前描述的更改的原因，我们创建了一个文件系统的模拟，并模拟了一个名为`bookmarks.json`的文件的存在，该文件包含我们在上一步创建的JSON表示。
- en: After that, we create an instance of the `ImportCommand` class using the new
    constructor we have added, which allows us to pass the mock filesystem as a parameter.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用我们添加的新构造函数创建`ImportCommand`类的一个实例，这个构造函数允许我们传递模拟文件系统作为参数。
- en: We are now ready to invoke the `OnImportCommand` by relying on the mock filesystem
    and passing the name of the `bookmarks.json` file we simulated earlier. It is
    important to note here that if we pass the name of a file that was not part of
    the simulation, the test will fail.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备通过依赖模拟文件系统并传递我们之前模拟的`bookmarks.json`文件名来调用`OnImportCommand`。这里需要注意的是，如果我们传递一个不在模拟中的文件名，测试将失败。
- en: 'We are now ready to verify whether our assertions are correct. Pay careful
    attention to how we did it: we first ensured that calling the `OnImportCommand`
    method triggered three calls to the `Import` method of `BookmarkService` (here,
    these calls are in fact made to the mock version of the service since we do not
    want the service to be activated but rather, we only want to validate that it
    was invoked as expected). This is, however, not sufficient to validate that the
    test is successful as these three calls could include unexpected calls. To make
    sure that these calls are legitimate, we verify them, one by one, ensuring that
    each of their meaningful properties matches what is expected.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备验证我们的断言是否正确。请仔细注意我们是如何做到的：我们首先确保调用`OnImportCommand`方法触发了对`BookmarkService`的`Import`方法的三个调用（在这里，这些调用实际上是针对服务的模拟版本进行的，因为我们不希望激活服务，而只是想验证它是否按预期被调用）。然而，这还不足以验证测试是否成功，因为这些三个调用可能包括意外的调用。为了确保这些调用是合法的，我们逐一验证它们，确保它们的有意义属性与预期相符。
- en: 'And that’s it for test case #1\. Let’s now move on to test case #5.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例#1就到这里。现在让我们继续到测试用例#5。
- en: 'Here is the code for this test case:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个测试用例的代码：
- en: '[PRE12]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code for this test case is very similar to the code for test case #1, with
    two noticeable differences:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例的代码与测试用例#1的代码非常相似，有两个明显的不同点：
- en: We are calling the real implementation of `BookmarkService`, not a mock. The
    reason is that we want to ensure that the bookmarks have been imported correctly
    and that the conflicting one has been renamed accordingly. If that service was
    relying on a database, we could have mocked that database.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在调用`BookmarkService`的真实实现，而不是模拟。原因是我们要确保书签已经被正确导入，并且冲突的书签已经被相应地重命名。如果该服务依赖于数据库，我们可以模拟那个数据库。
- en: The last assertion, although not necessary, ensures that the original, conflicting
    bookmark does not exist anymore since it has been updated.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个断言，虽然不是必需的，但确保原始的冲突书签不再存在，因为它已经被更新了。
- en: Now, if you have been coding along with me, you have certainly noticed that
    this code does not work. In fact, it does not even compile! Don’t worry, this
    was intentional 😊. The intention is to teach you how to control visibility to
    test artifacts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你一直和我一起编码，你肯定已经注意到这段代码不起作用。事实上，它甚至无法编译！别担心，这是故意的 😊。目的是教你如何控制测试实体的可见性。
- en: Internals visibility
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部可见性
- en: In the `ImportCommand` class, we added a second constructor (which takes a parameter
    of type `IFileSystem`) and an overload for the `OnImportCommand` handler method.
    These two methods have been marked as `internal`, which simply means that they
    are visible to all parts of the code within the current project but aren’t visible
    outside of that project unless we specify otherwise.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ImportCommand` 类中，我们添加了一个第二个构造函数（它接受一个类型为 `IFileSystem` 的参数）以及 `OnImportCommand`
    处理方法的重载。这两个方法都被标记为 `internal`，这仅仅意味着它们在当前项目的所有代码部分都是可见的，除非我们另外指定，否则它们在该项目之外是不可见的。
- en: This is the recommended approach when you add artifacts specifically for testing
    purposes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加专门用于测试目的的工件时，这是推荐的方法。
- en: The `internal` accessor is very interesting. It allows us to control its visibility.
    In this case, we only want the test project to see these internal code artifacts.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal` 访问器非常有趣。它允许我们控制其可见性。在这种情况下，我们只想让测试项目看到这些内部代码工件。'
- en: 'To do that, we will need to update the `bookmarkr.csproj` file (the one where
    these code artifacts marked as `internal` are located) to indicate that we only
    want the test project to be able to access them. We can achieve this by adding
    this entry:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要更新 `bookmarkr.csproj` 文件（这些标记为 `internal` 的代码工件所在的文件）以指示我们只想让测试项目能够访问它们。我们可以通过添加以下条目来实现这一点：
- en: '[PRE13]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that code artifacts that are marked as `internal` in the `bookmarkr`
    project can only be “seen” by the `bookmarkr.UniTests` project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着标记为 `internal` 的 `bookmarkr` 项目中的代码工件只能被 `bookmarkr.UniTests` 项目“看到”。
- en: Now, you will notice that the code compiles and executes as expected.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会注意到代码按照预期编译并执行。
- en: Looking back at the test methods of the `ImportCommandTests` class, you have
    certainly noticed that in both test methods, we instantiated and initialized `MockFileSystem`
    and the string representation of the JSON structure of the bookmarks in the same
    way. Hence, this code is redundant and, if it changes over time, we need to update
    this code in both places. This will get even worse as the number of test methods
    increases.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 `ImportCommandTests` 类的测试方法，你肯定已经注意到，在这两个测试方法中，我们都以相同的方式实例化和初始化了 `MockFileSystem`
    以及书签 JSON 结构的字符串表示。因此，这段代码是冗余的，如果它随时间变化，我们需要在这两个地方更新这段代码。随着测试方法数量的增加，这会变得更糟。
- en: Fortunately, MS Test provides a way to centralize this initialization. Let’s
    see how this works.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MS Test 提供了一种集中初始化的方法。让我们看看它是如何工作的。
- en: Centralizing test initialization
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中化测试初始化
- en: MS Test provides a `[TestInitialize]` attribute that can be used to decorate
    a method where any common instantiation, initialization, or configuration can
    be centralized.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: MS Test 提供了一个 `[TestInitialize]` 属性，可以用来装饰一个方法，其中任何常见的实例化、初始化或配置都可以集中化。
- en: 'This method is then automatically invoked by the MS Test framework before calling
    every test method. This has another benefit: every test method gets fresh instances
    of the objects instantiated in the initialization method, preventing the execution
    of a test method to have an impact and an influence on the execution of the next
    test method.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法随后由 MS Test 框架在调用每个测试方法之前自动调用。这还有一个好处：每个测试方法都会获得初始化方法中实例化的对象的全新实例，从而防止一个测试方法的执行对下一个测试方法的执行产生影响和影响。
- en: 'The code of the test initialization method looks like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 测试初始化方法的代码如下所示：
- en: '[PRE14]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Fantastic! Now we know everything we need to know to implement meaningful and
    efficient tests for our CLI application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们知道了实现我们 CLI 应用程序有意义的和高效的测试所需的一切。
- en: But before closing this chapter, there is one last thing I want to discuss with
    you. I want to tell you how you can use these tests that you are implementing
    to identify and eliminate a bug.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但在结束这一章之前，还有最后一件事我想和你讨论。我想告诉你如何使用你正在实施的这些测试来识别和消除错误。
- en: How to hunt a bug
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何追踪错误
- en: Tests play a key role in hunting down a bug and ensuring it doesn’t come up
    again. To do that, you should follow a process.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在追踪错误和确保它不会再次出现中扮演着关键角色。为了做到这一点，你应该遵循一个流程。
- en: Whenever a bug is discovered (by you or your team) or reported (by the user),
    you should write tests that reproduce it. These tests can be of different types.
    These are to ensure that the bug doesn’t come up again.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时发现（由你或你的团队）或报告（由用户）错误，你应该编写重现它的测试。这些测试可以是不同类型的。这是为了确保错误不会再次出现。
- en: Now, run your tests and you should notice that tests are failing. Tests that
    cover wider ranges (such as system or integration tests) will tell you in what
    component of the application the bug is happening. Then, more granular tests (such
    as unit tests) will tell you in what class and ultimately in what method the bug
    is hiding.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行你的测试，你应该会注意到测试失败了。覆盖范围更广的测试（例如系统或集成测试）会告诉你错误发生在应用程序的哪个组件中。然后，更细粒度的测试（例如单元测试）会告诉你错误隐藏在哪个类中，最终在哪个方法中。
- en: By using a smart combination of both wide-range and granular tests, you will
    be able to hunt down the bug. Keep in mind that breakpoints will be great allies.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用范围广泛和细粒度测试的智能组合，你将能够追踪到错误。记住，断点将是你的强大盟友。
- en: And that’s it! We are now armed with everything we need to enhance the quality
    of our application by leveraging software testing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在拥有了利用软件测试提高应用程序质量所需的一切。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned why testing is an important step in the process
    of developing any application, including CLI applications. I like to call tests
    your safety nets: they ensure not only that your new features behave as expected
    but also that you don’t accidentally introduce bugs in existing functionalities
    (we call these **regressions**). I highly encourage you to write effective tests
    and run them often.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了为什么测试是开发任何应用程序（包括 CLI 应用程序）过程中的重要步骤。我喜欢称测试为你的安全网：它们不仅确保你的新功能按预期工作，而且确保你不会意外地在现有功能中引入错误（我们称之为**回归**）。我强烈建议你编写有效的测试并经常运行它们。
- en: We also explored the categories and roles of tests, and we learned techniques
    for testing applications and applied them to **Bookmarkr**, our CLI application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了测试的分类和角色，并学习了测试应用程序的技术，并将它们应用于我们的 CLI 应用程序 **Bookmarkr**。
- en: Our application now has the required functionalities, and we ensured, through
    testing, that these functionalities behave as expected. It is now time to deliver
    the application to its users!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在具备了所需的功能，并且通过测试确保了这些功能按预期工作。现在是时候将应用程序交付给用户了！
- en: This is why, in the next chapter, we will explore different techniques that
    will allow us to package, distribute, and deploy our application.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在下一章中，我们将探讨不同的技术，这些技术将使我们能够打包、分发和部署我们的应用程序。
- en: Your turn!
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码进行实践是学习的好方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你通过添加以下功能来改进 Bookmarkr 应用程序。
- en: 'Task #1 – Write the required unit tests for the remaining functionalities'
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 为剩余的功能编写所需的单元测试'
- en: In this chapter, we wrote tests only for the `link` and `import` commands. You
    are hence challenged to write tests for the other commands. You will have to figure
    out what test cases are to be considered and implement them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只为 `link` 和 `import` 命令编写了测试。因此，你被挑战为其他命令编写测试。你必须弄清楚要考虑哪些测试用例，并实现它们。
- en: 'Task #2 – Write integration tests for the sync command'
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 为同步命令编写集成测试'
- en: The `sync` command deals with a database. For the purpose of unit testing, you
    can mock the database using NSubstitute. However, when implementing an integration
    test, you need a real database. You are then challenged to write integration tests
    for the `sync` command. You will have to provide a test database and use the appropriate
    connection string depending on whether the application is running in production
    or in testing mode.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync` 命令处理数据库。为了单元测试的目的，你可以使用 NSubstitute 模拟数据库。然而，在实现集成测试时，你需要一个真实的数据库。你将面临编写
    `sync` 命令的集成测试的挑战。你必须提供一个测试数据库，并使用适当的连接字符串，这取决于应用程序是在生产模式还是测试模式下运行。'
