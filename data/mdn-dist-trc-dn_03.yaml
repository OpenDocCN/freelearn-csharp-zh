- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The .NET Observability Ecosystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET可观察性生态系统
- en: In the previous chapter, we explored .NET observability features included into
    the platform and frameworks, but there are more instrumentations covering other
    libraries and environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了平台和框架中包含的.NET可观察性功能，但还有更多针对其他库和环境的工具。
- en: 'In this chapter, we’ll learn how to find and evaluate instrumentations and
    then take a closer look at instrumentations for a few specific libraries: StackExchange.Redis,
    Azure, and AWS SDKs. We’ll also explore tracing and metrics coming from infrastructure
    using **Dapr** (**distributed application runtime**) as an example. Finally, we’ll
    see how to configure tracing in serverless environments where we have less control,
    but observability is even more important.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何查找和评估工具，然后更深入地研究几个特定库的工具：StackExchange.Redis、Azure和AWS SDKs。我们还将探索使用**Dapr**（**分布式应用程序运行时**）作为示例的基础设施跟踪和指标。最后，我们将看到如何在控制较少的无服务器环境中配置跟踪，但可观察性更为重要。
- en: 'Through this chapter, you’ll learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你将学习：
- en: How to find, evaluate, and enable OpenTelemetry instrumentations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查找、评估和启用OpenTelemetry工具
- en: What Dapr and service meshes are capable of when it comes to observability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到可观察性时，Dapr和服务网格能够做到什么程度
- en: How to enable tracing in serverless environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在无服务器环境中启用跟踪
- en: By the end of this chapter, you’ll get hands-on experience with different kinds
    of instrumentations and you will be able to configure and use distributed tracing
    for a wide range of backend applications. Let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得不同类型工具的实际操作经验，并能够配置和使用分布式跟踪来支持广泛的后端应用程序。让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’re going to evolve our meme application and use a cloud
    object store, Amazon S3 or Azure Blob Storage, along with a local Redis cache.
    The code for this chapter is available in the book’s GitHub repository at [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter3](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter3),
    which has the following folder structure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演进我们的meme应用程序，并使用云对象存储，Amazon S3或Azure Blob存储，以及本地Redis缓存。本章的代码可在本书的GitHub存储库中找到，网址为[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter3](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter3)，其文件夹结构如下：
- en: '`libraries`: Contains library instrumentation sample app for the first section
    of this chapter'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libraries`：包含本章第一部分的库工具示例应用程序'
- en: '`dapr`: Contains Dapr instrumentation sample for the second section'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dapr`：包含第二部分的Dapr工具示例'
- en: '`serverless`: Contains `aws` and `azure` folders with examples of AWS Lambda
    and Azure Functions instrumentations'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serverless`：包含`aws`和`azure`文件夹，其中包含AWS Lambda和Azure Functions工具的示例'
- en: 'To run these applications, you would need the following tools:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些应用程序，你需要以下工具：
- en: .NET SDK 7.0 or later
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK 7.0或更高版本
- en: Visual Studio or VS Code, but any text editor would work
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio或VS Code，但任何文本编辑器都可以工作
- en: Docker and `docker-compose`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker和`docker-compose`
- en: Dapr CLI
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dapr CLI
- en: 'An Azure subscription (optional):'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Azure订阅（可选）：
- en: We’re going to use Blob Storage and Application Insights.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用Blob存储和应用洞察。
- en: With Blob Storage, we’re going to stay well within free-tier limits. Application
    Insights does not have a free tier, but you can still try it out with Azure promotional
    credits.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blob存储，我们将确保保持在免费层级的限制之内。Application Insights没有免费层，但你仍然可以使用Azure促销积分来试用。
- en: We’ll use Azure Function Tools v4 and (optionally) Azure CLI.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用Azure Function Tools v4和（可选）Azure CLI。
- en: 'An AWS subscription (optional):'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个AWS订阅（可选）：
- en: We’re going to use S3, Lambda, and X-Ray. We’ll stay well within free-tier limits
    for each of them.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用S3、Lambda和X-Ray。我们将确保每个服务的使用都保持在免费层级的限制之内。
- en: We’ll need AWS toolkit for VS or Lambda .NET CLI and (optionally) AWS CLI.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将需要AWS工具包用于VS或Lambda .NET CLI以及（可选）AWS CLI。
- en: Configuring cloud storage
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置云存储
- en: If you don’t want to create an Azure or AWS subscription, you can still run
    `libraries` and `dapr` samples locally by setting `CloudStorage.Type` to `Local`
    in `storage/appsettings.json`. There is no local setup for serverless demos.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想创建Azure或AWS订阅，你仍然可以通过将`storage/appsettings.json`中的`CloudStorage.Type`设置为`Local`来本地运行`libraries`和`dapr`示例。无服务器演示没有本地设置。
- en: Otherwise, set `CloudStorage.Type` to the storage of your choice, `AwsS3` or
    `AzureBlob`, and let’s see how to configure them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将`CloudStorage.Type`设置为你的选择存储，`AwsS3`或`AzureBlob`，然后让我们看看如何配置它们。
- en: AWS S3
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS S3
- en: 'Create a new bucket using AWS console or CLI:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS控制台或CLI创建一个新的桶：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, add bucket info to `libraries/storage/appsettings.json`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将桶信息添加到`libraries/storage/appsettings.json`。
- en: We’ll also need credentials to access blob storage and we’re going to use the
    credentials file where we can. You can generate one using the `aws configure`
    command. Applications would search for AWS credentials file at `${HOME}/.aws/credentials`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要凭证来访问blob存储，我们将使用我们能够使用的凭证文件。您可以使用`aws configure`命令生成一个。应用程序将在`${HOME}/.aws/credentials`中搜索AWS凭证文件。
- en: Replace the `HOME` environment variable in `docker-compose.yml` in the `libraries/`
    and `serverless/aws` folders.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 替换`libraries/`和`serverless/aws`文件夹中的`docker-compose.yml`中的`HOME`环境变量。
- en: Azure Blob Storage
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Blob存储
- en: 'Create a new storage account. You can use Azure portal or Azure CLI and then
    obtain a connection string:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的存储账户。您可以使用Azure门户或Azure CLI，然后获取连接字符串：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the connection string to `.env` file next to `libraries/docker-compose.yml`
    in the following format:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将连接字符串添加到`libraries/docker-compose.yml`旁边的`.env`文件中，格式如下：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using instrumentations for popular libraries
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流行库的仪表化
- en: In the previous chapter, we saw how to enable tracing for the .NET platform,
    ASP.NET Core, and Entity Framework to cover the basics, but anyone can create
    instrumentation for a popular library and share it with the community. Also, with
    tracing and metrics primitives being part of .NET and OpenTelemetry to collect
    data in a vendor-agnostic way, libraries can add native instrumentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何为.NET平台、ASP.NET Core和Entity Framework启用跟踪以涵盖基础知识，但任何人都可以为流行的库创建仪表化并与社区分享。此外，跟踪和度量原语作为.NET和OpenTelemetry的一部分，可以以供应商无关的方式收集数据，库可以添加原生仪表化。
- en: 'There are multiple terms that describe different kinds of instrumentations:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个术语描述不同类型的仪表化：
- en: '**Auto-instrumentation** *sometimes* implies that instrumentation can be enabled
    without *any* modification of application code, but is sometimes used to describe
    any shared instrumentation that is easy to enable.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动仪表化**有时意味着可以在不修改任何应用程序代码的情况下启用仪表化，但有时也用来描述任何易于启用的共享仪表化。'
- en: '**Instrumentation library** means that you can enable instrumentation by installing
    the corresponding NuGet package and configuring it with a few lines of code at
    startup time.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表化库**意味着您可以通过安装相应的NuGet包并在启动时用几行代码进行配置来启用仪表化。'
- en: '**Native instrumentation** implies that instrumentation code is a part of the
    library, so no additional NuGet package is necessary, but you may still need to
    enable instrumentation.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生仪表化**意味着仪表化代码是库的一部分，因此不需要额外的NuGet包，但您可能仍然需要启用仪表化。'
- en: '**Manual instrumentation** is the one that you write yourself as a part of
    your application code.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动仪表化**是您作为应用程序代码的一部分自己编写的。'
- en: The boundaries between automatic, native, and instrumentation libraries are
    blurry. For example, the HTTP client contains native instrumentation starting
    with .NET 7.0, but you might still enable it in a more convenient way with the
    corresponding instrumentations. Or, with some bytecode rewrite that configures
    OpenTelemetry, we can enable library instrumentations without changing any of
    the application code. In this book, we use a relaxed version of the auto-instrumentation
    term (for the lack of a better one) to describe all non-manual instrumentations,
    but we mention a specific kind when it’s relevant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自动、原生和仪表化库之间的界限模糊。例如，从.NET 7.0开始，HTTP客户端包含原生仪表化，但您可能仍然可以通过相应的仪表化以更方便的方式启用它。或者，通过一些配置OpenTelemetry的字节码重写，我们可以在不更改任何应用程序代码的情况下启用库仪表化。在这本书中，我们使用自动仪表化的宽松版本（由于缺乏更好的术语）来描述所有非手动仪表化，但在相关的情况下我们会提到具体的类型。
- en: 'There are several sources where we can find available instrumentations:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从几个来源找到可用的仪表化：
- en: '**OpenTelemetry registry** ([https://opentelemetry.io/registry):](https://opentelemetry.io/registry):)
    You can filter the instrumentations by language and component. Many instrumentations
    are not added to the registry though. It lists all kinds of instrumentation regardless
    of their kind.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenTelemetry注册表**([https://opentelemetry.io/registry):](https://opentelemetry.io/registry):)
    您可以根据语言和组件过滤仪表化。尽管如此，许多仪表化并未添加到注册表中。它列出了所有类型的仪表化，而不考虑它们的类型。'
- en: '**OpenTelemetry .NET repo** ([https://github.com/open-telemetry/opentelemetry-dotnet):](https://github.com/open-telemetry/opentelemetry-dotnet):)
    Contains library instrumentation for .NET frameworks and libraries. The ASP.NET
    Core and HTTP client instrumentations we used in the previous chapter live here
    along with SQL, gRPC, and exporters for OSS backends. These are instrumentation
    libraries.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenTelemetry .NET 仓库** ([https://github.com/open-telemetry/opentelemetry-dotnet):](https://github.com/open-telemetry/opentelemetry-dotnet):)
    包含 .NET 框架和库的库仪表化。我们之前章节中使用的 ASP.NET Core 和 HTTP 客户端仪表化工具，以及 SQL、gRPC 和 OSS 后端导出器都存放在这里。这些都是仪表化库。'
- en: '**OpenTelemetry Contrib repo** ([https://github.com/open-telemetry/opentelemetry-dotnet-contrib):](https://github.com/open-telemetry/opentelemetry-dotnet-contrib):)
    Contains different OpenTelemetry components: instrumentation libraries, exporters,
    and other utilities. You can find instrumentations for AWS SDK, ElasticSearch,
    WCF, StackExchange.Redis, and more there. The Entity Framework instrumentation
    we used in the previous chapter also lives in this repo.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenTelemetry Contrib 仓库** ([https://github.com/open-telemetry/opentelemetry-dotnet-contrib):](https://github.com/open-telemetry/opentelemetry-dotnet-contrib):)
    包含不同的 OpenTelemetry 组件：仪表化库、导出器和其它实用工具。你可以在那里找到 AWS SDK、ElasticSearch、WCF、StackExchange.Redis
    等的仪表化工具。我们之前章节中使用的 Entity Framework 仪表化工具也存放在这个仓库中。'
- en: '**OpenTelemetry instrumentation repo** ([https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation):](https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation):)
    Contains fully codeless auto-instrumentations that work via different mechanism
    - .NET profiling API. You can find GraphGL and MongoDB instrumentation there.
    In addition to auto-instrumentations for specific libraries; it provides a mechanism
    to configure OpenTelemetry in a codeless way that includes a set of common instrumentation
    libraries.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenTelemetry 仪表化仓库** ([https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation):](https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation):)
    包含通过不同机制（.NET 分析 API）工作的完全无代码自动仪表化。你可以在那里找到 GraphGL 和 MongoDB 仪表化工具。除了为特定库提供的自动仪表化机制外，它还提供了一种无代码配置
    OpenTelemetry 的机制，包括一组常见的仪表化库。'
- en: '**Other sources**: If you didn’t find what you’re looking for in the registry
    or the OpenTelemetry repos, search for issues in OpenTelemetry repos and don’t
    forget to check your library repo. For example, you can find MongoDB instrumentation
    at [https://github.com/jbogard/MongoDB.Driver.Core.Extensions.DiagnosticSources](https://github.com/jbogard/MongoDB.Driver.Core.Extensions.DiagnosticSources),
    which is leveraged in the *instrumentation* repo but can be used as a standalone
    instrumentation library.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他来源**：如果你在注册表或 OpenTelemetry 仓库中没有找到你想要的内容，请在 OpenTelemetry 仓库中搜索问题，并且不要忘记检查你的库仓库。例如，你可以在
    [https://github.com/jbogard/MongoDB.Driver.Core.Extensions.DiagnosticSources](https://github.com/jbogard/MongoDB.Driver.Core.Extensions.DiagnosticSources)
    找到 MongoDB 仪表化工具，它被用于 *instrumentation* 仓库，但也可以作为一个独立的仪表化库使用。'
- en: When adding instrumentations, pay attention to their stability and maturity.
    Instrumentations in the `opentelemetry-dotnet` repo are widely used but are not
    yet stable (it could have changed by the time you read this).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加仪表化工具时，请注意它们的稳定性和成熟度。`opentelemetry-dotnet` 仓库中的仪表化工具被广泛使用，但尚未稳定（在你阅读此内容时可能已经发生变化）。
- en: Instrumentations in the *contrib* repo have different statuses; for example,
    AWS is stable, while MySQL is in alpha and works for relatively old versions of
    the `MySQL.Data` package at the time of writing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*contrib* 仓库中的仪表化工具有不同的状态；例如，AWS 是稳定的，而 MySQL 则处于 alpha 阶段，并在编写本文时适用于相对较旧的
    `MySQL.Data` 包版本。'
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you decide to take dependency on a less common preview package, make sure
    to test it well. Compatibility with your version of the client library, stability,
    and performance should be the main concerns. All of them should be covered with
    integration and stress-testing—just make sure to enable instrumentation!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定依赖一个不太常见的预览包，请确保对其进行充分的测试。与客户端库版本的兼容性、稳定性和性能应该是主要关注点。所有这些都应该通过集成和压力测试来覆盖——只需确保启用仪表化功能！
- en: It’s good to get a basic idea of how the instrumentation works and check whether
    the mechanism behind it satisfies your performance requirements. For example,
    native instrumentations rely on `ActivitySource` or `DiagnosticSource`, and MongoDB
    and AWS instrumentations rely on hooks in corresponding libraries. All of these
    methods should work reasonably well, but the `MySQL.Data` instrumentation relies
    on `System.Diagnostics.TraceListener`, which is not thread-safe by default, and,
    when configured to be thread-safe, is not performant.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 了解监控的工作原理并检查其背后的机制是否满足您的性能要求是很好的。例如，原生监控依赖于`ActivitySource`或`DiagnosticSource`，MongoDB和AWS监控依赖于相应库中的钩子。所有这些方法都应该工作得相当好，但`MySQL.Data`监控依赖于`System.Diagnostics.TraceListener`，默认情况下不是线程安全的，并且当配置为线程安全时，性能也不佳。
- en: Even the most efficient instrumentations come with some performance hit. You
    should expect throughput to drop a few percent compared to non-instrumented code.
    Specific numbers heavily depend on your scenarios and OpenTelemetry configuration,
    such as sampling.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最高效的监控也会带来一些性能损失。您应该预计吞吐量与非监控代码相比会下降几个百分点。具体的数字很大程度上取决于您的场景和OpenTelemetry配置，例如采样。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Many developers consider auto-instrumentations to be magical and avoid them
    for this reason. By learning the mechanisms behind instrumentation, you can identify
    areas for additional testing, understand limitations, and gain confidence to use
    it (or not).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为自动监控是神奇的，因此为了避免这种情况而避免使用它们。通过了解监控背后的机制，您可以识别出需要额外测试的区域，了解限制，并增强使用它（或不用）的信心。
- en: So, let’s instrument the new version of the meme service and dig deep into each
    instrumentation we’re going to use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们监控meme服务的新版本，并深入了解我们将要使用的每个监控项。
- en: Instrumenting application
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序监控
- en: 'Our new demo application stores memes in Azure Blob Storage or AWS S3 and caches
    them in Redis, as shown in *Figure 3**.1*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新演示应用程序将meme存储在Azure Blob Storage或AWS S3中，并在Redis中缓存，如图*图3.1*所示：
- en: '![Figure 3.1 – Meme service with configurable cloud storage](img/B19423_03_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 可配置云存储的meme服务](img/B19423_03_01.jpg)'
- en: Figure 3.1 – Meme service with configurable cloud storage
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 可配置云存储的meme服务
- en: You can also set it up to store memes in Redis if you don’t want to configure
    a cloud subscription.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想配置云订阅，也可以将其设置为在Redis中存储meme。
- en: There are no changes on **frontend** from the previous chapter—we already enabled
    OpenTelemetry with HTTP instrumentations there. On **storage**, though we still
    need to add a few more instrumentations for AWS, Redis, and Azure SDK.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章相比，**前端**没有变化——我们已经在那里启用了OpenTelemetry和HTTP监控。在**存储**方面，尽管我们仍然需要为AWS、Redis和Azure
    SDK添加更多监控。
- en: 'First, we need to install `OpenTelemetry.Contrib.Instrumentation.AWS` and `OpenTelemetry.Instrumentation.StackExchangeRedis`
    and then configure them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`OpenTelemetry.Contrib.Instrumentation.AWS`和`OpenTelemetry.Instrumentation.StackExchangeRedis`，然后进行配置：
- en: libraries\storage\Program.cs
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: libraries\storage\Program.cs
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/libraries/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/libraries/storage/Program.cs)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/libraries/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/libraries/storage/Program.cs)'
- en: Let’s unpack it and explore instrumentations one by one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一展开并探索监控项。
- en: Redis
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis
- en: Redis instrumentation is available via the `OpenTelemetry.Instrumentation.StackExchangeRedis`
    package and comes from the *contrib* repo—documentation and examples are available
    there.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Redis监控通过`OpenTelemetry.Instrumentation.StackExchangeRedis`包提供，并来自*contrib*仓库——那里有文档和示例。
- en: Let’s see how we can evaluate this instrumentation. While any details about
    it might change, the approach can be applied to any other instrumentation library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何评估这种监控。虽然关于它的具体细节可能会改变，但这种方法可以应用于任何其他监控库。
- en: Redis instrumentation is not stable at the time of writing but it has a fair
    number of downloads on NuGet and no bugs reported. If we investigate how it works,
    we’ll see that it leverages the `StackExchange.Redis` profiling APIs—hooks allowing
    the start of a profiling session and recording events that happen during its execution.
    Despite the name, it doesn’t need the profiler attached.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，Redis 仪表化尚不稳定，但在 NuGet 上有相当多的下载量，并且没有报告任何错误。如果我们调查它是如何工作的，我们会看到它利用了 `StackExchange.Redis`
    分析 API——允许开始分析会话并记录执行期间发生的事件的钩子。尽管名称如此，它不需要附加分析器。
- en: It’s a relatively complex instrumentation—a profiling API is not designed for
    distributed tracing, so instrumentation must cover the gaps by maintaining an
    internal cache of sessions and cleaning them up.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对复杂的仪表化——分析 API 并非为分布式跟踪而设计，因此仪表化必须通过维护会话的内部缓存并清理它们来填补空白。
- en: To enable instrumentation, we call the `AddRedisInstrumentation` extension method
    on `TracerProviderBuilder` and pass the connection instance. If you have more
    than one connection, you’ll have to enable instrumentation for each of them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用仪表化，我们在 `TracerProviderBuilder` 上调用 `AddRedisInstrumentation` 扩展方法并传递连接实例。如果你有多个连接，你必须为每个连接启用仪表化。
- en: 'We also passed instrumentation options and enabled verbose database statements
    to collect additional data including Redis keys and scripts by setting `SetVerboseDatabaseStatements`
    flag to `true`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了仪表化选项并启用了详细数据库语句，通过将 `SetVerboseDatabaseStatements` 标志设置为 `true` 来收集包括
    Redis 键和脚本在内的附加数据：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s a good idea to check how this configuration might affect application performance
    and the verbosity of the output before deploying it to production. If we look
    into the Redis instrumentation code, this flag guards reflection-based (but efficient)
    calls to obtain the command key and script.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在将配置部署到生产环境之前，检查该配置可能对应用程序性能和输出冗余性的影响是个好主意。如果我们查看 Redis 仪表化代码，这个标志保护了基于反射（但高效）的调用，以获取命令键和脚本。
- en: Depending on what we store in Redis, we should also make sure it does not record
    any secrets or sensitive data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在 Redis 中存储的内容，我们还应确保它不会记录任何秘密或敏感数据。
- en: You probably noticed that instrumentations follow a common pattern, but unlike
    Redis ones, most of them are global and don’t require a per-client instance setup.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到仪表化遵循一个常见的模式，但与 Redis 仪表化不同，大多数仪表化是全局的，并且不需要每个客户端实例的设置。
- en: 'There are other options that control tracing on Redis: you can specify callback
    to enrich activities, disable events with additional timings, and configure intervals
    to clean up completed profiling sessions.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他选项可以控制 Redis 上的跟踪：你可以指定用于丰富活动的回调，禁用具有附加计时的事件，并配置间隔以清理完成的会话。
- en: 'If we start the application now and upload and download several memes on http://localhost:5051/,
    we’d see traces like the one shown in *Figure 3**.2* for meme download flow:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动应用程序并在 http://localhost:5051/ 上上传和下载几个 Meme，我们会看到类似于 *图 3.2* 中所示的跟踪，用于
    Meme 下载流程：
- en: '![Figure 3.2 – Meme download with Redis span](img/B19423_03_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 使用 Redis 跨度下载 Meme](img/B19423_03_02.jpg)'
- en: Figure 3.2 – Meme download with Redis span
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 使用 Redis 跨度下载 Meme
- en: You can see the standard `net.peer.*` attributes describing generic network
    endpoint and `db.*` attributes describing database call with `db.statement` matching
    Redis command and key. We only see the key (`this_is_fine`) since we set `SetVerboseDatabaseStatements`
    to `true`, otherwise `db.statement` would match the command `HMGET`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到描述通用网络端点的标准 `net.peer.*` 属性和描述与 `db.statement` 匹配 Redis 命令和键的数据库调用的 `db.*`
    属性。我们只看到了键（`this_is_fine`），因为我们已将 `SetVerboseDatabaseStatements` 设置为 `true`，否则
    `db.statement` 将匹配命令 `HMGET`。
- en: You can also see three logs (span events in Jaeger) describing additional timings
    for the Redis command. Since Redis is quite fast, you might find these events
    to be not very useful and disable them by setting `EnrichActivityWithTimingEvents`
    to `false`, which should decrease your observability bill and slightly improve
    performance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到三个日志（Jaeger 中的跨度事件）描述了 Redis 命令的附加计时信息。由于 Redis 非常快，你可能会发现这些事件不太有用，可以通过将
    `EnrichActivityWithTimingEvents` 设置为 `false` 来禁用它们，这应该会减少你的可观察性账单并略微提高性能。
- en: AWS SDK
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS SDK
- en: AWS SDK instrumentation is available in the `OpenTelemetry.Contrib.Instrumentation.AWS`
    NuGet package with the code residing in the *contrib* repo. Let’s try to evaluate
    it using the same approach.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: AWS SDK 仪表化可在 `OpenTelemetry.Contrib.Instrumentation.AWS` NuGet 包中找到，代码位于 *contrib*
    仓库中。让我们尝试使用相同的方法来评估它。
- en: 'It is stable and relies on a global tracing handler that applies to all AWS
    clients and instances, not just S3\. This handler in turn leverages .NET tracing
    primitives: `Activity` and `ActivitySource`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它是稳定的，并依赖于适用于所有 AWS 客户端和实例的全局跟踪处理器，而不仅仅是 S3。此处理器反过来利用 .NET 跟踪原语：`Activity` 和
    `ActivitySource`。
- en: 'To enable AWS instrumentation, just call the `AddAWSInstrumentation` extension
    method on `TracerProviderBuilder`. At this moment, there’s just one configurable
    option that controls whether nested HTTP calls should be traced:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 AWS 仪表化，只需在 `TracerProviderBuilder` 上调用 `AddAWSInstrumentation` 扩展方法。此时，只有一个可配置的选项控制是否跟踪嵌套
    HTTP 调用：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 3**.3* shows the meme upload trace: `PutObject` that in turn makes
    an `HTTP PUT` request to S3\. After the meme is uploaded, it’s cached on Redis:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.3* 展示了 Meme 上传跟踪：`PutObject`，它反过来向 S3 发起 `HTTP PUT` 请求。Meme 上传后，它被缓存在
    Redis 上：'
- en: '![Figure 3.3 – Upload meme to S3](img/B19423_03_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 将 Meme 上传到 S3](img/B19423_03_03.jpg)'
- en: Figure 3.3 – Upload meme to S3
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 将 Meme 上传到 S3
- en: The nested HTTP span is coming from the HTTP Client instrumentation, and we
    only see it because `SuppressDownstreamInstrumentation` is set to `false`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的 HTTP 跨度来自 HTTP 客户端仪表化，我们之所以能看到它，是因为 `SuppressDownstreamInstrumentation`
    设置为 `false`。
- en: 'If we expand `S3.PutObject`, we’ll see attributes that describe this operation,
    as shown in *Figure 3**.4*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开 `S3.PutObject`，我们将看到描述此操作的属性，如图 *3.4* 所示：
- en: '![Figure 3.4 – AWS S3 span attributes](img/B19423_03_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – AWS S3 跨度属性](img/B19423_03_04.jpg)'
- en: Figure 3.4 – AWS S3 span attributes
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – AWS S3 跨度属性
- en: Azure SDK
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure SDK
- en: Azure SDK instrumentation is native—it’s baked into modern libraries—and you
    don’t need to install any additional packages. Tracing code for all client libraries
    is available in the [https://github.com/Azure/azure-sdk-for-net/](https://github.com/Azure/azure-sdk-for-net/)
    repo. Still, it’s not stable because of tracing semantic conventions being experimental.
    For example, attribute names, types, and relationships between activities may
    change in the future.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Azure SDK 仪表化是原生的——它已嵌入到现代库中——您不需要安装任何额外的包。所有客户端库的跟踪代码都可在 [https://github.com/Azure/azure-sdk-for-net/](https://github.com/Azure/azure-sdk-for-net/)
    仓库中找到。然而，由于跟踪语义约定是实验性的，它仍然不稳定。例如，属性名称、类型和活动之间的关系可能会在未来发生变化。
- en: 'You can enable it with `AppContext` switch either in `csproj` or by adding
    the following code before Azure clients’ initialization:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `AppContext` 切换在 `csproj` 中启用它，或者通过在 Azure 客户端初始化之前添加以下代码：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instrumentation uses `ActivitySource` and `Activity` directly, so all we need
    to enable it is to call the `AddSource("Azure.*")` method on `TracerProviderBuilder`.
    It enables all sources that start with `Azure`, but you can also enable individual
    sources.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表化直接使用 `ActivitySource` 和 `Activity`，因此我们只需要在 `TracerProviderBuilder` 上调用 `AddSource("Azure.*")`
    方法来启用它。它启用了所有以 `Azure` 开头的源，但您也可以启用单个源。
- en: '*Figure 3**.5* shows the Azure SDK blob upload trace—logical upload operation
    and nested HTTP request. We see one there, but for chunked downloads, complex
    calls, or in case of retries, we’d see multiple nested HTTP calls:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.5* 展示了 Azure SDK 块上传跟踪——逻辑上传操作和嵌套 HTTP 请求。我们在这里看到一个，但对于分块下载、复杂调用或重试的情况，我们会看到多个嵌套
    HTTP 调用：'
- en: '![Figure 3.5 –  Azure Blob upload](img/B19423_03_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – Azure Blob 上传](img/B19423_03_05.jpg)'
- en: Figure 3.5 – Azure Blob upload
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – Azure Blob 上传
- en: We explored tracing for several libraries and learned how to discover and evaluate
    instrumentations. Let’s now discover what we can get from infrastructure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了几个库的跟踪，并学习了如何发现和评估仪表化。现在，让我们发现我们可以从基础设施中获得什么。
- en: Leveraging infrastructure
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用基础设施
- en: In this section, we’ll explore Dapr for microservices. Dapr provides service
    discovery, component bindings, secret management, locking, state management, observability,
    and more building blocks helping developers to focus on application logic. We’ll
    focus on distributed tracing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Dapr 在微服务中的应用。Dapr 提供服务发现、组件绑定、密钥管理、锁定、状态管理、可观察性以及更多构建块，帮助开发者专注于应用逻辑。我们将重点关注分布式跟踪。
- en: 'In our demo application, we’re going to handle all network calls with Dapr
    and enable tracing and metrics on it. We’ll also keep telemetry enabled on the
    microservices. *Figure 3**.6* shows the new application layout:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示应用程序中，我们将使用 Dapr 处理所有网络调用，并在此上启用跟踪和度量。我们还将保持微服务上的遥测开启。*图 3.6* 展示了新的应用程序布局：
- en: '![Figure 3.6 – Meme application with Dapr runtime](img/B19423_03_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 使用 Dapr 运行的 Meme 应用](img/B19423_03_06.jpg)'
- en: Figure 3.6 – Meme application with Dapr runtime
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 使用 Dapr 运行的 Meme 应用
- en: Dapr runs as a sidecar—a separate process wrapping each application instance.
    **Frontend** in our setup calls into **storage** via Dapr, which handles service
    discovery, error handling, encryption, load balancing, and more. **Storage**,
    in turn, uses Dapr output **binding** to communicate to Azure, AWS, or store memes
    locally.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr作为边车运行——一个围绕每个应用程序实例的独立进程。在我们的设置中，**前端**通过Dapr调用**存储**，Dapr处理服务发现、错误处理、加密、负载均衡等。**存储**反过来使用Dapr输出**绑定**与Azure、AWS或本地存储表情包进行通信。
- en: Dapr integrates well with Kubernetes, but we’ll use self-hosted mode and `docker-compose`
    to keep things simple.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr与Kubernetes集成良好，但我们将使用自托管模式并使用`docker-compose`来保持简单。
- en: Dapr supports distributed tracing and metrics for incoming and outgoing calls
    that applications make through Dapr. Let’s see what it means in practice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr支持通过Dapr进行的应用程序入站和出站调用的分布式跟踪和度量。让我们看看它在实践中意味着什么。
- en: Configuring secrets
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置密钥
- en: 'Dapr secrets configuration needs a different approach than we used for the
    libraries demo. We’ll need to update `darp/configs/dapr/storage-components/secrets.json`
    as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr密钥配置需要不同于我们在库演示中使用的不同方法。我们需要按以下方式更新`darp/configs/dapr/storage-components/secrets.json`：
- en: 'For AWS, put your access keys in `{"awsKey": <key>, "``awsSecret": <secret>}`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于AWS，将您的访问密钥放在`{"awsKey": <key>, "awsSecret": <secret>}`中。'
- en: 'For Azure, set `{"azStorageAccount": <account>, "azStorageKey": <key>}.` If
    you don''t have Azure credentials, remove the `binding-azure.yaml` file from the
    `dapr/configs/dapr/storage-components` folder, otherwise samples will not work.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于Azure，设置`{"azStorageAccount": <account>, "azStorageKey": <key>}.` 如果你没有Azure凭证，请从`dapr/configs/dapr/storage-components`文件夹中删除`binding-azure.yaml`文件，否则示例将无法工作。'
- en: For local runs, set `CloudStorage.Type` to `Local` in `storage/appsettings.json`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于本地运行，请在`storage/appsettings.json`中将`CloudStorage.Type`设置为`Local`。
- en: Configuring observability on Dapr
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Dapr上配置可观察性
- en: 'To enable tracing and metrics, let’s add corresponding sections to `Configuration
    spec`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用跟踪和度量，让我们在`配置规范`中添加相应的部分：
- en: ./dapr/configs/dapr/config.yml
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ./dapr/configs/dapr/config.yml
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/dapr/configs/dapr/config.yml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/dapr/configs/dapr/config.yml)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/dapr/configs/dapr/config.yml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/dapr/configs/dapr/config.yml)'
- en: We also added Dapr sidecars to `docker-compose.yml`, enabled the Zipkin trace
    receiver on the OpenTelemetry collector, and added Dapr metrics endpoints to Prometheus
    targets to scrape from. As a result, we receive traces and metrics from the application
    and Dapr at the same time. Let’s check them out.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`docker-compose.yml`中添加了Dapr边车，在OpenTelemetry收集器上启用了Zipkin跟踪接收器，并将Dapr度量端点添加到Prometheus目标以进行抓取。因此，我们同时从应用程序和Dapr接收跟踪和度量。让我们来看看。
- en: Tracing
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪
- en: 'Let’s run the application now with `docker-compose up --build`, hit `http://localhost:16686`
    and find some upload requests, you should see something like the trace shown in
    *Figure 3**.7*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`docker-compose up --build`运行应用程序，点击`http://localhost:16686`并找到一些上传请求，你应该会看到类似于*图3.7*中所示的跟踪：
- en: '![Figure 3.7 – Trace from the application and Dapr ](img/B19423_03_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 应用程序和Dapr的跟踪](img/B19423_03_07.jpg)'
- en: Figure 3.7 – Trace from the application and Dapr
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 应用程序和Dapr的跟踪
- en: The first two spans coming from `frontend /memes/d8…` and `CallLocal/storage/memes/d8…`
    spans—they are new and are coming from Dapr.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`frontend /memes/d8…`和`CallLocal/storage/memes/d8…`的前两个跨度——它们是新的，并且来自Dapr。
- en: 'If we expand them as shown in *Figure 3**.8*, we’ll also see the attributes
    it set:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像*图3.8*中所示那样展开它们，我们还会看到它设置的属性：
- en: '![Figure 3.8 – Dapr spans and attributes ](img/B19423_03_08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – Dapr跨度属性](img/B19423_03_08.jpg)'
- en: Figure 3.8 – Dapr spans and attributes
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – Dapr跨度属性
- en: You would probably wonder if we still need distributed tracing on the service—let’s
    check it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们是否还需要在服务上进行分布式跟踪——让我们检查一下。
- en: Stop containers and comment out the `OTEL_EXPORTER_OTLP_ENDPOINT` environment
    variable in `docker-compose.yml` for **frontend** and **storage**; we don’t enable
    OpenTelemetry if the endpoint is not provided.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 停止容器并在`docker-compose.yml`中的**前端**和**存储**上注释掉`OTEL_EXPORTER_OTLP_ENDPOINT`环境变量；如果没有提供端点，我们不启用OpenTelemetry。
- en: 'Then, restart the application and upload some memes again, and the result is
    shown in *Figure 3**.9*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新启动应用程序并再次上传一些表情包，结果如*图3.9*所示：
- en: '![Figure 3.9 – Dapr tracing without OpenTelemetry enabled in the application](img/B19423_03_09.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 应用程序未启用 OpenTelemetry 的 Dapr 跟踪](img/B19423_03_09.jpg)'
- en: Figure 3.9 – Dapr tracing without OpenTelemetry enabled in the application
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 应用程序未启用 OpenTelemetry 的 Dapr 跟踪
- en: So, we see the spans coming from Dapr, but the trace does not look right—upload
    to Azure Blob is not a child of an incoming request represented with `CallLocal/storage`
    span. What happened there?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到来自 Dapr 的跨度，但跟踪看起来并不正确——上传到 Azure Blob 不是用 `CallLocal/storage` 跨度表示的入站请求的子项。那里发生了什么？
- en: In [*Chapter 2*](B19423_02.xhtml#_idTextAnchor038), *Native Monitoring in .NET*,
    we have shown that ASP.NET Core and `HttpClient` in .NET create activities regardless
    of OpenTelemetry presence. This is what happened here—`CallLocal` is a grandparent
    to `/v1.0/bindings/azureblob`, but the span between them is not recorded and causation
    is lost.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B19423_02.xhtml#_idTextAnchor038) *.NET 的原生监控* 中，我们展示了 ASP.NET Core
    和 .NET 中的 `HttpClient` 创建活动，无论是否存在 OpenTelemetry。这就是这里发生的事情——`CallLocal` 是 `/v1.0/bindings/azureblob`
    的曾祖父母，但它们之间的跨度没有被记录，因果关系丢失。
- en: Similarly, if you use Dapr on an application that does not enable distributed
    tracing by default, the context will not be propagated within the `CallLocal`
    and `/v1.0/bindings/azureblob` would disappear.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你在一个默认不启用分布式跟踪的应用程序上使用 Dapr，上下文将不会在 `CallLocal` 和 `/v1.0/bindings/azureblob`
    中传播。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Dapr or service mesh, such as Istio, can trace network calls, but they cannot
    propagate trace context within the application process and rely on applications
    to do it. They also can’t stamp context on the logs if your application does not
    do it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr 或服务网格，如 Istio，可以跟踪网络调用，但它们无法在应用程序进程内传播跟踪上下文，并依赖于应用程序来完成。如果你的应用程序没有这样做，它们也不能在日志上标记上下文。
- en: If you can’t instrument your application, traces coming from Dapr or service
    mesh are still handy, despite being semi-correlated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法对你的应用程序进行仪表化，来自 Dapr 或服务网格的跟踪仍然很有用，尽管它们是半相关的。
- en: If you use Dapr for reasons beyond observability and your application is instrumented,
    then Dapr tracing gives you observability into Dapr itself to see how it handles
    requests, so you can compare latencies, debug configuration issues, and so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Dapr 的原因超出了可观察性，并且你的应用程序已经进行了仪表化，那么 Dapr 跟踪可以让你对 Dapr 本身有可观察性，以查看它是如何处理请求的，这样你可以比较延迟、调试配置问题等等。
- en: Metrics
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标
- en: Dapr reports extensive metrics about application communication and bindings
    such as HTTP and gRPC request count, duration, and request and response size histograms.
    You could also find Go runtime stats for the Dapr itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr 报告了关于应用程序通信和绑定（如 HTTP 和 gRPC 请求计数、持续时间以及请求和响应大小直方图）的详细指标。你也可以找到 Dapr 自身的
    Go 运行时统计信息。
- en: These metrics look quite promising but by default they use the HTTP request
    path as an attribute on metrics, which has high cardinality. While they allow
    to reduce cardinality with a regular expression and convert path to an API route,
    it would be a problem in high-scale production application. Once they become production
    ready, they could be a great alternative to many in-process metrics covering network
    communication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标看起来很有前景，但默认情况下，它们使用 HTTP 请求路径作为指标上的属性，这具有高基数。虽然它们允许使用正则表达式来减少基数并将路径转换为 API
    路由，但在高规模的生产应用程序中可能会出现问题。一旦它们准备好投入生产，它们可以成为许多进程内指标的绝佳替代品，这些指标涵盖了网络通信。
- en: Instrumenting serverless environments
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端无服务器环境
- en: Serverless environments need observability more than other systems—they are
    frequently used to integrate different services with little-to-no user code, making
    debugging and local testing difficult. With load balancing, scaling, and other
    common infrastructure pieces handled for us, we still need to understand what’s
    going on when things don’t work as expected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端无服务器环境比其他系统更需要可观察性——它们经常用于以少量或没有用户代码的方式集成不同的服务，这使得调试和本地测试变得困难。尽管负载均衡、扩展和其他常见的基础设施组件由我们处理，但我们仍然需要了解当事情没有按预期进行时发生了什么。
- en: In addition, as users, we are very limited with telemetry collection options—we
    can’t install agents, configure runtime, or run something in privileged mode—we
    can only use what cloud providers expose. At the same time, cloud providers have
    a great opportunity to instrument code for us. Let’s see what AWS Lambda and Azure
    Functions provide out of the box and what we can do on top of it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为用户，我们在遥测收集选项上非常有限——我们无法安装代理、配置运行时或在特权模式下运行某些内容——我们只能使用云提供商提供的。同时，云提供商有为我们仪表化代码的巨大机会。让我们看看
    AWS Lambda 和 Azure Functions 提供了什么，以及我们可以在其上做什么。
- en: AWS Lambda
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: 'AWS Lambda supports invocation tracing with X-Ray out of the box; you just
    need to enable active tracing via console or CLI to trace incoming calls to your
    function and see basic invocation metrics:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 支持与 X-Ray 集成的调用跟踪；您只需通过控制台或 CLI 启用活动跟踪即可跟踪对函数的传入调用并查看基本的调用指标：
- en: '![Figure 3.10 – AWS X-Ray service map showing default Lambda instrumentation](img/B19423_03_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – AWS X-Ray 服务映射显示默认 Lambda 仪表化](img/B19423_03_10.jpg)'
- en: Figure 3.10 – AWS X-Ray service map showing default Lambda instrumentation
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – AWS X-Ray 服务映射显示默认 Lambda 仪表化
- en: To go further than this and trace what happens in your code, you’d need to use
    X-Ray SDK as a stable solution or OpenTelemetry, which is in beta at this point.
    We’re going to play with OpenTelemetry in this demo.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步跟踪代码中的操作，您需要使用 X-Ray SDK 作为稳定的解决方案或 OpenTelemetry，目前它处于测试阶段。在这个演示中，我们将使用
    OpenTelemetry。
- en: The configuration around OpenTelemetry is likely to change. So, we will kindly
    ask you to check out the latest instructions for **ADOT Collector** (**AWS Distro
    for OpenTelemetry Collector**), available at [https://aws-otel.github.io/docs/getting-started/lambda/lambda-dotnet](https://aws-otel.github.io/docs/getting-started/lambda/lambda-dotnet).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 的配置可能会发生变化。因此，我们将礼貌地请您查看最新的 **ADOT 收集器**（**AWS Distro for OpenTelemetry
    Collector**）说明，可在 [https://aws-otel.github.io/docs/getting-started/lambda/lambda-dotnet](https://aws-otel.github.io/docs/getting-started/lambda/lambda-dotnet)
    找到。
- en: ADOT Collector is based on OpenTelemetry Collector; it’s also compatible with
    AWS environments and comes with a preselected set of community components. We’re
    going to send traces to X-Ray, which is a default configuration for ADOT Collector,
    but you can configure it to send data to your observability backend.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ADOT 收集器基于 OpenTelemetry 收集器；它也兼容 AWS 环境，并附带一组预选的社区组件。我们将向 X-Ray 发送跟踪信息，这是 ADOT
    收集器的默认配置，但您可以配置它以将数据发送到您的可观察性后端。
- en: Now we’re ready to explore the tracing experience in Lambda.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好探索 Lambda 中的跟踪体验。
- en: Enabling additional tracing
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用额外的跟踪
- en: 'Tracing configuration in Lambda is like any other service. First, we need to
    install the `OpenTelemetry.Instrumentation.AWSLambda` NuGet package and then configure
    it along with the exporter and other instrumentations:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 中的跟踪配置与其他服务类似。首先，我们需要安装 `OpenTelemetry.Instrumentation.AWSLambda` NuGet
    包，然后与导出器和其他仪表化配置一起进行配置：
- en: Function.cs
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Function.cs
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs)'
- en: Let’s unpack what happens here. First, we set `AWSXRayPropagator` as a default
    context propagator—it enables context propagation over the `X-Amzn-Trace-Id` header.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这里发生的事情。首先，我们将 `AWSXRayPropagator` 设置为默认上下文传播器——它通过 `X-Amzn-Trace-Id`
    标头启用上下文传播。
- en: 'Then, we enabled Lambda instrumentation with `AddAWSLambdaConfigurations`.
    If we look under the hood, this method does a couple of things:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `AddAWSLambdaConfigurations` 启用了 Lambda 仪表化。如果我们深入了解，这个方法做了几件事情：
- en: Detects and configures resource attributes such as cloud provider, region, function
    name, and version
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和配置资源属性，如云提供商、区域、函数名称和版本
- en: Enables `ActivitySource` that reports Lambda invocations and stitches context
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 `ActivitySource`，它报告 Lambda 调用并缝合上下文
- en: Note that we do it in the static constructor to optimize performance and reduce
    costs. Despite being serverless, Lambda uses one process for multiple invocations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在静态构造函数中这样做以优化性能并降低成本。尽管 Lambda 是无服务器的，但它使用一个进程来处理多个调用。
- en: 'As the last step, we need to implement the tracing handler that wraps our Lambda
    logic:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要实现包装我们的 Lambda 逻辑的跟踪处理程序：
- en: Function.cs
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Function.cs
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs)'
- en: Note that we configured Lambda to invoke `TracingHandler` instead of inner `MemeHandler`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们配置 Lambda 调用 `TracingHandler` 而不是内部的 `MemeHandler`。
- en: If we get back to the configuration, the rest enables AWS SDK and HTTP Client
    instrumentation. We also configured the OTLP exporter without parameters—it uses
    the default endpoint (`localhost:4317`) and the default protocol (`gRPC`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到配置，其余部分启用 AWS SDK 和 HTTP 客户端工具。我们还配置了不带参数的 OTLP 导出器 – 它使用默认端点 (`localhost:4317`)
    和默认协议 (`gRPC`)。
- en: We also configured **frontend** to send data to ADOT with the X-Ray exporter,
    so we get all traces in the same place.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还配置了 **前端** 使用 X-Ray 导出器将数据发送到 ADOT，因此我们可以在同一位置获取所有跟踪。
- en: If you didn’t deploy your Lambda function yet, deploy it now, for example, with
    AWS Toolkit for Visual Studio or Lambda tools for .NET CLI.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未部署 Lambda 函数，现在就部署它，例如，使用 Visual Studio 的 AWS Toolkit 或 .NET CLI 的 Lambda
    工具。
- en: Make sure to configure the function URL on `Storage__Endpoint` environment variable—you
    can set it in `./frontend/docker-compose.yml`. We don’t use authorization in the
    demo, but make sure to secure your real-life applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `Storage__Endpoint` 环境变量上配置函数 URL – 您可以在 `./frontend/docker-compose.yml`
    中设置它。在演示中我们不使用授权，但请确保保护您现实生活中的应用程序。
- en: Now, let’s start `docker-compose up --build`, then upload and download some
    memes at `http://localhost:5051`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始 `docker-compose up --build`，然后在 `http://localhost:5051` 上上传和下载一些表情包。
- en: 'Let’s switch to AWS X-Ray and check out the traces. You should see something
    similar to *Figure 3**.11*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到 AWS X-Ray 并检查跟踪。您应该会看到类似于 *图 3.11* 的内容：
- en: '![Figure 3.11 – Lambda tracing with OpenTelemetry](img/B19423_03_11.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 使用 OpenTelemetry 的 Lambda 跟踪](img/B19423_03_11.jpg)'
- en: Figure 3.11 – Lambda tracing with OpenTelemetry
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 使用 OpenTelemetry 的 Lambda 跟踪
- en: If you check the service map, it now shows S3 in addition to Lambda nodes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查服务图，它现在除了 Lambda 节点外还显示了 S3。
- en: Now that you know how to enable tracing for AWS Lambda, let’s see what Azure
    Functions are capable of.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何为 AWS Lambda 启用跟踪，让我们看看 Azure Functions 有哪些能力。
- en: Azure Functions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Azure Functions support distributed tracing with Azure Monitor (Application
    Insights) out-of-the-box. It includes triggers and most bindings. If you use in-process
    functions, tracing covers user code too, with isolated workers, you need to enable
    and configure tracing in the worker process yourself.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 支持与 Azure Monitor (Application Insights) 集成的分布式跟踪。它包括触发器和大多数绑定。如果您使用进程内函数，跟踪也会覆盖用户代码，对于隔离的工作进程，您需要自行在工作进程中启用和配置跟踪。
- en: Azure Functions rely on the instrumentations in client SDKs used for triggers
    and bindings. For example, they reuse ASP.NET Core Activities in HTTP Trigger
    and Azure SDK instrumentation for Azure Blob Storage inputs and outputs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 依赖于用于触发器和绑定的客户端 SDK 中的工具。例如，它们在 HTTP 触发器中重用 ASP.NET Core 活动，并在
    Azure Blob Storage 输入和输出中使用 Azure SDK 工具。
- en: The Azure Functions runtime does not support OpenTelemetry for in-process functions
    yet, but your observability vendor may provide an extension that covers this gap.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 运行时目前尚不支持 OpenTelemetry 用于进程内函数，但您的可观察性供应商可能提供一种扩展来填补这一空白。
- en: 'In our sample, Azure Functions host automatically reports triggers and binding
    calls to Application Insights – this auto-collection lights up in presence of
    the `APPLICATIONINSIGHTS_CONNECTION_STRING` environment variable, which we can
    set in the `local.settings.json` file, as shown in this example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，Azure Functions 主机自动向 Application Insights 报告触发器和绑定调用 – 这种自动收集在存在 `APPLICATIONINSIGHTS_CONNECTION_STRING`
    环境变量时启动，我们可以在 `local.settings.json` 文件中设置它，如本例所示：
- en: ./serverless/azure/memefunc/local.settings.json
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ./serverless/azure/memefunc/local.settings.json
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/local.settings.json](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/local.settings.json)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/local.settings.json](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/local.settings.json)'
- en: 'We also need to enable OpenTelemetry for the worker process with the following
    code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用以下代码为工作进程启用 OpenTelemetry：
- en: ./serverless/azure/memefunc/Program.cs
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ./serverless/azure/memefunc/Program.cs
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/Program.cs)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/Program.cs)'
- en: Here we use a familiar way to enable OpenTelemetry, but `the Microsoft.Azure.Functions.Worker`
    activity source is new. The source is part of Azure Functions Worker and propagates
    trace context from the host to isolated worker. It creates an activity representing
    worker invocation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了一种熟悉的方式来启用 OpenTelemetry，但 `the Microsoft.Azure.Functions.Worker` 活动源是新的。该源是
    Azure Functions Worker 的一部分，它从主机传播跟踪上下文到隔离的工作进程。它创建了一个代表工作者调用的活动。
- en: On the `Azure.Monitor.OpenTelemetry.Exporter` to send data to Application Insights
    endpoint directly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Azure.Monitor.OpenTelemetry.Exporter` 上发送数据到 Application Insights 端点。
- en: 'To run the sample, we’ll need an Application Insights resource. You can create
    one with the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例需要创建一个 Application Insights 资源。你可以使用以下命令创建：
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It will return JSON output containing `connectionString`, which we’ll need
    to configure Functions. Let’s now set Azure Blob Storage and Application Insights
    connection strings in `memefunc/local.setting.json` and we’re ready to run the
    application:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回包含 `connectionString` 的 JSON 输出，这是我们配置 Functions 所需要的。现在让我们在 `memefunc/local.setting.json`
    中设置 Azure Blob Storage 和 Application Insights 连接字符串，然后我们就可以运行应用程序了：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Hit `http://localhost:5051` to upload and download some memes, and then go
    to your Application Insights resource and search for recent requests. *Figure
    3**.12* shows an example of captured trace:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `http://localhost:5051` 来上传和下载一些表情包，然后转到你的 Application Insights 资源并搜索最近请求。*图
    3.12* 展示了捕获的跟踪示例：
- en: '![Figure 3.12 – Azure Functions trace ](img/B19423_03_12.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – Azure Functions 跟踪](img/B19423_03_12.jpg)'
- en: Figure 3.12 – Azure Functions trace
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – Azure Functions 跟踪
- en: We traced this call from `storage-download` function that in turn downloaded
    a blob. We used Azure Blob Storage bindings, so all the communication with blob
    storage was handled by Azure Functions host and outside of the worker process.
    As a result, the Azure Functions invocation span (`storage-download`) and all
    spans related to blobs are reported by the Functions host.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们追踪了这个从 `storage-download` 函数发出的调用，该函数随后下载了一个 blob。我们使用了 Azure Blob Storage
    绑定，因此与 blob 存储的所有通信都由 Azure Functions 主机处理，且在工作进程之外。因此，Azure Functions 调用跨度（`storage-download`）以及所有与
    blob 相关的跨度都是由 Functions 主机报告的。
- en: The `Invoke` span is recorded by `Microsoft.Azure.Functions.Worker` activity
    source; it represents function invocation on the worker side. If we had any nested
    operations done inside worker, we’d see them reported as children of the `Invoke`
    span.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke` 调用跨度由 `Microsoft.Azure.Functions.Worker` 活动源记录；它代表在工作进程上的函数调用。如果我们有任何在工作者内部完成的嵌套操作，我们会看到它们作为
    `Invoke` 调用跨度的子项被报告。'
- en: Even though most of the application logic happened outside of the application
    code, we can see what happened under the hood because of tracing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大部分应用程序逻辑发生在应用程序代码之外，但由于跟踪，我们仍然可以看到底层的操作。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored instrumentations in the .NET ecosystem. You learned
    how to evaluate and configure different kinds of instrumentation libraries, how
    to enable and use tracing on Dapr, and what serverless environments can provide
    with different levels of configuration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 .NET 生态系统中的仪器化。你学习了如何评估和配置不同类型的仪器库，如何启用和使用 Dapr 上的跟踪，以及不同配置级别下无服务器环境可以提供什么。
- en: Client library auto-instrumentations can be found in OpenTelemetry repositories
    or registries, while some libraries don’t need instrumentations, providing tracing
    natively. Instrumentations’ maturity and stability levels vary, so it’s important
    to review and test them as a part of your normal integration and stress testing.
    Instrumentations usually provide configuration options to control the amount of
    details they capture, allowing you to find the right cost-value ratio for your
    system. Client libraries and frameworks are not the only sources of traces—your
    infrastructure such as service meshes, web servers, load balancers, and proxies
    can emit them. We checked out the tracing story in Dapr and confirmed that it
    provides insights into Dapr itself but can’t propagate the context and stamp it
    on the logs and other signals in the application. So, infrastructure traces complement
    but cannot substitute in-process tracing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端库自动跟踪可以在OpenTelemetry仓库或注册表中找到，而一些库不需要跟踪工具，提供原生的跟踪功能。跟踪工具的成熟度和稳定性水平各不相同，因此作为你正常集成和压力测试的一部分，审查和测试它们很重要。跟踪工具通常提供配置选项来控制它们捕获的细节量，这允许你为你的系统找到合适的成本效益比。客户端库和框架并不是跟踪的唯一来源——你的基础设施，如服务网格、Web服务器、负载均衡器和代理也可以产生跟踪。我们检查了Dapr中的跟踪故事，确认它提供了对Dapr本身的洞察，但不能传播上下文并在应用程序的日志和其他信号上打上标记。因此，基础设施跟踪是补充但无法替代进程内跟踪。
- en: Serverless environments provide integration with tracing and monitoring tools;
    it’s critical for them since users are limited in the configuration of serverless
    runtime.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器环境提供了与跟踪和监控工具的集成；这对于它们来说至关重要，因为用户在无服务器运行时的配置上有限。
- en: We explored AWS Lambda, which supports OpenTelemetry, with ADOT Collector and
    in-code configuration, and Azure Functions that supports vendor-specific codeless
    instrumentation for in-process mode, while out-of-the-box OpenTelemetry support
    is yet to come.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了支持OpenTelemetry的AWS Lambda，使用ADOT收集器和代码内配置，以及支持供应商特定代码无跟踪模式的Azure Functions，而开箱即用的OpenTelemetry支持尚未到来。
- en: Now that you know how to discover and use third-party instrumentations in different
    environments, you should be able to get observability into a broad spectrum of
    distributed applications. However, to debug in-process issues such as deadlocks,
    memory leaks, or inefficient code, we’ll need lower-level telemetry—this is what
    we’re going to explore in the next chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在不同的环境中发现和使用第三方跟踪工具，你应该能够对广泛范围的分布式应用程序获得可观察性。然而，要调试进程内问题，如死锁、内存泄漏或低效的代码，我们需要更底层的遥测——这就是我们将在下一章中探讨的内容。
- en: Questions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you find instrumentation for a popular library you use? When you find
    one, what would you check for?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何找到一个你使用的流行库的跟踪工具？当你找到一个时，你会检查什么？
- en: What is a typical mechanism behind OpenTelemetry tracing instrumentations?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenTelemetry跟踪工具背后的典型机制是什么？
- en: What service mesh can and cannot do in terms of tracing?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务网格在跟踪方面能做什么，不能做什么？
