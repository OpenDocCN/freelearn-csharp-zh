- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: The Event System and Programming for UI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件系统和UI编程
- en: One of the key features of the Unity UI system is the ability to easily program
    how the UI elements receive interactions from the player via events. The **Event
    System** is a robust system that allows you to create and manage events.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI系统的关键特性之一是能够通过事件轻松编程UI元素如何接收玩家的交互。**事件系统**是一个强大的系统，允许你创建和管理事件。
- en: Once you learn how to take advantage of the Event System, you will be able to
    create interactable UI as well as UI that responds to events in your game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你学会了如何利用事件系统，你将能够创建可交互的UI以及响应游戏事件的事件UI。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: How to access UI elements and their properties via code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过代码访问UI元素及其属性
- en: What the Event System is and how to work with it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件系统是什么以及如何与之协同工作
- en: How to customize input axes with the Input Manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用输入管理器自定义输入轴
- en: What an Input Module is, and which ones are provided by Unity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入模块是什么，以及Unity提供了哪些输入模块
- en: How to use the Event Trigger component to receive events on UI objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用事件触发组件接收UI对象上的事件
- en: What Raycasters are and what types of Raycasters are provided by Unity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射线投射器是什么以及Unity提供了哪些类型的射线投射器
- en: How to show and hide pop-up Panels using keyboard inputs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用键盘输入显示和隐藏弹出面板
- en: How to pause the game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何暂停游戏
- en: How to create a drag and drop inventory system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建拖放库存系统
- en: How to use mouse or multi-touch input to pan and zoom the camera
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用鼠标或多点触控输入平移和缩放相机
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008)
- en: Accessing UI elements in code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中访问UI元素
- en: All the UI elements can be accessed and manipulated in code like other GameObjects.
    To access a UI element in code, you must include the `UnityEngine.UI` namespace
    and the correct variable type. Let’s look at the `UnityEngine.UI` namespace.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有UI元素都可以像其他GameObject一样在代码中进行访问和操作。要访问代码中的UI元素，你必须包含`UnityEngine.UI`命名空间和正确的变量类型。让我们看看`UnityEngine.UI`命名空间。
- en: UnityEngine.UI namespace
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`UnityEngine.UI`命名空间'
- en: A `using` keyword.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`关键字。'
- en: By default, all new C# scripts include the `System.Collections`, `System.Collections.Generic`
    and `UnityEngine` namespaces. To access the properties of UI elements via code,
    you must first use the `UnityEngine.UI` namespace.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有新的C#脚本都包含了`System.Collections`、`System.Collections.Generic`和`UnityEngine`命名空间。要通过代码访问UI元素的属性，你必须首先使用`UnityEngine.UI`命名空间。
- en: 'Therefore, at the top of your C# script, you will need to include the following
    line to signify that you want to use the `UnityEngine.UI` namespace:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你的C#脚本顶部，你需要包含以下行来表示你想要使用`UnityEngine.UI`命名空间：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Without using the namespace, any variable type related to UI elements will be
    colored red in your code editor, and you will be given a compiler error. Once
    you include the namespace, the variable type will change to the blue-colored text,
    signifying that it is an available variable type, and the compiler error will
    disappear.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用命名空间的情况下，与UI元素相关的任何变量类型在你的代码编辑器中都会被标记为红色，并且你会收到一个编译错误。一旦你包含了命名空间，变量类型将变为蓝色文本，表示这是一个可用的变量类型，编译错误将消失。
- en: UI variable types
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI变量类型
- en: Each variable type is a class within the `UnityEngine.UI` namespace. Therefore,
    each of these variable types, in turn, has its own set of variables and functions
    that can be accessed. We’ll discuss each variable type more thoroughly in future
    sections and chapters, but for now, let’s just look at the standard template for
    accessing a property of a UI element in code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量类型都是`UnityEngine.UI`命名空间中的一个类。因此，这些变量类型中的每一个都有自己的变量和函数集，可以访问。我们将在未来的章节中更详细地讨论每个变量类型，但就目前而言，让我们先看看在代码中访问UI元素属性的标准化模板。
- en: 'You can find within the source files a Unity package named `Chapter 08``.unitypackage`.
    Importing it will bring in a scene named `Chapter8.unity` and various code files.
    Import the items from the package and open the scene. In the `Chapter8` scene,
    you will see a UI Image named `UI Variables Example`. It does not have a sprite
    assigned to it and appears as a white square. The following script, `AddSprite.cs`,
    is attached to the UI Image:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源文件中找到一个名为`Chapter 08``.unitypackage`的Unity包。导入它将引入一个名为`Chapter8.unity`的场景和多个代码文件。导入包中的项目并打开场景。在`Chapter8`场景中，你会看到一个名为`UI
    Variables Example`的UI图像。它没有分配任何精灵，显示为一个白色方块。以下名为`AddSprite.cs`的脚本附加到UI图像上：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The UI-specific pieces of code are highlighted in the preceding code. Note that
    the `UnityEngine.UI` namespace is included at the top of the class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中突出显示了UI特定的代码。请注意，`UnityEngine.UI`命名空间包含在类的顶部。
- en: 'There are two public variables defined in the class: `theImage`, which is an
    `Image` type, and `theSprite`, which is a `Sprite` type. The `theImage` variable
    is referencing the UI Image in the scene and the `theSprite` variable is referencing
    the sprite that will become the source image of the UI Image.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中定义了两个公共变量：`theImage`，它是一个`Image`类型，和`theSprite`，它是一个`Sprite`类型。`theImage`变量引用场景中的UI图像，而`theSprite`变量引用将成为UI图像源图像的精灵。
- en: The `Image` variable type is within the `UnityEngine.UI` namespace and represents
    UI Image GameObject. The `Sprite` variable type is not a UI element and is included
    in the `UnityEngine` namespace.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`变量类型位于`UnityEngine.UI`命名空间中，表示UI图像GameObject。`Sprite`变量类型不是一个UI元素，它包含在`UnityEngine`命名空间中。'
- en: Within the `Start()` function, the properties of the `Image` component on `theImage`
    are referenced by typing a period and then the property after the variable name.
    You can access any property that appears in a UI element’s corresponding component
    in this way. You can also access properties that are not listed in the component
    this way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start()`函数中，通过在变量名后输入一个点然后输入属性来引用`theImage`上的`Image`组件的属性。你可以以这种方式访问UI元素对应组件中出现的任何属性。你也可以以这种方式访问组件中未列出的属性。
- en: 'The `AddSprite` script attached to `UI Variables Example (Image)` appears in
    the inspector, as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到`UI Variables Example (Image)`的`AddSprite`脚本在检查器中显示，如下面的截图所示：
- en: '![Figure 8.1: The AddSprite script and its properties](img/B18327_08_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：AddSprite脚本及其属性](img/B18327_08_01.jpg)'
- en: 'Figure 8.1: The AddSprite script and its properties'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：AddSprite脚本及其属性
- en: Now, when the scene is played, the sprite will change from a blank white square
    to an image of a banana with its aspect ratio preserved.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当场景播放时，精灵将从空白白色方块变为香蕉图像，并保持其宽高比。
- en: Let’s explore the Event System, which will allow us to interact with our UI.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索事件系统，这将使我们能够与我们的UI进行交互。
- en: The Event System
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件系统
- en: In [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), we learned that when the
    first Canvas is added to a scene, a GameObject named `EventSystem` is automatically
    added to the Hierarchy. The Event System allows you to easily receive player interactions
    and send those interactions to objects in your scene through events. Note that
    I said, *objects in your scene* and not *UI objects*. The Event System allows
    you to send events to non-UI items, too!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18327_06.xhtml#_idTextAnchor085)中，我们了解到当第一个Canvas被添加到场景中时，会自动在层次结构中添加一个名为`EventSystem`的GameObject。事件系统允许你轻松接收玩家交互并将这些交互通过事件发送到场景中的对象。请注意，我说的是*场景中的对象*，而不是*UI对象*。事件系统还可以将事件发送到非UI元素！
- en: Before we proceed, I’d like to note my use of `EventSystem` (one word) and Event
    System (two words), because I will be switching back and forth between the two.
    I want you to know that I am doing it deliberately and am not just randomly deciding
    that sometimes I hate the spacebar.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想指出我使用`EventSystem`（一个单词）和Event System（两个单词），因为我将在两者之间来回切换。我想让你知道我这样做是有意为之，并不是随机决定有时候我讨厌空格键。
- en: I will use `EventSystem` (one word) to reference the actual GameObject that
    appears in the Hierarchy of your scene and Event System (two words) to reference
    the system that handles events.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`EventSystem`（一个单词）来引用场景层次结构中实际出现的GameObject，并使用Event System（两个单词）来引用处理事件的系统。
- en: The Event System does quite a few things for you other than just sending events
    to objects. It also keeps track of the currently selected GameObject, the Input
    Modules, and Raycasting.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向对象发送事件之外，事件系统还为你做了很多事情。它还跟踪当前选中的 GameObject、输入模块和射线投射。
- en: 'The EventSystem GameObject initializes, by default, with three components:
    the **Transform**, **Event System** Manager, and **Standalone Input Module**,
    as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: EventSystem GameObject 默认初始化时包含三个组件：**Transform**、**Event System** 管理器和 **Standalone
    Input Module**，如下面的截图所示：
- en: '![Figure 8.2: The EventSystem GameObject and its components](img/B18327_08_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2：EventSystem GameObject 及其组件](img/B18327_08_02.jpg)'
- en: 'Figure 8.2: The EventSystem GameObject and its components'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：EventSystem GameObject 及其组件
- en: Since `EventSystem` is a GameObject, it physically exists within the scene (even
    though it has no renderable component making it visible) and therefore has a **Transform**
    component like all other GameObjects. You should be familiar with the **Transform**
    component by now, so we won’t discuss it further. However, the other two components
    do merit further discussion. Let’s look at the **Event System** component more
    closely now. We’ll also discuss the **Standalone Input Module** component in the
    *Input Modules* section of this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `EventSystem` 是一个 GameObject，它实际上存在于场景中（尽管它没有可渲染的组件使其可见），因此它具有与其他所有 GameObject
    一样的 **Transform** 组件。你现在应该熟悉 **Transform** 组件了，所以我们不会进一步讨论它。然而，其他两个组件确实值得进一步讨论。现在让我们更仔细地看看
    **Event System** 组件。我们还会在本章的 *Input Modules* 部分讨论 **Standalone Input Module**
    组件。
- en: You cannot have more than that one `EventSystem` GameObject in your scene. If
    you try to add a new one in the scene via **+** | **UI** | **Event System**, a
    new one will not be added, and the one currently in the scene will be selected
    for you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你的场景中不能有超过一个 `EventSystem` GameObject。如果你尝试通过 **+** | **UI** | **Event System**
    在场景中添加一个新的，则不会添加新的，而是会为你选择场景中当前存在的那个。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you manage to add a second **EventSystem** to your scene (by perhaps using
    *Ctrl* + *D* to duplicate the existing one), you will see a warning message on
    your **Console**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设法在你的场景中添加第二个 **EventSystem**（例如通过使用 *Ctrl* + *D* 复制现有的一个），你将在你的 **Console**
    上看到一个警告信息。
- en: If you have more than one **EventSystem** GameObject in your scene, only the
    first one added will actually do anything. Any additional **EventSystems** will
    be non-functional.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的场景中有多于一个 **EventSystem** GameObject，只有第一个添加的会实际执行任何操作。任何额外的 **EventSystems**
    都将无法使用。
- en: Let’s look at the **Event System** Manager next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来看看 **Event System** 管理器。
- en: Event System Manager
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Event System 管理器
- en: '**Event System** Manager is the component that actually does all the tracking
    and managing of the various **Event** **System** elements.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Event System** 管理器是负责跟踪和管理各种 **Event** **System** 元素的组件。'
- en: If you want to work with the `EventSystem` GameObject will not be automatically
    created for you. You can add an **Event System** Manager to a GameObject by selecting
    **Add Component** | **Event** | **Event System** on the object’s Inspector. Let’s
    talk about the properties under the **Event** **System** Manager.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要与 `EventSystem` GameObject 一起工作，它不会自动为你创建。你可以通过在对象的检查器中选择 **Add Component**
    | **Event** | **Event System** 来将 **Event System** 管理器添加到 GameObject。让我们来谈谈 **Event**
    **System** 管理器下的属性。
- en: First Selected
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首次选中
- en: You know when you start up a game and the **Start Game** button is highlighted
    for you so that hitting *Enter* will start the game without you having to use
    your mouse? That’s what the **First Selected** property does for you. It selects
    a UI element in the scene for you automatically when it starts up.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动游戏时，你知道 **Start Game** 按钮会为你高亮显示，这样按下 *Enter* 就可以开始游戏，而无需使用鼠标？这就是 **First
    Selected** 属性为你做的事情。它在启动时自动为你选择场景中的 UI 元素。
- en: You can drag and drop any intractable UI element into this slot to make it the
    first selected UI item in your scene. This is particularly helpful for games that
    do not use a mouse or touchscreen but rely solely on a gamepad, joystick, or keyboard.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何不可交互的 UI 元素拖放到这个槽位，使其成为场景中第一个选中的 UI 项目。这对于不使用鼠标或触摸屏，而完全依赖游戏手柄、摇杆或键盘的游戏尤其有帮助。
- en: Send Navigation Events
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送导航事件
- en: 'The **Send Navigation Events** property can be toggled on and off. When this
    property is enabled, you can navigate between UI elements via a gamepad, joystick,
    or keyboard. The following navigation events can be used:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Send Navigation Events** 属性可以开启或关闭。当此属性启用时，你可以通过游戏手柄、摇杆或键盘在 UI 元素之间导航。以下导航事件可以使用：'
- en: '**Move**: You can select the various UI elements via arrow keys on the keyboard
    or the control stick on a gamepad (or whichever keys/buttons you have designated
    as the movement keys). Movement will start at the UI item designated **First Selected**.
    We will discuss how to specify the order in which UI items are selected using
    movement in [*Chapter 10*](B18327_10.xhtml#_idTextAnchor236).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**: 您可以通过键盘上的箭头键或游戏手柄上的控制杆（或您指定的任何移动键/按钮）选择各种UI元素。移动将从指定的**第一个选择**的UI项目开始。我们将在[*第10章*](B18327_10.xhtml#_idTextAnchor236)中讨论如何使用移动来指定UI项目的选择顺序。'
- en: '**Submit**: Commit to the UI item selected.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交**: 承诺选择UI项目。'
- en: '**Cancel**: Cancel the selection.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消**: 取消选择。'
- en: Drag Threshold
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖动阈值
- en: The **Drag Threshold** property represents the number of pixels a UI object
    can be moved before it is considered being *dragged*. People don’t have perfectly
    steady hands, so when they are trying to click or tap a UI item, their mouse or
    finger may move slightly. This **Drag Threshold** allows the player to move their
    input slightly (or a lot if you make this number high) before the item they are
    selecting is *dragged* rather than *clicked*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**拖动阈值**属性表示UI对象在被视为*拖动*之前可以移动的像素数。人们的手并不完全稳定，所以当他们试图点击或轻触UI项目时，他们的鼠标或手指可能会稍微移动。这个**拖动阈值**允许玩家在所选项目被*拖动*而不是*点击*之前稍微移动他们的输入（如果你将这个数字设置得高，那么移动可能会很多）。'
- en: Input Manager
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入管理器
- en: Before we discuss the next component of the **Event System** Manager, I want
    to discuss the Input Manager. The Input Manager is where you define the axes in
    your game by assigning them to the buttons on your mouse, keyboard, or joystick
    (gamepad). This also allows you to use the axis name when coding to easily reference
    all inputs that you want to perform in an action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论**事件系统**管理器的下一个组件之前，我想讨论输入管理器。输入管理器是您通过将它们分配到鼠标、键盘或游戏手柄（游戏手柄）上的按钮来定义游戏中轴的地方。这也允许您在编码时使用轴名称，以便轻松引用您想要在动作中执行的所有输入。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember, as we discussed in [*Chapter 5*](B18327_05.xhtml#_idTextAnchor072),
    there are actually two systems that will allow you to handle input in your game:
    the Input Manager and the new Input System. This chapter will focus on the Input
    Manager. We will discuss the new Input System in a future chapter.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，正如我们在[*第5章*](B18327_05.xhtml#_idTextAnchor072)中讨论的，实际上有两个系统可以允许您在游戏中处理输入：输入管理器和新的输入系统。本章将重点介绍输入管理器。我们将在未来的章节中讨论新的输入系统。
- en: To open the **Input Manager**, select **Edit** | **Project Settings** | **Input
    Manager**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开**输入管理器**，请选择**编辑** | **项目设置** | **输入管理器**。
- en: 'If you select the arrow next to **Axes**, you will see the default list of
    axes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择**轴**旁边的箭头，您将看到默认的轴列表：
- en: '![Figure 8.3: The Input Manager and all its pre-defined axes](img/B18327_08_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：输入管理器和所有预定义的轴](img/B18327_08_03.jpg)'
- en: 'Figure 8.3: The Input Manager and all its pre-defined axes'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：输入管理器和所有预定义的轴
- en: 'There are 30 total axes by default. Changing the number next to **Size** will
    give you more or less axes. Expanding the individual axes will reveal the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下有30个总轴。更改**大小**旁边的数字将为您提供更多或更少的轴。展开单个轴将显示以下内容：
- en: '![Figure 8.4: The first Horizontal input axis](img/B18327_08_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：第一个水平输入轴](img/B18327_08_04.jpg)'
- en: 'Figure 8.4: The first Horizontal input axis'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：第一个水平输入轴
- en: The word entered in the **Name** slot is what will appear next to the expandable
    arrow. In the preceding screenshot, all the keys that allow for horizontal movement
    have been defined.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在**名称**槽中输入的单词将出现在可展开箭头旁边。在上面的截图中，所有允许水平移动的键都已定义。
- en: Note that the left and right arrows, along with the *A* and *D* keys of a keyboard,
    are defaulted to the **Horizontal** movement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，左箭头和右箭头，以及键盘上的*A*和*D*键，默认为**水平**移动。
- en: There is also a second **Horizontal** axis further down the list. It is configured
    to work with a joystick or a gamepad.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中还有一个第二个**水平**轴。它配置为与游戏手柄一起工作。
- en: '![Figure 8.5: The second Horizontal input axis](img/B18327_08_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：第二个水平输入轴](img/B18327_08_05.jpg)'
- en: 'Figure 8.5: The second Horizontal input axis'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：第二个水平输入轴
- en: As there are two `"``Horizontal"` label.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有两个`"``Horizontal"`标签。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To view a list of the keywords for each keyboard key as well as a description
    for each of the properties of an axis input, visit [https://docs.unity3d.com/Manual/class-InputManager.xhtml](https://docs.unity3d.com/Manual/class-InputManager.xhtml).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个键盘键的关键字列表以及轴输入的每个属性的描述，请访问[https://docs.unity3d.com/Manual/class-InputManager.xhtml](https://docs.unity3d.com/Manual/class-InputManager.xhtml)。
- en: This will allow you to reference all these buttons and joysticks together as
    a group. This is much simpler than having to write code that gets each of the
    individual keyboard keys along the individual joysticks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你将所有这些按钮和摇杆作为一个组来引用。这比编写代码来获取每个单独摇杆上的单独键盘键要简单得多。
- en: You can delete any of these 30 default axes you want by right-clicking on them
    and selecting **Delete** **Array Element**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过右键单击并选择**删除** **数组元素**来删除这些30个默认轴中的任何一个。
- en: However, be careful when you delete them. You need at least one **Submit** axis
    and one **Cancel** axis to be able to use the **Standalone Input Manager** (unless
    you change the **Submit Button** and **Cancel Button** in the **Standalone Input
    Manager**). For more information, refer to the *Standalone Input Manager* section
    of this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你删除它们时要小心。你需要至少一个**提交**轴和一个**取消**轴才能使用**独立输入管理器**（除非你更改**独立输入管理器**中的**提交按钮**和**取消按钮**）。有关更多信息，请参阅本章的**独立输入管理器**部分。
- en: Now that we have explored the Input Manager, we can review the various input
    functions for buttons and key presses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了输入管理器，我们可以回顾按钮和按键的各种输入函数。
- en: Input functions for buttons and key presses
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按键和按键的输入函数
- en: There are quite a few ways to access key and button presses via code. How you
    do this depends on whether you have the key specified as an axis in the **Input
    Manager** and whether you want the key to register once or continuously. I’ll
    discuss a few in this text, but you can find a full list of the functions at [https://docs.unity3d.com/ScriptReference/Input.xhtml](https://docs.unity3d.com/ScriptReference/Input.xhtml).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方法可以通过代码访问按键和按钮的按下。你如何做这取决于你是否在**输入管理器**中将键指定为轴，以及你是否希望键只注册一次或持续注册。我将在本文中讨论几个，但你可以在[https://docs.unity3d.com/ScriptReference/Input.xhtml](https://docs.unity3d.com/ScriptReference/Input.xhtml)找到完整的函数列表。
- en: A script named `KeyPresses.cs` is attached to the `Main Camera` in the `Chapter8`
    example scene we were reviewing earlier in this chapter. The `KeyPresses.cs` script
    contains all the code demonstrated in this section if you’d like to play around
    with key presses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们回顾的`Chapter8`示例场景中，有一个名为`KeyPresses.cs`的脚本附加到了`Main Camera`上。如果你想要尝试按键，`KeyPresses.cs`脚本包含了本节中展示的所有代码。
- en: GetButton
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetButton
- en: If you have a button defined as an axis in the `GetButton()`, `GetButtonDown()`,
    and `GetButtonUp()` to determine when a button has been pressed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将按钮定义为`GetButton()`、`GetButtonDown()`和`GetButtonUp()`中的轴，以确定何时按下按钮。
- en: '`GetButton()` returns `true` while the button is being held, `GetButtonDown()`
    returns `true` only once, on the frame that the button is initially pressed, and
    `GetButtonUp()` returns `true` only once, on the frame that the button is released.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetButton()`在按钮被按下时返回`true`，`GetButtonDown()`只在按钮最初按下的一帧返回`true`，而`GetButtonUp()`只在按钮释放的一帧返回`true`。'
- en: Within each of the functions, you place the axis name from the `Update()` function
    of a script so that they can be triggered at any time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个函数中，你放置从脚本的`Update()`函数中获取的轴名称，这样它们就可以在任何时候被触发。
- en: 'So, for example, if you wanted to check whether the *Enter* key is being pressed,
    since it is assigned to a **Positive Button** for the **Submit** axis, you can
    write the following code to trigger when the *Enter* key is pressed down:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想检查*Enter*键是否被按下，因为它被分配给**提交**轴的**正按钮**，你可以在*Enter*键按下时触发以下代码：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keep in mind that this will not just trigger with the *Enter* key, as the **Submit**
    axis has a few keys assigned to the **Positive Button** and **Alt** **Positive
    Button**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这不仅仅会与*Enter*键触发，因为**提交**轴分配了一些键给**正按钮**和**Alt** **正按钮**。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that if you play the **Chapter8** scene and want to watch
    these button and key presses fire the console log messages, you must first click
    within the **Game View** so that the inputs will register in the game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果你要播放**Chapter8**场景并想观察这些按钮和按键触发控制台日志消息，你必须首先在**游戏视图**内点击，这样输入才会注册到游戏中。
- en: GetAxis
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetAxis
- en: If you’re looking for a function that will trigger continuously without any
    breaks between firing, you want to use `GetAxis()` rather than `GetButton()`.
    `GetButton()` is good for buttons you want to hold down but want a slight pause
    between events firing (think of holding down a fire button, and the gun shoots
    bullets with breaks in between them). `GetAxis()` works better for events involving
    movement because of this continuous frame-rate independent execution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个在触发之间没有任何中断的连续触发的函数，你应该使用`GetAxis()`而不是`GetButton()`。`GetButton()`对于你想要按下但希望在事件触发之间有轻微暂停的按钮很好（想想按下射击按钮，枪在子弹之间有中断地射击）。`GetAxis()`由于这种连续的、帧率无关的执行，更适合涉及移动的事件。
- en: '`GetAxis()` works a bit differently, as it returns a `float` value rather than
    a `bool`, such as `GetButton()`. It is also best suited within an `Update()` function.
    So, for example, you can check whether the horizontal movement is occurring as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAxis()`的工作方式略有不同，因为它返回一个`float`值，而不是像`GetButton()`那样的`bool`值。它也最适合在`Update()`函数中使用。例如，你可以检查水平移动是否发生，如下所示：'
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: GetKey
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetKey
- en: If you want to get a keyboard key press that is not assigned to an axis, you
    can use `GetKey()`, `GetKeyDown()`, or `GetKeyUp()` to reference keyboard keys
    via their `KeyCode`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要获取未分配给轴的键盘按键，你可以使用`GetKey()`、`GetKeyDown()`或`GetKeyUp()`通过它们的`KeyCode`引用键盘按键。
- en: The `GetKey()` functions work pretty similar to the `GetButton()` functions.
    `GetKey()` returns `true` while the key is being held down; `GetKeyDown()` returns
    `true` only once, on the frame that the key is initially pressed; and `GetKeyUp()`
    returns `true` only once, on the frame that the key is released.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetKey()`函数的工作方式与`GetButton()`函数非常相似。`GetKey()`在按键被按下时返回`true`；`GetKeyDown()`只在按键首次按下时返回`true`；`GetKeyUp()`只在按键释放时返回`true`。'
- en: Each key has its own `KeyCode` that needs to be referenced in the parentheses
    of the `GetKey()` functions. You can find a list of all the keyboard `KeyCode`
    values at [https://docs.unity3d.com/ScriptReference/KeyCode.xhtml](https://docs.unity3d.com/ScriptReference/KeyCode.xhtml).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键都有自己的`KeyCode`，需要在`GetKey()`函数的括号中引用。你可以在[https://docs.unity3d.com/ScriptReference/KeyCode.xhtml](https://docs.unity3d.com/ScriptReference/KeyCode.xhtml)找到所有键盘`KeyCode`值的列表。
- en: 'So, for example, if you wanted to check whether the *8* key from the alphanumeric
    keyboard is being pressed, you could write the following code to trigger when
    the *8* key is pressed down:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想检查字母数字键盘上的`*8*`键是否被按下，你可以在按下`*8*`键时触发以下代码：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GetMouseButton
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetMouseButton
- en: 'Just as with `GetButton()` and `GetKey()`, there are three functions for checking
    when a mouse button has been pressed: `GetMouseButton()`, `GetMouseButtonDown()`,
    and `GetMouseButtonUp()`. They return `true` in the same way that the `GetButton()`
    and `GetKey()` functions do.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`GetButton()`和`GetKey()`一样，有三个函数用于检查鼠标按钮是否被按下：`GetMouseButton()`、`GetMouseButtonDown()`和`GetMouseButtonUp()`。它们返回`true`的方式与`GetButton()`和`GetKey()`函数相同。
- en: You’d place these functions within the `Update()` function as well. Within the
    parentheses, you check to see which button is being pressed; `0` represents a
    left-click, `1` represents a right-click, and `2` represents a middle-click.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些函数放在`Update()`函数中。在括号内，你检查哪个按钮被按下；`0`代表左键点击，`1`代表右键点击，`2`代表中间点击。
- en: 'So, for example, if you wanted to check that the middle mouse button was clicked,
    you could write the following code to trigger when the middle mouse button is
    pressed down:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想检查中间鼠标按钮是否被点击，你可以在鼠标按钮按下时触发以下代码：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we’ve reviewed the input function for buttons and key presses, let’s
    review the Input Modules.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了按钮和按键的输入函数，让我们回顾一下输入模块。
- en: Input Modules
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入模块
- en: Input Modules describe how the Event System will handle the inputs to the game
    via the mouse, keyboard, touchscreen, gamepad, and so on. You can think of them
    as the bridge between the hardware and events.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输入模块描述了事件系统如何通过鼠标、键盘、触摸屏、游戏手柄等处理游戏的输入。你可以把它们看作是硬件和事件之间的桥梁。
- en: 'There are three input modules provided by Unity:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了三个输入模块：
- en: Standalone Input Module
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立输入模块
- en: Base Input Module
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础输入模块
- en: Pointer Input Module
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针输入模块
- en: To utilize these input modules, you attach them as components to your `EventSystem`
    GameObject.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些输入模块，你需要将它们作为组件附加到你的`EventSystem`游戏对象上。
- en: You are not restricted to using these three input modules and can create your
    own, so if you have an input device that is not covered by one of those three,
    you’d create your own input module script and then attach it to the Event System.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于使用这三个输入模块，还可以创建自己的模块，所以如果你有一个未被这三个模块覆盖的输入设备，你将创建自己的输入模块脚本，然后将其附加到事件系统。
- en: There is another input module called Touch Input Module, which used to be necessary
    for touchscreen inputs. However, this module has been deprecated and its functionality
    is now lumped into the Standalone Input Module. Since this input module has been
    deprecated, it will not be discussed in this text.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为触摸输入模块的输入模块，曾经是触摸屏输入所必需的。然而，此模块已被弃用，其功能现在被整合到独立输入模块中。由于此输入模块已被弃用，它将不会在本文本中讨论。
- en: Let’s look at the three input modules provided by Unity in depth.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨Unity提供的三个输入模块。
- en: Standalone Input Module
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立输入模块
- en: The **Standalone Input Module** is a pretty robust input module that will work
    with most of your input devices. It works with a mouse, keyboard, touchscreen,
    and gamepad.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**独立输入模块**是一个相当健壮的输入模块，可以与大多数输入设备一起工作。它支持鼠标、键盘、触摸屏和游戏手柄。'
- en: The `EventSystem` GameObject when it is created. However, you can attach the
    **Standalone Input Module** as a component using **Add Component** | **Event**
    | **Standalone Input Module** on the object’s **Inspector**. You could do this
    if you wanted to add a second one, previously deleted it, and want to re-attach
    it, or want to add the **Standalone Input Module** to another GameObject.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`EventSystem`游戏对象时。然而，你可以使用**添加组件** | **事件** | **独立输入模块**在对象的**检查器**上将其作为组件附加。如果你想要添加第二个，之前已经删除了它，并想要重新附加，或者想要将**独立输入模块**添加到另一个游戏对象。
- en: '![Figure 8.6: The Standalone Input Module component](img/B18327_08_06.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：独立输入模块组件](img/B18327_08_06.jpg)'
- en: 'Figure 8.6: The Standalone Input Module component'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：独立输入模块组件
- en: You’ll see that the first four properties of the **Standalone Input Module**
    are **Horizontal Axis**, **Vertical Axis**, **Submit Button**, and **Cancel Button**.
    These properties are the reason I wanted to discuss the Input Manager before discussing
    the Input Modules. The default properties assigned to these slots are **Horizontal**,
    **Vertical**, **Submit**, and **Cancel**. These assignments are referencing the
    axes assignments from the Input Manager.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到**独立输入模块**的前四个属性是**水平轴**、**垂直轴**、**提交按钮**和**取消按钮**。这些属性是我想要在讨论输入模块之前先讨论输入管理器的原因。这些槽位分配的默认属性是**水平**、**垂直**、**提交**和**取消**。这些分配引用了输入管理器的轴分配。
- en: The `10`. This means that there will be a tenth of a second delay after an input
    action before the next input action is registered. The **Repeat Delay** property
    is the amount of time, in seconds, before **Input Actions Per** **Second** occurs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`10`。这意味着在下一个输入动作被注册之前，将有一个十分之一秒的延迟。**重复延迟**属性是在**每秒输入动作数**发生之前的时间，以秒为单位。'
- en: Setting the **Force Module Active** property to true will make this **Standalone
    Input** **Module** active.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Force Module Active**属性设置为true将使此**独立输入****模块**生效。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about the Standalone Input Module at the following locations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置了解更多关于独立输入模块的信息：
- en: '[https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml](mailto:https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml](mailto:https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml)'
- en: '[https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml](https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml](https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml)'
- en: BaseInputModule/PointerInputModule
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BaseInputModule/PointerInputModule
- en: The `BaseInputModule` and `PointerInputModule` are modules that are only accessible
    via code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseInputModule`和`PointerInputModule`是只能通过代码访问的模块。'
- en: If you need to create your own Input Module, you will create it by extending
    from the `BaseInputModule`. You can view a full list of the variables, functions,
    and messages that can be utilized by extending the `BaseInputModule` at [https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要创建自己的输入模块，您将通过从`BaseInputModule`扩展来创建它。您可以在[https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml)查看通过扩展`BaseInputModule`可以利用的变量、函数和消息的完整列表。
- en: The `PointerInputModule` is a `BaseInputModule` that is used by the Standalone
    Input Module described earlier. It can also be used to write custom Input Modules.
    You can view a full list of the variables, functions, and messages that can be
    utilized by extending the `PointerInputModule` at [https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointerInputModule`是一个`BaseInputModule`，它被前面描述的独立输入模块使用。它也可以用来编写自定义输入模块。您可以在[https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml)查看通过扩展`PointerInputModule`可以利用的变量、函数和消息的完整列表。'
- en: Now, let’s look at how we can access multi-touch input on mobile and touchscreen
    devices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何访问移动设备和触摸屏设备上的多点触控输入。
- en: Input for multi-touch
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多点触控输入
- en: Accessing multi-touch is pretty easy. You access touches with `Input.GetTouch(index)`,
    where the index represents the index of the touch, with the first touch occurring
    at index `0`. From there, you can access information pretty much in the same way
    as accessing information about a mouse. You can also find out how many total touches
    are occurring with `Input.touchCount`. See the *Examples* section of this chapter
    for an example of how to access multi-touch input.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 访问多点触控非常简单。您可以使用`Input.GetTouch(index)`访问触摸，其中index代表触摸的索引，第一个触摸发生在索引`0`。从那里，您可以以几乎与访问鼠标信息相同的方式访问信息。您还可以使用`Input.touchCount`找出正在发生的总触摸数。请参阅本章的*示例*部分，了解如何访问多点触控输入的示例。
- en: Mobile devices also have accelerometers and gyroscopes providing input to the
    device. Let’s look at how you can access those inputs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备还具有加速度计和陀螺仪，为设备提供输入。让我们看看您如何访问这些输入。
- en: Input for accelerometer and gyroscope
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速度计和陀螺仪输入
- en: 'You can access data from the device’s accelerometer using the `Vector3 Input.acceleration`
    property. The coordinates of `Input.acceleration` line up with the scene based
    on the rotation of the device, as shown:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Vector3 Input.acceleration`属性从设备的加速度计访问数据。`Input.acceleration`的坐标与基于设备旋转的场景对齐，如下所示：
- en: '![Figure 8.7: The world axes based on screen rotation](img/B18327_08_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：基于屏幕旋转的世界坐标轴](img/B18327_08_07.jpg)'
- en: 'Figure 8.7: The world axes based on screen rotation'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：基于屏幕旋转的世界坐标轴
- en: 'Simple examples of this involve moving an object around a scene when the device
    is moved, using something like the following within an `Update()` function on
    the object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的简单例子包括在设备移动时在场景中移动一个对象，可以在对象的`Update()`函数中使用以下内容：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The gyroscope uses more complicated mathematics to get a more precise movement
    of the screen using the `Gyroscope` class. Remember, the gyroscope is not supported
    on many devices, so it’s best to use the accelerometer when possible.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 陀螺仪使用更复杂的数学来使用`Gyroscope`类获取更精确的屏幕移动。记住，陀螺仪在许多设备上不受支持，因此当可能时最好使用加速度计。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'An example of how to use the gyroscope on an iOS device can be found here:
    [https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml](https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在iOS设备上使用陀螺仪的示例可以在这里找到：[https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml](https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml)。
- en: Now that we’ve reviewed the various input modules, let’s review Event Triggers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了各种输入模块，让我们来回顾一下事件触发器。
- en: Event Trigger
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件触发器
- en: The `onClick` event. However, if you’d like to add an event to an object that
    either isn’t already set up to receive events or you want it to receive different
    events, you can attach an **Event Trigger** component to the GameObject.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick`事件。然而，如果您想向一个尚未设置接收事件的对象或希望它接收不同事件的对象添加事件，您可以将**事件触发器**组件附加到GameObject上。'
- en: You can attach an **Event Trigger** component by selecting **Add Component**
    | **Event** | **Event Trigger**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择**添加组件** | **事件** | **事件触发器**来附加一个**事件触发器**组件。
- en: One caveat of using the **Event Trigger** component is that the object it is
    attached to receives all the events, not just the ones you added. So, even if
    you don’t tell the object what to do with the specified event, it will receive
    that event and acknowledge that the event occurred—it just won’t do anything in
    response. This can slow the performance of your game. If you are worried about
    performance, you will want to write your own script that attaches only the events
    you want to use to your component. The next section, *Event Inputs*, discusses
    how to achieve this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**事件触发器**组件的一个注意事项是，附加到该组件的对象会接收到所有事件，而不仅仅是添加的事件。所以，即使你没有告诉对象如何处理指定的事件，它也会接收到该事件并确认事件已发生——它只是不会做出任何响应。这可能会降低你游戏的表现。如果你担心性能，你将需要编写自己的脚本，只将你想要使用的那些事件附加到组件上。下一节*事件输入*将讨论如何实现这一点。
- en: If you use an **Event Trigger** component on an object other than a UI element,
    the object must also have a collider component, and you must include a raycaster
    on the camera within the scene.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个非UI元素上使用**事件触发器**组件，该对象也必须有一个碰撞器组件，并且你必须在场景中包含摄像机的射线投射器。
- en: Which collider and raycaster you use depends on whether you are working in 2D
    or 3D.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的碰撞器和射线投射器取决于你是否在2D或3D环境中工作。
- en: If you are working in 2D, you can add a 2D collider to the object with **Add
    Component** | **Physics 2D** and then select the appropriate 2D collider from
    within the object’s **Inspector**. You can then add a raycaster to the camera
    by selecting **Add Component** | **Event** | **Physics 2D Raycaster** from within
    the camera’s **Inspector**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在2D环境中工作，你可以通过选择**添加组件** | **物理2D**来为对象添加一个2D碰撞器，然后从对象的**检查器**中选择合适的2D碰撞器。然后，你可以通过在摄像机的**检查器**中选择**添加组件**
    | **事件** | **物理2D射线投射器**来为摄像机添加一个射线投射器。
- en: If you are working in 3D, you can add a 3D collider to the object with **Add
    Component** | **Physics** and then select the appropriate 3D collider from within
    the object’s **Inspector**. You can then add a raycaster to the camera by selecting
    **Add Component** | **Event** | **Physics Raycaster** from within the camera’s
    **Inspector**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在3D环境中工作，你可以通过选择**添加组件** | **物理**来为对象添加一个3D碰撞器，然后从对象的**检查器**中选择合适的3D碰撞器。然后，你可以通过在摄像机的**检查器**中选择**添加组件**
    | **事件** | **物理射线投射器**来为摄像机添加一个射线投射器。
- en: Let’s look at the various event types that the Event Trigger can receive.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看事件触发器可以接收的各种事件类型。
- en: Event types
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件类型
- en: You can tell the object which type of input event you want to receive by selecting
    **Add New** **Event Type**.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择**添加新事件类型**来告诉对象你希望接收哪种类型的输入事件。
- en: Many of these events are tied to the bounding region of the object. The bounding
    region of a UI object is represented by the area of the Rect Transform. For a
    non-UI object, the bounding region is represented by a 2D or 3D collider.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些事件都与对象的边界区域相关。UI对象的边界区域由Rect Transform的面积表示。对于非UI对象，边界区域由2D或3D碰撞器表示。
- en: Pointer events
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针事件
- en: Pointer events can be called by the pointer in a **Standalone Input Module**.
    Remember that a pointer is not exclusively a mouse. The pointer in a **Standalone
    Input Module** can be a mouse, finger touch, or a reticle tied to gamepad movement.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 指针事件可以通过**独立输入模块**中的指针调用。记住，指针不仅仅是鼠标。在**独立输入模块**中的指针可以是鼠标、手指触摸或与游戏手柄移动相关的十字准星。
- en: Two of the event types are related to the position of the pointer in relation
    to the object’s bounding box region. The **PointerEnter** event is called when
    the pointer enters the bounding box of the object and **PointerExit** is called
    when the pointer exits the bound box area.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 两种事件类型与指针相对于对象边界框区域的位置相关。当指针进入对象的边界框时，会调用**PointerEnter**事件，而当指针退出边界框区域时，会调用**PointerExit**。
- en: There are three events related to clicking on the object. The **PointerDown**
    event is called when the pointer is pressed down within the bounding region of
    the object, and **PointerUp** is called when the pointer is released within the
    bounding region of the object. It’s important to note that with **PointerUp**,
    the pointer can be pressed outside of the object, held down, and then released
    inside the object for the **PointerUp** event to trigger. The **PointerClick**
    event is called when the pointer is pressed and then released within the bounding
    region of the object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与点击对象相关的事件有三个。当指针在对象的边界区域内按下时，会调用**PointerDown**事件，而当指针在对象的边界区域内释放时，会调用**PointerUp**。需要注意的是，在**PointerUp**事件中，指针可以在对象外部按下，然后保持按下状态，并在对象内部释放，以触发**PointerUp**事件。当指针在对象的边界区域内按下并释放时，会调用**PointerClick**事件。
- en: Drag and Drop events
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖放事件
- en: When working with the various drag and drop events, it’s important to differentiate
    between the object being dragged and the object on which the dragged object is
    dropped.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理各种拖放事件时，区分被拖动的对象和拖动对象被放置的对象非常重要。
- en: The **InitializePotentialDrag** event is called whenever a drag object is found,
    but before an object is actually being dragged.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当发现拖动对象时，会调用**InitializePotentialDrag**事件，但在实际拖动对象之前。
- en: The **Drag** event is called on the object being dragged when it is being dragged.
    A **Drag** event occurs when a pointer is pressed within the bounding box of an
    object and then moved without releasing. It’s ended by releasing the pointer.
    The **BeginDrag** event is called from the object being dragged when its drag
    begins, and the **EndDrag** event is called when its drag ends.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被拖动时，会调用**Drag**事件。当指针在对象的边界框内按下并移动而不释放时，会发生**Drag**事件。通过释放指针来结束。当拖动开始时，从被拖动的对象中调用**BeginDrag**事件，当拖动结束时，调用**EndDrag**事件。
- en: The **Drop** event is different from the **EndDrag** event. The **EndDrag**
    event is called on the object that was just being dragged. The **Drop** event
    is called by the object on which the dragged object was dropped. Therefore, the
    **Drop** event is called by the object touching the dragged object when the dragged
    object stops dragging. So, if you were making a drag and drop menu, you’d add
    the **Drag** event to the objects you want to drag and the **Drop** event to the
    slots they will be dropped into.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**Drop**事件与**EndDrag**事件不同。**EndDrag**事件是在刚刚被拖动的对象上调用。**Drop**事件是由拖动对象被放置的对象调用的。因此，当拖动对象停止拖动时，**Drop**事件是由接触拖动对象的那个对象调用的。所以，如果您正在制作拖放菜单，您会将**Drag**事件添加到您想要拖动的对象上，并将**Drop**事件添加到它们将被拖放到其中的槽位。'
- en: Selection events
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择事件
- en: The **Select** event is called when the object is considered the selected object
    and **Deselect** is called when the object is no longer considered selected. Each
    of these events only fires once—the moment the object is considered selected or
    deselected. If you want an event that will trigger continuously while the object
    is selected, you can use the **UpdateSelected** event. The **UpdateSelected**
    event is called every frame.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被认为是选中的对象时，会调用**Select**事件，而当对象不再被认为是选中时，会调用**Deselect**。这些事件中的每一个都只触发一次——即对象被认为是选中或取消选中的那一刻。如果您想要一个在对象选中时持续触发的事件，您可以使用**UpdateSelected**事件。**UpdateSelected**事件会每帧调用一次。
- en: Other events
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他事件
- en: Other events are called based on assignments in the Input Manager. Remember
    that you can assign buttons, keys, and such to axes that define movement, submit,
    and cancel. Let’s talk about a few of these events.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其他事件是基于输入管理器中的分配来触发的。请记住，您可以将按钮、键等分配给定义移动、提交和取消的轴。让我们来谈谈这些事件中的几个。
- en: The **Scroll** event is called when the mouse wheel scrolls and the **Move**
    event is called when a movement happens. When the button assigned to the **Submit**
    axis is pressed, the **Submit** event is called and when the button assigned to
    the **Cancel** axis is pressed, the **Cancel** event is called.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标滚轮滚动时，会调用**Scroll**事件，当发生移动时，会调用**Move**事件。当分配给**Submit**轴的按钮被按下时，会调用**Submit**事件，而当分配给**Cancel**轴的按钮被按下时，会调用**Cancel**事件。
- en: Adding an action to the event
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将动作添加到事件中
- en: 'Once you have actually selected an event type, you must specify what will happen
    when that event type triggers. The following screenshot shows the results of selecting
    **Pointer Enter** as an event type:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你实际选择了事件类型，你必须指定当该事件类型触发时会发生什么。以下截图显示了选择**指针进入**作为事件类型的结果：
- en: '![Figure 8.8: The Event Trigger component](img/B18327_08_08.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：事件触发器组件](img/B18327_08_08.jpg)'
- en: 'Figure 8.8: The Event Trigger component'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：事件触发器组件
- en: The preceding screenshot shows that an event type of **Pointer Enter** has been
    selected, but what happens when the pointer enters the object’s bounding area
    is yet to be defined. To define what happens when the event triggers, you must
    select the **+** sign at the bottom-right corner of the event’s box. You can add
    multiple actions when the event triggers by selecting the **+** sign multiple
    times.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示已选择**指针进入**事件类型，但指针进入对象的边界区域时会发生什么尚未定义。要定义事件触发时会发生什么，你必须选择事件框右下角的**+**符号。你可以通过多次选择**+**符号来添加多个在事件触发时执行的操作。
- en: Once an event type has been added to the **Event Trigger** component, it cannot
    be added a second time and will be grayed out in the **Add New Event** **Type**
    list.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将事件类型添加到**事件触发器**组件中，就不能再次添加，并且在**添加新事件类型**列表中将变为灰色。
- en: To remove an event type from the **Event Trigger** component, select the **–**
    sign at the top-right corner of the event type’s box.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要从**事件触发器**组件中移除事件类型，请选择事件类型框右上角的**–**符号。
- en: 'Once the plus sign is selected, the event type should look as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了加号，事件类型应该看起来如下：
- en: '![Figure 8.9: The Event Trigger component with a Pointer Enter event](img/B18327_08_09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9：带有指针进入事件的事件触发器组件](img/B18327_08_09.jpg)'
- en: 'Figure 8.9: The Event Trigger component with a Pointer Enter event'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：带有指针进入事件的事件触发器组件
- en: The first setting on this event is a dropdown menu with the **Runtime Only**
    (by default), **Editor and Runtime**, and **Off** options. This is where we specify
    when the event can be triggered. Setting this to **Off** will make the event never
    trigger. Setting this to **Runtime Only** will have the event trigger when the
    game is being played. Setting this to **Editor and Runtime** will make events
    trigger when the game is being played, but it also accepts the triggers in the
    Editor when the game is not in play mode. Most of the time, **Runtime Only** is
    sufficient for what you will be doing and hence it is the default.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件的第一项设置是一个下拉菜单，包含**仅运行时**（默认）、**编辑器和运行时**和**关闭**选项。这是我们指定事件何时可以触发的地方。将此设置为**关闭**将使事件永远不会触发。将此设置为**仅运行时**将在游戏正在播放时触发事件。将此设置为**编辑器和运行时**将使事件在游戏正在播放时触发，但它也接受在游戏不在播放模式时在编辑器中的触发。大多数情况下，**仅运行时**对于你要做的事情就足够了，因此它是默认设置。
- en: Below that dropdown menu is a slot with **None (Object)** in it. You are to
    drag from the Hierarchy whichever item the function you want to run is attached
    to into this slot. Once that is assigned, a list of all the available components
    and scripts attached to that object will display in the second dropdown menu.
    You can drag and drop the object the **Event Trigger** is attached to in this
    slot and are not restricted to only using other objects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单下方有一个槽位，里面写着**无（对象）**。你需要从层次结构中拖动你想要运行的功能所附加的任何项目到这个槽位。一旦分配完成，所有附加到该对象的可用组件和脚本的列表将在第二个下拉菜单中显示。你可以将此槽位中附加的**事件触发器**对象拖动并放下，并且不限于只使用其他对象。
- en: The following screenshot shows an `Image` GameObject with an `foodSpriteSheet_1`
    sprite when the pointer enters its **Rect Transform**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个当指针进入其**矩形变换**时带有`foodSpriteSheet_1`精灵的`Image`游戏对象。
- en: '![Figure 8.10: The Event Trigger component with a Pointer Enter event that
    swaps a sprite](img/B18327_08_10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10：带有交换精灵的指针进入事件的事件触发器组件](img/B18327_08_10.jpg)'
- en: 'Figure 8.10: The Event Trigger component with a Pointer Enter event that swaps
    a sprite'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：带有交换精灵的指针进入事件的事件触发器组件
- en: To see this `Chapter8` scene. Hover your mouse over the image. It will initially
    look like a potion bottle but will change to a triangle when your mouse hovers
    over it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此`Chapter8`场景，将鼠标悬停在图像上。它最初看起来像一瓶药水，但当你的鼠标悬停在其上时，会变成三角形。
- en: You can also run functions within scripts attached to objects. For example,
    the next screenshot shows the same image but now with a `Main Camera` has a script
    attached to it called `HelloWorld.cs` with a function called `HeyThere()`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在附加到对象的脚本中运行函数。例如，下一张截图显示了相同的图像，但现在 `Main Camera` 附加了一个名为 `HelloWorld.cs`
    的脚本，其中包含一个名为 `HeyThere()` 的函数。
- en: '![Figure 8.11: The Event Trigger component with Pointer Click event that triggers
    a method](img/B18327_08_11.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11：具有触发方法的指针点击事件的 Event Trigger 组件](img/B18327_08_11.jpg)'
- en: 'Figure 8.11: The Event Trigger component with Pointer Click event that triggers
    a method'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11：具有触发方法的指针点击事件的 Event Trigger 组件
- en: The `HeyThere()` function simply prints `Hello world! This is main camera speaking!`
    in the **Console** whenever the image to the right is clicked.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeyThere()` 函数简单地在 **控制台** 中打印 `Hello world! This is main camera speaking!`，每当点击右侧的图像时。'
- en: To run a function from the **Event Trigger** component, it must be public, have
    a return type of void, and have no more than one parameter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 **事件触发** 组件中运行一个函数，它必须是公共的，返回类型为 void，并且参数不超过一个。
- en: Now, let’s review how we can write code that performs similarly to the Event
    Trigger component through the use of event inputs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下如何通过使用事件输入来编写与事件触发组件功能相似的代码。
- en: Event inputs
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件输入
- en: As stated in the *Event Trigger* section, you may not want to use an **Event
    Trigger** component because the **Event Trigger** component causes the object
    on which it is attached to receive all the events listed in the *Event Trigger*
    section. So, if you are worried about performance issues, you will want an alternate
    way to receive events on an object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *事件触发* 部分所述，你可能不想使用 **事件触发** 组件，因为 **事件触发** 组件会导致它附加的对象接收 *事件触发* 部分中列出的所有事件。因此，如果你担心性能问题，你将希望有另一种方式在对象上接收事件。
- en: All event types that were available to add in the *Event Trigger* section can
    also be added to an object via code without using the **Event Trigger** component.
    To use an event without the **Event Trigger** component, you must derive your
    script from the appropriate interface and know the type of event data class that
    the event uses.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *事件触发* 部分中可用的所有事件类型也可以通过代码添加到对象中，而无需使用 **事件触发** 组件。要使用没有 **事件触发** 组件的事件，你必须从适当的接口派生你的脚本，并知道事件使用的事件数据类类型。
- en: An **interface** is a template that defines all the required functionality that
    a class can implement. So, by using an interface, you can then use any of the
    methods or functions that have been defined within that interface. I’ll show you
    some examples of how to do this, but first, let’s look at the available events
    and their required interfaces.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口** 是一个模板，它定义了一个类可以实现的全部所需功能。因此，通过使用接口，你可以使用该接口中定义的任何方法或函数。我将向你展示一些如何做到这一点的示例，但首先，让我们看看可用的事件及其所需的接口。'
- en: 'There are three classes that the event data can be derived from, which are
    `PointerEventData`, `AxisEventData`, and `BaseEventData`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 事件数据可以派生自三个类，它们是 `PointerEventData`、`AxisEventData` 和 `BaseEventData`：
- en: '`PointerEventData` is the class that contains events associated with the pointer'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointerEventData` 是包含与指针相关事件的类'
- en: '`AxisEventData` contains events associated with the keyboard and gamepad'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AxisEventData` 包含与键盘和游戏手柄相关的事件'
- en: '`BaseEventData` contains events that are used by all event types'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseEventData` 包含所有事件类型使用的的事件'
- en: There is a fourth event data class, `AbstractEventData`. It is the class from
    which the other three inherit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个第四个事件数据类，`AbstractEventData`。它是其他三个类继承的类。
- en: 'The list of events available for a `StandaloneInputModule` along with their
    required interfaces and event data class are provided in the following chart.
    The events are listed in the same order they are listed within the Event Trigger
    component for continuity purposes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图表中提供了 `StandaloneInputModule` 可用的事件列表及其所需的接口和事件数据类。为了保持一致性，事件按照在事件触发组件中列出的顺序列出：
- en: '| **Event** | **Interface** | **Event** **Data Type** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **事件** | **接口** | **事件数据类型** |'
- en: '| --- | --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `OnPointerEnter` | `IPointerEnterHandler` | `PointerEventData` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `OnPointerEnter` | `IPointerEnterHandler` | `PointerEventData` |'
- en: '| `OnPointerExit` | `IPointerExitHandler` | `PointerEventData` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `OnPointerExit` | `IPointerExitHandler` | `PointerEventData` |'
- en: '| `OnPointerDown` | `IPointerDownHandler` | `PointerEventData` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `OnPointerDown` | `IPointerDownHandler` | `PointerEventData` |'
- en: '| `OnPointerUp` | `IPointerUpHandler` | `PointerEventData` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `OnPointerUp` | `IPointerUpHandler` | `PointerEventData` |'
- en: '| `OnPointerClick` | `IPointerClickHandler` | `PointerEventData` |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `OnPointerClick` | `IPointerClickHandler` | `PointerEventData` |'
- en: '| `OnDrag` | `IdragHandler` | `PointerEventData` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `OnDrag` | `IdragHandler` | `PointerEventData` |'
- en: '| `OnDrop` | `IdropHandler` | `PointerEventData` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `OnDrop` | `IdropHandler` | `PointerEventData` |'
- en: '| `OnScroll` | `IscrollHandler` | `PointerEventData` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `OnScroll` | `IscrollHandler` | `PointerEventData` |'
- en: '| `OnUpdateSelected` | `IUpdateSelectedHandler` | `BaseEventData` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `OnUpdateSelected` | `IUpdateSelectedHandler` | `BaseEventData` |'
- en: '| `OnSelect` | `IselectHandler` | `BaseEventData` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `OnSelect` | `IselectHandler` | `BaseEventData` |'
- en: '| `OnDeselect` | `IdeselectHandler` | `BaseEventData` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `OnDeselect` | `IdeselectHandler` | `BaseEventData` |'
- en: '| `OnMove` | `IMoveHandler` | `AxisEventData` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `OnMove` | `IMoveHandler` | `AxisEventData` |'
- en: '| `OnInitializePotentialDrag` | `IInitializePotentialDragHandler` | `PointerEventData`
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `OnInitializePotentialDrag` | `IInitializePotentialDragHandler` | `PointerEventData`
    |'
- en: '| `OnBeginDrag` | `IbeginDragHandler` | `PointerEventData` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `OnBeginDrag` | `IbeginDragHandler` | `PointerEventData` |'
- en: '| `OnEndDrag` | `IEndDragHandler` | `PointerEventData` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `OnEndDrag` | `IEndDragHandler` | `PointerEventData` |'
- en: '| `OnSubmit` | `ISubmitHandler` | `BaseEventData` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `OnSubmit` | `ISubmitHandler` | `BaseEventData` |'
- en: '| `OnCancel` | `ICancelHandler` | `BaseEventData` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `OnCancel` | `ICancelHandler` | `BaseEventData` |'
- en: 'Table 8.1: Interfaces and event data types for the various events'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1：各种事件的接口和事件数据类型
- en: 'To write a class with one of these events, you will use the following template:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写具有这些事件之一的类，您将使用以下模板：
- en: '[PRE7]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The items highlighted in the preceding code will be replaced by the items within
    the preceding table.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中突出显示的项目将被上一表中相应的项目替换。
- en: 'For example, if you wanted to implement an `OnPointerEnter` event, the code
    would look as follows after the highlighted code has been replaced with an appropriate
    event, interface, and event data type:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想实现一个 `OnPointerEnter` 事件，在将高亮代码替换为适当的事件、接口和事件数据类型后，代码将如下所示：
- en: '[PRE8]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You must include the `UnityEngine.EventSystems` namespace to write code with
    event data. The `UnityEngine.UI` namespace is optional and is only required if
    you will also be writing your events for UI objects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须包含 `UnityEngine.EventSystems` 命名空间才能编写具有事件数据的代码。`UnityEngine.UI` 命名空间是可选的，并且仅在您还将为
    UI 对象编写事件时才需要。
- en: Now that we’ve reviewed various ways to send and receive events, let’s look
    at raycasters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了发送和接收事件的各种方法，让我们来看看射线发射器。
- en: Raycasters
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射线发射器
- en: Remember that the Event System keeps track of raycasting along with all the
    other things we have discussed. Raycasting is used to determine which UI elements
    are being interacted with by projecting a ray from the user’s pointer into the
    scene. This ray is considered to originate at the camera’s plane and then proceed
    forward through the scene. Whatever this ray hits receives an interaction. You
    can have the ray continue through the first UI element it hits or stop at the
    first UI element it hits. To get a ray to stop at the first UI element it hits,
    the object must block raycasting. This will stop items behind it from being interacted
    with. Next, we’ll discuss the types of raycasters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，事件系统会跟踪射线投射以及我们讨论的所有其他事情。射线投射用于确定哪些 UI 元素正在与用户指针交互，通过从用户指针向场景投射一条射线来实现。这条射线被认为起源于摄像机的平面，然后向前穿过场景。射线击中的任何东西都会收到交互。您可以让射线继续穿过它击中的第一个
    UI 元素，或者停止在它击中的第一个 UI 元素处。要让射线在击中的第一个 UI 元素处停止，该对象必须阻止射线投射。这将阻止其后面的项目被交互。接下来，我们将讨论射线发射器的类型。
- en: Graphic Raycaster
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形射线发射器
- en: When a Canvas is added to the scene, it is automatically given a **Graphic**
    **Raycaster** component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Canvas 被添加到场景中时，它将自动获得一个 **图形** **射线发射器** 组件。
- en: 'This is the raycasting system that will allow you to interact with all UI objects
    that are children of that Canvas. It has three properties: **Ignore Reversed Graphics**,
    **Blocking Objects**, and **Blocking Mask**.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是允许您与该 Canvas 的所有子 UI 对象交互的射线投射系统。它有三个属性：**忽略反转图形**、**阻挡对象**和**阻挡遮罩**。
- en: The **Ignore Reversed Graphics** toggle determines whether or not graphical
    objects within the Canvas can be interacted with if they are facing backward (in
    relation to the raycaster). The **Blocking Objects** and **Blocking Mask** properties
    allow you to assign the types of objects that are in front of the Canvas (between
    the camera and the Canvas) that can block raycasting to the Canvas.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**忽略反转图形** 开关确定如果图形对象面向后（相对于射线发射器），Canvas 内的图形对象是否可以交互。**阻挡对象**和**阻挡遮罩**属性允许您分配位于
    Canvas 前面的对象类型（在摄像机和 Canvas 之间），这些对象可以阻止射线投射到 Canvas 上。'
- en: Other Raycasters
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他射线发射器
- en: As stated earlier, if you want to use the Event System with a non-UI object,
    you must attach a Raycaster component to a camera within the scene. You can add
    either a **Physics 2D Raycaster** or a **Physics Raycaster** (or both) to your
    camera based on whether you are using 2D or 3D.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你想在一个非UI对象上使用事件系统，你必须将射线投射器组件附加到场景中的相机上。根据你是否使用2D或3D，你可以向你的相机添加**物理2D射线投射器**或**物理射线投射器**（或两者都添加）。
- en: From within the camera’s inspector, you can add the **Physics 2D Raycaster**
    by selecting **Add Component** | **Event** | **Physics 2D Raycaster** and the
    **Physics Raycaster** by selecting **Add Component** | **Event** | **Physics Raycaster**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在相机的检查器中，你可以通过选择**添加组件** | **事件** | **物理2D射线投射器**来添加**物理2D射线投射器**，通过选择**添加组件**
    | **事件** | **物理射线投射器**来添加**物理射线投射器**。
- en: 'The two components appear as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件如下所示：
- en: '![Figure 8.12: The two types of Physics Raycasters](img/B18327_08_12.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12：两种物理射线投射器类型](img/B18327_08_12.jpg)'
- en: 'Figure 8.12: The two types of Physics Raycasters'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：两种物理射线投射器类型
- en: The **Event Mask** property determines which types of objects can receive raycasting.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件掩码**属性决定了哪些类型的对象可以接收射线投射。'
- en: If you attempt to add either of these components to a non-camera GameObject,
    a **Camera** component will automatically be attached to the GameObject as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将这两个组件添加到非相机GameObject中，系统会自动将**相机**组件附加到GameObject上。
- en: Now that we’ve reviewed the various systems that we can use to program interactions
    for our UI, let’s look at some examples.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了我们可以用来为我们的UI编程交互的各种系统，让我们看看一些示例。
- en: Examples
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: We will continue to work on the UI we have been building for the last two chapters.
    To help organize the project, duplicate the `Chapter7` scene that you created
    in the last chapter; it will automatically be named `Chapter8`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建我们在过去两章中构建的UI。为了帮助组织项目，复制你在上一章中创建的`Chapter7`场景；它将自动命名为`Chapter8`。
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you did not work through the examples for [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085),
    and [*Chapter 7*](B18327_07.xhtml#_idTextAnchor106), but would like to work through
    the examples in this chapter, you can import the package labeled **Chapter 08**
    **– Examples 1 - Start**. You can also view the completed examples in the **Chapter
    08** **– Examples 1 –** **End** package.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完成[*第6章*](B18327_06.xhtml#_idTextAnchor085)和[*第7章*](B18327_07.xhtml#_idTextAnchor106)的示例，但想在本章中完成示例，你可以导入标记为**第08章
    – 示例1 - 开始**的包。你还可以在**第08章 – 示例1 – 结束**包中查看完成的示例。
- en: Showing and hiding pop-up menus with keypress
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用按键显示和隐藏弹出菜单
- en: 'So far, we have made two Panels that we plan on turning into popups: the `Pause
    Panel` from [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), and the `Inventory
    Panel` from [*Chapter 7*](B18327_07.xhtml#_idTextAnchor106). Right now, they are
    both visible in the scene (even though `Pause Panel` is hidden behind the `Inventory
    Panel`). We want them to pop up when we press *P* and *I* on the keyboard. For
    demonstration purposes, we’ll access the keyboard keys differently for each Panel.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了两个计划将其转换为弹出窗口的面板：来自[*第6章*](B18327_06.xhtml#_idTextAnchor085)的`暂停面板`和来自[*第7章*](B18327_07.xhtml#_idTextAnchor106)的`库存面板`。目前，它们都在场景中可见（尽管`暂停面板`被`库存面板`遮挡）。我们希望当我们在键盘上按下*P*和*I*键时，它们能够弹出。为了演示目的，我们将为每个面板使用不同的键盘键访问方式。
- en: Remember that both of these Panels have Canvas Group components on them. These
    components will allow us to easily access the Panels’ alpha, intractable, and
    blocks raycasts properties.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这两个面板上都有Canvas Group组件。这些组件将允许我们轻松访问面板的alpha、不可交互和阻挡射线投射属性。
- en: Using KeyCode with the Inventory Panel
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用KeyCode与库存面板
- en: 'Let’s begin with the `Inventory Panel`. We want the Panel to pop up and close
    when the *I* key is pressed on the keyboard. To make the `Inventory Panel` appear
    and disappear with the *I* key, complete the following steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`库存面板`开始。我们希望当按下键盘上的*I*键时，面板能够弹出和关闭。为了使`库存面板`通过*I*键显示和隐藏，请完成以下步骤：
- en: Create a new C# script in the `Assets/Scripts` folder by right-clicking within
    the **Project** view of the folder and selecting **Create** | **C# Script** from
    the pop-up Panel.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中创建一个新的C#脚本，通过在文件夹的**项目**视图中右键单击并从弹出面板中选择**创建** | **C#脚本**来完成。
- en: Name the script `ShowHidePanels.cs`, and then double-click on it to open.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本命名为`ShowHidePanels.cs`，然后双击它以打开。
- en: 'Now, let’s use a `public CanvasGroup` variable called `inventoryPanel` to represent
    the Panel. We use a `CanvasGroup` variable type to reference the Panel since we
    want to access the properties of the `ShowHidePanels` script to include the following
    highlighted line of code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个名为 `inventoryPanel` 的 `public CanvasGroup` 变量来表示面板。我们使用 `CanvasGroup`
    变量类型来引用面板，因为我们想访问 `ShowHidePanels` 脚本的属性，包括以下高亮显示的代码行：
- en: '[PRE9]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `CanvasGroup` variable type, even though it is used with UI elements, is
    not in the `UnityEngine.UI` namespace, but the `UnityEngine` namespace, so we
    do not need to include the `UnityEngine.UI` namespace in our script at the moment.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管与 UI 元素一起使用，`CanvasGroup` 变量类型并不在 `UnityEngine.UI` 命名空间中，而是在 `UnityEngine`
    命名空间中，因此我们目前不需要在我们的脚本中包含 `UnityEngine.UI` 命名空间。
- en: 'Let’s create another variable that will keep track of whether or not the `Inventory
    Panel` is visible. Add the following code to the next line of the script to initialize
    the variable:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个变量来跟踪 `Inventory Panel` 是否可见。将以下代码添加到脚本的下一条语句中，以初始化该变量：
- en: '[PRE10]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will be toggling the Panels on and off by adjusting their `alpha`, `interactable`,
    and `blocksRaycasts` properties. When the Panel is hidden, it should also not
    accept interactions or block raycasts. So, let’s create a method that we can call
    to perform the toggle. Add the following namespace to your script:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过调整它们的 `alpha`、`interactable` 和 `blocksRaycasts` 属性来切换面板的开启和关闭。当面板被隐藏时，它也不应接受交互或阻挡射线。因此，让我们创建一个我们可以调用的方法来执行切换。将以下命名空间添加到您的脚本中：
- en: '[PRE11]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following method to your script:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下方法添加到您的脚本中：
- en: '[PRE12]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the method has two parameters. The first parameter is a `CanvasGroup`
    called `Panel` and the second parameter is a Boolean called `show`. It will set
    the `alpha` property to `0` when `show` is `false` and `1` when `show` is `true`.
    It will also set the `interactable` and `blocksRaycasts` properties to `false`
    when `show` is `false` and `true` when `show` is `true`.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，该方法有两个参数。第一个参数是一个名为 `Panel` 的 `CanvasGroup`，第二个参数是一个名为 `show` 的布尔值。当 `show`
    为 `false` 时，它将 `alpha` 属性设置为 `0`，当 `show` 为 `true` 时，设置为 `1`。它还将 `interactable`
    和 `blocksRaycasts` 属性在 `show` 为 `false` 时设置为 `false`，在 `show` 为 `true` 时设置为 `true`。
- en: 'We want `Inventory Panel` to be hidden when the scene starts playing. So, update
    the `Start()` function to include the following code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望当场景开始播放时，`Inventory Panel` 被隐藏。因此，更新 `Start()` 函数以包含以下代码：
- en: '[PRE13]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we need to write code that triggers whenever the *I* key on the keyboard
    is pressed down. We will use the `Input.GetKeyDown()` function in a way that the
    function is called the moment the key is pressed down. We will also use `KeyCode.I`
    to reference the *I* key on the keyboard. Add the following code to your `Update`
    function to check whether the *I* key is pressed down:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要编写代码，以便在按下键盘上的 *I* 键时触发。我们将以 `Input.GetKeyDown()` 函数的方式调用该函数，使其在键按下时立即被调用。我们还将使用
    `KeyCode.I` 来引用键盘上的 *I* 键。将以下代码添加到您的 `Update` 函数中，以检查 *I* 键是否被按下：
- en: '[PRE14]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We want this key to disable and enable the Panel, so we will change the value
    of `inventoryUp` to whatever the opposite of its current value is. That is, if
    it is `true`, we will set it to `false`, if it is `false`, we will set it to `true`.
    Then, we will call the `TogglePanel()` method.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个键可以禁用和启用面板，因此我们将 `inventoryUp` 的值更改为其当前值的相反。也就是说，如果它是 `true`，我们将将其设置为
    `false`，如果它是 `false`，我们将将其设置为 `true`。然后，我们将调用 `TogglePanel()` 方法。
- en: 'Add the following highlighted code to your `Update()` function:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下高亮显示的代码添加到您的 `Update()` 函数中：
- en: '[PRE15]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, for this code to work, we need to attach it to a GameObject within our
    scene. It really doesn’t matter what GameObject we attach it to, since we used
    a public variable to access our `Inventory Panel`, we can assign that via the
    Inspector. However, since we are planning on using this script to affect both
    Panels, I want to add it to `Main Camera`. Drag and drop the `ShowHidePanels`
    script into the `Main Camera`. You should now see the following as a component
    on your `Main Camera`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使此代码正常工作，我们需要将其附加到场景中的某个 GameObject 上。实际上，我们附加到哪个 GameObject 上并不重要，因为我们使用了一个公共变量来访问我们的
    `Inventory Panel`，我们可以通过检查器进行分配。然而，由于我们计划使用此脚本影响两个面板，我想将其添加到 `Main Camera` 上。将
    `ShowHidePanels` 脚本拖放到 `Main Camera` 上。您现在应该看到以下内容作为 `Main Camera` 上的组件：
- en: '![Figure 8.13: The ShowHidePanel.cs script component](img/B18327_08_13.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13：ShowHidePanel.cs 脚本组件](img/B18327_08_13.jpg)'
- en: 'Figure 8.13: The ShowHidePanel.cs script component'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13：ShowHidePanel.cs 脚本组件
- en: 'Now, we need to assign the `Inventory Panel` GameObject to the slot labeled
    **Inventory Panel**. Drag and drop the **Inventory Panel** from the Hierarchy
    into this slot:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将`库存面板`GameObject分配给标记为**库存面板**的槽位。从层次结构中拖放**库存面板**到这个槽位：
- en: '![Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component](img/B18327_08_14.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14：添加库存面板ShowHidePanel.cs脚本组件](img/B18327_08_14.jpg)'
- en: 'Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：添加库存面板ShowHidePanel.cs脚本组件
- en: Play the game to ensure that the code is working correctly. You should see the
    inventory Panel start out invisible and then turn on and off as you press the
    *I* key on the keyboard.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放游戏以确保代码正确无误。你应该看到库存面板一开始是不可见的，然后按键盘上的*I*键时开启和关闭。
- en: Now that we’ve completed the work needed to show and hide the `Inventory Panel`,
    we can move on to the `Pause Panel`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了显示和隐藏`库存面板`所需的工作，我们可以继续到`暂停面板`。
- en: Using Input Manager with the Pause Panel
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有暂停面板的输入管理器
- en: Now, let’s do the same thing for the `Pause Panel`. We’ll do this slightly differently
    than the `Inventory Panel`. To make sure that you can see how to access a key
    with the Input Manager, we’ll use the Input Manager instead of a `KeyCode`. We
    also need to actually pause the game.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`暂停面板`做同样的事情。我们将与`库存面板`略有不同。为了确保你可以看到如何使用输入管理器访问一个键，我们将使用输入管理器而不是`KeyCode`。我们还需要实际暂停游戏。
- en: 'To display the `Pause Panel` using the *P* key and pause the game, complete
    the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用*P*键显示`暂停面板`并暂停游戏，完成以下步骤：
- en: First, we need to set up the Input Manager to include a `Pause` axis. Open the
    Input Manager with **Edit** | **Project Settings** | **Input Manager** and expand
    the axes by selecting the arrow next to the word **Axes**.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要设置输入管理器以包含一个`暂停`轴。通过**编辑** | **项目设置** | **输入管理器**打开输入管理器，并选择**轴**旁边的箭头以展开轴。
- en: 'By default, your project has 30 axes. You can replace one of these with the
    new `Pause` axis if you aren’t planning on using them, but we might as well just
    go ahead and make a new one. Definitely don’t delete the `31`. This will duplicate
    the last axis in the list, **Debug Horizontal**, as shown in the following screenshot:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，你的项目有30个轴。如果你不打算使用它们，可以用新的`暂停`轴替换其中的一个，但我们可以直接创建一个新的。绝对不要删除`31`。这将复制列表中的最后一个轴，即**调试水平**，如下面的截图所示：
- en: '![Figure 8.15: The Input Manager with an extra axis](img/B18327_08_15.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15：带有额外轴的输入管理器](img/B18327_08_15.jpg)'
- en: 'Figure 8.15: The Input Manager with an extra axis'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：带有额外轴的输入管理器
- en: 'Change the second `Debug Horizontal` axis to a `Pause` axis by changing the
    `Pause`, the `p`, and changing the rest of the properties to the following:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个`调试水平`轴更改为`暂停`轴，通过更改`暂停`，`p`，并将其余属性更改为以下内容：
- en: '![Figure 8.16: The Pause axis added to the Input Manager](img/B18327_08_16.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图8.16：添加到输入管理器的暂停轴](img/B18327_08_16.jpg)'
- en: 'Figure 8.16: The Pause axis added to the Input Manager'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：添加到输入管理器的暂停轴
- en: 'Now that we have our `Pause` axis set up, we can start writing our code. Let’s
    define some variables to use with the `Pause Panel` similar to the way we defined
    variables for `Inventory Panel`. Add the following variable definitions at the
    top of your class under your previous variable definitions:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了`暂停`轴，我们可以开始编写代码。让我们定义一些变量来与`暂停面板`一起使用，类似于我们为`库存面板`定义变量的方式。在类中你的上一个变量定义下方添加以下变量定义：
- en: '[PRE16]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following to the `Start()` function and make the `Pause Panel` invisible
    at start:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`函数中添加以下内容，使`暂停面板`在开始时不可见：
- en: '[PRE17]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we added the `Pause` axis to our Input Manager, we can use `Input.GetButtonDown()`
    instead of `Input.GetKeyDown()`, like we did with `Inventory Panel`. We want to
    use `GetButtonDown()` rather than `GetAxis()` because we want a function that
    will return `true` once, not continuously. If it returned continuously (using
    `GetAxis()`), the Panel would flicker in and out while the *P* key was being pressed.
    Add the following code at the end of your `Update()` function. Note that it’s
    very similar to the code we used for Inventory Panel:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们向输入管理器添加了`暂停`轴，我们可以使用`Input.GetButtonDown()`而不是`Input.GetKeyDown()`，就像我们使用`库存面板`时做的那样。我们想使用`GetButtonDown()`而不是`GetAxis()`，因为我们想要一个一次返回`true`而不是持续返回的函数。如果它持续返回（使用`GetAxis()`），当按下*P*键时，面板会在开启和关闭之间闪烁。在`Update()`函数的末尾添加以下代码。注意，它与用于库存面板的代码非常相似：
- en: '[PRE18]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we’ve added new public variables to our script, it should be showing
    up in the `Main Camera`. Drag and drop the `Pause Panel` from the Hierarchy to
    the **Pause** **Panel** slot.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在我们脚本中添加了新的公共变量，它应该会显示在 `Main Camera` 中。将 `Pause Panel` 从层级拖放到 **Pause**
    **Panel** 插槽。
- en: '![Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added](img/B18327_08_17.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17：添加了 Pause Panel 的 ShowHidePanel.cs 脚本组件](img/B18327_08_17.jpg)'
- en: 'Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17：添加了 Pause Panel 的 ShowHidePanel.cs 脚本组件
- en: Now, play the game and watch the `Pause Panel` become visible and invisible
    when you press the *P* key on the keyboard.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，玩游戏并观察当你按下键盘上的 *P* 键时，`Pause Panel` 如何变得可见和不可见。
- en: Next, we’ll learn about pausing the game.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何暂停游戏。
- en: Pausing the game
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: The game doesn’t actually pause right now. If we had animations or events running
    in the scene, they would continue to run even with the `Pause Panel` up. A really
    easy way to pause a game is to manipulate the time scale of the game. If the time
    scale is set to `1`, time will run as it normally does. If the time scale is set
    to `0`, the time within the game will pause.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 目前游戏实际上并没有暂停。如果我们场景中有动画或事件正在运行，即使 `Pause Panel` 打开，它们也会继续运行。暂停游戏的一个非常简单的方法是操作游戏的时间尺度。如果时间尺度设置为
    `1`，时间将像平常一样运行。如果时间尺度设置为 `0`，游戏中的时间将暂停。
- en: Also, our current setup doesn’t quite work as a pause menu would be expected
    to. `Inventory Panel` and `Pause Panel` can be displayed at the same time. If
    `Inventory Panel` is up, the `Pause Panel` is covered up by it since it is rendering
    behind it. Also, the `Inventory Panel` can be activated when the game is *paused*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们当前的设置并不完全符合预期的暂停菜单。`Inventory Panel` 和 `Pause Panel` 可以同时显示。如果 `Inventory
    Panel` 打开，由于它渲染在后面，`Pause Panel` 会被它覆盖。此外，当游戏处于暂停状态时，可以激活 `Inventory Panel`。
- en: 'We’ll need to pause the time scale of our game, change the order that our Panels
    render, and disable functionality when the game is paused to have a `Pause Panel`
    that functions properly. To create a properly functioning `Pause Panel`, complete
    the following steps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `Pause Panel` 正确工作，我们需要暂停游戏的时间尺度、改变我们的 Panels 渲染的顺序，并在游戏暂停时禁用功能。要创建一个正常工作的
    `Pause Panel`，请完成以下步骤：
- en: 'Add the following to the `Update()` function to the `ShowHidePanels` script
    to pause the time in the game:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `ShowHidePanels` 脚本的 `Update()` 函数中，以暂停游戏中的时间：
- en: '[PRE19]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s deal with the fact that `Pause Panel` is behind the `Inventory Panel`.
    This is an easy fix. Simply change their order in the Hierarchy by dragging the
    `Pause Panel` below the `Inventory Panel`. The items that are listed lower in
    the Hierarchy render on top of the ones listed above it within the scene. Now,
    the `Pause Panel` will be above the `Inventory Panel` in the scene:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们处理这样一个事实：`Pause Panel` 在 `Inventory Panel` 的后面。这是一个简单的修复。只需通过拖动 `Pause
    Panel` 到 `Inventory Panel` 下方来改变它们在层级中的顺序。在层级中列出的较低项目将在场景中渲染在列出的较高项目之上。现在，`Pause
    Panel` 将在场景中位于 `Inventory Panel` 之上：
- en: '![Figure 8.18: The children of the Popup Canvas](img/B18327_08_18.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18：Popup Canvas 的子项](img/B18327_08_18.jpg)'
- en: 'Figure 8.18: The children of the Popup Canvas'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18：Popup Canvas 的子项
- en: 'The only thing left to do is to disable the ability of the `Inventory Panel`
    to appear and disappear if the `Pause Panel` is up. Adjust the `if` statement
    that checks for the *I* key being pressed to also check whether `pauseUp` is false,
    like so:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是禁用 `Inventory Panel` 在 `Pause Panel` 打开时出现和消失的能力。调整检查 *I* 键是否被按下的 `if`
    语句，同时检查 `pauseUp` 是否为 `false`，如下所示：
- en: '[PRE20]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s important to remember that when you have a `Pause Panel`, other events
    need to be turned off. Setting the timescale to `0` does not stop the ability
    for other events to occur; it only really stops animations and any clocks you
    may have displayed that use the time scale. So, we will need to ensure that any
    other event we program is turned off when the game is paused.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，当你有一个 `Pause Panel` 时，其他事件需要被关闭。将时间尺度设置为 `0` 并不会停止其他事件发生的可能性；它实际上只会停止动画和任何使用时间尺度的时钟。因此，我们需要确保我们在游戏暂停时关闭任何其他我们编程的事件。
- en: Dragging and dropping inventory items
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拖放库存物品
- en: We have an `Inventory Panel` that can be displayed and hidden and a HUD inventory.
    I want to be able to drag objects from my larger `Inventory Panel` to my smaller
    HUD inventory called `Bottom Right Panel` that we created in the previous chapter.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个可以显示和隐藏的`库存面板`和一个HUD库存。我希望能够将对象从我的较大的`库存面板`拖拽到我们在上一章中创建的较小的HUD库存`右下角面板`。
- en: 'To make things a little easier for ourselves, let’s disable the `ShowHidePanels`
    script that we added to the `Main Camera` earlier in this chapter. You can do
    this by deselecting the checkbox next to the script’s component on the `Main Camera`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们自己更容易操作，让我们禁用本章早期添加到`主相机`的`ShowHidePanels`脚本。你可以通过在`主相机`上取消选中脚本组件旁边的复选框来完成此操作：
- en: '![Figure 8.19: Disabling the ShowHidePanel.cs script component](img/B18327_08_19.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19：禁用ShowHidePanel.cs脚本组件](img/B18327_08_19.jpg)'
- en: 'Figure 8.19: Disabling the ShowHidePanel.cs script component'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：禁用ShowHidePanel.cs脚本组件
- en: Let’s also disable `Pause Panel` so that it will not be in our way. Do this
    by deselecting the checkbox next to the name of the `Pause Panel` in its Inspector.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也禁用`暂停面板`，这样它就不会妨碍我们。通过在`检查器`中取消选中`暂停面板`名称旁边的复选框来完成此操作。
- en: Now, our Panel will stay visible, making it easier for us to debug the code
    we’re about to write.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的面板将保持可见，这使得我们更容易调试即将编写的代码。
- en: 'There are quite a few different ways to make a drag and drop mechanic. To ensure
    that this chapter provides an example of how to use the `Inventory Panel` and
    `Bottom Right Panel`, complete the following steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种不同的方式来实现拖拽机制。为了确保本章提供一个如何使用`库存面板`和`右下角面板`的例子，请完成以下步骤：
- en: Create a new C# script in the `Assets/Scripts` folder called `DragAndDrop.cs`
    and open it.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中创建一个新的C#脚本，命名为`DragAndDrop.cs`并打开它。
- en: 'We will be referencing UI elements in this script, so add the `UnityEngine.UI`
    namespace to the top of the script with this:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们将引用UI元素，所以将`UnityEngine.UI`命名空间添加到脚本的顶部，如下所示：
- en: '[PRE21]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We only need to add two variables to this script: one will represent the GameObject
    being dragged, and the other represents the Canvas that the items will be dragged
    on. Add the following public variables to the top of the class:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要向这个脚本添加两个变量：一个将代表被拖拽的GameObject，另一个将代表物品将被拖拽在其上的Canvas。将以下公共变量添加到类的顶部：
- en: '[PRE22]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we write any more code, let’s go back to the Editor and do a bit more
    prep work. Drag the `DragAndDrop.cs` script to the `Main Camera` to attach it
    as a component:![Figure 8.20: The components of the Main Camera](img/B18327_08_20.jpg)'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写更多代码之前，让我们回到编辑器并做一些更多的准备工作。将`DragAndDrop.cs`脚本拖拽到`主相机`上以将其附加为组件：![图8.20：主相机的组件](img/B18327_08_20.jpg)
- en: 'Figure 8.20: The components of the Main Camera'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.20：主相机的组件
- en: I’ve chosen to create a script that attaches to the `Main Camera` rather than
    the individual inventory items to reduce the need to duplicate this script.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我选择创建一个附加到`主相机`的脚本而不是单个库存项目，以减少需要复制此脚本的需求。
- en: Now, create a new UI Canvas by selecting `Drag Canvas`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过选择`拖拽画布`创建一个新的UI画布。
- en: Select `HUD Canvas` and copy its **Canvas Scalar** component by selecting the
    settings three dots (aka “the kabob”) in its top-right corner and selecting **Copy**
    **Component**.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`HUD画布`，通过在其右上角选择设置三个点（也称为“烤肉串”）并选择**复制****组件**来复制其**画布缩放器**组件。
- en: Reselect `Drag Canvas` and paste the copied **Canvas Scaler** properties to
    its **Canvas Scalar** component by selecting the three dots in its top-right corner
    and selecting **Paste** **Component Values**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新选择`拖拽画布`，通过在其右上角选择三个点并选择**粘贴****组件值**，将复制的**画布缩放器**属性粘贴到其**画布缩放器**组件中。
- en: 'Once that is done, it should have the following values:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成这些操作后，它应该具有以下值：
- en: '![Figure 8.21: The Canvas Scaler component on the Drag Canvas](img/B18327_08_21.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图8.21：拖拽画布上的画布缩放器组件](img/B18327_08_21.jpg)'
- en: 'Figure 8.21: The Canvas Scaler component on the Drag Canvas'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：拖拽画布上的画布缩放器组件
- en: 'Set the `Drag Canvas`’ Canvas component to `1`. This will cause anything that
    is on the `Drag Canvas` to render in front of all other Canvases since the other
    Canvases have a `0`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`拖拽画布`的画布组件设置为`1`。这将导致`拖拽画布`上的任何内容都会渲染在其他所有画布之前，因为其他画布的值为`0`：
- en: '![Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component](img/B18327_08_22.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22：在拖拽画布的画布组件上更新排序顺序](img/B18327_08_22.jpg)'
- en: 'Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：在拖拽画布的画布组件上更新排序顺序
- en: 'Drag and drop the `Drag Canvas` from the Hierarchy into the `DragAndDrop` script
    component on the `Main Camera`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Drag Canvas`从**层次结构**拖放到**主相机**上的`DragAndDrop`脚本组件中：
- en: '![Figure 8.23: The Drag and Drop component](img/B18327_08_23.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图8.23：拖放组件](img/B18327_08_23.jpg)'
- en: 'Figure 8.23: The Drag and Drop component'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：拖放组件
- en: 'Reopen the `DragAndDrop` script. Create a new function called `StartDrag()`,
    as follows:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`DragAndDrop`脚本。创建一个名为`StartDrag()`的新函数，如下所示：
- en: '[PRE23]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function will be called when a drag begins. It accepts a GameObject as
    a parameter and then creates a new instance of it at the position of the mouse.
    It then moves it so that it is a child of `dragCanvas`. Lastly, it sets the size
    of the sprite on the Image component to native size. This resets the scale of
    the Image’s Rect Transform to its sprite’s original pixel size. (Refer to [*Chapter
    12*](B18327_12.xhtml#_idTextAnchor328) for more on **Set Native Size**). The last
    line makes the image 10% bigger than its native size.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当拖动开始时，此函数将被调用。它接受一个GameObject作为参数，然后在鼠标的位置创建该对象的新实例。然后，它将其移动，使其成为`dragCanvas`的子对象。最后，它将图像组件上的精灵大小设置为原始大小。这会将图像的Rect
    Transform的缩放重置为其精灵的原始像素大小。（有关**设置原始大小**的更多信息，请参阅[*第12章*](B18327_12.xhtml#_idTextAnchor328)）。最后一行使图像比其原始大小大10%。
- en: Note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After we hook up our **BeginDrag** and **Drag** events, if you comment out the
    line of code that sets the size to native, you›ll see that the Image does not
    actually render in the scene, because its scale is «wacky» from the original GameObject
    being within a **Layout Group**.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将**开始拖动**和**拖动**事件连接起来之后，如果您注释掉设置大小为原始大小的代码行，您会发现图像实际上并没有在场景中渲染，因为它的缩放从原始GameObject在**布局组**内变得“古怪”。
- en: 'Now, create a new function called `Drag()`, as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`Drag()`的新函数，如下所示：
- en: '[PRE24]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function will be called when an object is being dragged. While the object
    is dragged, it will keep position with the mouse.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当对象被拖动时，此函数将被调用。在对象被拖动时，它将保持与鼠标的位置一致。
- en: 'Return to the Editor. We will just hook the events to the first object in the
    `Inventory Panel` for now. Select the first `Food` image in the `Inventory Panel`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到编辑器。我们现在只是将事件连接到**库存面板**中的第一个对象。选择**库存面板**中的第一个**食物**图像：
- en: '![Figure 8.24: Selecting the Food GameObject](img/B18327_08_24.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24：选择**食物**游戏对象](img/B18327_08_24.jpg)'
- en: 'Figure 8.24: Selecting the Food GameObject'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：选择**食物**游戏对象
- en: 'Add a new Event Trigger component to the `Food` Image by selecting **Add Component**
    | **Event** | **Event Trigger** within its **Inspector**:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**检查器**中选择**添加组件** | **事件** | **事件触发**，向**食物**图像添加一个新的**事件触发**组件：
- en: '![Figure 8.25: The Food GameObject with the Event Trigger component](img/B18327_08_25.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图8.25：带有事件触发组件的**食物**游戏对象](img/B18327_08_25.jpg)'
- en: 'Figure 8.25: The Food GameObject with the Event Trigger component'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：带有事件触发组件的**食物**游戏对象
- en: 'Now, add a **Begin Drag** event type and a **Drag** event type to the **Event
    Trigger** list by selecting **Add New Event Type** | **BeginDrag** and **Add New
    Event Type** | **Drag**:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过选择**添加新事件类型** | **开始拖动**和**添加新事件类型** | **拖动**，将**开始拖动**事件类型和**拖动**事件类型添加到**事件触发**列表中：
- en: '![Figure 8.26: The Event Trigger component with two events](img/B18327_08_26.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图8.26：具有两个事件的**事件触发**组件](img/B18327_08_26.jpg)'
- en: 'Figure 8.26: The Event Trigger component with two events'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26：具有两个事件的**事件触发**组件
- en: 'Now, we will add an action to the **Begin Drag** list by selecting the plus
    sign at the bottom-right corner of the **Begin** **Drag** area:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过选择**开始拖动**区域右下角的加号来向**开始拖动**列表添加一个动作：
- en: '![Figure 8.27: Adding a Begin Drag event](img/B18327_08_27.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图8.27：添加**开始拖动**事件](img/B18327_08_27.jpg)'
- en: 'Figure 8.27: Adding a Begin Drag event'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：添加**开始拖动**事件
- en: 'Drag the `Main Camera` into the object slot:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Main Camera`拖入对象槽中：
- en: '![Figure 8.28: Updating the Begin Drag event with the camera](img/B18327_08_28.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图8.28：使用相机更新**开始拖动**事件](img/B18327_08_28.jpg)'
- en: 'Figure 8.28: Updating the Begin Drag event with the camera'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28：使用相机更新**开始拖动**事件
- en: 'The function dropdown list is now intractable. Expand the function dropdown
    list to see the list of functions, components, and such attached to the `Main
    Camera`. Find the **DragAndDrop** script and then the **StartDrag (****GameObject)**
    function:![Figure 8.29: Adding the StartDrag method](img/B18327_08_29.jpg)'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数下拉列表现在不可操作。展开函数下拉列表以查看附加到`Main Camera`的函数、组件等列表。找到**DragAndDrop**脚本和**StartDrag
    (GameObject)**函数：![图8.29：添加**StartDrag**方法](img/B18327_08_29.jpg)
- en: 'Figure 8.29: Adding the StartDrag method'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.29：添加**StartDrag**方法
- en: 'Once you have done so, you should see the following:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成上述操作后，你应该会看到以下内容：
- en: '![Figure 8.30: Adding the StartDrag method](img/B18327_08_30.jpg)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图8.30：添加StartDrag方法](img/B18327_08_30.jpg)'
- en: 'Figure 8.30: Adding the StartDrag method'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.30：添加StartDrag方法
- en: Now, we need to assign the GameObject parameter. Drag and drop the `Food` Image
    that this **Event Trigger** component is attached to into the parameter slot.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要分配GameObject参数。将此**事件触发器**组件附加到的`Food`图像拖放到参数槽中。
- en: '![Figure 8.31: Updating the StartDrag method](img/B18327_08_31.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图8.31：更新StartDrag方法](img/B18327_08_31.jpg)'
- en: 'Figure 8.31: Updating the StartDrag method'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31：更新StartDrag方法
- en: 'Now, set up the **Drag** event list similarly so that it looks like this:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以类似的方式设置**Drag**事件列表，使其看起来像这样：
- en: '![Figure 8.32: Adding the Drag method](img/B18327_08_32.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图8.32：添加Drag方法](img/B18327_08_32.jpg)'
- en: 'Figure 8.32: Adding the Drag method'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32：添加Drag方法
- en: 'If you play the game, you should now be able to drag the orange in the first
    slot out of its slot.![Figure 8.33: Dragging the orange from the inventory](img/B18327_08_33.jpg)'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你玩游戏，你现在应该能够将第一个槽位中的橙色拖出其槽位。![图8.33：从库存中拖动橙色](img/B18327_08_33.jpg)
- en: 'Figure 8.33: Dragging the orange from the inventory'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.33：从库存中拖动橙色
- en: You’ll see, in the Hierarchy, there is a new GameObject called `Food(Clone)`
    that is a child of the `Drag Canvas`. This is the orange that gets created when
    you begin dragging.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会在层次结构中看到一个名为`Food(Clone)`的新GameObject，它是`Drag Canvas`的子对象。这是当你开始拖动时创建的橙色。
- en: '![Figure 8.34: The item being dragged in the Drag Canvas](img/B18327_08_34.jpg)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图8.34：在Drag Canvas中拖动的项目](img/B18327_08_34.jpg)'
- en: 'Figure 8.34: The item being dragged in the Drag Canvas'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.34：在Drag Canvas中拖动的项目
- en: At this point, you can actually make as many of these clones as you want. In
    a moment, however, we will make it so that there is only one clone in the `Drag
    Canvas` at a time.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，你实际上可以创建尽可能多的这些克隆。然而，稍后我们将使其在`Drag Canvas`中一次只有一个克隆。
- en: 'Go back to the `DragAndDrop` script and create a new function called `StopDrag()`,
    as follows:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`DragAndDrop`脚本，创建一个名为`StopDrag()`的新函数，如下所示：
- en: '[PRE25]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code will destroy the `Food(Clone)` GameObject once it is no longer being
    dragged.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将在不再拖动`Food(Clone)`GameObject时将其销毁。
- en: 'Go back to the Editor and reselect the `Food` Image in `Inventory Panel`. Give
    its `EndDrag` event type by selecting `Drag()` function from the `DragAndDrop`
    script to this event since that was the last selected function:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器，重新选择`Inventory Panel`中的`Food`图像。通过从`DragAndDrop`脚本中选择`Drag()`函数来为此事件分配`EndDrag`事件类型，因为这是最后一个选定的函数：
- en: '![Figure 8.35: The End Drag event with the Drag method](img/B18327_08_35.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图8.35：使用Drag方法结束拖动事件](img/B18327_08_35.jpg)'
- en: 'Figure 8.35: The End Drag event with the Drag method'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.35：使用Drag方法结束拖动事件
- en: 'Replace the `Drag()` function in the function dropdown with the `StopDrag()`
    function:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数下拉菜单中的`Drag()`函数替换为`StopDrag()`函数：
- en: '![Figure 8.36: The End Drag event with the StopDrag method](img/B18327_08_36.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图8.36：使用StopDrag方法结束拖动事件](img/B18327_08_36.jpg)'
- en: 'Figure 8.36: The End Drag event with the StopDrag method'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36：使用StopDrag方法结束拖动事件
- en: Play the game, and you will see that the orange can now be dragged out of its
    slot, and when you release the mouse, it is destroyed. This stops you from being
    able to drag a bunch of oranges from this slot.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始游戏，你会看到现在可以拖动橙色出其槽位，当你释放鼠标时，它会被销毁。这阻止了你从该槽位拖动一串橙子的能力。
- en: 'Go back to the `DragAndDrop` script and create a new function called `Drop()`,
    as shown in the following:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`DragAndDrop`脚本，创建一个名为`Drop()`的新函数，如下所示：
- en: '[PRE26]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function accepts an `Image` as a parameter. This Image will be the Image
    component of the slot that will receive a drop. The first line of the function
    finds the first child of the `dragCanvas` (at position `0`) and then assigns its
    Image’s sprite to the sprite of the `dropSlot`. Since we have set up the `StopDrag()`
    function to destroy the object being dragged once it stops dragging, we don’t
    have to worry about there being more than one child of the `Drag Canvas` GameObject,
    making this the easiest way to find the object being dragged.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数接受一个`Image`作为参数。此Image将是接收拖放操作的槽位的图像组件。函数的第一行找到`dragCanvas`的第一个子对象（位置`0`），然后将它的图像精灵分配给`dropSlot`的精灵。由于我们已经设置了`StopDrag()`函数，在停止拖动时销毁被拖动的对象，所以我们不必担心`Drag
    Canvas`GameObject有多个子对象，这使得这是找到被拖动对象的最简单方法。
- en: 'Go back to the Editor and select the second `Food` Image in the `Bottom` `Right
    Panel`:![Figure 8.37: Selecting the correct Food item](img/B18327_08_37.jpg)'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器并选择`底部右面板`中的第二个`Food`图像：![图8.37：选择正确的食品物品](img/B18327_08_37.jpg)
- en: 'Figure 8.37: Selecting the correct Food item'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.37：选择正确的食品物品
- en: We’re using the second `Food` Image, rather than the first, because the first
    already has an orange in it, and it will be hard to tell that our script worked
    in that slot.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用的是第二个`Food`图像，而不是第一个，因为第一个已经有一个橙子在里头，而且很难判断我们的脚本在那个槽位是否起作用。
- en: Add a new `Food` Image by selecting **Add Component** | **Event** | **Event
    Trigger** within its Inspector.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在其检查器中选择**添加组件** | **事件** | **事件触发器**来添加一个新的`Food`图像。
- en: 'Add a `Drop` event type to the **Event Trigger** component by selecting **Add
    New Event Type** | **Drop**:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**添加新事件类型** | **Drop**，向**事件触发器**组件添加一个`Drop`事件类型：
- en: '![Figure 8.38: The Drop event](img/B18327_08_38.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图8.38：Drop事件](img/B18327_08_38.jpg)'
- en: 'Figure 8.38: The Drop event'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38：Drop事件
- en: Add a new action to the list with the **+** sign.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**号向列表中添加一个新动作。
- en: 'Drag `Main Camera` to the object slot and select the `Drop()` function from
    the `DragAndDrop` script:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`主相机`拖到对象槽位，并从`DragAndDrop`脚本中选择`Drop()`函数：
- en: '![Figure 8.39: The Drop event with its method populated](img/B18327_08_39.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图8.39：带有填充方法的Drop事件](img/B18327_08_39.jpg)'
- en: 'Figure 8.39: The Drop event with its method populated'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.39：带有填充方法的Drop事件
- en: 'Now, drag the `Food` Image that this **Event Trigger** component is attached
    to into the parameter slot:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此**事件触发器**组件附加到的`Food`图像拖入参数槽位：
- en: '![Figure 8.40: The Drop event with the correct parameter](img/B18327_08_40.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图8.40：带有正确参数的Drop事件](img/B18327_08_40.jpg)'
- en: 'Figure 8.40: The Drop event with the correct parameter'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.40：带有正确参数的Drop事件
- en: 'Play the game and when you drag the orange into the slot over the banana, the
    `Drop()` function doesn’t appear to trigger. This is because the orange being
    dragged is blocking the raycasting from reaching the banana, so the banana never
    thinks anything is dropped on it. This is an easy fix. Add the following line
    of code to the end of the `StartDrag()` function in the `DragAndDrop` script so
    that the raycast won’t be blocked by the orange anymore:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏，当你将橙色拖入香蕉上方的槽位时，`Drop()`函数似乎没有触发。这是因为被拖动的橙色阻挡了射线投射到达香蕉，所以香蕉从未认为有任何东西被扔到它上面。这是一个简单的修复。将以下代码行添加到`DragAndDrop`脚本中的`StartDrag()`函数末尾，这样射线投射就不会再被橙色阻挡了：
- en: '[PRE27]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Play the game, and you should now be able to drag the orange from the first
    slot of the `Inventory Panel` to the second slot of `Bottom` `Right Panel`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏，你现在应该能够将`库存面板`的第一个槽位中的橙子拖到`底部右面板`的第二个槽位。
- en: The functionality of drag and drop is now complete; we just need to add the
    functionality to the other slots. Let’s add the drag events to the other `Inventory
    Panel` items first.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖放功能现在已完成；我们只需要添加其他槽位的功能。首先，让我们向其他`库存面板`物品添加拖动事件。
- en: Copy the `Food` Item in the `Inventory Panel` that we hook the events up to,
    using the three dots in the component’s top-right corner.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用组件右上角的三点复制`库存面板`中的`Food`物品，将其与事件连接起来。
- en: Select all the other `Food` Images in the `Inventory Panel` by clicking on them
    while holding *Ctrl*.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Ctrl*键的同时点击其他`Food`图像，以选择`库存面板`中的所有其他`Food`图像。
- en: Now, with all eight `Food` Images still selected, click on the three dots on
    the `Food` Images should now have the **Event Trigger** component with all the
    appropriate events.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，所有八个`Food`图像仍然被选中，点击`Food`图像上的三点，现在应该具有带有所有适当事件的**事件触发器**组件。
- en: We’re not done with these other inventory items yet. We need to select each
    one and drag it into the parameter of the `BeginDrag` event type for its component.
    Otherwise, each of these other eight `Food` items will drag out oranges instead
    of the appropriate `Food` item, because the original orange is assigned to that
    slot. Do so now.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有完成这些其他库存物品。我们需要选择每个物品，并将其拖入其组件的`BeginDrag`事件类型参数中。否则，这八个其他`Food`物品将拖出橙子而不是适当的`Food`物品，因为原始的橙子被分配到那个槽位。现在就做吧。
- en: Before continuing, play the game and ensure that each inventory item in `Inventory
    Panel` drags out the appropriate image.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请玩游戏并确保`库存面板`中的每个库存物品都能拖出相应的图像。
- en: Now, we will copy the drop events from the second `Food` Image image in the
    `Bottom Right Panel` to all the other `Food` Images within the Panel. Copy the
    `Food` Image in the `Bottom` `Right Panel`.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`Bottom Right Panel`中的第二个`Food`图像复制事件到面板内的所有其他`Food`图像。复制`Bottom Right
    Panel`中的`Food`图像。
- en: Select the other four `Food` Images in the `Bottom Right Panel` while holding
    down *Ctrl*.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住*Ctrl*键的同时选择`Bottom Right Panel`中的其他四个`Food`图像。
- en: With each of the `Food` Images shown in the preceding screenshot still selected,
    paste the component as new in the Inspector.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图中所显示的每个`Food`图像仍然被选中时，在检查器中粘贴组件作为新组件。
- en: Now, select each of the new `Food` Images and assign each to the parameter slot
    within their **Event** **Trigger** component.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择每个新的`Food`图像，并将它们分配给它们**事件****触发**组件中的参数槽位。
- en: Play the game and ensure that the correct image slot is changed when a food
    item is dropped into it.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播玩游戏并确保当食物物品放入其中时，正确的图像槽位会发生变化。
- en: Now that the drag and drop code is done, re-enable the `ShowHidePanels` script
    on the `Main Camera` and re-enable the `Pause Panel`.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在拖放代码已经完成，重新启用`Main Camera`上的`ShowHidePanels`脚本和重新启用`Pause Panel`。
- en: That’s it for the drag and drop code. Currently, the `Pause Panel` blocks the
    raycast on the items within the `Inventory Panel`, so you don’t have to worry
    about disabling these events when the game is paused. However, if you end up changing
    the layout, you will want to do so by checking whether the `pauseUp` variable
    in `ShowHidePanels` is `false` before performing the tasks.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放代码就到这里了。目前，`Pause Panel`阻止了`Inventory Panel`内物品的射线投射，所以当游戏暂停时，你不必担心禁用这些事件。然而，如果你最终更改了布局，你将想要在执行任务之前检查`ShowHidePanels`中的`pauseUp`变量是否为`false`。
- en: If you want to allow the objects to go back and forth (drag from both Panels
    and drop in both Panels), all you have to do is copy the appropriate component
    to the opposite Panels!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想允许物体在两个面板之间来回移动（从两个面板拖动并放入两个面板），你只需要将适当的组件复制到对面的面板！
- en: You might also want to make the repeated UI elements prefabs so that you can
    save yourself some time during development or instantiate them programmatically.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望将重复的UI元素制作成预制体，这样你可以在开发过程中节省时间或以编程方式实例化它们。
- en: There are so many more examples I would love to cover in this chapter, but I
    can’t make this chapter take up the entire page count of the book! You’ll see
    more examples of how to use the Event System in the upcoming chapters, so don’t
    worry; this isn’t the last code example you will see.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我本想在本章中涵盖更多示例，但无法让本章占据整本书的页数！你将在接下来的章节中看到更多如何使用事件系统的示例，所以不用担心；这不是你将看到的最后一个代码示例。
- en: Pan and zoom with mouse and multi-touch input
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用鼠标和多点触控输入平移和缩放
- en: The last example I want to cover in this chapter is how to pan the camera with
    a two-finger touch and pinch to zoom. We will also implement a left-click pan
    and scroll wheel zoom so that you can easily test it on your computer (when you
    don’t have multi-touch input). The following image shows what we will be implementing.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要讨论的最后一个示例是如何使用两指触摸平移相机和捏合缩放。我们还将实现左键点击平移和滚轮缩放，以便你可以在电脑上轻松测试（当你没有多点触控输入时）。以下图片显示了我们将要实现的内容。
- en: '![Figure 8.41: Demonstration of the pan and zoom code working](img/B18327_08_41.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图8.41：平移和缩放代码的工作演示](img/B18327_08_41.jpg)'
- en: 'Figure 8.41: Demonstration of the pan and zoom code working'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.41：平移和缩放代码的工作演示
- en: 'To implement a pan and zoom on the camera, complete the following steps:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要在相机上实现平移和缩放，请完成以下步骤：
- en: So that I can actually see the effects of the pan and zoom, I want to populate
    some items in the scene. Let’s start by creating a prefab that we will place multiple
    times in the background. Create a `Prefabs` folder in your project by right-clicking
    on the `Assets` folder and selecting `Prefabs`.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了我能够真正看到平移和缩放的效果，我想在场景中添加一些物品。让我们先创建一个预制体，我们将在背景中多次放置它。通过在`Assets`文件夹上右键单击并选择`Prefabs`来在你的项目中创建一个`Prefabs`文件夹。
- en: Drag a sprite to the scene. I chose the first gem in the `foodSpriteSheet` called
    `foodSpriteSheet_1`.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个精灵拖动到场景中。我选择了`foodSpriteSheet`中的第一个宝石，名为`foodSpriteSheet_1`。
- en: Ensure that the **Transform** component of the sprite is positioned at the origin.
    If it is not, select the three dots in the top-right corner of the component and
    then select **Reset**.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保精灵的**变换**组件位于原点。如果不是，请选择组件右上角的三点，然后选择**重置**。
- en: Rename the sprite `Tile`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵重命名为`Tile`。
- en: Now, drag the sprite from the Hierarchy into your `Prefabs` folder. This will
    create a prefab called `Tile`.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将精灵从层次结构拖动到你的`Prefabs`文件夹中。这将创建一个名为`Tile`的预设。
- en: We no longer need the prefab in the scene so go ahead and delete it.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要场景中的预设，所以请将其删除。
- en: Create an empty GameObject by selecting **+** | **Create Empty** in the Hierarchy.
    We will use this to hold the code that instantiates our tiles.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在层次结构中选择**+** | **Create Empty**创建一个空GameObject。我们将使用它来存放实例化我们的瓷砖的代码。
- en: Rename this empty GameObject to `Tile Maker`.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个空GameObject重命名为`Tile Maker`。
- en: In the book’s source files, you will find three scripts called `Tile.cs`, `TileMaker.cs`,
    and `CameraHandle.cs`. Import them into the `Scripts` folder of your project.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书的源文件中，你会找到三个名为`Tile.cs`、`TileMaker.cs`和`CameraHandle.cs`的脚本。将它们导入到你的项目的`Scripts`文件夹中。
- en: Attach the `Tile.cs` script to the `Tile` prefab. This script will be used to
    make any instantiated `Tile` prefab have a random sprite.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Tile.cs`脚本附加到`Tile`预设。此脚本将用于使任何实例化的`Tile`预设具有随机精灵。
- en: Since the `Tile.cs` script is not really essential to the example, I won’t review
    the code, but I will point out that the `possibleSprites` list contains all the
    sprites that the tile can change to. Add all the sprites that look like gems to
    this list. You should see something like the following
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Tile.cs`脚本对示例不是必需的，所以我不将审查代码，但我会指出`possibleSprites`列表包含所有瓷砖可以转换成的精灵。将所有看起来像宝石的精灵添加到这个列表中。你应该会看到如下内容
- en: '![Figure 8.42: The possible sprites for the tile](img/B18327_08_42.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图8.42：瓷砖的可能精灵](img/B18327_08_42.jpg)'
- en: 'Figure 8.42: The possible sprites for the tile'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.42：瓷砖的可能精灵
- en: Now attach the `TileMaker.cs` script to the `Tile` `Maker` GameObject.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`TileMaker.cs`脚本附加到`Tile` `Maker` GameObject。
- en: 'Drag the `Tile` prefab into the **Tile Prefab** slot and set the other values
    as follows:![Figure 8.43: The TileMaker.cs script component](img/B18327_08_43.jpg)'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Tile`预设拖动到**Tile Prefab**槽中，并设置其他值如下：![图8.43：TileMaker.cs脚本组件](img/B18327_08_43.jpg)
- en: 'Figure 8.43: The TileMaker.cs script component'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.43：TileMaker.cs脚本组件
- en: This will make a total of `500` tiles instantiate in `25` columns and `20` rows.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将总共实例化`500`个瓷砖，分布在`25`列和`20`行。
- en: Play the game and you should see a bunch of random gems appear in your scene.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏，你应该会看到场景中出现许多随机的宝石。
- en: '![Figure 8.44: The gems in the scene](img/B18327_08_44.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图8.44：场景中的宝石](img/B18327_08_44.jpg)'
- en: 'Figure 8.44: The gems in the scene'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.44：场景中的宝石
- en: Now, let’s hook up the pan and zoom script. Attach the `CameraHandler.cs` script
    to the `Main Camera`.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们连接上平移和缩放脚本。将`CameraHandler.cs`脚本附加到`Main Camera`。
- en: 'Before we review the code, let’s add the correct variables to the component.
    Adjust the values to the following:![Figure 8.45: The CameraHandler.cs script
    component](img/B18327_08_45.jpg)'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们审查代码之前，让我们向组件添加正确的变量。调整值如下：![图8.45：CameraHandler.cs脚本组件](img/B18327_08_45.jpg)
- en: 'Figure 8.45: The CameraHandler.cs script component'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.45：CameraHandler.cs脚本组件
- en: The various properties add bounds to how far the camera can pan, how much it
    can zoom, and how quickly it pans and zooms.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的属性为相机平移和缩放的范围、缩放的程度以及平移和缩放的速度添加了限制。
- en: 'Now, let’s review the code. The code handles pan and zoom in two ways: one
    is with mouse input and the other with touch input. You’ll see that it also has
    special conditions for when a touch device is being played remotely via the Unity
    Editor.'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来审查代码。代码以两种方式处理平移和缩放：一种是通过鼠标输入，另一种是通过触摸输入。你会看到它还对通过Unity编辑器远程播放的触摸设备有特殊条件。
- en: 'A large portion of this code is vector math, and I will leave that for you
    to review on your own. The parts of this code I want to focus on are the parts
    relative to this chapter, specifically the parts involving `Input` and `Touch`.
    First, let’s look at the `HandleMouse()` method. I’ve highlighted the relevant
    parts:'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的大部分是矢量数学，我将留给你自己复习。我想重点关注的代码部分是与本章相关的部分，特别是涉及`Input`和`Touch`的部分。首先，让我们看看`HandleMouse()`方法。我已经突出显示了相关部分：
- en: '[PRE28]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that it uses `Input.GetMouseButtonDown(0)` to see if the left mouse button
    is currently held down, `Input.GetMouseButton(0)` to see if the mouse button has
    been clicked, and `Input.mousePosition` to find where the mouse is located.
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意它使用`Input.GetMouseButtonDown(0)`来检查是否按下了左鼠标按钮，使用`Input.GetMouseButton(0)`来检查鼠标按钮是否被点击，以及使用`Input.mousePosition`来找到鼠标的位置。
- en: 'Now, let’s look at how input is handled with touch in the `HandleTouch()` method.
    First, it looks to see how many fingers are touching the screen with the following
    `switch` statement:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在`HandleTouch()`方法中处理触摸输入。首先，它使用以下`switch`语句查看屏幕上有多少个手指在触摸：
- en: '[PRE29]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When a single finger is touching the screen, the camera can pan. It first must
    get the position of the finger. It does so with the following code:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当单个手指触摸屏幕时，相机可以进行平移。它首先必须获取手指的位置。它使用以下代码来完成：
- en: '[PRE30]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once again, I have highlighted the relevant code.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，我已经突出显示了相关代码。
- en: 'When two fingers are touching the screen, it will get the position of the fingers
    with the following:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个手指触摸屏幕时，它会使用以下方式获取手指的位置：
- en: '[PRE31]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next piece of code that I want to focus on is the following line within
    the `PanCamera()` method:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我接下来要关注的是`PanCamera()`方法中的以下代码行：
- en: '[PRE32]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Figure 8.46: The Event Trigger on the Background Canvas](img/B18327_08_46.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![图8.46：背景画布上的事件触发器](img/B18327_08_46.jpg)'
- en: 'Figure 8.46: The Event Trigger on the Background Canvas'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.46：背景画布上的事件触发器
- en: 'Now that you’ve reviewed the code, play the game again to see the pan and zoom
    functions in action. If you can, I recommend also plugging a mobile device into
    your computer and running the game via Unity Remote. You can view information
    about how to use Unity Remote here: [https://docs.unity3d.com/Manual/UnityRemote5.xhtml](https://docs.unity3d.com/Manual/UnityRemote5.xhtml).'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经审查了代码，再次玩游戏以查看平移和缩放功能。如果你能的话，我建议将移动设备连接到你的电脑，并通过Unity Remote运行游戏。你可以在这里查看有关如何使用Unity
    Remote的信息：[https://docs.unity3d.com/Manual/UnityRemote5.xhtml](https://docs.unity3d.com/Manual/UnityRemote5.xhtml)。
- en: We don’t want the game to pan and zoom when it’s paused and the inventory Panel
    is up! So, let’s update the `ShowHidePanels.cs` script to call the `TurnOffPanAndZoom()`
    and `TurnOnPanAndZoom()` methods, which toggle the `canPan` and `canZoom` Boolean
    variables.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望游戏在暂停时以及库存面板打开时进行平移和缩放！所以，让我们更新`ShowHidePanels.cs`脚本，调用`TurnOffPanAndZoom()`和`TurnOnPanAndZoom()`方法，这些方法切换`canPan`和`canZoom`布尔变量。
- en: 'Add the following variable to the `ShowHidePanels.cs` class:'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下变量添加到`ShowHidePanels.cs`类中：
- en: '[PRE33]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we need to initialize the `cameraHandler` variable. Add an `Awake()` method
    with the following code:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要初始化`cameraHandler`变量。添加一个`Awake()`方法，包含以下代码：
- en: '[PRE34]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, add the following to the `TogglePanel()` method. This will call the `TurnOffPanAndZoom()`
    method whenever the game is paused or showing the inventory and call `TurnOnPanAndZoom()`
    whenever neither of the Panels is visible:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将以下内容添加到`TogglePanel()`方法中。这将使`TurnOffPanAndZoom()`方法在游戏暂停或显示库存时被调用，并在两个面板都不可见时调用`TurnOnPanAndZoom()`方法：
- en: '[PRE35]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You should now have a fully functional pan and zoom that are disabled when menus
    are visible!
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该拥有一个完全功能的平移和缩放功能，当菜单可见时将禁用！
- en: 'This is almost the exact code I used in my game Barkeology, which you can find
    on the iOS app store: [https://apps.apple.com/kn/app/barkeology/id1500348850](https://apps.apple.com/kn/app/barkeology/id1500348850)
    So, if you do not have the ability to test your code on your mobile device, but
    would like to see it in action, you can view it there.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是我用在游戏Barkeology中的确切代码，你可以在iOS应用商店找到它：[https://apps.apple.com/kn/app/barkeology/id1500348850](https://apps.apple.com/kn/app/barkeology/id1500348850)。所以，如果你没有在移动设备上测试代码的能力，但想看到它的工作情况，你可以在那里查看。
- en: While this marks the end of the chapter, we will continue to work in the Event
    System throughout this text, so you will see plenty more examples.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这标志着本章的结束，但我们将继续在本文本中使用事件系统进行工作，所以你会看到更多示例。
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we know how to utilize the Event System and program for UI elements,
    we can start making interactive and visual UI elements. We can also create UI
    that has its various properties change when events occur.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何利用事件系统和为UI元素编程，我们可以开始制作交互式和可视化的UI元素。我们还可以创建在事件发生时其各种属性会改变的UI。
- en: We covered a lot in this chapter! We discussed how to access the properties
    of UI elements and how to work with the Event System. We also discussed how to
    use the Input Module. Now, you can create UI that responds to user inputs as well
    as UI that responds to events within your game.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容！我们讨论了如何访问UI元素的属性以及如何与事件系统协同工作。我们还讨论了如何使用输入模块。现在，你可以创建对用户输入做出响应的UI，以及对你游戏中事件做出响应的UI。
- en: 'In the next chapter, we will look at the other input system provided by Unity:
    the New Input System (yeah, that’s its actual name).'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Unity提供的其他输入系统：新输入系统（是的，这就是它的实际名称）。
