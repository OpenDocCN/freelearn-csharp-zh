- en: Observer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: In this chapter, we are going to learn about the Observer pattern, but we are
    going to take a different approach from our previous chapters, for the simple
    reason that the Observer pattern is already natively implemented in the Unity
    engine, in the form of the C# event system. But just to cover our bases, we will
    quickly review the classic form of the Observer pattern and then compare it to
    the C# event system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习观察者模式，但我们将采取与之前章节不同的方法，简单的原因是观察者模式已经在 Unity 引擎中以 C# 事件系统的形式原生实现。但为了全面起见，我们将快速回顾观察者模式的经典形式，然后将其与
    C# 事件系统进行比较。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of the the Observer pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式的基本原理
- en: Reviewing how it's implemented natively in the C# event system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查它如何在 C# 事件系统中原生实现
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This is a hands-on chapter, so you will need to have a basic understanding of
    Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实践性章节，因此您需要具备对 Unity 和 C# 的基本理解。
- en: 'We will be using the following Unity-specific engine and C# language concept(s):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下 Unity 特定引擎和 C# 语言概念：
- en: Events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Delegates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Coroutines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: You don't need to know about them before starting this chapter, but it would
    help to take the time to review some online documentation on the subject.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，您不需要了解它们，但花时间回顾一些关于该主题的在线文档会有所帮助。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际运行情况：
- en: '[http://bit.ly/2Fy4HvP](http://bit.ly/2Fy4HvP)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Fy4HvP](http://bit.ly/2Fy4HvP)'
- en: A preview of the Observer pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式的预览
- en: As its name implies, the purpose of the Observer pattern is to observe. To be
    more precise, the core purpose of the Observer is to observe other objects and
    specific changes in their internal states. Before the Observer pattern, the only
    way to watch an object from the *outside, looking in* was by calling constantly
    or *pinging* its public members in the hope that you would capture a change in
    its values.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，观察者模式的目的就是观察。更准确地说，观察者的核心目的是观察其他对象及其内部状态的具体变化。在观察者模式之前，从“外面看”观察一个对象的唯一方法是通过不断调用或“ping”其公共成员，希望捕捉到其值的变化。
- en: The Observer pattern was designed to solve this limitation by defining a system
    in which objects (subjects) maintain a list of other objects (observers). Subjects
    call observers when they need to broadcast a change on their side.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式旨在通过定义一个系统来解决这个问题，在该系统中，对象（主题）维护一个其他对象（观察者）的列表。当主题需要广播其方面的变化时，它们会调用观察者。
- en: We can visualize the principles of this system with this real-world example
    of a Wall Street broker managing a catalog of stocks (subjects) associated with
    a list of clients (observers). When particular market events occur, the broker
    calls all their clients to let them know that the value of their stocks has changed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下现实世界的例子来可视化这个系统的原理：一位华尔街经纪人管理着一组与客户列表（观察者）关联的股票目录（主题）。当特定市场事件发生时，经纪人会联系所有客户，告知他们其股票的价值已发生变化。
- en: 'Let''s review a UML diagram of a typical implementation of the Observer pattern
    to see how this might work when implemented in code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个典型实现观察者模式的 UML 图，看看它在代码中实现时可能的工作方式：
- en: '![](img/e843293c-2b96-46ca-8fba-4c42b1f2ddc3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e843293c-2b96-46ca-8fba-4c42b1f2ddc3.png)'
- en: 'As you can see, the subject and the observer both have their respective interfaces,
    but the most important one to analyze is `ISubject`, which includes the following
    public functions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主题和观察者都有自己的接口，但最重要的分析接口是 `ISubject`，它包括以下公共函数：
- en: '`Attach()`: This function allows the addition of an observer object to the
    list of observers to notify.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attach()`: 这个函数允许将观察者对象添加到要通知的观察者列表中。'
- en: '`Detach()`: This one removes an observer from the list of observers.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Detach()`: 这个函数会从观察者列表中移除一个观察者。'
- en: '`Notify()`: This will notify all the observers that have been attached to the
    subject''s observer list.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notify()`: 这将通知所有已附加到主题观察者列表中的观察者。'
- en: Even though this is not a very complicated design to implement, it can become
    very tedious to write each time you need to observe other objects. Modern languages
    such as C# have natively implemented the Observer pattern in the form of an event
    system, so programmers don't have to write it out manually.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是一个非常复杂的设计来实现，但每次你需要观察其他对象时，编写它都可能变得非常繁琐。现代语言，如C#，已经以事件系统的形式原生实现了观察者模式，因此程序员不需要手动编写它。
- en: Unlike applications such as spreadsheets, which usually only change their current
    run-states depending on users' interactions, we must take note that games are
    not event-driven; instead, it's the main game loop that drives the game forward.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常只根据用户交互改变当前运行状态的电子表格应用程序不同，我们必须注意，游戏不是事件驱动的；相反，是主游戏循环推动游戏向前发展。
- en: The C# event system
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#事件系统
- en: 'As a Unity developer, you will probably never need to implement a complete
    Observer pattern by hand because C# has a native implementation of the Observer
    natively available in the form of the event system. But before we start writing
    code, let''s review the core components of the C# event system:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Unity开发者，你可能永远不需要手动实现完整的观察者模式，因为C#已经以事件系统的形式提供了原生的观察者实现。但在我们开始编写代码之前，让我们回顾一下C#事件系统的核心组件：
- en: '**Events:** When an event is raised by an object (publisher), it sends out
    a signal that other objects (subscribers) can capture. This concept might sound
    very familiar to that of throwing and handling exceptions, in the sense that when
    an exception is thrown, it goes up the call stack until it''s handled. But in
    the case of the event system, there''s not really a call chain, because once an
    object broadcasts an event, only those objects that subscribe to it will be notified
    and can choose to get triggered by it or just ignore it. So, we can basically
    imagine it has as a sudden burst of a radio signal that only those with antennas
    can listen to.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：当一个对象（发布者）引发事件时，它会发送一个信号，其他对象（订阅者）可以捕获这个信号。这个概念可能听起来非常熟悉，就像抛出和处理异常一样，当异常被抛出时，它会沿着调用栈向上传递，直到被处理。但在事件系统的案例中，实际上并没有调用链，因为一旦一个对象广播了一个事件，只有订阅了它的对象才会被通知，并且可以选择被它触发或只是忽略它。所以，我们基本上可以想象它就像一个突然爆发的无线电信号，只有那些有天线的人才能听到。'
- en: '**Delegates:** The concept behind delegates is simple when you understand their
    underlying low-level mechanism. A high-level definition of delegates is that they
    hold references to functions. They are very useful when you want to trigger multiple
    functions from one call—in other words, when you want to multicast. But this is
    a very abstract definition of what delegates actually do behind the scenes. They''re
    basically function pointers, which means that they hold the memory address to
    other functions. So, we could visualize them as an address book that contains
    a list of locations of functions. And that''s why a delegate can hold multiple
    functions and call them all at once.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代表（Delegates）**：当你理解它们背后的底层机制时，代表的概念很简单。代表的高级定义是它们持有函数的引用。当你想要从一个调用中触发多个函数时，它们非常有用——换句话说，当你想要多播（multicast）时。但这是对代表在幕后实际做什么的一个非常抽象的定义。它们基本上是函数指针，这意味着它们持有其他函数的内存地址。因此，我们可以将它们想象成一个包含函数位置的地址簿。这就是为什么代表可以持有多个函数并一次性调用它们。'
- en: Benefits and drawbacks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和缺点
- en: The Observer is one of those patterns that has become embedded in modern languages
    and code bases. It would be hard not to use this pattern, as its drawbacks are
    limited.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是那些已经嵌入到现代语言和代码库中的模式之一。很难不使用这个模式，因为它的缺点是有限的。
- en: 'The following is a list of the benefits:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些好处：
- en: '**Loose coupling**: The main advantage of the Observer is that it decouples
    observed objects from observers. They don''t need to know one another; they just
    broadcast or listen.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：观察者的主要优势是它将观察对象与观察者解耦。它们不需要相互了解；它们只需要广播或监听。'
- en: '**Send data to anyone**: You can easily send data to and from one object to
    another.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向任何人发送数据**：你可以轻松地将数据从一个对象发送到另一个对象。'
- en: '**Stop listening at any time**: There''s no explicit contract between subjects
    and listeners, so they can stop broadcasting if needed.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随时停止监听**：主体和听众之间没有明确的合同，因此如果需要，他们可以随时停止广播。'
- en: 'The following is a drawback:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个缺点：
- en: '**Noisy code**: The Observer pattern has brought about the event-driven paradigm,
    but it can can become noisy and difficult to manage, if overused'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嘈杂的代码**：观察者模式带来了事件驱动范式，但如果过度使用，它可能会变得嘈杂且难以管理。'
- en: Use case example
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: The Observer pattern in the form of an event system is often used to manage
    user input, but let's see whether we can use events for something else, such as
    an automated system that broadcasts its state changes to other systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以事件系统形式的观察者模式通常用于管理用户输入，但让我们看看我们是否可以用事件做其他事情，比如一个自动系统，它将广播其状态变化给其他系统。
- en: Let's say we are building a classic puzzle game with a countdown timer. As in
    most games or sports that have timers, we will give our player a unique sign and
    feedback to remind them how much time there is left.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个带有倒计时计时器的经典益智游戏。在大多数有计时器的游戏或运动中，我们将给玩家一个独特的标志和反馈，以提醒他们剩余多少时间。
- en: 'Our three main timer feedback events are going to be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们三个主要的计时器反馈事件如下：
- en: Clock started
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟开始
- en: Half time
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半场
- en: Time's up
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间到
- en: 'For each event, let''s trigger something unique, such as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个事件，让我们触发一些独特的事情，如下所示：
- en: Dim the lights
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减弱灯光
- en: Trigger a buzzer
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发蜂鸣器
- en: Display a message on the screen
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示一条消息
- en: 'But the challenge here is this: how are we going to notify the individual systems
    or components that manage the lighting, sounds, and UI of the state of the timer?
    When we have this type of problem, the Observer pattern becomes very useful, in
    the form of the event system: we will be able to have all those individual systems
    listen to the timer while it broadcasts specific timed events.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里的挑战是：我们如何通知管理照明、声音和UI的各个系统或组件计时器的状态？当我们遇到这类问题时，观察者模式就变得非常有用，以事件系统的形式：我们将能够让所有这些个别系统在计时器广播特定时间事件时进行监听。
- en: Code example
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'We are going to start this code example by implementing the most important
    component of an Observer pattern: the subject. Without something to observe, the
    Observer pattern has no use. Refer to the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实现观察者模式最重要的组件：主题来开始这个代码示例。如果没有东西可以观察，观察者模式就没有用途。请参考以下步骤：
- en: 'In the case of our code example, the `Timer` class is going to be our subject:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，`Timer`类将是我们主题：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, there's not much code; it's quite simple to implement a subject
    with the C# event system. The most important thing is the relationship between
    the `delegate` and the `event` type. An *event* is a message sent by an object,
    but during the communication process, it doesn't know which objects will receive
    its message, so it needs a pointer-like mechanism that can act as an intermediate
    between the sender and the receivers, and that's when delegates are required.
    Just imagine the delegate as the one that points the event message to the right
    *observers*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码并不多；使用C#事件系统实现一个主题相当简单。最重要的是`委托`和`事件`类型之间的关系。一个`事件`是对象发送的消息，但在通信过程中，它并不知道哪些对象会接收其消息，因此需要一个类似指针的机制，可以在发送者和接收者之间充当中间人，这就是委托所需的地方。只需想象一下，委托就是将事件消息指向正确的`观察者`。
- en: 'There''s also another important detail to keep in mind. Notice that every time
    we call an event such as `OnTimerEnded()`, it checks for nulls on its associated
    event-type reference before raising the event:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个重要的细节需要注意。请注意，每次我们调用像`OnTimerEnded()`这样的事件时，它都会在其相关的事件类型引用上检查null，然后再引发事件：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We do this because we can't broadcast an event if no one is listening. We need
    at least one observer that will handle the reception of the event. This is the
    way the event system is implemented and manages its references.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为如果没有人在听，就无法广播事件。我们需要至少一个处理事件接收的观察者。这就是事件系统实现和管理其引用的方式。
- en: 'Now that we have our subject ready, it''s time to implement the systems that
    will register themselves to receive event messages from our `Timer`. In other
    words, we are going to implement our observers. The first one is `Buzzer`, which
    will notify our player that the timer has started or ended, by making a buzzing
    sound:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了主题，是时候实现那些将注册自己以接收来自我们的`Timer`事件消息的系统了。换句话说，我们将实现我们的观察者。第一个是`Buzzer`，它将通过发出蜂鸣声来通知玩家计时器已经开始或结束：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next one in our list is the `WarningLight`, which will blink when the timer
    reaches halftime:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们列表中的下一个是`WarningLight`，当计时器达到半场时将闪烁：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As our final observer, we are going to implement `Notifier`, which has the
    responsibility of popping up a message when the time is up and the game is over:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为我们的最终观察者，我们将实现`Notifier`，它负责在时间到游戏结束时弹出消息：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should notice something that all our observers have in common: they all
    register themselves to receive events from the `Timer` by pointing to a specific
    local function. This implementation means that when the `Timer` broadcasts an
    event, all those objects that are observing it will get one of their local methods
    called automatically. Therefore, a remote event can provoke a local function call
    of an object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到我们所有的观察者有一个共同点：它们都通过指向一个特定的本地函数来注册自己以接收来自`Timer`的事件。这种实现方式意味着当`Timer`广播一个事件时，所有观察它的对象将自动调用它们的一个本地方法。因此，远程事件可以触发对象的本地函数调用：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another point to keep in mind is that an event can't point to `null` references,
    so it's good practice to make sure an object will remove itself as an observer
    if it gets disabled.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的点是一个事件不能指向`null`引用，因此确保一个对象在禁用时作为观察者移除是一个好的实践。
- en: The Observer pattern expressed through the C# event system offers a simple but
    powerful way of implementing an observer-and-subject relationship between objects,
    without explicit coupling and with a few lines of code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过C#事件系统表达的观察者模式提供了一种简单但强大的方法来实现对象之间的观察者-主题关系，无需显式耦合，并且只需要几行代码。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to implement the Observer pattern by building
    a timer that can trigger behaviors in our scene by having components listen to
    specific timed events. An important take away from this pattern is that the Observer
    pattern is natively implemented in Unity in the form of the C# event system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过构建一个计时器来实现观察者模式，该计时器可以通过组件监听特定的定时事件来触发场景中的行为。从这个模式中，我们得到的一个重要启示是，观察者模式在Unity中以C#事件系统的形式原生化实现。
- en: In the next chapter, we will explore the State pattern. Another useful pattern
    for game programming, it is somewhat related to the Observer pattern.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨状态模式。这是游戏编程中另一个有用的模式，它与观察者模式有些相关。
- en: Exercise
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: As we have learned in this chapter, the Observer pattern was the inspiration
    for the C# event system. But, of course, it's not an exact implementation of this
    pattern. So, as an exercise, I would encourage you to re-write the timer system
    that we just implemented, but without using the C# event system; instead, follow
    the design of the Observer pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中学到的，观察者模式是C#事件系统的灵感来源。但当然，它并不是这个模式的精确实现。所以，作为一个练习，我会鼓励你重新编写我们刚刚实现的计时器系统，但不要使用C#事件系统；相反，遵循观察者模式的设计。
- en: You can use the UML diagram shown at the beginning of the chapter as a starting
    point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本章开头所示的UML图作为起点。
- en: It's common to see design patterns implemented in unorthodox ways. Often, design
    patterns inspire programmers to structure their code in a certain way, but rarely
    will you see an accurate and "by the book" implementation of a specific pattern
    in production code bases.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在不寻常的方式中实现设计模式是很常见的。通常，设计模式会激发程序员以某种方式结构化他们的代码，但在生产代码库中，你很少会看到特定模式的准确和“按部就班”的实现。
- en: Further reading
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides([http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&WT.oss_r=1&item=171742](http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&WT.oss_r=1&item=171742))'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 《*设计模式*》，作者：Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides([http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&WT.oss_r=1&item=171742](http://www.pearsoned.co.uk/bookshop/detail.asp?WT.oss=design%20patterns%20elements&WT.oss_r=1&item=171742))
