<html><head></head><body>
		<div><h1 id="_idParaDest-56" class="chapter-number"><a id="_idTextAnchor055" class="calibre6 pcalibre1 pcalibre"/>3</h1>
			<h1 id="_idParaDest-57" class="calibre5"><a id="_idTextAnchor056" class="calibre6 pcalibre1 pcalibre"/>Fundamentals of C# Programming</h1>
			<p class="calibre3">Welcome to <a href="B20871_03.xhtml#_idTextAnchor055" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 3</em></a>, where we shall dive into the heart of technical interviews, specifically focusing on the fundamentals of C# programming. C# is a widely adopted, robust, and versatile language, used across various domains, including but not limited to game development, web services, and enterprise-level software.</p>
			<p class="calibre3">Grasping the essentials of a programming language such as C# is crucial to excel in technical interviews. In this chapter, we will walk you through the vital principles of C#, commencing with essential concepts, data types, variables, and operators, and swiftly move to control structures and loops. Our aim is not just to acquaint you with the syntax but to also ensure that you comprehend the logic behind it, enabling you to write effective and clean code.</p>
			<p class="calibre3">Furthermore, we shall delve into the basics of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) using C#. Understanding OOP<a id="_idIndexMarker122" class="calibre6 pcalibre1 pcalibre"/> allows you to design and manage complex applications, a skill that is greatly appreciated in the tech industry.</p>
			<p class="calibre3">By the end of this chapter, you will possess a solid foundation in C# programming. This knowledge will empower you to confidently tackle coding challenges and demonstrate your problem-solving abilities during technical interviews. This chapter is designed to provide you with a balanced mix of theoretical understanding and practical exercises, thereby ensuring you can apply the learned concepts effectively.</p>
			<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
			<ul class="calibre10">
				<li class="calibre11">Essential C# concepts and principles</li>
				<li class="calibre11">Working with data types, variables, and operators in C#</li>
				<li class="calibre11">Writing control structures and loops in C#</li>
				<li class="calibre11">Exploring the basics of OOP using C#</li>
			</ul>
			<h1 id="_idParaDest-58" class="calibre5"><a id="_idTextAnchor057" class="calibre6 pcalibre1 pcalibre"/>Essential C# concepts and principles</h1>
			<p class="calibre3">In this section, we aim to help you deepen your understanding of fundamental C# principles, enabling you to confidently answer the related questions you may encounter during technical interviews. This section is designed as a Q&amp;A in which we will tackle potential interview questions covering a range of topics, from the basics of the C# syntax to key concepts of OOP in C#. We believe this interactive approach will help reinforce your knowledge and prepare you effectively for real-world interview scenarios.</p>
			<p class="calibre3">Let’s dive in and start exploring the questions you might face and how to approach answering them effectively.</p>
			<h2 id="_idParaDest-59" class="calibre7"><a id="_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"/>What does the C# language represent, and for which platforms and applications is it intended?</h2>
			<p class="calibre3">C# is a programming language<a id="_idIndexMarker123" class="calibre6 pcalibre1 pcalibre"/> created by Microsoft and part of the .NET platform. With C#, a variety<a id="_idIndexMarker124" class="calibre6 pcalibre1 pcalibre"/> of applications can be developed, such as desktop<a id="_idIndexMarker125" class="calibre6 pcalibre1 pcalibre"/> applications, web applications, mobile applications, gaming applications (via Unity), cloud computing solutions, and more. C# is supported across various platforms thanks to .NET Core and Xamarin.</p>
			<h2 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor059" class="calibre6 pcalibre1 pcalibre"/>What’s the fundamental difference between .dll and .exe files in the context of C# projects?</h2>
			<p class="calibre3">In the context of C# and .NET, an <code>.exe</code> (<code>.exe</code> file, the program starts its execution. On the other hand, a <code>.dll</code> (<strong class="bold">dynamic-link library</strong>) file is a code library that doesn’t have<a id="_idIndexMarker127" class="calibre6 pcalibre1 pcalibre"/> a direct entry point but can be called by another program or application. It’s a means of code reuse among different projects.</p>
			<h2 id="_idParaDest-61" class="calibre7"><a id="_idTextAnchor060" class="calibre6 pcalibre1 pcalibre"/>How does the entry point of a program written in C# look?</h2>
			<p class="calibre3">The entry point in a C# program<a id="_idIndexMarker128" class="calibre6 pcalibre1 pcalibre"/> is typically represented by the <code>Main()</code> method, which is located in the <code>Program</code> class. This method must be static and serves as the starting point<a id="_idIndexMarker129" class="calibre6 pcalibre1 pcalibre"/> for the program’s execution. Usually, its structure looks like this:</p>
			<pre class="source-code">
public class Program
{
    public static void Main(string[] args)
    {
        // program code
    }
}</pre>
			<p class="calibre3">The <code>args</code> argument contains an array of strings that is passed to the program upon its launch.</p>
			<h2 id="_idParaDest-62" class="calibre7"><a id="_idTextAnchor061" class="calibre6 pcalibre1 pcalibre"/>How is memory management conducted in C#?</h2>
			<p class="calibre3">In C#, memory management<a id="_idIndexMarker130" class="calibre6 pcalibre1 pcalibre"/> is handled automatically thanks to the <strong class="bold">garbage collector</strong> mechanism. It automatically identifies objects<a id="_idIndexMarker131" class="calibre6 pcalibre1 pcalibre"/> that are no longer used by the program and frees the memory they occupy. While the garbage collector simplifies memory management, developers need to carefully manage unmanaged resources that are not controlled by the .NET garbage collector, such as database connections or file streams. If developers do not release these resources, they will persist for the lifetime of the application, potentially causing memory leaks and system strain.</p>
			<h2 id="_idParaDest-63" class="calibre7"><a id="_idTextAnchor062" class="calibre6 pcalibre1 pcalibre"/>What are the principles of OOP in C#?</h2>
			<p class="calibre3">OOP is based on four main<a id="_idIndexMarker132" class="calibre6 pcalibre1 pcalibre"/> principles: encapsulation, inheritance, polymorphism, and abstraction. In C#, this means the following:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Encapsulation</strong> allows data and methods to be bundled<a id="_idIndexMarker133" class="calibre6 pcalibre1 pcalibre"/> into a unit (class) and restricts access to certain components.</li>
				<li class="calibre11"><strong class="bold">Inheritance</strong> permits one class (the child or derived class) to inherit<a id="_idIndexMarker134" class="calibre6 pcalibre1 pcalibre"/> the attributes and methods of another class (the parent or base class). This promotes the reuse of code and establishes a hierarchical relationship<a id="_idIndexMarker135" class="calibre6 pcalibre1 pcalibre"/> between classes.</li>
				<li class="calibre11"><strong class="bold">Polymorphism</strong> is the capability of a single function<a id="_idIndexMarker136" class="calibre6 pcalibre1 pcalibre"/> or method to work in various ways based on its inputs or on which object it is called upon. In C#, polymorphism can be achieved through method overriding, using the <strong class="source-inline1">override</strong> keyword, and method hiding, utilizing the <strong class="source-inline1">new</strong> keyword to hide a method in the base class.</li>
				<li class="calibre11"><strong class="bold">Abstraction</strong> allows developers to hide complex implementations<a id="_idIndexMarker137" class="calibre6 pcalibre1 pcalibre"/> and show only the essential features of an object. This means that the user interacts with only what’s necessary and the internal workings are kept hidden. In C#, abstract classes and interfaces are tools that can help achieve abstraction.</li>
			</ul>
			<p class="calibre3">These principles help in designing robust<a id="_idIndexMarker138" class="calibre6 pcalibre1 pcalibre"/> and scalable applications, allowing for easy maintenance and further development. C# offers a rich set of features to implement and benefit from these principles effectively.</p>
			<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor063" class="calibre6 pcalibre1 pcalibre"/>How is error handling done in C#?</h2>
			<p class="calibre3">In C#, the primary error handling<a id="_idIndexMarker139" class="calibre6 pcalibre1 pcalibre"/> mechanism is based on the use of <code>try</code>, <code>catch</code>, <code>finally</code>, and <code>throw</code> constructs. When code in a <code>try</code> block causes an error, execution jumps to the corresponding <code>catch</code> block, where the exception is handled. The <code>finally</code> block, if present, is typically executed after <code>try/catch</code>, regardless of whether there was an exception or not. However, there are critical exceptions, such as <code>StackOverflowException</code> or <code>OutOfMemoryException</code>, which can result in a program crash and thus the <code>finally</code> block won’t be executed.</p>
			<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor064" class="calibre6 pcalibre1 pcalibre"/>What does the dependency injection principle mean and how is it implemented in C#?</h2>
			<p class="calibre3"><strong class="bold">Dependency injection</strong> (<strong class="bold">DI</strong>) is a software design approach that reduces<a id="_idIndexMarker140" class="calibre6 pcalibre1 pcalibre"/> tight coupling between system components. At the core of DI is the passing of dependencies (services, objects) to components rather than creating them inside those components. In C# and .NET, DI is often implemented using dependency<a id="_idIndexMarker141" class="calibre6 pcalibre1 pcalibre"/> containers, such as <em class="italic">Microsoft.Extensions.DependencyInjection</em>, <em class="italic">Ninject</em>, <em class="italic">Autofac</em>, and others.</p>
			<h2 id="_idParaDest-66" class="calibre7"><a id="_idTextAnchor065" class="calibre6 pcalibre1 pcalibre"/>What are boxing and unboxing in C#, and why can they be a problem?</h2>
			<p class="calibre3"><code>object</code> type or any interface type implemented by that value type. <code>object</code> type is converted back to the corresponding value type. The primary concern with boxing and unboxing in C# is their potential to degrade application performance. Boxing necessitates heap memory allocation and value type copying, thus slowing operations, especially with large datasets or in high-frequency scenarios. Unboxing, if incorrectly managed, can lead to runtime errors due to improper type casting, disrupting program execution. Additionally, these operations can increase the workload on the garbage collector, causing more frequent collection cycles and negatively impacting the application’s responsiveness.</p>
			<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor066" class="calibre6 pcalibre1 pcalibre"/>What does Entity Framework represent and how is it applied?</h2>
			<p class="calibre3"><strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) is an <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) framework developed by Microsoft<a id="_idIndexMarker144" class="calibre6 pcalibre1 pcalibre"/> for the .NET ecosystem. It<a id="_idIndexMarker145" class="calibre6 pcalibre1 pcalibre"/> enables developers to work with databases using object models instead of writing direct SQL code. This tool simplifies the process of creating and managing data models, automating database schema migrations, and writing queries that make database interaction more intuitive.</p>
			<h2 id="_idParaDest-68" class="calibre7"><a id="_idTextAnchor067" class="calibre6 pcalibre1 pcalibre"/>What’s the difference between threads and processes in C#?</h2>
			<p class="calibre3">In an operating system, a process<a id="_idIndexMarker146" class="calibre6 pcalibre1 pcalibre"/> is a distinct execution entity that has its own memory space. A thread<a id="_idIndexMarker147" class="calibre6 pcalibre1 pcalibre"/> is the smallest unit of execution within a process. Each process can have one or multiple threads. In C#, threads can be managed using the <code>Thread</code> class from the <code>System.Threading</code> namespace. The main difference lies in the fact that threads within a single process can share the same memory area, whereas each process has its own isolated memory context.</p>
			<h2 id="_idParaDest-69" class="calibre7"><a id="_idTextAnchor068" class="calibre6 pcalibre1 pcalibre"/>What are the main development environments used for C#, and are there alternatives to Visual Studio?</h2>
			<p class="calibre3">The main IDE for C# is Visual Studio from Microsoft. However, there are alternatives, such as Visual Studio Code (a lightweight code editor with support for C# extensions) and JetBrains Rider. Each environment has its own benefits and features, and the choice depends on the specific needs of the developer:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Visual Studio</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Features</em>: Comprehensive IDE with advanced tools<a id="_idIndexMarker148" class="calibre6 pcalibre1 pcalibre"/> for large-scale projects and multi-language support</li><li class="calibre11"><em class="italic">Use case</em>: Best suited for enterprise-level applications, offering a range of tools for collaborative and complex projects</li></ul></li>
				<li class="calibre11"><strong class="bold">Visual </strong><strong class="bold">Studio Code</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Features</em>: Lightweight, open source code<a id="_idIndexMarker149" class="calibre6 pcalibre1 pcalibre"/> editor with a rich ecosystem of extensions, including C# support</li><li class="calibre11"><em class="italic">Use case</em>: Ideal for individual developers or small teams, providing a flexible and extensible environment for various languages and frameworks</li></ul></li>
				<li class="calibre11"><strong class="bold">JetBrains Rider</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Features</em>: Cross-platform .NET IDE with powerful tools<a id="_idIndexMarker150" class="calibre6 pcalibre1 pcalibre"/> for .NET development and a rich set of plugins</li><li class="calibre11"><em class="italic">Use case</em>: Excellent for cross-platform development, offering consistent experiences and high-quality code analysis and refactoring tools</li></ul></li>
			</ul>
			<h2 id="_idParaDest-70" class="calibre7"><a id="_idTextAnchor069" class="calibre6 pcalibre1 pcalibre"/>What programming patterns do you know, and which ones have you implemented in C#?</h2>
			<p class="calibre3">Programming patterns are proven solutions<a id="_idIndexMarker151" class="calibre6 pcalibre1 pcalibre"/> for common development challenges. They indicate the optimal way to implement a specific task. In C#, I often use patterns such as <em class="italic">Singleton</em>, <em class="italic">Factory</em>, <em class="italic">Observer</em>, <em class="italic">Strategy</em>, and <em class="italic">Decorator</em>.</p>
			<h2 id="_idParaDest-71" class="calibre7"><a id="_idTextAnchor070" class="calibre6 pcalibre1 pcalibre"/>Can you describe different software testing methods and their primary differences?</h2>
			<p class="calibre3">There are several types of testing, including the following:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Unit testing</strong>: Focuses on individual pieces<a id="_idIndexMarker152" class="calibre6 pcalibre1 pcalibre"/> of code, particularly functions or methods</li>
				<li class="calibre11"><strong class="bold">Integration testing</strong>: Checks the interaction between different<a id="_idIndexMarker153" class="calibre6 pcalibre1 pcalibre"/> parts of the software</li>
				<li class="calibre11"><strong class="bold">System testing</strong>: Tests the entire <a id="_idIndexMarker154" class="calibre6 pcalibre1 pcalibre"/>system</li>
			</ul>
			<p class="calibre3">The main difference lies in the level of access and the scope of testing.</p>
			<h2 id="_idParaDest-72" class="calibre7"><a id="_idTextAnchor071" class="calibre6 pcalibre1 pcalibre"/>How do you determine the best time to conduct unit testing compared to integration or system testing?</h2>
			<p class="calibre3">Unit testing is best conducted during<a id="_idIndexMarker155" class="calibre6 pcalibre1 pcalibre"/> development when a specific component or function is being created or modified.</p>
			<p class="calibre3">Integration testing should be applied after several components<a id="_idIndexMarker156" class="calibre6 pcalibre1 pcalibre"/> have been combined to verify their correct interaction.</p>
			<p class="calibre3">System testing should be applied<a id="_idIndexMarker157" class="calibre6 pcalibre1 pcalibre"/> when the entire product or a significant portion of it is ready for release.</p>
			<h2 id="_idParaDest-73" class="calibre7"><a id="_idTextAnchor072" class="calibre6 pcalibre1 pcalibre"/>What is NuGet, and how can it be used to add libraries to your project?</h2>
			<p class="calibre3"><strong class="bold">NuGet</strong> is a package manager for the .NET platform<a id="_idIndexMarker158" class="calibre6 pcalibre1 pcalibre"/> that allows developers to easily add, update, and remove external libraries and dependencies in their projects. To add an external library to a project through NuGet, you need to open the NuGet console in the development environment (e.g., in Visual Studio) or use its graphical interface, find the desired package, and install it.</p>
			<p class="calibre3">Having mastered the essential concepts and principles of C#, you’ve already taken a significant step toward understanding this powerful programming language. But the journey doesn’t end here. Your next step is to delve into working with data types, variables, and operators<a id="_idIndexMarker159" class="calibre6 pcalibre1 pcalibre"/> in C#. Ready to continue? It’s time to dive even deeper!</p>
			<h1 id="_idParaDest-74" class="calibre5"><a id="_idTextAnchor073" class="calibre6 pcalibre1 pcalibre"/>Working with data types, variables, and operators in C#</h1>
			<p class="calibre3">When diving into C#, it’s essential to grasp data types, variables, and operators—they’re the backbone of your applications. In this section, we’ll explore these foundational elements, paving the way for more advanced coding. Ready to solidify your understanding? Let’s dive in!</p>
			<h2 id="_idParaDest-75" class="calibre7"><a id="_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"/>What are the basic primitive data types in C#? What is the main difference between value type and reference type?</h2>
			<p class="calibre3">In C#, there are <a id="_idIndexMarker160" class="calibre6 pcalibre1 pcalibre"/>primitive data types, such as <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>bool</code>, <code>byte</code>, and others. The main difference<a id="_idIndexMarker161" class="calibre6 pcalibre1 pcalibre"/> between the <em class="italic">value</em> type and <em class="italic">reference</em> type lies in how they<a id="_idIndexMarker162" class="calibre6 pcalibre1 pcalibre"/> are stored and how their memory management. Value types are stored on the stack and directly contain their value, while reference types are stored in the heap and contain a reference to the object in memory.</p>
			<h2 id="_idParaDest-76" class="calibre7"><a id="_idTextAnchor075" class="calibre6 pcalibre1 pcalibre"/>What is the primary distinction between string and StringBuilder in the context of strings?</h2>
			<p class="calibre3">The <code>string</code> type in C# is immutable, meaning<a id="_idIndexMarker163" class="calibre6 pcalibre1 pcalibre"/> every time the string is modified, a new instance is created. On the other hand, <code>StringBuilder</code> is designed for efficiently modifying<a id="_idIndexMarker164" class="calibre6 pcalibre1 pcalibre"/> strings without the need to create numerous new instances.</p>
			<h2 id="_idParaDest-77" class="calibre7"><a id="_idTextAnchor076" class="calibre6 pcalibre1 pcalibre"/>How do you initialize and interact with one-dimensional and multidimensional arrays? What differentiates "string[][]" from "string[,]"?</h2>
			<p class="calibre3">A one-dimensional array<a id="_idIndexMarker165" class="calibre6 pcalibre1 pcalibre"/> in C# is initialized like this: <code>int[] arr = new int[5];</code>. As for multidimensional <a id="_idIndexMarker166" class="calibre6 pcalibre1 pcalibre"/>arrays, <code>string[,]</code> is a two-dimensional<a id="_idIndexMarker167" class="calibre6 pcalibre1 pcalibre"/> array, while <code>string[][]</code> is an array<a id="_idIndexMarker168" class="calibre6 pcalibre1 pcalibre"/> of arrays, also<a id="_idIndexMarker169" class="calibre6 pcalibre1 pcalibre"/> known as a <em class="italic">jagged</em> array.</p>
			<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor077" class="calibre6 pcalibre1 pcalibre"/>What are bitwise operations and which operators in C# support these operations?</h2>
			<p class="calibre3">Bitwise operations allow<a id="_idIndexMarker170" class="calibre6 pcalibre1 pcalibre"/> for manipulations at the level of individual bits of a numerical value. The primary bitwise operators in C# are <code>&amp;</code> (<em class="italic">AND</em>), <code>|</code> (<em class="italic">OR</em>), <code>^</code> (<em class="italic">XOR</em>), and <code>~</code> (<em class="italic">NOT</em>).</p>
			<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor078" class="calibre6 pcalibre1 pcalibre"/>What is the purpose of "nullable" types in C# and how do you work with them correctly?</h2>
			<p class="calibre3"><code>Nullable</code> types in C# allow representing <a id="_idIndexMarker171" class="calibre6 pcalibre1 pcalibre"/>an absent or uninitialized value for value types. They are typically used when there is a need to distinguish a <em class="italic">zero</em> value from the absence of a value. To check for the presence of a value, you can use the <code>HasValue</code> property, and to retrieve the value itself, you use <code>Value</code>.</p>
			<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor079" class="calibre6 pcalibre1 pcalibre"/>What is known about operator overloading in C# and why can it be useful?</h2>
			<p class="calibre3">Operator overloading allows defining<a id="_idIndexMarker172" class="calibre6 pcalibre1 pcalibre"/> the actions of operators for user-defined data types, such as classes. This can be useful, for instance, for easy manipulation of complex numbers, vectors, or other mathematical structures.</p>
			<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor080" class="calibre6 pcalibre1 pcalibre"/>How can one overload an operator in C# and could you provide an example?</h2>
			<p class="calibre3">In C#, operator overloading<a id="_idIndexMarker173" class="calibre6 pcalibre1 pcalibre"/> allows you to redefine the way built-in operators work for user-defined types such as classes and structs. To overload an operator, you define a static method in your class or struct with the <code>operator</code> keyword followed by the operator symbol you want to overload. The method must return a result and take at least one parameter of the type you’re overloading the operator for.</p>
			<p class="calibre3">Here’s a simple example of overloading the <code>+</code> operator for a custom <code>Vector</code> class:</p>
			<pre class="source-code">
public class Vector
{
    public int X { get; set; }
    public int Y { get; set; }
    public Vector(int x, int y)
    {
        X = x;
        Y = y;
    }
    // Overload + operator
    public static Vector operator +(Vector v1, Vector v2)
    {
        return new Vector(v1.X + v2.X, v1.Y + v2.Y);
    }
}
// Usage:
Vector vector1 = new Vector(1, 2);
Vector vector2 = new Vector(2, 3);
Vector result = vector1 + vector2;  // This will call the overloaded + operator</pre>
			<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor081" class="calibre6 pcalibre1 pcalibre"/>How do comparison and relational operators work in C#?</h2>
			<p class="calibre3">Comparison (<code>==</code>, <code>!=</code>) and relational (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) operators are used<a id="_idIndexMarker174" class="calibre6 pcalibre1 pcalibre"/> to compare two values. It’s important<a id="_idIndexMarker175" class="calibre6 pcalibre1 pcalibre"/> to remember that when comparing reference types, the <code>==</code> operator checks for reference equality, not content.</p>
			<h2 id="_idParaDest-83" class="calibre7"><a id="_idTextAnchor082" class="calibre6 pcalibre1 pcalibre"/>What is the purpose of logical operators in C#, how do they function, and why is it important to pay attention to operator precedence?</h2>
			<p class="calibre3">Logical operators, such<a id="_idIndexMarker176" class="calibre6 pcalibre1 pcalibre"/> as <code>&amp;&amp;</code> (<em class="italic">logical “and”</em>), <code>||</code> (<em class="italic">logical “or”</em>), and <code>!</code> (<em class="italic">logical negation</em>), are used for combined logical conditions. It’s important to know operator precedence<a id="_idIndexMarker177" class="calibre6 pcalibre1 pcalibre"/> as it affects the order of operations. For example, the expression <code>A &amp;&amp; B || C</code> will be interpreted as <code>(A &amp;&amp; B) || C</code>, not <code>A &amp;&amp; (B || C)</code>, which can lead to different results.</p>
			<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor083" class="calibre6 pcalibre1 pcalibre"/>When and why should you use “const” variables in C#? What’s the difference between them and “readonly”?</h2>
			<p class="calibre3"><code>const</code> variables should be used when you need<a id="_idIndexMarker178" class="calibre6 pcalibre1 pcalibre"/> to define a variable that doesn’t change throughout the program’s life cycle. They must have a value assigned at compile<a id="_idIndexMarker179" class="calibre6 pcalibre1 pcalibre"/> time. On the other hand, <code>readonly</code> can be initialized in a class constructor and ensure that its value cannot be changed afterward.</p>
			<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor084" class="calibre6 pcalibre1 pcalibre"/>Which method of object comparison in C# is better to use, “==” or “Equals()”, and why?</h2>
			<p class="calibre3">For value types, <code>==</code> and <code>Equals()</code> usually work the same <a id="_idIndexMarker180" class="calibre6 pcalibre1 pcalibre"/>way, but for reference types, <code>==</code> checks for reference equality, not <a id="_idIndexMarker181" class="calibre6 pcalibre1 pcalibre"/>content. <code>Equals()</code> can be overridden for custom<a id="_idIndexMarker182" class="calibre6 pcalibre1 pcalibre"/> classes to ensure content-based comparison. As a rule, if you want to compare the content of objects, it’s better to use <code>Equals()</code>.</p>
			<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor085" class="calibre6 pcalibre1 pcalibre"/>What’s the primary distinction between “is” and “as” when converting types in C#?</h2>
			<p class="calibre3"><code>is</code> checks whether an object<a id="_idIndexMarker183" class="calibre6 pcalibre1 pcalibre"/> is an instance of a certain<a id="_idIndexMarker184" class="calibre6 pcalibre1 pcalibre"/> type and returns a Boolean value. <code>as</code> is used for safe type casting and will return <code>null</code> if the conversion is not possible, rather than throwing an exception.</p>
			<h2 id="_idParaDest-87" class="calibre7"><a id="_idTextAnchor086" class="calibre6 pcalibre1 pcalibre"/>What do explicit and implicit type conversions mean in C#?</h2>
			<p class="calibre3">Implicit-type conversion<a id="_idIndexMarker185" class="calibre6 pcalibre1 pcalibre"/> happens automatically when a data type that can hold less information is converted<a id="_idIndexMarker186" class="calibre6 pcalibre1 pcalibre"/> to one that can hold more (for example, from <code>int</code> to <code>double</code>). Explicit-type conversion (casting) is required when there’s a risk of data loss during the conversion.</p>
			<h2 id="_idParaDest-88" class="calibre7"><a id="_idTextAnchor087" class="calibre6 pcalibre1 pcalibre"/>What is the purpose of the "??" operator in C# and in which scenarios should it be used?</h2>
			<p class="calibre3">The <code>??</code> operator is a null-coalescing operator<a id="_idIndexMarker187" class="calibre6 pcalibre1 pcalibre"/> that returns the left operand if it’s not <code>null</code>; otherwise, it returns the right one. It’s useful for setting default values for potentially <code>null</code> values.</p>
			<h2 id="_idParaDest-89" class="calibre7"><a id="_idTextAnchor088" class="calibre6 pcalibre1 pcalibre"/>What are tuples, how are they used in C#, and what are their advantages compared to classes?</h2>
			<p class="calibre3">Tuples in C# are ordered<a id="_idIndexMarker188" class="calibre6 pcalibre1 pcalibre"/> collections of various types. They are useful for representing datasets without creating specific types. Compared to classes, tuples are typically lighter and more convenient for small, temporary datasets.</p>
			<p class="calibre3">In this section, we delved into the core components of C#—data types, variables, and operators, which form the backbone of any C# application. We explored the differences between value and reference types and examined string manipulations, alongside the initialization and handling of various arrays. We also discussed the role of bitwise and logical operators, the use of nullable types, and the principles of operator overloading. We touched upon important topics such as object comparison methods, type conversions, and the advantages of using tuples<a id="_idIndexMarker189" class="calibre6 pcalibre1 pcalibre"/> for compact data representation. With this solid foundation, we are ready to advance to the next section, <em class="italic">Writing control structures and loops in C#</em>, to further enhance our programming skills.</p>
			<h1 id="_idParaDest-90" class="calibre5"><a id="_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"/>Writing control structures and loops in C#</h1>
			<p class="calibre3">Control structures and loops<a id="_idIndexMarker190" class="calibre6 pcalibre1 pcalibre"/> are fundamental elements of any program, allowing developers<a id="_idIndexMarker191" class="calibre6 pcalibre1 pcalibre"/> to efficiently manage the flow of code execution. In the C# language, there is a variety of powerful tools for this purpose. In this section, we will delve into various control structures, such as conditional statements and selection, as well as key concepts of looping through data using different types of loops. Through an in-depth study of these elements, you’ll gain a solid foundation for writing efficient and structured code in C#. Let’s begin!</p>
			<h2 id="_idParaDest-91" class="calibre7"><a id="_idTextAnchor090" class="calibre6 pcalibre1 pcalibre"/>What are the main loops available in C# and how do you choose the best loop for a specific situation?</h2>
			<p class="calibre3">In C#, several types of loops<a id="_idIndexMarker192" class="calibre6 pcalibre1 pcalibre"/> are available: <code>for</code>, <code>foreach</code>, <code>while</code>, and <code>do-while</code>. Let’s look at each of them:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">for</strong>: This is the most commonly<a id="_idIndexMarker193" class="calibre6 pcalibre1 pcalibre"/> used loop when you know the number of iterations beforehand.</li>
				<li class="calibre11"><strong class="source-inline1">foreach</strong>: This type of loop is perfect<a id="_idIndexMarker194" class="calibre6 pcalibre1 pcalibre"/> for iterating through collections or arrays when you need to work with each element sequentially.</li>
				<li class="calibre11"><strong class="source-inline1">while</strong>: This loop executes as long as the specified<a id="_idIndexMarker195" class="calibre6 pcalibre1 pcalibre"/> condition is true. It’s useful when you don’t know the number of iterations beforehand.</li>
				<li class="calibre11"><strong class="source-inline1">do-while</strong>: This loop is similar to <strong class="source-inline1">while</strong>, but the condition<a id="_idIndexMarker196" class="calibre6 pcalibre1 pcalibre"/> is checked after executing the loop body, ensuring the loop body is executed at least once.</li>
			</ul>
			<p class="calibre3">Choosing the best loop depends on the specific situation. If you need to iterate over all elements of a collection, <code>foreach</code> would be the most convenient. If you know the number of iterations, <code>for</code> would be the most efficient. In cases where you don’t know the number of iterations in advance, you can use <code>while</code> or <code>do-while</code>, depending on whether you want the loop body to execute at least once or not.</p>
			<h2 id="_idParaDest-92" class="calibre7"><a id="_idTextAnchor091" class="calibre6 pcalibre1 pcalibre"/>How do you use the “if”, “else if”, and “else” operators in C#? In which situations would you recommend using each of them?</h2>
			<p class="calibre3">The <code>if</code>, <code>else if</code>, and <code>else</code> operators are<a id="_idIndexMarker197" class="calibre6 pcalibre1 pcalibre"/> used for<a id="_idIndexMarker198" class="calibre6 pcalibre1 pcalibre"/> conditional code<a id="_idIndexMarker199" class="calibre6 pcalibre1 pcalibre"/> execution. <code>if</code> checks a condition and, if it’s <code>true</code>, executes the code block following it. <code>else if</code> allows you to check additional conditions if the previous conditions were <code>false</code>. <code>else</code> executes a code block when none of the previous conditions were met. Use <code>if</code> to check a single primary condition, <code>else if</code> to check additional conditions, and <code>else</code> as a fallback code block to execute.</p>
			<h2 id="_idParaDest-93" class="calibre7"><a id="_idTextAnchor092" class="calibre6 pcalibre1 pcalibre"/>What’s the difference between “for” and “foreach” loops? In which cases is it better to use each?</h2>
			<p class="calibre3">The <code>for</code> loop is used when you know<a id="_idIndexMarker200" class="calibre6 pcalibre1 pcalibre"/> in advance how many times you need to execute the loop. The <code>foreach</code> loop is designed for iterating over collections, such as lists or arrays. Use <code>for</code> when you have a specific number of iterations, and <code>foreach</code> when you need to iterate over all elements in a collection.</p>
			<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor093" class="calibre6 pcalibre1 pcalibre"/>What is the “switch” operator and how is it different from a sequence of “if-else” operators?</h2>
			<p class="calibre3">The <code>switch</code> operator allows you to check<a id="_idIndexMarker201" class="calibre6 pcalibre1 pcalibre"/> a variable against multiple values. It is more compact and often more convenient for checking the values of a single variable. An <code>if-else</code> sequence, on the other hand, offers<a id="_idIndexMarker202" class="calibre6 pcalibre1 pcalibre"/> more flexibility as it can check different conditions, not being limited to just one variable.</p>
			<h2 id="_idParaDest-95" class="calibre7"><a id="_idTextAnchor094" class="calibre6 pcalibre1 pcalibre"/>What do the “continue” and “break” operators do in loops, and when can they be useful?</h2>
			<p class="calibre3"><code>continue</code> skips the current loop iteration<a id="_idIndexMarker203" class="calibre6 pcalibre1 pcalibre"/> and proceeds to the next one. <code>break</code> exits the loop<a id="_idIndexMarker204" class="calibre6 pcalibre1 pcalibre"/> prematurely. <code>continue</code> is useful when some loop iterations need to be skipped, and <code>break</code> when you need to terminate the loop execution under a certain condition.</p>
			<h2 id="_idParaDest-96" class="calibre7"><a id="_idTextAnchor095" class="calibre6 pcalibre1 pcalibre"/>How do you combine multiple conditions in a single “if” statement using logical operators?</h2>
			<p class="calibre3">You can use logical <a id="_idIndexMarker205" class="calibre6 pcalibre1 pcalibre"/>operators <code>&amp;&amp;</code> (<em class="italic">logical “and”</em>) and <code>||</code> (<em class="italic">logical “or”</em>) to combine multiple conditions, for example, <code>if (x &gt; 5 &amp;&amp; y &lt; </code><code>10) {...}</code>.</p>
			<h2 id="_idParaDest-97" class="calibre7"><a id="_idTextAnchor096" class="calibre6 pcalibre1 pcalibre"/>What is the peculiarity of the “do-while” loop compared to the regular “while” loop?</h2>
			<p class="calibre3">The primary difference<a id="_idIndexMarker206" class="calibre6 pcalibre1 pcalibre"/> is that in the <code>do-while</code> loop, the condition is checked<a id="_idIndexMarker207" class="calibre6 pcalibre1 pcalibre"/> after the loop body is executed, ensuring that the loop body runs at least once, regardless of the condition.</p>
			<h2 id="_idParaDest-98" class="calibre7"><a id="_idTextAnchor097" class="calibre6 pcalibre1 pcalibre"/>What does a nested loop look like and why can it be useful?</h2>
			<p class="calibre3">A nested loop is a loop placed inside<a id="_idIndexMarker208" class="calibre6 pcalibre1 pcalibre"/> another loop. It is often used for processing a two-dimensional array or matrix. See the following for an example:</p>
			<pre class="source-code">
for (int i = 0; i &lt; 3; i++)
{
    for (int j = 0; j &lt; 3; j++)
    {
        Console.WriteLine($"i = {i}, j = {j}");
    }
}</pre>
			<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"/>How can you prevent a potentially infinite loop execution?</h2>
			<p class="calibre3">To prevent an infinite<a id="_idIndexMarker209" class="calibre6 pcalibre1 pcalibre"/> loop, it’s crucial to ensure that a loop termination condition will be met. This can be done by checking conditions before entering the loop, using execution time limiters, or through internal counters and monitoring tools.</p>
			<h2 id="_idParaDest-100" class="calibre7"><a id="_idTextAnchor099" class="calibre6 pcalibre1 pcalibre"/>What is recursion in C# and how do you prevent stack overflow when using recursive methods?</h2>
			<p class="calibre3">Recursion is a technique<a id="_idIndexMarker210" class="calibre6 pcalibre1 pcalibre"/> where a method calls itself. To prevent stack overflow, it’s important<a id="_idIndexMarker211" class="calibre6 pcalibre1 pcalibre"/> to have a clear base case<a id="_idIndexMarker212" class="calibre6 pcalibre1 pcalibre"/> that will halt the recursive calls and to limit the recursion depth.</p>
			<h2 id="_idParaDest-101" class="calibre7"><a id="_idTextAnchor100" class="calibre6 pcalibre1 pcalibre"/>How can you optimize a loop for processing a large amount of data in C#?</h2>
			<p class="calibre3">To optimize a loop, you can use parallelism, employ <a id="_idIndexMarker213" class="calibre6 pcalibre1 pcalibre"/>efficient data structures, reduce the number of operations within the loop, and utilize caching where possible.</p>
			<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor101" class="calibre6 pcalibre1 pcalibre"/>What is “yield return” in C# and when can it be useful?</h2>
			<p class="calibre3"><code>yield return</code> allows you to create iterators<a id="_idIndexMarker214" class="calibre6 pcalibre1 pcalibre"/> without the need to generate an auxiliary collection. It’s useful when you want to lazily generate values as you iterate through a collection.</p>
			<h2 id="_idParaDest-103" class="calibre7"><a id="_idTextAnchor102" class="calibre6 pcalibre1 pcalibre"/>How do you create an infinite loop using “for”?</h2>
			<p class="calibre3">An infinite loop<a id="_idIndexMarker215" class="calibre6 pcalibre1 pcalibre"/> can be created<a id="_idIndexMarker216" class="calibre6 pcalibre1 pcalibre"/> using <code>for</code> in the following manner:</p>
			<pre class="source-code">
for(;;)
{
// loop code
}</pre>
			<p class="calibre3">Here, the condition, initialization, and increment are absent, so the loop will run indefinitely.</p>
			<p class="calibre3">In this section, we explored control structures and loops, essential tools for dictating the flow of code in C#. We discussed various loop types, such as <code>for</code>, <code>foreach</code>, <code>while</code>, and <code>do-while</code>, highlighting how to select the appropriate one depending on the task at hand. We also covered the usage and applications of conditional operators <code>if</code>, <code>else if</code>, and <code>else</code>. We examined the efficiency of the <code>switch</code> operator compared to that of a chain of <code>if-else</code> statements, and the roles<a id="_idIndexMarker217" class="calibre6 pcalibre1 pcalibre"/> of <code>continue</code> and <code>break</code> operators<a id="_idIndexMarker218" class="calibre6 pcalibre1 pcalibre"/> within loops. With this foundation, we are now prepared to delve into more advanced topics.</p>
			<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor103" class="calibre6 pcalibre1 pcalibre"/>Exploring the basics of OOP using C#</h1>
			<p class="calibre3">In this section, we turn our focus toward the basics of OOP<a id="_idIndexMarker219" class="calibre6 pcalibre1 pcalibre"/> using C#. As we venture further, we will unravel the core principles of OOP, a paradigm that facilitates organized and reusable code. Through C#, we will explore key OOP concepts such as classes, objects, inheritance, and polymorphism, fostering a deeper understanding and equipping you with the skills to craft robust and efficient applications. Let’s embark on this enlightening journey.</p>
			<h2 id="_idParaDest-105" class="calibre7"><a id="_idTextAnchor104" class="calibre6 pcalibre1 pcalibre"/>How does C# integrate the principles of OOP?</h2>
			<p class="calibre3">C# supports all the core<a id="_idIndexMarker220" class="calibre6 pcalibre1 pcalibre"/> principles of<a id="_idIndexMarker221" class="calibre6 pcalibre1 pcalibre"/> OOP: <em class="italic">encapsulation</em>, <em class="italic">inheritance</em>, <em class="italic">polymorphism</em>, and <em class="italic">abstraction</em>. For instance, classes and interfaces in C# allow for the implementation of inheritance and polymorphism, while access modifiers facilitate encapsulation.</p>
			<h2 id="_idParaDest-106" class="calibre7"><a id="_idTextAnchor105" class="calibre6 pcalibre1 pcalibre"/>How does encapsulation work in C#?</h2>
			<p class="calibre3">In C#, encapsulation is ensured through<a id="_idIndexMarker222" class="calibre6 pcalibre1 pcalibre"/> access modifiers such as <code>private</code>, <code>protected</code>, and <code>public</code>. These modifiers determine the visibility of class members, allowing for the hiding of implementation details and exposing only the necessary API.</p>
			<h2 id="_idParaDest-107" class="calibre7"><a id="_idTextAnchor106" class="calibre6 pcalibre1 pcalibre"/>How is polymorphism implemented in C#?</h2>
			<p class="calibre3">Polymorphism in C# is realized through the ability<a id="_idIndexMarker223" class="calibre6 pcalibre1 pcalibre"/> to override methods in subclasses using the <code>virtual</code> and <code>override</code> keywords, as well as through interfaces that allow different classes to have a consistent set of methods.</p>
			<h2 id="_idParaDest-108" class="calibre7"><a id="_idTextAnchor107" class="calibre6 pcalibre1 pcalibre"/>What does inheritance entail in C#?</h2>
			<p class="calibre3">Inheritance in C# allows<a id="_idIndexMarker224" class="calibre6 pcalibre1 pcalibre"/> for the creation of a new class based on an existing one, inheriting its attributes and behavior. This is achieved using the <code>:</code> keyword, followed by the name of the base class.</p>
			<h2 id="_idParaDest-109" class="calibre7"><a id="_idTextAnchor108" class="calibre6 pcalibre1 pcalibre"/>What is the difference between a class and its instance in C#?</h2>
			<p class="calibre3">A class serves as a schematic or prototype<a id="_idIndexMarker225" class="calibre6 pcalibre1 pcalibre"/> that delineates the characteristics and functions<a id="_idIndexMarker226" class="calibre6 pcalibre1 pcalibre"/> of objects. An object (or instance of a class) is a specific representation of that class with a unique set of attribute values.</p>
			<h2 id="_idParaDest-110" class="calibre7"><a id="_idTextAnchor109" class="calibre6 pcalibre1 pcalibre"/>Why are access modifiers such as “public”, “private”, “protected”, and “internal” used in C#?</h2>
			<p class="calibre3">These modifiers determine<a id="_idIndexMarker227" class="calibre6 pcalibre1 pcalibre"/> the level of access to class members. <code>public</code> makes a member accessible to any code; <code>private</code> restricts access to only the methods of the given class; <code>protected</code> allows access to the given class and its descendants, and <code>internal</code> makes a member accessible to any code within the same assembly.</p>
			<h2 id="_idParaDest-111" class="calibre7"><a id="_idTextAnchor110" class="calibre6 pcalibre1 pcalibre"/>Can a class in C# inherit from multiple other classes simultaneously?</h2>
			<p class="calibre3">No, C# does not support multiple inheritance for classes. However, a class can implement multiple interfaces.</p>
			<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor111" class="calibre6 pcalibre1 pcalibre"/>How do method overloading and method overriding differ in C#?</h2>
			<p class="calibre3">Method overloading allows having multiple versions<a id="_idIndexMarker228" class="calibre6 pcalibre1 pcalibre"/> of a single method in one class with different parameters. Method overriding allows a subclass to replace the implementation of a method provided by its base class.</p>
			<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"/>What are the main differences between interfaces and base classes in C#?</h2>
			<p class="calibre3">Interfaces define<a id="_idIndexMarker229" class="calibre6 pcalibre1 pcalibre"/> a contract (a set of methods without implementation) that must be adhered<a id="_idIndexMarker230" class="calibre6 pcalibre1 pcalibre"/> to by the class that implements it. Base classes contain an implementation that can be inherited and extended. A class can inherit only one base class but can implement multiple interfaces.</p>
			<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor113" class="calibre6 pcalibre1 pcalibre"/>Why is composition sometimes considered a better choice than inheritance?</h2>
			<p class="calibre3">Composition offers greater<a id="_idIndexMarker231" class="calibre6 pcalibre1 pcalibre"/> flexibility, allowing dynamic changes to an object’s behavior on the fly, and reduces the risk of issues associated with tight coupling between classes. It also promotes the principle of <em class="italic">composition over inheritance</em>, suggesting that using composition for the reusability of code is a more desirable approach.</p>
			<h2 id="_idParaDest-115" class="calibre7"><a id="_idTextAnchor114" class="calibre6 pcalibre1 pcalibre"/>What are properties in C# and how do they differ from fields?</h2>
			<p class="calibre3">Properties are a special kind of class<a id="_idIndexMarker232" class="calibre6 pcalibre1 pcalibre"/> member in C# that represents access to data with the ability to define logic when reading or writing that data. They allow you to control access to internal fields and can contain additional logic, for instance, for validation. Fields, on the other hand, are variables<a id="_idIndexMarker233" class="calibre6 pcalibre1 pcalibre"/> defined in the class and are used to store data.</p>
			<h2 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor115" class="calibre6 pcalibre1 pcalibre"/>What’s the main difference between abstract classes and interfaces in C#?</h2>
			<p class="calibre3">Abstract classes can contain methods<a id="_idIndexMarker234" class="calibre6 pcalibre1 pcalibre"/> both with and without implementation. They cannot be instantiated<a id="_idIndexMarker235" class="calibre6 pcalibre1 pcalibre"/> directly. Interfaces only contain method declarations without implementation. A class can implement multiple interfaces but can inherit only one abstract class.</p>
			<h2 id="_idParaDest-117" class="calibre7"><a id="_idTextAnchor116" class="calibre6 pcalibre1 pcalibre"/>Why is encapsulating fields important for the SOLID principles?</h2>
			<p class="calibre3">Encapsulation helps keep the internal<a id="_idIndexMarker236" class="calibre6 pcalibre1 pcalibre"/> state of an object protected and hidden from the external world, which supports adherence to the <em class="italic">Open/Closed Principle</em> of SOLID. It also helps prevent unwanted state changes that could violate the <em class="italic">Single </em><em class="italic">Responsibility Principle</em>.</p>
			<h2 id="_idParaDest-118" class="calibre7"><a id="_idTextAnchor117" class="calibre6 pcalibre1 pcalibre"/>What is the role of delegates in OOP in the context of C#?</h2>
			<p class="calibre3">Delegates in C# are objects<a id="_idIndexMarker237" class="calibre6 pcalibre1 pcalibre"/> that can point to methods. They allow for the realization of the function pointers concept in a type-safe manner. Delegates are often used to implement events and callbacks.</p>
			<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor118" class="calibre6 pcalibre1 pcalibre"/>How are constructors used for object initialization and how do they differ from static constructors?</h2>
			<p class="calibre3">Constructors help initialize an object<a id="_idIndexMarker238" class="calibre6 pcalibre1 pcalibre"/> at the time of its creation, setting the necessary state or performing any other required setup. Static constructors<a id="_idIndexMarker239" class="calibre6 pcalibre1 pcalibre"/> are used to initialize static members of a class or to perform actions that should occur only once for the class, not for each individual object.</p>
			<h2 id="_idParaDest-120" class="calibre7"><a id="_idTextAnchor119" class="calibre6 pcalibre1 pcalibre"/>What do aggregation and association mean in OOP, and how are they implemented in C#?</h2>
			<p class="calibre3"><strong class="bold">Aggregation</strong> and <strong class="bold">association</strong> represent two distinct relationships<a id="_idIndexMarker240" class="calibre6 pcalibre1 pcalibre"/> between classes within the OOP paradigm. Association<a id="_idIndexMarker241" class="calibre6 pcalibre1 pcalibre"/> denotes a broader connection between two classes, indicating that one class incorporates the other.</p>
			<p class="calibre3">Let me show some examples of how they are implemented:</p>
			<ul class="calibre10">
				<li class="calibre11">Association is a bi-directional relationship<a id="_idIndexMarker242" class="calibre6 pcalibre1 pcalibre"/> between two classes. Here, we demonstrate a one-to-many association between a <strong class="source-inline1">Library</strong> class and a <strong class="source-inline1">Book</strong> class:<pre class="source-code">
public class Book</pre><pre class="source-code">
{</pre><pre class="source-code">
    public string Title { get; set; }</pre><pre class="source-code">
}</pre><pre class="source-code">
public class Library</pre><pre class="source-code">
{</pre><pre class="source-code">
    public List&lt;Book&gt; Books { get; set; }</pre><pre class="source-code">
    public Library()</pre><pre class="source-code">
    {</pre><pre class="source-code">
        Books = new List&lt;Book&gt;();</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre><p class="calibre3">In the preceding code, the <code>Library</code> class has a list of <code>Book</code> objects, illustrating a one-to-many association.</p></li>
				<li class="calibre11">Aggregation represents a relationship<a id="_idIndexMarker243" class="calibre6 pcalibre1 pcalibre"/> where one class is a part of another class. Here, we illustrate an aggregation between a <strong class="source-inline1">Car</strong> class and an <strong class="source-inline1">Engine</strong> class:<pre class="source-code">
public class Engine</pre><pre class="source-code">
{</pre><pre class="source-code">
    public string Model { get; set; }</pre><pre class="source-code">
}</pre><pre class="source-code">
public class Car</pre><pre class="source-code">
{</pre><pre class="source-code">
    public Engine CarEngine { get; set; }</pre><pre class="source-code">
    public Car(Engine engine)</pre><pre class="source-code">
    {</pre><pre class="source-code">
        CarEngine = engine;</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre><p class="calibre3">In this example, the <code>Car</code> class contains<a id="_idIndexMarker244" class="calibre6 pcalibre1 pcalibre"/> an <code>Engine</code> object, demonstrating an aggregation relationship where the <code>Engine</code> class represents a part of the <code>Car</code> class.</p></li>
			</ul>
			<p class="calibre3">Through these examples, we can see how both association and aggregation relationships can be implemented in C# using class properties and constructors.</p>
			<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor120" class="calibre6 pcalibre1 pcalibre"/>How can multiple inheritance be implemented in C# if there is no direct support?</h2>
			<p class="calibre3">In C#, there’s no direct support for<a id="_idIndexMarker245" class="calibre6 pcalibre1 pcalibre"/> multiple inheritance. However, multiple inheritance can be realized using interfaces. A class can implement multiple interfaces that may come from different sources.</p>
			<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor121" class="calibre6 pcalibre1 pcalibre"/>What does the principle of “composition over inheritance” mean and when is it useful?</h2>
			<p class="calibre3"><strong class="bold">Composition</strong> over <strong class="bold">inheritance</strong> is a software design approach<a id="_idIndexMarker246" class="calibre6 pcalibre1 pcalibre"/> that encourages the use of composition (where objects utilize other objects) over inheritance for code reusability. It can be useful when a class’s behavior requires dynamic changes or when inheritance might lead to undesired rigid coupling between classes.</p>
			<h2 id="_idParaDest-123" class="calibre7"><a id="_idTextAnchor122" class="calibre6 pcalibre1 pcalibre"/>Why are exceptions in C# considered objects, and how do you create your own exception class?</h2>
			<p class="calibre3">In C#, exceptions are implemented<a id="_idIndexMarker247" class="calibre6 pcalibre1 pcalibre"/> as objects that inherit from the base <code>Exception</code> class. This allows for passing additional information about the exception and creating custom exception types. To create<a id="_idIndexMarker248" class="calibre6 pcalibre1 pcalibre"/> your own exception class, simply inherit it from the <code>Exception</code> class or one of its subclasses.</p>
			<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor123" class="calibre6 pcalibre1 pcalibre"/>What is the purpose of the “base” keyword in the context of inheritance in C#?</h2>
			<p class="calibre3">The <code>base</code> keyword allows you to call members<a id="_idIndexMarker249" class="calibre6 pcalibre1 pcalibre"/> from the base class when in a derived class. It is most commonly used in derived classes to call the constructor of the base class or to access other base class members that were overridden in the derived class.</p>
			<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor124" class="calibre6 pcalibre1 pcalibre"/>How is the “this” keyword used in C#?</h2>
			<p class="calibre3">The <code>this</code> keyword points to the present instance<a id="_idIndexMarker250" class="calibre6 pcalibre1 pcalibre"/> of the class. It is often used to point to the fields or methods of the current object, especially when method parameter names overlap with class field names.</p>
			<p class="calibre3">We’ve reached the end of our journey through the basics of C# and OOP in this chapter. With a strong foundation established, you’re well-equipped to tackle the most common C# coding scenarios in your technical interviews.</p>
			<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor125" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
			<p class="calibre3">In this chapter, we dove deep into key concepts, explored data types, variables, and operators, dissected control structures and loops, and discovered the basics of OOP. However, becoming proficient in C# is a continuous learning journey.</p>
			<p class="calibre3">As we turn the page, we’ll start navigating the more advanced terrain of C# programming in the next chapter. <a href="B20871_04.xhtml#_idTextAnchor127" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced C# Concepts</em>, will bring light to the advanced facets of C#, including working with collections, LINQ, exception handling, debugging, asynchronous programming, and a lot more.</p>
			<p class="calibre3">We will unravel the complexities of C# and learn how to make the best use of its capabilities to solve more intricate problems and enhance application performance. From creating reusable code with generic classes, methods, and interfaces to diving deep into multithreading and garbage collection, we’ll gear you up for a higher level of programming challenges. Remember, each concept is a stepping stone, leading you to master the art of C# programming. So, buckle up for the next exciting chapter in your learning journey!</p>
			<h1 id="_idParaDest-127" class="calibre5"><a id="_idTextAnchor126" class="calibre6 pcalibre1 pcalibre"/>Additional reading</h1>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">C# 12 and .NET 8 – Modern Cross-Platform Development Fundamentals - Eighth Edition,</em> by Mark J. Price <p class="calibre3"><a href="https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870" class="calibre6 pcalibre1 pcalibre">https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870</a></p></li>
				<li class="calibre11"><em class="italic">Refactoring with C#,</em> by Matt Eland<p class="calibre3"><a href="https://www.packtpub.com/product/refactoring-with-c/9781835089989" class="calibre6 pcalibre1 pcalibre">https://www.packtpub.com/product/refactoring-with-c/9781835089989</a></p></li>
			</ul>
		</div>
	</body></html>