- en: Chapter 11. F# Expert Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we've dealt mostly with customary F# facilities that constitute
    the core of successful F# idiomatic use in diverse application fields. The common
    sign of (almost) all of the related usage patterns is that they are straightforward
    and ordinary. Their mastery is a must for any intermediate level F# practitioner.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I'm going to step out of the regular space where expressions
    always yield results, calculations take place sequentially, and code must be first
    written in order to be later used. I will walk you through some of expert level
    F# techniques, the area of exciting usage patterns that is often considered overcomplicated
    and error-prone in nonfunctional paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter I will cover the following topics in the context of F# idiomatic
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: Type providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will approach each of these subjects by giving a brief overview accompanied
    with a concise usage sample taken from the enterprise trenches. I will attempt
    to show that these features are not really mind-bending and usually offer developers
    a strong safety net. However, please do not expect any sort of deep dive into
    these subjects. Consider the contents of this chapter more a roadmap to become
    skillful in these F# use patterns, as stimuli and practical application teasers.
  prefs: []
  type: TYPE_NORMAL
- en: A note on custom computation expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've decided not to cover arbitrary **F# Computation Expressions** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions)
    ) in this book despite F# itself having this mechanism baked in under the hood
    of significant language features, such as *sequence expressions* (covered in [Chapter
    6](text00053.html#ch06 "Chapter 6.  Sequences - The Core of Data Processing Patterns")
    , *Sequences - The Core of Data Processing Patterns* ), *query expressions* (covered
    in [Chapter 9](text00068.html#ch09 "Chapter 9. More Data Crunching") , *More Data
    Crunching* ), and *asynchronous expressions* (to be addressed in this chapter).
    Although custom computation expressions allow crafting very elegant code in some
    cases, I feel that covering this feature here may divert us from the practicality
    path we are pursuing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Those of you interested in a solid understanding and mastery of the F# computation
    expressions may turn to this excellent detailed reading on the subject by Scott
    Wlaschin: **The "Computation Expressions" series** ([https://fsharpforfunandprofit.com/series/computation-expressions.html](https://fsharpforfunandprofit.com/series/computation-expressions.html)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring type providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frankly, I consider **type providers** as one of the most exciting, powerful,
    and pragmatic F# features. Ability to apply type providers is, in my opinion,
    among the strongest arguments for the usage of F# in enterprise software development.
  prefs: []
  type: TYPE_NORMAL
- en: The feature review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type providers in F# represent a pretty unique *practical* pattern of manipulating
    various data sources in a strongly typed manner. This manipulation is accomplished
    via types, methods, and properties that were derived from the data source features
    and built at compile-time in a fully automated fashion. The developer is not required
    to author and/or maintain these automatically *provided* data manipulation means.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of automatic code generation itself is as old as pyramids, but what
    makes the difference is versatility, ease of usage, and a painless experience.
    Those who've ever wrestled with **SqlMetal** ([https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx)
    ) or **WSDLTool** ([https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx](https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx)
    ) would appreciate the way of type providers a lot.
  prefs: []
  type: TYPE_NORMAL
- en: It is also true that *creating* a useful type provider of production quality
    may require a lot of skill and effort. Nevertheless, once created, the type provider
    component can be used without any limits, so the usage benefits overweigh the
    construction pains by many times.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that since the introduction of type providers in
    F# 3.0, many valuable data source kinds have already been covered. Since the initial
    wave of type provider construction mentioned in **Twelve F# type providers in
    action** ([https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/](https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/)
    ), the available providers have gotten significantly more mature, providing a
    slick and smooth usage experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough talking; let''s first take a look at the big picture of F# type provider
    workings. This is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The feature review](img/Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: F# type provider workings
  prefs: []
  type: TYPE_NORMAL
- en: 'Without pretending to cover all potential external data sources, I am mentioning
    the following ones here:'
  prefs: []
  type: TYPE_NORMAL
- en: Files of many specific formats (Excel, comma-separated, JSON, and so on) frequently
    utilized in enterprise development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database engines (Microsoft SQL Server, Oracle, MySQL, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variety of web APIs implementing different protocols and data presentation
    formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variety of application engines (Python, R, MatLab, and so on) that can be
    remotely controlled in order to implement the desired processing and yielding
    results being given input data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The magic begins at compile-time, when the developer references code type(s)
    that are expected to be provided from the given data source(s) within the F# application:
    results of a given query against a database, tabular data from some Excel file,
    clustering results of certain data; you name it. The F# compiler needs the corresponding
    type provider(s) to be available in the form of library packages. Reaching out
    to given data sources for the required metadata at compile-time, the type provider
    in concert with the F# compiler builds provided types, methods, and properties
    that allow you to treat external data on the fly in a strongly typed manner.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, **SQLClient type provider** ([http://fsprojects.github.io/FSharp.Data.SqlClient](http://fsprojects.github.io/FSharp.Data.SqlClient)
    ) takes compile-time connection strings, connects *during compilation* to the
    given data engine instance, and having the text of the given query in T-SQL on
    hand uses certain system stored procedures in order to find types associated with
    the columns of the to-be-returned result set. This type information translates
    into a built-on-the-fly type associated with the query. As a result, if we are
    compiling under Visual Studio, we are getting Intellisense with regard to the
    fields associated with the result set that is present as the F# sequence of the
    compiler-provided type.
  prefs: []
  type: TYPE_NORMAL
- en: If at run-time we shoot the same query against *some other* data engine that
    has data with table schemas similar to the table(s) participating in the compiled
    query, the provided data access type will still be good for data transformations.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that the correspondence between database schemas
    and the query associated with the provided type is kept under static typing scrutiny;
    if any part of this equation (either the query expression or the involved schemas)
    changes, the code simply does not compile.
  prefs: []
  type: TYPE_NORMAL
- en: This is simultaneously a fault and a blessing as it reliably protects from potential
    mishaps between the application code and the data layer. However, the necessity
    of having access to the SQL data engine at compile-time complicates arrangements
    such as builds, continuous integration, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I am a big fan of the aforementioned type provider and found it
    interesting that often, people do not realize the delineation that exists between
    compile-time and run-time and effectively confining the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some developers ask from time to time whether the query associated with the
    provided type can be changed at run-time. Apparently, the answer is a big *no*
    as that would require you to change the already generated type-specific code.
    At the same time, it is just fine (and expected) to change the connection string
    at run-time in order to access the target data engine where the data to be processed
    resides. Usually, the latter may be achieved with the provided type constructor
    having the run-time connection string as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to use this type provider for demo purposes later in this chapter,
    so you will have a chance to check your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: The demo problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When picking a demo problem for type provider subject, I was initially doubtful
    whether it''s feasible to delve into the type provider creation process or whether
    this book''s format limits me to using only the existing type providers. I even
    solicited an opinion from a group of colleagues on whether it''s possible to implement
    a practically sound type provider not exceeding 20 lines of F# code. The answer
    turned out to be affirmative, thanks to one of the authors of the aforementioned
    SQLClient type provider, who pointed out the interesting side problem this provider
    brought to light: the relationship between SQL code and the F# code.'
  prefs: []
  type: TYPE_NORMAL
- en: From the separation of concerns standpoint, it is not an impeccable proposition
    to have T-SQL queries belonging to an application embedded into the F# code as
    literals. Ideally, it would be great to keep these queries separately from the
    F# code in a separate SQL script directory, having designated `.sql` file per
    each query. But how can such an arrangement be possible if we need the contents
    of these files to be represented as string literals in the application code at
    compile-time?
  prefs: []
  type: TYPE_NORMAL
- en: Eureka! The way out would be using just another type provider!
  prefs: []
  type: TYPE_NORMAL
- en: An internal "file reader" type provider may associate a corresponding *provided*
    type with the SQL query text stored there as a literal field with each SQL query
    file at compile-time. The literal field does not anyhow differ from the literal
    string constant in the text. Such an elegant approach indeed!
  prefs: []
  type: TYPE_NORMAL
- en: Taking into account an apparent didactic value behind this clear delineation
    between compile-time and run-time considerations, I decided to come up with something
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to protect the execution of an application with a secret
    key but do not want to have the key value present anywhere in the source code.
    Instead, the secret may be kept in a key vault of some sort and be associated
    with the application only during the build. The deficiency of such protection
    is apparent as the secret value would be still present somewhere in the compiled
    application assembly. But that is not the point of the exercise. The requirement
    is this: there should be no secret key value in the source code.'
  prefs: []
  type: TYPE_NORMAL
- en: The demo solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our solution would be to create a type provider that, given a reference to the
    external repository that contains the secret key, would provide a type with the
    `string` secret value extracted from the repository and stored as a literal field.
    This means that such a field can be used as a case value in the `match...with`
    F# expression without revealing the underlying value in any manner. Also, you
    would acquire a firm understanding of the inner type provider workings as well
    as a sticky pattern to recall each time when in doubt about what activity happens
    when in type providing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m ready to jump upon the implementation. Writing a type provider in 2016
    is a breeze compared to how it was in 2012, when the feature was first delivered
    to the masses. Thanks to the open source effort of the amazing F# community for
    assembling together and packaging a sort of SDK in the form of the NuGet package
    for the creation of F# type providers, namely **FSharp.TypeProviders.StarterPack **
    ([https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack](https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack)
    ). Bear with me. Just perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Shoot out a new Visual Studio project to create the F# library named **KeyTypeProvider**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get rid of the two generated files with the `.fs` and `.fsx` extensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using **Package Manager Console** , add the Type Provider Starter Pack NuGet
    package to the just created project, issuing the `Install-Package FSharp.TypeProviders.StarterPack`
    command and observing a bunch of source code files added to the project (`ProvidedTypes.fsi`
    , `ProvidedTypes.fs` , and `DebugProvidedTypes.fs` ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new F# source code file named `KeyTypeProvider.fs` and place it *below*
    the last of injected files listed in the previous bullet (remember that the order
    in which the F# source code files are introduced to the compiler matters a lot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it; we are ready to craft the type provider code into the latter file.
    I am placing the snippet with the corresponding code as follows (`KeyTypeProvider.fs`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's not exactly 20 lines of code, but it's quite close. I will just outline
    the purpose of the bits and pieces in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Those of you willing to tinker with the code of such sort may walk through
    **Tutorial: Creating a Type Provider** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider)
    ) as a supplementary helper.'
  prefs: []
  type: TYPE_NORMAL
- en: After referring the pertinent libraries, the definition of our `KeyStringProvider`
      *type provider type* (yes, type provider has its own type, sure thing) follows
    decorated with the `[<TypeProvider>]` attribute and inherited from the `TypeProviderForNamespaces`
    type, which is defined elsewhere in these auto-inserted code files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three lines of code define the name and location of the provided type:
    `FSharp.IO.SecretKey` and the run-time assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: The body of the following `do` expression is the meat of the implementation.
    It defines that the provided type will have a single `Path` static parameter of
    type `string` , and most importantly, upon instantiation, the provider will read
    the text contained in the file referred by the `Path` and make the ingested string
    the value of the provided type's literal static field named `Key` . Right, I agree
    that the local text file is not the most reliable of key vaults, but this design
    choice is taken for brevity; the way the secret is kept is completely irrelevant
    to the subject. This part may be implemented in principle in any other manner.
  prefs: []
  type: TYPE_NORMAL
- en: The final `do()` expression decorated with the `[<assembly:TypeProviderAssembly()>]`
    attribute is just a type provider-specific assembly marker for the .NET assembly-loading
    machinery.
  prefs: []
  type: TYPE_NORMAL
- en: We are done. Building our project should produce `KeyTypeProvider.dll` in the
    target `bin` directory. Our type provider is ready to be put to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve created the following short F# script for this purpose (`Ch11_2.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for this script to compile, it is required that you put the `Secret.txt`
    file referred in the type declaration of `Vault` using our demo provided type,
    `FSharp.IO.SecretKey` , into the project directory side by side with the preceding
    script in the file system. As soon as we do this, Intellisense in Visual Studio
    begins working, which is reflected in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The demo solution](img/Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Local file contents packaged as a type's static field literal value
  prefs: []
  type: TYPE_NORMAL
- en: Note that the type provider revealed the contents of the secret (the `ABigSecret`
    string line) at compile-time via Intellisense. Nevertheless, the secret is not
    present in the source code whatsoever. Also, having the secret referred to as
    a `Vault.Key` case of the `function` expression without any objections from the
    F# compiler clearly indicates that the compiler fully buys into it being a genuine
    literal string!
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to see how all this plays outside of the type provider development
    environment, within a separate FSI session. The results are presented in the following
    screenshot and are fully aligned with the expectations. Just recollect the workings
    of this fun F# type provider application every time you feel any confusion about
    the type provider pattern applicability and abilities it should help you sort
    things out.
  prefs: []
  type: TYPE_NORMAL
- en: '![The demo solution](img/Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the SecretKey type provider from the FSI script
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up, F# type providers represent a rather unique idiomatic feature of
    automatic types generation that may deliver significant boosts in productivity
    and code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring concurrent computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To a great extent, the reinvigorated industrial attention on functional programming
    after many years of increased academic interest stems from the achieved capacities
    of electronics. On the one hand, the capabilities of contemporary computers make
    computer science findings considered more of a pure science savor thirty years
    ago quite practical today owing to an enormous increase in the speed and capacity
    of calculations. On the other hand, at the silicon level, the science has hit
    the physical limit for the further speeding-up of a single processor core operation.
    So the practical computation speed-up is happening along the lines of splitting
    a given amount of calculations between a group of processors working in a close
    concert.
  prefs: []
  type: TYPE_NORMAL
- en: The feature review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thing is that the brave new world of cheap multicore processors cannot afford
    expensive, error-prone, mentally onerous methods of programming. It is demanding
    the concurrency taming abstractions of a much higher level than the programming
    primitives for it that were developed by computer science in the era of the extensive
    growth of computing power.
  prefs: []
  type: TYPE_NORMAL
- en: These primitives have played their role in exposing the major problem behind
    concurrent calculations - such calculations are much less deterministic than we
    are accustomed to by dealing with sequential calculations. If the indeterminism
    in sequential calculations is usually associated with the imperfections of ambient
    physical environment materializing the former, the lack of determinism in concurrent
    calculations is intrinsic. This means that error-prone manipulation of programming
    primitives for synchronization between multiple co-executed calculations offers
    plenty of ways to shoot yourself in the foot.
  prefs: []
  type: TYPE_NORMAL
- en: The most prominent example of self-imposed indeterminism is **deadlock** ([https://en.wikipedia.org/wiki/Deadlock](https://en.wikipedia.org/wiki/Deadlock)
    ) when concurrent program parts lacking proper synchronization over shared resources
    may, under some conditions, mutually lock each other.
  prefs: []
  type: TYPE_NORMAL
- en: Much trickier (and potentially much more dangerous) are cases where the concurrent
    code may misbehave only under extremely rare conditions. This may be really dangerous
    because such conditions may not introduce themselves during quality assurance
    and user acceptance testing. Then, the defective code basically carrying a "bomb"
    gets released into production, and in full accordance with Murphy's Law, blows
    up at the most inappropriate obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: The functional programming promise for better quality concurrent programs is
    so dear to the industry today that many mainstream programming languages are getting
    supplied with add-on functional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look deeper into what F# offers to tame concurrency indeterminism,
    let''s take a look at the distinctive facets under the common concurrency umbrella
    that are important to recognize:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous and asynchronous** : The first one, given a few expressions to
    evaluate, does not start the evaluation of the next expression before the previous
    one has been evaluated. The second one allows you to move between some half-evaluated
    expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent and parallel** : Parallelism assumes simultaneous evaluation of
    more than one expression using multiple processing units, while concurrency may
    be asynchronous partial evaluation of a few expressions by a single processing
    unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interactive and reactive** : The former drives the external environment,
    while the latter responds to external environment demands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F# offers usage patterns taming concurrency using a uniform mechanism of **asynchronous
    expressions/workflows** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows)
    ). Concisely, an asynchronous expression, which is a particular specific form
    of the computation expression mentioned earlier, is written in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It has the generic type of `Async<'T>` . In turn, the `Async` class has a bunch
    of functions that trigger actual asynchronous evaluation of the preceding expression
    following a few scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very elegant and straightforward mechanism indeed. It allows you
    to conceal the fact that evaluation is going to be concurrent behind familiar
    forms of function composition. For example, take into account this innocuous code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It performs a rather loaded function composition with intermediary types presented
    as line comments, where the first line using a list comprehension expression yields
    a `list` of `Async<int>` , which then with the help of the `Async.Parallel` combinator
    fans out into `Async<int []>` parallel calculations that, in turn, with another
    `Async.RunSynchronously` combinator, join their asynchronously calculated expressions
    into the `int []` array of results, yielding 10 numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I will not attempt to prove to you that the preceding snippet will allow you
    to demonstrate performance gains from calculation parallelization. The preceding
    evaluation is so simple that the parallel snippet must in fact be *slower* than
    just sequential calculation analog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is because the parallel CPU asynchronous arrangement should introduce an
    overhead in comparison with a straightforward sequential list comprehension evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: However, it all changes when we step into territory that is dear to enterprise
    development, namely begin dealing with parallel I/O. Performance gains from the
    I/O parallelization are going to be the subject of the following demo problem
    illustrating the design pattern enabled by F# asynchronous calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The demo problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let me build an I/O-bound application that would allow the demonstration of
    a really overwhelming speedup when F# parallel I/O async pattern is applied. A
    good use case for this would be SQL Server with its scaling capabilities allowing
    you to reach persuasive improvements in comparison with multiple demos of concurrent
    web requests that F# authors and bloggers usually provide.
  prefs: []
  type: TYPE_NORMAL
- en: As an asynchronous concurrency vehicle, I'll be using the feature of the `FSharp.Data.SqlClient`
    type provider's **SQLCommandProvider** ([https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs](https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs)
    ), which allows asynchronous querying with the help of the `AsyncExecute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: I will create synchronous and asynchronous implementations of the same task
    of extracting data from SQL Server and then carrying out a performance comparison
    to detect and measure gains secured by F# asynchronous I/O usage pattern application.
  prefs: []
  type: TYPE_NORMAL
- en: The demo solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of conciseness, the SQL-related part is going to be extremely
    simple. Executing the following T-SQL script against the instance of the `(localdb)\ProjectsV12`
    database engine accompanying the installation of Visual Studio 2013 or any other
    Microsoft SQL Server installation available to you, given it fulfills the type
    provider **system requirements** ([http://fsprojects.github.io/FSharp.Data.SqlClient/](http://fsprojects.github.io/FSharp.Data.SqlClient/)
    ), will create the necessary database components from scratch (`Ch11_1.sql` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the part marked `(1)` creates and prepares for use the instance of the
    `demo` database, and the part marked `(2)` puts the `dbo.MockQuery` stored procedure
    into this database. This stored procedure, which lacks input arguments, implements
    an extremely simple query. Specifically, first, it introduces a time delay of
    1 second, mocking some data search activity and then it returns a single data
    row with the integer `1` as the execution result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I turn to commenting the F# script for the demo solution (`Ch11_1.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider that the preceding F# code taken literally will not compile because
    of a few line wraps introduced by typesetting. Instead, use the code part accompanying
    the book as the source of working F# code.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the type provider package and opening the required libraries,
    the `connStr` value decorated with the `[<Literal>]` attribute signifies both
    design-time and execution-time SQL server connection strings. This line might
    require modifications if you are using some other version of database engine.
  prefs: []
  type: TYPE_NORMAL
- en: The next line delivers the type provider magic by introducing the `SqlCommandProvider`
    provided type `Mock` ensuring statically typed access to the results of the wrapped
    query that is represented by the stored procedure call, `exec MockQuery` , over
    our `connStr` connection string.
  prefs: []
  type: TYPE_NORMAL
- en: The following `querySync` function ensures sequential execution of the `cmd`
    command represented by the instance of the provided `Mock` type given the number
    of times `nReq` yields a sequence of query results (each is just `1` from the
    single row of the result set) and then aggregates this sequence with `Seq.sum`
    . If we evaluate the `querySync 10` expression, we may expect a bit above a 10
    second delay in getting back a single number, `10` .
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. The following `query` function takes any argument and returns
    an asynchronous computation of type `Async<int>` . I put this function within
    the combined expression wrapped into the `queryAsync` function, effectively representing
    the concurrent variant of `querySync` . Specifically, the array of `nReq` numbers
    is mapped into an `Async<int>` array of the same size, and then they are all fanned
    out by `Async.Parallel` , joined back after completion with `Async.RunSynchronously`
    and eventually aggregated by `Array.sum` into a single number.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece is an instrumentation higher-order `timing` function that just
    measures and outputs the evaluation of the `f args` computation duration in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright; now, it is time to take our script for a spin. I put the code into
    FSI and measure the duration of executing `querySync` and `queryAsync` 100 times.
    You can see the measurement results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The demo solution](img/Image00056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Measuring synchronous versus asynchronous SQL querying
  prefs: []
  type: TYPE_NORMAL
- en: Are you as impressed as I am? Results show that I/O parallelization in the case
    of SQL queries allowed improved performance approximately 100-fold!
  prefs: []
  type: TYPE_NORMAL
- en: This demo is quite persuasive and I strongly recommend that you master and use
    this and other F# idiomatic concurrency patterns in your practical work.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring reactive computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive computations are the part of concurrent computations' scope. They just
    stress a slightly different matter, namely the processing of general events. The
    processing of events may be genuinely concurrent, when one or more of simultaneously
    occurring events are processed without any sort of serialization or genuinely
    sequential if a new event is not processed until the processing of the previous
    one has finished.
  prefs: []
  type: TYPE_NORMAL
- en: The feature review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, the event processing view akin to concurrency takes roots at the development
    of the systems that have **user interface** ( **UI** ) component(s) when sluggish
    processing of data coming from input devices and/or data reflecting the visual
    state of graphic UI components is simply unacceptable as it creates a terrible
    **user experience** ( **UX** ).
  prefs: []
  type: TYPE_NORMAL
- en: This is all good and true, but let's concentrate on an aspect not directly related
    to UI/UX, namely the conceptual consideration of **event processing** taking place.
    As this consideration is tied to F#, I will limit the review with .NET boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the development of interactive operating systems such as Windows coined
    the concept of **callback** ([https://en.wikipedia.org/wiki/Callback_(computer_programming)](https://en.wikipedia.org/wiki/Callback_(computer_programming))
    ), which brought to consideration **events** and **event handlers** . This is
    the lowest conceptual level of reactive programming, where the developer's responsibility
    is to provide the handlers for each event class.
  prefs: []
  type: TYPE_NORMAL
- en: The next abstraction level in reactive computations came with object-oriented
    programming and is manifested by the  **Observer design pattern** ([https://en.wikipedia.org/wiki/Observer_pattern](https://en.wikipedia.org/wiki/Observer_pattern)
    ). Now, the developer may think of a specific event type processing flow as an
    interaction between the event type (in other words, **subject** ) source named
    **Observable** and zero or more parties interested in the processing of this subject
    event named **Observers** . Observers manifest their interest in the subject by
    dynamically **registering** and **unregistering** with the corresponding Observable.
    As soon as the next event belonging to the subject comes into existence, all Observers
    registered at the moment with the corresponding Observer get notified about the
    chance of processing the event and then continue waiting for the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the conceptual quintessence for reactive computations took place with
    the seminal work of a group headed by computer scientist **Erik Meijer** ([https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)](https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist))
    ), who created **Reactive Extensions (Rx) for .NET** ([https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: The key idea behind Rx is concentrating on **pushing** versus **pulling** data
    sequences by introducing a fundamental `IObservable` interface that is a reversal
    of `IEnumerable` in the way it exposes the event data stream. This is similar
    to how "normal" data sequences, after being enumerated, can be pulled-composed
    by higher-order functions and queried using LINQ--and observable event sequences
    (event streams) may be received--composed with higher-order functions and processed
    by LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: F# supports all three of the preceding abstractions, throwing in some improvements
    in comparison with other programming languages of the .NET platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This subject matter is very well documented and I refer you to related F#-specific
    documentation on the `Microsoft.FSharp.Control` namespace pieces and `Reactive
    Extensions (Rx)` for details: **Event module** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d)
    ). **Observable module** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d)
    ). **Reactive Extensions** ([https://msdn.microsoft.com/en-us/data/gg577609.aspx](https://msdn.microsoft.com/en-us/data/gg577609.aspx)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of retelling the preceding documentation, I will take F# reactive computation
    features for a spin, implementing a relevant practical task. I will try to make
    the implementation self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: The demo problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider the following **integration pattern ** ( [http://www.enterpriseintegrationpatterns.com/patterns/messaging/](http://www.enterpriseintegrationpatterns.com/patterns/messaging/)
    ) that is quite typical for the enterprise: document message exchange over two
    point-to-point channels. We are a client of an external service that communicates
    with us using a pair of dedicated channels. If we need to send a document message,
    we just push it into the outbound channel and the remote service somehow consumes
    it. If the service sends a message(s) back to us, they are delivered into the
    inbound channel. As soon as we pull a document message from the inbound channel,
    it gets removed from there. The following figure illustrates this interaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The demo problem](img/Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enterprise two-way document exchange
  prefs: []
  type: TYPE_NORMAL
- en: Those of you who get involved in Enterprise LOB development have perhaps already
    recognized a typical case of peer-to-peer **Electronic Data Interchange (EDI)**
    ([https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer](https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer)
    ). Often, providers are quite conservative in choosing specific transfer protocols
    and prefer sticking to "old but gold" technologies such as **SSH File Transfer
    Protocol (SFTP)** ([https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol](https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol)
    ) for a reasonably inexpensive way of integration when data security is a requirement.
    As an enterprise may be involved into EDI with multiple remote service providers,
    the amount of such arrangements may be quite significant.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, I'm not going to concentrate on building a configurable library
    that allows the addition of a new EDI provider with a few lines of code. Instead,
    I will address the semantics layer that usually stands outside of architectural
    considerations, namely relations that may need to be enforced between bidirectional
    document message exchanges that, for SFTP transfer, translate into pushing and
    pulling formatted files to/from the service provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a bit more specific, I offer to your attention a real case from the **Jet.com**
    ([https://jet.com/](https://jet.com/) ) Finance realm, where I at the moment write
    F# code for a living. Let''s consider the payment system as a client and the bank
    as a service provider. The service gist is to execute payment advices and deliver
    remittances to the bank accounts of legal and physical entities with whom Jet.com
    gets into temporary "I owe you" relations: suppliers and vendors, merchants of
    the marketplace, employees with outstanding reimbursable business expenses and
    the like.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's assume that we have built our communication code around SFTP, which
    pushes remittances to the bank, gets back statements, originations and the like,
    all retries are in place, and all wheels are rotating smoothly. Are we doing fine?
  prefs: []
  type: TYPE_NORMAL
- en: Turns out the answer is "not really". We silently assume at this point that
    the bank's implementation is free of problems based on a whole slew of fallacies,
    such as "it's about finance", "the bank would not survive if it had bugs", "it
    is too big to allow failures" and similar. However, the bank's software is just
    software and is susceptible to all kinds of human errors. We may expect its reliability
    to be overall higher than in a random start-up minimal viable product code constituting
    a web application implementing a hot business idea and written in a garage during
    few hackathons. On the other hand, each bank's software release carries the next
    "last bug" in it, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'It so happened one day that Jet''s bank client software did not provision for
    the following scenario: what if the bank correctly accepts and executes each payment
    advice, but once in a while it does not communicate the deferred final payment
    status back to us? The payment recipients are all happy with remittance cash hitting
    their accounts and no communication errors taking place. If we take the successful
    outcome of our deliverable payment advices for granted, this bug may stay there
    forever! This is a low probability scenario but not absolutely improbable. In
    fact, a similar defect went unnoticed in Jet''s payment arrangement for a short
    time until marketplace reports started showing a growing amount of deferred payments.
    That was embarrassing!'
  prefs: []
  type: TYPE_NORMAL
- en: Can we fix this by being proactive with our "pull" data transfer part? Keep
    reading for the outline of the potential solution.
  prefs: []
  type: TYPE_NORMAL
- en: The demo solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the (overly simplified) potential solutions would be to mix the flow
    of "heartbeat" events with the flow of guarded events. As the generalization of
    guarding a single event of a certain type to any number events of a similar type
    is not challenging, let me consider a single guarded event of a type for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Within this guarded event flow mix, we establish a threshold upon how many heartbeats
    are considered healthy between the start of guarding the event and the actual
    occurrence of the guarded event. For example (the specific numbers do not anyhow
    coincide with real ones), we may say that if the ACH payment is being sent and
    after following three heartbeat events, `ACHOrigination` event is still not received,
    this should be the indication of a problem and the responsible personnel must
    be alerted of the deviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let me implement the preceding using Reactive Extensions (`Ch11_3.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After loading a slew of required components from the corresponding NuGet libraries,
    I introduce the `PaymentFlowEvent` type reflecting the mix of the previously mentioned
    three events.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `GuardACHOrigination` class combines the stream of `PaymentFlowEvent`
    events set by argument `flow` , which is also known as `Subject` , `alerter` for
    the carrying out of notifications, and business logic combining all these parts
    together. **Subject** ([https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx)
    ) is a combination of the observable sequence and Observer, and it plays the central
    role in the preceding implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Guard()` method takes `flow` , and with the help of its `Subscribe` method,
    sets a simple state machine tracking of what is going on upon the arrival of each
    instance of flowing through events of type `PaymentFlowEvents` . Given that the
    abnormality is recognized, the diagnostics notification is pushed into `alerter`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I create the required bits and pieces: `paymentFlow` representing the
    event stream of interest, `alerter` to receive notifications within `Guard()`
    , `notifier` to act upon notification events from `alerter` , and finally, fireup
    everything to life with `GuardACHOrigination(paymentFlow,alerter).Guard()` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great; now it''s time to push a stream of events into the built arrangement
    and observe the reactive behavior in FSI. The following screenshot reflects that
    the code behavior is completely aligned with the expected: timely guarded events
    pass smoothly, overdue guarded events trigger alerts, and unguarded events get
    disregarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The demo solution](img/Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Guarding the event flow with the F# reactive code
  prefs: []
  type: TYPE_NORMAL
- en: The demonstrated pattern of applying F# in a reactive manner is an important tool
    belt skill that should be mastered by enterprise practitioners.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring quotations and metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last feature I want to cover among the advanced patterns of F# use is **Code
    Quotations**  ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations)
    ). This feature is quite mind-bending, allowing you to work with the program code
    as if it is data, and evaluate these "program as data" pieces when needed and
    in the needed manner.
  prefs: []
  type: TYPE_NORMAL
- en: The feature review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at this feature from the more operational angle, a program piece may
    be represented as an expression tree representing the code but without running
    the code generation off this representation. This allows for arbitrary execution
    behavior when the expression tree is to be evaluated. It can be evaluated as F#
    code or as source to generate JavaScript code or even as GPU-executed code or
    in any other feasible manner.
  prefs: []
  type: TYPE_NORMAL
- en: The cool thing about quoted expressions is that they are typed, they can be
    spliced together from parts, or they can be decomposed into parts using active
    patterns, among other features. Without delving into too much detail, I want to
    demonstrate that if required, F# offers this extra layer of flexibility by allowing
    you to tweak the program code and evaluate the tweaked code programmatically.
    For this purpose, I will be using **F# Quotations Evaluator** ([http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html](http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'A very brief demonstration of the feature abilities is as follows (`Ch11_4.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the required library support:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `mutable` quoted `divider` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and compile a function with `divider` spliced into this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the compiled `is5Divisor` function to a few arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the spliced `divider` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that `is5Divisor` workings did not change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Recompile the spliced `divider` value into another function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the newly compiled `is7divisor` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Equipped with some understanding of how quotations work, let me now apply the
    feature to a sizable demo problem.
  prefs: []
  type: TYPE_NORMAL
- en: The demo problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While looking for a demo problem, I turn to the finance space again. Let''s
    look at the matter of invoice total adjustment based on the timeliness of payment.
    Paying an outstanding invoice early may bring some savings, while being late on
    it may impose penalties. When a vendor or supplier establishes payment terms,
    any combination of premiums and/or penalties may be set: neither premium nor penalty,
    just a premium, just a penalty, and both premium and penalty. It would be great
    to have an arrangement that would allow you to easily and naturally handle this
    variety. In other words, an adjustment is sought - for that, when applied to the
    invoice total and the payment date, finds out what the actual payment amount aligned
    with the payment terms would be.'
  prefs: []
  type: TYPE_NORMAL
- en: The demo solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the script implementing the sought adjustment object (`Ch11_4.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that the the necessary library is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Then the `Adjustment` type is defined, which is either `Absent` or `Premium`
    /`Penalty` with the structure of the `System.TimeSpan*decimal` tuple, where the
    `TimeSpan` part defines the amount of time between invoice issuance and payment
    dates and `decimal` sets the adjustment multiplier. For `Premium` , the tuple
    is interpreted as "if the number of days between the invoice issuance and payment
    is less or equal to `TimeSpan` , then the amount of payment should be decreased
    by the `decimal` multiplier". For `Penalty` , it is "if the number of days between
    the invoice issuance and payment is greater or equal to `TimeSpan` , then the
    amount of payment should be increased by the `decimal` multiplier".
  prefs: []
  type: TYPE_NORMAL
- en: The `Terms` type captures the adjustment terms within the `Adjust` method. Using
    F# quotations, it defines payment adjustment functions for each potential combination
    of terms, and then it either implements the prescribed adjustment or it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to see how it would work, we need a test bed. Let''s define a
    record representing invoice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also define test list of invoices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The function deriving the amount of payment due is now based on terms, and
    the invoice may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to define a full variety of the possible terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we can observe in the following screenshot how all this plays
    together after being applied to test invoices by applying each payment term to
    the same invoice group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The demo solution](img/Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using F# quotations
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we assayed a few features of advanced F# usage category. I
    hope I was able to demonstrate that even for the advanced features, F# continues
    to keep the promise of "solving complex problems with simple code".
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to pay further attention to the subject constituting this
    book's title. The content so far did not in any way cross the traditional view
    of design patterns usually associated with the contents of **Gang of Four Book**
    ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
    ). In the next chapter, I will justify the taken approach by observing the "classic"
    design patterns and principles from a functional-first view point.
  prefs: []
  type: TYPE_NORMAL
