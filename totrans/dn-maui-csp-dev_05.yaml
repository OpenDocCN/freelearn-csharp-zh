- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at a number of controls and how to handle
    their events and commands. In this chapter, we’ll look at moving the logic into
    `ViewModel` using commands and messaging. We’ll then go on to cover Styles, which
    let you provide a uniform appearance to your controls with little effort.
  prefs: []
  type: TYPE_NORMAL
- en: One key feature of a well-designed user experience is that when something is
    going to take more than a second or so, you let the user know that the app is
    working on it so that it doesn’t look like your app froze.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the user informed of activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving event handling to `ViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need Visual Studio. You can find the source code
    for this chapter here: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls).
    If you want to follow along, continue with the project you were working on in
    [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054).'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the user informed of activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to let the user know that your application is working on
    something time-consuming:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ActivityIndicator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressBar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ActivityIndicator` essentially says, “I’m working on it, but I don’t know
    how long it will take,” whereas `ProgressBar` says, “I’m working on it, and I’m
    about halfway done.” Let’s explore each of these in a bit more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: ActivityIndicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start by adding `ActivityIndicator` to the login page below the Buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `IsRunning` property is bound to the `ActivityIndicatorIsRunning`
    property. That property is in `LoginViewModel` (you’ll remember that we set that
    file as the binding context):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve set its default value to `true`, so the activity indicator will be running
    when the page comes up. Let’s shut it off after creating the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Nothing has changed in the create page code except the addition of the final
    line. Here we reach into `ViewModel` and set the `ActivityIndicatorIsRunning`
    property to `false`. That should stop `ActivityIndicator` whose `IsRunning` property
    is bound to `showActivityIndicator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks like *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – ActivityIndicator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – ActivityIndicator
  prefs: []
  type: TYPE_NORMAL
- en: Working or hung?
  prefs: []
  type: TYPE_NORMAL
- en: Note that under some circumstances, your program might hang, yet the activity
    indicator will continue spinning. This can cause enormous confusion and frustration
    for your user. One way to escape that problem is to set a timer, and if the task
    doesn’t complete in *n* seconds, you stop the indicator and, for example, display
    an error dialog. Of course, if everything is hung, you won’t be able to do that,
    but typically, the indicator will have frozen as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`ActivityIndicator` is great, but it only tells the user that something is
    happening, not how far it has progressed in its task. That is what `ProgressBar`
    is for.'
  prefs: []
  type: TYPE_NORMAL
- en: ProgressBar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ProgressBar` divides a task into fractional parts (for example, percentages)
    and displays what part (fraction, percentage, and so on) has been completed. We’ve
    all seen progress bars: ideally, they move smoothly across the screen; in fact,
    they often move in fits and starts as the task they are tracking completes.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to create a progress bar, but we are going to fake an action. That
    is, we’ll progress the bar based on time rather than actual progress in a task.
    Nonetheless, the workings of `ProgressBar` will become evident.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let’s comment out `ActivityIndicator` in `LoginPage.xaml`,
    and replace it with `ProgressBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have declared `ProgressBar` with only two properties: its color and
    its name. The name allows us to refer to the bar in the code-behind. We would,
    of course, normally update `ProgressBar` based on data in the `ViewModel`, but
    for now, as we have done before, we’ll do that work in the code-behind (`LoginPage.xaml.cs`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that will start and advance the progress bar based on the
    user clicking the **Submit** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[1] We will set the value of `ProgressBar` based on the value of the counter
    variable (`i`) in the `for` loop. The `ProgressBar` values range from `0` to `1`,
    with the percentage or fraction of progress measured as values between those two
    numbers. Here, we initialize the counter variable to `0.0`, and until it reaches
    the `1.0` value, we increment by one-tenth.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Within the `for` loop, we call `ProgressTo` on `ProgressBar`. That method
    takes three values:'
  prefs: []
  type: TYPE_NORMAL
- en: The value we want to progress to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The amount of time to get there, in milliseconds
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easing (see the following section)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3] The action we’ll take when the progress bar completes.'
  prefs: []
  type: TYPE_NORMAL
- en: Another related feature is *Easing*, which refers to how quickly an action goes
    from start to full speed. Let’s take a look at that in a bit more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Easing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Easing* refers to the pattern of how an item moves. For example, a train does
    not go from standing still in the station to racing along at 75 miles per hour
    all at once; it *eases* into the final speed. If you drew a graph of the acceleration,
    it would look like a sine wave, and two of the enumerated values of easing are,
    in fact, `SineIn` (for the pattern of starting up) and `SineOut` (for the pattern
    of coming back into the station).'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, however, we want the progress bar to move smoothly and at a constant
    speed, which is what `easing.Linear` does.
  prefs: []
  type: TYPE_NORMAL
- en: The net effect is that the progress bar will be animated across its entire course.
    We know that we are moving from `0` to `1` in tenths, and we know that we are
    taking half a second (500 milliseconds) to go each one-tenth of the way; thus,
    we know that the entire trip from `0.0` (nothing showing on the bar) to `1.0`
    (the bar fully filled with color) will take five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the conclusion of our `for` loop, the dialog will pop up, giving a nice
    simulation of the completion of the task that the progress bar was tracking. A
    snapshot of that progress is shown in *Figure 5**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The progress bar is about 75% of the way toward completion'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The progress bar is about 75% of the way toward completion
  prefs: []
  type: TYPE_NORMAL
- en: For convenience and to keep things simple, we’ve been using the code-behind
    for event handling. Of course, as noted in [*Chapter 3*](B19723_03.xhtml#_idTextAnchor036),
    there are good reasons to use commands rather than events and to handle them in
    `ViewModel`. Let’s look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Moving event handling to ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that when a Button is pressed, we want to handle that fact in the `ViewModel`,
    as is preferred by the `ProgressBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling things in `ViewModel` gets tricky when we want to interact with the
    `Clicked` event and add a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll create `RelayCommand` in `ViewModel` to handle the `Submit` Command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[1] Access `LoginProgressBar` on `LoginPage` (more later on how to do that)
    and call `ProgressTo` as we saw earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Access `MainPage` through the `Application` object and call `DisplayAlert`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how are we going to access the `LoginProgressBar` in the UI? We need a
    static member of `LoginPage` to accomplish this. We’ll pull the declaration of
    `LoginProgressBar` out of the **Extensible Application Markup Language** (**XAML**)
    and move it into the code-behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to be sure to initialize this in the constructor of `LoginPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re going to need to refer to `StackLayout` if we want to add that to `ProgressBar`,
    so let’s name it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re ready to add `ProgressBar` to the children of `StackLayout`. Here’s
    the complete constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[1] Notice that `InitializeComponent` comes before adding `ProgressBar` to
    the children of `StackLayout`. Until this is called, `LoginStackLayout` will be
    null.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] By calling `Add` here, `LoginProgressBar` is added to `LoginStackLayout`
    below the controls created in the XAML.'
  prefs: []
  type: TYPE_NORMAL
- en: Huh? Let’s take it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking it down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the order of what happens when you run this, enter your username and
    password, and click **Submit**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProgressBar` is added to the page in the page constructor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on `SubmitCommand` is sent to `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ViewModel` handles that in `Submit`, `RelayCommand`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `RelayCommand`, it updates the (static) `LoginProgressBar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then calls `DialogBox` through `MainPage`, which it has access to through
    the `Application` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This works beautifully but is a bit labored. The use of `Application.Current.MainPage`
    is not unusual, but the hoops we jumped through to access `ProgressBar` are. The
    solution to that is to use `Messaging`, which is covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs: []
  type: TYPE_NORMAL
- en: It is generally considered best practice for `ViewModel` not to see aspects
    of the view (as it does here). In the next example, we will isolate the VM from
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: Sending and receiving messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than reaching into `View`, we can have `ViewModel` signal `View` when
    it is time to display the dialog or other `View`-dependent element.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we want to show `Snackbar` when the user clicks on the
    `Command` (which is preferred because it puts the logic into `ViewModel`). `ViewModel`
    might then massage data or otherwise do whatever it needs to do, and then signal
    `View` to display `Snackbar` by sending out a message to that effect.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that `ViewModel` publishes a message such as “anyone who has subscribed
    to this message, show a `Snackbar`” and the page subscribes to that message and
    so shows `Snackbar` when the message is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some circumstances, there may be more than one **Subscriber**. For that
    matter, in some circumstances, more than one **Publisher** can send the same message,
    as shown in *Figure 5**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Publish and Subscribe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Publish and Subscribe
  prefs: []
  type: TYPE_NORMAL
- en: Messaging center
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI has a built-in messaging system, but it has been deprecated in favor
    of `WeakReferenceMessenger` provided in the .NET Community Toolkit MVVM, which
    we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with WeakReferenceMessenger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set this up, first create a class that will serve as the message. You can
    create this class anywhere that both `View` and `ViewModel` can see it. For convenience,
    I’ll put it above the `LoginPage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the `LoginPage` constructor, we need to register to receive such a
    message. Once you receive the message you might call a method, or alternatively,
    you’ll use a Lambda expression to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register to receive the message, use the `WeakReferenceMessenger''s Register`
    method. Here is the code to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What goes between the opening and closing braces is whatever you want to do
    when you receive that message. I’ve moved the code we were using in the event
    handler to here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need to do is revise `LoginPage.xaml` so that the `ViewModel`,
    rather than an event handler in the code-behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will invoke the Create relay method in the **ViewModel**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewModel` calls the `Send` method, sending in an instance of `ConstructMessage`
    as a signal to any registered listeners to take some action. The `Create` method
    might, before sending that message, do other work that is best done in `ViewModel`
    rather than code-behind.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a much cleaner way of *decoupling* `ViewModel` and `View` when we need
    to have logic in `ViewModel` take an action that can only be taken by `View`.
  prefs: []
  type: TYPE_NORMAL
- en: '`WeakReferenceMessenger` can also be used to communicate from one `ViewModel`
    to another.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is called `WeakReferenceMessenger` in distinction from stet `StrongReferenceMessenger`.
    The advantage of `WeakReferenceMessenger`, and the reason it is generally what
    is chosen, is that it manages its own memory and cleanup, so you don’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the page in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving on, and to reinforce the fact that anything you can do in XAML
    you can do in C#, here is the version of `LoginPage` that we will be using in
    Forget Me Not (ForgetMeNotDemo) written in C# (in the repo, this page is called
    `LoginCS`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[1] We start by declaring the class and giving it `LoginViewModel`. This is
    done by *dependency injection*, a topic covered in detail in [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160).'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] `ActivityIndicator` is instantiated; it will be added to the page later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] The `IsEnabled` property of `ActivityIndicator` is bound to a property
    in `ViewModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] We add to `StackLayout` by adding to its `Children` collection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] We haven’t covered `Grid` yet, but you can see that it is a layout that
    has rows and columns. We’ll look at it in greater depth in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] In `Grid`, each individual row and column can be given a name from `enumeration`
    or can be referred to by its zero-based index.'
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway from this section is that you can certainly create all the
    controls and their commands and properties in C# as well as in XAML. I will continue
    to dip into C#, but I’m afraid it will drive you crazy to show each type in both,
    so again, for layout and controls, we’ll focus predominantly on XAML – the standard
    approach for .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common to have a collection of data and to want to display it in a list,
    allowing the user to select one or more items and then do some work with those
    items. There are a couple of ways to do this in .NET MAUI, but the most common
    (and best) is to use `CollectionView`.
  prefs: []
  type: TYPE_NORMAL
- en: To see this at work, examine `Preferences.xaml` along with its code-behind `Preferences.xaml.cs`
    and `ViewModel`, `PreferencesViewModel.cs`. We will use this page extensively
    as we build Forget Me Not, but let’s start slowly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to create a list of the user’s preferences (shirt size, music genre,
    and so on). For that, we’ll use `CollectionView`, and we’ll, of course, need a
    collection to view. The page, when completed, will look much like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The Preferences page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – The Preferences page
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than each line being a unique object, we’ll create one type that we
    can show repeatedly. In the `Model` folder, create a `Preference` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Partial classes
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI virtually all classes are *partial* to support the Community Toolkit
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '`Preference` has only two properties, both strings. The `PreferencePrompt`
    string will hold the text on the left of the page, and the `PreferenceValue` string
    will hold the user’s preference on the right side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is a collection of these `Preference` objects. To get
    that, we’re going to build a `Service`, whose job, eventually, will be to interact
    with the API and get us our list of `Preference` objects. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Services`, create a `PreferenceService` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside that file add a `GetPreferences` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewModel` will call `GetPreferences` on the service and get back a list of
    the `Preference` objects. We’ll turn to how `PreferenceService` gets those objects
    in just a bit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `PreferencesViewModel`, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[1] Declare an instance of `PreferenceService`'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Initialize it in the constructor'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] In the `Init` method, fill the `Preferences` collection with what you get
    back from the service'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160), we will review dependency
    injection. At that point, we’ll pass in a `PreferenceService` interface and let
    the `InversionOfControl` container supply the service for us. If that didn’t make
    sense to you, no problem; it will all become clear in [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, who instantiates `ViewModel` and calls `Init`? For that, we turn to the
    code-behind of the `PreferencesPage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Naming the ViewModel vm
  prefs: []
  type: TYPE_NORMAL
- en: I’m not big on using acronyms in code, and would normally have named the local
    instance of `ViewModel`. But using *vm* is such a convention in .NET MAUI (going
    back to `Xamarin.Forms`) that I indulge myself.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI, the two life cycle events you will often want control over are
    when the page is first being shown (`OnAppearing`) and when it is being shut down
    (`OnDisappearing`). Let’s explore this next.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding OnAppearing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time a page appears, its `OnAppearing` method is called. We override that
    method so that we can call `vm.Init()`. We do this because `Init` is asynchronous,
    and while we can make `OnAppearing` asynchronous using the `async` keyword, we
    can’t do that with the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnInit()`, in turn, calls `GetPreferences` on the service and gets back a
    collection of the `Preference` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the service works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In time, our `PreferenceService's` `GetPreferences` method will call into our
    API to get the list of preferences from our database, which will be stored in
    the cloud. For now, it will call `GetPreferencesMock`, which will handcraft the
    list and return it to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an excerpt from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The result is a collection of `Preference` objects. Let’s look at how to display
    that collection.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the collection of Preference objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a collection of `Preference` objects in `ViewModel`, we can
    create our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is much to see in this listing. Let’s take things one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] `Label` has multiple lines; we’ve seen this before. We set `LineBreakMode`
    to `WordWrap` so that we break the lines between words. Notice the use of `&#10;`,
    which forces a line break.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] The **Save** button is very unusual as it has a click event handler as
    well as a command! The click event handler will handle showing the toast.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] The command will be handled in `ViewModel` and will call the `Save` method
    in the service (which we will not implement just yet).'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] The `ItemsSource` property points to the collection that `CollectionView`
    will display. In our case, that is the `Preferences` collection in `ViewModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] `SelectionMode` is set to `None`, as we won’t be selecting items in this
    display. We will be editing items and then pressing **Save** to save the changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] An item template says, “here is how I want you to display each item in
    the collection, one by one.”'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] Interestingly, we are using `Entry` for the prompt. This allows the user
    to change the prompt, which is what we want. We can’t anticipate every category,
    so we create a number of them, but we let the user tweak the list as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] Not only will we be displaying the value of the prompt from the database,
    but we’ll want to write back whatever the user enters as well. Thus, we mark the
    text as two-way (that is, data > View and View > data)'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] We’ve not seen `onPlatform` before. This says, “always use this value except,
    on this platform, use this other value.” Here we are saying that the text color
    is `Black`, except on `Ios`, where it is `White`.'
  prefs: []
  type: TYPE_NORMAL
- en: The code-behind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll remember that we are not only handling the command in `ViewModel` but
    we’re also handling the `Clicked` event in the code-behind. Here is the rest of
    `PreferencesPage.xaml.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The event handler just calls the `ShowToast` method, which then does its thing,
    as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This way, when the list of preferences is saved, the toast notifies the user
    that all went well.
  prefs: []
  type: TYPE_NORMAL
- en: Did it all go well?
  prefs: []
  type: TYPE_NORMAL
- en: In the code shown, we just assume that it all went well. To do this properly,
    we’d want `ViewModel` to wait for confirmation from the API that the operation
    was completed successfully, and then it would send a message to the code-behind,
    which would then, and only then, display the toast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go any further, open `AppShell.xaml` and change the startup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once we get to [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129), we can stop
    this silliness and just navigate to the page we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of all of this is shown in *Figure 5**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The Preferences page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – The Preferences page
  prefs: []
  type: TYPE_NORMAL
- en: A few quick things to note in *Figure 5**.5*. The fields on the left have been
    underlined, indicating that they are entry objects, not labels, and thus can be
    modified. The top arrow points to the fact that the fields are free-form, and
    the user can enter whatever they want, and the lower arrow points to the toast.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve been setting numerous properties on our UI controls. Often, we’ve
    had to repeat the same properties on various instances of the same type of control.
    There is a better way: styles, which we’ll cover next.'
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Styles** allow you to provide a uniform look to your controls by putting
    all the details in one place.'
  prefs: []
  type: TYPE_NORMAL
- en: You create a style for a control type (for example, `Button`), and that style
    is applied to all controls of that type (refer to the *Explicit versus implicit
    styles* section). You can also base a style on an existing style, extending or
    modifying the original.
  prefs: []
  type: TYPE_NORMAL
- en: Styles can be stored on the page that uses the control, or they can be stored
    at the application level. In either case, they are created inside `ResourceDictionary`,
    typically declared at the top of the file. To make them available at the application
    level, just put them in `App.xaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Where to put your styles
  prefs: []
  type: TYPE_NORMAL
- en: If you are only going to use the styles on objects on a single page, it makes
    sense to put the styles in the resources of that page. If you want to be able
    to reuse these styles on multiple pages, then you will want them in `App.xaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s return to the `ResourceDictionary` and our first styles.
    Place this code at the very top of the file, just below the `ContentPage` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we have created a style for the labels on the page. In that
    style, we have set a number of properties with their values. This will be applied
    to every `Label` because this is an implicit style, as described next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to the use of styles is that they greatly simplify the controls they
    are applied to. For example, the labels now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: They are no longer cluttered with all the style information that has been centralized
    in `ResourceDictionary`. This not only makes for cleaner XAML, but if you later
    decide to change one of these values, you do so in one place rather than throughout
    the page. Thus, the same clean code guideline that applies to C# (don’t repeat
    yourself) applies to styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of styles: implicit and explicit. `TargetType`, as we saw
    earlier. **Explicit styles** can be applied to controls individually. Let us explore
    this in more detail next.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit versus implicit styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a style explicit, you give it a key, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now pick which of these styles you want to apply to `Label` based on
    that key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in *Figure 5**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Explicit styles applied'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Explicit styles applied
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the style in the control
  prefs: []
  type: TYPE_NORMAL
- en: If you have a style that you want to use on all of your (for example) labels,
    but you have one `Label` that needs one or two properties to be different, one
    way to handle that is just to make the change in that `Label`. Properties assigned
    directly to the control override those of the style. On the other hand, if you
    have sets of controls that need nearly the same properties but differ in some
    ways, then you want to use style inheritance, which is covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Style inheritance or BasedOn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The construct for `LargeLabel` and `SmallLabel` has a lot of duplication. You
    can refactor this to use a base style and then just add the changes in your explicit
    styles. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[1] An implicit label style'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] A style created to be the base style for other styles'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] A derived style that uses properties from the base style'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Using the derived style'
  prefs: []
  type: TYPE_NORMAL
- en: Derived styles
  prefs: []
  type: TYPE_NORMAL
- en: Note that derived styles can add new properties (as was done here), they can
    override values in the base style, or both. Notice also that we refactored the
    styles, but did not have to refactor `Label` that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deeper into some of the more advanced aspects of .NET
    MAUI controls. We looked at the `Activity` element as well as `ProgressBar`. We
    went on to look at moving command handling into `ViewModel` and using messages
    to communicate between `ViewModel` and `View`.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter by looking at styles and how they can be used to provide
    a uniform appearance to the UI and how we can refactor duplication out of similar
    styles by using style inheritance (`BasedOn`).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at how we lay out `controls` on the page, moving
    beyond the simple `StackLayouts` we’ve been using so far.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between `ActivityIndicator` and `ProgressBar`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between an event and a command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `WeakReferenceManager`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you use a style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you refactor common properties in styles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a small form that pretends to gather information on the user to create
    a profile (name, age, address, and so on). Add an image you can tap on and two
    buttons: one to accept the entered info and one to cancel it.'
  prefs: []
  type: TYPE_NORMAL
- en: If the user taps on the image, put up a dialog box with a message, but handle
    the tap itself in `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Handle the button clicks in `ViewModel`. On clicking `Snackbar` to show what
    info they have saved, nicely formatted.
  prefs: []
  type: TYPE_NORMAL
