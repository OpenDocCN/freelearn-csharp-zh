<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-110"><a id="_idTextAnchor513"/>6</h1>
<h1 id="_idParaDest-111"><a id="_idTextAnchor514"/>Building a Photo Gallery App Using CollectionView and CarouselView</h1>
<p>In this chapter, we will build an app that shows photos from the camera roll (photo gallery) of a user’s device. The user will also be able to select photos as favorites. We will then look at the different ways to display photos—in carousels and in multi-column grid control. By using the .NET MAUI <code>CarouselView</code> control to display a group of images, the user can swipe through them to view each image. To display a large group of images, we will use the .NET MAUI <code>CollectionView</code> control and vertical scrolling to allow the user to view all the images. By learning how to use these controls, we will be able to use them in a lot of other cases when we build real-world apps.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Requesting permissions from the user to access data</li>
<li>How to import photos from the iOS and Mac Catalyst photo gallery</li>
<li>How to import photos from the Android photo gallery</li>
<li>How to import photos from the Windows photo gallery</li>
<li>How to use <code>CarouselView</code> in .NET MAUI</li>
<li>How to use <code>CollectionView</code> in .NET MAUI</li>
</ul>
<h1 id="_idParaDest-112"><a id="_idTextAnchor515"/>Technical requirements</h1>
<p>To be able to complete this project, you will need to have Visual Studio for Mac or Windows installed, as well as the necessary .NET MAUI workloads. See <em class="italic">Chapter 1</em>,<em class="italic"> Introduction to .NET MAUI</em>, for more details on how to set up your environment.</p>
<p>To build an iOS <a id="_idIndexMarker605"/>app using Visual Studio for your PC, you have to have a <strong class="bold">Macintosh</strong> (<strong class="bold">Mac</strong>) device connected. If you don’t have access to a Mac at all, you can just follow the Android and Windows part of this project.</p>
<p>You can find the full source for the code in this chapter at <a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/">https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/</a>.<a id="_idTextAnchor516"/><a id="_idTextAnchor517"/></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor518"/>Project overview</h1>
<p>Almost all apps visualize collections of data, and in this chapter, we will focus on two of the .NET MAUI controls that can be used to display data collections—<code>CollectionView</code><em class="italic"> </em>and <code>CarouselView</code>. Our app will show the photos that users have on their devices; to do that, we need to create a photo importer for each platform—one for iOS<a id="_idTextAnchor519"/> and Mac Catalyst, one for Windows, and one for Android.</p>
<p>The build time for this project is about 60 minutes<a id="_idTextAnchor520"/>.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor521"/>Building the photo gallery app</h1>
<p>This project, like all the rest, is a <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project...</strong>-style project, which means that we will <a id="_idIndexMarker606"/>not be importing any code at all. So, this first section is all about creating the project and setting up the basic project structure<a id="_idTextAnchor522"/><a id="_idTextAnchor523"/><a id="_idTextAnchor524"/>.</p>
<p>It’s time to start building the app using the following steps. Let’s begin!</p>
<h2 id="_idParaDest-115">Creating the new projec<a id="_idTextAnchor525"/>t</h2>
<p>The first <a id="_idIndexMarker607"/>step is to create a new .NET MAUI <a id="_idIndexMarker608"/>project:</p>
<ol>
<li>Open Visual Studio 2022 and select <strong class="bold">Create a </strong><strong class="bold">new project</strong>:</li>
</ol>
<div><div><img alt="Figure 6.1 – Visual Studio 2﻿022" src="img/Figure_6.1_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Visual Studio 2<a id="_idTextAnchor526"/>022</p>
<p class="list-inset">This <a id="_idIndexMarker609"/>will open the <strong class="bold">Create a new </strong><strong class="bold">project</strong> wizard.</p>
<ol>
<li value="2">In the search field, type in <code>maui</code> and select the <strong class="bold">.NET MAUI App</strong> item from the list:</li>
</ol>
<div><div><img alt="Figure 6.2 – Create a new proje﻿ct" src="img/Figure_6.2_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Create a new proje<a id="_idTextAnchor527"/>ct</p>
<ol>
<li value="3">Click <strong class="bold">Next</strong>.</li>
<li>Complete <a id="_idIndexMarker610"/>the next step of the wizard by naming your project. We will be calling our application <code>GalleryApp</code> in this case. Move on to the next dialog box by clicking <strong class="bold">Next</strong>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 6.3 – Configure your new proje﻿ct" src="img/Figure_6.3_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Configure your new proje<a id="_idTextAnchor528"/>ct</p>
<ol>
<li value="5">Click <strong class="bold">Next</strong>.</li>
<li>The last <a id="_idIndexMarker611"/>step will prompt you for <a id="_idIndexMarker612"/>the version of .NET Core to support. At the time of writing, .NET 6 is available as <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>), and .NET 7 is <a id="_idIndexMarker613"/>available as <strong class="bold">Standard-Term Support</strong>. For the purposes of this book, we will assume that you will be using .NET 7.</li>
</ol>
<div><div><img alt="Figure 6.4 – Additional information" src="img/Figure_6.4_B19214.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Additional information</p>
<ol>
<li value="7">Finalize the setup by clicking <strong class="bold">Create</strong> and wait for Visual Studio to create the project.</li>
</ol>
<p>Just like that, the app is created. Let’s start by getting some photos to disp<a id="_idTextAnchor529"/><a id="_idTextAnchor530"/><a id="_idTextAnchor531"/>lay.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor532"/>Importing photos</h2>
<p>The importing of photos is something that is carried out for all the platforms, so we will create a photo <a id="_idIndexMarker614"/>importer interface. The interface will have two <code>Get</code> methods—one that supports paging and one that gets photos with specified filenames. Both methods will also take a quality argument, but we will only use that argument in the iOS photo importer. The quality argument will be an <code>enum</code> type with two options—<code>High</code> and <code>Low</code>. However, before we create the interface, we will create a model class that will represent an imported photo using the following steps:</p>
<ol>
<li>Create a new folder named <code>Models</code> in the <code>GalleryApp</code> project.</li>
<li>Create a new class named <code>Photo</code> in the recently created folder:<pre class="source-code">
namespace GalleryApp.Models;
public class Photo
{
  public string Filename { get; set; }
  public byte[] Bytes { get; set; }
}</pre></li> </ol>
<p>Now that <a id="_idIndexMarker615"/>we have created the model class, we can continue to create the interface:</p>
<ol>
<li>Create a new folder named <code>Services</code> in the project.</li>
<li>Create a new interface named <code>IPhotoImporter</code> in the <code>Services</code> folder:<pre class="source-code">
namespace GalleryApp.Services;
using System.Collections.ObjectModel;
using GalleryApp.Models;
public interface IPhotoImporter
{
  Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, int  count, 
Quality quality = Quality.Low);
  Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(List&lt;string&gt; filenames, 
Quality quality = Quality.Low);
}</pre></li> <li>In the <code>Services</code> folder, add a new file and create an <code>enum</code> type named <code>Quality</code> with two members—<code>Low</code> and <code>High</code>:<pre class="source-code">
namespace GalleryApp.Services;
public enum Quality
{
  Low,
  High
}</pre></li> <li>In the <code>Services</code> folder, create <a id="_idIndexMarker616"/>a new class named <code>PhotoImporter</code>:<pre class="source-code">
namespace GalleryApp.Services;
using GalleryApp.Models;
using System.Collections.ObjectModel;
internal partial class PhotoImporter : IPhotoImporter
{
  private partial Task&lt;string[]&gt; Import();
  public partial Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int 
start, int count, Quality quality);
  public partial Task&lt;ObservableCollection&lt;Photo&gt;&gt; 
Get(List&lt;string&gt; filenames, Quality quality);
}</pre><p class="list-inset">This class provides us with the base for the platform-specific implementations. By marking it <code>partial</code>, we are telling the compiler that there is more to this class in other files. We will be putting the implementation in the platform-specific folders<a id="_idTextAnchor533"/> later.</p></li> </ol>
<p>Now that <a id="_idIndexMarker617"/>we have the interface, we can add app permissions.</p>
<h3>Requesting app permissions</h3>
<p>If your app doesn’t require any of the device’s extra features, such as location, camera, or internet, then you will need to use permissions to request access to those resources. While each <a id="_idIndexMarker618"/>platform implements permissions slightly differently, .NET MAUI maps the platform-specific permissions into a common set of permissions to make things simpler. The permission system in .NET MAUI is also extensible so that you can create your own permissions to best suit your app.</p>
<p>Let’s look at a specific example to see how requesting permissions works. <code>GalleryApp</code> displays images from a device’s photo library. In the case of iOS and Android, the app must declare and request access to the photo library before it can use it. While these permissions are configured and named differently, .NET MAUI defines a <code>Photo</code> permission that hides those implementation details.</p>
<p>Follow these steps to add a permission check to <code>GalleryApp</code>:</p>
<ol>
<li>Create a new class named <code>AppPermissions</code> in the <code>GalleryApp</code> project.</li>
<li>Modify the class definition to add a <code>partial</code> modifier, and remove the default constructor:<pre class="source-code">
namespace GalleryApp;
internal partial class AppPermissions
{
}</pre></li> <li>Add the following class definition to the <code>AppPermissions</code> class:<pre class="source-code">
internal partial class AppPermissions
{
<strong class="bold">  internal partial class AppPermission : Permissions.Photos</strong>
<strong class="bold">  {</strong>
<strong class="bold">  }</strong>
}</pre><p class="list-inset">This creates a type named <code>AppPermission</code> that derives from the default .NET MAUI <code>Photos</code> permission class. It is also marked <code>partial</code> to allow for platform-specific <a id="_idIndexMarker619"/>implementation details to be added. Spoiler alert: we will need to have some platform-specific permissions.</p></li> <li>Add the following method to the <code>AppPermissions</code> class:<pre class="source-code">
public static async Task&lt;PermissionStatus&gt; 
CheckRequiredPermission() =&gt; await Permissions.
CheckStatusAsync&lt;AppPermission&gt;();</pre><p class="list-inset">The <code>CheckRequiredPermission</code> method is used to ensure our app has the right permissions before we attempt any operations that might fail if we don’t. Its implementation is to call the .NET MAUI <code>CheckSyncStatus</code> with our <code>AppPermission</code> type. It returns a <code>PermissionStatus</code>, which is an <code>enum</code> type. We are mostly interested in the <code>Denied</code> and <code>Granted</code> values.</p></li> <li>Add the <code>CheckAndRequestRequiredPermission</code> method to the <code>AppPermissions</code> class:<pre class="source-code">
public static async Task&lt;PermissionStatus&gt; 
CheckAndRequestRequiredPermission()
{
  PermissionStatus status = await Permissions.
CheckStatusAsync&lt;AppPermission&gt;();
  if (status == PermissionStatus.Granted)
            return status;
  if (status == PermissionStatus.Denied &amp;&amp; DeviceInfo.Platform 
== DevicePlatform.iOS)
  {
    // Prompt the user to turn on in settings
    // On iOS once a permission has been denied it may not be 
requested again from the application
    await App.Current.MainPage.DisplayAlert("Required App 
Permissions", "Please enable all permissions in Settings for 
this App, it is useless without them.", "Ok");
  }
  if
  (Permissions.ShouldShowRationale&lt;AppPermission&gt;())
  {
    // Prompt the user with additional information as to why the 
permission is needed
    await App.Current.MainPage.DisplayAlert("Required App 
Permissions", "This is a Photo gallery app, without these 
permissions it is useless.", "Ok");
  }
  status = await MainThread.InvokeOnMainThreadAsync(Permissions.
RequestAsync&lt;AppPermission&gt;);
  return status;
  }
}</pre><p class="list-inset">The <code>CheckAndRequestRequiredPermission</code> method handles the intricacies of requesting access from the user. The first step is to simply check whether the <a id="_idIndexMarker620"/>permission has already been granted, and if it has, return the status. Next, if you are on iOS and the permission has been denied, it cannot be requested again, so you must instruct the user on how to grant permission to the app by using the settings panel. In the request behavior, Android includes the ability to nag the user if they have denied access. This behavior is exposed through .NET MAUI with the <code>ShouldShowRationale</code> method. It will return <code>false</code> for any platform that does not support this behavior; on Android, it will return <code>true</code> the first time the user denies access and <code>false</code> if the user denies it a second time. Finally, we request access for <code>AppPermission</code> from the user. Again, .NET MAUI is hiding all the platform implementation details from us, making checking and requesting access to certain resources very straightforward.</p></li> </ol>
<p class="callout-heading">Look familiar?</p>
<p class="callout">If the preceding code looks familiar, it might be. This is the same implementation that is described in the .NET MAUI documentation. You can find it at <a href="https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/appmodel/permissions">https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/appmodel/permissions</a>.</p>
<p>Now that we have the shared <code>AppPermissions</code> in place, we can start with the platform implementations.</p>
<h3>Importing photos from the iOS photo gallery</h3>
<p>First, we will write the iOS code. To access photos, we need permission from the user, and we need to explain why we are asking for permission. To do that, we add text that explains why <a id="_idIndexMarker621"/>we need permission to the <code>info.plist</code> file. This text will be displayed when we ask the users for permission. To open the <code>info.plist</code> file, right-click on the file in the <code>Platforms/iOS</code> folder and click <code>Info.plist</code> editor. Add the following text to the end of the <code>&lt;</code><code>dict&gt;</code> element:</p>
<pre class="source-code">
&lt;key&gt; NSPhotoLibraryUsageDescription &lt;/key&gt;
&lt;string&gt; We want to show your photos in this app &lt;/string&gt;</pre> <p>The first thing we will do is implement the <code>Import</code> method that reads what photos can be loaded:</p>
<ol>
<li>In the <code>GalleryApp</code> project in the <code>Platforms/iOS</code> folder, create a new class called <code>PhotoImporter</code>.</li>
<li>Change the namespace declaration from <code>GalleryApp.Platforms.iOS</code> to <code>GalleryApp.Services</code>.</li>
<li>The partial class definitions must be in the same namespace, even though they are in different folders.</li>
<li>Add the <code>partial</code> modifier.</li>
<li>Resolve all the references.</li>
<li>Create a <code>private</code> field with a <code>PHAsset</code> dictionary named <code>assets</code>. This will be used to store photo information:<pre class="source-code">
private Dictionary&lt;string,PHAsset&gt; assets;</pre></li> <li>Create a new <code>private partial</code> method named <code>Import</code>:<pre class="source-code">
private partial async Task&lt;string[]&gt; Import()
{
}</pre></li> <li>In the <code>Import</code> method, request authorization using the <code>AppPermissions.Check</code><strong class="source-inline">
</strong><code>AndRequestRequiredPermission</code> method:<pre class="source-code">
var status = await AppPermissions.
CheckAndRequestRequiredPermission();</pre></li> <li>If the <a id="_idIndexMarker622"/>user has granted access, fetch all the image assets by using <code>PHAsset.FetchAssets</code>:<pre class="source-code">
internal partial class PhotoImporter
{
  private Dictionary&lt;string,PHAsset&gt; assets;
  private partial async Task&lt;string[]&gt; Import()
  {
    var status = await AppPermissions.
CheckAndRequestRequiredPermission();
<strong class="bold">    if (status == PermissionStatus.Granted)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      assets = PHAsset.FetchAssets(PHAssetMediaType.Image, null)</strong>
<strong class="bold">      .Select(x =&gt; (PHAsset)x)</strong>
<strong class="bold">      .ToDictionary(asset =&gt; asset.</strong>
<strong class="bold">ValueForKey((NSString)"filename").ToString(), asset =&gt; asset);</strong>
<strong class="bold">    }</strong>
<strong class="bold">    return assets?.Keys.ToList().ToArray();</strong>
}</pre></li> </ol>
<p>Now, we have fetched <code>PHAssets</code><em class="italic"> </em>for all the photos, but to show the photo, we need to get the actual photo. On iOS, to do that, we need to request the image for the asset. This is <a id="_idIndexMarker623"/>something that is carried out asynchronously, so we will use <code>ObservableCollection</code>:</p>
<pre class="source-code">
private void AddImage(ObservableCollection&lt;Photo&gt; photos, string path, 
PHAsset asset, Quality quality)
  {
    var options = new PHImageRequestOptions()
    {
      NetworkAccessAllowed = true,
      DeliveryMode = quality == Quality.Low ?
      PHImageRequestOptionsDeliveryMode.FastFormat :
      PHImageRequestOptionsDeliveryMode.HighQualityFormat
    };
        PHImageManager.DefaultManager.RequestImageForAsset(asset, 
PHImageManager.MaximumSize, PHImageContentMode.AspectFill, options, 
(image, info) =&gt;
    {
      using NSData imageData = image.AsPNG();
      var bytes = new byte[imageData.Length];
             System.Runtime.InteropServices.Marshal.Copy(imageData.
Bytes, bytes, 0, Convert.ToInt32(imageData.Length));
      photos.Add(new Photo()
      {
        Bytes = bytes,
        Filename = Path.GetFileName(path)
      });
    });
  }</pre> <p>Now, we have <a id="_idIndexMarker624"/>what we need to start implementing the two <code>Get</code> methods from the interface. We will start with the partial <code>Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, int count, Quality quality = Quality.Low)</code><em class="italic"> </em>method, which will be used to get photos from the <code>CollectionView</code><em class="italic"> </em>view that loads photos incrementally:</p>
<pre class="source-code">
public partial async Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, 
int count, Quality quality)
  {
    var photos = new ObservableCollection&lt;Photo&gt;();
    var status = await AppPermissions.
CheckAndRequestRequiredPermission();
    if (status == PermissionStatus.Granted)
    {
      var result = await Import();
      if (result.Length == 0)
      {
        return photos;
      }
      Index startIndex = start;
      Index endIndex = start + count;
      if (endIndex.Value &gt;= result.Length)
      {
        endIndex = result.Length;
      }
      if (startIndex.Value &gt; endIndex.Value)
      {
        return photos;
      }
      foreach (var path in result[startIndex..endIndex])
      {
        AddImage(photos, path, assets[path], quality);
      }
    }
    return photos;
  }</pre> <p>The other <a id="_idIndexMarker625"/>method from the <code>IPhotoImporter</code> interface, <code>Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(List&lt;string&gt; filenames, Quality quality = Quality.Low)</code>, is very similar to the <code>Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, int count, Quality quality = Quality.Low)</code> method. The only difference is that there is no code to handle indexes, and the <code>foreach</code> loop that loops through the result’s array contains an <code>if</code> statement that checks whether the filename is the same as the current <code>PHAsset</code> object, and if it is, it calls the <a id="_idTextAnchor534"/><code>AddImage</code> method:</p>
<pre class="source-code">
public partial async Task&lt;ObservableCollection&lt;Photo&gt;&gt; 
Get(List&lt;string&gt; filenames, Quality quality)
  {
    var photos = new ObservableCollection&lt;Photo&gt;();
    var result = await Import();
    if (result?.Length == 0)
    {
      return photos;
    }
    foreach (var path in result)
    {
      if (filenames.Contains(path))
      {
        AddImage(photos, path, assets[path], quality);
      }
    }
    return photos;
  }</pre> <p>In the preceding code, we set <code>NetworkAccessAllowed = true</code>. We do this to make it <a id="_idIndexMarker626"/>possible to download ph<a id="_idTextAnchor535"/>otos from <strong class="bold">iCloud</strong>.</p>
<p>Now, one of the four photo importers of our project is complete. The Mac Catalyst importer will be the next one we implement.</p>
<h3>Importing photos from the Mac Catalyst photo gallery</h3>
<p>The Mac Catalyst importer is exactly the same as what we just did for iOS. However, there isn’t <a id="_idIndexMarker627"/>a convenient way to say, “<em class="italic">I need this class for just iOS and Mac Catalyst, and nothing else.</em>” So we will take the path of least resistance and just copy the class into the Mac Catalyst platform folder:</p>
<ol>
<li>Right-click the <code>PhotoImporter.cs</code> file in the <code>Platforms/iOS</code> folder in the project and select <strong class="bold">Copy</strong>.</li>
<li>Right-click the <code>Platforms/MacCatalyst</code> folder and select <strong class="bold">Paste</strong>.</li>
<li>Right-click on the <code>Info.plist</code> file in the <code>Platforms/MacCatalyst</code> folder and click <code>&lt;</code><code>dict&gt;</code> element:<pre class="source-code">
&lt;key&gt; NSPhotoLibraryUsageDescription &lt;/key&gt;
&lt;string&gt; We want to show your photos in this app &lt;/string&gt;</pre></li> </ol>
<p>That concludes the Mac Catalyst implementation of the <code>PhotoImporter</code> class. Next, we will work on the<a id="_idTextAnchor536"/> Android platform.</p>
<h3>Importing photos from the Android photo gallery</h3>
<p>Now that we have created an implementation for iOS, we will do the same for Android. Before we <a id="_idIndexMarker628"/>jump right into the importer, we need to address the permissions on Android.</p>
<p>In Android API version 33, three new permissions were added to enable read access to media files: <code>ReadMediaImages</code>, <code>ReadMediaVideos</code>, and <code>ReadMediaAudio</code>. Prior to API version 33, all that was required was the <code>ReadExternalStorage</code> permission. To properly request the correct permission for the API version of the device, create a new file named <code>AppPermissions</code> in the <code>Platform/Android</code> folder and modify it to look like the following:</p>
<pre class="source-code">
using Android.OS;
[assembly: Android.App.UsesPermission(Android.Manifest.Permission.
ReadMediaImages)]
[assembly: Android.App.UsesPermission(Android.Manifest.Permission.
ReadExternalStorage, MaxSdkVersion = 32)]
namespace GalleryApp;
internal partial class AppPermissions
{
  internal partial class AppPermission : Permissions.Photos
  {
    public override (string androidPermission, bool isRuntime)[] 
RequiredPermissions
    {
      get
      {
        List&lt;(string androidPermission, bool isRuntime)&gt; perms = new();
        if (Build.VERSION.SdkInt &gt;= BuildVersionCodes.Tiramisu)
                    perms.Add((global::Android.Manifest.Permission.
ReadMediaImages, true));
        else
                    perms.Add((global::Android.Manifest.Permission.
ReadExternalStorage, true));
        return perms.ToArray();
      }
    }
  }
}</pre> <p>The first two <a id="_idIndexMarker629"/>lines add the required permissions to the <code>AndroidManifet.xml</code> file, similar to what we did manually with the iOS <code>info.plist</code> file. However, we only need <code>ReadMediaImages</code> for API 33+ and <code>ReadExternalStorage</code> for API versions below 33, so we set <code>MaxSdkVersion</code> for the <code>ReadExternalStorage</code> property. Then, we extend the <code>AppPermission</code> class with an implementation of the <code>RequirePermissions</code> property. In <code>RequirePermissions</code>, we return an array containing the <code>ReadMediaImages</code> permissions if the API version is 33 or higher, or the <code>ReadExternalStorage</code> permission if the API version is lower than 33. The Boolean value that is part of the <code>perms</code> array indicates whether the permission requires requesting access at runtime from the user. Now, when the app launches, it will request access for the correct permission based on the API level of the device.</p>
<p>Now that we have the Android-specific permissions sorted, we can import images using the following steps:</p>
<ol>
<li>Create a new class named <code>PhotoImporter</code> in the project in the <code>Platforms/Android</code> folder.</li>
<li>Change the namespace declaration from <code>GalleryApp.Platforms.Android</code> to <code>GalleryApp.Services</code>.</li>
<li>The partial class definitions must be in the same namespace, even though they are in different folders.</li>
<li>Add the <code>partial</code> modifier.</li>
<li>Add a <code>using</code> statement for <code>GalleryApp.Models</code> to use the <code>Photo</code> class later.</li>
<li>Like the iOS implementation, we will start by implementing the <code>Import</code> method. Add a new method named <code>Import</code> as follows:<pre class="source-code">
private partial async Task&lt;string[]&gt; Import()
{
  var paths = new List&lt;string&gt;();
  return paths.ToArray();
}</pre></li> <li>Request <a id="_idIndexMarker630"/>permissions from the user to get the photos (highlighted in the following code block):<pre class="source-code">
private partial async Task&lt;string[]&gt; Import()
{
  var paths = new List&lt;string&gt;();
<strong class="bold">  var status = await AppPermissions.</strong>
<strong class="bold">CheckAndRequestRequiredPermission();</strong>
<strong class="bold">  if (status == PermissionStatus.Granted)</strong>
<strong class="bold">  {</strong>
<strong class="bold">  }</strong>
  return paths.ToArray();
}</pre></li> <li>Now, use <code>ContentResolver</code> to query for the files and add them to the result:<pre class="source-code">
private partial async Task&lt;string[]&gt; Import()
{
  var paths = new List&lt;string&gt;();
  var status = await AppPermissions.
CheckAndRequestRequiredPermission();
  if (status == PermissionStatus.Granted)
  {
<strong class="bold">    var imageUri = MediaStore.Images.Media.ExternalContentUri;</strong>
<strong class="bold">    var projection = new string[] { MediaStore.IMediaColumns.</strong>
<strong class="bold">Data };</strong>
<strong class="bold">    var orderBy = MediaStore.Images.IImageColumns.DateTaken;</strong>
<strong class="bold">    var cursor = Platform.CurrentActivity.ContentResolver.</strong>
<strong class="bold">Query(imageUri, projection, null, null, orderBy);</strong>
<strong class="bold">    while (cursor.MoveToNext())</strong>
<strong class="bold">    {</strong>
<strong class="bold">      string path = cursor.GetString(cursor.</strong>
<strong class="bold">GetColumnIndex(MediaStore.IMediaColumns.Data));</strong>
<strong class="bold">      paths.Add(path);</strong>
<strong class="bold">    }</strong>
  }
  return paths.ToArray();
}</pre></li> </ol>
<p>We will <a id="_idIndexMarker631"/>then start editing the <code>Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, int count, Quality quality = Quality.Low)</code> method. If the import succeeds, we will continue to write the code that handles which photos should be imported in this loading of images. Conditions are specified with the <code>start</code> and <code>count</code> parameters. Use the following <a id="_idIndexMarker632"/>code listing to implement the first <code>Get</code> method:</p>
<pre class="source-code">
public partial async Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, 
int count, Quality quality)
{
  var photos = new ObservableCollection&lt;Photo&gt;();
  var result = await Import();
  if (result.Length == 0)
  {
    return photos;
  }
  Index startIndex = start;
  Index endIndex = start + count;
  if (endIndex.Value &gt;= result.Length)
  {
    endIndex = result.Length;
  }
  if (startIndex.Value &gt; endIndex.Value)
  {
    return photos;
  }
  foreach (var path in result[startIndex..endIndex])
  {
    photos.Add(new()
    {
      Bytes = File.ReadAllBytes(path),
      Filename = Path.GetFileName(path)
    });
  }
  return photos;
}</pre> <p>Let’s review the preceding code. The first step is to call the <code>Import</code> method and verify that there <a id="_idIndexMarker633"/>are photos to import. If there are none, we simply return an empty list. If there are photos to import, then we need to know <code>startIndex</code> and <code>endIndex</code> in the <code>photos</code> array to import. The code defaults to <code>endIndex</code> being <code>startIndex</code> plus the count of photos to import. If the count of photos to import is greater than the number of photos returned from the <code>Import</code> method, then <code>endindex</code> is adjusted to the length of the photos returned from the <code>Import</code> method. If <code>startIndex</code> is greater than <code>endIndex</code>, then we return the list of photos. Finally, we can read the images from <code>startIndex</code> to <code>endIndex</code> from the array of photos and return the bytes from the file and just the name of the file for each entry.</p>
<p>Now, we will continue with the other <code>Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get</code><strong class="source-inline">
(List&lt;string&gt; filenames, Quality quality = </strong><code>Quality.Low)</code> method.</p>
<p>Create a <code>foreach</code> loop to loop through all the photos and to check whether each photo is specified in the <code>filenames</code><em class="italic"> </em>parameter. If a photo is specified in the <code>filenames</code> parameter, read the photo from the path, as in the first <code>Get</code><em class="italic"> </em>method:</p>
<pre class="source-code">
public partial async Task&lt;ObservableCollection&lt;Photo&gt;&gt; 
Get(List&lt;string&gt; filenames, Quality quality)
{
  var photos = new ObservableCollection&lt;Photo&gt;();
  var result = await Import();
  if (result.Length == 0)
  {
    return photos;
  }
  foreach (var path in result)
  {
    var filename = Path.GetFileName(path);
    if (!filenames.Contains(filename))
    {
      continue;
    }
    photos.Add(new Photo()
    {
      Bytes = File.ReadAllBytes(path),
      Filename = filename
    });
  }
  return photos;
}</pre> <p>With the <a id="_idIndexMarker634"/>Android importer finished, we can move to the final importer for Windows.</p>
<h3>Importing photos from the Windows photo gallery</h3>
<p>The final <a id="_idIndexMarker635"/>importer that we need is for the Windows platform. The code will follow the same pattern as for the other platforms; however, for Windows, we will use the <strong class="bold">Windows Search</strong> service to get the list of photos. Let’s see how this platform is implemented by following these steps:</p>
<ol>
<li>Import the <code>tlbimp-Windows.Search.Interop</code> and <code>System.Data.OleDB</code> NuGet packages. These are needed to search the filesystem for images.</li>
<li>Open the <code>GalleryApp</code> project by double-clicking it in <strong class="bold">Solution Explorer</strong>; edit the new imports to add a condition:<pre class="source-code">
&lt;PackageReference Include="System.Data.OleDb" Version="7.0.0" 
<strong class="bold">Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(Target</strong>
<strong class="bold">Framework)')) == 'windows'"</strong> /&gt;
&lt;PackageReference Include="tlbimp-Microsoft.Search.Interop" 
Version="1.0.0" <strong class="bold">Condition="$([MSBuild]::GetTargetPlatform</strong>
<code>PackageReference</code> so that it is only used when <code>TargetPlatformIdentifier</code> is <code>'windows'</code>.</p></li> <li>Create a new class called <code>PhotoImporter</code> in the <code>Windows</code> platform folder, and mark it as <code>partial</code>.</li>
<li>Change the namespace declaration from <code>GalleryApp.Platforms.Windows</code> to <code>GalleryApp.Services</code>.</li>
<li>The <code>partial</code> class definitions must be in the same namespace, even though they are in different folders.</li>
<li>Add <code>using</code> directives, so that we can use the classes in those namespaces:<pre class="source-code">
using GalleryApp.Models;
using Microsoft.Search.Interop;
using System.Data.OleDb;</pre></li> <li>Add a <code>private</code> field to hold the <code>QueryHelper</code> reference:<pre class="source-code">
ISearchQueryHelper queryHelper;</pre></li> <li>Like the <a id="_idIndexMarker636"/>previous implementations, we will start by implementing the <code>Import</code> method, so add a new method named <code>Import</code> as follows:<pre class="source-code">
private partial async Task&lt;string[]&gt; Import()
{
  var paths = new List&lt;string&gt;();
  return paths.ToArray();
}</pre></li> <li>Request permissions from the user to get the photos (highlighted in the following code block):<pre class="source-code">
private partial async Task&lt;string[]&gt; Import()
{
  var paths = new List&lt;string&gt;();
<strong class="bold">  var status = await AppPermissions.</strong>
<strong class="bold">CheckAndRequestRequiredPermission();</strong>
<strong class="bold">  if (status == PermissionStatus.Granted)</strong>
<strong class="bold">  {</strong>
<strong class="bold">  }</strong>
  return paths.ToArray();
}</pre></li> <li>Now, using <code>QueryHelper</code>, get all <a id="_idIndexMarker637"/>the image paths:<pre class="source-code">
private partial async Task&lt;string[]&gt; Import()
{
  var paths = new List&lt;string&gt;();
  var status = await AppPermissions.
CheckAndRequestRequiredPermission();
  if (status == PermissionStatus.Granted)
  {
<strong class="bold">    string sqlQuery = queryHelper.GenerateSQLFromUserQuery(" ");</strong>
<strong class="bold">    using OleDbConnection conn = new(queryHelper.</strong>
<strong class="bold">ConnectionString);</strong>
<strong class="bold">    conn.Open();</strong>
<strong class="bold">    using OleDbCommand command = new(sqlQuery, conn);</strong>
<strong class="bold">    using OleDbDataReader WDSResults = command.ExecuteReader();</strong>
<strong class="bold">    while (WDSResults.Read())</strong>
<strong class="bold">    {</strong>
<strong class="bold">      var itemUrl = WDSResults.GetString(0);</strong>
<strong class="bold">      paths.Add(itemUrl);</strong>
<strong class="bold">    }</strong>
  }
  return paths.ToArray();
}</pre><p class="list-inset">Here, <code>QueryHelper</code> is used to create a SQL query, and we use <code>OleDbConnection</code> to query the search index for all the matching files.</p></li> </ol>
<p>We can <a id="_idIndexMarker638"/>now start editing the <code>Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, int count, Quality quality = Quality.Low)</code> method. Add the following declaration to the <code>PhotoImporter</code> class:</p>
<pre class="source-code">
public partial async Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(int start, 
int count, Quality quality)
{
}</pre> <p>Now, we will start the implementation of the method by setting up file patterns and the locations we will search:</p>
<pre class="source-code">
string[] patterns = { ".png", ".jpeg", ".jpg" };
string[] locations = {
Environment.GetFolderPath(Environment.SpecialFolder.MyPictures),
      Environment.GetFolderPath(Environment.SpecialFolder.
CommonPictures),
     Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.
UserProfile),"OneDrive","Camera Roll")
};</pre> <p>These arrays <a id="_idIndexMarker639"/>define the file extensions and folders that we will search for photos. We will then create <code>QueryHelper</code> from the <code>tlbimp-Windows.Search.Interop</code> NuGet package and, using the arrays, configure the query parameters:</p>
<pre class="source-code">
queryHelper = new CSearchManager().GetCatalog("SystemIndex").
GetQueryHelper();
queryHelper.QueryMaxResults = start + count;
queryHelper.QuerySelectColumns = "System.ItemPathDisplay";
queryHelper.QueryWhereRestrictions = "AND (";
foreach (var pattern in patterns)
     queryHelper.QueryWhereRestrictions += " Contains(System.
FileExtension, '" + pattern + "') OR";
queryHelper.QueryWhereRestrictions = queryHelper.
QueryWhereRestrictions[..^2];
queryHelper.QueryWhereRestrictions += ")";
queryHelper.QueryWhereRestrictions += " AND (";
foreach (var location in locations)
     queryHelper.QueryWhereRestrictions += " scope='" + location + "' 
OR";
queryHelper.QueryWhereRestrictions = queryHelper.
QueryWhereRestrictions[..^2];
queryHelper.QueryWhereRestrictions += ")";
queryHelper.QuerySorting = "System.DateModified DESC";</pre> <p><code>QueryMaxResults</code> is set so that we only retrieve the results we are looking for. Then, we specify that the only data column to return is <code>"System.ItemPathDisplay"</code>. Next, we set <code>QueryWhereRestictions</code> from our list of extensions. Note the use of the <code>range</code> operator to remove the trailing <code>"OR"</code> in the query string. We use the same technique to add the locations to <code>QueryWhereRestrictions</code>. Finally, we set the sort order.</p>
<p>The remainder <a id="_idIndexMarker640"/>of the method is going to be very similar to those of the previous platforms. If the import succeeds, we will continue to handle what photos should be imported in this loading of images. Conditions are specified with the <code>start</code> and <code>count</code> parameters. Use the following code listing to complete the implementation of the first <code>Get</code> method:</p>
<pre class="source-code">
var photos = new ObservableCollection&lt;Photo&gt;();
var result = await Import();
if (result?.Length == 0)
{
  return photos;
}
Index startIndex = start;
Index endIndex = start + count;
if (endIndex.Value &gt;= result.Length)
{
  endIndex = result.Length;
}
if (startIndex.Value &gt; endIndex.Value)
{
  return photos;
}
foreach (var uri in result[startIndex..endIndex])
{
  var path = new System.Uri(uri).AbsolutePath;
  photos.Add(new()
  {
    Bytes = File.ReadAllBytes(path),
    Filename = Path.GetFileName(path)
  });
}
return photos;</pre> <p>Let’s quickly <a id="_idIndexMarker641"/>review the preceding code. The first step is to call the <code>Import</code> method and verify that there are photos to import. If there are none, we simply return an empty list. If there are photos to import, then we need to know <code>startIndex</code> and <code>endIndex</code> in the <code>photos</code> array to import. <code>startIndex</code> and <code>endIndex</code> are adjusted to make sure they are valid for the photos to import. Then, we can read the images from <code>startIndex</code> to <code>endIndex</code> from the array of photos and return the bytes from the file and just the name of the file for each entry.</p>
<p>Now, we will continue with the other <code>Task&lt;ObservableCollection&lt;Photo&gt;&gt; Get(List&lt;string&gt; filenames, Quality quality = Quality.Low)</code> method. Add the following declaration to the <code>PhotoImporter</code> class:</p>
<pre class="source-code">
public partial async Task&lt;ObservableCollection&lt;Photo&gt;&gt; 
Get(List&lt;string&gt; filenames, Quality quality)
{
}</pre> <p>Now, we will <a id="_idIndexMarker642"/>start the implementation of the method by setting the search parameters:</p>
<pre class="source-code">
queryHelper = new CSearchManager().GetCatalog("SystemIndex").
GetQueryHelper();
queryHelper.QuerySelectColumns = "System.ItemPathDisplay";
queryHelper.QueryWhereRestrictions = "AND (";
foreach (var filename in filenames)
     queryHelper.QueryWhereRestrictions += " Contains(System.Filename, 
'" + filename + "') OR";
queryHelper.QueryWhereRestrictions = queryHelper.
QueryWhereRestrictions[..^2];
queryHelper.QueryWhereRestrictions += ")";</pre> <p>For this method, we only need to add all the filenames to <code>QueryWhereRestrictions</code>. Following that, call the <code>Import</code> method, and if it returns results, then use a <code>foreach</code> loop to loop through all the photos and to check whether each photo is specified in the <code>filenames</code><em class="italic"> </em>parameter. If a photo is specified in the <code>filenames</code> parameter, read the photo from the path, as in the first <code>Get</code><em class="italic"> </em>method:</p>
<pre class="source-code">
var photos = new ObservableCollection&lt;Photo&gt;();
var result = await Import();
if (result?.Length == 0)
{
  return photos;
}
foreach (var uri in result)
{
  var path = new System.Uri(uri).AbsolutePath;
  var filename = Path.GetFileName(path);
  if (filenames.Contains(filename))
  {
    photos.Add(new()
    {
      Bytes = File.ReadAllBytes(path),
      Filename = filename
    });
  }
}
return photos;</pre> <p>The photo <a id="_idIndexMarker643"/>importers are now finished, and we are ready to write the rest of the app, which will mostly involve adding code that is shared between the platforms.</p>
<h3>Writing the app-initializing code</h3>
<p>We have now written the code that we will use to get <a id="_idTextAnchor537"/>data to the app. Let’s continue to build the app, starting <a id="_idIndexMarker644"/>with init<a id="_idTextAnchor538"/>ializing the core parts of the app.</p>
<h3>Wiring up dependency injection</h3>
<p>By using dependency injection as a pattern, we can keep our code cleaner and more testable. This <a id="_idIndexMarker645"/>app will use constructor injection, which means that all the dependencies that a class has must be passed through its constructor. The container then constructs objects for you, so you don’t have to <a id="_idIndexMarker646"/>care too much about the dependency chain. Since .NET MAUI already includes a dependency injection framework, <strong class="bold">Microsoft.Extensions.DependencyInjection</strong>, there is nothing extra to install.</p>
<p class="callout-heading">Confused about dependency injection?</p>
<p class="callout">Check out the <em class="italic">Wiring up a dependency injection</em> section in <em class="italic">Chapter 2</em>, <em class="italic">Building Our Fir<a id="_idTextAnchor539"/>st .NET MAUI App</em>, for <a id="_idTextAnchor540"/><a id="_idTextAnchor541"/>more details on dependency injection.</p>
<p>While it is recommended to use extension methods to group the types together, we have very few types in this app to register so we will use a different method in the next section.</p>
<h4>Registering PhotoImporter with dependency injection</h4>
<p>Let’s add <a id="_idIndexMarker647"/>the required code to <a id="_idIndexMarker648"/>register the types we have created so far, as shown in the following steps:</p>
<ol>
<li>In the <code>GalleryApp</code> project, open <code>MauiProgram.cs</code>.</li>
<li>Make the following changes to the <code>MauiProgram</code> class (the changes are highlighted):<pre class="source-code">
<strong class="bold">using GalleryApp.Services;</strong>
using Microsoft.Extensions.Logging;
public static class MauiProgram
{
  public static MauiApp CreateMauiApp()
  {
    var builder = MauiApp.CreateBuilder();
    builder
      .UseMauiApp&lt;App&gt;()
      .ConfigureFonts(fonts =&gt;
      {
        fonts.AddFont("OpenSans-Regular.ttf", 
"OpenSansRegular");
        fonts.AddFont("OpenSans-Semibold.ttf", 
"OpenSansSemibold");
      });
#if DEBUG
    builder.Logging.AddDebug();
#endif
  <strong class="bold">builder.Services.AddSingleton&lt;IPhotoImporter&gt;(serviceProvider </strong>
<strong class="bold">=&gt; new PhotoImporter<a id="_idTextAnchor542"/>());</strong>
    return builder.Build();
  }
}</pre></li> </ol>
<p>The .NET MAUI <code>MauiAppBuilder</code> class exposes the <code>Services</code> property, which is the dependency injection container. We simply need to add the types we want dependency injection to know about and the container will do the rest for us. Think of a builder <a id="_idIndexMarker649"/>as something that collects a lot of information on what needs to be done, and then builds the object we need. It’s a <a id="_idIndexMarker650"/>very useful pattern on its own, by the way.</p>
<p>We only use the builder for one thing at the moment. Later on, we will use it to register any class in the assembly that inherits from our abstract <code>ViewModel</code><em class="italic"> </em>class and our views. The container is now prepared for us to ask for these types.</p>
<h3>Creating a shell</h3>
<p>The main <a id="_idIndexMarker651"/>navigation for this app will be tabs at the bottom of the screen. The app <a id="_idIndexMarker652"/>will have a fly-out menu with two options—<strong class="bold">Home</strong> and <strong class="bold">Gallery</strong>:</p>
<ol>
<li>Create a new folder named <code>Views</code> in the project.</li>
<li>In the <code>Views</code> folder, create two new files using the <code>MainView</code> and one named <code>GalleryView</code>.</li>
<li>Delete the <code>MainPage.Xaml</code> and <code>MainPage.Xaml.cs</code> files from the root of the project since we won’t be needing those.</li>
<li>Open the <code>AppShell.xaml</code> file in the root of the project.<p class="list-inset">Add both views to the <code>Shell</code> object using the <code>ContentTemplate</code> property of <code>ShellContent</code>. Use the <code>DataTemplate</code> markup extension to load the view from the dependency injection container:</p><pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;Shell
    x:Class="GalleryApp.AppShell"
      
     
    
    <strong class="bold"></strong>&gt;
    <strong class="bold">&lt;ShellContent Title="Home" ContentTemplate="{DataTemplate views:MainView}" /&gt;</strong>
<strong class="bold">    &lt;ShellContent Title="Gallery" ContentTemplate="{D<a id="_idTextAnchor543"/>ataTemplate views:GalleryView}" /&gt;</strong>
&lt;/Shell&gt;</pre></li> <li>Since the <a id="_idIndexMarker653"/>views are loaded via <code>DataTemplates</code>, they must be <a id="_idIndexMarker654"/>registered with dependency injection. Add the highlighted code to <code>MauiProgram.cs</code>, after the <code>IPhotoInmporter</code> line:<pre class="source-code">
        builder.Services.
AddSingleton&lt;IPhotoImporter&gt;(serviceProvider =&gt; new 
PhotoImporter());
<strong class="bold">        builder.Services.AddTransient&lt;Views.MainView&gt;();</strong>
<strong class="bold">        builder.Services.AddTransient&lt;Views.GalleryView&gt;();</strong>
return builder.Build();</pre></li> </ol>
<p>Now that we have created a shell, let’s conti<a id="_idTextAnchor544"/>nue with some other b<a id="_idTextAnchor545"/>ase code before we start to create the views.</p>
<h3>Creating a base view model</h3>
<p>Before we create an actual view model, we will create an abstract base view model that all view <a id="_idIndexMarker655"/>models can inherit from. The idea behind this base <a id="_idIndexMarker656"/>view model is that we can write common code in it. In this case, we will implement the <code>INotifyPropertyChanged</code> interface by going through the following steps:</p>
<ol>
<li>In the <code>GalleryApp</code> project, create a folder named <code>ViewModels</code>.</li>
<li>Add a NuGet reference to <code>CommunityToolkit.Mvvm</code>; we use <code>CommunityToolkit.Mvvm</code> for implementing the <code>INotifyPropertyChanged</code> interface, as we have in other chapters.</li>
<li>Create a new abstract class named <code>ViewModel</code>:<pre class="source-code">
namespace GalleryApp.ViewModels;
using CommunityToolkit.Mvvm.ComponentModel;
public abstract partial class ViewModel: ObservableObject
{
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsNotBusy))]
    private bool isBusy;
    public bool IsNotBusy =&gt; !IsBusy;
    abstract protected internal Task Initialize();
}</pre></li> </ol>
<p>In this app’s <code>ViewModel</code> class, we have added an abstract method for <code>Initialize</code>. Each <code>ViewModel</code> implementation will override this method and load the images asynchronously for display. The <code>IsBusy</code> and <code>NotIsBusy</code> properties are used as flags to indicate when the data has completed loading.</p>
<p>Now, we have a <code>ViewModel</code> base that we c<a id="_idTextAnchor546"/>an use for all <code>ViewModel</code> insta<a id="_idTextAnchor547"/><a id="_idTextAnchor548"/><a id="_idTextAnchor549"/>nces that we will create later in this project.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor550"/>Creating the gallery view</h2>
<p>Now, we will <a id="_idIndexMarker657"/>start to build the views. We will start with the gallery view, which will show the photos as a grid. We will start with <code>GalleryViewModel</code>, and then create <code>GalleryView</code>. Creating the view model first allows Visual Studio to use the <code>GalleryViewModel</code> definition to check the syntax of the data bindings in the XAML file.</p>
<h3>Creating GalleryViewModel</h3>
<p><code>GalleryViewModel</code><em class="italic"> </em>is the class that will be responsible for fetching the data and handling <a id="_idIndexMarker658"/>the view logic. Because photos will be added asynchronously to the photo collection, we don’t want to set <code>IsBusy</code><em class="italic"> </em>to <code>false</code><em class="italic"> </em>immediately after we call the <code>Get</code><em class="italic"> </em>method of <code>PhotoImporter</code>. We will instead wait 3 seconds first. However, we will also add an event listener to the collection so that we can listen for changes. If the collection changes and there are items in it, we will set <code>IsBusy</code><em class="italic"> </em>to <code>false</code>. Create a class named <code>GalleryViewModel</code> in the <code>ViewModels</code> folder and add the following code to implement this:</p>
<pre class="source-code">
namespace GalleryApp.ViewModels;
using CommunityToolkit.Mvvm.ComponentModel;
using GalleryApp.Models;
using GalleryApp.Services;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
public partial class GalleryViewModel : ViewModel
{
    private readonly IPhotoImporter photoImporter;
    [ObservableProperty]
    public ObservableCollection&lt;Photo&gt; photos;
    public GalleryViewModel(IPhotoImporter photoImporter) : base()
    {
        this.photoImporter = photoImporter;
    }
    override protected internal async Task Initialize()
    {
        IsBusy = true;
        Photos = await photoImporter.Get(0, 20);
        Photos.CollectionChanged += Photos_CollectionChanged;
        await Task.Delay(3000);
        IsBusy = false;
    }
    private void Photos_CollectionChanged(object sender, System.
Collections.Specialized.NotifyCollectionChangedEventArgs e)
    {
        if (e.NewItems != null &amp;&amp; e.NewItems.Count &gt; 0)
        {
            IsBusy = false;
            Photos.CollectionChanged -= Photos_CollectionChanged;
        }
    }
}</pre> <p>Finally, register <code>GalleryViewModel</code> with <a id="_idIndexMarker659"/>dependency injection in <code>MauiProgram</code>:</p>
<pre class="source-code">
        builder.Services.AddSingleton&lt;IphotoImporter&gt;(serviceProvider 
=&gt; new PhotoImporter());
        <strong class="bold">builder.Services.AddTransient&lt;ViewModels.GalleryViewModel&gt;();</strong>
builder.Services.AddTransient&lt;Views.MainView&gt;();
builder.Services.AddTransient&lt;Views.GalleryView&gt;();
return builder.Build();</pre> <p>Now, <code>GalleryViewModel</code> is ready, so we can start to create <code>GalleryView</code>.</p>
<h3>Creating GalleryView</h3>
<p>First, we will <a id="_idIndexMarker660"/>create a converter that will convert <code>byte[]</code> to <code>Microsft.Maui.Controls.ImageSource</code>. In the <code>GalleryApp</code> project, create a new folder named <code>Converters</code>, and inside the folder, create a new class named <code>BytesToImageConverter</code>:</p>
<pre class="source-code">
namespace GalleryApp.Converters;
using System.Globalization;
internal class BytesToImageConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object 
parameter, CultureInfo culture)
    {
        if (value != null)
        {
            var bytes = (byte[])value;
            var stream = new MemoryStream(bytes);
            return ImageSource.FromStream(() =&gt; stream);
        }
        return null;
    }
    public object ConvertBack(object value, Type targetType, object 
parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}</pre> <p>To use <a id="_idIndexMarker661"/>the converter, we need to add it as a resource. We will do this by adding it to a <code>Resource</code><strong class="source-inline">
Dictionary</strong> object in the <code>Resources</code> property of <code>GalleryView</code>.</p>
<p>Open <code>GalleryView.xaml</code>, and add the following highlighted code to the view:</p>
<pre class="source-code">
&lt;ContentPage  
              
<strong class="bold">    </strong>
    x:Class="GalleryApp.Views.GalleryView"
    Title="GalleryView"&gt;
<strong class="bold">    &lt;ContentPage.Resources&gt;</strong>
<strong class="bold">      &lt;ResourceDictionary&gt;</strong>
<strong class="bold">        &lt;converters:BytesToImageConverter x:Key="ToImage" /&gt;</strong>
<strong class="bold">      &lt;/ResourceDic<a id="_idTextAnchor551"/>tionary&gt;</strong>
<strong class="bold">    &lt;/ContentPage.Resources&gt;</strong>
&lt;/ContentPage&gt;</pre> <p>To be <a id="_idIndexMarker662"/>able to bind to <code>ViewModel</code>, we will set <code>BindingContext</code><em class="italic"> </em>to <code>GalleryViewModel</code>. Use the constructor dependency injection in <code>GalleryView.xaml.cs</code> to create an instance of <code>GalleryViewModel</code>.</p>
<p>Open <code>GalleryView.xaml.cs</code>, and add the following highlighted code to the class:</p>
<pre class="source-code">
public GalleryView(<strong class="bold">GalleryViewModel viewModel</strong>)
{
    InitializeComponent();
    <strong class="bold">BindingContext = viewModel;</strong>
<strong class="bold">      MainThread.InvokeOnMainThreadAsync(viewModel.Initialize);</strong>
<code>GalleryViewModel</code>. That instance is set as <code>BindingContext</code> for the page. This object will be used in the XAML bindings of the view. Finally, we initialize the view model asynchronously.</p>
<p>What we <a id="_idIndexMarker663"/>will show in this view is a grid with three columns. To build this with .NET MAUI, we will use the <code>CollectionView</code> control. To specify the layout that <code>CollectionView</code> should have, add a <code>GridItemsLayout</code><em class="italic"> </em>element to the <code>ItemsLayout</code> property of <code>CollectionView</code>. Follow these steps to build this view:</p>
<ol>
<li>Navigate to <code>GalleryView.xaml</code>.<p class="list-inset">Import the namespaces for <code>GalleryApp.ViewModels</code> and <code>GalleryApp.Models</code> as <code>viewModels</code> and <code>models</code>, respectively:</p><pre class="source-code">

<strong class="bold"></strong>
<strong class="bold"></strong>
x:Class=" GalleryApp.Views.GalleryView"</pre></li> <li>On <code>ContentPage</code>, set <code>x:DataType</code> to <code>viewModels:GalleryViewModel</code>. This makes the bindings compile, which will make our view faster to render:<pre class="source-code">
&lt;CollectionView x:Name="Photos" ItemsSource="{Binding Photos}"&gt;
  &lt;CollectionView.ItemsLayout&gt;
    &lt;GridItemsLayout Orientation="Vertical" Span="3" 
HorizontalItemSpacing="0" /&gt;
  &lt;/CollectionView.ItemsLayout&gt;
  &lt;CollectionView.ItemTemplate&gt;
    &lt;DataTemplate x:DataType="models:Photo"&gt;
      &lt;Grid&gt;
        &lt;Image Aspect="AspectFill" Source="{Binding Bytes, 
Converter={StaticResource ToImage}}" HeightRequest="120" /&gt;
      &lt;/Grid&gt;
    &lt;/DataTempla<a id="_idTextAnchor552"/>te&gt;
  &lt;/CollectionView.ItemTemplate&gt;
&lt;/CollectionView&gt;</pre></li> </ol>
<p>Now, we can see the photos in the view. However, we will also need to create the content that <a id="_idIndexMarker664"/>will be shown when we don’t have any photos to show as they have not been loaded yet, or if there are no photos available. Add the following highlighted code to create a <code>DataTemplate</code> object to show when <code>CollectionView</code><em class="italic"> </em>doesn’t have any data:</p>
<pre class="source-code">
&lt;CollectionView :Name="Photos" ItemsSource="{Binding Photos}" 
<strong class="bold">EmptyView="{Binding}"</strong>&gt;
…
<strong class="bold">  &lt;CollectionView.EmptyViewTemplate&gt;</strong>
<strong class="bold">    &lt;DataTemplate x:DataType="viewModels:GalleryViewModel"&gt;</strong>
<strong class="bold">      &lt;Grid&gt;</strong>
<strong class="bold">        &lt;ActivityIndicator IsVisible="{Binding IsBusy}" /&gt;</strong>
<strong class="bold">        &lt;Label Text="No photos to import could be found" </strong>
<strong class="bold">IsVisible="{Binding IsNotBusy}" HorizontalOptions="Center" </strong>
<strong class="bold">VerticalOptions="Center" HorizontalTextAlignment="Center" /&gt;</strong>
<strong class="bold">      &lt;/Grid&gt;</strong>
<strong class="bold">    &lt;/DataTemplate&gt;</strong>
<strong class="bold">  &lt;/CollectionView.EmptyViewTemplate&gt;</strong>
&lt;/CollectionView&gt;</pre> <p>Now, we can run the app. The next <a id="_idTextAnchor553"/>step is to lo<a id="_idTextAnchor554"/>ad more photos when a user reaches the end of the view.</p>
<h3>Loading photos incrementally</h3>
<p>To load more than the first 20 items, we will load photos incrementally so that when users scroll <a id="_idIndexMarker665"/>to the end of <code>CollectionView</code>, it will start to load more items. <code>CollectionView</code> has built-in support for loading data incrementally. Because we get an <code>ObservableCollection</code><em class="italic"> </em>object back from the photo importer and data is added asynchronously to it, we need to create an event listener to handle when items are added to the photo importer so that we can add it to the <code>ObservableCollection</code><em class="italic"> </em>instance that we bound to <code>CollectionView</code>. Create the event listener by navigating to <code>GalleryViewModel.cs</code> and adding the following code at the end of the class:</p>
<pre class="source-code">
private int itemsAdded;
private void Collection_CollectionChanged(object sender, System.
Collections.Specialized.NotifyCollectionChangedEventArgs args)
  {
    foreach (Photo photo in args.NewItems)
    {
      itemsAdded++;
      Photos.Add(photo);
    }
    if (itemsAdded == 20)
    {
      var collection = (ObservableCollection&lt;Photo&gt;)sender;
      collection.CollectionChanged -= Collection_CollectionChanged;
    }
  }
  private int currentStartIndex = 0;
  [RelayCommand]
  public async Task LoadMore()
  {
    currentStartIndex += 20;
    itemsAdded = 0;
    var collection = await photoImporter.Get(currentStartIndex, 20);
    collection.CollectionChanged += Collection_CollectionChanged;
  }</pre> <p>The only <a id="_idIndexMarker666"/>thing we have left to do to get the incremental load to work is to bind <code>CollectionView</code> to the code we created in <code>ViewModel</code>. The following code will trigger the loading of more photos when the user has just five items left:</p>
<pre class="source-code">
&lt;CollectionView x:Name="Photos" EmptyView="{Binding}" 
ItemsSource="{Binding Photos}" <strong class="bold">RemainingItemsThreshold="5" </strong>
<strong class="bold">RemainingItemsThresholdReachedCommand="{Binding LoadMoreCommand}"</strong>&gt;</pre> <p>Now that we have a view that <a id="_idTextAnchor555"/>shows photos and loads them increment<a id="_idTextAnchor556"/>ally, we can make it possible to add photos as favorites.</p>
<h3>Saving favorites</h3>
<p>In <code>GalleryView</code>, we want <a id="_idIndexMarker667"/>to be able to select favorites that we can show in <code>MainView</code>. To do that, we need to store the photos that we have selected so that it remembers our selection. Create a new interface in the <code>GalleryApp</code> project named <code>ILocalStorage</code> in the <code>Services</code> folder:</p>
<pre class="source-code">
public interface ILocalStorage<a id="_idTextAnchor557"/>
{
  void  Store(string filename);
  List&lt;string&gt; Get();
}</pre> <p>The easiest <a id="_idIndexMarker668"/>way to store/persist data in .NET MAUI is to use the built-in property store. <code>Preferences</code> is a static class in the <code>Microsoft.Maui.Storage</code> namespace. Follow these steps to use it:</p>
<ol>
<li>Create a new class named <code>MauiLocalStorage</code> in the <code>Services</code> folder.</li>
<li>Implement the <code>ILocalStorage</code> interface:<pre class="source-code">
namespace GalleryApp.Services;
using System.Text.Json;
public class MauiLocalStorage : ILocalStorage
{
  public const string FavoritePhotosKey = "FavoritePhotos";
  public List&lt;string&gt; Get()
  {
    if (Preferences.ContainsKey(FavoritePhotosKey))
    {
      var filenames = Preferences.Get(FavoritePhotosKey,string.Empty);
      return JsonSerializer.Deserialize&lt;List&lt;string&gt;&gt;(filenames);
    }
    return new List&lt;string&gt;();
  }
  public void Store(string filename)
  {
    var filenames = Get();
    filenames.Add(filename);
    var json = JsonSerializer.Serialize(filenames);
    Preferences.Set(FavoritePhotosKey, json);
  }
}</pre></li> </ol>
<p>To be able to use <code>ILocalStorage</code> with constructor injection, we need to register it with the <a id="_idIndexMarker669"/>container. Navigate to the <code>MauiProgram</code> class and add the following highlighted code:</p>
<pre class="source-code">
builder.Services.AddSingleton&lt;IPhotoImporter&gt;(serviceProvider =&gt; new 
PhotoImporter());
<strong class="bold">builder.Services.AddTransient&lt;ILocalStorage&gt;(ServiceProvider =&gt; new </strong>
<strong class="bold">MauiLocalStorage());<a id="_idTextAnchor558"/></strong>
builder.Services.AddTransient&lt;ViewModels.MainViewModel&gt;();</pre> <p>Now, we are ready to use the local storage.</p>
<p>Navigate to the <code>GalleryViewModel</code> class, add the <code>ILocalStorage</code><em class="italic"> </em>interface to the constructor, and assign it to a field:</p>
<pre class="source-code">
private readonly IPhotoImporter photoImporter;
<strong class="bold">private readonly ILocalStorage localStorage;</strong>
public GalleryViewModel(IPhotoImporter photoImporter, <strong class="bold">ILocalStorage </strong>
<strong class="bold">localStorage</strong>)
{
  this.photoImporter = photoImporter;
  <strong class="bold">this.localStorage = localStorage;</strong>
}</pre> <p>The next step is to create a command that we can bind to from the view when we select photos. The command will monitor which photos we have selected and notify other views that we <a id="_idIndexMarker670"/>have added favorite photos. We will use <code>WeakReferenceManager</code> from <code>CommunityToolkit</code> to send messages from <code>GalleryViewModel</code> to <code>MainViewModel</code>.</p>
<p>Follow these steps to implement the <code>GalleryViewModel</code> side:</p>
<ol>
<li>Create a new class in the <code>Services</code> folder named <code>Messages</code>:<pre class="source-code">
namespace GalleryApp.Services;
internal static class Messages
{
  public const string FavoritesAddedMessage = 
nameof(FavoritesAddedMessage);
}</pre><p class="list-inset">This is used to define the message type we are sending to <code>MainViewModel</code>.</p></li> <li>Navigate to <code>GalleryViewModel</code>.</li>
<li>Create a new method named <code>AddFavorites</code> that is attributed to the <code>RelayCommand</code> type.</li>
<li>Add the following code:<pre class="source-code">
[RelayCommand]
public void AddFavorites(List&lt;Photo&gt; photos)
{
  foreach (var photo in photos)
  {
    localStorage.Store(photo.Filename);
  }
         WeakReferenceMessenger.Default.Send&lt;string&gt;(Messages.
FavoritesAddedMessage);
}</pre></li> </ol>
<p>Now, we are <a id="_idIndexMarker671"/>ready to start working with the view. The first thing we will do is make it possible to select photos. Navigate to <code>GalleryView.xaml</code> and set the <code>SelectionMode</code> mode of <code>CollectionView</code> to <code>Multiple</code> to make it possible to select multiple items:</p>
<pre class="source-code">
&lt;CollectionView x:Name="Photos" 
EmptyView="{Binding}" ItemsSource="{Binding Photos}" 
<strong class="bold">SelectionMode="Multiple"</strong> RemainingItemsThreshold="5" 
RemainingItemsThresholdReachedCommand="{Binding LoadMore}"&gt;</pre> <p>When a user selects a photo, we want it to be clear which photos have been selected. To achieve this, we will use <code>VisualStateManager</code>. We will do this by creating a style for <code>Grid</code> and setting <code>Opacity</code> to <code>0.5</code>, as in the following code. Add the code to <code>Resources</code> of the page:</p>
<pre class="source-code">
&lt;ContentPage.Resources&gt;
  &lt;ResourceDictionary&gt;
    &lt;converters:BytesToImageConverter x:Key="ToImage" /&gt;
<strong class="bold">      &lt;Style TargetType="Grid"&gt;</strong>
<strong class="bold">        &lt;Setter Property="VisualStateManager.VisualStateGroups"&gt;</strong>
<strong class="bold">          &lt;VisualStateGroupList&gt;</strong>
<strong class="bold">            &lt;VisualStateGroup x:Name="CommonStates"&gt;</strong>
<strong class="bold">              &lt;VisualState x:Name="Normal" /&gt;</strong>
<strong class="bold">                &lt;VisualState x:Name="Selected"&gt;</strong>
<strong class="bold">                  &lt;VisualState.Setters&gt;</strong>
<strong class="bold">                    &lt;Setter Property="Opacity" Value="0.5" /&gt;</strong>
<strong class="bold">                &lt;/VisualState.Setters&gt;</strong>
<strong class="bold">              &lt;/VisualState&gt;</strong>
<strong class="bold">            &lt;/VisualStateGroup&gt;</strong>
<strong class="bold">          &lt;/VisualStateGroupList&gt;</strong>
<strong class="bold">        &lt;/Setter&gt;</strong>
<strong class="bold">      &lt;/Style&gt;</strong>
  &lt;/ResourceDictionary&gt;
&lt;/ContentPage.Resources&gt;</pre> <p>To save <a id="_idIndexMarker672"/>the selected photos, we will create a toolbar item that the user can tap:</p>
<ol>
<li>Add <code>ToolbarItem</code> with the <code>Text</code> property set to <code>Select</code>.</li>
<li>Add an event handler named <code>SelectToolBarItem_Clicked</code>:<pre class="source-code">
&lt;ContentPage.ToolbarItems&gt;
    &lt;ToolbarItem Text="Select" Clicked="SelectToolBarItem_
Clicked" /&gt;
&lt;/ContentPage.ToolbarItems&gt;</pre></li> <li>Navigate to the code behind the <code>GalleryView.xaml.cs</code> file.</li>
<li>Add the following <code>using</code> statements:<pre class="source-code">
using GalleryApp.Models;
using GalleryApp.ViewModels;</pre></li> <li>Create an event handler named <code>SelectToolBarItem_Clicked</code>:<pre class="source-code">
private void SelectToolBarItem_Clicked(object sender, EventArgs e)
  {
    if (!Photos.SelectedItems.Any())
    {
      DisplayAlert("No photos", "No photos selected", "OK");
      return;
    }
    var viewModel = (GalleryViewModel)BindingContext;
         viewModel.AddFavoritesCommand.Execute(Photos.
SelectedItems.Select(x =&gt;(Photo)x).ToList());
    DisplayAlert("Added", "Selected photos have been added to 
favorites", "OK");
  }</pre></li> </ol>
<p>Now that <a id="_idIndexMarker673"/>we are d<a id="_idTextAnchor559"/>one with <code>GalleryView</code>, we will continue with the main view, which will <a id="_idTextAnchor560"/>show the latest photos and the favorite photos in two carousels.</p>
<h3>Creating the carousels for MainView</h3>
<p>The last <a id="_idIndexMarker674"/>view in this app is <code>MainView</code>, which is the view that is visible when users start the app. This view will sho<a id="_idTextAnchor561"/>w two ca<a id="_idTextAnchor562"/>rousel views—one with recent photos and one with favorite photos.</p>
<h3>Creating the view model for MainView</h3>
<p>We will <a id="_idIndexMarker675"/>start by creating <code>ViewModel</code> that we will use for the view. In the <code>ViewModel</code> folder, create a new class named <code>MainViewModel</code>:</p>
<pre class="source-code">
namespace GalleryApp.ViewModels;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Messaging;
using GalleryApp.Models;
using GalleryApp.Services;
using System.Collections.ObjectModel;
public partial class MainViewModel : ViewModel
{
  private readonly IPhotoImporter photoImporter;
  private readonly ILocalStorage localStorage;
  [ObservableProperty]
  private ObservableCollection&lt;Photo&gt; recent;
  [ObservableProperty]
  private ObservableCollection&lt;Photo&gt; favorites;
  public MainViewModel(IPhotoImporter photoImporter, ILocalStorage 
localStorage)
  {
    this.photoImporter = photoImporter;
    this.localStorage = localStorage;
  }
  override protected internal async Task Initialize()
  {
    var photos = await photoImporter.Get(0, 20, Quality.Low);
    Recent = photos;
    await LoadFavorites();
        WeakReferenceMessenger.Default.Register&lt;string&gt;(this, async 
(sender, message) =&gt; {
      if( message == Messages.FavoritesAddedMessage )
      {
        await MainThread.InvokeOnMainThreadAsync(LoadFavorites);
      }
    });
  }
  private async Task LoadFavorites()
  {
    var filenames = localStorage.Get();
    var favorites = await photoImporter.Get(filenames, Quality.Low);
    Favorites = favorites;
  }
}</pre> <p>In the preceding code, the <code>Initialize</code> method is used to register a callback with <code>Weak</code><strong class="source-inline">
ReferenceManager</strong>. This callback invokes the <code>LoadFavorites</code> method if the message sent was <code>Message.FavoritesAddedMessage</code>. Recall that <code>Messages.Favorites</code><strong class="source-inline">
AddedMessage</strong> is sent from <code>GalleryViewModel</code> after selecting new photos.</p>
<p>In the <code>LoadFavorites</code> method, the favorites are loaded from the storage provider instance in <code>localStorage</code>. Then, the photos from the favorites are imported using the <code>photoImporter</code> instance.</p>
<p>We need <a id="_idIndexMarker676"/>to add the view model to dependency injection so that we can use it in the view. Open <code>MauiProgram</code> and add the highlighted code:</p>
<pre class="source-code">
        builder.Services.AddTransient&lt;ILocalStorage&gt;(ServiceProvider 
=&gt; new MauiLocalStorage());
<strong class="bold">        builder.Services.AddTransient&lt;ViewModels.MainViewModel&gt;();</strong>
        builder.Services.AddTransient&lt;ViewModels.GalleryVie<a id="_idTextAnchor563"/>wModel&gt;();</pre> <p>Now that we h<a id="_idTextAnchor564"/>ave created <code>MainViewModel</code>, we will continue with the latest photos.</p>
<h3>Showing the latest photos</h3>
<p>We are <a id="_idIndexMarker677"/>now ready to set up the carousel views. We have already created the view model, so we can use the view model to populate the view with content.</p>
<p>Let’s look at the steps to create the view:</p>
<ol>
<li>In the constructor of the code, behind the <code>MainView.xaml.cs</code> file, set <code>ViewModel</code> to <code>BindingContext</code>:<pre class="source-code">
public MainView(<strong class="bold">MainViewModel viewModel</strong>)
{
  InitializeComponent();
  <strong class="bold">BindingContext = viewModel;</strong>
<strong class="bold">        MainThread.InvokeOnMainThreadAsync(viewModel.Initialize);</strong>
    }</pre></li> <li>Navigate to <code>MainView.xaml</code>.</li>
<li>Add the <a id="_idIndexMarker678"/>following code:<pre class="source-code">
&lt;ContentPage 
             
    
    
    
    x:Class="GalleryApp.Views.MainView"
    x:DataType="viewModels:MainViewModel"
    Title="My Photos"&gt;
  &lt;ContentPage.Resources&gt;
    &lt;ResourceDictionary&gt;
      &lt;converters:BytesToImageConverter x:Key="ToImage" /&gt;
    &lt;/ResourceDictionary&gt;
  &lt;/ContentPage.Resources&gt;
  &lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition Height="*" /&gt;
      &lt;RowDefinition Height="50" /&gt;
      &lt;RowDefinition Height="*" /&gt;
      &lt;RowDefinition Height="20" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;CarouselView ItemsSource="{Binding Recent}" 
PeekAreaInsets="40,0,40,0" &gt;
      &lt;CarouselView.ItemsLayout&gt;
        &lt;LinearItemsLayout Orientation="Horizontal"  SnapPointsAlignment="Start" 
SnapPointsType="Mandatory" /&gt;
      &lt;/CarouselView.ItemsLayout&gt;
      &lt;CarouselView.ItemTemplate&gt;
        &lt;DataTemplate x:DataType="models:Photo"&gt;
          &lt;Image Source="{Binding Bytes, 
Converter={StaticResource ToImage}}" Aspect="AspectFill" /&gt;
        &lt;/DataTemplate&gt;
      &lt;/CarouselView.ItemTemplate&gt;
    &lt;/CarouselView&gt;
  &lt;/Grid&gt;
&lt;/ContentPage&gt;</pre><p class="list-inset">The <code>CarouselView</code> control is used to present data to the user in a scrollable layout, where the user can swipe to move through the collection of items. It is very similar to <code>CollectionView</code>; however, the uses of the two controls are different. You would use <code>CollectionView</code> when you want to display a list of items with <a id="_idIndexMarker679"/>an indeterminate length, and <code>CarouselView</code> is used to highlight items from a list of items with a limited length. Since <code>CarouselView</code> shares implementations with the <code>CollectionView</code> control, it uses the familiar <code>ItemTemplate</code> property to customize how each item is displayed. It adds an <code>ItemsLayout</code> property to define how the collection of items is displayed. <code>CarouselView</code> can use either a <code>Horizontal</code> or <code>Vertical</code> layout direction, with <code>Horizontal</code> being the default.</p><p class="list-inset">In <code>MainView</code>, <code>CarouselView</code> is used to display the <code>Recent</code> photos from <code>MainViewModel</code>. <code>ItemsLayout</code> is customized to set the scrolling behavior so that items will snap into view using the start, or left edge of the image. The <code>SnapPointType</code> property set to <code>Mandatory</code> makes sure that <code>CarouselView</code> snaps the image into place after scrolling, which would ensure a single image is always in view.</p><p class="list-inset"><code>ItemsTemplate</code> is used to display an image that is data-bound to each photo and displays the image from the bytes in the <code>Photo</code> model. <code>BytesToImageConverter</code> converts the byte array from the <code>Photo</code> model into <code>ImageSource</code> that can be displayed by the <code>Image</code> control. The <code>Image</code> control has the <code>Aspect</code> property set to <code>AspectFill</code>, allowing the image control to resize the image, maintaining the aspect ratio of the source image to fill the available visible space.</p></li> </ol>
<p>Now that we have sho<a id="_idTextAnchor565"/>wn the latest photos in a carousel, the next (<a id="_idTextAnchor566"/>and the last) step is to show the favorite photos in another carousel.</p>
<h3>Showing the favorite photos</h3>
<p>The last thing we will do in this app is add a carousel to show favorite photos. Add the following <a id="_idIndexMarker680"/>highlighted code inside <code>Grid</code>, after the first <code>CarouselView</code>, as shown in the following code snippet:</p>
<pre class="source-code">
&lt;Grid&gt;
  &lt;!—Code omitted for brevity --&gt;
  &lt;CarouselView&gt;
    &lt;!—Code omitted for brevity --&gt;
  &lt;/CarouselView&gt;
<strong class="bold">  &lt;Label Grid.Row="1" Margin="10" Text="Favorites" FontSize="Subtitle" </strong>
<strong class="bold">FontAttributes="Bold" /&gt;</strong>
<strong class="bold">  &lt;CarouselView Grid.Row="2" ItemsSource="{Binding Favorites}" </strong>
<strong class="bold">PeekAreaInsets="0,0,40,0" IndicatorView="Indicator"&gt;</strong>
<strong class="bold">    &lt;CarouselView.ItemsLayout&gt;</strong>
<strong class="bold">      &lt;LinearItemsLayout Orientation="Horizontal" </strong>
<strong class="bold">SnapPointsAlignment="Start" SnapPointsType="MandatorySingle" /&gt;</strong>
<strong class="bold">    &lt;/CarouselView.ItemsLayout&gt;</strong>
<strong class="bold">    &lt;CarouselView.EmptyViewTemplate&gt;</strong>
<strong class="bold">      &lt;DataTemplate&gt;</strong>
<strong class="bold">        &lt;Label Text="No favorites selected" /&gt;</strong>
<strong class="bold">      &lt;/DataTemplate&gt;</strong>
<strong class="bold">    &lt;/CarouselView.EmptyViewTemplate&gt;</strong>
<strong class="bold">    &lt;CarouselView.ItemTemplate&gt;</strong>
<strong class="bold">      &lt;DataTemplate x:DataType="models:Photo"&gt;</strong>
<strong class="bold">        &lt;Border Grid.RowSpan="2" StrokeShape="RoundRectangle </strong>
<strong class="bold">15,15,15,15" Padding="0" Margin="0,0,0,0" BackgroundColor="#667788" &gt;</strong>
<strong class="bold">          &lt;Image Source="{Binding Bytes, Converter={StaticResource </strong>
<strong class="bold">ToImage}}" Aspect="AspectFill" /&gt;</strong>
<strong class="bold">        &lt;/Border&gt;</strong>
<strong class="bold">      &lt;/DataTemplate&gt;</strong>
<strong class="bold">    &lt;/CarouselView.ItemTemplate&gt;</strong>
<strong class="bold">  &lt;/CarouselView&gt;</strong>
<strong class="bold">  &lt;IndicatorView Grid.Row="3" x:Name="Indicator" HorizontalOptions="Center" SelectedIndicatorColor="Red" IndicatorColor="LightGray" /&gt;</strong>
&lt;/Grid&gt;</pre> <p>For the <code>Favorites</code> photos, again, <code>CarouselView</code> is used with a few changes from <code>CarouselView</code> displaying the <code>Recent</code> photos. The most visible change is that the <code>ItemsLayout</code> property is now using <code>MandatorySingle</code> for the value of <code>SnapPointsType</code>. This forces a behavior that only allows the user to swipe one image at <a id="_idIndexMarker681"/>a time, snapping each image into view.</p>
<p>The <code>ItemTemplate</code> property has also been changed to add a rounded border around each image, with a background color.</p>
<p>New to this <code>CarouselView</code> is the <code>EmptyViewTemplate</code> property. This is used to display the text <code>"No favorites selected"</code> when the <code>Favorites</code> property is empty.</p>
<p>Finally, <code>IndicatorView</code> was added to provide the user with a visual cue of how many items are in <code>CarouselView</code> and which item is currently displayed. <code>CarouselView</code> is connected to <code>IndicatorView</code> by the <code>IndicatorView</code> property of <code>CarouselView</code>. The <code>IndicatoryView</code> property is set to the <code>x:Name</code> property of <code>IndicatorView</code>. The <code>IndicatorView</code> displays on the page as a series of horizontal light gray dots, with the dot representing the current image in red.</p>
<p>That is all—now, we <a id="_idIndexMarker682"/>can run the app and see both <a id="_idTextAnchor567"/>the most recent photos and the photos that have been marked as favorites.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor568"/>Summary</h1>
<p>In this chapter, we focused on photos. We learned how to import photos from the platform-specific photo galleries and how we can display them as a grid using <code>CollectionView</code> and in carousels using <code>CarouselView</code>. This makes it possible for us to build other apps and provides multiple options for presenting data to users, as we can now pick the best method for the situation.</p>
<p>Additionally, we learned about permissions and how to check and request permission to use protected resources in our app.</p>
<p>If you are interested in extending the app even further, try creating a page to view the details of the photo, or to view the photo in full screen by tapping on the photo.</p>
<p>In the next chapter, we will build an app using location services and look at how to visualize location data on a map.</p>
</div>
</body></html>