- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Optimization with Profiler, Frame Debugger, and Memory Profiler
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Profiler、帧调试器和内存Profiler进行优化
- en: Welcome to the fourth part of this book—I am glad you have reached this part
    as it means that you have almost completed a full game! In this chapter, we are
    going to discuss optimization techniques to review your game’s performance and
    improve it, as having a good and constant framerate is vital to any game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第四部分——我很高兴你到达了这一部分，这意味着你几乎完成了一个完整游戏！在本章中，我们将讨论优化技术来审查你的游戏性能并提高它，因为保持良好的和稳定的帧率对任何游戏都是至关重要的。
- en: Performance is a broad topic that requires a deep understanding of several Unity
    systems and could span several books. We are going to look at how to measure performance
    and explore the effects of our changes to systems to learn how they work through
    testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是一个广泛的话题，需要深入理解几个Unity系统，可能涉及几本书的内容。我们将探讨如何衡量性能，并探索我们对系统所做的更改的影响，通过测试来了解它们是如何工作的。
- en: 'In this chapter, we will examine the following performance concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查以下性能概念：
- en: Optimizing graphics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形优化
- en: Optimizing processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化处理
- en: Optimizing memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化内存
- en: By the end of this chapter, you will be able to gather performance data of the
    three main pieces of hardware that run your game—the GPU, CPU, and RAM. You will
    be able to analyze that data to detect possible performance issues and understand
    how to solve the most common ones.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够收集运行你的游戏的三件主要硬件的性能数据——GPU、CPU和RAM。你将能够分析这些数据以检测可能存在的性能问题，并了解如何解决最常见的问题。
- en: We will start by learning how to optimize the graphics side of our game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何优化我们游戏中的图形方面。
- en: Optimizing graphics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形优化
- en: The most common cause of performance issues is related to the misuse of assets,
    especially on the graphics side, due to not having enough knowledge of how Unity’s
    graphics engines work. We are going to explore how a GPU works at a high level
    and how to improve its usage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题最常见的原因与资产误用有关，尤其是在图形方面，这主要是因为对Unity图形引擎工作原理了解不足。我们将探讨GPU在高级别上是如何工作的，以及如何提高其使用效率。
- en: 'In this section, we will examine the following graphics optimization concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下图形优化概念：
- en: Introduction to graphics engines
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形引擎简介
- en: Using Frame Debugger
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用帧调试器
- en: Using batching
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用批处理
- en: Other optimizations
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他优化
- en: We will start by looking at a high-level overview of how graphics are rendered
    to better understand the performance data that we will gather later in Frame Debugger.
    Based on the debugger’s results, we are going to identify the areas where we can
    apply **batching** (which is a technique to combine the rendering process of several
    objects, reducing its cost), along with other common optimizations to keep in
    mind.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看图形渲染的高级概述，以便更好地理解我们将在帧调试器中收集的性能数据。基于调试器的结果，我们将确定可以应用**批处理**（这是一种将多个对象的渲染过程组合起来的技术，以降低其成本）以及其他需要考虑的常见优化领域。
- en: Introduction to graphics engines
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形引擎简介
- en: Nowadays, every gaming device, whether it is a computer, a mobile device, or
    a console, has a video card—a set of hardware that specializes in graphics processing.
    It differs from a CPU in a subtle but important way. Graphics processing involves
    the processing of thousands of mesh vertices and the rendering of millions of
    pixels, so the GPU is designed to run short programs a massive number of times,
    while the CPU can handle programs of any length but with limited parallelization
    capabilities. The reason for having those processing units (CPU and GPU) is so
    that our program can use each one when needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个游戏设备，无论是电脑、移动设备还是游戏机，都有一个显卡——一组专门从事图形处理的硬件。它在微妙但重要的方式上与CPU不同。图形处理涉及处理数千个网格顶点和渲染数百万个像素，因此GPU被设计为运行简短程序数以万计次，而CPU可以处理任何长度的程序，但并行化能力有限。拥有这些处理单元（CPU和GPU）的原因是，我们的程序可以在需要时使用每一个。
- en: 'The problem here is that graphics don’t just rely on the GPU. The CPU is also
    involved in the process, making calculations and issuing commands to the GPU,
    so they must work together. For that to happen, both processing units need to
    communicate, and because they are (usually) physically separated, they need another
    piece of hardware to allow this: a bus, the most common type being the **Peripheral
    Component Interconnect Express** (**PCI Express**) bus.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是图形不仅仅依赖于GPU。CPU也参与了这个过程，进行计算并向GPU发出命令，因此它们必须协同工作。为了实现这一点，这两个处理单元需要通信，因为它们通常是物理上分开的，所以它们需要另一块硬件来实现这一点：总线，最常见的类型是**外围组件互连扩展**（**PCI
    Express**）总线。
- en: 'PCI Express is a type of connection that allows massive amounts of data to
    be moved between the GPU and CPU, but the problem is that even if it’s very fast,
    the communication time can be noticeable if you issue a lot of commands between
    both units. So, the key concept here is that graphics performance is improved
    mainly by reducing the communications between the GPU and CPU:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express是一种连接类型，允许在GPU和CPU之间移动大量数据，但问题是即使它非常快，如果你在这两个单元之间发出大量命令，通信时间也可能变得明显。因此，这里的关键概念是，图形性能主要通过减少GPU和CPU之间的通信来提高：
- en: '![](img/B18585_18_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_18_01.png)'
- en: 'Figure 18.1: CPU/GPU communication through a PCI Express bus'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：通过PCI Express总线进行的CPU/GPU通信
- en: Nowadays, new hardware architecture allows the CPU and GPU to coexist in the
    same chipset, reducing communication time and even sharing memory. Sadly, that
    architecture doesn’t allow the processing power needed for video games, as having
    those two pieces separated allows them to have enough space for a large number
    of cores.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，新的硬件架构允许CPU和GPU在同一芯片组中共存，减少通信时间，甚至共享内存。遗憾的是，这种架构不允许视频游戏所需的处理能力，因为将这两者分开可以让它们有足够的空间容纳大量核心。
- en: The basic algorithm of a graphics engine is to determine which objects are visible
    using culling algorithms, sorting and grouping them according to their similarities,
    and then issuing drawing commands to the GPU to render those groups of objects,
    sometimes more than once. The main form of communication between the CPU and GPU
    are the **drawing commands**, usually called **draw calls**, and our main task
    when optimizing graphics is to reduce them as much as we can. The problem is that
    there are several sources of draw calls that need to be considered, such as the
    lighting or certain special effects. Studying every single one of them will take
    a long time, and even so, new versions of Unity can introduce new graphics features
    with their own draw calls. Instead, we will explore a way to discover these draw
    calls using Frame Debugger.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图形引擎的基本算法是使用剔除算法确定哪些对象是可见的，根据它们的相似性对它们进行排序和分组，然后向GPU发出绘制命令以渲染这些对象组，有时会多次。CPU和GPU之间主要的通信形式是**绘制命令**，通常称为**绘制调用**，我们在优化图形时的主要任务是尽可能减少它们。问题是存在多个需要考虑的绘制调用来源，例如光照或某些特殊效果。研究每一个都需要花费很长时间，即使如此，Unity的新版本也可能引入具有自己绘制调用的新图形功能。相反，我们将探索使用帧调试器发现这些绘制调用的方法。
- en: Using Frame Debugger
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用帧调试器
- en: '**Frame Debugger** is a tool that allows us to see a list of all the draw calls
    that the Unity rendering engine sends to the GPU. It not only lists them but also
    provides information about each draw call, including the data needed to detect
    optimization opportunities. By using Frame Debugger, we can see how our changes
    modify the number of draw calls, giving us immediate feedback on our efforts.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧调试器**是一个工具，它允许我们查看Unity渲染引擎发送给GPU的所有绘制调用的列表。它不仅列出它们，还提供了有关每个绘制调用的信息，包括检测优化机会所需的数据。通过使用帧调试器，我们可以看到我们的更改如何修改绘制调用的数量，立即对我们的努力给出反馈。'
- en: Note that reducing draw calls is sometimes not enough to improve performance,
    as each draw call can have different processing times; but usually, that difference
    is not big enough to consider. Also, in certain special rendering techniques,
    such as ray tracing or ray marching, a single draw call can drain all of our GPU
    power. This won’t be the case in our game, so we won’t take that into account
    right now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，减少绘制调用有时并不足以提高性能，因为每个绘制调用可能具有不同的处理时间；但通常，这种差异并不足以考虑。此外，在某些特殊的渲染技术中，例如光线追踪或光线步进，单个绘制调用可能会耗尽我们所有的GPU性能。在我们的游戏中不会出现这种情况，所以我们现在不考虑这一点。
- en: 'Let’s use Frame Debugger to analyze the rendering process of our game by doing
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Open Frame Debugger (**Window** | **Analysis** | **Frame Debugger**).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game and when you want to analyze the performance, click the **Enable**
    button in the top-left corner of **Frame Debugger** (press *Esc* to regain control
    of the mouse while playing):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_18_02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.2: Enabling Frame Debugger'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Game** tab to open the Game view.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the slider to the right of the **Disable** button slowly from left to
    right to see how the scene is rendered. Each step is a draw call that is being
    executed in the CPU for that given game frame. You can also observe how the list
    in the left part of the window highlights the name of the executed draw call at
    that moment:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_18_03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.3: Analyzing our frame’s draw calls'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: If some of the draw calls in the list output a gray image in the Game panel,
    alongside a warning in the console, a temporary fix for this is selecting your
    scene’s Main Camera and setting the **MSAA** property in the **Output** section
    of its **Camera** component to **Off**. Remember to revert this change afterward
    using Frame Debugger.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on any draw call from the list and observe the details in the right part
    of the window.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Most of them can be confusing to you if you are not used to code engines or
    shaders, but you can see that some of them have a human-readable part that says
    **Why this draw call can’t be batched with the previous one**, which tells you
    why two objects weren’t drawn together in a single draw call. We will examine
    those reasons later:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18585_18_04.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.4: The batching break reasons in Frame Debugger'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: With the window open in **Play** mode, disable the terrain and see how the amount
    of draw calls changes immediately. Sometimes, just turning objects on and off
    can be enough to detect what is causing performance issues. Also, try disabling
    postprocessing and other graphics-related objects, such as particles.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if we are not fully aware of where each one of these draw calls came from,
    we can at least start by modifying the settings throughout Unity to see the impact
    of those changes. There’s no better way of discovering how something as massive
    as Unity works than going through every toggle and seeing the impact of those
    changes through a measuring tool. Of course, sometimes we just need to pay the
    price of certain draw calls to achieve certain effects, like in the case of the
    terrain, although you can always wonder if it’s worth it or not, but that would
    require a case-by-case analysis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Even if Frame Debugger gives us lots of info, sometimes you can take an extra
    step and use more advanced tools, like RenderDoc or Nvidia Nsight to mention some
    of them, which work similarly to Frame Debugger in the sense that they show all
    the draw calls, but also show info like the timings of each draw call, meshes,
    shaders, textures being used by each one of them, and much more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使帧调试器给我们提供了大量信息，有时你可以额外采取一步，并使用更高级的工具，如RenderDoc或Nvidia Nsight等，这些工具在功能上与帧调试器相似，即它们显示了所有的绘制调用，但还显示了每个绘制调用的计时信息、每个调用使用的网格、着色器和纹理等信息。
- en: Now, let’s discuss the basic techniques for reducing draw calls and see their
    effects in Frame Debugger.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论减少绘制调用的基本技术，并查看它们在帧调试器中的效果。
- en: Using batching
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用批处理
- en: We discussed several optimization techniques in previous chapters, with lighting
    being the most important one. If you measure the draw calls as you implement the
    techniques, you will notice the impact of those actions on the draw call count.
    However, in this section, we will focus on another graphics optimization technique
    known as batching. **Batching** is the process of grouping several objects to
    draw them together in a single draw call.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了几种优化技术，其中光照是最重要的。如果你在实现这些技术时测量绘制调用，你会注意到这些操作对绘制调用数量的影响。然而，在本节中，我们将关注另一种称为批处理的图形优化技术。**批处理**是将多个对象分组以在单个绘制调用中一起绘制的进程。
- en: You may be wondering why we can’t just draw everything in a single draw call,
    and while that is technically possible, there is a set of conditions that need
    to be met in order to combine two objects, the usual case being combining materials.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不能只在一个绘制调用中绘制所有内容，虽然这在技术上可行，但为了合并两个对象，需要满足一系列条件，通常情况是合并材质。
- en: Remember that materials are assets that act as graphics profiles, specifying
    a **Material** mode or shader and a set of parameters to customize the aspect
    of our objects, and remember that we can use the same material in several objects.
    If Unity has to draw an object with a different material than the previous one,
    a `SetPass` call needs to be called before issuing its draw call, which is another
    form of CPU/GPU communication used to set the **Material** properties in the GPU,
    such as its textures and colors. If two objects use the same materials, this step
    can be skipped. The `SetPass` call from the first object is reused by the second,
    and that opens the opportunity to batch the objects. If they share the same settings,
    Unity can combine the meshes into a single one in the CPU, and then send the combined
    mesh in a single draw call to the GPU.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，材料是作为图形配置文件使用的资产，它指定了一个**材质**模式或着色器以及一组参数来定制我们对象的外观，并且记住我们可以在多个对象中使用相同的材质。如果Unity需要绘制一个与上一个不同的材质的对象，必须在发出绘制调用之前调用`SetPass`，这是另一种形式的CPU/GPU通信，用于在GPU中设置**材质**属性，例如其纹理和颜色。如果两个对象使用相同的材质，则可以跳过此步骤。第一个对象的`SetPass`调用会被第二个对象重用，这为批处理对象打开了机会。如果它们共享相同的设置，Unity可以在CPU中将网格合并成一个，然后通过单个绘制调用将合并后的网格发送到GPU。
- en: 'There are several ways to reduce the number of materials, such as removing
    duplicates, but the most effective way is through a concept called **texture atlasing**.
    This means merging textures from different objects into a single one. This way,
    several objects can use the same material due to the fact that the texture used
    there can be applied to several objects and an object that has its own texture
    requires its own material. Sadly, there’s no automatic system in Unity to combine
    the textures of three-dimensional objects, such as the Texture Atlasobject we
    used in 2D. There are probably some systems in the Asset Store, but automatic
    systems can have several side effects. This work is usually done by an artist,
    so just keep this technique in mind when working with a dedicated 3D artist (or
    if you are your own artist):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以减少材质的数量，例如删除重复项，但最有效的方法是通过一个称为**纹理图集**的概念。这意味着将不同对象的纹理合并到一个纹理中。这样，由于使用的纹理可以应用于多个对象，因此多个对象可以使用相同的材质。遗憾的是，Unity中没有自动系统来合并三维对象的纹理，例如我们在2D中使用的Texture
    Atlas对象。可能有一些系统在Asset Store中，但自动系统可能会有一些副作用。这项工作通常由艺术家完成，所以当与专门的3D艺术家（或如果你是自己）工作时，请记住这个技术：
- en: '![](img/B18585_18_05.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_05.png)'
- en: 'Figure 18.5: Pieces of different metallic objects'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5：不同金属物体的碎片
- en: 'Let’s explore batching with Frame Debugger by doing the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下操作使用帧调试器探索批处理：
- en: 'Go to **Edit** | **Preferences** | **Core Render Pipeline** and set **Visibility**
    to **All Visible**. This will allow us to see both basic and advanced graphics
    settings:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑** | **首选项** | **核心渲染管线**并将**可见性**设置为**所有可见**。这将允许我们看到基本和高级图形设置：
- en: '![](img/B18585_18_06.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_06.png)'
- en: 'Figure 18.6: Enable the display of all available graphics settings'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6：启用显示所有可用图形设置
- en: 'Search for the **Scriptable Render Pipeline Settings** asset that we currently
    want to use (**Edit** | **Project Settings** | **Graphics** | **Scriptable Render
    Pipeline Settings**):'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索我们目前想要使用的**可脚本渲染管线设置**资产（**编辑** | **项目设置** | **图形** | **可脚本渲染管线设置**）：
- en: '![](img/B18585_18_07.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_07.png)'
- en: 'Figure 18.7: Scriptable Render Pipeline Settings'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7：可脚本渲染管线设置
- en: 'Uncheck **SRP Batcher** in the **Rendering** section and check **Dynamic Batching**.
    We will discuss **SRP Batcher** later in this chapter:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**渲染**部分取消勾选**SRP Batcher**并勾选**动态批处理**。我们将在本章后面讨论**SRP Batcher**：
- en: '![](img/B18585_18_08.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_08.png)'
- en: 'Figure 18.8: Disabling SRP Batcher'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8：禁用SRP Batcher
- en: Create a new empty scene for testing (**File** | **New Scene**).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为测试创建一个新的空场景（**文件** | **新建场景**）。
- en: Create two materials of different colors.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两种不同颜色的材质。
- en: Create two cubes and put one material into the first and the other into the
    second.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个立方体，并将一个材质放入第一个立方体，另一个材质放入第二个立方体。
- en: 'Open Frame Debugger and click **Enable** to see the call list for the draw
    calls of our cubes:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开帧调试器并点击**启用**以查看我们立方体的绘制调用列表：
- en: '![Text  Description automatically generated](img/B18585_18_09.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18585_18_09.png)'
- en: 'Figure 18.9: The draw calls for the cubes'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.9：立方体的绘制调用
- en: Select the second **Draw Mesh Cube** call and look at the batch-breaking reason.
    It should say that the objects have different materials.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第二个**绘制网格立方体**调用，并查看批处理中断的原因。它应该说明对象具有不同的材质。
- en: Use one of the materials on both cubes and look at the list again. You will
    notice that now we just have one **Draw Mesh Cube** call. You might need to disable
    and enable Frame Debugger again for it to refresh properly if you are not playing
    the game.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个立方体上使用相同的材质，并再次查看列表。你会注意到现在我们只有一个**绘制网格立方体**调用。如果你没有在玩游戏，可能需要再次禁用和启用帧调试器以正确刷新。
- en: Now, I challenge you to try the same steps but create spheres instead of cubes.
    If you do that, you will probably notice that even with the same materials, the
    spheres are not batched! Here is where we need to introduce the concept of **dynamic
    batching**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我挑战你尝试相同的步骤，但用球体代替立方体。如果你这样做，你可能会注意到，即使使用相同的材质，球体也没有被批处理！这就是我们需要引入**动态批处理**概念的地方。
- en: 'Remember that GameObjects have a **Static** checkbox, which serves to notify
    several Unity systems that the object won’t move so that they can apply several
    optimizations. Objects that don’t have this checkbox checked are considered dynamic.
    So far, the cubes and spheres we used for our tests have been dynamic, so Unity
    needed to combine them in every frame because they can move and combining is not
    “free.” Its cost is associated directly with the number of vertices in the model.
    You can get the exact numbers and all the required considerations from the Unity
    manual, which will appear if you search `Unity Batching` on the internet or can
    be accessed with this link: [https://docs.unity3d.com/Manual/DrawCallBatching.html](https://docs.unity3d.com/Manual/DrawCallBatching.html).
    However, it is enough to say that if the number of vertices of an object is big
    enough, that object won’t be batched, and doing so would require more than issuing
    two draw calls. That’s why our spheres weren’t batched; a sphere has too many
    vertices.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，GameObject有一个**静态**复选框，它用于通知几个Unity系统该对象不会移动，以便它们可以应用一些优化。未勾选此复选框的对象被认为是动态的。到目前为止，我们用于测试的立方体和球体都是动态的，因此Unity需要在每一帧将它们组合起来，因为它们可以移动，组合不是“免费的”。其成本与模型中的顶点数直接相关。你可以从Unity手册中获得确切的数字和所有必要的考虑，这可以通过在互联网上搜索`Unity
    Batching`或通过此链接访问：[https://docs.unity3d.com/Manual/DrawCallBatching.html](https://docs.unity3d.com/Manual/DrawCallBatching.html)。然而，可以说，如果一个对象的顶点数足够大，那么该对象就不会被批处理，这样做将需要发出超过两个绘制调用。这就是为什么我们的球体没有被批处理；球体有太多的顶点。
- en: 'Now, things are different if we have static objects because they use a second
    batching system—the **static batcher**. The concept of this is the same. Merge
    objects to render them in one draw call, and again these objects need to share
    the same material. The main difference is that this batcher will batch more objects
    than the dynamic batcher because the merging is done once at the time that the
    scene loads and is then saved in memory to use in the next frames, costing memory
    but saving lots of processing time with each frame. You can use the same approach
    we used to test the dynamic batcher to test the static version just by checking
    the **Static** checkbox of the spheres this time and seeing the result in **Play**
    mode; in **Edition** mode (when it is not playing), the static batcher won’t work:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有静态对象，情况就不同了，因为它们使用第二个批处理系统——**静态批处理器**。这个概念是相同的。合并对象以在一个绘制调用中渲染它们，并且这些对象需要共享相同的材质。主要区别在于，这个批处理器将批处理比动态批处理更多的对象，因为合并是在场景加载时一次性完成的，然后保存在内存中以供下一帧使用，这会消耗内存，但每个帧都会节省大量的处理时间。你可以使用我们用来测试动态批处理的方法来测试静态版本，只需这次检查球体的**静态**复选框，并在**播放**模式下查看结果；在**编辑**模式（当它没有播放时），静态批处理器不会工作：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_18_10.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序 描述自动生成](img/B18585_18_10.png)'
- en: 'Figure 18.10: A static sphere and its static batch'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.10：一个静态球体及其静态批处理
- en: Before moving on, let’s discuss why we disabled SRP Batcher and how that changes
    what we just discussed. In its 2020 edition, Unity introduced **Universal Render
    Pipeline** (**URP**), a new Render Pipeline.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们讨论一下为什么我们禁用了SRP Batcher以及这如何改变我们刚才讨论的内容。在2020版中，Unity引入了**通用渲染管线**（**URP**），这是一种新的渲染管线。
- en: 'Along with several improvements, one that is relevant right now is SRP Batcher,
    a new batcher that works on dynamic objects with no vertex or material limits
    (but with other limits). Instead of relying on sharing the same material with
    batch objects, SRP Batcher can have a batch of objects with materials that use
    the same shader, meaning we can have, for example, 100 objects with 100 different
    materials for each one, and they will be batched regardless of the number of vertices,
    as long as the material uses the same shader and Variant:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了几个改进之外，目前一个相关的改进是SRP Batcher，这是一个新的批处理器，它对没有顶点或材质限制的动态对象进行工作（但有其他限制）。SRP Batcher不是依赖于与批处理对象共享相同的材质，它可以有一个使用相同着色器的对象批处理，这意味着我们可以有，例如，100个对象，每个对象有100种不同的材质，并且它们将根据材质使用相同的着色器和变体进行批处理，只要材质使用相同的着色器和变体，无论顶点数量多少：
- en: '![A picture containing text, sign, screenshot  Description automatically generated](img/B18585_18_11.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、标志、屏幕截图的图片 描述自动生成](img/B18585_18_11.png)'
- en: 'Figure 18.11: GPU data persistence for materials, which allows SRP Batcher
    to exist'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.11：材质的GPU数据持久性，这允许SRP Batcher存在
- en: One shader can have several versions or Variants, and the selected Variant is
    chosen based on the settings. We can have a shader that doesn’t use normal mapping,
    and a Variant that doesn’t calculate normals will be used, so that can affect
    SRP Batcher. So, there’s basically no drawback to using SRP Batcher, so go ahead
    and turn it on again. Try creating lots of spheres with as many materials as you
    can and check the number of batches it will generate in Frame Debugger. Just consider
    that if you need to work on a project done in a pre-URP era, this won’t be available,
    so you will need to know the proper batching strategy to use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个着色器可以有多个版本或变体，选择的变体基于设置。我们可以有一个不使用法线贴图的着色器，以及一个不计算法线的变体将被使用，这可能会影响SRP Batcher。所以，使用SRP
    Batcher基本上没有缺点，所以请继续将其打开。尝试创建尽可能多的球体，使用尽可能多的材质，并在帧调试器中检查它将生成的批次数。只是考虑一下，如果你需要在一个URP时代之前完成的项目上工作，这将不可用，因此你需要知道适当的批处理策略来使用。
- en: Other optimizations
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他优化
- en: As mentioned before, there are lots of possible graphics optimizations, so let’s
    discuss briefly the basic ones, starting with **Level of Detail** (**LOD**). LOD
    is the process of changing the mesh of an object based on its distance to the
    camera. This can reduce draw calls if you replace, for example, a house with several
    parts and pieces with a single combined mesh with reduced detail when the house
    is far. Another benefit of using LOD is that you reduce the cost of a draw call
    because of the reduction in the vertex count.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有许多可能的图形优化，因此让我们简要讨论一下基本优化，从**细节级别**（**LOD**）开始。LOD是根据物体与摄像机的距离改变物体网格的过程。如果在物体距离较远时，用单个具有较少细节的合并网格替换由几个部分和部件组成的房子，这可以减少绘制调用。使用LOD的另一个好处是，由于顶点数量的减少，可以降低绘制调用的成本。
- en: 'To use this feature, do the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，请执行以下操作：
- en: 'Create an empty object and parent the two versions of the model. You need to
    use models that have several versions with different levels of detail, but for
    now, we are just going to test this feature using a cube and a sphere:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空对象，并将模型的两个版本作为父对象。你需要使用具有不同细节级别的好几个版本，但现在我们只是使用一个立方体和一个球体来测试这个功能：
- en: '![A picture containing diagram  Description automatically generated](img/B18585_18_12.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片  描述自动生成](img/B18585_18_12.png)'
- en: 'Figure 18.12: A single object with two LOD meshes'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12：一个具有两个LOD网格的单个对象
- en: Add a **LOD group** component to the parent.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**LOD组**组件添加到父对象中。
- en: 'The default **LOD group** is prepared to support three LOD meshes groups, but
    as we only have two, right-click on one and click **Delete**. You can also select
    **Insert Before** to add more LOD groups:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的**LOD组**已准备好支持三个LOD网格组，但因为我们只有两个，所以右键单击一个，然后点击**删除**。您也可以选择**插入之前**来添加更多LOD组：
- en: '![Funnel chart  Description automatically generated with low confidence](img/B18585_18_13.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![漏斗图  描述自动生成，置信度低](img/B18585_18_13.png)'
- en: 'Figure 18.13: Removing a LOD group'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.13：移除LOD组
- en: Select **LOD 0**, the highest-detail LOD group, and click on the **Add** button
    in the **Renderers** list below this to add the sphere to that group. You can
    add as many mesh renderers as you want.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**LOD 0**，这是最高细节的LOD组，然后点击下面的**渲染器**列表中的**添加**按钮，将该球体添加到该组。你可以添加任意数量的网格渲染器。
- en: 'Select **LOD 1** and add the cube:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**LOD 1**并添加立方体：
- en: '![Graphical user interface  Description automatically generated](img/B18585_18_14.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  描述自动生成](img/B18585_18_14.png)'
- en: 'Figure 18.14: Adding renderers to LOD groups'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.14：向LOD组添加渲染器
- en: Drag the line between the two groups to control the distance range that each
    group will occupy. As you drag it, you will see a preview of how far the camera
    needs to be to switch groups. Also, you have the **Culled** group, which is the
    distance from where the camera will not render any group.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动两个组之间的线来控制每个组将占据的距离范围。当你拖动时，你会看到相机需要移动多远才能切换组。此外，你还有**裁剪**组，这是相机不会渲染任何组的距离。
- en: Just move around the scene in the **Scene** panel to see how the meshes are
    swapped.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需在**场景**面板中移动场景，就可以看到网格是如何交换的。
- en: Something to consider here is that the colliders of the objects won’t be disabled,
    so just have the renderers in the LOD sub-objects. Put the collider with the shape
    of LOD 0 in the parent object, or just remove the colliders from the LOD group
    objects, except group 0.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里需要考虑的是，物体的碰撞器不会被禁用，所以只需在LOD子对象中放置渲染器。将LOD 0形状的碰撞器放在父对象中，或者只需从LOD组对象中移除碰撞器，除了组0。
- en: 'Another optimization to consider is **frustum culling**. By default, Unity
    will render any object that falls into the view area or frustum of the camera,
    skipping the ones that don’t. The algorithm is cheap enough to always use, and
    there’s no way to disable it. However, it does have a flaw. If we have a wall
    hiding all the objects behind it, even if they are occluded, they fall inside
    the frustum, so they will be rendered anyway. Detecting whether every pixel of
    a mesh occludes every pixel of the other mesh is almost impossible to do in real
    time, but luckily, we have a workaround: occlusion culling.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的优化是**视锥裁剪**。默认情况下，Unity会渲染任何落在摄像机视图区域或视锥体内的对象，跳过那些不在的对象。该算法足够便宜，可以始终使用，而且无法禁用它。然而，它确实有一个缺陷。如果我们有一堵墙隐藏了它后面的所有对象，即使它们被遮挡，它们也会落在视锥体内，所以它们仍然会被渲染。检测网格的每个像素是否遮挡了另一个网格的每个像素几乎是不可能在实时中完成的，但幸运的是，我们有一个解决方案：遮挡裁剪。
- en: '**Occlusion culling** is a process that analyzes a scene and determines which
    objects can be seen in different parts of the scene, dividing them into sectors
    and analyzing each one. As this process can take quite long, it is done in the
    editor, similarly to lightmapping. As you can imagine, it only works on static
    objects given its calculated in editor time. To use it, do the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**遮挡剔除**是一个分析场景并确定场景不同部分中可以看到哪些对象的过程，将它们分为区域并分析每一个。由于这个过程可能需要相当长的时间，它是在编辑器中完成的，类似于光照贴图。正如你可以想象的那样，它只对静态对象有效，因为它的计算是在编辑器中进行的。要使用它，请执行以下操作：'
- en: Mark the objects that shouldn’t move as static, or if you only want this object
    to be considered static for the occlusion culling system, check the **Occluder
    Static** and **Ocludee Static** checkboxes of the arrow to the right of the **Static**
    checkbox.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将不应移动的对象标记为静态，或者如果你只想让这个对象在遮挡剔除系统中被视为静态，请检查**静态**复选框右侧的箭头处的**遮挡者静态**和**被遮挡者静态**复选框。
- en: Open the **Occlusion Culling** window (**Window** | **Rendering** | **Occlusion
    Culling**).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**遮挡剔除**窗口（**窗口** | **渲染** | **遮挡剔除**）。
- en: Save the scene and hit the **Bake** button at the bottom of the window, and
    then wait for the baking process. If you don’t save the scene before the baking
    process, it won’t be executed.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并点击窗口底部的**烘焙**按钮，然后等待烘焙过程。如果你在烘焙过程之前没有保存场景，它将不会执行。
- en: Select the **Visualization** tab in the **Occlusion Culling** window.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**遮挡剔除**窗口中选择**可视化**选项卡。
- en: 'With the **Occlusion Culling** window visible, select the camera (or Virtual
    Camera in the case of a Cinemachine controlled camera) and drag it around, seeing
    how objects are occluded as the camera moves:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**遮挡剔除**窗口可见时，选择相机（或Cinemachine控制的相机的情况下的虚拟相机）并拖动它，观察随着相机移动，物体是如何被遮挡的：
- en: '![A picture containing outdoor, aircraft  Description automatically generated](img/B18585_18_15.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![包含户外和飞机的图片，描述自动生成](img/B18585_18_15.png)'
- en: 'Figure 18.15: On the left is the normal scene and on the right is the scene
    with occlusion culling'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.15：左侧是正常场景，右侧是应用了遮挡剔除的场景
- en: Take into account that if you move the camera outside the calculated area, the
    process won’t take place, and Unity will only calculate areas near the static
    objects. You can extend the calculation area by creating an empty object and adding
    an **Occlusion Area** component, setting its position and size to cover the area
    that the camera will reach, and, finally, rebaking the culling. Try to be sensible
    with the size of the cube. The larger the area to calculate, the larger the space
    needed in your disk to store the generated data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你将相机移动到计算区域之外，该过程将不会进行，Unity将只计算静态对象附近的区域。你可以通过创建一个空对象并添加**遮挡区域**组件来扩展计算区域，设置其位置和大小以覆盖相机将到达的区域，最后重新烘焙剔除。尽量对立方体的尺寸保持敏感。要计算的区域越大，你磁盘上存储生成的数据所需的空间就越大。
- en: 'You can use several of these areas to be more precise—for example, in an L-shaped
    scene, you can use two of them:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些区域中的几个来提高精确度——例如，在一个L形场景中，你可以使用其中的两个：
- en: '![Chart  Description automatically generated with medium confidence](img/B18585_18_16.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成，置信度中等](img/B18585_18_16.png)'
- en: 'Figure 18.16: Occlusion Area'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.16：遮挡区域
- en: If you see that the objects are not being occluded, it can be that the occluder
    object (the wall in this case) is not big enough to be considered. You can increase
    the size of the object or reduce the **Smallest Occluder** setting in the **Bake**
    tab of the window. Doing that will subdivide the scene further to detect small
    occluders, but that will take more space in the disk to store more data. So again,
    be sensible with this setting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到物体没有被遮挡，可能是因为遮挡对象（在这个例子中是墙壁）不够大，不能被考虑。你可以增加对象的大小或减少窗口**烘焙**选项卡中的**最小遮挡者**设置。这样做将进一步细分场景以检测小遮挡者，但这将在磁盘上占用更多空间来存储更多数据。因此，再次提醒，对这个设置保持敏感。
- en: There are still some more techniques that we can apply to our game, but the
    ones we have discussed are enough for our game. So, in this section, we learned
    about the process of rendering graphics in a video card, the concept of batches,
    how to profile them to know exactly how many of them we have and what they are
    doing, and finally, how to reduce them as much as we can. Now, let’s start discussing
    other optimization areas, such as the processing area.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还可以应用一些其他技术到我们的游戏中，但我们讨论的这些已经足够用于我们的游戏。因此，在本节中，我们学习了在视频卡中渲染图形的过程，批处理的概念，如何分析它们以确切知道我们有多少个批处理以及它们在做什么，最后，如何尽可能减少它们。现在，让我们开始讨论其他优化领域，例如处理领域。
- en: Optimizing processing
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化处理
- en: While graphics usually take up most of the time that a frame needs to be generated,
    we should never underestimate the cost of badly optimized code and scenes. There
    are several parts of the game that are still calculated in the CPU, including
    part of the graphics process (such as the batching calculations), physics, audio,
    and our code. Here, we have a lot more causes of performance issues than on the
    graphics side, so again, instead of discussing every optimization, let’s learn
    how to discover them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图形通常占用生成帧所需的大部分时间，但我们绝不能低估代码和场景优化不良的成本。游戏中有几个部分仍在CPU中进行计算，包括图形处理的一部分（如批处理计算）、物理、音频以及我们的代码。在这里，我们比图形方面有更多的性能问题原因，所以，我们再次不讨论每一个优化，而是学习如何发现它们。
- en: 'In this section, we will examine the following CPU optimization concepts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下CPU优化概念：
- en: Detecting CPU- and GPU-bound
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测CPU和GPU限制
- en: Using the **CPU Usage** Profiler
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**CPU使用情况**Profiler
- en: General CPU optimization techniques
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用CPU优化技术
- en: We will start by discussing the concepts of CPU- and GPU-bound, which focus
    on the optimization process, determining whether the problem is GPU- or CPU-related.
    Later, as with the GPU optimization process, we will look at how to gather the
    performance data of the CPU and interpret it to detect possible optimization techniques
    to be applied.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论CPU和GPU限制的概念，这些概念侧重于优化过程，确定问题是否与GPU或CPU相关。稍后，就像GPU优化过程一样，我们将探讨如何收集CPU的性能数据并解释它以检测可能要应用的优化技术。
- en: Detecting CPU- and GPU-bound
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测CPU和GPU限制
- en: As with Frame Debugger, the Unity Profiler allows us to gather data about the
    performance of our game through a series of Profiler modules, each one designed
    to gather data about different Unity systems per frame, such as physics, audio,
    and, most importantly, **CPU usage**. This last module allows us to see the most
    important operations that Unity executed to process the frame—which range from
    our scripts to systems such as physics and graphics (the CPU part).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与帧调试器类似，Unity Profiler允许我们通过一系列Profiler模块收集关于游戏性能的数据，每个模块都设计用来收集每帧不同Unity系统的数据，例如物理、音频，最重要的是**CPU使用情况**。这个最后的模块允许我们看到Unity执行以处理帧的最重要操作——从我们的脚本到物理和图形（CPU部分）等系统。
- en: Before exploring the **CPU usage**, one important bit of data that we can gather
    in this module is whether we are CPU or GPU bound. As explained before, a frame
    is processed using both the CPU and GPU, and those pieces of hardware can work
    in parallel. While the GPU is executing drawing commands, the CPU can execute
    physics and our scripts in a very efficient way. But now, let’s say that the CPU
    finishes its work while the GPU is still working. Can the CPU start to work on
    the next frame? The answer is no. This would lead to a de-synchronization, so
    in this scenario, the CPU will need to wait. This is known as CPU-bound, and we
    also have the opposite case, GPU-bound, when the GPU finishes earlier than the
    CPU.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索**CPU使用情况**之前，我们可以在本模块中收集的一个重要数据点是我们是否受CPU或GPU限制。正如之前所解释的，一个帧的处理既使用CPU也使用GPU，这些硬件可以并行工作。当GPU执行绘图命令时，CPU可以非常高效地执行物理和我们的脚本。但是，现在假设CPU完成其工作，而GPU仍在工作。CPU可以开始处理下一帧吗？答案是不了。这会导致不同步，因此在这种情况下，CPU需要等待。这被称为CPU-bound，我们还有相反的情况，即GPU-bound，当GPU比CPU先完成时。
- en: 'It is important to concentrate our optimization efforts, so if we detect that
    our game is GPU-bound, we will focus on GPU graphics optimization (like reduction
    of mesh and shader complexity), and if it is CPU-bound, then we will focus on
    the rest of the systems and the CPU side of graphics processing. To detect whether
    our game is one or the other, do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 集中我们的优化努力是很重要的，因此如果我们检测到我们的游戏是 GPU 限制的，我们将专注于 GPU 图形优化（如减少网格和着色器复杂性），如果是 CPU
    限制的，那么我们将专注于其他系统和图形处理的 CPU 部分。为了检测我们的游戏是哪种情况，请执行以下操作：
- en: Open **Profiler** (**Window** | **Analysis** | **Profiler**).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **分析器**（**窗口** | **分析** | **分析器**）。
- en: 'In the **Profiler Modules** dropdown in the top-left corner, tick **GPU** to
    enable the GPU profiler:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角的 **分析器模块** 下拉菜单中，勾选 **GPU** 以启用 GPU 分析器：
- en: '![Table  Description automatically generated](img/B18585_18_17.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![表格，描述自动生成](img/B18585_18_17.png)'
- en: 'Figure 18.17: Enabling the GPU profiler'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.17：启用 GPU 分析器
- en: Play the game and select the **CPU Usage** profiler, clicking on its name in
    the left part of the **Profiler** window.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放游戏并选择 **CPU 使用率** 分析器，点击 **分析器** 窗口的左侧部分其名称。
- en: 'Click the **Last Frame** button, the one with the double arrow pointing to
    the right, to always display info of the last frame being rendered:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **最后一帧** 按钮，即指向右的双箭头按钮，以始终显示正在渲染的最后一帧的信息：
- en: '![A picture containing calendar  Description automatically generated](img/B18585_18_18.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![包含日历的图片，描述自动生成](img/B18585_18_18.png)'
- en: 'Figure 18.18: Last frame button (double arrow to the right)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.18：最后一帧按钮（向右的双箭头）
- en: 'Also click the **Live** button to enable Live mode, which allows you to see
    the results of profiling in real time. This can have an impact on performance,
    so you can disable it later:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还点击 **Live** 按钮以启用实时模式，这允许你实时查看分析结果。这可能会影响性能，因此你可以稍后禁用它：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_18_19.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序，描述自动生成](img/B18585_18_19.png)'
- en: 'Figure 18.19: Enabling Live mode'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.19：启用实时模式
- en: 'Observe the bar with the **CPU** and **GPU** labels in the middle of the window.
    It should say how many milliseconds are being consumed by the CPU and GPU. The
    one with the higher number will be the one that is limiting our framerate and
    will determine whether we are GPU- or CPU-bound:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察窗口中间带有 **CPU** 和 **GPU** 标签的条形图。它应该说明 CPU 和 GPU 消耗了多少毫秒。数值较高的那个将是限制我们的帧率的那个，并确定我们是
    GPU-还是 CPU-限制的：
- en: '![A picture containing table  Description automatically generated](img/B18585_18_20.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![包含表格的图片，描述自动生成](img/B18585_18_20.png)'
- en: 'Figure 18.20: Determining whether we are CPU- or GPU-bound'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.20：确定我们是 CPU-还是 GPU-限制的
- en: 'There is a chance that when you try to open the GPU profiler, you will see
    a not supported message, and this can happen in certain cases (such as on Mac
    devices that use the Metal graphics API). In that scenario, another way to see
    whether we are GPU-bound is by searching `waitforpresent` in the search bar right
    next to the CPU/GPU labels while selecting the **CPU Usage** profiler. If you
    don’t see the search bar, click the drop-down menu at the left of **Live** (which
    should say **Timeline**) and select **Hierarchy**:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能当你尝试打开 GPU 分析器时，你会看到一个不支持的消息，这种情况可能发生在某些情况下（例如在使用 Metal 图形 API 的 Mac 设备上）。在这种情况下，另一种查看我们是否是
    GPU 限制的方法是在选择 **CPU 使用率** 分析器时，在 CPU/GPU 标签旁边的搜索栏中搜索 `waitforpresent`。如果你看不到搜索栏，点击
    **Live**（应显示为 **时间轴**）左侧的下拉菜单并选择 **层次结构**：
- en: '![](img/B18585_18_21.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_21.png)'
- en: 'Figure 18.21: Searching waitforpresent'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.21：搜索 waitforpresent
- en: Here, you can see how long the CPU has been waiting for the GPU. Check the **Time
    ms** column to get the number. If you see **0.00**, it is because the CPU is not
    waiting for the GPU, meaning we are CPU-bound. In the preceding screenshot, you
    can see that my screen displays **0.00** while the CPU is taking **9.41ms** and
    the GPU is taking **6.73ms**. So, my device is CPU-bound, but consider your device
    and project can bring different results.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 CPU 等待 GPU 的时间有多长。检查 **时间 ms** 列以获取数字。如果你看到 **0.00**，这意味着 CPU 不在等待
    GPU，这意味着我们是 CPU-限制的。在前面的屏幕截图中，你可以看到我的屏幕显示 **0.00**，而 CPU 正在消耗 **9.41ms**，GPU 正在消耗
    **6.73ms**。所以，我的设备是 CPU-限制的，但请考虑你的设备和项目可能带来不同的结果。
- en: Now that we can detect whether we are CPU- or GPU-bound, we can focus our optimization
    efforts. So far, we discussed how to profile and optimize part of the GPU process
    in the *Optimizing graphics* section. Now, if we detect that we are CPU-bound,
    let’s see how to profile the CPU.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够检测到我们是CPU受限还是GPU受限，我们可以集中优化努力。到目前为止，我们在*优化图形*部分讨论了如何分析和优化GPU过程的一部分。现在，如果我们检测到我们是CPU受限，让我们看看如何分析CPU。
- en: Using the CPU Usage Profiler
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CPU使用率分析器
- en: Profiling the CPU is done in a similar way to profiling the GPU. We need to
    get a list of actions the CPU executes and try to reduce the number of them, or
    at least reduce their cost. Here is where the **CPU Usage Profiler** module comes
    in—a tool that allows us to see all the instructions that the CPU executed in
    one frame. The main difference is that the GPU mostly executes draw calls, and
    we have a few types of them, while the CPU can have hundreds of different instructions
    to execute, and sometimes some of them cannot be deleted, such as physics or audio
    processing. In these scenarios, we are looking to reduce the cost of these functions
    in case they are consuming too much time. So, again, an important note here is
    to detect which function is taking too much time and then reduce its cost or remove
    it, which requires a deeper understanding of the underlying system. Let’s start
    detecting the function first.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 分析CPU的方式与分析GPU的方式类似。我们需要获取CPU执行的动作列表，并尝试减少它们的数量，或者至少减少它们的成本。在这里，**CPU使用率分析器**模块就派上用场了——这是一个允许我们查看CPU在一个帧中执行的所有指令的工具。主要区别在于GPU主要执行绘制调用，我们只有几种类型，而CPU可以执行数百种不同的指令，有时其中一些指令无法删除，例如物理或音频处理。在这些情况下，我们希望减少这些函数的成本，以防它们消耗了太多时间。因此，在这里的一个重要提示是检测哪个函数消耗了太多时间，然后减少其成本或删除它，这需要更深入地了解底层系统。让我们首先开始检测函数。
- en: When you play the game with the **Profiler** tab opened, you will see a series
    of graphics showing the performance of your game, and in the **CPU Usage** profiler,
    you will see that the graphic is split into different colors, each one referring
    to different parts of frame processing. You can check the information to the left
    of the Profiler to see what each color means, but let’s discuss the most important
    ones.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在打开**分析器**标签的情况下玩游戏时，你会看到一系列显示游戏性能的图形，在**CPU使用率**分析器中，你会看到图形被分成不同的颜色，每个颜色都指代帧处理的不同部分。你可以查看分析器左侧的信息，以了解每种颜色的含义，但让我们讨论最重要的几个。
- en: 'In the following screenshot, you can see how the graphic should look:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以看到图形应该如何显示：
- en: '![Chart  Description automatically generated](img/B18585_18_22.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B18585_18_22.png)'
- en: 'Figure 18.22: Analyzing the CPU Usage graph'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.22：分析CPU使用率图
- en: 'If you see the graphic, you will probably assume that the dark-green part of
    the graph is taking up most of the performance time, and while that is true, you
    can also see from the legend that dark green means **Others**, and that’s because
    we are profiling the game in the editor. The editor won’t behave exactly like
    the final game. In order for it to run, it has to do lots of extra processing
    that won’t be executed in the game, so the best you can do is profile directly
    in the build of the game. There, you will gather more accurate data. We are going
    to discuss how to do builds in the next chapter, so for now, we can ignore that
    area. What we can do now is simply click on the colored square to the left of
    the **Others** label to disable that measurement from the graph in order to clean
    it up a little bit. If you also see a large section of yellow, it is referring
    to **VSync**, which is basically the time spent waiting for our processing to
    match the monitor’s refresh rate. This is also something that we can ignore, so
    you should also disable it. In the next screenshot, you can check the graphic
    color categories and how to disable them:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到图形，你可能会认为图表中深绿色的部分占据了大部分的性能时间，虽然这是真的，但你也可以从图例中看到，深绿色代表**其他**，这是因为我们在编辑器中分析游戏。编辑器不会表现得完全像最终的游戏。为了运行它，它必须执行许多额外的处理，这些处理在游戏中不会执行，所以你能做的最好的事情就是直接在游戏构建中进行分析。在那里，你会收集到更准确的数据。我们将在下一章讨论如何进行构建，所以现在我们可以忽略那个区域。我们现在能做的就是简单地点击**其他**标签左侧的彩色方块，以从图中禁用该测量，以便稍微清理一下。如果你也看到一个很大的黄色部分，它指的是**垂直同步**，这基本上是我们等待处理与显示器刷新率匹配的时间。这也是我们可以忽略的东西，所以你也应该禁用它。在下一张屏幕截图中，你可以检查图形颜色类别以及如何禁用它们：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_18_23.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18585_18_23.png)'
- en: 'Figure 18.23: Disabling VSync and Others from the Profiler'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.23：从性能分析器中禁用 VSync 及其他设置
- en: Now that we have cleaned up the graph, we can get a good idea of our game’s
    potential framerate by looking at the line with the **ms** label (in our case,
    **5ms (200FPS)**), which indicates that frames below that line have more than
    200 FPS, and frames above that line have less.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清理了图表，我们可以通过查看带有**ms**标签的线条（在我们的案例中，**5ms (200FPS)**）来了解我们游戏潜在帧率的良好概念，这表明低于该线的帧有超过
    200 FPS，而高于该线的帧则较少。
- en: In my case, I have excellent performance, but remember, I am testing this on
    a powerful machine. The best way to profile is not only in the build of the game
    (as an executable) but also in the target device, which should be the lowest-spec
    hardware we intend our game to run on. Our target device depends a lot on the
    target audience of the game. If we are making a casual game, we are probably targeting
    mobile devices, so we should test the game on the lowest-spec phone we can, but
    if we are targeting hardcore gamers, they will probably have a powerful machine
    to run our game on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我拥有出色的性能，但请记住，我是在一台强大的机器上测试的。进行性能分析的最佳方式不仅是在游戏的构建（作为可执行文件）中，还包括在目标设备上，这应该是我们打算让游戏运行的最低配置硬件。我们的目标设备很大程度上取决于游戏的目标受众。如果我们正在制作休闲游戏，我们可能针对的是移动设备，因此我们应该在最低配置的手机上测试游戏，但如果我们的目标是针对核心玩家，他们可能拥有强大的机器来运行我们的游戏。
- en: If you are targeting hardcore gamers, of course, this doesn’t mean that we can
    just make a very unoptimized game because of that, but it will give us enough
    processing space to add more detail. Anyway, I strongly recommend you avoid those
    kinds of games if you are a beginner as they are more difficult to develop, which
    you will probably realize. Stick to simple games to begin with.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你针对的是核心玩家，当然，这并不意味着我们可以因为这一点就制作一个非常未优化的游戏，但这将给我们足够的空间来添加更多细节。无论如何，我强烈建议如果你是初学者，避免那些类型的游戏，因为它们更难开发，你可能很快就会意识到这一点。一开始就坚持简单的游戏。
- en: Looking at the graphics colors, you can observe the cost on the CPU side of
    rendering in light green, which the graph shows is taking up a significant portion
    of the processing time, which is actually normal. Then, in blue, we can see the
    cost of our scripts’ and others systems’ execution, which is also taking up a
    significant portion, but again, this is quite normal. Also, we can observe a little
    bit of orange, which is physics, and also a little bit of light blue, which is
    animations. Remember to check the colored labels in the Profiler to remember which
    color refers to what.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察图形颜色，你可以观察到渲染在 CPU 方面的成本以浅绿色表示，图表显示它占用了相当一部分的处理时间，这是正常的。然后，在蓝色中，我们可以看到我们的脚本和其他系统执行的代价，这也占用了相当一部分，但同样，这也是相当正常的。我们还可以观察到一点橙色，代表物理，还有一点浅蓝色，代表动画。请记住检查性能分析器中的彩色标签，以记住哪种颜色代表什么。
- en: 'Now, those colored bars represent a group of operations, so if we consider
    the **Rendering** bar to be representing 10 operations, how do we know which operations
    that includes? Also, how do we know which of these operations is taking up the
    most performance time? Out of those 10 operations, a single one could be causing
    these issues. Here is where the bottom part of the profiler is useful. It shows
    a list of all the functions being called in the frame. To use it, do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，那些彩色条代表一组操作，如果我们认为**渲染**条代表 10 个操作，我们如何知道这包括哪些操作？同样，我们如何知道这些操作中哪一个占用了最多的性能时间？在这
    10 个操作中，任何一个都可能是导致这些问题的原因。这就是性能分析器底部部分有用的地方。它显示了一帧中所有被调用的函数列表。要使用它，请执行以下操作：
- en: Click any part of the *CPU Usage* section in the Profiler and check that the
    button at the top-left part of the bottom bar of the Profiler says **Hierarchy**.
    If not (for example, if it says **Timeline**), click it and select **Hierarchy**.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击性能分析器中**CPU 使用率**部分的任何部分，并检查性能分析器底部栏左上角的按钮是否显示为**层次结构**。如果不是（例如，如果显示为**时间线**），点击它并选择**层次结构**。
- en: Clear the search bar we used earlier. It will filter function calls by name,
    and we want to see them all.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除我们之前使用的搜索栏。它将按名称过滤函数调用，而我们希望看到所有调用。
- en: Click on the **Time ms** column until you see an arrow pointing downward. This
    will order the calls by cost in descending order.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**时间 ms**列，直到你看到一个指向下方的箭头。这将按成本降序排列调用。
- en: Click on a frame that catches your attention in the graph—probably one of the
    ones with the biggest height that consume more processing time. This will make
    the Profiler stop the game straight away and show you information about that frame.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图表中引起你注意的帧——可能是那些高度最大、消耗更多处理时间的帧之一。这将使Profiler立即停止游戏并显示有关该帧的信息。
- en: There are two things to consider when looking at the graph. If you see peaks
    that are significantly higher than the rest of the frames, that can cause a hiccup
    in your game—a very brief moment where the game is frozen—which can break the
    performance. Also, you can look for a long series of frames with higher time consumption.
    Try to reduce them as well. Even if this is only temporary, the impact of it will
    be easily perceived by the player, especially in VR games, as that could induce
    nausea.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看图表时，有两个方面需要考虑。如果你看到高于其他帧的峰值，这可能会在游戏中造成中断——一个非常短暂的瞬间，游戏会冻结，这可能会破坏性能。此外，你可以寻找长时间消耗较高的帧序列。尝试减少它们。即使这只是一个临时的解决方案，但玩家很容易就能感知到它的影响，尤其是在VR游戏中，因为这可能会引起恶心。
- en: '**PlayerLoop** will probably appear as the most time-consuming frame, but that’s
    not very informative. You can explore it further by expanding it by clicking on
    the arrow to its left.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PlayerLoop** 可能会显示为耗时最长的帧，但这并不很有信息量。你可以通过点击其左侧的箭头进一步探索它。'
- en: 'Click on each function to highlight it in the graph. Functions with higher
    processing times will be highlighted with thicker bars, and those are the ones
    we will focus on:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击每个函数以在图表中突出显示它。处理时间较长的函数将以较粗的条形显示，我们将重点关注这些函数：
- en: '![Table  Description automatically generated with medium confidence](img/B18585_18_24.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成，置信度中等](img/B18585_18_24.png)'
- en: 'Figure 18.24: The Render Camera function highlighted in the graph'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.24：图中突出显示的渲染相机功能
- en: 'You can keep clicking on the arrows to further explore the functions until
    you hit a limit. If you want to go deeper, enable the **Deep Profile** mode in
    the top bar of the Profiler. This will give you more details, but take into account
    that this process is expensive and will make the game go slower, altering the
    time shown in the graph, making it appear much higher than the real time. Here,
    ignore the numbers and look at how much of the process a function is taking up
    based on the graph. You will need to stop, enable **Deep Profile**, and play it
    again to make it work:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以继续点击箭头以进一步探索函数，直到达到限制。如果你想深入了解，可以在Profiler的顶部栏中启用**深度分析**模式。这将提供更多细节，但请注意，这个过程成本高昂，会使游戏运行变慢，改变图表中显示的时间，使其看起来比实际时间高得多。在这里，忽略数字，根据图表查看函数占用的过程量。你需要停止，启用**深度分析**，然后再次播放以使其工作：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_18_25.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或短信描述自动生成](img/B18585_18_25.png)'
- en: 'Figure 18.25: Enabling Deep Profile'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.25：启用深度分析
- en: With this knowledge, we can start improving our game performance (if it’s below
    the target framerate), but each function is called by the CPU and is improved
    in its own unique way, which requires greater knowledge about Unity’s internal
    workings. That could span several books, and anyway, the internals change on a
    version-to-version basis. Instead, you could study how each function works by
    looking up data about that specific system on the internet and official documentation,
    or again, by just disabling and enabling objects or parts of our code to explore
    the impact of our actions, as we did with Frame Debugger. Profiling requires creativity
    and inference to interpret and react accordingly to the data obtained, so you
    will need some patience here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些知识，我们可以开始提高我们的游戏性能（如果它低于目标帧率），但每个函数都是由CPU调用的，并且以它独特的方式得到改进，这需要我们对Unity内部工作有更深入的了解。这可能需要几本书的内容，而且无论如何，内部结构会随着版本的不同而变化。相反，你可以通过在网上查找关于该特定系统的数据以及官方文档来研究每个函数的工作原理，或者再次，通过禁用和启用我们的代码或其部分来探索我们行动的影响，就像我们在帧调试器中所做的那样。性能分析需要创造力和推理来解释和相应地反应所获得的数据，因此你需要一些耐心。
- en: Now that we have discussed how to get the profiling data relating to the CPU,
    let’s discuss some common ways to reduce **CPU usage**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了如何获取与CPU相关的性能分析数据，那么让我们来讨论一些常见的降低**CPU使用率**的方法。
- en: General CPU optimization techniques
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用CPU优化技术
- en: In terms of CPU optimizations, there are lots of possible causes of high performance,
    including the abuse of Unity’s features, a large number of physics or audio objects,
    improper asset/object configurations, and so on. Our scripts can also be coded
    in an unoptimized way, abusing or misusing expensive Unity API functions. So far,
    we have discussed several good practices of using Unity systems, such as audio
    configurations, texture sizes, batching, and finding functions such as `GameObject.Find`
    and replacing them with managers. So, let’s discuss some specific details about
    common cases.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU优化方面，有许多可能导致性能高的原因，包括滥用Unity的功能、大量物理或音频对象、不正确的资产/对象配置等。我们的脚本也可以以非优化的方式编写，滥用或误用昂贵的Unity
    API函数。到目前为止，我们已经讨论了使用Unity系统的几个良好实践，例如音频配置、纹理大小、批处理，以及将`GameObject.Find`等函数替换为管理器。因此，让我们讨论一些常见情况的具体细节。
- en: Let’s start by seeing how a large amount of objects impacts our performance.
    Here, you can just create lots of objects with `Rigidbody` (at least 200) configured
    in **Dynamic Profile**, and observe the results in the Profiler.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从观察大量对象如何影响我们的性能开始。在这里，您只需创建大量带有`Rigidbody`（至少200个）的对象，并在**动态配置文件**中配置，然后在剖析器中观察结果。
- en: 'You will notice, in the following screenshot, how the orange part of the profiler
    just got bigger and that the `Physics.Processing` function is responsible for
    this increase:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您会注意到，剖析器的橙色部分变大了，而`Physics.Processing`函数是导致这种增加的原因：
- en: '![A picture containing table  Description automatically generated](img/B18585_18_26.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![包含表格的图片描述自动生成](img/B18585_18_26.png)'
- en: 'Figure 18.26: The Physics processing of several objects'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.26：多个对象的物理处理
- en: Remember that the Profiler has other modules that you can activate by clicking
    the **Profiler Modules** button, and there’s one for physics. Consider enabling
    it and checking the info it gives you. Also check the official documentation for
    the profiler for more info on those modules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，剖析器还有其他可以通过点击**剖析器模块**按钮激活的模块，其中一个用于物理。考虑启用它并检查它提供的信息。还要查看剖析器的官方文档，以获取有关这些模块的更多信息。
- en: 'Another test to see the impact of several objects could be creating lots of
    audio sources. In the following screenshot, you can see that we needed to re-enable
    **Others** because part of the audio processing comes under that category. We
    mentioned earlier that **Others** belongs to the editor, but it can encompass
    other processes as well, so keep that in mind:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试多个对象影响的方法是创建大量的音频源。在下面的屏幕截图中，您可以看到我们需要重新启用**其他**，因为部分音频处理属于该类别。我们之前提到**其他**属于编辑器，但它也可以包括其他过程，所以请记住这一点：
- en: '![Chart  Description automatically generated with low confidence](img/B18585_18_27.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成，置信度低](img/B18585_18_27.png)'
- en: 'Figure 18.27: The Physics processing of several objects'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.27：多个对象的物理处理
- en: So, to discover these kinds of problems, you can just start disabling and enabling
    objects and see whether they increase the time or not. A final test is on particles.
    Create a system that spawns a big enough number of particles to affect our framerate
    and check the Profiler.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了发现这类问题，您可以简单地开始禁用和启用对象，看看它们是否增加了时间。最后的测试是在粒子上进行。创建一个系统，生成足够多的粒子以影响我们的帧率，并检查剖析器。
- en: 'In the following screenshot, you can check how the particle processing function
    is highlighted in the graph, showing that it takes a large amount of time:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以检查粒子处理功能在图表中的高亮显示，显示它需要大量时间：
- en: '![Timeline  Description automatically generated](img/B18585_18_28.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴描述自动生成](img/B18585_18_28.png)'
- en: 'Figure 18.28: Particle processing'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.28：粒子处理
- en: Then, on the scripting side, we have other kinds of things to consider, some
    of which are common to all programming languages and platforms, such as iterating
    long lists of objects, the misuse of data structures, and deep recursion. However,
    in this section, I will mainly be discussing Unity-specific APIs, starting with
    `print` or `Debug.Log`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在脚本方面，我们还有其他需要考虑的问题，其中一些是所有编程语言和平台共有的，例如迭代长列表的对象、数据结构的误用和深度递归。然而，在本节中，我主要将讨论Unity特定的API，从`print`或`Debug.Log`开始。
- en: This function is useful to get debugging information in the console, but it
    can also be costly because all logs are written onto the disk immediately to avoid
    losing valuable information if our game crashes. Of course, we want to keep those
    valuable logs in the game, but we don’t want it to affect the performance, so
    what can we do?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在控制台中获取调试信息很有用，但它也可能很昂贵，因为所有日志都会立即写入磁盘，以避免我们的游戏崩溃时丢失有价值的信息。当然，我们希望保留这些有价值的日志，但又不希望它们影响性能，我们该怎么办呢？
- en: 'One possible approach is to keep those messages but disable the non-essential
    ones in the final build, such as informative messages, keeping the error-reporting
    function active. One way to do this is through compiler directives, such as the
    ones used in the following screenshot. Remember that this kind of `if` statement
    is executed by the compiler and can exclude entire portions of code when compiling
    if its conditions are not met:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方法是保留这些消息，但在最终构建中禁用非必要的消息，例如信息性消息，保持错误报告功能活跃。一种实现方式是通过编译器指令，如下面的截图所示。请记住，这种`if`语句是由编译器执行的，如果条件不满足，可以在编译时排除整个代码段：
- en: '![](img/B18585_18_29.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_29.png)'
- en: 'Figure 18.29: Disabling code'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.29：禁用代码
- en: In the preceding screenshot, you can see how we are asking whether this code
    is being compiled by the editor or for a development build, which is a special
    kind of build intended to be used for testing (more on that in the next chapter).
    You can also create your own kind of logging system with functions with the compiler
    directives, so you don’t need to use them in every log that you want to exclude.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到我们正在询问这段代码是否由编辑器编译，或者是为了开发构建而编译，这是一种特殊的构建，旨在用于测试（更多内容将在下一章中介绍）。你还可以使用带有编译器指令的函数创建自己的日志系统，这样你就不需要在想要排除的每个日志中都使用它们。
- en: In this section, we learned about the tasks a CPU faces when processing a video
    game, how to profile them to see which ones are not necessary, and how to reduce
    the impact of those processes. There are a few other script aspects that can affect
    performance not only on the processing side but also on the memory side, so let’s
    discuss them in the next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了CPU在处理视频游戏时面临的任务，如何分析它们以查看哪些是不必要的，以及如何减少这些过程的影响。还有一些其他脚本方面会影响性能，不仅是在处理方面，也在内存方面，所以让我们在下一节中讨论它们。
- en: Optimizing memory
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化内存
- en: We discussed how to profile and optimize two pieces of hardware—the CPU and
    GPU—but there is another piece of hardware that plays a key role in our game—RAM.
    This is the place where we put all of our game’s data. Games can be memory-intensive
    applications, and unlike several other applications, they are constantly executing
    code, so we need to be especially careful about that.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何分析并优化两块硬件——CPU和GPU，但还有另一块硬件在我们的游戏中扮演着关键角色——RAM。这是我们放置所有游戏数据的地方。游戏可能是内存密集型应用程序，并且与许多其他应用程序不同，它们不断执行代码，因此我们需要特别注意这一点。
- en: 'In this section, we will examine the following memory optimization concepts:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下内存优化概念：
- en: Memory allocation and the garbage collector
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配和垃圾回收
- en: Using the Memory Profiler
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存分析器
- en: Let’s start discussing how memory allocation works and what role garbage collection
    plays here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论内存分配是如何工作的，以及垃圾回收在这里扮演什么角色。
- en: Memory allocation and the garbage collector
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配和垃圾回收
- en: Each time we instantiate an object, we are allocating memory in RAM, and in
    a game, we will be allocating memory constantly. In other programming languages,
    aside from allocating the memory, you need to manually deallocate it, but C# has
    a garbage collector, which is a system that tracks unused memory and cleans it.
    This system works with a reference counter, which tracks how many references to
    an object exist, and when that counter reaches `0`, it means all references have
    become null and the object can be deallocated. This deallocation process can be
    triggered in several situations, the most common situation being when we reach
    the maximum assigned memory and we want to allocate a new object. In that scenario,
    we can release enough memory to allocate our object, and if that is not possible,
    the memory is expanded.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们实例化一个对象时，我们都在RAM中分配内存，在游戏中，我们将不断分配内存。在其他编程语言中，除了分配内存外，你还需要手动释放它，但C#有一个垃圾回收器，这是一个跟踪未使用内存并清理它的系统。这个系统与引用计数器一起工作，它跟踪一个对象存在的引用数量，当这个计数器达到`0`时，这意味着所有引用都已变为null，对象可以被释放。这个释放过程可以在几种情况下触发，最常见的情况是我们达到分配的最大内存量，并想要分配一个新的对象。在这种情况下，我们可以释放足够的内存来分配我们的对象，如果这不可能，内存就会被扩展。
- en: 'In any game, you will probably be allocating and deallocating memory constantly,
    which can lead to memory fragmentation, meaning there are small spaces between
    alive object memory blocks that are mostly useless because they aren’t big enough
    to allocate an object, or maybe the sum of the spaces is big enough, but we need
    continuous memory space to allocate our objects. In the following diagram, you
    can see a classic example of trying to fit a big chunk of memory into the little
    gaps generated by fragmentation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何游戏中，你可能会不断分配和释放内存，这可能导致内存碎片化，意味着在活动对象内存块之间存在小空间，这些空间大部分是无用的，因为它们不够大以分配一个对象，或者也许这些空间的总和足够大，但我们需要连续的内存空间来分配我们的对象。在下面的图中，你可以看到一个经典的例子，即尝试将一大块内存放入由碎片化产生的细小缝隙中：
- en: '![Graphical user interface  Description automatically generated with low confidence](img/B18585_18_30.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 描述由低置信度自动生成](img/B18585_18_30.png)'
- en: 'Figure 18.30: Trying to instantiate an object in a fragmented memory space'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.30：尝试在碎片化内存空间中实例化一个对象
- en: Some types of garbage collection systems, such as the one in regular C#, are
    generational, meaning memory is split into generation buckets according to the
    “age” of its memory. Newer memory will be placed in the first bucket, and this
    memory tends to be allocated and deallocated frequently. Because this bucket is
    small, working within it is fast. The second bucket has the memory that survived
    a previous deallocation sweep process in the first bucket. That memory is moved
    to the second bucket to prevent it from being checked constantly if it survived
    the process, and it is possible that that memory will last the length of our program’s
    lifetime. The third bucket is just another layer of bucket 2\. The idea is that
    most of the time, the allocation and deallocation system will be working in bucket
    1, and as it is small enough, it is quick to allocate, deallocate, and compact
    memory in a continuous fashion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一些垃圾回收系统类型，例如常规C#中的系统，是按代进行的，这意味着内存根据其“年龄”被分成代存储桶。较新的内存将被放置在第一个桶中，这种内存往往被频繁地分配和释放。因为这个桶很小，所以在其中工作很快。第二个桶包含在第一个桶中经过先前释放扫描过程的内存。这些内存被移动到第二个桶中，以防止在经过这个过程后不断检查它是否存活，并且这种内存可能持续我们程序的生命周期。第三个桶只是第二个桶的另一层。其想法是，大多数时候，分配和释放系统将在第一个桶中工作，并且由于它足够小，连续分配、释放和压缩内存很快。
- en: The problem here is that Unity uses its own version of the garbage collection
    system, and that version is non-generational and non-compacting, meaning memory
    is not split into buckets and memory won’t be moved to fill the gaps. This suggests
    that allocating and deallocating memory in Unity will still result in the fragmentation
    problem, and if you don’t regulate your memory allocation, you might end up with
    an expensive garbage collection system being executed very often, producing hiccups
    in our game, which you can see in the **Profiler CPU Usage** module as a pale-yellow
    color.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是 Unity 使用它自己的垃圾回收系统版本，而这个版本是非代际和非压缩的，这意味着内存不会被分成桶，内存也不会被移动来填补空隙。这表明在 Unity
    中分配和释放内存仍然会导致碎片化问题，如果你不调节你的内存分配，你可能会频繁执行昂贵的垃圾回收系统，导致我们的游戏出现卡顿，这在**Profiler CPU
    Usage**模块中可以以浅黄色显示。
- en: 'One way to deal with this is by preventing memory allocation as much as you
    can, avoiding it when it is not necessary. There are a few tweaks here and there
    that you can make to prevent memory allocation, but before looking at those, again,
    it is important to first get data about the problem before you start fixing things
    that may not be an issue. This advice applies to any type of optimization process.
    Here, we can still use the **CPU Usage** profiler to see how much memory is allocated
    to each function call that the CPU executes in each frame, and that is simply
    done by looking at the **GC Alloc** column, which indicates the amount of memory
    that the function allocated:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是在尽可能的情况下防止内存分配，在不必要的时候避免它。这里有一些小调整可以防止内存分配，但在查看这些调整之前，再次强调，在开始修复可能不是问题的东西之前，首先获取关于问题的数据是很重要的。这条建议适用于任何类型的优化过程。在这里，我们仍然可以使用
    **CPU Usage** 分析器来查看 CPU 在每一帧中执行每个函数调用分配了多少内存，这很简单，只需查看 **GC Alloc** 列，它表示函数分配的内存量：
- en: '![Table  Description automatically generated with medium confidence](img/B18585_18_31.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![表描述自动生成，置信度中等](img/B18585_18_31.png)'
- en: 'Figure 18.31: The memory allocation of the Update event function of Sight'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.31：Sight 更新事件函数的内存分配
- en: In the preceding screenshot, we can see how our function is allocating too much
    memory, which is produced because there are many enemies in the scene. But that’s
    no excuse; we are allocating that much RAM at every frame, so we need to improve
    this. There are several things that can contribute to our memory being claimed
    by allocations, so let’s discuss the basic ones, starting with array-returning
    functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到我们的函数分配了过多的内存，这是由于场景中有许多敌人造成的。但这并不是借口；我们每帧都在分配这么多 RAM，因此我们需要改进这一点。有几件事情可能导致我们的内存被分配，让我们先讨论基本的一些，从返回数组的函数开始。
- en: If we review the `Sight` script code, we can see that the only moment where
    we are allocating memory is in the call to `Physics.OverlapSphere`, and that is
    evident because it is an array-returning function, which is a function that returns
    a varying amount of data. To do this, it needs to allocate an array and return
    that array to us. This needs to be done on the side that created the function,
    Unity, but in this case, Unity gives us two versions of the function—the one that
    we are using and the `NonAlloc` version. It is usually recommended to use the
    second version, but Unity uses the other one to make coding simpler for beginners.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾 `Sight` 脚本代码，我们可以看到我们分配内存的唯一时刻是在调用 `Physics.OverlapSphere`，这是显而易见的，因为它是一个返回数组的函数，这是一个返回可变数量数据的函数。为了做到这一点，它需要分配一个数组并将该数组返回给我们。这需要在创建函数的旁边进行，即
    Unity，但在这个案例中，Unity 给我们提供了两个版本的函数——我们正在使用的版本和 `NonAlloc` 版本。通常建议使用第二个版本，但 Unity
    使用另一个版本来简化初学者的编码。
- en: 'The `NonAlloc` version looks as in the following screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonAlloc` 版本如下截图所示：'
- en: '![](img/B18585_18_32.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_32.png)'
- en: 'Figure 18.32: Memory allocation of the Update event function of Sight'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.32：Sight 更新事件函数的内存分配
- en: This version requires us to allocate an array with enough space to save the
    largest amount of colliders our `OverlapSphere` variable can find and pass it
    as the third parameter. This allows us to allocate the array just once and reuse
    it on every occasion that we need it. In the preceding screenshot, you can see
    how the array is static, which means it is shared between all the `Sight` variables
    as they won’t execute in parallel (no `Update` function will). This will work
    fine. Keep in mind that the function will return the number of objects that were
    detected, so we just iterate on that count. The array can have previous results
    stored within it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本要求我们分配一个数组，以保存`OverlapSphere`变量可以找到的最大数量的碰撞器，并将其作为第三个参数传递。这允许我们只分配一次数组，并在需要时重复使用它。在先前的截图中，你可以看到数组是静态的，这意味着它在所有`Sight`变量之间共享，因为它们不会并行执行（没有`Update`函数）。这将正常工作。请注意，该函数将返回检测到的对象数量，所以我们只需迭代这个计数。数组可以存储之前的结果。
- en: Now, check your Profiler and notice how the amount of memory allocated has been
    reduced greatly. There might be some remaining memory allocation within our function,
    but sometimes there is no way to keep it at `0`. However, you can try to look
    at the reasons for this using deep profiling or by commenting some code and seeing
    which comment removes the allocation. I challenge you to try this. Also, `OverlapSphere`
    is not the only case where this could occur. You have others, such as the `GetComponents`
    functions family, which, unlike `GetComponent`, finds all the components of a
    given type, not just the first one, so pay attention to any array-returning function
    of Unity and try to replace it with a non-allocating version, if there is one.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查你的Profiler，注意内存分配量已经大大减少。在我们的函数中可能还有一些剩余的内存分配，但有时没有方法可以将其保持在`0`。然而，你可以尝试使用深度分析或通过注释一些代码来查看哪些注释可以消除分配。我挑战你尝试这样做。此外，`OverlapSphere`不是唯一可能发生这种情况的情况。你还有其他情况，例如`GetComponents`函数家族，与`GetComponent`不同，它找到给定类型的所有组件，而不仅仅是第一个组件，所以请注意Unity中任何返回数组的函数，并尝试用非分配版本替换它，如果有的话。
- en: 'Another common source of memory allocation is string concatenation. Remember
    that strings are immutable, meaning they cannot change if you concatenate two
    strings. A third one needs to be generated with enough space to hold the first
    ones. If you need to concatenate a large number of times, consider using `string.Format`
    if you are just replacing placeholders in a template string, such as putting the
    name of the player and the score they got in a message or using `StringBuilder`,
    a class that just holds all the strings to be concatenated in a list and, when
    necessary, concatenates them together, instead of concatenating them one by one
    as the **+** operator does. Also, consider using the new string interpolation
    functionality of C#. You can see some examples in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的内存分配来源是字符串连接。记住，字符串是不可变的，这意味着如果你连接两个字符串，它们不会改变。第三个需要生成足够的空间来容纳前两个字符串。如果你需要多次连接，考虑使用`string.Format`，如果你只是在一个模板字符串中替换占位符，例如在消息中放入玩家的名字和得分，或者使用`StringBuilder`，这是一个只将所有要连接的字符串放在列表中的类，在需要时，它会将它们连接在一起，而不是像**+**运算符那样逐个连接。此外，考虑使用C#的新字符串插值功能。你可以在以下截图中看到一些示例：
- en: '![](img/B18585_18_33.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_18_33.png)'
- en: 'Figure 18.33: String management in C#'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.33：C#中的字符串管理
- en: Finally, a classic technique to consider is object pooling, which is suitable
    in cases where you need to instantiate and destroy objects constantly, such as
    with bullets or effects. In that scenario, the use of regular `Instantiate` and
    `Destroy` functions will lead to memory fragmentation, but object pooling fixes
    that by allocating the maximum amount of required objects possible. It replaces
    `Instantiate` by taking one of the preallocated functions and it replaces `Destroy`
    by returning the object to the pool.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个值得考虑的经典技术是对象池，它适用于需要不断实例化和销毁对象的情况，例如子弹或效果。在这种情况下，使用常规的`Instantiate`和`Destroy`函数会导致内存碎片化，但对象池通过分配尽可能多的所需对象来解决这个问题。它通过从预分配的函数中取一个来替换`Instantiate`，并通过将对象返回到池中来替换`Destroy`。
- en: 'A simple pool can be seen in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了简单的池：
- en: '![](img/B18585_18_34.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_18_34.png)'
- en: 'Figure 18.34: A simple object pool'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.34：简单的对象池
- en: 'There are several ways to improve this pool, but it is fine as it is for now.
    Note that objects need to be reinitialized when they are taken out of the pool,
    and you can do that with the `OnEnable` event function or by creating a custom
    function to inform the object to do so. Also, note that Unity has recently added
    an Object Pool class that you can investigate at the following link: [https://docs.unity3d.com/2022.1/Documentation/ScriptReference/Pool.ObjectPool_1.html](https://docs.unity3d.com/2022.1/Documentation/ScriptReference/Pool.ObjectPool_1.html),
    but I still recommend making your own first to grasp the idea of pools.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored some basic memory allocation reduction techniques,
    let’s look at the new **Memory Profiler** tool, introduced in the latest version
    of Unity, to explore memory in greater detail.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Using the Memory Profiler
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this Profiler, we can detect memory allocated on a frame-per-frame basis,
    but it won’t show the total memory allocated so far, which would be useful to
    study how we are using our memory. This is where the **Memory Profiler** can help
    us. This relatively new Unity package allows us to take memory snapshots of every
    single object allocated both on the native and managed side—native meaning the
    internal C++ Unity code and managed meaning anything that belongs to the C# side
    (that is, both our code and Unity’s C# engine code). We can explore snapshots
    with a visual tool and rapidly see which type of object is consuming the most
    RAM and how they are referenced by other objects.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the **Memory Profiler**, do the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Package Manager** (**Window** | **Package Manager**) and enable
    preview packages (**Wheel Icon** | **Project Settings** | **Enable Pre-release
    Packages**):'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_18_35.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.35: Enabling preview packages'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **+** button and select **Add package by name…**:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_18_36.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.36: Installing packages from Git URLs'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dialog box, write `com.unity.memoryprofiler` and click **Add**. We need
    to add the package this way as it’s still an experimental one:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_18_37.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.37: Installing the Memory Profiler'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, open the **Memory Profiler** in **Window** | **Analysis** |
    **Memory Profiler**.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game and click on the **Capture** button in the **Memory Profiler**
    window:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_18_38.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.38: Capturing a snapshot'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the snapshot that appeared in the list (the one below the **Session
    1** label) to see a summary of the memory consumption at the moment of taking
    a snapshot:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18585_18_39.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.39: Memory summary'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we can see that we are consuming 4.79 GB of memory, split between
    **Managed Heap** (C# code variables), **Other Native Memory** (Unity’s C++ memory),
    **Graphics & Graphics Driver**, **Audio**, and much more. There are different
    things that are accounted for in these categories, but for now, we are good. Open
    the package documentation in the Package Manager to get more info about them.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们可以看到我们正在消耗4.79 GB的内存，这些内存被分配在**托管堆**（C#代码变量）、**其他原生内存**（Unity的C++内存）、**图形与图形驱动程序**、**音频**以及更多。这些类别中包含了不同的事物，但就目前而言，我们做得很好。在包管理器中打开包文档以获取更多关于它们的信息。
- en: 'Click the **Tree Map** button at the top part of the middle section of the
    **Memory Profiler** window. This will open the **Tree View**, which allows you
    to visually see which types of assets are the more demanding in terms of memory:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**内存分析器**窗口中间部分顶部的**树图**按钮。这将打开**树视图**，允许您直观地看到哪些类型的资源在内存方面要求更高：
- en: '![](img/B18585_18_40.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_18_40.png)'
- en: 'Figure 18.40: Memory tree view'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.40：内存树视图
- en: In our case, we can see that `RenderTexture` uses up the most memory, which
    belongs to the image that is displayed in the scene, as well as some textures
    used by postprocessing effects. Try to disable the `PPVolume` object and take
    another snapshot to detect the difference.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们可以看到`RenderTexture`消耗了最多的内存，这属于场景中显示的图像以及一些用于后期处理效果的纹理。尝试禁用`PPVolume`对象并再次截图以检测差异。
- en: 'In my case, that dropped off 130 MB. There are other textures needed for other
    effects, such as HDR. If you want to explore where those remaining MB came from,
    click on the **RenderTexture** block to subdivide it into its objects and take
    your own guesses based on the names of the textures:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的案例中，这减少了130 MB。还有其他纹理用于其他效果，例如HDR。如果您想探索剩余的MB来自哪里，请单击**RenderTexture**块将其细分为其对象，并根据纹理的名称进行自己的猜测：
- en: '![A picture containing application  Description automatically generated](img/B18585_18_41.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![包含应用程序描述的图片，自动生成](img/B18585_18_41.png)'
- en: 'Figure 18.41: Memory blocks in detail'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.41：内存块详细视图
- en: You can repeat the same process in the `Texture2D` block type, which belongs
    to the textures used in the materials of our models. You can look at the biggest
    one and detect its usage—maybe it is a big texture that is never seen close enough
    to justify its size. Then, we can reduce its size using the **Max Size of the
    Texture** import settings.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在`Texture2D`块类型中重复相同的操作，这属于我们模型材料中使用的纹理。您可以查看最大的一个并检测其使用情况——可能是一个从未被足够接近地看到以证明其大小的纹理。然后，我们可以使用**纹理最大尺寸**导入设置来减小其大小。
- en: As with any profiler, it is always useful to carry out the profiling directly
    in the build (more on that in the next chapter) because taking snapshots in the
    editor will capture lots of memory that is used by the editor and will not be
    used in the build. An example of this is the loading of unnecessary textures because
    the editor probably loaded them when you clicked them to see their previews in
    the **Inspector** window.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何分析器一样，始终在构建中直接执行分析非常有用（关于这一点将在下一章中详细介绍），因为在编辑器中捕获快照将捕获大量编辑器使用的内存，这些内存在构建中不会被使用。一个例子是加载不必要的纹理，因为编辑器可能是在您点击它们以在**检查器**窗口中查看预览时加载它们的。
- en: Take into account that due to the **Memory Profiler** being a package, its UI
    can change often, but its basic idea will remain. You can use this tool to detect
    whether you are using the memory in unexpected ways. Something useful to consider
    here is how Unity loads assets when loading a scene, which consists of loading
    all assets referenced in the scene at load time. This means that you can have,
    as an example, an array of prefabs that have references to materials that have
    references to textures, and even if you don’t instantiate a single instance of
    them, the prefabs must be loaded in memory, causing them to occupy space. In this
    scenario, I recommend that you explore the use of `Addressables`, which provide
    a way to load assets dynamically. But let’s keep things simple for now.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于**内存分析器**是一个包，其UI可能会经常变化，但其基本理念将保持不变。您可以使用此工具检测您是否以意外的方式使用内存。这里值得考虑的一个有用因素是Unity在加载场景时如何加载资源，这包括在加载时加载场景中引用的所有资源。这意味着您可以有，例如，一个预制体数组，这些预制体引用了具有引用纹理的材料，即使您没有实例化它们的单个实例，预制体也必须在内存中加载，从而占用空间。在这种情况下，我建议您探索使用`Addressables`，它提供了一种动态加载资源的方法。但现在让我们保持简单。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Optimizing a game is not an easy task, especially if you are not familiar with
    the internals of how each Unity system works. Sadly, this is a titanic task, and
    no one knows every single system down to its finest details, but with the tools
    learned in this chapter, we have a way to explore how changes affect systems through
    exploration. We learned how to profile the CPU, GPU, and RAM and what the key
    hardware in any game is, as well as covered some common good practices to avoid
    abusing them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 优化游戏并非易事，尤其是如果你不熟悉每个Unity系统的工作原理。遗憾的是，这是一个巨大的任务，没有人知道每个系统及其最细微细节的每一个方面，但通过本章学到的工具，我们有一种方法来探索变化如何通过探索影响系统。我们学习了如何分析CPU、GPU和RAM，以及任何游戏中关键硬件是什么，还介绍了一些常见的良好实践，以避免滥用它们。
- en: Now, you are able to diagnose performance issues in your game, gathering data
    about the performance of the three main pieces of hardware—the CPU, GPU, and RAM—and
    then using that data to focus your optimization efforts on applying the correct
    optimization technique. Performance is important as your game needs to run smoothly
    to give your users a pleasant experience.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能够诊断游戏中的性能问题，收集关于CPU、GPU和RAM这三件主要硬件性能的数据，然后使用这些数据来集中优化努力，应用正确的优化技术。性能很重要，因为你的游戏需要流畅运行，以给用户带来愉快的体验。
- en: In the next chapter, we are going to see how to create a build of our game to
    share with other people, without needing to install Unity. This is also very useful
    for profiling, given profiling builds are going to give us more accurate data
    than profiling in the editor.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何创建一个无需安装Unity的游戏构建版本，以便与他人分享。这对于性能分析也非常有用，因为性能分析构建版本将比在编辑器中进行性能分析提供更准确的数据。
- en: Join us on Discord!
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Unity game development experts, and the
    author himself.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过Ask Me Anything（AMA）环节与作者聊天，等等。
- en: Scan the QR code or visit the link to join the community.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接加入社区。
- en: '![](img/Nicolas_QR_Code.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![尼古拉斯二维码](img/Nicolas_QR_Code.png)'
- en: '[https://packt.link/handsonunity22](https://packt.link/handsonunity22)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/handsonunity22](https://packt.link/handsonunity22)'
