<html><head></head><body>
		<div id="_idContainer039">
			<h1 id="_idParaDest-120" class="chapter-number"><a id="_idTextAnchor177"/>11</h1>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor178"/>Applying the Open-Closed Principle</h1>
			<p>The open-closed principle is credited to Bertrand Meyer, after its appearance in his 1988 book, <em class="ita ic">Object-Oriented Software Construction </em>(<a href="https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction">https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction</a>). This book describes the following principles that we can apply to <span class="No-Break">our software:</span></p>
			<ul>
				<li>A type is open if it can <span class="No-Break">be extended</span></li>
				<li>A type is closed when it is available to <span class="No-Break">other types</span></li>
			</ul>
			<p>Suppose we have a class called <strong class="source-in ine">Shape</strong> that has a method called <strong class="source-in ine">area</strong>, which in turn calculates the area of the shape. We want to be able to add new shapes to our program without modifying the <a id="_idTextAnchor179"/><strong class="source-in ine">Shape</strong> class, so we make the <strong class="source-in ine">Shape</strong> class open <span class="No-Break">for extension.</span></p>
			<p>To do this, we create a new class called <strong class="source-in ine">Triangle</strong> that inherits from <strong class="source-in ine">Shape</strong> and overrides the <strong class="source-in ine">area</strong> method to calculate the area of a triangle. We can also create a <strong class="source-in ine">Rectangle</strong> class and any other new shapes <span class="No-Break">we want.</span></p>
			<p>Now, whenever we need to calculate the area of a shape, we can simply create a new instance of the appropriate shape class and call its <strong class="source-in ine">area</strong> method. Because the <strong class="source-in ine">Shape</strong> class is closed for modification, we don’t need to modify it every time we add a new shape to <span class="No-Break">our program.</span></p>
			<p>Classes in C# are, by default, open for extension. We can inherit from any classes that are not sealed and add new meanings to them. But the base class we’re inheriting from should be closed, meaning that there shouldn’t be a need for any change in the base type for the new type <span class="No-Break">to work.</span></p>
			<p>This helps us to design our code for extensibility and keep responsibilities in the <span class="No-Break">right place.</span></p>
			<p>Taking a step back, we can apply some of this at the system level. What if we could simply expand on our systems, without the need to add configurations at the heart of a type for it to know about <span class="No-Break">the additions?</span></p>
			<p>This type of thinking is the type we used earlier in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, with the <strong class="source-in ine">ICommand</strong> interface and its implementations. The two commands we added were not known by any parts of the system, but by implementing the <strong class="source-in ine">ICommand</strong> interface, we could see both types through an introspective of <span class="No-Break">our system.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>The goal of the <span class="No-Break">open-closed principle</span></li>
				<li>Encapsulating <span class="No-Break">type discovery</span></li>
				<li>Encapsulating the discovery <span class="No-Break">of instances</span></li>
				<li>Hooking up with the <span class="No-Break">service collection</span></li>
				<li>A practical <span class="No-Break">use case</span></li>
			</ul>
			<p>By the end of the chapter, you will understand how you can set your code and projects up for success in order to make them more flexible and extensible, and how to create code that welcomes changes and additions without having to perform open-heart surgery on your code <span class="No-Break">every time.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor180"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter11">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter11</a>) and it builds on the <strong class="source-in ine">Fundamentals</strong> code, which can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">.</span></p>
			<p><a id="_idTextAnchor181"/>The goal of the <span class="No-Break">open-closed principle</span></p>
			<p>In a world with <a id="_idIndexMarker397"/>ever-changing and growing requirements, newly discovered business opportunities, or even pivots for your business, it’s not very helpful if your software has to go through triple-bypass surgery for changes to be made. At the heart of an agile mindset sits the ability to be nimble and react to change in a timely fashion. From a business perspective, this is a type of elasticity that is very useful. The goal is to be cost-effective when changes come in. In projects or product developments that I’ve been part of, I’ve often noticed that this translates into an ad hoc mindset, and often a total disregard for writing code in a way that makes it possible to let the code have longevity and be understood <span class="No-Break">by developers.</span></p>
			<p>The initial phase of development, the exciting part of getting to the first version of a software product, is where we set the tone for the code future of the code base. In most cases, however, this only represents a small fraction of the lifecycle of the code. This is why I believe we should focus much more on how we can set ourselves up for success in the maintenance <span class="No-Break">of code.</span></p>
			<p>A very common idea I often<a id="_idIndexMarker398"/> also encounter is the strong belief that just getting the first version out the door is key and that after that, we can start fixing all the things we weren’t proud of originally, such as all the shortcuts we had to take because we thought we didn’t have time to do it <em class="ita ic">properly</em>. Chasing a <strong class="bo d">Minimum Viable Product</strong> (<strong class="bo d">MVP</strong>) is a very popular approach. The chase is driven by a desire to deliver products to the market and learn from them. Unfortunately, in my experience, we often don’t get to create a viable product at all, but rather prototypes that prove what we want to build. They might feel like products on the surface, but they lack a proper foundation to stand on. From a non-technical viewpoint, it feels like this is exactly what the developers wanted, and that they want you to move on. And who can blame them? Customers who start using these products might also feel like they are using a product, but they have no idea what’s going on under the surface. Pretty soon after getting the first version out there, the business, customers, and end users will come back with new things they’d like the software to do. I’ve yet to see a business prioritize fixing the foundation at this point. When this is combined with reported shortcomings or concrete faults in the software, you end up sprinting toward new goals. The excitement you had getting the first version out goes away, and the work becomes <span class="No-Break">a chore.</span></p>
			<p>We did the business a huge disservice by not putting design-based thinking into our code, which would have set the business up for success. The code might be in a worse state than it could’ve been, making it hard to make all these changes. This often leads to less satisfied developers, who might ultimately decide to leave in the hope that their next place of work will offer them a better working environment for writing <span class="No-Break">better code.</span></p>
			<p>Where am I going with all this? I do believe it is possible to deliver actual MVPs, lower the amount of technical debt in the code base dramatically, and make it possible to iterate on the MVP to deliver more, faster, and more accurately with a strong foundation. I’m pretty sure businesses would rather have the latter – something that won’t die a slow death the second it hits <span class="No-Break">the market.</span></p>
			<p>At the heart of enabling this sits one of my favorite principles: <strong class="bo d">the open-closed principle</strong>. As I mentioned previously, I <a id="_idIndexMarker399"/>see it as a strategic mindset: not just a tactical approach to writing classes, but a system-level method. How can we make sure we can just drop code in at any time, extending the capabilities of our software, with the confidence that it won’t break the existing system? If we can avoid having to modify existing code to accomplish our new objectives, we lower the risk of regressions in our <span class="No-Break">software dramatically.</span></p>
			<p>We can leverage the building blocks we’ve built so far in this book to accomplish this and improve on them to make them <span class="No-Break">more friendl<a id="_idTextAnchor182"/>y.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor183"/>Encapsulating type discovery</h1>
			<p>In <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, we introduced a class called <strong class="source-in ine">Types</strong>, which <a id="_idIndexMarker400"/>encapsulates the logic used in finding types. This is a very powerful construct for enabling software to be extensible. We can make it a little bit better and build a construct on top of it that simplifies <span class="No-Break">its use.</span></p>
			<p>In the <strong class="source-in ine">Types</strong> class, we have a method called <strong class="source-in ine">FindMultiple()</strong>, which allows us to find types that implement a specific type. A small improvement on this would be to allow us to represent the different types we want implementations of by taking a dependency in a constructor of a specific type that <span class="No-Break">describes this.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">You’ll find the implementation of this in the <strong class="bo d">Fundamentals</strong> part of the repository mentioned in the <em class="ita ic">Technical </em><span class="No-Break"><em class="ita ic">requirements</em></span><span class="No-Break"> section.</span></p>
			<p>The concept is basically to have the type represented as an interface, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public interface IImplementationsOf&lt;T&gt; : IEnumerable&lt;Type&gt;
    where T : class
{
}</pre>
			<p>The interface takes a generic type that describes the type whose implementations you’re interested in. It then says it is an enumerable of <strong class="source-in ine">Type</strong>, which makes it possible for you to iterate over it directly. The generic constraint of <strong class="source-in ine">class</strong> is there to limit the scope of the types you can <a id="_idIndexMarker401"/>work with, since it wouldn’t be useful to allow primitive types such as <strong class="source-in ine">int</strong>, which <span class="No-Break">aren’t inheritable.</span></p>
			<p>The implementation of the interface is straightforward and looks <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public class ImplementationsOf&lt;T&gt; : IImplementationsOf&lt;T&gt;
    where T : class
{
    readonly IEnumerable&lt;Type&gt; _types;
    public ImplementationsOf(ITypes types)
    {
        _types = types.FindMultiple&lt;T&gt;();
    }
    public IEnumerator&lt;Type&gt; GetEnumerator()
    {
        return _types.GetEnumerator();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return _types.GetEnumerator();
    }
}</pre>
			<p>The code takes <strong class="source-in ine">ITypes</strong> as dependencies, as it will use it to actually find <span class="No-Break">the implementations.</span></p>
			<p>Discovering types is one thing, and this makes the approach a little bit nicer by making the code more readable and<a id="_idIndexMarker402"/> clearer. But this only gives you the type. A more common method is to get not only the type but also <span class="No-Break">its insta<a id="_idTextAnchor184"/>nces.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor185"/>Encapsulating the discovery of instances</h1>
			<p>Another encapsulation<a id="_idIndexMarker403"/> we can perform, which is probably more suited to our current scenario, is to find the implementations and then get their <span class="No-Break">instances directly.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">You’ll find the implementation of this in the <strong class="bo d">Fundamentals</strong> part of the repository, in the <em class="ita ic">Technical </em><span class="No-Break"><em class="ita ic">requirements</em></span><span class="No-Break"> section.</span></p>
			<p>The concept is basically to represent the code similarly to the case in which <strong class="source-in ine">IImplementationsOf&lt;T&gt;</strong> is used as the interface, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public interface IInstancesOf&lt;T&gt; : IEnumerable&lt;T&gt;
    where T : class
{
}</pre>
			<p>The interface in the code uses the generic parameter to determine the types for which it can provide instances. It then implements <strong class="source-in ine">IEnumerable&lt;T&gt;</strong>, making it possible to enumerate its instances directly and get instances of <span class="No-Break">the type.</span></p>
			<p>The implementation of the interface is straightforward and is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public class InstancesOf&lt;T&gt; : IInstancesOf&lt;T&gt;
    where T : class
{
    readonly IEnumerable&lt;Type&gt; _types;
    readonly IServiceProvider _serviceProvider;
    public InstancesOf(ITypes types,
      IServiceProvider serviceProvider)
    {
        _types = types.FindMultiple&lt;T&gt;();
        _serviceProvider = serviceProvider;
    }
    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        foreach (var type in _types) yield return
          (T)_serviceProvider.GetService(type)!;
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        foreach (var type in _types) yield return
          _serviceProvider.GetService(type);
    }
}</pre>
			<p>The code leverages <strong class="source-in ine">ITypes</strong> and, as with <strong class="source-in ine">ImplementationsOf&lt;T&gt;</strong>, it uses the <strong class="source-in ine">FindMultiple()</strong> method to find the actual types. Since it will discover types it does not know anything about and, consequently, it does not know how to instantiate them if they don’t have a default constructor without arguments, it needs support in order to do this. To this end, it leverages the <strong class="source-in ine">IServiceProvider</strong> instance found in .NET. <strong class="source-in ine">IServiceProvider</strong> is what<a id="_idIndexMarker404"/> gets set up when using the .NET dependency injection system. The <strong class="source-in ine">GetEnumerator()</strong> implementation then iterates the types and provides the instance by calling the <strong class="source-in ine">GetService()</strong> method <span class="No-Break">on </span><span class="No-Break"><strong class="source-in ine">IServiceProvider</strong></span><span class="No-Break">.</span></p>
			<p>Note that the implementation asks <strong class="source-in ine">IServiceProvider</strong> only when enumerated instead of just doing this in the constructor. The reason for this is that you don’t want to run the risk of something taking a dependency on <strong class="source-in ine">IInstancesOf&lt;T&gt;</strong> that has a longer lifecycle than the implementations. For instance, if a class using <strong class="source-in ine">IInstancesOf&lt;T&gt;</strong> is a <strong class="bo d">singleton</strong>, all the instances in the class using it are <span class="No-Break">themselves singletons.</span></p>
			<p>The only caveat is that when calling <strong class="source-in ine">GetService()</strong> for types that do not have a concrete registration on <strong class="source-in ine">IServiceProvider</strong>, you’ll get <strong class="source-in ine">null</strong>. This is not <span class="No-Break">very <a id="_idTextAnchor186"/>useful.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor187"/>Hooking up with the service collection</h1>
			<p>Since we’re leveraging <strong class="source-in ine">ServiceProvider</strong> to create instances, and since its default behavior is to<a id="_idIndexMarker405"/> have everything explicitly registered with it, it might not have a registration for the concrete type <span class="No-Break">we asked.</span></p>
			<p>In <a href="B19418_10.xhtml#_idTextAnchor162"><span class="No-Break"><em class="ita ic">Chapter 10</em></span></a>, <em class="ita ic">Convention over Configuration</em>, you did an implementation for discovering the relationship between interfaces and implementations according to a convention. We can extend this thinking and say that it should be possible to resolve classes themselves according to <span class="No-Break">their type.</span></p>
			<p>To do this, we leverage more reflection metadata to filter out the different types we are not <span class="No-Break">interested in.</span></p>
			<p>In <a href="B19418_10.xhtml#_idTextAnchor162"><span class="No-Break"><em class="ita ic">Chapter 10</em></span></a>, <em class="ita ic">Convention over Configuration</em>, you created something <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">Service</strong></span><strong class="source-in ine">
CollectionExtensions</strong>. We want to make use of this here as well, but we also want to add some additional functionality. Move the file into the shared <span class="No-Break"><strong class="source-in ine">Fundamentals</strong></span><span class="No-Break"> project.</span></p>
			<p>Open the <strong class="source-in ine">ServiceCollectionExtensions</strong> class and <a id="_idIndexMarker406"/>add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public static IServiceCollection AddSelfBinding(this IServiceCollection services, ITypes types)
{
    const TypeAttributes staticType =
      TypeAttributes.Abstract | TypeAttributes.Sealed;
    types.All.Where(_ =&gt;
        (_.Attributes &amp; staticType) != staticType &amp;&amp;
        !_.IsInterface &amp;&amp;
        !_.IsAbstract &amp;&amp;
        services.Any(s =&gt; s.ServiceType !=
          _)).ToList().ForEach(_ =&gt;
    {
        var __ = _.HasAttribute&lt;SingletonAttribute&gt;() ?
            services.AddSingleton(_, _) :
            services.AddTransient(_, _);
    });
    return services;
}</pre>
			<p>The code uses the <strong class="source-in ine">ITypes</strong> system and filters down types by ignoring <strong class="source-in ine">static</strong> classes, as they can’t be instantiated. In addition, it also ignores interfaces and abstract types for the same reason. It then ignores any types that are already registered in the <strong class="source-in ine">services</strong> collection. Any type that is left is then registered. If the type has the <strong class="source-in ine">[Singleton]</strong> attribute, it registers as a singleton; otherwise, it uses a <strong class="bo d">transient</strong> lifecycle, meaning you’ll get a new instance every time you ask <span class="No-Break">for one.</span></p>
			<p>With this in place, we’re getting <a id="_idIndexMarker407"/>ready to apply what we have in a more <span class="No-Break">prac<a id="_idTextAnchor188"/>tical way.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor189"/>Practical use case</h1>
			<p>Let’s build something that leverages <a id="_idIndexMarker408"/>the new form of discovery but, more importantly, shows the concept of an elastic growing system that does not require changes at the core for new features to <span class="No-Break">be added.</span></p>
			<p>Let’s revisit the concept of compliance, which is a very common scenario in software. We looked into GDPR in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, and <a href="B19418_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="ita ic">Chapter 5</em></span></a>, <em class="ita ic">Leveraging Attributes</em>. GDPR is just one type of compliance with which it is important to <span class="No-Break">deal with.</span></p>
			<p>The goal is to create a system in which the core “engine” does not know about the different types of compliance metadata that can exist and instead provides extensibility points, where developers can just add new compliance metadata types as <span class="No-Break">they’re needed.</span></p>
			<p>We want the engine to be generalized and accessible to everyone. Following the GitHub repository mentioned in <em class="ita ic">Technical requirements</em>, you’ll find that there is a <strong class="bo d">Fundamentals</strong> project. All the code listed here can be <span class="No-Break">found there.</span></p>
			<p>Let’s start by creating a record that represents the type of metadata that leverages the <strong class="source-in ine">ConceptAs&lt;&gt;</strong> base record found in <strong class="source-in ine">Fundamentals</strong>. Add a file called <strong class="source-in ine">ComplianceMetadataType.cs</strong> and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public record ComplianceMetadataType(Guid Value) : ConceptAs&lt;Guid&gt;(Value)
{
    public static readonly ComplianceMetadataType PII = new(Guid.Parse("cae5580e-83d6-44dc-9d7a-a72e8a2f17d7"));
    public static implicit operator
      ComplianceMetadataType(string value) =&gt;
      new(Guid.Parse(value));
    public static implicit operator
      ComplianceMetadataType(Guid value) =&gt; new(value);
}</pre>
			<p>The code introduces a <strong class="source-in ine">record</strong> instance inheriting <strong class="source-in ine">ConceptAs&lt;&gt;</strong> and makes the value inside it a <strong class="source-in ine">Guid</strong> instance. It then adds a well-known type for <strong class="bo d">personally identifiable information</strong>, or <strong class="bo d">PII</strong> for short. The type<a id="_idIndexMarker409"/> also adds implicit operators for<a id="_idIndexMarker410"/> converting from a <strong class="source-in ine">string</strong> representation of a <strong class="source-in ine">Guid</strong> instance, as well as directly from a <span class="No-Break"><strong class="source-in ine">Guid</strong></span><span class="No-Break"> instance.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The <strong class="source-in ine">ConceptAs&lt;&gt;</strong> type is explained in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types </em><span class="No-Break"><em class="ita ic">Using Reflection</em></span><span class="No-Break">.</span></p>
			<p>Next, we want a type that will represent the actual metadata. Add a file called <strong class="source-in ine">ComplianceMetadata.cs</strong> and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public record ComplianceMetadata(ComplianceMetadataType MetadataType, string Details);</pre>
			<p>The code represents the metadata as a reference to the type of metadata, followed by a <span class="No-Break"><strong class="source-in ine">Details</strong></span><span class="No-Break"> string.</span></p>
			<p>In order for us to be able to discover the metadata, we need something that can provide this metadata. We represent this as an interface that is discoverable for us on <span class="No-Break">its own.</span></p>
			<p>Add a file called <strong class="source-in ine">ICanProvideComplianceMetadataForType.cs</strong> and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public interface ICanProvideComplianceMetadataForType
{
    bool CanProvide(Type type);
    ComplianceMetadata Provide(Type type);
}</pre>
			<p>The code represents a provider that decides whether it’s capable of providing using the <strong class="source-in ine">CanProvide()</strong> method, followed by a method for actually providing the metadata. The key to the extensibility lies<a id="_idIndexMarker411"/> with this pattern, which enables us to drop in any implementations that can be called for any type, and the implementation itself decides whether it can provide <span class="No-Break">the metadata.</span></p>
			<p>Since <strong class="source-in ine">ICanProvideComplianceMetadataForType</strong> is only focused on providing metadata for <strong class="source-in ine">Type</strong>, we need another provider for the properties of <span class="No-Break">a type.</span></p>
			<p>Add a file called <strong class="source-in ine">ICanProvideComplianceMetadataForProperty.cs</strong> and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public interface ICanProvideComplianceMetadataForProperty
{
    bool CanProvide(PropertyInfo property);
    ComplianceMetadata Provide(PropertyInfo property);
}</pre>
			<p>As with <strong class="source-in ine">ICanProvideComplianceMetadataForType</strong>, you’ll see that <strong class="source-in ine">ICanProvideComplianceMetadataForProperty</strong> has the <strong class="source-in ine">CanProvide()</strong> method and a <strong class="source-in ine">Provide()</strong> method; the only difference is that it is focused <span class="No-Break">on </span><span class="No-Break"><strong class="source-in ine">PropertyInfo</strong></span><span class="No-Break">.</span></p>
			<p>With the discoverable interfaces in<a id="_idIndexMarker412"/> place, we can start to build the engine that discovers these things and combines them into something that can be leveraged as <span class="No-Break">a system.</span></p>
			<p>Let’s start by defining the contract for the compliance engine by adding an interface for it. Add a file called <strong class="source-in ine">IComplianceMetadataResolver.cs</strong> and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public interface IComplianceMetadataResolver
{
    bool HasMetadataFor(Type type);
    bool HasMetadataFor(PropertyInfo property);
    IEnumerable&lt;ComplianceMetadata&gt; GetMetadataFor(Type
      type);
    IEnumerable&lt;ComplianceMetadata&gt;
      GetMetadataFor(PropertyInfo property);
}</pre>
			<p>The code adds methods for asking whether <strong class="source-in ine">Type</strong> or <strong class="source-in ine">PropertyInfo</strong> has metadata associated with it and getting the <span class="No-Break">associated metadata.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor190"/>Helping the developer</h2>
			<p>It’s good <a id="_idIndexMarker413"/>practice to be clear on whether calling code skips calling the <strong class="source-in ine">Has*()</strong> methods and goes directly for the <strong class="source-in ine">Get*()</strong> method, and whether there is no metadata. If there is no metadata, the <strong class="source-in ine">Get*()</strong> methods can’t really do anything except throw <span class="No-Break">an exception.</span></p>
			<p>Add a file called <strong class="source-in ine">NoComplianceMetadataForType.cs</strong> and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public class NoComplianceMetadataForType : Exception
{
    public NoComplianceMetadataForType(Type type)
        : base($"Types '{type.FullName}'  does not have any
        compliance metadata.")
    {
    }
}</pre>
			<p>The code represents <a id="_idIndexMarker414"/>an exception with a clear name and a clear message saying that the type does not have <span class="No-Break">any metadata.</span></p>
			<p>Let’s do the same for the properties without metadata. Add a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">NoCompliance</strong></span><strong class="source-in ine">
MetadataForProperty.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public class NoComplianceMetadataForProperty : Exception
{
    public NoComplianceMetadataForProperty(PropertyInfo
      property)
        : base($"Property '{property.Name}' on type
          '{property.DeclaringType?.FullName}' does not
          have any compliance metadata.")
    {
    }
}</pre>
			<p>As with <strong class="source-in ine">NoComplianceMetadataForType</strong>, the <strong class="source-in ine">NoComplianceMetadataForProperty</strong> exception is clear, as suggested by its exception name and message, as to which properties do not have metadata associated <span class="No-Break">with them.</span></p>
			<p>Now you can create the<a id="_idIndexMarker415"/> implementation of the <span class="No-Break"><strong class="source-in ine">IComplianceMetadataResolver</strong></span><span class="No-Break"> interface.</span></p>
			<p>Add a file called <strong class="source-in ine">ComplianceMetadataResolver.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance;
public class ComplianceMetadataResolver : IComplianceMetadataResolver
{
    readonly IEnumerable&lt;
      ICanProvideComplianceMetadataForType&gt; _typeProviders;
    readonly IEnumerable&lt;
      ICanProvideComplianceMetadataForProperty&gt;
      _propertyProviders;
    public ComplianceMetadataResolver(
        IInstancesOf&lt;ICanProvideComplianceMetadataForType&gt;
          typeProviders,
        IInstancesOf&lt;
          ICanProvideComplianceMetadataForProperty&gt;
          propertyProviders)
    {
        _typeProviders = typeProviders.ToArray();
        _propertyProviders = propertyProviders.ToArray();
    }
}</pre>
			<p>The code makes use of <strong class="source-in ine">IInstancesOf&lt;&gt;</strong> for both <span class="No-Break">the </span><span class="No-Break"><strong class="source-in ine">ICanProvideComplianceMeta</strong></span><strong class="source-in ine">
dataForType</strong> provider type and the <strong class="source-in ine">ICanProvideComplianceMetadataForProperty</strong> provider type. It collects all these and creates instances<a id="_idIndexMarker416"/> of them in <span class="No-Break">the constructor.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">It might not be desirable to keep the instances around, as in the case presented here. This is entirely up to the implementation. In this use case, it <span class="No-Break">is fine.</span></p>
			<p>Now you need to implement the methods from the interface. Add the following code to the end of the <span class="No-Break"><strong class="source-in ine">ComplianceMetadataResolver</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public bool HasMetadataFor(Type type) =&gt; _typeProviders.Any(_ =&gt; _.CanProvide(type));
public IEnumerable&lt;ComplianceMetadata&gt; GetMetadataFor(Type type)
{
    ThrowIfNoComplianceMetadataForType(type);
    return _typeProviders
        .Where(_ =&gt; _.CanProvide(type))
        .Select(_ =&gt; _.Provide(type))
        .ToArray();
}
void ThrowIfNoComplianceMetadataForType(Type type)
{
    if (!HasMetadataFor(type))
    {
        throw new NoComplianceMetadataForType(type);
    }
}</pre>
			<p>The code uses <strong class="source-in ine">_typeProviders</strong> discovered in the constructor to determine whether the type given to it is<a id="_idIndexMarker417"/> something for which the provider can provide metadata. If it can, it will return true; if not, it will return false. The <strong class="source-in ine">GetMetadataFor()</strong> method checks whether it can provide; if it can’t, it will throw the <strong class="source-in ine">NoComplianceMetadataForType</strong> exception. If it can, it will filter down to the providers that can provide and then ask them to provide. It then combines all the metadata into <span class="No-Break">one collection.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor191"/>Supporting properties</h2>
			<p>You now want to do the same for the<a id="_idIndexMarker418"/> properties. Add the following code to the end of the <span class="No-Break"><strong class="source-in ine">ComplianceMetadataResolver</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public bool HasMetadataFor(PropertyInfo property) =&gt; _propertyProviders.Any(_ =&gt; _.CanProvide(property));
public IEnumerable&lt;ComplianceMetadata&gt; GetMetadataFor(PropertyInfo property)
{
    ThrowIfNoComplianceMetadataForProperty(property);
    return _propertyProviders
        .Where(_ =&gt; _.CanProvide(property))
        .Select(_ =&gt; _.Provide(property))
        .ToArray();
}
void ThrowIfNoComplianceMetadataForProperty(PropertyInfo property)
{
    if (!HasMetadataFor(property))
    {
        throw new
          NoComplianceMetadataForProperty(property);
    }
}</pre>
			<p>As for types, the code asks <strong class="source-in ine">_propertyProviders</strong> whether they can provide and then uses this to filter for the <a id="_idIndexMarker419"/>properties using the <strong class="source-in ine">GetMetadataFor()</strong> method. The same behavior as that of the types throwing an exception will occur if there is no metadata when it <span class="No-Break">is requested.</span></p>
			<p>With the engine in place, we now need to make use of it and create the <span class="No-Break">first implementation.</span></p>
			<p>In <strong class="source-in ine">Fundamentals</strong>, you should already have an attribute <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">PersonalIdentifiable</strong></span><strong class="source-in ine">
InformationAttribute</strong>. You now want to create a provider that can provide metadata for this on a <span class="No-Break">property level.</span></p>
			<p>Add a file called <strong class="source-in ine">PersonalIdentifiableInformationMetadataProvider.cs</strong> in a sub-folder called <strong class="source-in ine">GDPR</strong>, in the <strong class="source-in ine">Compliance</strong> folder, inside <strong class="source-in ine">Fundamentals</strong>, and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
namespace Fundamentals.Compliance.GDPR;
public class PersonalIdentifiableInformationMetadataProvider :  ICanProvideComplianceMetadataForProperty
{
    public bool CanProvide(PropertyInfo property) =&gt;
        property.GetCustomAttribute&lt;PersonalIdentifiableInformationAttribute&gt;() != default ||
        property.DeclaringType?.GetCustomAttribute&lt;PersonalIdentifiableInformationAttribute&gt;() != default;
    public ComplianceMetadata Provide(PropertyInfo
      property)
    {
        if (!CanProvide(property))
        {
            throw new
              NoComplianceMetadataForProperty(property);
        }
        var details = property.GetCustomAttribute&lt;
          PersonalIdentifiableInformationAttribute&gt;()!
          .ReasonForCollecting;
        return new
          ComplianceMetadata(ComplianceMetadataType.PII,
          details);
    }
}</pre>
			<p>The code looks for <strong class="source-in ine">PersonalIdentifiableInformationAttribute</strong> in the property given; if it’s present in the property or the declaring type, it can provide <strong class="source-in ine">ComplianceMetadata</strong>. This <a id="_idIndexMarker420"/>method provides <strong class="source-in ine">ComplianceMetadata</strong> if it is present and uses <strong class="source-in ine">ReasonForCollecting</strong> for <span class="No-Break">the details.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor192"/>Using the GDPR infrastructure</h2>
			<p>With your first<a id="_idIndexMarker421"/> GDPR provider in place, you can start to create a system that <span class="No-Break">leverages it.</span></p>
			<p>Let’s now create <a id="_idIndexMarker422"/>a folder, called <strong class="source-in ine">Chapter11</strong>, at the root of your repository. Change into this folder in your command-line interface and create a new console project, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
dotnet new console</pre>
			<p>You’re going to make use of the Microsoft hosting model to get the .NET default service provider without spinning up a web application. To achieve this, you’ll need the package called <strong class="source-in ine">Microsoft.Extensions.Hosting</strong>. In the terminal, you’ll add the reference by doing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet add package Microsoft.Extensions.Hosting</pre>
			<p>The next thing you’ll need to do is to reference the <strong class="source-in ine">Fundamentals</strong> project. In the terminal, do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet add reference ../Fundamentals/Fundamentals.csproj</pre>
			<p>Now you can start modeling a simple domain model for a patient system. Start by adding a file called <strong class="source-in ine">JournalEntry.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Chapter11;
public class JournalEntry
{
    public string Title { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
}</pre>
			<p>The code adds a type that represents<a id="_idIndexMarker423"/> an entry in a patient’s journal with a title and a <span class="No-Break">content property.</span></p>
			<p>Add a file called <strong class="source-in ine">Patient.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Fundamentals.Compliance.GDPR;
namespace Chapter11;
public class Patient
{
    [PersonalIdentifiableInformation("Employment records")]
    public string FirstName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Employment records")]
    public string LastName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Uniquely identifies
      the employee")]
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
    public IEnumerable&lt;JournalEntry&gt; JournalEntries { get;
      set; } = Enumerable.Empty&lt;JournalEntry&gt;();
}</pre>
			<p>The code adds a definition of a patient with their first name, last name, and social security number, as well as all<a id="_idIndexMarker424"/> the journal entries for the patient. For the personal information, metadata is used in the form <span class="No-Break">of </span><span class="No-Break"><strong class="source-in ine">[PersonalIdentifiableInformation]</strong></span><span class="No-Break">.</span></p>
			<p>Open the <strong class="source-in ine">Program.cs</strong> file and make it look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using Chapter11;
using Fundamentals;
using Fundamentals.Compliance;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
var host = Host.CreateDefaultBuilder()
    .ConfigureServices((context, services) =&gt;
    {
        var types = new Types();
        services.AddSingleton&lt;ITypes&gt;(types);
        services.AddBindingsByConvention(types);
        services.AddSelfBinding(types);
    })
    .Build();</pre>
			<p>The code sets up a generic host builder, registers <strong class="source-in ine">Types</strong> as a singleton, and then leverages <strong class="source-in ine">AddBindingsByConvention()</strong>, which you created in <a href="B19418_10.xhtml#_idTextAnchor162"><span class="No-Break"><em class="ita ic">Chapter 10</em></span></a>, <em class="ita ic">Convention over Configuration</em>, to hook up the services by convention. It then calls the <strong class="source-in ine">AddSelfBinding()</strong>, which you introduced earlier in this chapter. It ends by building the <span class="No-Break">host instance.</span></p>
			<p>With the host instance, we get the <strong class="source-in ine">Services</strong> property, which is the build service provider. You use this to get an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-in ine">IComplianceMetadataResolver</strong></span><span class="No-Break">.</span></p>
			<p>Add the following code at the end <span class="No-Break">of </span><span class="No-Break"><strong class="source-in ine">Program.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var complianceMetadataResolver = host.Services.
  GetRequiredService&lt;IComplianceMetadataResolver&gt;();
var typeToCheck = typeof(Patient);
Console.WriteLine($"Checking type for compliance rules: {typeToCheck.
  FullName}");
if (complianceMetadataResolver.HasMetadataFor(typeToCheck))
{
    var metadata =
      complianceMetadataResolver.GetMetadataFor(
      typeToCheck);
    foreach (var item in metadata)
    {
        Console.WriteLine($"Type level - {item.Details}");
    }
}</pre>
			<p>The code uses <strong class="source-in ine">IComplianceMetadataResolver</strong> to get the metadata for the types. In your case, for now, it’s<a id="_idIndexMarker425"/> hardcoded <span class="No-Break">to </span><span class="No-Break"><strong class="source-in ine">Patient</strong></span><span class="No-Break">.</span></p>
			<p>To get the metadata from the properties, add the following code at the end <span class="No-Break">of </span><span class="No-Break"><strong class="source-in ine">Program.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
foreach (var property in typeToCheck.GetProperties())
{
    if (complianceMetadataResolver
      .HasMetadataFor(property))
    {
        var metadata = complianceMetadataResolver
          .GetMetadataFor(property);
        foreach (var item in metadata)
        {
            Console.WriteLine($"Property: {property.Name} –
              {item.Details}");
        }
    }
    else if (property.PropertyType.IsGenericType &amp;&amp;
      property.PropertyType.GetGenericTypeDefinition()
      .IsAssignableTo(typeof(IEnumerable&lt;&gt;)))
    {
        var type = property.PropertyType
          .GetGenericArguments().First();
        if (complianceMetadataResolver
          .HasMetadataFor(type))
        {
            Console.WriteLine($"\nProperty {property.Name}
              is a collection of type {type.FullName} with
              type level metadata");
            var metadata = complianceMetadataResolver.
               GetMetadataFor(type);
            foreach (var item in metadata)
            {
                Console.WriteLine($"{property.Name} –
                  {item.Details}");
            }
        }
    }
}</pre>
			<p>The code loops through the properties of <strong class="source-in ine">typeToCheck</strong> and then prints out any details on the metadata from the properties. It also looks for any properties that have a generic argument and<a id="_idIndexMarker426"/> happen to implement <strong class="source-in ine">IEnumerable&lt;&gt;</strong>, and it prints out any metadata associated with the <span class="No-Break">item type.</span></p>
			<p>Running your program should give you the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
Checking type for compliance rules: Chapter11.Patient
Property: FirstName - Employment records
Property: LastName - Employment records
Property: SocialSecurityNumber - Uniquely identifies the employee
Property JournalEntries is a collection of type Chapter11.JournalEntry with type level metadata</pre>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor193"/>Adding more providers</h2>
			<p>With the engine in place, you<a id="_idIndexMarker427"/> can now start adding to it by simply dropping<a id="_idIndexMarker428"/> in new providers. Let’s add one for <strong class="source-in ine">JournalEntry</strong>. Add a file called <strong class="source-in ine">JournalEntryMetadataProvider.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Fundamentals.Compliance;
namespace Chapter11;
public class JournalEntryMetadataProvider : ICanProvideComplianceMetadataForType
{
    public bool CanProvide(Type type) =&gt; type == typeof(JournalEntry);
    public ComplianceMetadata Provide(Type type) =&gt; new("7242aed8-
          8d70-49df-8713-eea45e2764d4", "Journal entry");
}</pre>
			<p>The code uses the <strong class="source-in ine">JournalEntry</strong> type to decide whether it can provide or not. Every <strong class="source-in ine">JournalEntry</strong> should be treated specially as <a id="_idIndexMarker429"/>that holds critical information that shouldn’t be shared. The <strong class="source-in ine">Provide()</strong> method creates a new entry with a unique identifier for the <span class="No-Break"><strong class="source-in ine">JournalEntry</strong></span><span class="No-Break"> type.</span></p>
			<p>Running the program should now give you more information; notice the journal entries that have been added to <span class="No-Break">your output:</span></p>
			<pre class="source-code">
Checking type for compliance rules: Chapter11.Patient
Property: FirstName - Employment records
Property: LastName - Employment records
Property: SocialSecurityNumber - Uniquely identifies the employee
Property JournalEntries is a collection of type Chapter11.JournalEntry
  with type level metadata
JournalEntries - Journal entry</pre>
			<p>To continue to add things to <a id="_idIndexMarker430"/>your system, let’s add something that lets you mark a type <span class="No-Break">as </span><span class="No-Break"><strong class="bo d">confidential</strong></span><span class="No-Break">.</span></p>
			<p>Add a file called <strong class="source-in ine">ConfidentialAttribute.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Chapter11;
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false,
  Inherited = true)]
public sealed class ConfidentialAttribute : Attribute
{
}</pre>
			<p>The attribute is <span class="No-Break">targeting classes.</span></p>
			<p>Next, you need a provider that can provide metadata for the new attribute. Add a file called <strong class="source-in ine">ConfidentialMetadataProvider.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using System.Reflection;
using Fundamentals.Compliance;
namespace Chapter11;
public class ConfidentialMetadataProvider :
  ICanProvideComplianceMetadataForType
{
    public bool CanProvide(Type type) =&gt;
      type.GetCustomAttribute&lt;ConfidentialAttribute&gt;() !=
      null;
    public ComplianceMetadata Provide(Type type) =&gt;
      new("8dd1709a-bbe1-4b98-84e1-9e7be2fd4912", "The data
      is confidential");
}</pre>
			<p>The provider looks for <strong class="source-in ine">ConfidentialAttribute</strong> to decide whether it can provide. If it can, the <strong class="source-in ine">Provide()</strong> method creates a new instance of <strong class="source-in ine">ComplianceMetadata</strong> with a unique identifier for the type <span class="No-Break">it represents.</span></p>
			<p>Open the <strong class="source-in ine">Patient.cs</strong> file<a id="_idIndexMarker431"/> and add the <strong class="source-in ine">[Confidential]</strong> attribute in front of the <strong class="source-in ine">Patient</strong> class, making the class look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using Fundamentals.Compliance.GDPR;
namespace Chapter11;
[Confidential]
public class Patient
{
    [PersonalIdentifiableInformation("Employment records")]
    public string FirstName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Employment records")]
    public string LastName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Uniquely identifies
      the employee")]
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
    public IEnumerable&lt;JournalEntry&gt; JournalEntries { get;
      set; } = Enumerable.Empty&lt;JournalEntry&gt;();
}</pre>
			<p>Running the program now <a id="_idIndexMarker432"/>should give you an output that includes the type-level information at the <span class="No-Break">very top:</span></p>
			<pre class="source-code">
Checking type for compliance rules: Chapter11.Patient
Type level - The data is confidential
Property: FirstName - Employment records
Property: LastName - Employment records
Property: SocialSecurityNumber - Uniquely identifies the employee
Property JournalEntries is a collection of type Chapter11.JournalEntry with type level metadata
JournalEntries - Journal entry</pre>
			<p>You’ve now created a system that is flexible and extensible. You don’t have to go into the “engine” to perform any changes to introduce new capabilities. This is a powerful featu<a id="_idTextAnchor194"/>re and a trait of a <span class="No-Break">healthy system.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor195"/>Summary</h1>
			<p>Building software that is <strong class="bo d">evergreen</strong> is hard. Software that stands the test of time, does not lose its maintainability, and has the ability to allow development of new capabilities in a reasonable time frame is even harder. Keeping the time it takes to develop new business value close to constant is what we’re aiming for. This makes it much easier for businesses to determine the impact of new functionalities. It also makes this impact more predictable <span class="No-Break">for developers.</span></p>
			<p>To this end, there are techniques, patterns, practices, and principles that can help. Thinking in extensible terms and designing the code to not become locked down is key, in my opinion. In this way, most of the time, it’s possible to focus on additions, rather than having to perform open-heart surgery just to add <span class="No-Break">new capabilities.</span></p>
			<p>In the next chapter, we’re going to look at combining what we looked at in this chapter with what you started doing with conventions in <a href="B19418_10.xhtml#_idTextAnchor162"><span class="No-Break"><em class="ita ic">Chapter 10</em></span></a>, <em class="ita ic">Convention over Configuration</em>. Conventions can take many forms, and they can help you go beyond the inheritance model of C# <span class="No-Break">and .NET.</span></p>
		</div>
	</body></html>