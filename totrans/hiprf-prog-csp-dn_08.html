<html><head></head><body>
		<div id="_idContainer121">
			<h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor117"/>Chapter 6</em>: The .NET Collections </h1>
			<p>Collections are an integral part of .NET. There are different ways to use these collections. Microsoft .NET makes heavy use of arrays and collections when dealing with things such as datasets, arrays, lists, dictionaries, stacks, and queues. You will be hard-pressed to write a C# program without having to use the Collections Framework. The different ways of using the collections and arrays differ in terms of their performance degradation and performance improvement. Therefore, understanding when to use arrays and when to use collections will form an important aspect of your C# and .NET programming skills.</p>
			<p>In this chapter, you will learn how to improve the performance of your collection operations. By using <strong class="source-inline">BenchmarkDotNet</strong> with different versions of the code, you will be able to see the differences in performance and be in a position to choose the best method that suits your needs.</p>
			<p>We will be covering the following topics in this chapter:</p>
			<ul>
				<li><strong class="bold">Understanding the different collection offerings</strong>: This section is purely informational and provides an overview of the <strong class="source-inline">System.Collections</strong>, <strong class="source-inline">System.Collections.Generic</strong>, <strong class="source-inline">System.Collections.Concurrent</strong>, and <strong class="source-inline">System.Collections.Specialized</strong> namespaces. </li>
				<li><strong class="bold">Setting up our sample database</strong>: We will be using a SQL database that highlights the difference between <strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">IQueryable</strong>. This section will show you how to develop our sample database with sample data that will be used later in this chapter.</li>
				<li><strong class="bold">Deciding between interfaces and concrete classes</strong>: In this section, you will benchmark the performance between using classes and interfaces. Then, you will be able to decide on the method that best suits your needs.</li>
				<li><strong class="bold">Deciding between using arrays or collections</strong>: There are strengths and weaknesses between using arrays and collections. In this section, you will benchmark the performance of arrays and collections and decide which to use based on your performance requirements.</li>
				<li><strong class="bold">Accessing objects using indexers</strong>: In this section, we will discuss accessing objects in the same way we would access items in an array by using indexers.</li>
				<li><strong class="bold">Comparing IEnumerable and IEnumerator</strong>: In this section, we will benchmark iterations using both IEnumerable and IEnumerator. You will see that there is a definite performance difference between these ways of enumerating.</li>
				<li><strong class="bold">Database query performance</strong>: In this section, we will query a database using five different methods, benchmarking their performance to see which method produces the fastest performance.</li>
				<li><strong class="bold">Exploring the yield keyword</strong>: In this section, you will learn about the <strong class="source-inline">yield</strong> keyword and how it relates to the performance of your applications, especially when it comes to iterating through collections and arrays.</li>
				<li><strong class="bold">Learning the difference between concurrency and parallelism</strong>: In this section, you will understand the difference between concurrency and parallelism, and learn when to use one over the other.</li>
				<li><strong class="bold">Learning the difference between Equals() and ==</strong>: In this section, you will understand the differences between the different equality operators, and learn when to use one over the other.</li>
				<li><strong class="bold">Studying LINQ performance</strong>: LINQ is a C# query language that is heavily utilized when it comes to processing collections, but it can be slow or fast, depending on the way you code your queries. In this section, you will learn how to benchmark different ways of performing the same types of queries. In doing so, you will see the difference in performance between the different ways of writing the same queries.</li>
			</ul>
			<p>By the end of this chapter, you will be able to do the following:</p>
			<ul>
				<li>Describe the different collections available and their uses</li>
				<li>Choose between using interfaces and collections</li>
				<li>Understand the trade-offs between arrays and collections</li>
				<li>Write indexers</li>
				<li>Choose the best form of iteration for your particular needs</li>
				<li>Use the <strong class="source-inline">yield</strong> keyword</li>
				<li>Know which equality operator to use for different types of equality checking</li>
				<li>Improve LINQ query performance</li>
			</ul>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need access to the following tools:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>SQL Server (any version) Express or higher</li>
				<li>SQL Server Management Studio</li>
				<li>This book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06</a><a href="https://github.com/PacktPublishing/Mastering-High-Performance-with-C-10.0-and-.NET-6&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Understanding the different collection offerings</h1>
			<p>A collection<a id="_idIndexMarker607"/> is a group of records that can be treated as one logical unit. Examples of logical record groups include people, countries, products, ingredients, books, authors, and more. </p>
			<p>There are four main types of collections, as follows:</p>
			<ul>
				<li><strong class="bold">Index-based</strong> collections, such as an array<a id="_idIndexMarker608"/> or list. Index-based collections<a id="_idIndexMarker609"/> contain an internal index. The index can be either numeric or string-based. An index-based collection is more commonly accessed using a numerical index. Numerical indexes are zero-based. This means that a collection's index will start<a id="_idIndexMarker610"/> at zero for the first record<a id="_idIndexMarker611"/> and increase in value by the order of one for each subsequent record. Collections that can be accessed using numerical indexes include arrays and lists. </li>
				<li><strong class="bold">Key/value pair</strong> collections, such as a hash table<a id="_idIndexMarker612"/> or sorted list. Key/value pair collections<a id="_idIndexMarker613"/> such as <strong class="source-inline">Hashtable</strong> and <strong class="source-inline">SortedList</strong> use a key to look up the value stored in a collection. So, for example, if you have a collection of products, you can access the product you need by using the product code that was assigned as the key when the product was added to the key/value pair collection.</li>
				<li><strong class="bold">Prioritized</strong> collections, such as a stack<a id="_idIndexMarker614"/> or queue. Prioritized collections<a id="_idIndexMarker615"/> allow you to store and extract<a id="_idIndexMarker616"/> records in a particular sequence. A queue uses the <strong class="bold">First In First First Out</strong> (<strong class="bold">FIFO</strong>) sequence, while a stack<a id="_idIndexMarker617"/> uses the <strong class="bold">Last In First Out</strong> (<strong class="bold">LIFO</strong>) sequence.</li>
				<li><strong class="bold">Specialized</strong> collections, such as string collections<a id="_idIndexMarker618"/> and hybrid dictionaries. Specialized collections<a id="_idIndexMarker619"/> are out-of-the-box collections for specific purposes. For example, there is the <strong class="source-inline">CollectionsUtil</strong> class, which creates collections that ignore the case in strings, and the <strong class="source-inline">ListDictionary</strong> class, which is recommended for collections that contain less than 10 items. It implements <strong class="source-inline">IDictionary</strong> using a singly linked list.</li>
			</ul>
			<p>The .NET Collections Framework consists of the legacy <strong class="source-inline">System.Collections</strong> namespaces, as well as the newer <strong class="source-inline">System.Collections.Generic</strong>, <strong class="source-inline">System.Collections.Concurrent</strong>, and <strong class="source-inline">System.Collections.Specialized</strong> namespaces. Before we delve into the performance of collections, it is a good idea to reacquaint ourselves with the different collections that are available in each of the aforementioned namespaces.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>The System.Collections namespace</h2>
			<p>The <strong class="source-inline">System.Collections</strong> namespace contains various<a id="_idIndexMarker620"/> classes, structures, and<a id="_idIndexMarker621"/> interfaces. In this section, we will briefly cover what is available. The collections in this namespace are not thread-safe. If you require thread-safe collections, it would be better to use the collections in the <strong class="source-inline">System.Collections.Concurrent</strong> namespace instead, as advised by Microsoft!</p>
			<p>The <strong class="source-inline">ICollection</strong> interface defines the size, enumerators, and synchronization methods for all non-generic collections. To compare two objects, you can implement the <strong class="source-inline">IComparer</strong> interface. You can represent non-generic key/value pair collections using <strong class="source-inline">Idictionary</strong>. To enumerate a non-generic dictionary, you can use the <strong class="source-inline">IDictionaryEnumerator</strong> interface. Simple iteration over non-generic collections is provided by the <strong class="source-inline">IEnumerator</strong> interface, while equality between objects is implemented via the <strong class="source-inline">IEqualityComparer</strong> interface. The <strong class="source-inline">IList</strong> interface is used to implement non-generic collections of objects that can be individually accessed using the index. Structural comparison of objects and structural equality comparison of objects is implemented using the <strong class="source-inline">IStructuralComparable</strong> and <strong class="source-inline">IStructuralEquatable</strong> interfaces, respectively.</p>
			<ul>
				<li>The <strong class="source-inline">ArrayList</strong> class implements the <strong class="source-inline">IList</strong> interface using a dynamic array that can grow and shrink in size as required. </li>
				<li>On (<strong class="source-inline">0</strong>) and off (<strong class="source-inline">1</strong>), which are represented by the Boolean values <strong class="source-inline">false</strong> and <strong class="source-inline">true</strong>, respectively, are managed by the <strong class="source-inline">BitArray</strong> class. </li>
				<li>To compare two objects while ignoring string casing, you can use the <strong class="source-inline">CaseInsensitiveComparer</strong> class. Use <strong class="source-inline">CaseInsensitiveHashCodeProvider</strong> to generate hash codes using algorithms that ignore string casing. </li>
				<li>When you're building a strongly typed collection, inherit from the <strong class="source-inline">CollectionBase</strong> class. </li>
				<li>The <strong class="source-inline">Comparer</strong> class is used to compare two objects for equivalence with case-sensitive string comparison. </li>
				<li>Use <strong class="source-inline">DictionaryBase</strong> as the abstract class when developing strongly typed collections of key/value pairs. </li>
				<li>A collection of key/value pairs organized by key-based hash codes is represented by the <strong class="source-inline">Hashtable</strong> class. </li>
				<li>The <strong class="source-inline">Queue</strong> class provides a collection with FIFO access. </li>
				<li>The <strong class="source-inline">ReadOnlyCollectionBase</strong> abstract class is used as the base class for strongly typed non-generic, read-only collections. </li>
				<li>Use the <strong class="source-inline">SortedList</strong> class to hold a collection of key/value pairs that are sorted by the keys and are accessible by key or index. </li>
				<li>Use the <strong class="source-inline">Stack</strong> class if you need LIFO access for your collection. </li>
				<li>To compare two collection objects structurally, you can use the <strong class="source-inline">StructuralComparisons</strong> class. </li>
				<li>The <strong class="source-inline">DictionaryEntry</strong> structure defines a dictionary key/value pair that can be set or retrieved. <p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">IHashCodeProvider</strong> has now been marked obsolete and is no longer recommended by Microsoft for new development. Microsoft recommends that you use the <strong class="source-inline">IEqualityComparer</strong> and <strong class="source-inline">IEqualityComparer&lt;T&gt;</strong> interfaces instead.</p></li>
			</ul>
			<p>We now know<a id="_idIndexMarker622"/> what is available in<a id="_idIndexMarker623"/> the <strong class="source-inline">System.Collections</strong> namespace. Now, let's look at what's available in the <strong class="source-inline">System.Collections.Generic</strong> namespace.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>The System.Collections.Generic namespace</h2>
			<p>The classes and interfaces<a id="_idIndexMarker624"/> that are available in the <strong class="source-inline">System.Collections.Generic</strong> namespace provide<a id="_idIndexMarker625"/> collections that are strongly typed and that perform better than the classes within the <strong class="source-inline">System.Collections</strong> namespace. This namespace contains many classes, structs, and interfaces.</p>
			<p>The <strong class="source-inline">CollectionExtensions</strong> class provides<a id="_idIndexMarker626"/> extension methods for generic collections. To compare two objects, you<a id="_idIndexMarker627"/> can use the <strong class="source-inline">Comparer&lt;T&gt;</strong> class, which implements the <strong class="source-inline">IComparer&lt;T&gt;</strong> interface. The <strong class="source-inline">IComparer&lt;T&gt;</strong> interface defines the method types to implement to compare two objects.</p>
			<p>The <strong class="source-inline">IDictionary&lt;TKey, TValue&gt;</strong> interface provides methods for implementing generic dictionaries. For a dictionary to be read-only, it must implement the <strong class="source-inline">IReadOnlyDictionary&lt;TKey, TValue&gt;</strong> interface. A collection of keys and values is represented by the <strong class="source-inline">Dictionary&lt;TKey, TValue&gt;</strong> class. <strong class="source-inline">Dictionary&lt;TKey, TValue&gt;.KeyCollection</strong> cannot be inherited and represents the collection of keys within a <strong class="source-inline">Dictionary&lt;TKey, TValue&gt;</strong> collection. Finally, <strong class="source-inline">Dictionary&lt;TKey, TValue&gt;.ValueCollection</strong> cannot be inherited and represents the collection of values within a <strong class="source-inline">Dictionary&lt;TKey, TValue&gt;</strong> collection.</p>
			<p>The <strong class="source-inline">IEqualityComparer&lt;T&gt;</strong> interface defines methods that you can use to compare objects for equality. A base class for implementations of the <strong class="source-inline">IEqualityComparer&lt;T&gt;</strong> interface is provided called <strong class="source-inline">EqualityComparer&lt;T&gt;</strong>.</p>
			<p><strong class="source-inline">HashSet&lt;T&gt;</strong> represents a set of values. When a key that's been used to access a collection cannot be found within the collection that's being searched, then a <strong class="source-inline">KeyNotFoundException</strong> is raised. A key/value pair instance is generated using the <strong class="source-inline">KeyValuePair</strong> class. For a doubly linked list, use the <strong class="source-inline">LinkedList&lt;T&gt;</strong> class. The non-inheritable <strong class="source-inline">LinkedListNode&lt;T&gt;</strong> class represents a node in a collection of the <strong class="source-inline">LinkedList&lt;T&gt;</strong> type.</p>
			<p><strong class="source-inline">IList&lt;T&gt;</strong> represents a collection of objects for implementing lists that can be accessed by index. Read-only lists implement the <strong class="source-inline">IReadOnlyList&lt;T&gt;</strong> interface. When you need a collection that is strongly typed that enables searching, sorting, and manipulating lists, then use the <strong class="source-inline">List&lt;T&gt;</strong> class. For FIFO collections, use the <strong class="source-inline">Queue&lt;T&gt;</strong> class.</p>
			<p><strong class="source-inline">ReferenceEqualityComparere</strong> is an <strong class="source-inline">IEqualityComparer&lt;T&gt;</strong> that uses reference equality by calling <strong class="source-inline">ReferenceEquals(Object, Object)</strong> instead of using value equality by calling <strong class="source-inline">Equals(Object)</strong> when comparing two object instances.</p>
			<p>A key/value pair collection that's sorted on the key is represented by the <strong class="source-inline">SortedDictionary&lt;TKey, TValue&gt;</strong> class. This type of collection is represented by <strong class="source-inline">SortedDictionary&lt;TKey, TValue&gt;.KeyCollection</strong>, which cannot be inherited. The values that have been collected are represented by <strong class="source-inline">SortedDictionary&lt;TKey, TValue&gt;.ValueCollection</strong>, which cannot be inherited.</p>
			<p>The <strong class="source-inline">SortedList&lt;TKey, TValue&gt;</strong> class represents<a id="_idIndexMarker628"/> a collection of key/value pairs that are sorted by key based<a id="_idIndexMarker629"/> on the associated <strong class="source-inline">IComparer&lt;T&gt;</strong> implementation. A collection of objects that has been maintained in sorted order is represented by the <strong class="source-inline">SortedSet&lt;T&gt;</strong> class. The <strong class="source-inline">Stack&lt;T&gt;</strong> class provides LIFO manipulation for instances of the same type.</p>
			<p>There are several structures available for the various generic collection classes that allow you to enumerate<a id="_idIndexMarker630"/> the elements in the collection. These structures are called enumerators.</p>
			<p>Asynchronously enumerating over values of a specific type can be done by implementing the <strong class="source-inline">IAsyncEnumerable&lt;T&gt;</strong> interface. <strong class="source-inline">IAsyncEnumerator&lt;T&gt;</strong> provides the necessary support to iterate over a generic collection. <strong class="source-inline">ICollection&lt;T&gt;</strong> defines the methods needed to manipulate generic collections. Strongly typed collections that are read-only implement the <strong class="source-inline">IReadOnlyCollection&lt;T&gt;</strong> interface. Sets implement the <strong class="source-inline">ISet&lt;T&gt;</strong> interface, while read-only sets implement the <strong class="source-inline">IReadOnlySet&lt;T&gt;</strong> interface.</p>
			<p>Now that we've looked at what the <strong class="source-inline">System.Collections.Generic</strong> namespace has to offer, let's turn our attention to the <strong class="source-inline">System.Collections.Concurrent</strong> namespace.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>The System.Collections.Concurrent namespace</h2>
			<p>The collections in the <strong class="source-inline">System.Collections.Concurrent</strong> namespace<a id="_idIndexMarker631"/> are thread-safe. Whenever multiple<a id="_idIndexMarker632"/> threads are concurrently accessing a collection, use the collections in this namespace over the collections in the <strong class="source-inline">System.Collections</strong> and <strong class="source-inline">System.Collections.Generic</strong> namespaces.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Extension methods and explicit interface implementations of these collections are not guaranteed to be thread-safe. To ensure thread safety, synchronization may be required in these instances.</p>
			<p><strong class="source-inline">IProducerConsumerCollection&lt;T&gt;</strong> defines methods that form<a id="_idIndexMarker633"/> the basis of thread-safe collection manipulation<a id="_idIndexMarker634"/> in producer/consumer usage (also known as publisher/subscriber usage). Higher-level abstractions<a id="_idIndexMarker635"/> such as the <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> class can use<a id="_idIndexMarker636"/> this collection as their underlying storage mechanism.</p>
			<p>The <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> class provides blocking and bounding capabilities to thread-safe collections that implement the <strong class="source-inline">IProducerConsumerCollection&lt;T&gt;</strong> interface.</p>
			<p>Options to control partitioner buffering behavior are specified by the <strong class="source-inline">EnumerablePartitionerOptions</strong> enum.</p>
			<p>Arrays, lists, and enumerable partitioning strategies are provided by the <strong class="source-inline">Partitioner</strong> class. The <strong class="source-inline">Partitioner&lt;Tsource&gt;</strong> class provides a particular manner of splitting a data source into multiple partitions, while <strong class="source-inline">OrderablePartioner&lt;Tsource&gt;</strong> splits an orderable data source into multiple partitions.</p>
			<p>The <strong class="source-inline">Concurrent&lt;T&gt;</strong> class contains a thread-safe unordered list of objects. Thread-safe FIFO collections use the <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> class, while thread-safe LIFO collections use the <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong> class. To concurrently access key/value pairs in a thread-safe manner, use the <strong class="source-inline">ConcurrentDictionary&lt;Tkey, Tvalue&gt;</strong> class.</p>
			<p>With that, we've covered the <strong class="source-inline">System.Collections.Concurrent</strong> namespace. Now, let's look at the <strong class="source-inline">System.Collections.Specialized</strong> namespace.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>The System.Collections.Specialized namespace</h2>
			<p>The <strong class="source-inline">System.Collections.Specialized</strong> namespace contains<a id="_idIndexMarker637"/> specialized and strongly<a id="_idIndexMarker638"/> typed collections. Let's see what it has to offer.</p>
			<p>The <strong class="source-inline">CollectionChangedEventManager</strong> class provides a <strong class="source-inline">WeakEventManager</strong> implementation. By using the <strong class="source-inline">WeakEventListener</strong> pattern, you can attach listeners for the collection-changed event.</p>
			<p>To build a collection of strings that ignores the string casing, you can use the <strong class="source-inline">CollectionUtils</strong> class.</p>
			<p>The <strong class="source-inline">HybrdDictionary</strong> class changes its behavior when the collection is small, and when the collection grows in size. It does this by implementing <strong class="source-inline">IDictionary</strong> using a <strong class="source-inline">ListDictionary</strong> when the collection is small; it uses a <strong class="source-inline">Hashtable</strong> when the collection grows in size and becomes large.</p>
			<p>For fewer than 10 items, you can use <strong class="source-inline">ListDictionary</strong>, which implements <strong class="source-inline">IDictionary</strong> by using a singly linked list.</p>
			<p>To hold a collection of the string keys of a collection, use <strong class="source-inline">NameObjectCollectionBase.KeysCollection</strong>.</p>
			<p>When you need to provide data for the <strong class="source-inline">CollectionChanged</strong> event, use the <strong class="source-inline">NotifyCollectionChangedEventArgs</strong> class.</p>
			<p>When you have an ordered collection of key/value pairs that you need to be accessible via either the key or the index, use <strong class="source-inline">OrderedDictionary</strong>.</p>
			<p>You can use the <strong class="source-inline">StringCollection</strong> class to hold a collection of strings, and you can use the <strong class="source-inline">StringEnumerator</strong> class to perform a simple iteration of the <strong class="source-inline">StringCollection</strong> class.</p>
			<p>To get a hash table of keys and strongly typed string values, use the <strong class="source-inline">StringDictionary</strong> class.</p>
			<p>To store a Boolean value or small integer in 32 bits of memory, you can use the <strong class="source-inline">BitVector32</strong> structure. You can use <strong class="source-inline">BitVector32.Section</strong> of the vector to store an integer number.</p>
			<p>Indexed collections of key/value pairs are represented by the <strong class="source-inline">IOrderedDictionary</strong> interface. The <strong class="source-inline">INotifyCollectionChanged</strong> interface is used to notify listeners of dynamic changes to a collection, such as when items are added, modified, or removed. The <strong class="source-inline">NotifyCollectionChangedAction</strong> enum describes<a id="_idIndexMarker639"/> the action that resulted<a id="_idIndexMarker640"/> in the <strong class="source-inline">CollectionChanged</strong> event being fired.</p>
			<p>Now, let's look at custom collections and write one.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>Creating custom collections</h2>
			<p>To create custom<a id="_idIndexMarker641"/> collections, you must inherit from <strong class="source-inline">CollectionBase</strong>. The <strong class="source-inline">CollectionBase</strong> class has a read-only <strong class="source-inline">ArrayList</strong> property called <strong class="source-inline">InnerList</strong>, and it implements the <strong class="source-inline">IList</strong>, <strong class="source-inline">ICollection</strong>, and <strong class="source-inline">IEnumerable</strong> interfaces. Then, you can add your own <strong class="source-inline">Add</strong>, <strong class="source-inline">Remove</strong>, <strong class="source-inline">Clear</strong>, and <strong class="source-inline">Count</strong> methods. We'll do this in our project. We will create a very simple custom collection that inherits from <strong class="source-inline">CollectionBase</strong> so that you can see how easy it is to create custom collections. Follow these steps:</p>
			<ol>
				<li>Add a new class under the <strong class="source-inline">CustomCollections</strong> folder called <strong class="source-inline">CustomCollections</strong> that inherits from <strong class="source-inline">CollectionBase</strong>.</li>
				<li>Add the <strong class="source-inline">Add(object item)</strong> method to the class:<p class="source-code">public void Add(object item)</p><p class="source-code">{</p><p class="source-code">      InnerList.Add(item);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method adds an item to <strong class="source-inline">InnerList</strong>, which we have inherited from the <strong class="source-inline">CollectionBase</strong> class.</p>
			<ol>
				<li value="3">Add the <strong class="source-inline">Remove(object item)</strong> method to the class:<p class="source-code">public void Remove(object item)</p><p class="source-code">{</p><p class="source-code">      InnerList.Remove(item);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method removes<a id="_idIndexMarker642"/> an item from the inherited <strong class="source-inline">InnerList</strong>.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">Clear()</strong> method:<p class="source-code">public new void Clear()</p><p class="source-code">{</p><p class="source-code">InnerList.Clear();</p><p class="source-code">}</p></li>
			</ol>
			<p>This method clears all the items from <strong class="source-inline">InnerList</strong>.</p>
			<ol>
				<li value="5">Add the <strong class="source-inline">Count()</strong> method:<p class="source-code">public new int Count()</p><p class="source-code">{</p><p class="source-code">      return InnerList.Count;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method returns the count of the number of items in <strong class="source-inline">InnerList</strong>.</p>
			<p>As you can see, creating custom collections does not have to be hard. Our implementation is very simple and basic. However, such a class can be made to hold specific types instead of the generic object type. You could also make your class generic so that it accepts classes that implement a specific interface.</p>
			<p>The following is a detailed article by<a id="_idIndexMarker643"/> Microsoft on implementing custom collections by implementing <strong class="source-inline">ICollection</strong>: <a href="https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.">https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.</a></p>
			<p>As you read through this chapter, you will see different aspects of collections. You will also measure their performance. This way, as you create custom collections, you can choose the most performant way of doing things for the tasks at hand.</p>
			<p>Now that we've briefly<a id="_idIndexMarker644"/> covered the different collection offerings in the .NET Collections Framework, let's look at what Big O notation is.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>Understanding Big O notation</h1>
			<p>Big O notation is used to determine algorithmic<a id="_idIndexMarker645"/> efficiency. It determines how time scales concerning input. Constant time equates to a Big O notation value of O(1). Data operations that scale linearly over time, depending on the size of the operation, have a Big O notation value of (<em class="italic">N</em>), where <em class="italic">N</em> equals the amount of data being processed. </p>
			<p>For example, if you were iterating over several elements in an array or collection, you would use O(<em class="italic">N</em>), which is a linear time, where <em class="italic">N</em> is the size of the array or collection. If an iteration contains pairs such as <em class="italic">x</em> and <em class="italic">y</em>, where you iterate over <em class="italic">x</em> in the iteration and then <em class="italic">y</em> in the iteration, then your Big O notation would be O(<em class="italic">N</em><span class="superscript">2</span>). Another scenario would be identifying the amount of time it takes to harvest a square plot of land. This could be written as O(<em class="italic">a</em>), where <em class="italic">a</em> is the area of land. Alternatively, you could write the Big O notation as O(<em class="italic">s</em><span class="superscript">2</span>), where <em class="italic">s</em> is the length of one size.</p>
			<p>There are some rules<a id="_idIndexMarker646"/> to consider when using Big O notation:</p>
			<ul>
				<li>Different steps in your algorithm are added together. So, if step 1 takes O(<em class="italic">a</em>) time, and step 2 takes O(<em class="italic">b</em>) time, then your Big O notation for the algorithm will be O(<em class="italic">a+b</em>).</li>
				<li>Drop constants. For example, if you have two operations that are both constants in your algorithm, you do not write O(<em class="italic">2N</em>). The notation remains O(<em class="italic">N</em>).</li>
				<li>If you have different inputs that are different variables, such as collection a and collection b, then your Big O notation would be O(<em class="italic">a*b</em>).</li>
				<li>Drop non-dominant terms. So, O(<em class="italic">n</em><span class="superscript">2</span>) is equivalent to O(<em class="italic">n + n</em><span class="superscript">2</span>), which is equivalent to (<em class="italic">n</em><span class="superscript">2</span><em class="italic">+n</em><span class="superscript">2</span>).</li>
			</ul>
			<p>Now that we understand what Big O notation is and the various collections available to us, let's look at choosing the right collections for our work items.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Choosing the right collection</h2>
			<p>The key to performance when working<a id="_idIndexMarker647"/> with multiple items of data in memory is to choose the correct storage mechanism that offers the fastest processing time for your requirements. Here's the list of the different types of collections and their strengths to help you choose the right collections for the right tasks:</p>
			<ul>
				<li>A <strong class="source-inline">Dictionary</strong> is an unordered<a id="_idIndexMarker648"/> collection with contiguous storage that is directly accessible via a key. A dictionary's lookup efficiency using a key is O(1) and its manipulation efficiency is also O(1). Dictionaries are best used for high-performance lookups.</li>
				<li>A <strong class="source-inline">HashSet</strong> is unordered, has contiguous<a id="_idIndexMarker649"/> storage, and is directly accessible via a key. It has a lookup efficiency using a key of O(1), and a manipulation efficiency of O(1). <strong class="source-inline">HashSet</strong> is a unique unordered collection, called <strong class="source-inline">Dictionary</strong>, except the key and the value are the same object.</li>
				<li>A <strong class="source-inline">LinkedList</strong> lets the user have complete<a id="_idIndexMarker650"/> control over how it is ordered, does not have contiguous storage, and is not directly accessible. It has a lookup efficiency value of O(<em class="italic">n</em>), and a manipulation efficiency of O(1). It's best to use lists when you need to insert or remove items and no direct access is required.</li>
				<li>A <strong class="source-inline">List</strong> lets the user have complete control<a id="_idIndexMarker651"/> over how it is ordered, has contiguous storage, and is directly accessible via an index. It has a lookup efficiency using an index of O(1), and a lookup efficiency using a value of O(<em class="italic">n</em>). Its manipulation efficiency is O(<em class="italic">n</em>). It is best to use this list when direct access is required, the list is small, and there is no sorting.</li>
				<li>A <strong class="source-inline">Queue</strong> is ordered according<a id="_idIndexMarker652"/> to FIFO, has contiguous storage, and only has direct access from the front of the queue. It has a lookup efficiency at the front of the queue of O(1), and a manipulation index of O(1). It is essentially<a id="_idIndexMarker653"/> the same as <strong class="source-inline">List&lt;T&gt;</strong>, except it is only processed using FIFO.</li>
				<li>A <strong class="source-inline">SortedDictionary</strong> is ordered, does not have contiguous storage, and can be directly<a id="_idIndexMarker654"/> accessed using a key. It has a lookup efficiency using the key of O(<em class="italic">log n</em>) with a manipulation efficiency of O(<em class="italic">log n</em>). This collection makes a trade-off between speed and ordering and uses a binary search tree.</li>
				<li>A <strong class="source-inline">SortedList</strong> is ordered, has contiguous<a id="_idIndexMarker655"/> storage, and is directly accessible via a key. It has a lookup<a id="_idIndexMarker656"/> efficiency using the key of O(<em class="italic">log n</em>) and a manipulation efficiency of (O(<em class="italic">n</em>). The tree is implemented as an array, making lookups faster on preloaded data, but slower on loads.</li>
				<li>A <strong class="source-inline">SortedSet</strong> is ordered, does not have<a id="_idIndexMarker657"/> contiguous storage, and is directly accessible via a key. It has a lookup efficiency using a key of O(<em class="italic">log n</em>), and a manipulation efficiency of O(<em class="italic">log n</em>). It's a unique sorted collection, similar to a <strong class="source-inline">SortedDictionary</strong>, except the key and value are the same object.</li>
				<li>A <strong class="source-inline">Stack</strong> is ordered according to LIFO, has<a id="_idIndexMarker658"/> contiguous storage, and can only be directly accessed from the top of the stack. It has a lookup efficiency of the top item of O(1) and a manipulation efficiency of O(1)*. It is essentially the same as <strong class="source-inline">List&lt;T&gt;</strong>, except it is only processed using LIFO.<p class="callout-heading">Note</p><p class="callout">For mission-critical code, it is advised that you avoid using classes in the <strong class="source-inline">System.Collection</strong> namespace. Instead, you should be using the classes from the <strong class="source-inline">System.Collections.Generic</strong> namespace. Although this may sound like tried and tested advice, you are advised to run benchmark tests to see which method is best for your particular scenario.</p></li>
			</ul>
			<p>Now that you have been introduced to arrays and collections, we will set up our sample database before we continue looking at collections from a performance perspective.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor127"/>Setting up our sample database</h1>
			<p>In this chapter, we will be demonstrating<a id="_idIndexMarker659"/> the difference between how different collection interfaces handle data. For our demonstrations, we require access to database data. To do so, we will create a database, add a table to it, and populate it with data. We will use SQL Server for our database engine and SQL Server Management Studio to develop our sample database.</p>
			<p>To add our database, follow these steps:</p>
			<ol>
				<li value="1">Open <strong class="bold">SQL Server Management Studio</strong> and connect to your database engine.</li>
				<li>Right-click on the <strong class="bold">Databases</strong> folder in <strong class="bold">Object Explorer</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B16617_Figure_6.1.jpg" alt="Figure 6.1 – SQL Server Management Studio – Object Explorer &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – SQL Server Management Studio – Object Explorer </p>
			<ol>
				<li value="3">Select <strong class="bold">New Database</strong> from the context menu. This will display the <strong class="bold">New Database</strong> dialog, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B16617_Figure_6.2.jpg" alt="Figure 6.2 – SQL Server Management Studio – the New Database dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – SQL Server Management Studio – the New Database dialog</p>
			<ol>
				<li value="4">Once you have entered <strong class="source-inline">SampleData</strong> under <strong class="bold">Database name</strong>, click on the <strong class="bold">OK</strong> button to create<a id="_idIndexMarker660"/> the database.</li>
				<li>Locate the database by expanding the <strong class="bold">Databases</strong> folder, and then expand the database. Right-click on the <strong class="bold">Tables</strong> folder and select <strong class="bold">New</strong> | <strong class="bold">Table</strong>. Add a new table called <strong class="source-inline">Products</strong>, as shown here:</li>
			</ol>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Table_6.1.jpg" alt="Table 6.1 – The Products table's design&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.1 – The Products table's design</p>
			<ol>
				<li value="6"><strong class="bold">Save</strong> the table, and then<a id="_idIndexMarker661"/> expand the <strong class="bold">Tables</strong> folder. Right-click on the <strong class="bold">Product</strong> table and select <strong class="bold">Edit Top n records</strong>, where <em class="italic">n</em> will be the number of configured records to edit. This is 200 by default.</li>
				<li>Add the data shown in the following table to the <strong class="bold">Product</strong> table:</li>
			</ol>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Table_6.2.jpg" alt="Table 6.2 – The Product table's row data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.2 – The Product table's row data</p>
			<p>We now have a database<a id="_idIndexMarker662"/> with a single table filled with data that we will later use in this chapter. Now, let's understand collections from a performance perspective. Let's start by looking at how we decide between using arrays or collections.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor128"/>Deciding between interfaces and concrete classes</h1>
			<p>In this section, we will show<a id="_idIndexMarker663"/> that declaring a collection using an interface declaration rather than a concrete class declaration provides better time-based performance. We will accomplish this by benchmarking the generation of collections using an <strong class="source-inline">IList</strong> interface, as well as by using a <strong class="source-inline">List</strong> concrete class, so that you can see the difference in the performance of the different approaches. Follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">CH06_Collections</strong> project, add a new folder called <strong class="source-inline">ConcreteVsInterface</strong>.</li>
				<li>In the <strong class="source-inline">ConcreteVsInterface</strong> folder, add the <strong class="source-inline">ITax</strong> interface:<p class="source-code">internal interface ITax</p><p class="source-code">{</p><p class="source-code">      int Id { get; set; }</p><p class="source-code">      TaxType TaxType { get; set; }</p><p class="source-code">      TaxRate TaxRate { get; set; }</p><p class="source-code">      decimal LowerLimit { get; set; }</p><p class="source-code">      decimal UpperLimit { get; set; }</p><p class="source-code">      decimal Percentage { get; set; }</p><p class="source-code">      decimal Calculate(decimal amount);</p><p class="source-code">}</p></li>
			</ol>
			<p>This interface defines<a id="_idIndexMarker664"/> a contract that various concrete tax classes will have to adhere to. It enforces impact analysis since a change in this interface will be felt by all the classes that implement it.</p>
			<ol>
				<li value="3">Next, add the <strong class="source-inline">BaseTax</strong> class:<p class="source-code">internal abstract class BaseTax : ITax</p><p class="source-code">{</p><p class="source-code">    public int Id { get; set; }</p><p class="source-code">    public TaxType TaxType { get; set; }</p><p class="source-code">    public TaxRate TaxRate { get; set; }</p><p class="source-code">    public decimal LowerLimit { get; set; }</p><p class="source-code">    public decimal UpperLimit { get; set; }</p><p class="source-code">    public decimal Percentage { get; set; }</p><p class="source-code">    public abstract decimal Calculate(decimal amount);</p><p class="source-code">}</p></li>
			</ol>
			<p>This abstract class implements the <strong class="source-inline">ITax</strong> interface but marks <strong class="source-inline">Calculate(decimal amount)</strong> as abstract so that its implementation is left up to the subclasses. </p>
			<ol>
				<li value="4">Now, add<a id="_idIndexMarker665"/> the <strong class="source-inline">TaxRate</strong> enum:<p class="source-code">using System;</p><p class="source-code">[Flags]</p><p class="source-code">internal enum TaxRate</p><p class="source-code">{</p><p class="source-code">    TaxFreePersonalAllowance,</p><p class="source-code">    StarterRate,</p><p class="source-code">    BasicRate,</p><p class="source-code">    IntermediateRate,</p><p class="source-code">    HigherRate,</p><p class="source-code">    AdditionalRate</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">TaxRate</strong> enum provides the different types of tax rates for UK income tax. </p>
			<ol>
				<li value="5">Add the <strong class="source-inline">TaxtType</strong> enum:<p class="source-code">[Flags]</p><p class="source-code">internal enum TaxType</p><p class="source-code">{</p><p class="source-code">    CorporationTax,</p><p class="source-code">    ValueAddedTax,</p><p class="source-code">    IncomeTax,</p><p class="source-code">    NationInsuranceContributions,</p><p class="source-code">    ExciseDuties,</p><p class="source-code">    RoadTax,</p><p class="source-code">    StampDuty</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">TaxType</strong> interface provides the different kinds of UK taxes. Add the <strong class="source-inline">BaseRate</strong> class. This class<a id="_idIndexMarker666"/> will inherit from the <strong class="source-inline">BaseTax</strong> class. </p>
			<ol>
				<li value="6">Then, add the following constructor:<p class="source-code">public BasicRate()</p><p class="source-code">{</p><p class="source-code">    this.LowerLimit = 14550M;</p><p class="source-code">    this.UpperLimit = 24944M;</p><p class="source-code">    this.TaxType = TaxType.IncomeTax;</p><p class="source-code">    this.TaxRate = TaxRate.BasicRate;</p><p class="source-code">    this.Percentage = 0.2M;</p><p class="source-code">}</p></li>
			</ol>
			<p>This constructor sets the properties contained within <strong class="source-inline">BaseClass</strong> to the values applicable to basic rate income tax. </p>
			<ol>
				<li value="7">Now, implement the <strong class="source-inline">Calculate(decimal amount)</strong> method:<p class="source-code">public override decimal Calculate(decimal amount)</p><p class="source-code">{</p><p class="source-code">      if (Percentage &gt; 1)</p><p class="source-code">            throw new Exception("Invalid percentage. </p><p class="source-code">                Percentage must be between 0 and 1.");</p><p class="source-code">if (amount &lt; LowerLimit &amp; amount &gt; UpperLimit)</p><p class="source-code">    return 0;</p><p class="source-code">return Percentage * amount;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method checks if the percentage is less than one and throws an exception if it is not. The lower<a id="_idIndexMarker667"/> and upper amounts a person earns that are taxed are checked. If the amount is outside of this range, then zero is returned. The amount of tax on earnings is then returned and the method exits.</p>
			<ol>
				<li value="8">Add a new class called <strong class="source-inline">TaxMan</strong>:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Engines;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using CH06_Collections.Linq;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Threading;</p><p class="source-code">[MemoryDiagnoser]</p><p class="source-code">[Orderer(SummaryOrderPolicy.FastestToSlowest)]</p><p class="source-code">[RankColumn]</p><p class="source-code">public class TaxMan { }</p></li>
			</ol>
			<p>Our class is now configured to perform benchmarking using <strong class="source-inline">BenchmarkDotNet</strong>. </p>
			<ol>
				<li value="9">Add the following method:<p class="source-code">[Benchmark]</p><p class="source-code">public void BasicRateInterface()</p><p class="source-code">{</p><p class="source-code">      IList&lt;BasicRate&gt; basicRate = new </p><p class="source-code">          List&lt;BasicRate&gt;();</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">BasicRateInterface()</strong> method<a id="_idIndexMarker668"/> declares a list of <strong class="source-inline">BasicRate</strong> objects using the <strong class="source-inline">IList</strong> interface. </p>
			<ol>
				<li value="10">Add the <strong class="source-inline">BasicRateConcrete()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void BasicRateConcrete()</p><p class="source-code">{</p><p class="source-code">      List&lt;BasicRate&gt; basicRate = new </p><p class="source-code">          List&lt;BasicRate&gt;();</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">BasicRateConcrete()</strong> method declares a list of <strong class="source-inline">BasicRate</strong> objects using the concrete <strong class="source-inline">List</strong> class.</p>
			<ol>
				<li value="11">In the <strong class="source-inline">Program</strong> class, comment out the code in the <strong class="source-inline">Main</strong> method and add the following line of code:<p class="source-code">BenchmarkRunner.Run&lt;TaxMan&gt;();</p></li>
			</ol>
			<p>This line of code will run our benchmarks. Do a release build, and then run the executable from the command line. You should see the following output or similar:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B16617_Figure_6.3.jpg" alt="Figure 6.3 – The BenchmarkDotNet summary report showing the time difference between assigning IList&lt;T&gt; and List&lt;T&gt;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The BenchmarkDotNet summary report showing the time difference between assigning IList&lt;T&gt; and List&lt;T&gt;</p>
			<p>As we can see from the report, memory<a id="_idIndexMarker669"/> utilization is the same for both the interface and the concrete class implementations. But the faster instantiation time is obtained by assigning <strong class="source-inline">IList&lt;T&gt;</strong> instead of <strong class="source-inline">List&lt;T&gt;</strong>. Although the value will not be noticeable to the naked eye, it will become more noticeable over some time if there are a large number of assignments, such as when a large data iteration is taking place.</p>
			<p>Now, let's look at array and collection performance.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>Deciding between using arrays or collections</h1>
			<p>In this section, we'll discuss<a id="_idIndexMarker670"/> the pros and cons of using arrays and collections. We will also perform various benchmarks that measure array and collection performance. Armed with benchmark information, you can then make informed decisions as to whether arrays or collections are best suited to your specific needs. We will start by looking at arrays.</p>
			<p>The downsides to using arrays<a id="_idIndexMarker671"/> are as follows:</p>
			<ul>
				<li>Arrays are fixed in size, meaning that once the size of the array has been changed, its size cannot be changed.</li>
				<li>Since arrays are fixed in size, they are not recommended for efficient memory usage.</li>
				<li>Arrays can only hold heterogeneous data types, and data types can be primitive and object types.</li>
				<li>Data elements of the <strong class="source-inline">object</strong> type can hold different types of data elements. </li>
				<li>Arrays lack many useful<a id="_idIndexMarker672"/> methods.</li>
			</ul>
			<p>The benefits of using<a id="_idIndexMarker673"/> arrays are as follows:</p>
			<ul>
				<li>Arrays have a small memory footprint and have undergone some serious performance improvements in C# 9.0 and .NET 5.</li>
				<li>However, as arrays are fast and have undergone speed improvements, they are recommended when performance matters. </li>
			</ul>
			<p>The downside to using collections<a id="_idIndexMarker674"/> is as follows:</p>
			<ul>
				<li>When it comes to performance, they are not recommended over arrays.</li>
			</ul>
			<p>The benefits of using arrays<a id="_idIndexMarker675"/> are as follows:</p>
			<ul>
				<li>Collections effectively wrap arrays; <strong class="source-inline">generic List&lt;T&gt;</strong> is a good example.</li>
				<li>They are growable, which<a id="_idIndexMarker676"/> means that we can shrink and grow our collections as required. Because of this, collections are recommended over arrays when it comes to efficient memory utilization.</li>
				<li>Data elements (item data) in a collection can be homogeneous and heterogeneous.</li>
				<li>Collection classes have ready-made method support for most operations and can easily be extended. By this, we mean that arrays lack some useful methods that we get for free when we use collections.<p class="callout-heading">Note</p><p class="callout">It is recommended that you do not use the collections in the <strong class="source-inline">System.Collections</strong> namespace. Instead, you are encouraged to use the collections in the <strong class="source-inline">System.Collections.Generic</strong> namespaces.</p></li>
			</ul>
			<p>The standard collection that most programmers will be familiar with is the generic <strong class="source-inline">List&lt;T&gt;</strong> class. In this section, we will create a new project. Then, we will build up a <strong class="source-inline">uint</strong> array and a <strong class="source-inline">List&lt;uint&gt;</strong> collection and iterate through them. This process will be benchmarked using <strong class="source-inline">BenchmarkDotNet</strong>.</p>
			<p>We will be benchmarking adding items, iterating through, and retrieving items from arrays and collections. So, let's begin:</p>
			<ol>
				<li value="1">Add a new class under<a id="_idIndexMarker677"/> the project root called <strong class="source-inline">ArraysVsCollections</strong> with the following <strong class="source-inline">using</strong> statements:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p></li>
			</ol>
			<p>These <strong class="source-inline">using</strong> statements give us what we need to work with arrays and collections and benchmark them. </p>
			<ol>
				<li value="2">Add the following member variables:<p class="source-code">private int[] array;</p><p class="source-code">private List&lt;int&gt; collection;</p></li>
			</ol>
			<p>The array of <strong class="source-inline">int</strong> and the list of <strong class="source-inline">int</strong> will be used to benchmark adding, getting, and iterating arrays and collections. </p>
			<ol>
				<li value="3">Next, add the <strong class="source-inline">GlobalSetup()</strong> method:<p class="source-code">[GlobalSetup]</p><p class="source-code">public void GlobalSetup()</p><p class="source-code">{</p><p class="source-code">array = new int[1000];</p><p class="source-code">collection = new List&lt;int&gt;(1000);</p><p class="source-code">for (int i = 0; i &lt; 1000; i++)</p><p class="source-code">{</p><p class="source-code">    array[i] = i;</p><p class="source-code">    collection.Add(i);</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">GlobalSetup()</strong> method is attributed to the <strong class="source-inline">[GlobalSetup]</strong> attribute. This informs <strong class="source-inline">BenchmarkDotNet</strong> to run this method before all other benchmark methods. It initializes<a id="_idIndexMarker678"/> the array and collection with a size of <strong class="source-inline">1000</strong> and adds a value of <strong class="source-inline">i</strong> in the current iteration to both the array and collection. </p>
			<ol>
				<li value="4">Although we will not be utilizing the <strong class="source-inline">GlobalCleanup()</strong> method, we will add it for completeness so that you know how to perform cleanup operations when benchmarking:<p class="source-code">[GlobalCleanup]</p><p class="source-code">public void GlobalCleanup()</p><p class="source-code">{</p><p class="source-code">// Disposing logic</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">GlobalCleanup()</strong> method is where you would provide your cleanup logic if it were needed. </p>
			<ol>
				<li value="5">Now, add the <strong class="source-inline">ArrayAdd1000Logic()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void ArrayAdd1000Logic1()</p><p class="source-code">{</p><p class="source-code">int[] list = new int[1000];</p><p class="source-code">for (int i = 0; i &lt; 1000; i++)</p><p class="source-code">{</p><p class="source-code">    list[i] = i;</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ArrayAdd1000Logic()</strong> method declares<a id="_idIndexMarker679"/> an array of 1000 <strong class="source-inline">int</strong> values and later proceeds to add integer values to each element in the array. </p>
			<ol>
				<li value="6">Add the <strong class="source-inline">CollectionAdd1000Logic()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void CollectionAdd1000Logic()</p><p class="source-code">{</p><p class="source-code">Ilist&lt;int&gt; list = new new List&lt;int&gt;();</p><p class="source-code">for (int i = 0; i &lt; 1000; i++)</p><p class="source-code">      list.Add(i)</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">CollectionAdd1000Logic ()</strong> method declares a list of <strong class="source-inline">int</strong> elements. Then, it loops 1,000 times using a <strong class="source-inline">for</strong> loop and adds the current value to the collection. </p>
			<ol>
				<li value="7">Add the <strong class="source-inline">ArrayIterationLogic()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public int ArrayIterationLogic()</p><p class="source-code">{</p><p class="source-code">int res = 0;</p><p class="source-code">for (int i = 0; i &lt; 1000; i++)</p><p class="source-code">    res += array[i];</p><p class="source-code">return res;</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ArrayIterationLogic()</strong> method<a id="_idIndexMarker680"/> declares an <strong class="source-inline">int</strong> variable and assigns it a value of <strong class="source-inline">0</strong>. A <strong class="source-inline">for</strong> loop is used to iterate 1,000 times and add the value of the array at the index position to the <strong class="source-inline">res</strong> value. Once the iteration is over, the <strong class="source-inline">res</strong> variable is returned. </p>
			<ol>
				<li value="8">Now, add the <strong class="source-inline">CollectionIterationLogic()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public int CollectionIterationLogic()</p><p class="source-code">{</p><p class="source-code">int res = 0;</p><p class="source-code">for (int i = 0; i &lt; 1000; i++)</p><p class="source-code">    res += collection[i];</p><p class="source-code">return res;</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">CollectionIterationLogic()</strong> declares an <strong class="source-inline">int</strong> variable and assigns it a value of <strong class="source-inline">0</strong>. A <strong class="source-inline">for</strong> loop is used to iterate 1,000 times and add the value of the array at the index position to the <strong class="source-inline">res</strong> value. Once the iteration is over, the <strong class="source-inline">res</strong> variable is returned.</p>
			<ol>
				<li value="9">Add the <strong class="source-inline">ArrayGetElement500Logic()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public int ArrayGetElement500Logic()</p><p class="source-code">{</p><p class="source-code">return array[500];</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ArrayGetElement500Logic()</strong> method<a id="_idIndexMarker681"/> returns the value of the array at position <strong class="source-inline">500</strong>. </p>
			<ol>
				<li value="10">Now, add the <strong class="source-inline">CollectionGetElement500Logic()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public int CollectionGetElement500Logic()</p><p class="source-code">{</p><p class="source-code">return collection[500];</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">CollectionGetElement500Logic()</strong> method returns the value of the collection at position <strong class="source-inline">500</strong>. </p>
			<ol>
				<li value="11">Replace the code in the <strong class="source-inline">Main</strong> method with the following line of code:<p class="source-code">BenchmarkRunner.Run&lt;ArraysVsCollections&gt;();</p></li>
			</ol>
			<p>This call will run our benchmarks. Release build your code and run it from the console. You should see a report with similar timings to those shown in the following screenshot:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B16617_Figure_6.4.jpg" alt="Figure 6.4 – The BenchmarkDotNet summary report for array and collection operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The BenchmarkDotNet summary report for array and collection operations</p>
			<p>Looking at the performance<a id="_idIndexMarker682"/> in terms of time, adding items to an array is faster than adding items to a collection. Iterating a collection is faster than iterating over an array and getting an item from an array using its index is faster than getting a collection from a collection by its index. Based on these findings, you need to decide what your requirements are, and then choose the best type based on these requirements. </p>
			<p>Now, let's look at indexers.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Accessing objects using indexers</h1>
			<p>Indexes enable objects<a id="_idIndexMarker683"/> in classes to be accessed in the same way you access items<a id="_idIndexMarker684"/> in an array. An indexer will have a modifier, a return type, the <strong class="source-inline">this</strong> keyword to indicate the object of the current class, and an argument list. You will always use the <strong class="source-inline">this</strong> keyword when creating an indexer. Indexer is the term given to a parameterized property. The index is created using the <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> accessors. You are not allowed to use the <strong class="source-inline">ref</strong> or <strong class="source-inline">out</strong> keywords to modify indexer parameters. A minimum of one parameter should be specified. An indexer cannot be static since it is an instance member. However, the indexer properties can be static. You would implement an indexer if you need to operate on a group of elements. The main difference between a property and an indexer is that you identify and access a property by its name. On the other hand, with an indexer, it is identified by its signature and accessed using indexes. Moreover, you can overload indexers.</p>
			<p>Now, let's write a simple indexer<a id="_idIndexMarker685"/> example. In this example, we will have a class<a id="_idIndexMarker686"/> that has a constructor that takes a size. This size will set the size of an internal array of strings. We will be able to get the index of a string in the array by name and get an item from the array by index using indexers. Follow these steps:</p>
			<ol>
				<li value="1">Add a new class called <strong class="source-inline">Indexers</strong> and add a <strong class="source-inline">using</strong> statement to <strong class="source-inline">System namespace</strong>. Then, add the following array and constructor at the top of the class:<p class="source-code">private string[] _items;</p><p class="source-code">public Indexers(int size)</p><p class="source-code">{</p><p class="source-code">      _items = new string[size];</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">_items</strong> array will contain several strings. The size of the array is set by the value that's passed into the constructor that initializes the array. </p>
			<ol>
				<li value="2">Add the indexer to get a string by index:<p class="source-code">public string this[int index]</p><p class="source-code">{</p><p class="source-code">  get</p><p class="source-code">{</p><p class="source-code">    if (IsValidIndex(index))</p><p class="source-code">        return _items[index];</p><p class="source-code">    else</p><p class="source-code">        return string.Empty;</p><p class="source-code">}</p><p class="source-code">  set</p><p class="source-code">{</p><p class="source-code">    if (IsValidIndex(index))</p><p class="source-code">        _items[index] = value;</p><p class="source-code">}</p><p class="source-code">} </p></li>
			</ol>
			<p>This indexer uses an <strong class="source-inline">int</strong> value to get an item from the array and set the value of the array at the given<a id="_idIndexMarker687"/> index. Items are only set and retrieved<a id="_idIndexMarker688"/> if the index is valid.</p>
			<ol>
				<li value="3">We can check the index by passing it into the <strong class="source-inline">IsValidIndex(int index)</strong> method, which returns a <strong class="source-inline">bool</strong>. Let's add the <strong class="source-inline">IsValidIndex(int index)</strong> method:<p class="source-code">private bool IsValidIndex(int index)</p><p class="source-code">{</p><p class="source-code">    return index &gt; -1 &amp;&amp; index &lt; _items.Length;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method returns <strong class="source-inline">true</strong> if the index is greater than -1 and less than the length of the array. Otherwise, it returns <strong class="source-inline">false</strong>. </p>
			<ol>
				<li value="4">Now, add the index that takes a <strong class="source-inline">string</strong> and returns the string's index:<p class="source-code">public int this[string item]</p><p class="source-code">{</p><p class="source-code">  get</p><p class="source-code">{</p><p class="source-code">    return Array.IndexOf(_items, item);</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This indexer takes a <strong class="source-inline">string</strong>. Then, it looks up the index for the string<a id="_idIndexMarker689"/> and returns the index. There<a id="_idIndexMarker690"/> is no setter for this index. </p>
			<ol>
				<li value="5">In the <strong class="source-inline">Program</strong> class, add the <strong class="source-inline">IndexerExample()</strong> method:<p class="source-code">public static void IndexerExample()</p><p class="source-code">{</p><p class="source-code">      Indexers indexers = new Indexers(1000);</p><p class="source-code">      for (int i = 0; i &lt; 1000; i++)</p><p class="source-code">            indexers[i] = $"Item {i}";</p><p class="source-code">Console.WriteLine($"The item at position 500 is </p><p class="source-code">     \"{indexers[500]}\".");</p><p class="source-code">Console.WriteLine($"The index of \"Item 500\" is </p><p class="source-code">     {indexers["Item 500"]}.");</p><p class="source-code">}</p></li>
			</ol>
			<p>This method creates a new <strong class="source-inline">Indexer</strong> object with an internal array size of <strong class="source-inline">1000</strong>. Then, it loops 1,000 times and sets the value of each item in the array. After that, it prints out the value of the array at position 500 and prints out the value of <strong class="source-inline">Item 500</strong>. </p>
			<ol>
				<li value="6">Comment out the code in the <strong class="source-inline">Main</strong> method, and then add the following line:<p class="source-code">IndexerExample();</p></li>
			</ol>
			<p>This statement calls the method that executes our <strong class="source-inline">Indexer</strong> method. You should see the following output:</p>
			<p class="source-code"><strong class="bold">The item at position 500 is "Item 500".</strong></p>
			<p class="source-code"><strong class="bold">The index of "Item 500" is 500.</strong></p>
			<p>That concludes our look at indexers. As you can see, they are pretty simple. You can use any data item that you like for an indexer. However, it will be up to you to see how well such indexers<a id="_idIndexMarker691"/> perform. Now, let's look<a id="_idIndexMarker692"/> at the difference between the <strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">IEnumerator</strong> interfaces.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor131"/>Comparing IEnumerable and IEnumerator</h1>
			<p>The <strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">IEnumerator</strong> interfaces can both<a id="_idIndexMarker693"/> be used for iteration but in different ways. Let's understand each in brief.</p>
			<p>An object of the <strong class="source-inline">IEnumerable</strong> type will know how to traverse the collection that it holds, regardless of what its internal structure is like. There is one method that makes up an enumerable: <strong class="source-inline">GetEnumerator()</strong>. It returns as an instance of a class that implements the <strong class="source-inline">IEnumerable</strong> interface. Iteration is normally carried out using a <strong class="source-inline">foreach</strong> loop. Iterations of an enumerable are carried out using a <strong class="source-inline">foreach</strong> loop. However, an enumerable does not remember its location when iterating.</p>
			<p>Objects of the <strong class="source-inline">Ienumerator</strong> type declare two methods: <strong class="source-inline">MoveNext()</strong> and <strong class="source-inline">Reset()</strong>. There is one property called <strong class="source-inline">Current</strong> that gets the current item in the list that's being enumerated. The <strong class="source-inline">MoveNext()</strong> method moves to the next record in a collection and returns a Boolean value indicating the end of the collection. <strong class="source-inline">Reset()</strong> will reset the position to the first item in the collection. The <strong class="source-inline">Current</strong> property is called through an object that implements the <strong class="source-inline">IEnumerable</strong> interface, which returns the current element in the collection. An enumerator remembers its current location and uses a <strong class="source-inline">while</strong> loop when iterating.</p>
			<p>Let's see which method of enumeration is fastest. Will it be looping using an enumerable, or will it be looping using an iterator?</p>
			<ol>
				<li value="1">Add a new class called <strong class="source-inline">IEnumerableVsIEnumerable</strong> with the following <strong class="source-inline">using</strong> statements:<p class="source-code">    using BenchmarkDotNet.Attributes;</p><p class="source-code">    using BenchmarkDotNet.Running;</p><p class="source-code">    using System;</p><p class="source-code">    using System.Collections;</p><p class="source-code">    using System.Collections.Generic;</p><p class="source-code">    using System.Diagnostics;</p></li>
			</ol>
			<p>These <strong class="source-inline">using</strong> statements provide the elements we will need to build and test the performance between <strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">IEnumerator</strong>. </p>
			<ol>
				<li value="2">Add the following<a id="_idIndexMarker694"/> code to the class:<p class="source-code">private List&lt;int&gt; _years;</p><p class="source-code">public IEnumerableVsIEnumerator()</p><p class="source-code">{</p><p class="source-code">  _years = new List&lt;int&gt; { 1970, 1971, 1972, 1973, 1974, </p><p class="source-code">      1975, 1976, 1977, 1978, 1979 };</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are declaring a list of <strong class="source-inline">int</strong> values that will hold several year values. Our constructor then initializes the array with the years <strong class="source-inline">1970</strong> to <strong class="source-inline">1979</strong>. </p>
			<ol>
				<li value="3">Add the <strong class="source-inline">IterateEnumerator1970to1975()</strong> method:<p class="source-code">public void IterateEnumerator1970To1975()</p><p class="source-code">{</p><p class="source-code">  var years = _years.GetEnumerator();</p><p class="source-code">  while (years.MoveNext())</p><p class="source-code">{</p><p class="source-code">    Debug.WriteLine(years.Current);</p><p class="source-code">    if (years.Current &gt; 1975)</p><p class="source-code">        IterateEnumberator1976To1979(years);</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This method iterates over the values <strong class="source-inline">1970</strong> to <strong class="source-inline">1975</strong> and prints the values out to the debug window. </p>
			<ol>
				<li value="4">If the current year<a id="_idIndexMarker695"/> is greater than <strong class="source-inline">1975</strong>, then the enumerator is passed into the <strong class="source-inline">IterateEnumerator1976To1979(IEnumerator&lt;int&gt; years)</strong> method, which we will add now:<p class="source-code">public void IterateEnumberator1976To1979</p><p class="source-code">    (IEnumerator&lt;int&gt; years)</p><p class="source-code">{</p><p class="source-code">while (years.MoveNext())</p><p class="source-code">{</p><p class="source-code">    Debug.WriteLine(years.Current);</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes in an enumerator and iterates through it. On each iteration, it prints the current year to the debug window. </p>
			<ol>
				<li value="5">Add the following line to the end of the <strong class="source-inline">Main</strong> method in the <strong class="source-inline">Program</strong> class:<p class="source-code">IEnumerableVsIEnumeratorExample();</p></li>
			</ol>
			<p>This line of code calls a method that will run our example and show how an enumerator remembers where it is in the iteration. </p>
			<ol>
				<li value="6">Add the <strong class="source-inline">IEnumerableVsIEnumeratorExample()</strong> method to the <strong class="source-inline">Program</strong> class:<p class="source-code">private static void IEnumerableVsIEnumeratorExample()</p><p class="source-code">{</p><p class="source-code">  IEnumerableVsIEnumerator eve = new </p><p class="source-code">    IEnumerableVsIEnumerator();</p><p class="source-code">  eve.IterateEnumerator1970To1975();</p><p class="source-code">}</p></li>
			</ol>
			<p>This method runs our code. If you do a debug build and run the code, then you should see the years <em class="italic">1970</em> to <em class="italic">1979</em> printed to the output window. </p>
			<p>Now that you have seen an enumerator<a id="_idIndexMarker696"/> in action, we will add two methods to the <strong class="source-inline">IEnumerableVsIEnumerator</strong> class. </p>
			<ol>
				<li value="7">Add the <strong class="source-inline">BenchmarkIEnumerabled()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void BenchmarkIEnumerable()</p><p class="source-code">{</p><p class="source-code">  IEnumerable&lt;int&gt; enumerable = IEnumerable&lt;int&gt;)_years;</p><p class="source-code">  foreach (int i in enumerable)</p><p class="source-code">      Debug.WriteLine(i);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method uses an enumerable and a <strong class="source-inline">foreach</strong> loop to iterate through the years and write them to the debug window. </p>
			<ol>
				<li value="8">Add the <strong class="source-inline">BenchmarkIEnumerator()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void BenchmarkIEnumerator()</p><p class="source-code">{</p><p class="source-code">  IEnumerator&lt;int&gt; enumerator = _years.GetEnumerator();</p><p class="source-code">  while (enumerator.MoveNext())</p><p class="source-code">      Debug.WriteLine(enumerator.Current);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method uses an enumerator and a <strong class="source-inline">while</strong> loop to iterate through the years and write them to the debug window. </p>
			<ol>
				<li value="9">Comment out the code<a id="_idIndexMarker697"/> in the <strong class="source-inline">Main</strong> method in the <strong class="source-inline">Program</strong> class, and then add the following line:<p class="source-code">BenchmarkRunner.Run&lt;IEnumerableVsIEnumerator&gt;();</p></li>
			</ol>
			<p>This line of code detects our benchmarks and runs them to produce a summary report on performance. Do a release build and run the program from the command prompt. You should see the following output:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B16617_Figure_6.5.jpg" alt="Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator &#13;&#10;is faster than IEnumerable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator is faster than IEnumerable</p>
			<p>As we can see, even though <strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">IEnumerator</strong> both perform iterations on the same collection, they do so in different ways. And by viewing the benchmarking summary report, we can see that the clear winner in terms of performance is the <strong class="source-inline">IEnumerator</strong> interface. Now, let's look at the difference between <strong class="source-inline">IEnumerable</strong>, <strong class="source-inline">IEnumerator</strong>, and <strong class="source-inline">IQueryable</strong>, and the effects<a id="_idIndexMarker698"/> these differences have on performance when performing LINQ queries on a database.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor132"/>Database query performance</h1>
			<p>In the previous section, we saw how <strong class="source-inline">IEnumerator</strong> is different from and performs faster than <strong class="source-inline">IEnumerable</strong> when iterating through an in-memory collection. Now, let's query a database<a id="_idIndexMarker699"/> and iterate through the resulting collection using various benchmarked techniques. To do so, we'll follow these steps:</p>
			<ol>
				<li value="1">Add a new class called <strong class="source-inline">IEnumeratorVsIQueryable</strong>.</li>
				<li>We will be connecting to a SQL Server database, and we will have information we need to keep secret. Our <strong class="source-inline">secret.json</strong> files do not get checked into version control. So, right-click on the project and select <strong class="bold">Manage User Secrets</strong> from the context menu.</li>
				<li>A dialog box will pop up, informing you that additional packages are required. Click on <strong class="bold">Yes</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B16617_Figure_6.6.jpg" alt="Figure 6.6 – A dialog box, informing you that additional packages are required to manage user secrets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – A dialog box, informing you that additional packages are required to manage user secrets</p>
			<ol>
				<li value="4">Visual Studio will then open the <strong class="source-inline">secrets.json</strong> file in a new tab. This is where you will add your user secrets.</li>
				<li>Open the Package Manager Console and add the following packages:<ul><li><strong class="source-inline">Microsoft.EntityFrameworkCore</strong></li><li><strong class="source-inline">Microsoft.EntityFrameworkCore.SqlServer</strong></li><li><strong class="source-inline">Microsoft.EntityFrameworkCore.Tools</strong></li><li><strong class="source-inline">Microsoft.Extensions.Configuration</strong></li><li><strong class="source-inline">Microsoft.Extensions.Configuration.EnvironmentVariables</strong></li><li><strong class="source-inline">Microsoft.Extensions.Configuration.UserSecrets</strong></li><li><strong class="source-inline">Microsoft.Extensions.OptionsConfigurationExtensions</strong></li></ul></li>
			</ol>
			<p>These packages<a id="_idIndexMarker700"/> allow you to connect to and extract data from our SQL Server database. </p>
			<ol>
				<li value="6">Update your <strong class="source-inline">secrets.json</strong> file with the connection string to the database that we created at the start of this chapter:<p class="source-code">{</p><p class="source-code">  "DatabaseSettings": {</p><p class="source-code">    "ConnectionString": "YOUR_CONNECTION_STRING"</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This connection string will be used to connect to our database, perform a query that returns some data, and allow us to iterate through that data and perform some operations on it. </p>
			<ol>
				<li value="7">Add a folder called <strong class="source-inline">Configuration</strong>. In that folder, add a class called <strong class="source-inline">SecretsManager</strong> with an empty static constructor and the following <strong class="source-inline">using</strong> statements:<p class="source-code">using Microsoft.Extensions.Configuration;</p><p class="source-code">using System;</p><p class="source-code">using System.IO;</p></li>
			</ol>
			<p>We need these <strong class="source-inline">using</strong> statements for our file I/O and system configuration, such as obtaining secrets from a <strong class="source-inline">secrets.json</strong> file. </p>
			<ol>
				<li value="8">Add the following line<a id="_idIndexMarker701"/> at the top of the <strong class="source-inline">SecretsManager</strong> class:<p class="source-code">public static IConfigurationRoot Configuration { get; </p><p class="source-code">    set; }</p></li>
			</ol>
			<p>This line declares our static configuration property, which is used to obtain the configuration data within our application. </p>
			<ol>
				<li value="9">Now, add the following code:<p class="source-code">public static T GetSecrets&lt;T&gt;(string sectionName) </p><p class="source-code">    where T : class</p><p class="source-code">{</p><p class="source-code">var devEnvironmentVariable = Environment</p><p class="source-code">    .GetEnvironmentVariable("NETCORE_ENVIRONMENT");</p><p class="source-code">var isDevelopment = string.IsNullOrEmpty</p><p class="source-code">    (devEnvironmentVariable) || devEnvironmentVariable</p><p class="source-code">        .ToLower() == "development";</p><p class="source-code">var builder = new ConfigurationBuilder()    </p><p class="source-code">    .SetBasePath(Directory.GetCurrentDirectory())</p><p class="source-code">.AddJsonFile("appsettings.json", optional: true, </p><p class="source-code">    reloadOnChange: true)</p><p class="source-code">.AddEnvironmentVariables();</p><p class="source-code">if (isDevelopment) //only add secrets in development</p><p class="source-code">{</p><p class="source-code">    builder.AddUserSecrets&lt;T&gt;();</p><p class="source-code">}</p><p class="source-code">Configuration = builder.Build();</p><p class="source-code">return Configuration.GetSection(sectionName).Get&lt;T&gt;();</p><p class="source-code">}</p></li>
			</ol>
			<p>This code gets the environment<a id="_idIndexMarker702"/> variables for the .NET Core environment. Then, it gets the code to see if it is running in a software development environment. The configuration is built for the environment it will be running in. If we are in development, then we must add our <strong class="source-inline">secrets</strong> class as defined by the <strong class="source-inline">T</strong> variable. Switch to the <strong class="source-inline">Product</strong> class in the <strong class="source-inline">Models</strong> folder.</p>
			<ol>
				<li value="10">Add a <strong class="source-inline">using</strong> statement for <strong class="source-inline">System.ComponentModel.DataAnnotations</strong>. Change the struct to a class, and add the <strong class="source-inline">[Key]</strong> attribute to the <strong class="source-inline">Id</strong> property. We need these changes since we are using Entity Framework to connect to a database and extract data.</li>
				<li>Add the <strong class="source-inline">DatabaseSettings</strong> class to the <strong class="source-inline">Configuration</strong> folder:<p class="source-code">public class DatabaseSettings</p><p class="source-code">{</p><p class="source-code">    public string ConnectionString { get; set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class has a single property called <strong class="source-inline">ConnectionString</strong> that will hold our connection string to our <strong class="source-inline">SampleData</strong> database. Notice that the name of the class and property match the name of the JSON section and property! </p>
			<ol>
				<li value="12">Now, add <strong class="source-inline">appsettings.json</strong> to the root of your project with the following contents:<p class="source-code">{</p><p class="source-code">  "DatabaseSettings": {</p><p class="source-code">    "ConnectionString": "Set in Azure. For </p><p class="source-code">        development, set in User Secrets"</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This file contains the same layout as the <strong class="source-inline">secrets.json</strong> file and the <strong class="source-inline">DatabaseSettings</strong> class. This file is used to store our connection string. In development, it is set in our <strong class="source-inline">secrets</strong> file, while in production, it is set in Azure. Now that we have our database configuration in place, we can add our benchmarking code.</p>
			<ol>
				<li value="13">Add a new class<a id="_idIndexMarker703"/> to the root of the project called <strong class="source-inline">DatabaseQueryAndIteration</strong> that implements <strong class="source-inline">IDisposable</strong> with the following code:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using CH06_Collections.Configuration;</p><p class="source-code">using CH06_Collections.Data;</p><p class="source-code">using CH06_Collections.Models;</p><p class="source-code">using Microsoft.Extensions.Options;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Diagnostics;</p><p class="source-code">using System.Linq;</p><p class="source-code">[MemoryDiagnoser]</p><p class="source-code">[Orderer(SummaryOrderPolicy.Declared)]</p><p class="source-code">[RankColumn]</p><p class="source-code">public class DatabaseQueryAndIteration : IDisposable </p><p class="source-code">{</p><p class="source-code">}</p></li>
			</ol>
			<p>This code declares our class and defines the fact that it implements <strong class="source-inline">IDisposable</strong>. It is also configured to be benchmarked.</p>
			<ol>
				<li value="14">Implement the <strong class="source-inline">IDisposable</strong> interface<a id="_idIndexMarker704"/> in our class:<p class="source-code">private bool disposedValue;</p><p class="source-code">protected virtual void Dispose(bool disposing)</p><p class="source-code">{</p><p class="source-code">    if (!disposedValue) {</p><p class="source-code">        if (disposing)</p><p class="source-code">            _context.Dispose();</p><p class="source-code">        disposedValue = true;</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">public void Dispose(){</p><p class="source-code">    Dispose(disposing: true);</p><p class="source-code">    GC.SuppressFinalize(this);</p><p class="source-code">}</p></li>
			</ol>
			<p>This code disposes of our managed resources and suppresses the call to the class finalizer method.</p>
			<ol>
				<li value="15">We have everything in place to benchmark the methods in this class, access database resources, and clean up after ourselves. Add the following code to the class:<p class="source-code">private DatabaseContext _context;</p><p class="source-code">[GlobalSetup]</p><p class="source-code">public void GlobalSetup()</p><p class="source-code">{</p><p class="source-code">    var connectionString = SecretsManager.</p><p class="source-code">        GetSecrets&lt;DatabaseSettings&gt;(nameof</p><p class="source-code">          (DatabaseSettings)).ConnectionString;</p><p class="source-code">_context = new DatabaseContext(connectionString);</p><p class="source-code">}</p><p class="source-code">[GlobalCleanup]</p><p class="source-code">public void GlobalCleanup()</p><p class="source-code">{</p><p class="source-code">        Dispose(true);</p><p class="source-code">}</p></li>
			</ol>
			<p>The _<strong class="source-inline">context</strong> variable provides<a id="_idIndexMarker705"/> us with our database access. The <strong class="source-inline">GlobalSetup()</strong> method gets our connection string from our secrets file and creates a new <strong class="source-inline">DatabaseContext</strong> using the safely stored connection string. The <strong class="source-inline">GlobalSetup()</strong> method will run before our benchmarks. The <strong class="source-inline">GlobalCleanup()</strong> method calls the <strong class="source-inline">Dispose(disposing)</strong> method to clean up our managed resources after our benchmarks have finished running.</p>
			<ol>
				<li value="16">Next, add the <strong class="source-inline">QueryDb()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDb()</p><p class="source-code">{</p><p class="source-code">    var products = (from p in _context.Products</p><p class="source-code">                    where p.Id &gt; 1 select p);</p><p class="source-code">foreach (var product in products)</p><p class="source-code">    Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">QueryDb()</strong> method performs<a id="_idIndexMarker706"/> a simple LINQ query on the database by selecting products with an ID that's greater than <strong class="source-inline">1</strong>. Then, it iterates each product in the <strong class="source-inline">lQueryable&lt;Product&gt;</strong> list and writes the product name out to the debug window. </p>
			<ol>
				<li value="17">Now, add the <strong class="source-inline">QueryDbAsList()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsList()</p><p class="source-code">{</p><p class="source-code">List&lt;Product&gt; products = (from p in _context.Products</p><p class="source-code">where p.Id &gt; 1</p><p class="source-code">select p).ToList&lt;Product&gt;();</p><p class="source-code">foreach (var product in products)</p><p class="source-code">Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">QueryDbAsList()</strong> performs the same query as <strong class="source-inline">QueryDb()</strong>, except the processed type is of the <strong class="source-inline">List&lt;Product&gt;</strong> type.</p>
			<ol>
				<li value="18">Add the <strong class="source-inline">QueryDbAsIEnumerable()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsIEnumerable()</p><p class="source-code">{</p><p class="source-code">var products = (from p in _context.Products</p><p class="source-code">                where p.Id &gt; 1</p><p class="source-code">                select p).AsEnumerable&lt;Product&gt;();</p><p class="source-code">foreach (var product in products)</p><p class="source-code">    Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">QueryDbAsIEnumerable()</strong> method performs the same query as <strong class="source-inline">QueryDbAsList</strong>, but the processed type is of the <strong class="source-inline">Ienumerable&lt;Product&gt;</strong> type instead. </p>
			<ol>
				<li value="19">Add the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsIEnumerator()</p><p class="source-code">{</p><p class="source-code">      var products = (from p in _context.Products</p><p class="source-code">                where p.Id &gt; 1</p><p class="source-code">                select p).GetEnumerator();</p><p class="source-code">while (products.MoveNext())</p><p class="source-code">    Debug.WriteLine(products.Current.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">QueryDbAsIEnumerator()</strong> does the same as the previous<a id="_idIndexMarker707"/> methods but operates on the <strong class="source-inline">IEnumerator&lt;Product&gt;</strong> type and iterates using a <strong class="source-inline">while</strong> loop instead of a <strong class="source-inline">foreach</strong> loop. </p>
			<ol>
				<li value="20">Our final method in this class is the <strong class="source-inline">QueryDbAsIQueryable()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsIQueryable()</p><p class="source-code">{</p><p class="source-code">var products = (from p in _context.Products</p><p class="source-code">                where p.Id &gt; 1</p><p class="source-code">                select p).AsQueryable&lt;Product&gt;();</p><p class="source-code">foreach (var product in products)</p><p class="source-code">    Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method is the same as <strong class="source-inline">QueryDb</strong> but explicitly operates on the <strong class="source-inline">IQueryable&lt;Product&gt;</strong> type.</p>
			<ol>
				<li value="21">Replace the code in the <strong class="source-inline">Main</strong> method<a id="_idIndexMarker708"/> within the <strong class="source-inline">Program</strong> class with the following code:<p class="source-code">BenchmarkRunner.Run&lt;DatabaseQueryAndIteration&gt;();</p></li>
			</ol>
			<p>This code runs our benchmarks. Do a release build of the code and run the executable from the command line. You should see a summary report similar to the following:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B16617_Figure_6.7.jpg" alt="Figure 6.7 – The different times and memory allocations of various database query types using LINQ&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – The different times and memory allocations of various database query types using LINQ</p>
			<p>In terms of memory usage, the worst performer is the <strong class="source-inline">QueryDb()</strong> method, followed by the <strong class="source-inline">QueryDbAsList()</strong> method. <strong class="source-inline">QueryDbAsIEnumerable()</strong> and <strong class="source-inline">QueryDbAsIQueryable()</strong> are both slightly better than the previous two. However, the best performing method in terms of memory allocation out of all five methods is the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method.</p>
			<p>Speedwise, the <strong class="source-inline">QueryDb()</strong> method was the worst again, followed by <strong class="source-inline">QueryDbAsIEnumerable()</strong>, then <strong class="source-inline">QueryDbAsList()</strong>, and then <strong class="source-inline">QueryDbAsIQueryable()</strong>. And again, the best performer in terms of speed is the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method.</p>
			<p>Here, we can see that the best performing method<a id="_idIndexMarker709"/> for querying and iterating a database in terms of both speed and memory usage is the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method. Now, let's look at the <strong class="source-inline">yield</strong> keyword.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor133"/>Exploring the yield keyword</h1>
			<p>The <strong class="bold">yield</strong> keyword is contextual<a id="_idIndexMarker710"/> and is used with iterators. The following are the two ways to use the <strong class="source-inline">yield</strong> keyword:</p>
			<ul>
				<li><strong class="source-inline">yield return &lt;expression&gt;;</strong>: This returns the value of the expression.</li>
				<li><strong class="source-inline">yield break;</strong>: This will exit from the iteration</li>
			</ul>
			<p>When using the <strong class="source-inline">yield</strong> keyword, there are some restrictions to be aware of. These are as follows:</p>
			<ul>
				<li>You cannot use the <strong class="source-inline">yield</strong> keyword in <strong class="source-inline">unsafe</strong> blocks of code.</li>
				<li>You cannot use the <strong class="source-inline">ref</strong> or <strong class="source-inline">out</strong> parameters for methods, operators, or accessors.</li>
				<li>You cannot return using the <strong class="source-inline">yield</strong> keyword in a <strong class="source-inline">try-catch</strong> block.</li>
				<li>You cannot use the <strong class="source-inline">yield</strong> keyword in anonymous methods.</li>
				<li>You can use <strong class="source-inline">yield</strong> in a <strong class="source-inline">try</strong> block if the <strong class="source-inline">try</strong> block is followed by the <strong class="source-inline">finally</strong> block.</li>
				<li>You can use <strong class="source-inline">yield break</strong> in a <strong class="source-inline">try-catch</strong> block but not the <strong class="source-inline">finally</strong> block.</li>
			</ul>
			<p>In this section, we are going to add<a id="_idIndexMarker711"/> a class that shows the <strong class="source-inline">yield</strong> keyword in action. Then, we will benchmark two ways to return an <strong class="source-inline">IEnumerable&lt;long&gt;</strong> consisting of 1 million items, and show the vast difference in performance between them. Let's begin:</p>
			<ol>
				<li value="1">Add a new class called <strong class="source-inline">Yield</strong> to the root of the project:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">[MemoryDiagnoser]</p><p class="source-code">[Orderer(SummaryOrderPolicy.Declared)]</p><p class="source-code">[RankColumn]</p><p class="source-code">public class Yield { }</p></li>
			</ol>
			<p>This class will benchmark the use of the <strong class="source-inline">yield</strong> keyword. </p>
			<ol>
				<li value="2">Now, add the <strong class="source-inline">YieldSample()</strong> method:<p class="source-code">public void YieldSample()</p><p class="source-code">{</p><p class="source-code">DoCountdown();</p><p class="source-code">PrintMonthsOfYear();</p><p class="source-code">DoBreakIteration();</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">YieldSample()</strong> method will be called from our <strong class="source-inline">Program</strong> class. It will run all three methods. </p>
			<ol>
				<li value="3">Add the <strong class="source-inline">Countdown()</strong> method:<p class="source-code">private IEnumerable&lt;int&gt; Countdown()</p><p class="source-code">{</p><p class="source-code">      for (int x = 10; x &gt;= 0; x--)</p><p class="source-code">      yield return x;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method loops<a id="_idIndexMarker712"/> from <strong class="source-inline">10</strong> to <strong class="source-inline">0</strong>. Each iteration is returned using the <strong class="source-inline">yield</strong> keyword.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">DoCountdown()</strong> method:<p class="source-code">private void DoCountdown()</p><p class="source-code">{</p><p class="source-code">foreach (int x in Countdown())</p><p class="source-code">    Console.WriteLine(x);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">DoCountdown()</strong> method prints the countdown from <strong class="source-inline">10</strong> to <strong class="source-inline">0</strong> to the console window. </p>
			<ol>
				<li value="5">Add a class called <strong class="source-inline">Month</strong>:<p class="source-code">internal class Month</p><p class="source-code">{</p><p class="source-code">      public string Name { get; set; }</p><p class="source-code">      public int MonthOfYear { get; set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class holds the name of a month of the year and its number. </p>
			<ol>
				<li value="6">Now, add<a id="_idIndexMarker713"/> the <strong class="source-inline">Months</strong> class:<p class="source-code">internal class Months</p><p class="source-code">{</p><p class="source-code">   public IEnumerable&lt;Month&gt; MonthsOfYear</p><p class="source-code">   {</p><p class="source-code">    get</p><p class="source-code">   {</p><p class="source-code">    yield return new Month { Name = "January", </p><p class="source-code">        MonthOfYear = 1 };</p><p class="source-code">    yield return new Month { Name = "February", </p><p class="source-code">        MonthOfYear = 2 };</p><p class="source-code">    yield return new Month { Name = "March", </p><p class="source-code">        MonthOfYear = 3 };</p><p class="source-code">    yield return new Month { Name = "April", </p><p class="source-code">        MonthOfYear = 4 };</p><p class="source-code">    yield return new Month { Name = "May", </p><p class="source-code">        MonthOfYear = 5 };</p><p class="source-code">    yield return new Month { Name = "June", </p><p class="source-code">        MonthOfYear = 6 };</p><p class="source-code">    yield return new Month { Name = "July", </p><p class="source-code">        MonthOfYear = 7 };</p><p class="source-code">    yield return new Month { Name = "August", </p><p class="source-code">        MonthOfYear = 8 };</p><p class="source-code">    yield return new Month { Name = "September", </p><p class="source-code">        MonthOfYear = 9 };</p><p class="source-code">    yield return new Month { Name = "October", </p><p class="source-code">        MonthOfYear = 10 };</p><p class="source-code">    yield return new Month { Name = "November", </p><p class="source-code">        MonthOfYear = 11 };</p><p class="source-code">    yield return new Month { Name = "December", </p><p class="source-code">        MonthOfYear = 12 };</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This class returns a collection<a id="_idIndexMarker714"/> of <strong class="source-inline">Month</strong> objects using the <strong class="source-inline">yield</strong> keyword. Switch back to the <strong class="source-inline">Yield</strong> class. </p>
			<ol>
				<li value="7">Add the <strong class="source-inline">PrintMonthsOfYear()</strong> method:<p class="source-code">private void PrintMonthsOfYear()</p><p class="source-code">{</p><p class="source-code">foreach (Month month in new Months().MonthsOfYear)</p><p class="source-code">    Console.WriteLine($"{month.Name} is month </p><p class="source-code">        {month.MonthOfYear} of the year.");</p><p class="source-code">}</p></li>
			</ol>
			<p>This method iterates through the months of the year and prints them out to the console window. </p>
			<ol>
				<li value="8">Add the <strong class="source-inline">BreakIteration()</strong> method:<p class="source-code">private IEnumerable&lt;int&gt; BreakIteration()</p><p class="source-code">{</p><p class="source-code">int x = 0;</p><p class="source-code">while (x &lt; 20)</p><p class="source-code">{</p><p class="source-code">    if (x &lt; 15)</p><p class="source-code">        yield return x;</p><p class="source-code">    else</p><p class="source-code">        yield break;</p><p class="source-code">    x++;</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This method iterates <strong class="source-inline">20</strong> times. A check is made upon<a id="_idIndexMarker715"/> each iteration. If the value is less than <strong class="source-inline">15</strong>, the result is yielded and the variable is incremented. Otherwise, the iteration is exited. </p>
			<ol>
				<li value="9">Add the <strong class="source-inline">DoBreakIteration()</strong> method:<p class="source-code">private void DoBreakIteration()</p><p class="source-code">{</p><p class="source-code">        foreach (int x in BreakIteration())</p><p class="source-code">            Console.WriteLine($"Line {x}:");</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">DoBeakIteration()</strong> method iterates through <strong class="source-inline">BreakIteraton()</strong> and writes the value to the console window. </p>
			<ol>
				<li value="10">In the <strong class="source-inline">Program</strong> class, add a method called <strong class="source-inline">Yield()</strong>, and call it from your <strong class="source-inline">Main</strong> method:<p class="source-code">private static void Yield()</p><p class="source-code">{</p><p class="source-code">        var yieldToMe = new Yield();</p><p class="source-code">        yieldToMe.YieldSample();</p><p class="source-code">}</p></li>
			</ol>
			<p>This method runs our <strong class="source-inline">yield</strong> keyword examples. Do a debug build and step through the code so that you can see how it behaves. You will see that each time the <strong class="source-inline">yield</strong> keyword is encountered, it returns to the calling method. Then, it continues the iteration from where it left off.</p>
			<ol>
				<li value="11">Now, let's add our benchmarking<a id="_idIndexMarker716"/> to test the performance of the <strong class="source-inline">yield</strong> keyword. Add the <strong class="source-inline">GetValues()</strong> method:<p class="source-code">public IEnumerable&lt;long&gt; GetValues()</p><p class="source-code">{</p><p class="source-code">      List&lt;long&gt; list = new List&lt;long&gt;();</p><p class="source-code">      for (long i = 0; i &lt; 1000000; i++)</p><p class="source-code">            list.Add(i);</p><p class="source-code">return list;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method creates a collection of <strong class="source-inline">long</strong> values using a generic <strong class="source-inline">List</strong>. It iterates 1 million items and adds them to the collection. Once complete, the collection is returned to the caller as an <strong class="source-inline">IEnumerable&lt;long&gt;</strong> collection. </p>
			<ol>
				<li value="12">Add the <strong class="source-inline">GetValuesYield()</strong> method:<p class="source-code">public IEnumerable&lt;long&gt; GetValuesYield()</p><p class="source-code">{</p><p class="source-code">      for (long i = 0; i &lt; 1000000; i++)</p><p class="source-code">          yield return i;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method iterates through 1 million items and returns a collection of <strong class="source-inline">IEnumerable&lt;long&gt;</strong>. The iteration uses the <strong class="source-inline">yield</strong> keyword, so each iteration is returned to the caller. </p>
			<ol>
				<li value="13">Add the <strong class="source-inline">GetValuesBenchmark()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void GetValuesBenchmark()</p><p class="source-code">{</p><p class="source-code">      var data = GetValues();</p><p class="source-code">}</p></li>
			</ol>
			<p>This method benchmarks<a id="_idIndexMarker717"/> the <strong class="source-inline">GetValues()</strong> method.</p>
			<ol>
				<li value="14">Add the <strong class="source-inline">GetValuesYieldBenchmark()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void GetValuesYieldBenchmark()</p><p class="source-code">{</p><p class="source-code">      var data = GetValuesYield();</p><p class="source-code">}</p></li>
			</ol>
			<p>This method benchmarks the <strong class="source-inline">GetValuesYield()</strong> method. </p>
			<ol>
				<li value="15">Replace the code in the <strong class="source-inline">Main</strong> method in the <strong class="source-inline">Program</strong> class with the following line of code:<p class="source-code">BenchmarkRunner.Run&lt;Yield&gt;();</p></li>
			</ol>
			<p>This line of code runs our benchmarks. Do a release build and then run the executable from the command line. You should see the following summary report:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B16617_Figure_6.8.jpg" alt="Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits of using the yield keyword&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits of using the yield keyword</p>
			<p>As you can see from the report, building a list of 1 million <strong class="source-inline">long</strong> values is much slower compared to using the <strong class="source-inline">yield</strong> keyword. The <strong class="source-inline">yield</strong> keyword significantly speeds up how collections are processed. That's a 13,102,611.27 ns / 14.50 ns = 903,628.26 times increase in performance! So, you can<a id="_idIndexMarker718"/> see that the use of the <strong class="source-inline">yield</strong> keyword is very beneficial to the performance of your computer programs.</p>
			<p>In the next section, we will look at the difference between concurrency and parallelism and the effects they have on performance.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor134"/>Learning the difference between concurrency and parallelism</h1>
			<p>Concurrency and parallelism<a id="_idIndexMarker719"/> are often mistaken for the same thing, but they<a id="_idIndexMarker720"/> are different. Concurrency does many tasks at the same time using multi-threading. Multi-threading allots time to various threads based on time/context switching. This presents the illusion that the computer is doing multiple things at the same time. But it is, in reality, only doing one thing. Parallelism, on the other hand, does many things all at the same time.</p>
			<p>Concurrency is used to manage<a id="_idIndexMarker721"/> multiple computations simultaneously. It accomplishes this using interleaving operations. The benefit of concurrency is that it increases the amount of work that can be completed over time. It uses context switching to perform interleaving operations. Concurrency can work with a single processor. You are already aware of concurrency at work, as you will have had multiple applications running at the same time. All these programs are making use of concurrency. </p>
			<p>The main usage of concurrency<a id="_idIndexMarker722"/> is to have usable applications that are non-blocking. For example, if you<a id="_idIndexMarker723"/> have an application that performs a long-running operation, this operation can be run on a background thread to allow the user to still use the application and get work done. So, concurrency is not necessarily about performance – it is more about not blocking your users from being able to do what they intend with your application.</p>
			<p>Parallelism performs multiple<a id="_idIndexMarker724"/> computations at the same time in parallel to each other. To accomplish parallelism, multiple processors are required. The benefit of using parallelism is increased computational processing speed. Running document crawlers over a cluster and performing parallel queries and big data are examples of using parallelism. </p>
			<p>The main goal of parallelism is performance. In other words, the intention of using parallelism is to complete an operation in the shortest amount of time. An example of parallelism in use would be data-intensive number crunching for report generation.</p>
			<p>You should never mix concurrency with performance. If you do, your design will either be bad or over-engineered. So, if you want user interfaces to be non-blocking, use concurrency. However, if you want non-UI tasks to complete in the shortest possible time, use parallelism. Later in this book, we will devote whole chapters to concurrency, parallelism, and asynchronous processing. But for now, let's turn our attention to the difference between <strong class="source-inline">Equals()</strong> and <strong class="source-inline">==</strong>.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor135"/>Learning the difference between Equals() and ==</h1>
			<p>The <strong class="source-inline">==</strong> operator compares <a id="_idIndexMarker725"/>object references, known<a id="_idIndexMarker726"/> as shallow comparison, while the <strong class="source-inline">Equals()</strong> method compares<a id="_idIndexMarker727"/> object content, known<a id="_idIndexMarker728"/> as deep comparison. Both the operator<a id="_idIndexMarker729"/> and the method can be overloaded.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you overload the <strong class="source-inline">==</strong> operator, then you should overload the <strong class="source-inline">Equals()</strong> method and vice versa. </p>
			<p>The <strong class="source-inline">==</strong> operator<a id="_idIndexMarker730"/> returns <strong class="source-inline">true</strong> in the following<a id="_idIndexMarker731"/> situations:</p>
			<ul>
				<li><strong class="source-inline">Value Type Value == Value Type Value</strong></li>
				<li><strong class="source-inline">Reference Type Instance == Reference Type Instance</strong></li>
				<li><strong class="source-inline">String == String</strong></li>
			</ul>
			<p>The <strong class="source-inline">Equals()</strong> method <a id="_idIndexMarker732"/>returns <strong class="source-inline">true</strong> in the following situations:</p>
			<ul>
				<li><strong class="source-inline">ReferenceType.Equals(ReferenceType)</strong> both refer to the same object reference</li>
				<li><strong class="source-inline">ValueType.Equals(ValueType)</strong> are both the same type and have the same value</li>
			</ul>
			<p>Now, let's add a new class called <strong class="source-inline">Equality</strong> to the root of the <em class="italic">CH06_Collections</em> project to demonstrate the difference in performance between the <strong class="source-inline">==</strong> operator and the <strong class="source-inline">Equals()</strong> method. Let's get started: </p>
			<ol>
				<li value="1">Add the <strong class="source-inline">Equality</strong> class, as follows:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Diagnostics;</p><p class="source-code">using System.Linq;</p><p class="source-code">[MemoryDiagnoser]</p><p class="source-code">[Orderer(SummaryOrderPolicy.Declared)]</p><p class="source-code">[RankColumn]</p><p class="source-code">public class Equality { }</p></li>
			</ol>
			<p>With that, our class has been configured to perform benchmarking. </p>
			<ol>
				<li value="2">Add the following code to the top of the class:<p class="source-code">private List&lt;string&gt; _listOne;</p><p class="source-code">private List&lt;string&gt; _listTwo;</p><p class="source-code">private int _value1;</p><p class="source-code">private int _value2;</p><p class="source-code">private string _string1;</p><p class="source-code">private string _string2;</p></li>
			</ol>
			<p>Here, we have<a id="_idIndexMarker733"/> our value types, reference types, and string <a id="_idIndexMarker734"/>types in place that will have their equality tested. </p>
			<ol>
				<li value="3">Now, add the <strong class="source-inline">GlobalSetup()</strong> method:<p class="source-code">[GlobalSetup]</p><p class="source-code">public void GlobalSetup()</p><p class="source-code">{</p><p class="source-code">      _listOne = new List&lt;string&gt;</p><p class="source-code">{</p><p class="source-code">    "Alpha", "Beta", "Gamma", "Delta", "Eta", "Theta"</p><p class="source-code">};</p><p class="source-code">  _listTwo = _listOne;</p><p class="source-code">  _value1 = 123;</p><p class="source-code">  _value2 = _value1;</p><p class="source-code">  _string1 = "Hello, world!";</p><p class="source-code">  _string2 = _string1;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method assigns our variables<a id="_idIndexMarker735"/> in preparation for our equality<a id="_idIndexMarker736"/> benchmarks. </p>
			<ol>
				<li value="4">Add the <strong class="source-inline">ValueOperatorValue()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void ValueOperatorValue()</p><p class="source-code">{</p><p class="source-code">      bool value = _value1 == _value2;</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ValueOperatorValue()</strong> method benchmarks the equality checking of two values using the <strong class="source-inline">equality</strong> operator. </p>
			<ol>
				<li value="5">Add the <strong class="source-inline">ValueEqualsValue()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void ValueEqualsValue()</p><p class="source-code">{</p><p class="source-code">      bool value = _value1.Equals(_value2);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ValueEqualsValue()</strong> method benchmarks the equality checking of two values using the <strong class="source-inline">Equals(value)</strong> method. </p>
			<ol>
				<li value="6">Add the <strong class="source-inline">ReferenceOperatorReference()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void ReferenceOperatorReference()</p><p class="source-code">{</p><p class="source-code">      bool value = _listOne == _listTwo;</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ReferenceOperatorReference()</strong> method benchmarks<a id="_idIndexMarker737"/> the equality checking of two reference<a id="_idIndexMarker738"/> values using the equality operator. </p>
			<ol>
				<li value="7">Add the <strong class="source-inline">ReferenceEqualsReference()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void ReferenceEqualsReference()</p><p class="source-code">{</p><p class="source-code">      bool value = _listOne.Equals(_listTwo);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ReferenceEqualsReference()</strong> method benchmarks the equality checking of two values using the <strong class="source-inline">Equals(reference)</strong> method. </p>
			<ol>
				<li value="8">Add the <strong class="source-inline">StringOperatorString()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void StringOpertatorString()</p><p class="source-code">{</p><p class="source-code">      bool value = _string1 == _string2;</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">StringOperatorString()</strong> method benchmarks the equality testing of two strings using the <strong class="source-inline">==</strong> operator. </p>
			<ol>
				<li value="9">Next, add the <strong class="source-inline">StringEqualsString()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void StringEqualsString()</p><p class="source-code">{</p><p class="source-code">      bool value = _string1.Equals(_string2);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">StringEqualsString()</strong> method benchmarks<a id="_idIndexMarker739"/> the equality testing of two<a id="_idIndexMarker740"/> strings using the <strong class="source-inline">Equals()</strong> method. </p>
			<ol>
				<li value="10">Add <strong class="source-inline">BenchmarkRunner.Run&lt;Equality&gt;();</strong> to the <strong class="source-inline">Main</strong> method of the <strong class="source-inline">Program</strong> class, do a <strong class="source-inline">Release</strong> build, and then run your executable from the command line. You should end up with the following benchmark report:</li>
			</ol>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B16617_Figure_6.9.jpg" alt="Figure 6.9 – The BenchmarkDotNet summary report for various equality checks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – The BenchmarkDotNet summary report for various equality checks</p>
			<p>As we can see, it is quicker to test value type equality using the <strong class="source-inline">==</strong> operator, quicker to use the <strong class="source-inline">==</strong> operator to test reference type equality, and quicker to use <strong class="source-inline">Equals(string)</strong> when comparing strings. </p>
			<p>With that, we have completed<a id="_idIndexMarker741"/> this chapter. But before<a id="_idIndexMarker742"/> we move on to <a href="B16617_07_Final_SB_Epub.xhtml#_idTextAnchor139"><em class="italic">Chapter 7</em></a>, <em class="italic">LINQ Performance</em>, let's summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor136"/>Summary</h1>
			<p>In this chapter, we learned about the different types of collections and their usage. We saw that we should prefer using generic collections over non-generic collections. Then, we briefly touched on Big O Notation and how to use it to determine algorithmic efficiency. After that, we looked at choosing the right type of collection for what we needed.</p>
			<p>After that, we set up a sample database to test the querying and iteration of data using further on in the chapter. Then, we looked at how to choose between using interfaces and concrete classes and choosing between arrays and collections. Next, we looked at indexers and then moved on to look at <strong class="source-inline">IEnumerable&lt;T&gt;</strong>, <strong class="source-inline">IEnumerator&lt;T&gt;</strong>, and <strong class="source-inline">IQueryable&lt;T&gt;</strong> and their performance. </p>
			<p>The next topic we looked at was using the <strong class="source-inline">yield</strong> keyword. We touched on the differences between concurrency and parallelism and mentioned that these will be looked at in more depth in later chapters. Finally, we looked at the difference between the <strong class="source-inline">==</strong> operator and the <strong class="source-inline">Equals()</strong> method in terms of performance.</p>
			<p>In the next chapter, we will be looking at LINQ performance. But for now, see if you can answer the following questions, and check out the <em class="italic">Further reading</em> section to solidify what you have learned in this chapter.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor137"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">List the different namespace collections.</li>
				<li>What is Big O notation used for?</li>
				<li>What does algorithmic efficiency measure?</li>
				<li>Is it preferable to use <strong class="source-inline">IList&lt;T&gt;</strong> or <strong class="source-inline">List&lt;T&gt;</strong> in terms of instantiation speed?</li>
				<li>Should we use collections or arrays?</li>
				<li>What does an indexer do?</li>
				<li>Which method of iteration is fastest on an in-memory collection between <strong class="source-inline">IEnumerable&lt;T&gt;</strong> and <strong class="source-inline">IEnumerator&lt;T&gt;</strong>?</li>
				<li>In terms of memory and speed performance, what database query method performs best?</li>
				<li>When building a collection using iteration, what is the quickest way to build the collection up and return the results?</li>
			</ol>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor138"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li><em class="italic">Indexers</em>: <a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/">https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/</a>. </li>
				<li><em class="italic">ConsoleSecrets</em>: <a href="https://github.com/jasonshave/ConsoleSecrets">https://github.com/jasonshave/ConsoleSecrets</a>.</li>
				<li><em class="italic">Equality Operators</em>: <a href="https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators">https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators</a>.</li>
				<li><em class="italic">Interesting Performance Implications of C# 9 Records Equality Check</em>: <a href="https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919">https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919</a>.</li>
				<li><em class="italic">Improving Struct Equality Performance in C#:</em> <a href="http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C">http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C</a>.</li>
				<li><em class="italic">String Equality and Performance in C#:</em> <a href="https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/">https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/</a>.</li>
				<li><em class="italic">Performance Implications of Default Struct Equality in C#:</em> <a href="https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/">https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/</a>.</li>
				<li><em class="italic">Performance Best Practices in C#:</em> <a href="https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a">https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a</a>.</li>
				<li><em class="italic">8 Techniques to Avoid GC Pressure and Improve Performance in C# .NET</em>: <a href="https://michaelscodingspot.com/avoid-gc-pressure/">https://michaelscodingspot.com/avoid-gc-pressure/</a>.</li>
			</ul>
		</div>
	</body></html>