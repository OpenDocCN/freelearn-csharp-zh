<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor013"/>1</h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Data Types</h1>
<p><a id="_idTextAnchor015"/>Welcome to the first chapter in which you’ll start your amazing adventure with data structures and algorithms in the context of the <strong class="bold">C# programming language</strong>. First, we’ll provide a short introduction to this language. You will get to know how broad its possibilities are, in how many scenarios you can apply this language, as well as some basic constructions that you can use. This isn’t a C# course, so we won't be presenting various features one by one, and only a brief description will be provided.</p>
<p>The remaining part of this chapter is dedicated to <strong class="bold">data types</strong>, both built-in and user-defined, which you can use in your applications. First, you will learn what the difference is between value and reference types. Then, you will go through various available data types, starting with value types. Here, we will cover integral numeric types, floating-point numeric types, Boolean types, Unicode characters, constants, enumerations, value tuples, struct types, and nullable value types. Finally, we’ll cover reference types, including object and string types, as well as classes, records, interfaces, and delegates, together with dynamic and nullable reference types.</p>
<p>As you can see, you have quite a long journey before you. However, if you get to know the basics well, it will be much easier for you to get the most out of the content presented in the remainder of this book. I, as the author, am keeping my fingers crossed for you – good luck!</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>C# as a programming language</li>
<li>.NET-based console applications</li>
<li>The division of data types between value and reference types</li>
<li>Value types</li>
<li>Reference types</li>
</ul>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/><a id="_idTextAnchor017"/>C# as a programming language</h1>
<p>As a developer, you have probably heard about many programming languages, including <strong class="bold">C#</strong>, <strong class="bold">Java</strong>, <strong class="bold">C++</strong>, <strong class="bold">C</strong>, <strong class="bold">PHP</strong>, and <strong class="bold">Ruby</strong>. In all of them, you can <a id="_idIndexMarker000"/>use various data structures, as well as implement algorithms, to solve both basic and complex problems. However, each language has a specificity that’s visible while implementing data structures and accompanying algorithms. As<a id="_idIndexMarker001"/> mentioned previously, this book only focuses on the C# programming language. This is also the main topic of this section.</p>
<p>The C# language, pronounced <em class="italic">C sharp</em>, is a <strong class="bold">modern, general-purpose, strongly typed, and object-oriented programming language that can be used while developing a wide range of applications</strong>, such as web, mobile, desktop, distributed, and embedded solutions, as well as <a id="_idIndexMarker002"/>even games! It cooperates with various additional technologies and platforms, including <strong class="bold">ASP.NET Core</strong>, <strong class="bold">XAML</strong>, and <strong class="bold">Unity</strong>. Therefore, when <a id="_idIndexMarker003"/>you learn the C# language, as well as get to know more<a id="_idIndexMarker004"/> about data structures and algorithms in the context of this programming language, you can use such skills to create more than one particular type of software. What’s more, even if you decide to change your primary programming language to another, your knowledge regarding data structures and algorithms will still be useful. You might be wondering, <em class="italic">how is this possible?</em> The answer turns out to be very simple – you will understand how various data structures work, how you can implement them, as well as how you can apply them to solve various problems with specialized algorithms. But let’s go back to the C# language.</p>
<p>The current version of the language is <strong class="bold">C# 12</strong>. It is worth mentioning its interesting history in terms of various<a id="_idIndexMarker005"/> versions of the language (including 2.0, 3.0, 5.0, and 8.0) in which new features were added to increase language possibilities. When you take a look at the release notes for particular versions, you will see how the language is being improved and expanded over time to be a powerful and convenient solution for developers. New features are pretty awesome and can significantly simplify your work and allow you to refactor the code so that it’s shorter, as well as easier to understand and maintain. That’s great work that’s been done by the team developing C# that you can now benefit from while writing your code.</p>
<p>The syntax of the C# programming language is similar to other languages, such as Java or C++. For this reason, if you know such languages, you should easily be able to understand the code written in C#. As an example, similarly as in the languages mentioned previously, the code consists of statements that end with semicolons (<code>;</code>). The curly brackets, namely <code>{</code> and <code>}</code>, are used to group statements.</p>
<p>There are a few categories of<a id="_idIndexMarker006"/> statements, including the following:</p>
<ul>
<li><code>if</code> and <code>switch</code>. The <code>if</code> statement allows you to conditionally execute code, depending <a id="_idIndexMarker007"/>on the provided condition. The <code>switch</code> statement makes it possible to choose a statement list to execute <a id="_idIndexMarker008"/>using the <strong class="bold">pattern match</strong>.</li>
<li><code>do-while</code>, <code>while</code>, <code>for</code>, and <code>foreach</code>. They are<a id="_idIndexMarker009"/> related to <strong class="bold">loops</strong> and are <a id="_idIndexMarker010"/>used to execute a part of code many times while the condition is met.</li>
<li><code>break</code>, <code>continue</code>, and <code>goto</code>. They are used to control the execution<a id="_idIndexMarker011"/> of loops, such as to break it or move to the next iteration.</li>
<li><code>throw</code>, <code>try-catch</code>, <code>try-finally</code>, and <code>try-catch-finally</code>. They are connected to handling exceptions that can be<a id="_idIndexMarker012"/> thrown in various parts of the code.</li>
</ul>
<p>Other statements exist as well, such as <code>lock</code>, <code>yield</code>, <code>checked</code>, <code>unchecked</code>, and <code>fixed</code>. You will see some of the statements presented in the preceding list in the code snippets shown in the following chapters of this book, along with explanations.</p>
<p>Developing various applications in the C# language is also simplified by the availability of many additional great features, such <a id="_idIndexMarker013"/>as <strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>), which allows developers to get data from various sources, including SQL databases and XML documents, consistently. There are also some approaches to shorten the required code, such as using Lambda expressions, pattern matching, properties, expression-bodied members, records, and string interpolations. It is worth <a id="_idIndexMarker014"/>mentioning automatic <strong class="bold">garbage collection</strong>, which greatly simplifies the task of releasing memory.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can learn more about the newest version of the C# language at <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12</a>. The language history is shown at <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history</a>. A set of detailed information about the language reference (including value and reference types) is available at <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference</a>. You can find there information about available data types with a set of details, including the supported value ranges and precisions, which are presented later in this chapter.</p>
<p>Of course, the solutions<a id="_idIndexMarker015"/> mentioned previously are only a very limited subset of features that are available while developing in C#. You will see some others in the following parts of this book, along with examples and detail<a id="_idTextAnchor018"/>ed descriptions.</p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor019"/>.NET-based console applications</h1>
<p>To keep things simple, while<a id="_idIndexMarker016"/> reading this book, you will create many console-based applications, but the data structures and algorithms could be used in other kinds of solutions <a id="_idIndexMarker017"/>as well. The console-based applications will be created in <strong class="bold">Microsoft Visual Studio 2022 Community</strong>. This <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) is a comprehensive solution for developing <a id="_idIndexMarker018"/>various kinds of projects and is equipped with many great features that simplify the development and testing of your applications.</p>
<p>Just after launching the IDE, we can proceed by creating a new project. To create one, follow these steps:</p>
<ol>
<li>Click on <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong> in the main menu.</li>
<li>Choose <strong class="bold">Console App</strong> on the right in the <strong class="bold">Create a new </strong><strong class="bold">project</strong> window.</li>
<li>Type the name of the project (<strong class="bold">Project name</strong>), select a location for the files (<strong class="bold">Location</strong>), and enter the name of the solution (<strong class="bold">Solution name</strong>). Then, press <strong class="bold">Next</strong>.</li>
<li>In the <strong class="bold">Additional information</strong> window, set the framework version to <strong class="bold">.NET 8.0 (Long Term Support)</strong> and ensure that <strong class="bold">Do not use top-level statements</strong> is unchecked. If you are ready, click on the <strong class="bold">Create</strong> button to automatically create the project and generate the necessary files.</li>
</ol>
<p>Congratulations! You’ve just created the first project. But what’s inside?</p>
<p>Let’s take a look at the <strong class="bold">Solution Explorer</strong> window, which presents the structure of the project. It is worth mentioning that the project is included in the solution with the same name. Of course, a solution could contain more than one project, which is a common scenario while developing more complex applications. You can see how it works if you browse the GitHub <a id="_idIndexMarker019"/>repository of this book. It contains one solution with over 40 projects.</p>
<p class="callout-heading">Don’t have Solution Explorer?</p>
<p class="callout">If you cannot find the <strong class="bold">Solution Explorer</strong> window, you can open it by choosing the <strong class="bold">View</strong> | <strong class="bold">Solution Explorer</strong> option from the main menu. Similarly, you could open other windows, such as <strong class="bold">Output</strong> or <strong class="bold">Class View</strong>. If you cannot find a suitable window (for example, <strong class="bold">C# Interactive</strong>) directly within the <strong class="bold">View</strong> option, you can find it in the <strong class="bold">View</strong> | <strong class="bold">Other </strong><strong class="bold">Windows</strong> node.</p>
<p>The automatically generated project contains the <strong class="bold">Dependencies</strong> element, which presents additional dependencies used by the project. It is worth noting that you could easily add references by choosing the <strong class="bold">Add Project Reference</strong>, <strong class="bold">Add Shared Project Reference</strong>, or <strong class="bold">Add COM Reference</strong> option from the context menu of the <strong class="bold">Dependencies</strong> element. Moreover, you can install additional packages using <strong class="bold">NuGet Package Manager</strong>, which can be launched by choosing <strong class="bold">Manage NuGet Packages</strong> from the <strong class="bold">Dependencies</strong> context menu.</p>
<p class="callout-heading">Write from scratch or reuse existing packages?</p>
<p class="callout">It is a good idea to take a look at packages that are already available before writing the complex module on your own since a suitable package could already be available for developers. In such a case, you could not only shorten the development time but also reduce the chance of introducing mistakes. However, please check the license conditions and ensure that the external module is reliable.</p>
<p>The <code>Program.cs</code> file contains the main code in C#. You could adjust the behavior of the application by changing the following default implementation:</p>
<pre class="source-code">
// See <a href="https://aka.ms/new-console-template">https://aka.ms/new-console-template</a>
   for more information
Console.WriteLine("Hello, World!");</pre> <p>The initial content of this file contains just two lines. The first contains the comment, while the other writes the following text in the console when the program is launched:</p>
<pre class="console">
Hello, World!</pre> <p>It looks so simple and easy to<a id="_idIndexMarker020"/> modify, doesn’t it? This is true and the default implementation of this file has changed significantly over the last few years due to the functionality of <code>Program</code> class is defined, together with the <code>Main</code> static method, where the logic of the simple program is placed.</p>
<p>So, what will the default code look like if you disable the top-level statements? Let’s take a look at it:</p>
<pre class="source-code">
namespace GettingStarted
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello, World!");
        }
    }
}</pre> <p>The preceding code contains the definition of the <code>Program</code> class within the <code>GettingStarted</code> namespace. This class contains the <code>Main</code> static method, which is called automatically when the application is launched.</p>
<p>Before proceeding, let’s take a look at the structure of the project in the file explorer, not in the <strong class="bold">Solution Explorer</strong> window. Are such structures the same?</p>
<p class="callout-heading">How to open a project directory</p>
<p class="callout">You could open the directory with the <a id="_idIndexMarker022"/>project in the file explorer by choosing the <strong class="bold">Open Folder in File Explorer</strong> option from the context menu of the project node in the <strong class="bold">Solution </strong><strong class="bold">Explorer</strong> window.</p>
<p>First of all, you can see the <code>bin</code> and <code>obj</code> directories, which are generated automatically. Both contain <code>Debug</code> and <code>Release</code> directories, whose names are related to the configuration set<a id="_idIndexMarker023"/> in the IDE. After building the project, a subdirectory of the <code>bin</code> directory (that is, <code>Debug</code> or <code>Release</code>) contains the <code>net8.0</code> directory with <code>.exe</code>, <code>.dll</code>, and <code>.pdb</code> files. What’s more, there is no <code>Dependencies</code> directory, but there is the <code>.csproj</code> file, which contains the XML-based configuration of the project. Similarly, the solution-based <code>.sln</code> configuration file is located in the solution’s directory.</p>
<p class="callout-heading">Ignore some files and directories using Git</p>
<p class="callout">If you are using a <code>bin</code> and <code>obj</code> directories, as<a id="_idIndexMarker024"/> well as the <code>.csproj.user</code> file. I strongly encourage you to use a version control system for various projects, as well as to <strong class="bold">commit and push changes frequently</strong>. If you can, you can also try to automate the process of testing and deployment, such as by introducing <strong class="bold">continuous integration</strong> and <strong class="bold">continuous delivery</strong> (<strong class="bold">CI/CD</strong>). The<a id="_idIndexMarker025"/> introduction of such procedures can have a very positive impact on the quality and stability of your great applications, regardless of their types.</p>
<p>As you already know how to create projects for the examples we’ll be covering in this book, let’s focus on the available data types and their basic divisions, as<a id="_idTextAnchor020"/> well as write some code!</p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor021"/>Division of data types</h1>
<p>While developing applications in the C# language, you could use various data types, which are divided into two main<a id="_idIndexMarker026"/> groups, namely <strong class="bold">value types</strong> and <strong class="bold">reference types</strong>. The <a id="_idIndexMarker027"/>difference between them<a id="_idIndexMarker028"/> is quite simple – <strong class="bold">a variable of a value type directly contains data, while a variable of a reference type just stores a reference to data, which is located </strong><strong class="bold">somewhere else</strong>.</p>
<p>Here’s an illustration of this:</p>
<div><div><img alt="Figure 1.1 – The difference between value and reference types" src="img/B18069_01_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The difference between value and reference types</p>
<p>As you can see, a variable of a <strong class="bold">value type</strong> (shown as <strong class="bold">A</strong>) stores its actual <strong class="bold">value</strong> directly in the <strong class="bold">stack</strong> memory, while a variable of a <strong class="bold">reference type</strong> only stores a <strong class="bold">reference</strong> here. The actual value is located in the <strong class="bold">heap</strong> memory. Therefore, it is possible to have two or more variables of a<a id="_idIndexMarker029"/> reference type that reference the same value, as indicated by the <strong class="bold">C</strong> and <strong class="bold">D</strong> boxes in the preceding figure.</p>
<p class="callout-heading">Be careful – it is a simplification!</p>
<p class="callout">Please remember that this is some kind of simplification because value types are not always stored on the stack. There are some scenarios when they are stored on the heap. If you are interested in this topic, you can read much more about it at <a href="https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/">https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/</a>.</p>
<p>Of course, a difference between value <a id="_idIndexMarker030"/>and reference types is important while programming and you should know which types belong to the groups mentioned previously. Otherwise, you could make mistakes in the code that could be quite difficult to find.</p>
<p>For instance, you should be careful while <a id="_idIndexMarker031"/>comparing two objects with the <code>==</code>) since <strong class="bold">two variables of a value type are equal if their data are equal, while two variables of a reference type are equal if they reference the </strong><strong class="bold">same location</strong>.</p>
<p>You should also take care while assigning a variable of a reference type to another variable and while passing a variable of a reference type as an argument to a method and updating its data. This is because the change can be reflected in other variables that are referencing the same object. In contrast, while using a value type, the variable value is copied while it’s being passed as an argument to a method, returning a result from a method, or assigning it to another variable, so you only modify data in one location.</p>
<p>Does the division between value and reference types seem clear to you? If so, let’s proceed to the next section, where the value types will be described in more detail, and some c<a id="_idTextAnchor022"/><a id="_idTextAnchor023"/>ode snippets will be provided.</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor024"/>Value types</h1>
<p>To give you a better understanding of data types, let’s start by analyzing the first group, namely <strong class="bold">value types</strong>. They are<a id="_idIndexMarker032"/> further divided into the following categories:</p>
<ul>
<li><strong class="bold">Structs</strong><strong class="bold"> </strong>encapsulating data and functionalities, which are divided into the following <a id="_idIndexMarker033"/>categories:<ul><li><strong class="bold">Built-in value types</strong>, also referred to <a id="_idIndexMarker034"/>as <strong class="bold">simple types</strong>. These are divided into:<ul><li><strong class="bold">Integral </strong><strong class="bold">numeric types</strong></li><li><strong class="bold">Floating-point </strong><strong class="bold">numeric types</strong></li><li><strong class="bold">Boolean values</strong></li><li><strong class="bold">Unicode </strong><strong class="bold">UTF-16 characters</strong></li></ul></li><li><strong class="bold">Value tuples</strong></li><li><strong class="bold">User-defined </strong><strong class="bold">struct types</strong></li></ul></li>
<li><strong class="bold">Constants</strong></li>
<li><strong class="bold">Enumerations</strong></li>
</ul>
<p>All of these groups will be described<a id="_idIndexMarker035"/> in this secti<a id="_idTextAnchor025"/>on, starting with the simple types.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor026"/>Integral numbers</h2>
<p>The first group of <a id="_idIndexMarker036"/>built-in value types are the <code>System</code> namespace. Such types differ by the number of bytes used and whether signed or unsigned integral values are represented by them.</p>
<p class="callout-heading">Imagine an integer value</p>
<p class="callout">If you want to better visualize an integer value, you <a id="_idIndexMarker039"/>can find some examples around you – the publication year of this book, the number of legs of your table, and the number of keys on your keyboard. All of these are integer values, such as <code>2024</code>, <code>4</code>, and <code>84</code>. Yes, I counted the number of keys on my keyboard, especially for you!</p>
<p>The supported integral numeric types are as follows:</p>
<ul>
<li><code>Byte</code> (the <code>byte</code> keyword), as 8-bit unsigned</li>
<li><code>Sbyte</code> (<code>sbyte</code>), as 8-bit signed</li>
<li><code>Int16</code> (<code>short</code>), as 16-bit signed</li>
<li><code>Uint16</code> (<code>ushort</code>), as 16-bit unsigned</li>
<li><code>Int32</code> (<code>int</code>), as 32-bit signed</li>
<li><code>UInt32</code> (<code>uint</code>), as 32-bit unsigned</li>
<li><code>Int64</code> (<code>long</code>), as 64-bit signed</li>
<li><code>UInt64</code> (<code>ulong</code>), as 64-bit unsigned</li>
<li><code>System.IntPtr</code> (<code>nint</code>), as 32- or 64-bit (platform-dependent) signed</li>
<li><code>System.UintPtr</code> (<code>nuint</code>), as 32- or 64-bit (platform-dependent) unsigned</li>
</ul>
<p>As you can see, the types <a id="_idIndexMarker040"/>differ by the number of bytes for storing values and therefore<a id="_idIndexMarker041"/> by the range of available values. As an example, the <code>byte</code> data type supports values in the range from 0 to 255, <code>sbyte</code> from -128 to 127, <code>short</code> from -32,768 to 32,767, and <code>uint</code> from 0 to 4,294,967,295. Is it a huge number? Yes, it is. However, let’s take a look at the range for <code>ulong</code>, which is from 0 to 18,446,744,073,709,551,615.</p>
<p>You can specify values for integral types in the following modes:</p>
<ul>
<li><code>45</code>.</li>
<li><code>0x</code> or <code>0X</code> as a prefix – for example, <code>0xff</code> for 255.</li>
<li><code>0b</code> or <code>0B</code> as a prefix – for example, <code>0b1101110</code> for 110. It can be also written as <code>0b_0110_1110</code> to improve the readiness of the number.</li>
</ul>
<p>Here’s an exemplary code snippet:</p>
<pre class="source-code">
int a = <strong class="bold">-20</strong>;
byte b = <strong class="bold">0x0f</strong>;
uint c = <strong class="bold">0b01101110</strong>;</pre> <p>The last remark we’ll make is about the default value for any built-in integral numeric type. You probably won’t be surprised if I told you that it is <strong class="bold">zero</strong>.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor027"/>Floating-point numbers</h2>
<p>The second group of built-in value types are <strong class="bold">floating-point numeric types</strong>, which allow you to <a id="_idIndexMarker043"/>store <strong class="bold">floating-point values</strong>.</p>
<p class="callout-heading">Imagine a floating-point value</p>
<p class="callout">If you want to better imagine a<a id="_idIndexMarker044"/> floating-point value, you can measure your current body temperature in Celsius degrees, get your height in centimeters, count the money that you currently have in your wallet, or take a look at your computer’s processor frequency provided in GHz. All of these values are floating-point ones – for example, <code>36.6</code>, <code>184.8</code>, <code>105.34</code>, and <code>1.7</code>.</p>
<p>You can use three floating-point numeric types:</p>
<ul>
<li><code>Single</code> (<code>float</code>) using 32 bits – for example, <code>1.53f</code> (<code>f</code> or <code>F</code> suffix)</li>
<li><code>Double</code> (<code>double</code>) using 64 bits – for example, <code>1.53</code> (no suffix or <code>d</code>/<code>D</code> suffix)</li>
<li><code>Decimal</code> (<code>decimal</code>) using 128 bits – for example, <code>1.53M</code> (<code>m</code> or <code>M</code> suffix)</li>
</ul>
<p>Let’s take a look at the following code:</p>
<pre class="source-code">
float temperature = <strong class="bold">36.6f</strong>;
double reading = <strong class="bold">-4.5178923</strong>;
decimal salary = <strong class="bold">10000.47M</strong>;</pre> <p>As the number of used bits differs from 32 up to 128 bits, the range and precision of values differ significantly. Just take a look at the numbers:</p>
<ul>
<li><code>float</code> stores numbers between ±1.5×10−45 and ±3.4×1038</li>
<li><code>double</code> stores numbers between ±5.0×10−324 and ±1.7×10308</li>
<li><code>decimal</code> stores numbers between ±1.0×10-28 and ±7.9228×1028</li>
</ul>
<p>You might be surprised that even though <code>decimal</code> values use twice as many bits as the <code>double</code> type does, its range is significantly smaller. However, the <code>decimal</code> type is a good choice for monetary calculations.</p>
<p>In the end, remember that the default value for any floating-point numeric type is <strong class="bold">zero</strong>.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor028"/>Boolean values</h2>
<p>Regarding <code>Boolean</code> type or the <code>bool</code> keyword. This makes it possible to store a <code>true</code> or <code>false</code>. The default value is <code>false</code>.</p>
<p class="callout-heading">Imagine a Boolean value</p>
<p class="callout">If you want to visualize a Boolean value, answer the following questions: are you currently reading this book? Do you have at least 5 years of experience? Have you finished university? You can only answer these questions with <em class="italic">yes</em> (<code>true</code>) or <em class="italic">no</em> (<code>false</code>). No other answers are accepted. So, you can store such replies as Boolean variables.</p>
<p>Let’s take a look at the following code:</p>
<pre class="source-code">
bool isTrue = <strong class="bold">true</strong>;
bool first = <strong class="bold">isTrue || false</strong>;  // true
bool second = <strong class="bold">isTrue &amp;&amp; false</strong>; // false
bool third = <code>true</code> and <code>false</code> values, but also the <code>null</code>. In such circumstances, you <a id="_idIndexMarker048"/>can benefit from the nullable Boolean type (<code>bool?</code>), which also supports three-valued logic. You’ll learn more about nullable value types later.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor029"/>Unicode characters</h2>
<p>The last built-in value<a id="_idIndexMarker049"/> type we’ll mention here is the <code>Char</code> type or the <code>char</code> keyword. It represents a single Unicode character.</p>
<p class="callout-heading">Imagine a character</p>
<p class="callout">If you want to understand what a Unicode character is, please write your first name on a piece of paper, separating the following letters. Each one is a character – for example, <code>M</code>, <code>a</code>, <code>r</code>, <code>c</code>, <code>i</code>, and <code>n</code>. You can use also a character to indicate the gender of a person – that is, <code>m</code> (for male), <code>f</code> (for female), and <code>o</code> (for other). As we are talking about UTF-16 encoding, a lot more values can be stored using a <code>char</code> variable, including symbols such as <code>©</code>, <code>﷼</code>, or <code>ϔ</code>. But that’s not all – you can use also geometric symbols, such as <code>▶</code> and <code>◉</code>, or even mathematical ones, such as <code>⅖</code> or <code>∑</code>.</p>
<p>A <code>char</code> value can be<a id="_idIndexMarker051"/> specified using the following:</p>
<ul>
<li><code>'a'</code> or <code>'M'</code></li>
<li><code>\u</code> – for example, <code>'\u25cf'</code> for <code>●</code></li>
<li><code>\x</code> – for example, <code>'\x107'</code> for <code>ć</code></li>
</ul>
<p>The exemplary code <a id="_idIndexMarker052"/>snippet is as follows:</p>
<pre class="source-code">
char letter = <strong class="bold">'M'</strong>;
char bullet = <strong class="bold">'\u25cf'</strong>;
char special = <code>char</code> value is <code>\</code><code>0</code> (<code>U+0000</code>).</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>Constants</h2>
<p>It is worth <a id="_idIndexMarker053"/>noting that you<a id="_idIndexMarker054"/> can also define <strong class="bold">constant values</strong>. <strong class="bold">Each constant value is an </strong><strong class="bold">immutable value</strong><strong class="bold"> that cannot be changed</strong>. Constant <a id="_idIndexMarker055"/>values can only be <a id="_idIndexMarker056"/>created from simple types.</p>
<p class="callout-heading">Imagine a constant</p>
<p class="callout">If you want to remember constant values easily, think about some immutable values, such as the number of days in a week (<code>7</code>), the number of millimeters in a centimeter (<code>10</code>), the highest acceptable temperature value for a sensor (<code>90</code>), or the maximum number of iterations for your algorithm (<code>5</code>). None of these values can be changed after creation and can be defined as constants.</p>
<p>You can use the <code>const</code> keyword to create a constant value, as shown in the following line:</p>
<pre class="source-code">
<strong class="bold">const</strong> int DaysInWeek = 7;</pre> <p>Another<a id="_idIndexMarker057"/> interesting fact is that the constant expressions for which all operands are constant values of simple<a id="_idIndexMarker058"/> types are evaluated at compile time. This has<a id="_idTextAnchor031"/> a positive impact on the performance of your application.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor032"/>Enumerations</h2>
<p>Apart from the already mentioned types, the <a id="_idIndexMarker059"/>value types contain <strong class="bold">enumerations</strong>. <strong class="bold">Each has a set of </strong><strong class="bold">named constants</strong><strong class="bold"> to specify the available set </strong><strong class="bold">of </strong><strong class="bold"><a id="_idIndexMarker060"/></strong><strong class="bold">values</strong>.</p>
<p class="callout-heading">Imagine an enumeration</p>
<p class="callout">If you want to better visualize <a id="_idIndexMarker061"/>an enumeration, try to specify available colors for your car while configuring it (for example, black, white, gray, red, and yellow), languages supported by your app (for example, English, Polish, and German), or currencies in which you accept payments (for example, PLN, USD, and EUR). In all of these scenarios, there is a precisely defined list of available values to select, so they are good representatives of enumerations.</p>
<p>An example definition is as follows:</p>
<pre class="source-code">
<code>0</code>. This means that the <code>Pln</code> constant is equal to <code>0</code>, while <code>Eur</code> is equal to <code>2</code>. What’s more, the default value for the enumeration is <code>0</code>, which means that it is <code>Pln</code> in this case.</p>
<p>You can use the defined enumeration as a data type, as follows:</p>
<pre class="source-code">
CurrencyEnum currency = <strong class="bold">CurrencyEnum.Pln</strong>;
switch (currency)
{
    case <strong class="bold">CurrencyEnum.Pln</strong>: /* Polish zloty */ break;
    case <strong class="bold">CurrencyEnum.Usd</strong>: /* American Dollar */ break;
    <strong class="bold">default</strong>: /* Euro */ break;
}</pre> <p>Please keep in mind that if <a id="_idIndexMarker062"/>you place the preceding code in the <code>Program.cs</code> file – that is, the line containing the enumeration definition and then a few lines of code with the <code>switch</code> statement – you will receive an error stating <strong class="bold">Top-level statements must precede namespace and type declarations</strong>. This means that the<a id="_idIndexMarker063"/> declaration of the enumeration declaration must be placed at the end of the code, as shown here:</p>
<pre class="source-code">
CurrencyEnum currency = CurrencyEnum.Pln;
switch (currency)
{
    case CurrencyEnum.Pln: /* Polish zloty */ break;
    case CurrencyEnum.Usd: /* American Dollar */ break;
    default: /* Euro */ break;
}
<strong class="bold">enum CurrencyEnum { Pln, Usd, Eur };</strong></pre> <p>This note is not related to enumerations only as you could receive a similar error while using other types, such as records or classes. So, please remember the rule and <strong class="bold">place type declaration at the end</strong>, even if they are presented in this book before the remaining code.</p>
<p class="callout-heading">Should you add all the code to one file?</p>
<p class="callout">In simple exemplary applications, there’s nothing wrong with placing all the code within one file. However, if you are developing something even a bit more complex, I strongly encourage you to divide the whole solution into suitable projects, as well as to <strong class="bold">put various type declarations in separate files</strong>. When you need to create types (for example, enumerations, classes, or records) while reading the remaining parts of this book, it is assumed that you add them to new files. Each file should be named the same as the type that is declared within it. From my point of view, writing code has some similarities to creating art, so let’s try to <strong class="bold">write beautiful code that is not only correct and tested but also greatly arranged </strong><strong class="bold">and organized</strong>!</p>
<p>You can also <a id="_idIndexMarker064"/>benefit from more advanced features of enumerations, such as changing the <a id="_idIndexMarker065"/>underlying type or specifying values for particular constants. You can even do more and use the enumeration as a <strong class="bold">bit field</strong> – that is, as<a id="_idIndexMarker066"/> a set of <strong class="bold">flags</strong> – as presented here:</p>
<pre class="source-code">
<strong class="bold">[Flags]</strong>
enum <strong class="bold">ActionEnum</strong>
{
    None    = <strong class="bold">0b_0000_0000</strong>, // 0
    List    = <strong class="bold">0b_0000_0001</strong>, // 1
    Details = <strong class="bold">0b_0000_0010</strong>, // 2
    Add     = <strong class="bold">0b_0000_0100</strong>, // 4
    Edit    = <strong class="bold">0b_0000_1000</strong>, // 8
    Delete  = <strong class="bold">0b_0001_0000</strong>, // 16
    Publish = <strong class="bold">0b_0010_0000</strong>  // 32
}</pre> <p>Here, you can see the <code>ActionEnum</code> enumeration, which represents various actions that are allowed for users of the blog module, such as listing posts, showing details of a particular post, as well as adding, editing, deleting, and publishing a post. The constants have the following powers of two assigned, starting with <code>0</code> (<code>None</code>). The values are 20 (<code>1</code>), 21 (<code>2</code>), 22 (<code>4</code>), 23 (<code>8</code>), 24 (<code>16</code>), and 25 (<code>32</code>). These values are provided using the binary literal. Have you noticed that in each binary value, the <code>1</code>s are located in different places and everywhere there is only one <code>1</code>? Thanks to this, you can freely combine various flags, simply by using the <code>OR</code> binary operation, which is indicated by the <code>|</code> operator, as shown here:</p>
<pre class="source-code">
ActionEnum guest = ActionEnum.List;
ActionEnum user = <strong class="bold">ActionEnum.List | ActionEnum.Details</strong>;
ActionEnum editor = <strong class="bold">ActionEnum.List | ActionEnum.Add</strong>
    <code>List</code> and <code>Details</code> permissions to a user, the combined permission is equal to <code>00000011</code>. The admin with full access to the system has combined permission <a id="_idIndexMarker068"/>equal to <code>00111111</code>. Simple and efficient, isn’t it?</p>
<p>It’s worth mentioning that enumerations allow you to replace some <em class="italic">magical strings</em> (such as <code>Pln</code> or <code>Usd</code>) with constant values. This has a very positive impact on code quality. What’s more, it significantly simplifies refactoring, maintenance, and introducing changes in the code in the future.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor033"/>Value tuples</h2>
<p>The value tuple type is represented by the <code>System.ValueTuple</code> type and is <strong class="bold">a lightweight data structure that allows you to group multiple data elements of specific types</strong>. It has a very <a id="_idIndexMarker069"/>simple syntax, in which you just need to specify the<a id="_idIndexMarker070"/> types of all data members and, optionally, provide their names. All of the elements are public fields, so a tuple type is a <strong class="bold">mutable value type</strong>. What’s more, <strong class="bold">it is a very data-centric type, so you cannot even define methods </strong><strong class="bold">within it</strong>.</p>
<p class="callout-heading">Imagine a value tuple</p>
<p class="callout">If you want to understand a value tuple more easily, stop for a moment to think about the programming problem when you need to return a result from a method that consists of two or three values, such as a price in the chosen currency and the used conversion rate from the base currency, or a set of statistics consisting of minimum, maximum, and average values. As a solution, you can define a dedicated class, record, or struct and use it as a return type. However, this data structure will only be used once, and it will unnecessarily complicate the project and future changes. Another solution is to use <code>out</code> parameters for the method. However, such parameters cannot be used in all circumstances. To solve this problem, you can use a value tuple type and simply specify the types of data members that are returned from the method.</p>
<p>Even though the value<a id="_idIndexMarker071"/> tuple type seems to be straightforward, it can be used in various scenarios. Let’s take a<a id="_idIndexMarker072"/> look at the following code snippet, where we use a value tuple and specify the type of data members returned from the method:</p>
<pre class="source-code">
<strong class="bold">(int, int, double)</strong> result = Calculate(4, 8, 13);
Console.WriteLine($"Min = {<strong class="bold">result.Item1</strong>}
    / Max = {<code>Item1</code>, <code>Item2</code>, and <code>Item3</code> fields. The result is as follows:</p>
<pre class="console">
Min = 4 / Max = 13 / Avg = 8.33</pre> <p>If you don’t want to use <code>Item1</code>, <code>Item2</code>, and so on, you can change the code to specify the names of variables, as presented here:</p>
<pre class="source-code">
(int <strong class="bold">min</strong>, int <strong class="bold">max</strong>, double <strong class="bold">avg</strong>) = Calculate(4, 8, 13);
Console.WriteLine($"Min = {<strong class="bold">min</strong>} / Max = {<strong class="bold">max</strong>}
    / Avg = {<strong class="bold">avg</strong>:F2}");</pre> <p>Here, we’ll <strong class="bold">deconstruct</strong> a tuple by explicitly declaring the type and name of each field. If you execute the code, the result in the console will be the same as what it was previously. So far, you know how to get a result value that is a value tuple type, but how can you initialize it and return it from the method? Let’s take a look:</p>
<pre class="source-code">
<strong class="bold">(int, int, double)</strong> Calculate(params int[] numbers)
{
    if (numbers.Length == 0) { return <strong class="bold">(0, 0, 0)</strong>; }
    int min = int.MaxValue;
    int max = int.MinValue;
    int sum = 0;
    foreach (int number in numbers)
    {
        if (number &gt; max) { max = number; }
        if (number &lt; min) { min = number; }
        sum += number;
    }
    return <strong class="bold">(min, max, (double)sum / numbers.Length)</strong>;
}</pre> <p>You can further simplify<a id="_idIndexMarker073"/> the code and make it more readable by specifying an <strong class="bold">alias</strong> for this value tuple<a id="_idIndexMarker074"/> type. You can do so by using the following line of code:</p>
<pre class="source-code">
using Statistics = <strong class="bold">(int Min, int Max, double Avg)</strong>;</pre> <p>Then, it can be used in the remaining part of the code, as follows:</p>
<pre class="source-code">
<strong class="bold">Statistics</strong> Calculate(params int[] numbers)
{
    /* (...) */
    return (min, max, (double)sum / numbers.Length);
}</pre> <p>You can call the <code>Calculate</code> method as follows:</p>
<pre class="source-code">
<strong class="bold">Statistics</strong> result = Calculate(4, 8, 13);
Console.WriteLine($"Min = {<strong class="bold">result.Min</strong>} / Max = {<strong class="bold">result.Max</strong>}
    / Avg = {<strong class="bold">result.Avg</strong>:F2}");</pre> <p>Now that you understand how value tuples work, let’s move on to the next data type.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor034"/>User-defined structs</h2>
<p>Apart from using the previously mentioned value types, you can create <strong class="bold">data-centric struct types</strong> (also <a id="_idIndexMarker075"/>named <strong class="bold">structure types</strong>) and use them in your<a id="_idIndexMarker076"/> applications.</p>
<p class="callout-heading">Imagine a struct</p>
<p class="callout">If you want to better visualize <a id="_idIndexMarker077"/>a data-centric struct type, think about the readings that are obtained from a weather station. A single reading consists of the current values of temperature, pressure, and humidity. You can specify a type for such readings as a user-defined struct type with three immutable data members, namely for temperature, pressure, and humidity. Such values cannot be changed once you’ve received the results from the weather station.</p>
<p>Structs have some of the same capabilities as classes, which we’ll cover later. However, there are some differences – for example, a structure does not support inheritance. Despite the similarities to classes, you should only use structs in scenarios when a type does not provide behavior or provide it in a small amount.</p>
<p>This means that <code>readonly</code> modifier for the whole structure and all its data members, as shown here:</p>
<pre class="source-code">
public <strong class="bold">readonly struct</strong> Price
{
    public Price(decimal amount, CurrencyEnum currency)
    {
        Amount = amount;
        Currency = currency;
    }
    public <strong class="bold">readonly</strong> decimal Amount { get; <strong class="bold">init</strong>; }
    public <strong class="bold">readonly</strong> CurrencyEnum Currency { get; <strong class="bold">init</strong>; }
    public override string ToString()
        =&gt; $"{Amount} {Currency}";
}</pre> <p>Here, we define the <code>Price</code> immutable struct type, which has two auto-implemented read-only properties, specified using the <code>init</code> accessor. This allows us to set a value for such properties during the <a id="_idIndexMarker078"/>object’s construction and restrict later modifications. The struct type has also<a id="_idIndexMarker079"/> its own implementation of the <code>ToString</code> method, formatting the object as the amount and currency, separated by space. There is also a constructor with two parameters that sets the values of both properties.</p>
<p>You can make this code a bit shorter, as follows:</p>
<pre class="source-code">
public readonly struct Price(
    <strong class="bold">decimal amount, CurrencyEnum currency</strong>)
{
    public readonly decimal Amount { get; init; } <strong class="bold">= amount;</strong>
    public readonly CurrencyEnum Currency { get; init; }
        <strong class="bold">= currency;</strong>
    public override string ToString()
        =&gt; $"{Amount} {Currency}";
}</pre> <p>Don’t forget about the declaration of the <code>CurrencyEnum</code> enumeration, together with the <code>public</code> access modifier, as follows:</p>
<pre class="source-code">
public enum CurrencyEnum { Pln, Usd, Eur };</pre> <p>The usage of the <code>Price</code> struct is quite simple:</p>
<pre class="source-code">
Price priceRegular = new(100, CurrencyEnum.Pln);
Console.WriteLine(priceRegular);</pre> <p>The result that’s shown in the console is as follows:</p>
<pre class="console">
100 Pln</pre> <p>Since we’re talking about struct types, it is<a id="_idIndexMarker080"/> worth noting the <code>with</code><strong class="bold"> expression</strong><strong class="bold">, which allows you to create a copy of a structure type instance, together with changing values of some properties and fields</strong>. You can achieve this using the <strong class="bold">object initializer syntax</strong><strong class="bold"> while specifying</strong><strong class="bold"><a id="_idIndexMarker081"/></strong><strong class="bold"> which members should be modified and what values should be assigned</strong>. Let’s take a look at the following code:</p>
<pre class="source-code">
Price priceDiscount = priceRegular <code>priceRegular</code> instance and set the value of the <code>Amount</code> property to <code>50</code>. However, values of the remaining properties are the same as in the <code>priceRegular</code> instance, so <code>Currency</code> is set to <code>Pln</code>.</p>
<p>To conclude the topic <a id="_idIndexMarker083"/>of user-defined structs, it’s worth remembering that the default value for each of them is created by setting a<a id="_idTextAnchor035"/><a id="_idTextAnchor036"/>ll reference-type fields to <code>null</code> and all value-type fields to their default values.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor037"/>Nullable value types</h2>
<p>Now that we’ve come to<a id="_idIndexMarker084"/> the end of this section regarding value types, think about a scenario where you need to store either a particular value, such as a numeric one (for example, 154), or information that a value is not provided. One of the possible solutions<a id="_idIndexMarker085"/> is to use two variables. The first specifies whether the value is provided (the <code>bool</code> type), while the other stores a numeric value (for example, of the <code>int</code> type). However, is it possible to only use one variable instead of two? The answer is yes! To achieve this, you can use a <code>null</code> value.</p>
<p class="callout-heading">Imagine a nullable value type</p>
<p class="callout">If you want to understand nullable value types more easily, think about the scenario of calculating the age of a user of your portal. If the user provides you with their date of birth, the task is pretty simple. However, what about a situation when such a date is missing? You cannot calculate their age, so the age variable can be set to <code>null</code> instead of an integer value. Here, you can use the <code>int?</code> type.</p>
<p>As for its implementation, you can use the <code>?</code> operator just after a type name or use the <code>System.Nullable&lt;T&gt;</code> structure, which has the same effect, as shown here:</p>
<pre class="source-code">
<strong class="bold">int?</strong> age = 34;
<strong class="bold">float?</strong> note = 5.5f;
<code>null</code>, you can compare it <a id="_idIndexMarker087"/>with <code>null</code> or use the <code>HasValue</code> property. Then, you can get a value using the <code>Value</code> property, as presented here:</p>
<pre class="source-code">
if (age <strong class="bold">!= null</strong>) { Console.WriteLine(age.<strong class="bold">Value</strong>); }
if (note.<code>??</code>)<code>GetValueOrDefault</code> method. Examples for both are shown here:</p>
<pre class="source-code">
int chosenAge = age <strong class="bold">??</strong> 18;
float shownNote = note.<code>age</code> variable is not <code>null</code>, it is assigned to <code>chosenAge</code>. Otherwise, <code>18</code> is set. In the second line of code, the <code>note</code> value is assigned to <code>shownNote</code> if it is not <code>null</code>. Otherwise, <code>5.0f</code> is applied. Seems simple, doesn’t it?</p>
<p>While talking about the null-coalescing operator (<code>??</code>), you should <a id="_idIndexMarker089"/>also take a look at the <code>??=</code>. <code>??</code> operator, as presented in the following code:</p>
<pre class="source-code">
DateTime date = new(1988, 11, 9);
int? age = GetAgeFromBirthDate(date);
<strong class="bold">age ??= 18; // The same as: age = age ?? 18</strong>;
int? GetAgeFromBirthDate(DateTime date)
{
    double days = (DateTime.Now - date).TotalDays;
    return days &gt; 0 ? (int)(days / 365) : null;
}</pre> <p>Since we’re presenting various <code>null</code>-related <a id="_idIndexMarker090"/>operators, let’s introduce the <strong class="bold">null conditional operator</strong> as well. <strong class="bold">It is represented by the </strong><strong class="bold">?.</strong><strong class="bold"> operator and returns </strong><strong class="bold">null</strong><strong class="bold"> if the left-hand side operand is </strong><strong class="bold">null</strong><strong class="bold">. Otherwise, it is used as a standard dot operator</strong>. An example is as follows:</p>
<pre class="source-code">
string? GetFormatted(float? number)
    =&gt; number<code>GetFormatted</code> method<a id="_idIndexMarker091"/> returns <code>null</code> if <code>null</code> is provided as the <code>number</code> parameter. Otherwise, it returns the number formatted using the specified format.</p>
<p>Don’t forget that a default value<a id="_idIndexMarker092"/> for<a id="_idTextAnchor038"/> a nullable value type represents <code>null</code>. This means that the <code>HasValue</code> property returns <code>false</code>.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor039"/>Reference types</h1>
<p>The second main group of types is <code>object</code>, <code>string</code>, <code>delegate</code>, and <code>dynamic</code>. Moreover, you can declare <strong class="bold">classes</strong>, <strong class="bold">records</strong>, and <strong class="bold">interfaces<a id="_idTextAnchor040"/></strong>. <strong class="bold">Nullable reference <a id="_idTextAnchor041"/>types</strong> exist as well. All of these types will be described in this section. Let’s get started!</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor042"/>Objects</h2>
<p>The <code>Object</code> class (the <code>object</code> alias) is declared in the <code>System</code> namespace and performs an important role while developing applications in C#. Why? Because all other types in the <code>Object</code>. This means that built-in value types, built-in reference types, as well as user-defined value types and<a id="_idIndexMarker095"/> user-defined reference types, are derived from the <code>Object</code> class.</p>
<p class="callout-heading">Imagine an object</p>
<p class="callout">If you want to understand the object type more easily, think about it as “<em class="italic">something</em>.” As everything is “<em class="italic">something</em>,” everything is an object. Representatives of various value types and reference types are objects. Oh no – objects are everywhere around you! ;-)</p>
<p>Let’s take a look at a set of <a id="_idIndexMarker096"/>methods that are available for all objects:</p>
<ul>
<li><code>ToString</code> returns a string representation of the object</li>
<li><code>GetType</code> returns a type of the instance</li>
<li><code>Equals</code> checks whether the object is equal to a given object</li>
<li><code>GetHashCode</code> uses the hash function and returns its result</li>
</ul>
<p>As the <code>Object</code> type is the base entity for all value types, this means that it is possible to convert a variable of any value type (for example, <code>int</code> or <code>float</code>) into the <code>object</code> type, as well as to convert a variable of the <code>object</code> type into a <a id="_idIndexMarker097"/>specific value type. Such operations are <a id="_idIndexMarker098"/>named <strong class="bold">boxing</strong> (the first) and <strong class="bold">unboxing</strong> (the<a id="_idTextAnchor043"/> other), as shown here:</p>
<pre class="source-code">
int age = 28;
object ageBoxing = age;
int ageUnboxing = <code>ageBoxing</code> to <code>bool</code> instead of <code>int</code>, the code compiles without any errors. However, it fails at runtime with a <code>System.InvalidCastException</code> error. The additional message informs you that it is impossible to cast an object of the <code>System.Int32</code> type to the <code>System.Boolean</code> type.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor044"/>Strings</h2>
<p>There is often a necessity to store<a id="_idIndexMarker099"/> some text values. You can achieve this using the <code>String</code> built-in reference type from the <code>System</code> namespace, which is also available using the <code>string</code> keyword. The <code>string</code> type is <code>string</code> variable can be set to <code>null</code>.</p>
<p class="callout-heading">Imagine a string</p>
<p class="callout">If you want to better visualize a string, take a look at this sentence. It is a string! Your first name is a string too. Close this book for a moment and take a look out of your window. The name of your street is a string. That’s not all – even a car number plate is a string. It is one of the most common types that you’ll use frequently while developing applications, so please read this chapter and this book carefully since all the text in this book is a string as well!</p>
<p>You can perform various operations on <code>string</code> objects, such as <code>[]</code> operator, as shown here:</p>
<pre class="source-code">
string firstName = "Marcin", lastName = "Jamro";
int year = 1988;
string note = firstName + " " + lastName.ToUpper()
   + " was born in " + year;
string initials = firstName[0] + "." + lastName[0] + ".";</pre> <p>First, the <code>firstName</code> variable is declared, and the <code>Marcin</code> value is assigned to it. Similarly, <code>Jamro</code> is set as a value of the <code>lastName</code> variable. In the third line, we concatenate five elements (using the <code>+</code> operator), namely the current value of <code>firstName</code>, the space, the current value of <code>lastName</code> converted into uppercase (by calling <code>ToUpper</code>), the <code>was born in</code> string (with additional spaces), and the current value of <code>year</code>. In the last line, the first characters of the <code>firstName</code> and <code>lastName</code> variables are obtained using the <code>[]</code> operator, as well as concatenated with two dots to form the initials – that is, <code>M.J.</code> – which are stored as a value of the <code>initials</code> variable.</p>
<p>The <code>Format</code> method can also be used for constructing this string, as shown here:</p>
<pre class="source-code">
string note = string.Format("<strong class="bold">{0}</strong> <strong class="bold">{1}</strong> was born in <strong class="bold">{2}</strong>",
    firstName, lastName.ToUpper(), year);</pre> <p>In this example, we specify <a id="_idIndexMarker101"/>the <code>firstName</code> (represented by <code>{0}</code>), uppercase <code>lastName</code> (<code>{1}</code>), and <code>year</code> (<code>{2}</code>). The objects to format are specified as the following parameters of the method.</p>
<p>It is also worth<a id="_idIndexMarker102"/> mentioning the <code>$</code> character should be placed before <code>"</code>, as shown in the following example:</p>
<pre class="source-code">
string note = <strong class="bold">$"{firstName} {lastName.ToUpper()}</strong>
   was born in <code>,10</code> value for the minimum 10 characters and right alignment, as well as a negative <code>,-10</code> value for the minimum 10 characters and left alignment) or the <code>:F2</code> for a floating-point number with two digits after a comma or <code>:HH:mm</code> for presenting an hour with minutes).</p>
<p>Here’s some example code:</p>
<pre class="source-code">
string[] names = ["Marcin", "Adam", "Martyna"];
DateTime[] dates = [new(1988, 11, 9), new(1995, 4, 25),
    new(2003, 7, 24)];
float[] temperatures = [36.6f, 39.1f, 35.9f];
Console.WriteLine($<strong class="bold">"{"Name",-8} {"Birth date",10}</strong>
    <strong class="bold">{"Temp. [C]",11} -&gt; Result"</strong>);
for (int i = 0; i &lt; names.Length; i++)
{
    string line = $<strong class="bold">"{names[i],-8} {dates[i],10:dd.MM.yyyy}</strong>
        <strong class="bold">{temperatures[i],11:F1}</strong> -&gt; <strong class="bold">{</strong>
        <strong class="bold">temperatures[i] switch</strong>
<strong class="bold">        {</strong>
<strong class="bold">            &gt; 40.0f =&gt; "Very high",</strong>
<strong class="bold">            </strong><strong class="bold">&gt; 37.0f =&gt; "High",</strong>
<strong class="bold">            &gt; 36.0f =&gt; "Normal",</strong>
<strong class="bold">            &gt; 35.0f =&gt; "Low",</strong>
<strong class="bold">            _ =&gt; "Very low"</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }"</strong>;
    Console.WriteLine(line);
}</pre> <p>This example presents <a id="_idIndexMarker106"/>a simple table with body temperatures for three people, namely <code>Marcin</code>, <code>Adam</code>, and <code>Martyna</code>, together with their birth dates. The alignments (for example, <code>-8</code>) and<a id="_idIndexMarker107"/> format strings (for example, <code>dd.MM.yyyy</code>) are used. What’s more, the <code>&gt; 40.0f</code>), high (<code>&gt; 37.0f</code>), normal (<code>&gt; 36.0f</code>), low (<code>&gt; 35.0f</code>), or very low. The latter is the final case and<a id="_idIndexMarker110"/> is also called the <code>_</code> and matches all other values.</p>
<p>When you execute this code, you’ll see the following result:</p>
<pre class="console">
Name     Birth date   Temp. [C] -&gt; Result
Marcin   09.11.1988        36.6 -&gt; Normal
Adam     05.04.1995        39.1 -&gt; High
Martyna  24.07.2003        35.9 -&gt; Low</pre> <p>As you can see, the C# language is equipped with various possibilities, even related to just the <code>string</code> type. What’s more, you can combine different features, such as the interpolation string with the <code>switch</code> statement and pattern matching to create code that is easy to understand and maintain.</p>
<p>However, you should keep in mind that <code>string</code> is not a typical reference type and its behavior is a bit different<a id="_idIndexMarker112"/> than in the case of other reference types. You can see such a difference while <a id="_idIndexMarker113"/>comparing two <code>string</code> variables using the <code>==</code> operator. Here, two <code>string</code> instances are the<a id="_idTextAnchor045"/><a id="_idTextAnchor046"/><a id="_idTextAnchor047"/> same if they contain the same sequence of characters, so it is a similar behavior as in the case of value types.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor048"/>Classes</h2>
<p>As mentioned <a id="_idIndexMarker114"/>previously, C# is an object-oriented language and supports declaring classes together with various members, including <code>public</code>, <code>protected</code>, <code>internal</code>, <code>private</code>, and <code>file</code>. These <a id="_idIndexMarker116"/>access modifiers are mentioned together with classes, but you should remember that they can be used for some other types as well.</p>
<p class="callout-heading">Imagine a class</p>
<p class="callout">If you want to visualize a class, think about a vehicle. Each vehicle has some properties, namely brand, model, color, length, width, height, and weight. A vehicle can perform some actions, such as taking a given distance. You can also define more specific variants of vehicles, such as a car, a plane, and a boat. Each has the same properties as the base vehicle, as well as has some additional ones, such as a number plate and a fuel type (for example, petrol, diesel, or electric) for a car. It also has the action of a door opening. You can also create instances of such classes – for example, you can create three instances of a car that differ by model and number plate, as well as create an instance of a plane. Then, you can perform actions on such instances.</p>
<p>An example class is shown here:</p>
<pre class="source-code">
public class <strong class="bold">Person</strong>
{
    private string <strong class="bold">_location</strong> = string.Empty;
    public string <strong class="bold">Name</strong> { get; set; }
    public required int <strong class="bold">Age</strong> { get; set; }
    public <strong class="bold">Person</strong>() =&gt; Name = "---";
    public <strong class="bold">Person</strong>(string name)
    {
        Name = name;
    }
    public void <strong class="bold">Relocate</strong>(string location)
    {
        if (!string.IsNullOrEmpty(location))
        {
            _location = location;
        }
    }
    public float <strong class="bold">GetDistance</strong>(string location)
        =&gt; DistanceHelpers.GetDistance(_location, location);
}</pre> <p>The <code>Person</code> class contains the <code>_location</code> private field with the default value set to an empty string (<code>string.Empty</code>) and two public <code>Name</code> and <code>Age</code>). You will use the <a id="_idIndexMarker117"/>properties quite often while writing the <a id="_idIndexMarker118"/>code examples shown in this book, so let’s stop for a moment to explain them.</p>
<p>Each property is a member of a class that provides a mechanism for reading and writing using <strong class="bold">accessors</strong>:</p>
<ul>
<li><code>get</code> to return the property value</li>
<li><code>set</code> to assign a new value for the property</li>
<li><code>init</code> to set a value during object construction and prevent modifications</li>
</ul>
<p>By combining such accessors, a property can be put in one of the following instances:</p>
<ul>
<li><code>get</code> accessor and without the <code>set</code> accessor</li>
<li><code>set</code> accessor and without the <code>get</code> accessor</li>
<li><code>get</code> and <code>set</code> accessors</li>
</ul>
<p>Another interesting feature is a required variant of the property, which is specified by the <code>required</code> keyword placed just after the access modifier, as shown in the case of the <code>Age</code> property. It requires<a id="_idIndexMarker120"/> that the client code initializes the property, and it is a good idea to mark properties as <code>required</code> if they should be initialized at the beginning of using the class instance. It is also worth noting that a property has an accessibility level as one of the access modifiers, including <code>public</code> and <code>private</code>.</p>
<p>Let’s take a closer look at the example class:</p>
<ul>
<li>It contains a default constructor that<a id="_idIndexMarker121"/> sets a value of the <code>Name</code> property to <code>---</code> using the <strong class="bold">expression </strong><strong class="bold">body definition</strong>.</li>
<li>It contains a constructor that takes one parameter and sets the value of the <code>Name</code> property.</li>
<li>It contains the <code>Relocate</code> method, which updates the value of the private field.</li>
<li>It contains the <code>GetDistance</code> method, which calls the <code>GetDistance</code> static method from the <code>DistanceHelpers</code> class and returns the distance between two cities provided in kilometers. The implementation of the helper class is not shown in the preceding code. Note that if you are curious about how you can create a real implementation of the mechanism for calculating the distance between cities, you can take a look at <a href="B18069_08.xhtml#_idTextAnchor296"><em class="italic">Chapter 8</em></a>, <em class="italic">Exploring Graphs</em>, where such an application of graphs will be mentioned.</li>
</ul>
<p>You can create an instance of the class using the <code>new</code> operator. Then, you can perform various operations on the object that’s been created, such as calling a method, as shown here:</p>
<pre class="source-code">
Person person = <strong class="bold">new</strong>("Martyna") { Age = 20 };
person.<strong class="bold">Relocate</strong>("Rzeszow");
float distance = person.<strong class="bold">GetDistance</strong>("Warsaw");</pre> <p>As the C# language is <a id="_idIndexMarker122"/>still being developed and improved, new amazing features were introduced in the following versions and are related to classes as well. For example, with the<a id="_idIndexMarker123"/> newest version, you can use some concepts that make it possible to significantly limit the amount of code. The following code shows some of them:</p>
<pre class="source-code">
public class <strong class="bold">Person</strong>(string name)
{
    private string <strong class="bold">_location</strong> = string.Empty;
    public string <strong class="bold">Name</strong> { get; set; } = name;
    public required int <strong class="bold">Age</strong> { get; set; }
    public void <strong class="bold">Relocate</strong>(string? location) =&gt;
        _location = location ?? _location;
    public float <strong class="bold">GetDistance</strong>(string location) =&gt;
        DistanceHelpers.GetDistance(_location, location);
}</pre> <p>The preceding code performs almost the same role as the previous variant, but it is even shorter. If you also like such improvements, keep reading – you will see various possibilities o<a id="_idTextAnchor049"/><a id="_idTextAnchor050"/>f the C# language<a id="_idIndexMarker124"/> in the remaining chapters of this book.</p>
<p>Let’s proceed to<a id="_idIndexMarker125"/> the next section, which is dedicated to records.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor051"/>Records</h2>
<p>In the recent versions of the C# language, another great reference type was introduced: <code>record</code> or <code>record </code><code>class</code> keyword.</p>
<p class="callout-heading">Value type records exist as well</p>
<p class="callout">It is worth noting that <code>record struct</code> construction<a id="_idIndexMarker128"/> exists as well. This construction represents a value type with similar functionality. However, in this book, I’ll focus on the reference type version only. Of course, you can try another version on your own.</p>
<p>One great thing about records is that a smaller amount of code needs to be written because the compiler automatically generates the public <code>init</code>-only properties (called <code>Deconstruct</code> method with a set of <code>out</code> parameters, each one representing a positional parameter. <strong class="bold">This means that this data type is data-centric and is intended to be immutable, providing a short and </strong><strong class="bold">clear syntax.</strong></p>
<p class="callout-heading">Imagine a record</p>
<p class="callout">If you want to visualize a record, stand up and take a look at yourself in your mirror, focusing on your beautiful T-shirt. It has some properties, such as size (for example, S, M, or L), color (for example, white or red), and brand. All of these properties are immutable, so you cannot change them as you cannot resize your favorite T-shirt since it is produced. So, as your nice T-shirt is data-centric and its properties are immutable, it is a good representative of a record. Smile to yourself in your mirror and come back to reading the first chapter of this book!</p>
<p>Let’s take a look <a id="_idIndexMarker131"/>at the following example of a record declaration:</p>
<pre class="source-code">
public record <strong class="bold">Dog</strong>(string Name, string Breed, int Height,
    float Weight, int Age);</pre> <p>That’s all! Now, you have a record with five immutable properties (<code>Name</code>, <code>Breed</code>, <code>Height</code>, <code>Weight</code>, and <code>Age</code>), as well as a constructor with five parameters related to the positional parameters on the record declaration. You can use it to create a new instance, as shown in the following line of code:</p>
<pre class="source-code">
Dog rex = <code>ToString</code> method, which is a nice feature while debugging because you can easily see the values of all properties. To see how it works, add the following line of code:</p>
<pre class="source-code">
Console.WriteLine(rex);</pre> <p>The result is as follows:</p>
<pre class="console">
Dog { Name = Rex, Breed = Schnauzer, Height = 40,
    Weight = 11, Age = 5 }</pre> <p>As you can see, the name of the record is shown, together with the names and values of the following properties. Please keep in mind that properties are defined with <code>get</code> and <code>init</code> accessors, so their values can be read and cannot be changed after they are initialized. So, the following line will cause a compiler error:</p>
<pre class="source-code">
rex.Name = "Puppy";</pre> <p>If you want to change this behavior, you can do so with a record without positional parameters on the record declaration, but by defining the particular properties using the standard syntax, as shown here:</p>
<pre class="source-code">
public record <strong class="bold">Dog</strong>
{
     public required string <strong class="bold">Name</strong> { get; set; }
     public required string <strong class="bold">Breed</strong> { get; set; }
     public required int <strong class="bold">Height</strong> { get; set; }
     public required float <strong class="bold">Weight</strong> { get; set; }
     public required int <strong class="bold">Age</strong> { get; set; }
}</pre> <p>Another useful feature is a<a id="_idIndexMarker133"/> clear syntax for <code>with</code> expression, as shown here:</p>
<pre class="source-code">
Dog beauty = rex <code>Beauty</code> is created, based on <code>Rex</code>. All of the values of the properties are taken from <code>Rex</code>, apart from <code>Name</code> and <code>Height</code>, as specified after the <code>with</code> keyword. You also need to remember that you can adjust both positional properties and properties created using the standard syntax that have the <code>init</code> or <code>set</code> accessor. In such a case, a <strong class="bold">shallow copy</strong> is created, so for value types, a copy is used, while for reference types, only a reference is copied, so both a source and a target property will reference the same instance of a reference type.</p>
<p>Let’s take a look at the following line:</p>
<pre class="source-code">
<code>Name</code> and <code>Age</code> positional properties, ignoring others using <code>_</code>. As you <a id="_idIndexMarker136"/>can see, records are equipped with a lot of useful features, but there are even more of them, such as the support for inheritance.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor052"/>Interfaces</h2>
<p>Previously, we mentioned classes. They can implement one or more <strong class="bold">interfaces</strong>. This means that such a class must implement all methods, properties, events, and indexers that are specified in all<a id="_idIndexMarker137"/> implemented interfaces.</p>
<p class="callout-heading">Imagine an interface</p>
<p class="callout">If you want to remember what an <a id="_idIndexMarker138"/>interface is, think about various things that you have on yourself, including a shirt, pants, and a watch. As all of these things have different sets of properties, you can create a dedicated class for each of them. However, how can you indicate which things can be worn and which can be washed in a washing machine? You can mark various classes with special indicators, such as “wearable” and “washable.” This is where interfaces come to the rescue! You can create <code>IWearable</code> and <code>IWashable</code> interfaces. Then, you can implement <code>IWearable</code> by <code>Shirt</code>, <code>Pants</code>, and <code>Watch</code>, as well as implement <code>IWashable</code> by <code>Shirt</code> and <code>Pants</code> only. You can also require that everything washable must have a property regarding a maximum temperature for washing in a washing machine. Looks nice, doesn’t it? But that’s not all – you can also create a class regarding a washing machine with the <code>Wash</code> method, which takes the <code>IWashable</code> parameter, so you can pass <code>Shirt</code> or <code>Pants</code>. No watches are allowed here! Is this magic?</p>
<p>You can easily define interfaces in the C# language using the <code>interface</code> keyword:</p>
<pre class="source-code">
public interface <strong class="bold">IDevice</strong>
{
    string <strong class="bold">Model</strong> { get; set; }
    string <strong class="bold">Number</strong> { get; set; }
    int <strong class="bold">Year</strong> { get; set; }
    void <strong class="bold">Configure</strong>(DeviceConfiguration configuration);
    bool <strong class="bold">Start</strong>();
    bool <strong class="bold">Stop</strong>();
}</pre> <p>The <code>IDevice</code> interface contains three properties representing the following:</p>
<ul>
<li>A device model (<code>Model</code>)</li>
<li>A serial number (<code>Number</code>)</li>
<li>A production year (<code>Year</code>).</li>
</ul>
<p>What’s more, it contains the signatures of three methods:</p>
<ul>
<li><code>Configure</code> for device setup. Please note that the <code>DeviceConfiguration</code> class is missing <a id="_idIndexMarker139"/>here, so try to prepare it on your own.</li>
<li><code>Start</code> for starting the<a id="_idIndexMarker140"/> operation.</li>
<li><code>Stop</code> for stopping the operation.</li>
</ul>
<p>When a class implements the <code>IDevice</code> interface, it should contain all of these properties and methods, as presented in the following code snippet:</p>
<pre class="source-code">
public class <strong class="bold">Display</strong>
    : <strong class="bold">IDevice</strong>
{
    public string <strong class="bold">Model</strong> { get; set; }
    public string <strong class="bold">Number</strong> { get; set; }
    public int <strong class="bold">Year</strong> { get; set; }
    <strong class="bold">public int Diagonal { get; set; }</strong>
    public void <strong class="bold">Configure</strong>(
        DeviceConfiguration configuration) { (...) }
    public bool <strong class="bold">Start</strong>() { (...) }
    public bool <strong class="bold">Stop</strong>() { (...) }
}</pre> <p>As you can see, the <code>Display</code> class contains all of the properties and methods specified in the interface <a id="_idTextAnchor053"/><a id="_idTextAnchor054"/><a id="_idTextAnchor055"/><a id="_idTextAnchor056"/><a id="_idTextAnchor057"/><a id="_idIndexMarker141"/>it implements. However, you can add more elements to the class according to your <a id="_idIndexMarker142"/>preferences, such as the <code>Diagonal</code> property in this example.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor058"/>Delegates</h2>
<p>The <code>delegate</code> reference<a id="_idIndexMarker143"/> type <strong class="bold">specifies the required signature of </strong><strong class="bold">a method</strong>.</p>
<p class="callout-heading">Imagine a delegate</p>
<p class="callout">If you want to understand what a delegate type is, think about various ways of calculating the mean of three <a id="_idIndexMarker144"/>numbers. You can get it as an arithmetic mean, as a geometric mean, as a harmonic mean, or even as a root mean square or a power mean. However, in all of these cases, you need a function that takes three parameters (for three numbers) and returns a number as the result. In this case, you can understand a delegate as a template for a way of calculating any of the mentioned means. Then, you can prepare an exact implementation of each calculation.</p>
<p>The delegate could then be instantiated, as well as invoked, as shown here:</p>
<pre class="source-code">
<strong class="bold">Mean</strong> arithmetic = (a, b, c) =&gt; (a + b + c) / 3;
<strong class="bold">Mean</strong> geometric = delegate (double a, double b, double c)
    { return Math.Pow(a * b * c, 1 / 3.0); };
<strong class="bold">Mean</strong> harmonic = Harmonic;
double a = arithmetic.<strong class="bold">Invoke</strong>(5, 6.5, 7);
double g = geometric.<strong class="bold">Invoke</strong>(5, 6.5, 7);
double h = harmonic.<strong class="bold">Invoke</strong>(5, 6.5, 7);
Console.WriteLine($"{a:F2} / {g:F2} / {h:F2}");
double Harmonic(double a, double b, double c) =&gt;
    3 / ((1 / a) + (1 / b) + (1 / c));
<code>Mean</code> delegate specifies the required signature of a method for calculating a mean <a id="_idIndexMarker145"/>value of three <a id="_idIndexMarker146"/>floating-point numbers. It is instantiated with the following:</p>
<ul>
<li>A <code>arithmetic</code>)</li>
<li>An <code>geometric</code>)</li>
<li>A <code>harmonic</code>)</li>
</ul>
<p>Each delegate is invoked by calling the <code>Invoke</code> method. The results are presented in the console, as follows:</p>
<pre class="console">
6.17 / 6.10 / 6.04</pre> <p>Here, the Lambda expression is shown, so it is a good idea to tell you a bit more about such a construction. It uses the <code>=&gt;</code> operator, which separates the input parameters and the <code>(a, b, c)</code>. They are<a id="_idIndexMarker147"/> the same as the parameters of the delegate. On the right-hand side, there is the Lambda body, which calculates the result as a sum of inputs divided by 3. While develo<a id="_idTextAnchor059"/>ping applications in C#, you will use Lambda expressions quite often and it is a nice feature that can have a positive impact on your code quality.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor060"/>Dynamics</h2>
<p>Apart from the types we’ve already described, <code>dynamic</code> is available for developers. <strong class="bold">It allows you to bypass type checking during compilation so that you can perform it during runtime.</strong> Such a<a id="_idIndexMarker148"/> mechanism can be useful while <a id="_idIndexMarker149"/>you’re accessing<a id="_idIndexMarker150"/> some types of <strong class="bold">application programming </strong><strong class="bold">interfaces</strong> (<strong class="bold">APIs</strong>).</p>
<p class="callout-heading">Imagine a dynamic type</p>
<p class="callout">If you want to better visualize a dynamic type, ask someone nearby to put a blindfold on you and then give you a set of instructions on how to move from one room to another and sit in a chair – for example, walk 5 steps forward, turn right, walk 10 steps forward, and then sit down. If the instructions are correct, you will go to the other room and sit comfortably in the chair. However, if anything is wrong, you won’t know this by listening to all the instructions at the beginning, only when you hit a wall or sit on the floor instead of in the chair. This situation is somewhat similar to using dynamic types. If the instructions are correct, the application will work correctly, but if something is wrong, it may hurt. ;-)</p>
<p>You will not use<a id="_idIndexMarker151"/> the <code>dynamic</code> type while reading this book. However, to provide a short introduction to this feature, take<a id="_idIndexMarker152"/> a look at the code:</p>
<pre class="source-code">
<strong class="bold">dynamic</strong> posts = await GetPostsAsync();
foreach (<strong class="bold">dynamic</strong> post in posts)
{
    string title = post.<strong class="bold">title</strong>;
    Console.WriteLine($"Title: {title}");
}
Task&lt;<code>GetPostsAsync</code> method. The result is assigned to the <code>posts</code> variable with the <code>dynamic</code> type. Thus, we bypass <code>dynamic</code> type allows you to significantly limit the amount of code, but it should be used with caution.</p>
<p class="callout-heading">Strongly typed features are cool!</p>
<p class="callout">The strongly typed features of the C# language give you great development support. Both errors and warnings are useful as they help you make your code robust and more reliable. Remember that warnings are not something that should exist in the production version of your application. You should always try to decrease the number of warnings to zero, as well as take into account various hints provided by the IDE.</p>
<p>In the preceding code, the <code>await</code> keyword<a id="_idIndexMarker154"/> is used. It is related to <code>async</code> keyword. The <code>await</code> operator is placed in the line where the <code>GetPostsAsync</code> method is called. This means that the evaluation of the code is suspended until the <a id="_idIndexMarker155"/>asynchronous operation of getting posts from an external API is completed. Then, the <code>await</code> operator returns the collection of posts.</p>
<p class="callout-heading">Asynchronous programming is cool too!</p>
<p class="callout">Asynchronous programming is a very interesting and powerful topic and is crucial for the development of robust and highly efficient applications. This topic also involves the <code>ConcurrentQueue</code>, which will be covered in <a href="B18069_05.xhtml#_idTextAnchor165"><em class="italic">Chapter 5</em></a>, <em class="italic">Stacks and Queues</em>), as well as some <strong class="bold">synchronization primitives</strong>.</p>
<p>Are you ready to proceed to the last type that will be described in this chapter? If so, let’s go!</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor061"/>Nullable reference types</h2>
<p>Now that we’ve come to the end of this section <a id="_idIndexMarker157"/>regarding reference types, let’s take a look at <code>System.NullReferenceException</code> type. It is thrown when you access one of the members of a variable using the dot operator (<code>.</code>), when a variable is <code>null</code>. When using a new feature, you can explicitly mark a reference type as nullable using the <code>?</code> operator, similarly as in the case of nullable value types.</p>
<p class="callout-heading">Imagine a nullable reference type</p>
<p class="callout">If you want to understand what nullable reference types are, just remind yourself that reference types allow <code>null</code> values. So, why am I talking about nullable reference types? They are a special feature that tells you “<em class="italic">Be careful, it could be null!</em>” Using nullable reference types could sometimes seem to be an unnecessary complication for reference types. However, when using them for a longer period, you will see that they have a positive impact on your code’s quality and allow you to pay more attention to null reference issues and therefore could limit the number of errors while the program is running. I recommend that you familiarize yourself with this feature, even if it can be quite cumbersome at the beginning. I like it! What about you?</p>
<p>This feature is equipped with <code>null</code>, so the mechanism emits a warning that can be solved by <a id="_idIndexMarker160"/>you. The first solution is to add a conditional statement that checks whether the<a id="_idIndexMarker161"/> value is not equal to <code>null</code>. Another way is to use the <code>!</code>), when you are certain that the variable is not <code>null</code> here.</p>
<p>Let’s take a look at an example:</p>
<pre class="source-code">
Random random = new();
List&lt;<strong class="bold">Measurement?</strong>&gt; measurements = [];
for (int i = 0; i &lt; 100; i++)
{
    <strong class="bold">Measurement?</strong> measurement = random.Next(3) != 0
        ? new(DateTime.Now, random.Next(1000) / 1000.0f)
        : null;
    measurements.Add(measurement);
    Console.WriteLine(IsValid(measurement)
        ? <strong class="bold">measurement!</strong>.ToString()
        : "-");
    await Task.Delay(100);
}
static bool IsValid(<strong class="bold">Measurement?</strong> measurement)
{
    return measurement != null
        &amp;&amp; measurement.Value &gt;= 0.0f
        &amp;&amp; measurement.Value &lt;= 1.0f;
}
public record <code>null</code>, if the measurement is not received correctly from some external device. Within the <code>for</code> loop, we simulate <a id="_idIndexMarker162"/>getting a measurement by using the <code>Random</code> class. Statistically, about 2/3 of total measurements are retrieved correctly (the <code>Measurement</code> instance<a id="_idIndexMarker163"/> is then created) and the remaining 1/3 of total measurements are not retrieved (<code>null</code> is used instead). Such values are added to the <code>measurements</code> list. Then, we need to check whether the obtained reading is correct – that is, apart from being provided, its value is within the range of <code>&lt;0.0, 1.0&gt;</code>. We perform this check using the <code>IsValid</code> static method while taking the nullable <code>Measurement</code> instance as a parameter.</p>
<p>Finally, we just need to show information about a reading in the console. For the correct reading, we present a formatted value of the <code>Measurement</code> instance. Otherwise, we use a dash (<code>-</code>). However, if we write <code>measurement.ToString()</code>, we will receive a warning stating “<em class="italic">Dereference of a possibly null reference</em>” because the compiler does not know that we’re checking whether the measurement is not <code>null</code> within the <code>IsValid</code> method. We can avoid this warning using the null-forgiving operator by adding the <code>!</code> sign just after the variable name, before calling the <code>ToString</code> method. A small explanation may also be required for the line containing the <code>Delay</code> method call. It is only used to simulate the real behavior of the device, from which we read a measurement each 100 ms.</p>
<p>As you can see, both nullable value types and nullable reference types provide you with very similar semantics (such as <code>bool?</code> for a <a id="_idIndexMarker164"/>nullable value type and <code>string?</code> for a nullable reference type), but they are implemented in other ways. A nullable value type uses <code>System.Nullable&lt;T&gt;</code> internally (for example, <code>System.Nullable&lt;System.Boolean&gt;</code> for <code>bool?</code>), while a non-nullable value type uses another type (just <code>System.Boolean</code> for <code>bool</code>). The nullable reference type uses the same type for both nullable and non-nullable variants. This means that <code>string?</code> and <code>string</code> are provided by the <code>System.String</code> class in both cases.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor062"/>Summary</h1>
<p>This was only the first chapter of this book, but it contained quite a lot of information that will be useful while you’re reading the remaining ones. First, the <strong class="bold">C# programming language</strong> was briefly presented with a focus on showing various data types, both value and reference ones. You learned the difference between them and why understanding this difference is so important while developing applications.</p>
<p>Next, you saw various <strong class="bold">value types</strong>, including the built-in ones, such as integral numeric types, floating-point numeric types, Boolean type, and Unicode characters. Then, you learned about constants, enumerations, value tuples, user-defined struct types, and nullable value types. All of these were equipped with detailed descriptions, as well as some code examples to make understanding easier and faster.</p>
<p>Finally, you learned about the second group of types, namely <strong class="bold">reference types</strong>. Here, you saw the object and string types, classes, records, interfaces, as well as delegate and dynamic types. Then, you learned about nullable reference types. Again, a lot of information was supported by explanations and some code fragments.</p>
<p>With this introduction, you should be ready to proceed to the next chapter and learn <strong class="bold">what algorithms are and why they are so important</strong>. Let’s go!</p>
</div>
</body></html>