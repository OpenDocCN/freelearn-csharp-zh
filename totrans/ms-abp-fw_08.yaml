- en: '*Chapter 6*: Working with the Data Access Infrastructure'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all business applications use a kind of database system. We typically
    implement data access logic to read data from and write data to a database. We
    also need to deal with database transactions to ensure consistency in the data
    source.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work with the data access infrastructure
    of ABP Framework, which provides abstractions for data access by implementing
    **Repository** and **Unit of Work** (**UoW**) patterns. Repositories provide a
    standard way to perform common database operations for your **entities**. The
    UoW system automates database connections and transaction management to ensure
    a use case (typically, a **HyperText Transfer Protocol** (**HTTP**) request) is
    atomic; this means all operations done in the request are successful together
    or rolled back together in any error.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: You will see how to define your entities based on ABP Framework's pre-built
    base entity classes. Then, you will learn how to insert, update, delete, and query
    entities in the database using the repositories. You will also understand the
    UoW system to control transaction scopes in your application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework can work with any database system, while it provides built-in
    integration packages with `DbContext` class, mapping your entities to database
    tables, implementing your repositories, and deploying different ways of loading
    related entities when you have an entity. You will also see how to use **MongoDB**
    as a second database provider option.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers ABP''s fundamental data access infrastructure with the
    following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB integration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the UoW system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow and try the examples, you need to have an **integrated
    development environment** (**IDE**)/editor installed (for example, Visual Studio)
    to build ASP.NET Core projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities are the main classes to define your domain model. If you are using
    a relational database, an entity is generally mapped to a database table. An **object-relational
    mapper** **(ORM)**, such as EF Core, provides abstractions to make you feel as
    though you are working with objects in your application code rather than database
    tables.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework standardizes defining entities by providing some interfaces and
    base classes. In the next sections, you will learn about ABP Framework's `AggregateRoot`
    and `Entity` base classes (and their variants), using single **primary keys**
    (**PKs**) and **composite PKs** (**CPKs**) with these classes and working with
    **globally unique identifier** (**GUID**) PKs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: AggregateRoot classes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **aggregate** is a cluster of objects (entities and value objects) bound
    together by an aggregate root object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases do not have a physical aggregate concept. Every entity
    is related to a separate database table, and an aggregate is spread into more
    than one table. You define relations with **foreign keys** (**FKs**). However,
    in document/object databases such as MongoDB, an aggregate is saved into a single
    collection by serializing it as a single document (a **JavaScript Object Notation**
    (**JSON**)-like object). The aggregate root is mapped to the collection, and sub-entities
    are serialized within the aggregate root object. That means sub-entities don't
    have their collections and are always accessed over the aggregate root.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The Aggregate Concept
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the aggregate concept in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*, with all the details of this. For now, you can think
    of aggregate roots as the main (root) entities in your domain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In ABP Framework, you can define main entities and aggregate roots, by deriving
    from one of the `AggregateRoot` classes. `BasicAggregateRoot` is the most simple
    class for defining your aggregate roots.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example entity class is derived from the `BasicAggregateRoot`
    class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`BasicAggregateRoot` just defines an `Id` property as the PK and takes the
    PK type as the generic parameter. In this example, the PK type of `Form` is `Guid`.
    You can use any type as the PK (for example, `int`, `string`, and so on), as long
    as the underlying database provider supports it.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other base classes to derive your aggregate roots from, as detailed
    here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The `AggregateRoot` class has additional properties to support optimistic concurrency
    and object extension features.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreationAuditedAggregateRoot` inherits from the `AggregateRoot` class and
    adds `CreationTime` (`DateTime`) and `CreatorId` (`Guid`) properties to store
    creation audit information.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuditedAggregateRoot` inherits from the `CreationAuditedAggregateRoot` class
    and adds `LastModificationTime` (`DateTime`) and `LastModifierId` (`Guid`) properties
    to store modification audit information.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FullAuditedAggregateRoot` inherits from the `AuditedAggregateRoot` class and
    adds `DeletionTime` (`DateTime`) and `DeleterId` (`Guid`) properties to store
    deletion audit information. It also adds `IsDeleted` (`bool`) by implementing
    the `ISoftDelete` interface, which makes the entity soft-delete.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimistic Concurrency and Object Extension Features
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These topics are not covered in this book. Please check the ABP Framework documentation
    if you need to use them.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ABP automatically sets auditing properties. We will return to the audit logging
    and soft-delete topics in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Entity classes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Entity` base classes are similar to `AggregateRoot` classes, but they are
    used for sub-collection entities rather than main (root) entities. For example,
    the `Form` aggregate root example in the previous section has a collection of
    questions. The `Question` class is derived from the `Entity` class and is shown
    in the following code snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with the `AggregateRoot` class, the `Entity` class also defines an `Id` property
    of a given type. In this example, the `Question` entity also has a collection
    of options, where `Option` is another entity type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: There are some other pre-defined base entity classes, such as `CreationAuditedEntity`,
    `AuditedEntity`, and `FullAuditedEntity`. They are similar to the audited aggregate
    root classes explained in the previous section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Entities with CPKs
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relational databases support CPKs, whereby your PK consists of a combination
    of multiple values. Composite keys are especially useful for relation tables with
    **many-to-many** relations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you want to set multiple managers for a form object and add a collection
    property to the `Form` class, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can then define a `FormManager` class deriving from the non-generic `Entity`
    class, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you inherit from the non-generic `Entity` class, you have to implement
    the `GetKeys` method to return an array of the keys. In this way, ABP can use
    the CPK's value where it is needed. For this example, `FormId` and `UserId` are
    FKs to other tables, and they build the CPK of the `FormManager` entity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: CPKs for Aggregate Roots
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`AggregateRoot` classes also have non-generic versions for CPKs, while it is
    not so usual to set CPKs for aggregate root entities.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The GUID PK
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP mostly uses GUIDs as the PK type for pre-built entities. GUIDs are generally
    compared to auto-increment IDs (such as `int` or `long`, supported by relational
    databases). Here are some commonly known benefits of using GUIDs as the PK compared
    to auto-increment keys:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: GUIDs are naturally unique. This works well if you are building distributed
    systems, using a non-relational database, and need to split or merge tables or
    integrate external systems.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUIDs can be generated on the client side without needing a database round trip.
    In this way, the client code can know the PK value before saving the entity.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUIDs are impossible to guess, so they can be more secure in some cases (for
    example, if end users see the ID of an entity, they can't find the ID of another
    entity).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GUIDs also have some disadvantages compared to auto-increment integer values,
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: A GUID is 16 bytes in the storage, higher than `int` (4 bytes) and `long` (8
    bytes).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUIDs are not sequential by nature, which causes performance problems on clustered
    indexes. However, ABP offers a solution to that problem.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABP provides the `IGuidGenerator` service, which generates sequential `Guid`
    values by default. While it generates sequential values, the values generated
    by the algorithm are still safe to be universal and random. Generating a sequential
    value solves the clustered index performance problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If you manually set the `Id` value of an entity, always use the `IGuidGenerator`
    service; never use `Guid.NewGuid()`. If you don't set the `Id` value for a new
    entity and insert it into the database using a repository, the repository automatically
    sets it using the `IGuidGenerator` service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: GUID versus Auto-Increment
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: GUID versus auto-increment PKs is a hot discussion in software development,
    and there is no clear winner. ABP works with any PK type, so you can make your
    own choice based on your requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned the basics of entity definitions and will explore best practices
    for entities in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316), *DDD
    – The Domain Layer*. But now, let's continue with the repositories to understand
    how to work with a database to persist our entities.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Working with repositories
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Repository pattern** is a common approach to abstract the data access
    code from the other services of your application. In the next sections, you will
    learn how to use ABP Framework's generic repositories for your entities to query
    or manipulate data in the database using pre-defined repository methods. You will
    also see how to create custom repositories when you need to extend the generic
    repositories and add your own repository methods to encapsulate your data access
    logic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Database Providers
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Database provider integration should be done to use repositories. We will do
    this in the *EF Core integration* and *MongoDB integration* sections of this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have an entity, you can directly inject and use the generic repository
    for that entity. Here is an example class that uses a repository:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we''ve injected `IRepository<Form, Guid>`, the default generic
    repository for the `Form` entity. Then, we''ve used the `GetListAsync` method
    to get a filtered list of forms from the database. The generic `IRepository` interface
    has two generic parameters: entity type (`Form`, in this example) and PK type
    (`Guid`, in this example).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Repositories for Non-Aggregate Root Entities
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories are only available for *aggregate root* entities by default
    because it is a best practice to access aggregates via aggregate root objects.
    However, it is possible to enable generic repositories for other entity types
    if you're using a relational database. We will see the configuration point in
    the *EF Core integration* section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories provide many built-in methods to query, insert, update,
    and delete entities.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Inserting, updating, and deleting entities
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods can be used to manipulate data in the database:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`InsertAsync` is used to insert a new entity.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertManyAsync` is used to insert multiple entities in a single call.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateAsync` is used to update an existing entity.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateManyAsync` is used to update multiple entities in a single call.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteAsync` is used to delete an existing entity.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteManyAsync` is used to insert multiple entities in a single call.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About Asynchronous Programming
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All repository methods are asynchronous. As a general principle in .NET, it
    is strongly suggested to write your application code with the `async`/`await`
    pattern wherever possible, because in .NET, mixing asynchronous code with synchronous
    code leads to potential deadlock, timeout, and scalability problems in your application
    that are not easy to detect and resolve.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are using EF Core, these methods may not immediately perform an actual
    database operation because EF Core uses a change-tracking system. It saves changes
    only when you call the `DbContext.SaveChanges` method. ABP Framework's UoW system
    automatically calls the `SaveChanges` method when the current HTTP request successfully
    finishes. If you want to save changes into the database immediately, you can pass
    the `autoSave` parameter as `true` to the repository methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a new `Form` entity and immediately saves it
    to the database in the `InsertAsync` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even if you save changes into the database, the changes may not be visible yet,
    depending on the transaction isolation level, and will be rolled back if the current
    transaction fails. We will cover the UoW system in the *Understanding the UoW
    system* section of this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DeleteAsync` method has an extra overload to delete all the entities satisfying
    the given condition. The following example deletes all the draft forms in the
    database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also have a complex condition using logical operators such as `&&` and
    `||`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: About Cancellation Tokens
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: All repository methods get an optional `CancellationToken` parameter. Cancellation
    tokens are used to cancel a database operation when needed. For example, if the
    user closes the browser window, there is no need to continue a long-running database
    query operation. Most of the time, you don't need to manually pass a cancellation
    token, since ABP Framework automatically captures and uses the cancellation token
    from the HTTP request when you don't explicitly pass it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Querying a single entity
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods can be used to fetch a single entity:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`GetAsync`: Returns a single entity by its `Id` value or a predicate expression.
    Throws `EntityNotFoundException` if the requested entity was not found.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindAsync`: Returns a single entity by its `Id` value or a predicate expression.
    Returns `null` if the requested entity was not found.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should use the `FindAsync` method only if you have custom logic or fallback
    code, in case the given entity does not exist in the database. Otherwise, use
    `GetAsync`, which throws a well-known exception that causes the `404` status code
    to return to the client in an HTTP request.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `GetAsync` method to query a `Form` entity with
    its `Id` value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both methods have overloads to pass a predicate expression to query an entity
    with a given condition. The following example uses the `GetAsync` method to get
    a `Form` entity with its unique name:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Use these overloads only if you are expecting a single entity. If your query
    returns multiple entities, then they throw `InvalidOperationException`. For example,
    if form names are always *unique* in your system, you can find a form by name,
    as in this example. However, if your query may return multiple entities, use querying
    methods that return a list of entities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Querying a list of entities
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generic repositories provide a lot of options to query entities from the database.
    The following methods can be used to get a list of entities directly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`GetListAsync`: Returns all the entities or a list of entities satisfying the
    given condition'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetPagedListAsync`: Used to query entities by paging'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block shows how to get a list of forms filtered by the given
    name:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I've passed a lambda expression to the `GetListAsync` method to get all the
    `Form` entities with the given `name` parameter's value contained in their names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: These methods are simple but limited. If you want to write advanced queries,
    you can use **Language-Integrated Query** (**LINQ**) over the repositories.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ over the repositories
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repositories provide the `GetQueryableAsync()` method, which returns an `IQueryable<TEntity>`
    object. You can then use this object to perform LINQ on the entities in the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses a LINQ operation on the `Form` entities to get a
    list of forms filtered and ordered by their names:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've first obtained an `IQueryable<Form>` object, then written a LINQ query,
    and finally executed the query using the `IAsyncQueryableExecuter` service.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to write the previous query could be using LINQ extension
    methods, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Having an `IQueryable` object provides you with all the power of LINQ. You can
    even make joins between multiple `IQueryable` objects obtained from different
    repositories.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `IAsyncQueryableExecuter` service may seem strange to you. You may
    expect to call the `ToListAsync` method directly on the query object, like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unfortunately, `ToListAsync` is an extension method defined by EF Core (or MongoDB,
    if you are using it) and located inside the `Microsoft.EntityFrameworkCore` NuGet
    package. If referencing that package from your application layer is not a problem
    for you, then you can directly use these asynchronous extension methods in your
    code. However, if you want to keep your application layer ORM-independent, ABP's
    `IAsyncQueryableExecuter` service provides the necessary abstraction.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: IRepository async extension methods
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ABP Framework provides all the standard async LINQ extension methods for the
    `IRepository` interface: `AllAsync`, `AnyAsync`, `AverageAsync`, `ContainsAsync`,
    `CountAsync`, `FirstAsync`, `FirstOrDefaultAsync`, `LastAsync`, `LastOrDefaultAsync`,
    `LongCountAsync`, `MaxAsync`, `MinAsync`, `SingleAsync`, `SingleOrDefaultAsync`,
    `SumAsync`, `ToArrayAsync`, and `ToListAsync`. You can directly use any of these
    methods on a repository object.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `CountAsync` method to get a count of forms
    where the name starts with `"A"`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that these extension methods are only available on the `IRepository`
    interface. If you want to use queryable extensions, you should still follow the
    approach explained in the previous section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories for entities with CPKs
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your entity has a CPK, you can't use the `IRepository<TEntity, TKey>` interface,
    since it gets a single PK (`Id`) type. In this case, you can use the `IRepository<TEntity>`
    interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use `IRepository<FormManager>` to get managers of a given
    form, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, I've used the `IRepository<FormManager>` interface to perform
    a query for the `FormManager` entities.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Repositories for Non-Aggregate Root Entities
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the *Generic repositories* section of this chapter, you can't use
    `IRepository<FormManager>` by default, since `FormManager` is not an aggregate
    root entity. You normally want to get the `Form` aggregate root and access its
    `Managers` collection to get the form managers. However, if you are using EF Core,
    you can create default generic repositories for entities that are not aggregate
    roots. See the *EF Core integration* section to learn how to do this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: One limitation of generic repositories without the `TKey` generic argument is
    that they don't have methods that get `Id` parameters because they can't know
    the `Id` type. However, you can still use LINQ to write any type of query you
    need.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Other generic repository types
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You typically want to use the repository interfaces explained in the previous
    sections since they are the most feature-full repository types. However, there
    are some more limited repository types that can be useful in some scenarios, such
    as the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '`IBasicRepository<TEntity, TPrimaryKey>` and `IBasicRepository<TEntity>` provide
    fundamental repository methods, but they don''t support LINQ and `IQueryable`
    functionalities. You can use these repositories if your underlying database provider
    doesn''t support LINQ or you don''t want to leak LINQ queries into your application
    layer. In this case, you probably need to write custom repositories by inheriting
    from these interfaces and implement your queries with custom methods.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IReadOnlyRepository<TEntity, TKey>`, `IReadOnlyRepository<TEntity>`, `IReadOnlyBasicRepository<Tentity,
    TKey>`, and `IReadOnlyBasicRepository<TEntity, TKey>` provide methods to fetch
    data but do not include any methods to manipulate the database.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic repository methods are enough for most cases. However, you may still
    need to add custom methods to your repositories.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Custom repositories
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create custom repository interfaces and classes to access the underlying
    database provider **application programming interface** (**API**), encapsulate
    your LINQ expressions, call stored procedures, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom repository, first, define a new repository interface. Repository
    interfaces are defined in the `Domain` project that comes with the startup template.
    You can inherit from one of the generic repository interfaces to include the standard
    methods in your repository interface. The code is illustrated in the following
    snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`IFormRepository` inherits from `IRepository<Form, Guid>` and adds a new method
    to get a list of forms with some filters. You can then inject `IFormRepository`
    into your services instead of the generic repository and use your custom methods.
    If you don''t want to include the standard repository methods, just derive your
    interface from the `IRepository` (without any generic argument) interface. This
    is an empty interface that is used to identify your interface as a repository.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Surely, we must implement the `IFormRepository` interface somewhere in our application.
    ABP startup templates provide integration projects for the underlying database
    provider, so we can implement custom repository interfaces in the database integration
    project. We will implement that interface for EF Core and MongoDB in the next
    sections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: EF Core integration
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft's EF Core is the de facto ORM for .NET, with which you can work with
    major database providers, such as SQL Server, Oracle, MySQL, PostgreSQL, and Cosmos
    DB. It is the default database provider when you create a new ABP solution using
    the ABP **command-line interface** (**CLI**).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The startup template uses *SQL Server* by default. If you prefer another `-dbms`
    parameter while creating a new solution, like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`SqlServer`, `MySQL`, `SQLite`, `Oracle`, and `PostgreSQL` are directly supported.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Other Databases
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to ABP''s documentation to learn about up-to-date supported database
    options and how to switch to another database provider that the ABP CLI does not
    support out of the box: [https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS](https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, you will learn how to configure the DBMS (although it
    is already done in the startup template), define a `DbContext` class, and register
    to the **dependency injection** (**DI**) system. Then, you will see how to map
    your entities to database tables, using Code First Migrations and creating custom
    repositories for your entities. Finally, we will explore different ways of loading
    related data for an entity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the DBMS
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `AbpDbContextOptions` to configure the DBMS in the `ConfigureServices`
    method of our module. The following example configures using SQL Server as the
    DBMS:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Surely, the `UseSqlServer()` method call will be different if you've preferred
    a different DBMS. We don't need to set the connection string since it is automatically
    obtained from the `ConnectionStrings:Default` configuration. You can check the
    `appsettings.json` file in your project to see and change the connection string.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: We've configured the DBMS but haven't defined a `DbContext` object, which is
    necessary to work with the database in EF Core.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Defining DbContext
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DbContext` is the main object in EF Core that you interact with the database.
    You normally create a class inheriting from `DbContext` to create your own `DbContext`.
    With ABP Framework, we are inheriting from `AbpDbContext` instead.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `DbContext` class definition with ABP Framework:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`FormsAppDbContext` inherits from `AbpDbContext<FormsAppDbContext>`. `AbpDbContext`
    is a generic class and takes the `DbContext` type as a generic parameter. It also
    forces us to create a constructor, as shown here. We can then add `DbSet` properties
    for our entities. It is essential to add `DbSet` properties since ABP can create
    default generic repositories only for the entities with `DbSet` properties defined.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Once we've defined `DbContext`, we should register it with the DI system to
    use it in our application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Registering DbContext with DI
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AddAbpDbContext` extension method is used to register `DbContext` classes
    with the DI system. You can use this method inside the `ConfigureServices` method
    of your module (it is inside the `EntityFrameworkCore` project in the startup
    solution), as shown in the following code block:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`AddDefaultRepositories()` is used to enable default generic repositories for
    your entities related to that `DbContext`. It enables generic repositories only
    for aggregate root entities by default because, in `includeAllEntities` parameter
    to `true` if you want to use repositories for other entity types too, as illustrated
    here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this option, you can inject the `IRepository` service for any entity in
    your application code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The includeAllEntities Option in the Startup Template
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The ABP startup template sets the `includeAllEntities` option to `true` because
    developers working on relational databases are used to querying from all database
    tables. If you want to apply DDD principles strictly, you should always use the
    aggregate roots to access sub-entities. In this case, you can remove this option
    from the `AddDefaultRepositories` method call.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to register the `DbContext` class. We can inject and use `IRepository`
    interfaces for all your entities in your `DbContext` class. However, we should
    first configure the EF Core mappings for the entities.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Configuring entity mappings
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EF Core is an object-to-relational mapper that maps your entities to database
    tables. We can configure the details of those mappings in two ways, as outlined
    here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Using data annotation attributes on your entity class
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Fluent API inside by overriding the `OnModelCreating` method
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data annotation attributes makes your domain layer EF Core-dependent.
    If that's not a problem for you, you can simply use these attributes by following
    EF Core's documentation. In this book, I will use the Fluent API approach.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Fluent API approach, you can override the `OnModelCreating` method
    in your `DbContext` class, as shown in the following code block:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you override the `OnModelCreating` method, always call `base.OnModelCreating()`
    since ABP also performs default configurations inside that method, necessary to
    properly use ABP features such as audit logs and data filters. Then, you can use
    the `builder` object to perform your configurations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can configure the mapping for the `Form` class defined in this
    chapter, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Calling the `b.ConfigureByConvention()` method is important here. It configures
    the base properties of your entity if it is derived from ABP's pre-defined `Entity`
    or `AggregateRoot` classes. The remaining configuration code is pretty clean and
    standard, and you can learn all the details from EF Core's documentation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that configures a relation between entities:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we are defining the relation between the `Form` and `Question`
    entities: a form can have many questions, while a question always belongs to a
    single form.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The configuration we've made ensures that EF Core knows how to read and write
    entities to the database tables. However, related tables in the database should
    also be available. You can definitely create a database and the tables inside
    it manually. Then, in every change to your entities, you manually reflect the
    related changes in the database schema. However, it is hard to keep your entities
    and database tables in sync in this way. It is also tedious and error-prone to
    make them all manual, especially when you have multiple environments (such as
    development and production).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a better way: Code First Migrations. EF''s Code First
    Migrations system provides an efficient way to incrementally update the database
    schema to keep it in sync with your entity model. We''ve already used the Code
    First Migration system in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*. You can refer to that chapter to learn
    how to add a new database migration and apply it in the database.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom repositories
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an `IFormRepository` interface in the *Custom repositories* part
    of the *Working with repositories* section in this chapter. Now, it's time to
    implement this repository interface using EF Core.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement the repository inside the EF Core integration project of
    your solution, like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This class is derived from ABP''s `EfCoreRepository` class. In this way, we
    are inheriting all the standard repository methods. The `EfCoreRepository` class
    gets three generic parameters: the `DbContext` type, the entity type, and the
    PK type of the entity class.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`FormRepository` also implements `IFormRepository`, which defines a custom
    `GetListAsync` method. We get the `DbContext` instance to use all the power of
    the EF Core API in this method.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Tip about WhereIf
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Conditional filtering is a widely used pattern, and ABP provides a nice `WhereIf`
    extension method that can simplify our code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the `GetListAsync` method, as shown in the following code
    block:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we have the `DbContext` instance, we can use it to execute **Structured
    Query Language** (**SQL**) commands or stored procedures. The following method
    executes a raw SQL command to delete all draft forms:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Executing Stored Procedures and Functions
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to EF Core's documentation ([https://docs.microsoft.com/en-us/ef/core](https://docs.microsoft.com/en-us/ef/core))
    to learn how to execute stored procedures and functions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you implement `IFormRepository`, you can inject and use it instead of
    `IRepository<Form, Guid>`, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class uses the custom `GetListAsync` method of `IFormRepository`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Even if you implement a custom repository class for the `Form` entity, it is
    still possible to inject and use default generic repositories (for example, `IRepository<Form,
    Guid>`) for that entity. This is a good feature, especially if you start with
    generic repositories, then decide to create a custom repository later. You don't
    have to change your existing code that uses the generic repository.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential problem may occur if you override a base method from the `EfCoreRepository`
    class and customize it in your repository. In this case, the services that use
    the generic repository reference will continue to use the non-overridden method.
    To prevent this fragmentation, use the `AddRepository` method while registering
    your `DbContext` with DI, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this configuration, the `AddRepository` method redirects generic repositories
    to your custom repository class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Loading related data
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your entity has navigation properties to other entities or has collections
    of other entities, then you'll frequently need to access those related entities
    while working with the main entity. For example, the `Form` entity introduced
    before has a collection of `Question` entities, and you may need to access the
    questions while working with a `Form` object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to access related entities: **explicit loading**, **lazy
    loading**, and **eager loading**.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Explicit loading
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repositories provide `EnsurePropertyLoadedAsync` and `EnsureCollectionLoadedAsync`
    extension methods to load a navigation property or sub-collection explicitly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can explicitly load the questions of a form, as shown in the
    following code block:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we don't use `EnsureCollectionLoadedAsync` here, then the `form.Questions`
    collection might be empty. If we are not sure it is filled, we can use `EnsureCollectionLoadedAsync`
    to ensure it is loaded. The `EnsurePropertyLoadedAsync` and `EnsureCollectionLoadedAsync`
    methods do nothing if the related property or collection is already loaded, so
    calling them multiple times is not a problem for performance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lazy loading is a feature of EF Core that loads related properties and collections
    when you first access them. Lazy loading is not enabled by default. If you want
    to enable it for your `DbContext`, follow these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Install the `Microsoft.EntityFrameworkCore.Proxies` NuGet package in your EF
    Core layer.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `UseLazyLoadingProxies` method while configuring `AbpDbContextOptions`,
    as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Be sure that the navigation properties and collection properties are virtual
    in your entities, as shown here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you enable lazy loading, you don't need to use explicit loading anymore.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy loading is a discussed concept of ORMs. Some developers find it useful
    and practical, while others suggest not using it in any way. I am drawn to not
    using it because it has some potential problems, such as these:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading can't use asynchronous programming because there is no way to access
    a property with the `async`/`await` pattern. So, it blocks the caller thread,
    which is a bad practice for throughput and scalability.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have a `1+N` loading problem if you forget to eager-load the related
    data before using a `foreach` loop. `1+N` loading means you query a list of entities
    from the database with a single database operation (`1`), then perform a loop
    that accesses a navigation property (or a collection) of these entities. In this
    case, it lazy-loads the related property for each loop (`N` = count of the queried
    entities in the first database operation). So, you make a `1+N` database call,
    which dramatically drops your application performance. You should eager-load the
    related entities in such cases so that you make a single database in total.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it hard to predicate and optimize your code since you may not easily
    see when the related data is loaded from the database.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I suggest going for a more controlled approach and using eager loading wherever
    possible.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Eager loading
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eager loading is a way of loading related data while first querying the main
    entity.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you''ve created a custom repository method to load the related
    questions while getting a `Form` object from the database, as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you create such custom repository methods, you can use the full EF Core API.
    However, if you are working with ABP's repositories and don't want to depend on
    EF Core in your application layer, you can't use EF Core's `Include` extension
    method (which is used to eager-load the related data). In this case, you have
    two options, which are discussed in the next sections.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: IRepository.WithDetailsAsync
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `WithDetailsAsync` method of the `IRepository` returns an `IQueryable`
    instance by including the given properties or collections, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`WithDetailsAsync(f => f.Questions)` returns `IQueryable<Form>` with questions
    included, so we can safely loop through the `form.Questions` collection. `IAsyncQueryableExecuter`
    was explained before, in the *Generic repositories* section of this chapter. The
    `WithDetailsAsync` method can get more than one expression to include more than
    one property if you need it. `WithDetailsAsync` can''t be used if you need nested
    includes (the `ThenInclude` extension method in EF Core). In this case, create
    a custom repository method.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The Aggregate pattern
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Aggregate pattern will be covered in depth in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*. However, to give a brief bit of information, an aggregate
    is considered a single unit; it is read and saved as a single unit with all sub-collections.
    That means you always load related questions while loading a form.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP supports the aggregate pattern well and allows you to configure eager loading
    for an entity at a global point. We can write the following configuration inside
    the `ConfigureServices` method of our module class (in the `EntityFrameworkCore`
    project in your solution):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is suggested to include all sub-collections. Once you configure the `DefaultWithDetailsFunc`
    method as shown, then the following will occur:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Repository methods that return a single entity (such as `GetAsync`) will eager-load
    related entities by default unless you explicitly disable that behaviour by specifying
    the `includeDetails` parameter to `false` on the method call.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository methods that return multiple entities (such as `GetListAsync`) will
    allow the eager loading of related entities, while they will not eager-load by
    default.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are some examples.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a single form with sub-collections included like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Get a single form without sub-collections like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Get a list of forms without sub-collections like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Get a list of forms with sub-collections included like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The Aggregate pattern simplifies your application code in most cases, while
    you can still fine-tune cases where you need performance optimization. Note that
    navigation properties (to other aggregates) are not used if you truly implement
    the Aggregate pattern. We will return to this topic again in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We've covered the essentials of using EF Core with ABP Framework. The next section
    will explain MongoDB integration, the other built-in database provider of ABP
    Framework.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB integration
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a popular non-relational **document database**, which stores data
    in JSON-like documents rather than traditional row-/column-based tables.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The ABP CLI provides an option to create new applications using MongoDB, as
    shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you want to check and change the database connection string, you can look
    at the `appsettings.json` file of your application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB Client Package
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ABP uses the official `MongoDB.Driver` NuGet package for MongoDB integration.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, you will learn how to work with ABP's `AbpMongoDbContext`
    class to define `DbContext` objects, perform object-mapping configurations, register
    `DbContext` objects with the DI system, and implement custom repositories when
    you want to extend the generic repositories for your entities.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We begin the MongoDB integration by defining a `DbContext` class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Defining DbContexts
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MongoDB driver package doesn''t have a `DbContext` concept like EF Core
    does. However, ABP introduces the `AbpMongoDbContext` class to provide a standard
    way to define and configure MongoDB integration. We need to define a class deriving
    from the `AbpMongoDbContext` base class, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `MongoCollection` attribute sets the collection name on the database side.
    It is optional and uses the driver's default value if you don't specify it. Defining
    a collection property on the `FormsAppDbContext` class is required to use the
    default generic repositories.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Configuring object mappings
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the MongoDB C# driver is not an ORM, it still maps your entities to collections
    in the database, and you may want to customize the mapping configuration. In this
    case, override the `CreateModel` method in your `DbContext` class like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, I've configured MongoDB so that it ignores the `Description`
    property of the `Form` entity while saving and retrieving data. Please refer to
    the documentation of the `MongoDB.Driver` NuGet package to learn about all configuration
    options.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Registering DbContext with DI
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you create and configure your `DbContext` class, it is registered with
    the DI system in the `ConfigureServices` method of your module class (typically
    in the MongoDB integration project of your solution). The following code snippet
    illustrates this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`AddDefaultRepositories()` is used to enable default generic repositories for
    your entities related to that `DbContext`. You can then inject `IRepository<Form>`
    into your classes and start using your MongoDB database.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The `AddDefaultRepositories` method enables default repositories only for aggregate
    root entities (the entity classes derived from the `AggregateRoot` class). Set
    `includeAllEntities` to `true` to enable default repositories for all entity types.
    However, it is strongly suggested to apply the Aggregate pattern while working
    with MongoDB. The Aggregate pattern will be covered in depth in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Default generic repositories are enough in most cases, but you may need to access
    the MongoDB API or abstract your queries into custom repository methods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom repositories
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an `IFormRepository` interface in the *Custom repositories* part
    of the *Working with repositories* section in this chapter. We can implement this
    repository interface using MongoDB.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement the repository inside the MongoDB integration project of
    your solution, like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `FormRepository` class is derived from ABP''s `MongoDbRepository` class.
    In this way, we are inheriting all the standard repository methods. The `MongoDbRepository`
    class gets three generic parameters: the `DbContext` type, the entity type, and
    the PK type of the entity class.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FormRepository` class should implement the `GetListAsync` method defined
    by the `IFormRepository` interface, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'I''ve used the LINQ API of the MongoDB driver in this example, but you can
    use alternative APIs by obtaining the `IMongoCollection` object, as illustrated
    in the following code snippet:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, you can inject `IFormRepository` instead of the generic `IRepository<Form,
    Guid>` repository into your services and use all the standard and custom repository
    methods.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you implement a custom repository class for the `Form` entity, it is
    still possible to inject and use default generic repositories (such as `IRepository<Form,
    Guid>`) for that entity. If you implement a custom repository, it is suggested
    to use the `AddRepository` method on the `DbContext` registration code, as illustrated
    in the following code snippet:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this way, generic default repositories will be redirected to your custom
    repository class. If you override a base method in your custom repository, they
    will also use your overload instead of the base method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: We've learned how to use EF Core and MongoDB as the database provider. In the
    next section, we will understand the UoW system, making it possible to connect
    these databases and apply transactions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the UoW system
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UoW is the main system that ABP uses to initiate, manage, and dispose of database
    connections and transactions. The UoW system is designed with the **Ambient Context
    pattern**. That means when we create a new UoW, it creates a scoped context that
    is participated by all the database operations performed in the current scope
    by sharing the same context and is considered a single transaction boundary. All
    the operations done in a UoW are committed (on success) or rolled back (on exception)
    together.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: While you can manually create UoW scopes and control the transaction properties,
    most of the time, it works seamlessly just as you desire. However, it provides
    some options if you change the default behavior.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: UoW and Database Operations
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: All database operations must be performed in a UoW scope since UoW is the way
    to manage database connections and transactions in ABP Framework. Otherwise, you
    get an exception indicating that.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, you will gain an understanding of how the UoW system works
    and customize it by configuring the options. I will also explain how to manually
    control the UoW system when the conventional system doesn't work for your use
    case.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Configuring UoW options
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the default setup, in an ASP.NET Core application, an HTTP request is considered
    as the UoW scope. ABP starts a UoW at the beginning of the request and saves changes
    to the database if the request successfully finishes. It rolls back the UoW if
    the request fails because of an exception.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: ABP determines database transaction usage based on the HTTP request type. HTTP
    `GET` requests don't create a database transaction. UoW works anyway but doesn't
    use a database transaction in this case. All other HTTP request types (`POST`,
    `PUT`, `DELETE`, and others) use a database transaction if you haven't configured
    them otherwise.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: HTTP GET Requests and Transactions
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: It is a best practice not to make database changes in `GET` requests. If you
    make multiple write operations in a `GET` request and somehow your request fails,
    your database state could be left in an inconsistent state because ABP doesn't
    create a database transaction for `GET` requests. In this case, either enable
    transactions for `GET` requests using `AbpUnitOfWorkDefaultOptions` or manually
    control the UoW, as described in the next section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `AbpUnitOfWorkDefaultOptions` in the `ConfigureServices` method of your
    module (in the database integration project) if you want to change the UoW options,
    as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`TransactionBehavior` can take the following three values:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '`Auto` (default): Automatically determines using database transactions (transactions
    are enabled for non-`GET` `HTTP` requests)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enabled`: Always uses a database transaction, even for `HTTP` `GET` requests'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled`: Never uses a database transaction'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Auto` behavior is the default value and is suggested for most applications.
    `IsolationLevel` is only valid for relational databases. ABP uses the default
    value of the underlying provider if you don't specify it. Finally, the `Timeout`
    option allows you to set a default timeout value for transactions as milliseconds.
    If a UoW operation doesn't complete in the given timeout value, a timeout exception
    is thrown.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to configure the default options across all
    UoWs. It is also possible to configure these values for an individual UoW if you
    manually control it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Manually controlling the UoW
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For web applications, you rarely need to control the UoW system manually. However,
    for background workers or non-web applications, you may need to create UoW scopes
    yourself. You may also need to control the UoW system to create inner transaction
    scopes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to create a UoW scope is to use the `[UnitOfWork]` attribute on your
    method, like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The UoW system uses the Ambient Context pattern. If a surrounding UoW is already
    in place, your `UnitOfWork` attribute is ignored and your method participates
    in the surrounding UoW. Otherwise, ABP starts a new transactional UoW just before
    entering the `DoItAsync` method and commits the transaction if it doesn't throw
    an exception. The transaction is rolled back if that method throws an exception.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to fine-control the UoW system, you can inject and use the `IUnitOfWorkManager`
    service, as shown in the following code block:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, we are starting a new transactional UoW scope with 15 seconds
    as the `timeout` parameter''s value. With this usage (`requiresNew: true`), ABP
    always starts a new UoW even if there is a surrounding UoW. Always call the `uow.CompleteAsync()`
    method if everything goes right. You can use the `uow.RollbackAsync()` method
    if you want to roll back the current transaction.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, UoW uses an ambient scope. You can access the current UoW
    anywhere in this scope, using the `IUnitOfWorkManager.Current` property. It can
    be `null` if there is no ongoing UoW.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet uses the `SaveChangesAsync` method with the `IUnitOfWorkManager.Current`
    property:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've saved all pending changes to the database. However, if that's a transactional
    UoW, these changes are also rolled back if you roll back the UoW or throw any
    exception in the UoW scope.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to work with databases using ABP Framework.
    ABP standardizes to define entities by providing base classes. It also helps to
    automatically track change times and the users changing entities, when you derive
    from audited entity classes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The repository system provides the fundamental functionalities to read and write
    entities. You can use LINQ over the repositories for advanced querying possibilities.
    Also, you can create custom repository classes to work with the underlying data
    provider directly, hide complex queries behind simple repository interfaces, call
    stored procedures, and so on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储系统提供了读取和写入实体的基本功能。您可以使用LINQ在仓储上进行高级查询。此外，您还可以创建自定义仓储类，直接与底层数据提供程序一起工作，将复杂查询隐藏在简单的仓储接口后面，调用存储过程等。
- en: ABP is database-agnostic, but it provides integration packages with EF Core
    and MongoDB out of the box. ABP application startup templates come with one of
    these providers, whichever you prefer.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ABP是数据库无关的，但它提供了与EF Core和MongoDB的集成包，开箱即用。ABP应用程序启动模板包含这些提供程序之一，您可以选择您喜欢的。
- en: EF Core is the de facto ORM for the .NET platform, and ABP supports EF Core
    as a first-class citizen. The application startup template is fine-tuned to configure
    your mappings and manage your database schema migrations while supporting a modular
    application structure.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core是.NET平台上的事实上的ORM，ABP将其作为一等公民支持。应用程序启动模板经过精心调整，以配置您的映射并管理您的数据库模式迁移，同时支持模块化应用程序结构。
- en: Finally, the UoW system provides a seamless way to manage database connections
    and transactions for us. It keeps the application code clean by automating these
    repeating tasks for us.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，UoW系统为我们提供了一个无缝的方式来管理数据库连接和事务。它通过自动化这些重复性任务，使应用程序代码保持整洁。
- en: Data access is a core requirement for any business application, and it is essential
    to understand the details of it. The next chapter will continue with the cross-cutting
    concerns required for every application, such as authorization, validation, and
    exception handling.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问是任何业务应用的核心需求，理解其细节至关重要。下一章将继续介绍每个应用所需的横切关注点，例如授权、验证和异常处理。
