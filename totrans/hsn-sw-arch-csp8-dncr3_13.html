<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding the Different Domains in Software Solutions</h1>
                </header>
            
            <article>
                
<p>This chapter is dedicated to a modern software development technique called <strong>domain-driven design</strong> (<strong>DDD</strong>), which was first proposed by Eric Evans. While DDD has existed for more than 15 years, it reached a great success in the last few years because of its ability to cope with two important problems:</p>
<ul>
<li>Modeling complex systems where no single expert has in-depth knowledge of the whole domain. This knowledge is split among several people.</li>
<li>Facing big projects with several development teams. There are many reasons why a project is split among several teams, with the most common being the team's size and all of its members having different skills and/or different locations. In fact, experience has proven that teams of more than 6-8 people are not efficacious and clearly different skills and locations prevent a tight interaction from occurring. <span>Team splitting prevents tight interaction from happening for all the people involved in the project. </span></li>
</ul>
<p>In turn, the importance of the two aforementioned problems grew more in the last few years for the following reasons:</p>
<ul>
<li>Software systems <span>always </span>took up a lot of space inside every organization and became more and more complex and geographically distributed. </li>
<li>At the same time, the need for frequent updates increased so that these<span> complex software systems could be adapted, </span>as per the needs of a quickly changing market.</li>
<li>The preceding problems led to the conception of more sophisticated CI/CD cycles and the adoption of complex distributed architectures that may leverage reliability, high throughput, quick updates, and the capability to evolve legacy subsystems gradually. Yes <span>–</span> we are speaking of the microservices and container-based architectures we analyzed in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>.</li>
</ul>
<p class="mce-root"/>
<p>In this scenario, it's common to implement complex software systems with associated fast CI/CD cycles that <span>always </span>require more people to evolve and maintain them. In turn, this created the requirement of developing technologies that were adequate for high-complexity domains and for the cooperation of several loosely coupled development teams.</p>
<p>In this chapter, we will analyze the basic principles, advantages, and common patterns related to DDD, as well as how to use them in our solutions. More specifically, we will cover the following topics:</p>
<ul>
<li>What are software domains?</li>
<li>Understanding domain-driven design</li>
<li>Using SOLID principles to map your domains</li>
<li>Use case <span>– understanding the domains of the use case</span></li>
</ul>
<p>Let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter requires Visual Studio 2017 or 2019 free Community Edition or better with all the database tools installed.</p>
<p><span>All the code snippets in this chapter can be found in the GitHub repository associated with this book, <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8</a><a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8">.</a></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are software domains?</h1>
                </header>
            
            <article>
                
<p>As we discussed in <a href="a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml">Chapter 2</a>, <em>Functional and Nonfunctional Requirements</em>, and <a href="bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml">Chapter 3</a>, <em>Documenting the Requirements with Azure DevOps</em>, the transfer of knowledge from domain experts to the development team plays a fundamental role in software design. Developers try to communicate with experts and describe their solutions in a language that domain experts and stakeholders can understand. However, often, the same word has a different meaning in various parts of an organization, and what appear to be the same conceptual entities have completely different shapes in different contexts.</p>
<p class="mce-root"/>
<p>For instance, in our <span>WWTravelClub use case, the order-payment and packages-handling subsystems use completely different models for customers. Order-payment characterizes a customer by their payment methods and currency, bank accounts, and credit cards, while package-handling is more concerned with the locations and packages that have been visited and/or purchased in the past, the user's preferences, and their geographical location. Moreover, while order-payment refers to various concepts with a language that we may roughly define as a <em>bank language</em>, packages-handling uses a language that is typical of travel agencies/operators.</span></p>
<p>The classical way to cope with these discrepancies is to use a unique abstract entity called <strong>customer</strong>, which projects into two different views <span>– the</span> order-payment view and the packages-handling view. Each projection operation takes some operations and some properties from the <strong>customer</strong> abstract entity and changes their names. Sin<span>ce domain experts only give us the projected views, our main task as system designers is to create a conceptual model that can </span><span>explain all the views. </span><span>The following diagram shows how different views are handled:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/68ac81ab-ebad-4a37-921f-c8e3bf813822.png" style="width:28.08em;height:20.67em;"/></p>
<p>The main advantage of the classic approach is that we have a unique and coherent representation of the data of the domain. If this conceptual model is built successfully, all the operations will have a formal definition and purpose and the whole abstraction will be a <span>rationalization of the way the whole organization <em>should</em> work, </span>possibly highlighting and correcting errors and simplifying some procedures.</p>
<p>However, what are the downsides of this approach? First of all, the way work is organized may have an excessive impact on the preexisting organization that may prevent it from operating correctly for a certain amount of time since the constraint of using a unique coherent model doesn't offer enough options to mitigate this impact. Errors must be removed, duplication must be removed, and everything must be perfectly coherent so that there is a minimum irreducible impact that we can't mitigate since the only way to mitigate it would be to renounce the overall coherence.</p>
<p>This minimum impact can be acceptable in a small organization, when the software is destined for a small part of the overall organization, or when the software automatizes a small enough percentage of the data flow. However, as the software becomes the backbone of a whole geographically distributed organization, sharp changes become more unacceptable and unfeasible. Moreover, as the complexity of the software system grows, several other issues appear, as follows:</p>
<ul>
<li>Arriving at a uniquely coherent view of data becomes more difficult since we can't face complexity by breaking these tasks into smaller loosely coupled tasks.</li>
<li>As complexity grows, there is a need for frequents system changes, but it is quite difficult to update and maintain a unique global model. Moreover, bugs/errors that are introduced by changes in small subparts of the system may propagate to the whole organization through the uniquely shared model.</li>
<li>System modeling must be split among several teams and only loosely coupled tasks can be faced with separate teams.</li>
<li>The need to move to a microservice-based architecture makes the bottleneck of a unique database more unacceptable.</li>
<li>As the system grows, we need to communicate with more domain experts, each speaking a different language and each with a different view of that data model. Thus, we need to translate our unique model's properties and operations to/from more languages to be able to communicate with them.</li>
<li>As the system grows, it becomes more inefficient to deal with records with several hundreds/thousands of fields. Such inefficiencies originate in database engines that <span>inefficiently </span>handle big records with several fields (memory fragmentation, problems with too many related indices, and so on). However, the main inefficiencies take place in ORMs and business layers that are forced to handle these big records in their update operations. In fact, while query operations usually require just a few fields that have been retrieved from the storage engine, updates and business processing involve the whole entity.</li>
<li>As the traffic in the data storage subsystem grows, we need read and update/write parallelism in all the data operations. As we discussed in <a href="77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml">Chapter 7</a>, <em>How to Choose Your Data Storage in the Cloud</em>, while read parallelism is easily achieved with data replication, write parallelism requires sharding, and it is difficult to shard a uniquely monolithic and tightly connected data model.</li>
</ul>
<p>These issues are the reason for <span>DDD's </span>success in the last few years since they were characterized by more complex software systems that became the backbone of entire organizations. DDD's basic principles will be discussed in detail in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding domain-driven design</h1>
                </header>
            
            <article>
                
<p>Domain-driven design is about the construction of a unique domain model and keeps all the views as separate models. Thus, the whole application domain is split into smaller domains, each with a separate model. These separate domains are called <strong>Bounded Contexts</strong>. Each domain is characterized by the language spoken by the experts and used to name all the domain concepts and operations. Thus, each domain defines a common language used by both the expert and the development team called <strong>Ubiquitous Language</strong>. Translations are not needed anymore, and if the development team uses interfaces as a base for its code, the domain expert is able to understand and validate them since all the operations and properties are expressed in the same language that's used by the expert.</p>
<p>Here, we're getting rid of a cumbersome unique abstract model, but now we have several separated models that we need to relate somehow. DDD proposes that it will handle all of these separated models, that is, all the Bounded Contexts, as follows:</p>
<ul>
<li>We need to add B<span>ounded Context </span>boundaries whenever the meaning of the language terms change. For instance, in the WWTravelClub use case, order-payment and packages-handling belong to different Bounded Contexts because they give a different meaning to the word <strong>customer</strong>.</li>
<li>We need to explicitly represent relations among bounded contexts. Different development teams may work on different bounded contexts, but each team must have a clear picture of the relationship between the Bounded Context it is working on and all the other models. For this reason, such relationships are represented in a unique document that's shared with every team.</li>
<li>We need to keep all the bounded contexts aligned with continuous integration. Meetings <span>are organized </span>and simplified system prototypes are built in order to verify that all the Bounded Contexts are evolving coherently, that is, that all the Bounded Contexts can be integrated into the desired application behavior.</li>
</ul>
<p>The following diagram shows how the WWTravelClub example that we discussed in the previous section changes with the adoption of DDD:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f7b60e75-1f5b-4d4f-88cd-fb420114cd19.png" style="width:22.17em;height:15.58em;"/></p>
<p>There is a relationship between the customer entities of both Bounded Contexts, while the Purchase entity of the packages-handling <span>Bounded Context </span>is related to the payments. Identifying entities that map to each other in the various Bounded Contexts is the first step of formally defining the interfaces that represent all the possible communications among the contexts.</p>
<p>For instance, from the preceding diagram, we know that payments are done after purchases, and so we can deduce that the payment-orders Bounded Context must have an operation to create a payment for a specific customer. In this domain, new customers are created if they don't already exist. The payment creation operation is triggered immediately after purchase. Since several more operations are triggered after an item is purchased, we can implement all the communication related to a purchase event with the Publisher/Subscriber pattern we explained in <a href="a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml">Chapter 9</a>, <em>Design Patterns and .NET Core Implementation</em>. These are known as <strong>domain events</strong> in DDD. Using events to implement communications between Bounded Contexts is very common since it helps keep Bounded Contexts loosely coupled. </p>
<p>Once an instance of either an event or an operation that's been defined in the Bounded Context's interface crosses the context boundary, it is immediately translated into the U<span>biquitous Language</span> <span>of the receiving context. It is important that this translation is performed before the input data starts interacting with the other domain entities to avoid the Ubiquitous Language of the other domain becoming contaminated by extra-context terms. </span></p>
<div class="packt_infobox">Each Bounded Context implementation must contain a Data Model Layer completely expressed in terms of the Bounded Context Ubiquitous Language (class and interface names and property and method names), with no contamination from other Bounded Contexts Ubiquitous Languages, and without contamination from programming technical stuff. This is necessary to ensure good communication with domain experts and to ensure that domain rules are translated correctly into code so that they can be easily validated by domain experts.<br/>
When there is a strong mismatch between the communication language and the target U<span>biquitous Language, an anti-corruption layer is added to the receiving Bounded Context boundary. The only purpose of this anti-corruption layer is to perform a language translation.</span></div>
<p>The document that contains a representation of all the Bounded Contexts, along with the Bounded Context's mutual relationships and interface definitions, is called a <strong>Context Mapping</strong>. The relationships among contexts contain <span>organizational </span>constraints that specify the kind of cooperation that's required among the team that works on the different Bounded Contexts. Such relationships don't constrain the Bounded Context interfaces but do affect the way they may evolve during the software CI/CD cycle. They represent patterns of team cooperation. The most common patterns are as follows:</p>
<ul>
<li><strong>Partner</strong>: This is the original pattern suggested by Eric Evans. The idea is that the two teams have a mutual dependency on each other for delivery. In other terms, they decide together and, if needed, change the Bounded Context's mutual communication specifications during the software CI/CD cycle.</li>
<li><strong>Customer/supplier development teams</strong>: In this case, a team acts as a customer and the other acts as a supplier. Both teams define the interface of the customer side of the Bounded Context and some automated acceptance tests to validate it. After that, the supplier can work independently. This pattern works when the customer's Bounded Context is the only active part that invokes the interface methods that are exposed by the other Bounded Context. This is adequate for the interaction between the order-payments and the packages-handling contexts, where order-payments acts as a supplier since its functions are subordinate to the needs of packages-handling. When this pattern can be applied, it decouples the two Bounded Contexts completely.</li>
<li><strong>Conformist</strong>: This is similar to the customer/supplier, but in this case, the customer side accepts an interface that's been imposed by the supplier side with no negotiation stage. This pattern offers no advantages to the other patterns, but sometimes we are forced into the situation depicted by the pattern since either the supplier's Bounded Context is implemented in a preexisting product that can't be configured/modified too much or because it is a legacy subsystem that we don't want to modify.</li>
</ul>
<p>It is worth pointing out that the separation in Bounded Contexts is only efficacious if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction of complexity that's obtained by breaking a whole system into subparts would be overcome by the complexity of the coordination and communication processes. However, if Bounded Contexts are defined with the <em>language criterion</em>, that is, Bounded Context boundaries are added whenever the <em>Ubiquitous Language</em> changes, this should actually be the case. In fact, different languages may arise just as a result of a loose interaction between organization subparts since the more subparts there are for an organization to interact with, the more they end up using a common language.</p>
<p>Moreover, all human organizations can grow by evolving into loosely coupled subparts for the same reason complex software systems may be implemented just for the cooperation of loosely coupled submodules: this is the only way humans are able to cope with complexity. From this, we can conclude that complex organizations/artificial systems can always be decomposed into loosely coupled subparts. We just need to understand <em>how</em>.</p>
<p>Beyond the basic principles we've mentioned so far, DDD furnishes a few basic primitives to describe each Bounded Context, as well as some implementation patterns. While Bounded Context primitives are an integral part of DDD, these patterns are just useful heuristics we can use in our implementation, so their usage in some or in all Bounded Contexts is not obligatory once we opt for DDD adoption. </p>
<p>In the next section, we will describe primitives and patterns.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entities and value objects</h1>
                </header>
            
            <article>
                
<p>DDD entities represent domain objects that have a well-defined identity, as well as all the operations that are defined on them. They don't differ too much from the entities of other, more classical approaches. Also, DDD entities are the starting point of the storage layer design. The main difference is that DDD stresses their object-oriented nature more, while other approaches use them mainly as <em>records</em> whose properties can be written/updated without too many constraints. DDD, on the other hand, forces strong SOLID principles on them to ensure that only certain information is encapsulated inside of them and that only certain information is accessible from outside of them, which operations are allowed on them, and which business-level validation criteria apply to them.</p>
<p>In other words, DDD entities are richer than the <span>entities </span>of record-based approaches. In other approaches, <span>operations that </span>manipulate entities are defined outside of them in classes that represent business and/or domain operations. In DDD, these operations are moved to the entity definitions as their class methods. The reason for this is that they offer better modularity and keep related chunks of software in the same place so that they can be maintained and tested easily.</p>
<p>For the same reason, business validation rules are moved inside of DDD entities. DDD entity validation rules are business-level rules, so they must not be confused with database integrity rules or with user-input validation rules. They contribute to the way entities represent domain objects by encoding the constraints the represented objects must obey. In .NET Core, business validation can be carried out with one of the following techniques listed:</p>
<ul>
<li>Calling the validation methods in all the class methods that modify the entity</li>
<li>Hooking the validation methods to all the property setters</li>
<li>Decorating the class and/or its properties with a custom validation attribute and then invoking the <kbd>TryValidateObject</kbd> static method of the <kbd>System.ComponentModel.DataAnnotations.Validator</kbd> class on the entity each time it is modified</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once detected, validation errors must be handled somehow, that is, the current operation must be aborted and the error must be reported to an appropriate error handler. The simplest way to handle validation errors is by throwing an exception. This way, both purposes are easily achieved and we can choose where to intercept and handle them. Unfortunately, as we discussed in the <em>Performance issues that need to be considered while programming in C#</em> section of <a href="a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml">Chapter 2</a><span>, </span><em>Functional and Nonfunctional Requirements</em><span>,</span> exceptions imply big performance penalties, so, often, different options are considered. Handling errors in the normal flow of control would break modularity by spreading the code that's needed to handle the error all over the stack of methods that caused the error, with<span> a never-ending set of conditions all over that code. Therefore, more sophisticated options are needed.</span></p>
<p>A good alternative to exceptions is to notify the error handler of any errors that are defined in the Dependency Injection engine. Being scoped, the same service instance is returned while each request is being processed so that the handler that controls the execution of the whole call stack can inspect possible errors when the flow of control returns to it and can handle them appropriately. Unfortunately, this sophisticated technique can't abort the operation's execution immediately or return it to the controlling handler. Therefore, the developer is forced to add adequate control conditions to prevent the continuation of the operation. This is why exceptions are recommended for this scenario, notwithstanding their performance issues.</p>
<div class="packt_tip">Business-level validation must not be confused with input validation, which will be discussed in more detail in <a href="003ee8cb-5995-4364-8772-73d73df29cf8.xhtml">Chapter 13</a>, <em>Presenting ASP.NET Core MVC</em>, since the two types of validation have different and complementary purposes. While business-level validation rules encode domain rules, input validation enforces the format of every single input (string length, email and URL correct formats, and so on), ensures that all the necessary input has been provided, enforces the execution of the chosen user-machine interaction protocols, and provides fast and immediate feedback that drives the user to interact with the system.</div>
<p>Since DDD entities must have a well-defined identity, they must have properties that act as primary keys. It is common to override the <kbd>Object.Equal</kbd> method of all the DDD entities in such a way that two objects are considered equal whenever they have the same primary keys. This is easily achieved by letting all the entities inherit from an abstract <kbd>Entity</kbd> class, as shown in the following code:</p>
<pre>public abstract class Entity&lt;K&gt;: IEntity&lt;K&gt;<br/>    where K: IEqualityComparer&lt;K&gt;<br/>{<br/>        <br/>    public virtual K Id { get; protected set; }<br/>    public bool IsTransient()<br/>    {<br/>        return Object.Equals(Id, default(K));<br/>    }<br/>    public override bool Equals(object obj)<br/>    {<br/>        if (obj == null || !(obj is Entity&lt;K&gt;))<br/>            return false;<br/>        if (Object.ReferenceEquals(this, obj))<br/>            return true;<br/>        if (this.GetType() != obj.GetType())<br/>            return false;<br/>        Entity&lt;K&gt; item = (Entity&lt;K&gt;)obj;<br/>        if (item.IsTransient() || this.IsTransient())<br/>            return false;<br/>        else<br/>            return Object.Equals(item.Id, Id);<br/>    }<br/>    int? _requestedHashCode;<br/>    public override int GetHashCode()<br/>    {<br/>        if (!IsTransient())<br/>        {<br/>            if (!_requestedHashCode.HasValue)<br/>                _requestedHashCode = this.Id.GetHashCode() ^ 31;<br/>            return _requestedHashCode.Value;<br/>        }<br/>        else<br/>            return base.GetHashCode();<br/>    }<br/>    public static bool operator ==(Entity&lt;K&gt; left, Entity&lt;K&gt; right)<br/>    {<br/>        if (Object.Equals(left, null))<br/>            return (Object.Equals(right, null));<br/>        else<br/>            return left.Equals(right);<br/>    }<br/>    public static bool operator !=(Entity&lt;K&gt; left, Entity&lt;K&gt; right)<br/>    {<br/>        return !(left == right);<br/>    }<br/>}</pre>
<p><span>It is worth pointing out that, once we've redefined the <kbd>Object.Equal</kbd> method in the <kbd>Entity</kbd> class, we can also override with the </span><kbd>==</kbd><span> and </span><kbd>!=</kbd><span> operators. </span></p>
<p><span>The </span><kbd>IsTransient</kbd><span> predicate returns </span><kbd>true</kbd><span> whenever the entity has been recently created and hasn't been recorded in the permanent storage, so its primary key is still undefined.</span></p>
<div class="packt_infobox">In .NET, it is good practice that, whenever you override the <kbd>Object.Equal</kbd> method of a class, you also override its <kbd>Object.GetHashCode</kbd> method so that class instances can be efficiently stored in data structures such as dictionaries and sets. That's why the Entity class overrides it.</div>
<p>It is also worth implementing an <kbd>IEntity&lt;K&gt;</kbd> interface that defines all the properties/methods of <kbd>Entity&lt;K&gt;</kbd>. This interface is useful whenever we need to hide data classes behind interfaces.</p>
<p>Value objects, on the other hand, represent complex types that can't be encoded with numbers or strings. Therefore, they have no identity and no principal keys. They have no operations defined on them and are immutable; that is, once they've been created, all their fields can be read but cannot be modified. For this reason, they are usually encoded with classes whose properties have protected/private setters. Two value objects are considered equal when all their independent properties are equal (some properties are not independent since they just show data that's been encoded by other properties in a different way, as is the case for the ticks of <kbd>DateTime</kbd> and its representation of the date and time fields).</p>
<p>Typical value objects include costs represented as a number and a currency symbol, locations represented as longitude and latitude, addresses, contact information, and so on. When the interface of the storage engine is Entity Framework, which we analyzed in <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a>, <em>Interacting with Data in C# - Entity Framework Core</em>, and <a href="77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml">Chapter 7</a>, <em>How to Choose Your Data Storage in the Cloud</em>, value objects are connected with the entity that uses them through the <kbd>OwnsMany</kbd> and <kbd>OwnsOne</kbd> relationships. In fact, such relationships <span>also </span>accept classes with no principal keys defined on them.</p>
<p>When the storage engine is a NoSQL database, value objects are stored inside the record of the entities that use them. On the other hand, in the case of relational databases, they can either be implemented with separated tables whose principal keys are handled automatically by Entity Framework and are hidden from the developer (no property is declared as a principal key) or, in the case of <kbd>OwnsOne</kbd>, they are flattened and added to the table associated with the entity that uses them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using SOLID principles to map your domains</h1>
                </header>
            
            <article>
                
<p>In the following subsections, we will describe some of the patterns that are commonly used with DDD. Some of them can be adopted in all projects, while others can only be used for certain Bounded Contexts. The general idea is that the business layer is split into two layers:</p>
<ul>
<li>Application layer</li>
<li>Domain layer</li>
</ul>
<p>Here, the domain layer is based on the Ubiquitous Language and manipulates DDD entities and value objects.<span> DDD entities and value objects are defined in this domain layer. </span>The whole business layer communicates with the data layer that's implemented with Entity Framework through interfaces that are defined in the domain layer but are implemented in the data layer. Data that's passed/returned by these interface methods are known as DDD entities (the representation of queries and their results). The domain layer has no direct reference to the library that implements the data layer, but the connection between domain layer interfaces and their data layer implementations is performed in the dependency injection engine of the application layer. From this, we can understand the following:</p>
<ul>
<li>The data layer has a reference to the domain layer since it must implement its interfaces and must create DDD entities and value objects that are defined in the domain layer.</li>
<li>The application layer has references to the domain and data layers, but references to the data layer types only appear in the dependency engine, where they are associated with the respective interfaces that were defined in the domain layer.</li>
</ul>
<p>Thus, the domain layer contains the representation of the domain objects, the methods to use on them, validation constraints, and its relationship with various entities. To increase modularity and decoupling, communication among entities is usually encoded with events, that is, with a publisher/subscriber pattern. This means entity updates can trigger events that have been hooked to business operations.</p>
<p>This layered architecture allows us to change the whole data layer without affecting the domain layer, which only <span>depends on the domain specifications and language and doesn't depend on the technical details of how the data is handled.</span></p>
<p><span> </span><span>The application layer contains the definitions of all the operations that may potentially affect several entities and the definitions of all the queries that are needed by the applications. Both business operations and queries use the interfaces defined in the domain layer to interact with the data layer. However, while business operations manipulate and exchange entities with these interfaces, queries send query specifications and receive generic DTOs from them. Business operations are invoked either by other layers (typically the presentation layer) or by communication with the application layer. Business operations may also be hooked to events that are triggered when entities are modified by other operations. </span></p>
<p><span>Thus, the application layer operates on the interfaces defined in the domain layer instead of interacting directly with their data layer implementations, which means that the application layer is decoupled from the data layer. More specifically, data layer objects are only mentioned in the dependency injection engine definitions. All the other application layer components refer to the interfaces that are defined in the domain layers, and the dependency injection engine injects the appropriate implementations. </span></p>
<p>The application layer communicates with other application components through one or more of the following patterns:</p>
<ul>
<li>It exposes business operations and queries on a communication endpoint, such as an HTTP Web API (see <a href="3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml">Chapter 12</a>, <em>Applying Service-Oriented Architectures with .NET Core</em>). In this case, the presentation layer may connect to this endpoint or to other endpoints that, in turn, take information from this and other endpoints. Application components that collect information from several endpoints and expose them in a unique endpoint are called gateways. They may be either custom or general-purpose, such as Ocelot.</li>
<li>It is referenced as a library by an application that directly implements the presentation layer, such as an ASP.NET Core MVC Web application.</li>
<li>It doesn't expose all the information through endpoints and communicates some of the data it processes/creates to other application components that, in turn, expose endpoints.</li>
</ul>
<p>Before we describe these patterns, we need to understand the concept of aggregates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Aggregates</h1>
                </header>
            
            <article>
                
<p>So far, we have talked about entities as the <em>units</em> that are processed by a DDD-based business layer. However, several entities can be manipulated and made into single entities. An example of this is a purchase order and all of its items. In fact, it makes absolutely no sense to process a single order item independently of the order it belongs to. This happens because order-items are actually subparts of an order, not independent entities.</p>
<p>There is no transaction that may affect a single order-item without it affecting the order that the item is in. Imagine that two different people in the same company are trying to increase the total quantity of cement but one increases the quantity of <span>type-1 </span>cement (item 1) while the other increases the quantity of <span>type-2 </span>cement (item 2). If each item is processed as an independent entity, both quantities will be increased, which could cause an incoherent purchase order since the total quantity of cement would be increased twice.</p>
<p>On the other hand, if the whole order, along with all its order-items, is loaded and saved with every single transaction by both people, one of the two will overwrite the changes of the other one, so whoever makes the final change will have their requirements set. In a web application, it isn't possible to lock the purchase order for the whole time the user sees and modifies it, so an optimistic concurrency policy is used. For instance, it is enough to add a version number to each purchase order and to do the following:</p>
<ol>
<li>Read the order without opening any transaction.</li>
<li>Before saving the modified order, we open a transaction and perform a second read.</li>
<li>If the version number of the newly retrieved order differs from the one of the order that was modified by the user, the operation is aborted because someone else modified the order that was shown to the user immediately after the first read. In this case, the user is informed of the problem and the newly retrieved order is shown to the user once more.</li>
<li>If the version number is unchanged, we increase the version number, proceed with the save, and commit the transaction.</li>
</ol>
<p>A purchase order, along with all its subparts (its order-items), is called an <strong>aggregate</strong>, while the order entity is called the root of the aggregate. Aggregates always have roots since they are hierarchies of entities connected by <em>subparts</em> relations.</p>
<p>Since each aggregate represents a single complex entity, all the operations on it must be exposed by a unique interface. Therefore, the aggregate root usually represents the whole aggregate, and all the operations on the aggregate are defined as methods of the root entity.</p>
<p>When the <em>aggregate</em> pattern is used, the units of information that are transferred between the business layer and the data layer are called <em>aggregates</em>, queries, and query results. Thus, aggregates replace single entities. </p>
<p>What about the WWTravelClub location and packages entities we looked at in<span> <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a></span>, <em>Interacting with Data in C# - Entity Framework Core</em>, and <a href="77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml">Chapter 7</a><span>,</span><span> </span><em>How to Choose Your Data Storage in the Cloud</em>? Are packages part of the unique aggregates that are rooted in their associated locations? No! In fact, locations are rarely updated and changes that are made to a package have no influence on its location and on the other packages associated with the same location. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The repository and Unit of Work patterns</h1>
                </header>
            
            <article>
                
<p>The repository pattern is how we implement the interface between the domain data layer. Interfaces that are implemented by repositories are defined in the domain layer, while their implementations are defined in the data layer. The peculiarity of this way of implementing the interface with the data layer is its entity-centric nature, meaning that there should be a different repository for each root aggregate. Each repository contains all the save/creation operations that were performed on the associated aggregate, as well as all the query operations that were performed on the entities that compose the aggregate. </p>
<p>Since there are also transactions that can span several aggregates, usually, the repository pattern is applied with the <em>Unit of Work</em> pattern. The Unit of Work pattern states that each data layer interface (in our case, each repository) contains a reference to a <em>Unit of Work</em> interface that represents the identity of the current transaction. This means that several repositories with the same <em>Unit of Work</em> reference belong to the same transaction.</p>
<p>Both patterns can be implemented by defining some seed interfaces:</p>
<pre>public interface IUnitOfWork <br/>{ <br/>    Task&lt;bool&gt; SaveEntitiesAsync();<br/>    Task StartAsync();<br/>    Task CommitAsync();<br/>    Task RollbackAsync();<br/>}<br/><br/>public interface IRepository&lt;T&gt;: IRepository<br/>{<br/>   IUnitOfWork UnitOfWork { get; }<br/>}</pre>
<p>All the repository interfaces inherit from <kbd>IRepository&lt;T&gt;</kbd> and bind <kbd>T</kbd> to the aggregate root they are associated with, while <em>Unity of Work</em> simply implements <kbd>IUnitOfWork</kbd>. When using Entity Framework, <kbd>IUnitOfWork</kbd> is usually implemented with <kbd>DBContext</kbd>, which means that <kbd>SaveEntitiesAsync()</kbd> can perform other operations and then call the <kbd>DBContext</kbd> <kbd>SaveChangeAsync</kbd> method so that all the pending changes are saved with a single transaction. If a wider transaction that starts when some data is retrieved from the storage engine is needed, it must be started and committed/aborted by the application layer handler that takes care of the whole operation. <kbd>IRepository&lt;T&gt;</kbd> inherits from an empty <kbd>IRepisotory</kbd> interface to help automatic repository discovery. The GitHub repository associated with this book contains a <kbd>RepositoryExtensions</kbd> class whose <kbd>AddAllRepositories</kbd> <kbd>IServiceCollection</kbd> extension method automatically discovers all the repository implementations contained in an assembly and adds them to the dependency injection engine.</p>
<p>The following is a diagram of the data layer/domain layer/data layer architecture based on the repository and Unity of Work patterns:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e4ba8d3-66e0-4aa9-8975-e6f64347fdb8.png" style="width:22.83em;height:29.42em;"/></p>
<p>The main advantage of avoiding direct references to repository implementations is that the various modules can be tested easily if we mock these interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DDD entities and Entity Framework Core</h1>
                </header>
            
            <article>
                
<p>DDD requires entities to be defined in a way that is different from the way we defined entities in <span><a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a></span><span>, <em>Interacting with Data in C# - Entity Framework Core</em></span>. In fact, Entity Framework entities are record-like lists of public properties with almost no methods, while DDD entities should have methods that encode domain logic, more sophisticated validation logic, and read-only properties. While further validation logic and methods can be added without breaking Entity Framework's operations, adding read-only properties that must not be mapped to database properties can create problems that must be handled adequately. Preventing properties from being mapped to the database is quite easy <span>– all we need to do is</span> decorate them with the <kbd>NotMapped</kbd> attribute.</p>
<p>The issues that read-only properties have are a little bit more complex and can be solved in three fundamental ways:</p>
<ul>
<li>Define the DDD entities as different classes and copy data to/from them when entities are returned/passed to repository methods. This is the easiest solution but it requires that you write some code so that you can convert the entities between the two formats. DDD entities are defined in the domain layer, while the EF entities continue being defined in the data layer.</li>
<li>Let Entity Framework Core map fields to class private fields so that you can decide on how to expose them to properties by writing custom getters and/or setters. This can be done in the configuration code of the entity, as follows: </li>
</ul>
<pre style="padding-left: 60px">modelBuilder.Entity&lt;MyEntity&gt;()<br/>      .Property("_myPrivatefield");</pre>
<p style="padding-left: 60px">The main disadvantage of this approach is that the field is provided as a string, which prevents any compile-time checks and <span>also </span>prevents automatic refactoring, thereby creating possible sources of bugs and maintainability issues. Moreover, we can't use data annotations to configure the property since the whole configuration must be performed with the fluent interface of the <kbd>OnModelCreating</kbd> <kbd>DBContext</kbd> method. In this case, entity definitions must be moved from the domain layer as prescribed by DDD.</p>
<ul>
<li class="mce-root"><span>Hide the Entity Framework class with all its public properties behind an interface that, when needed, only exposes property getters. The interface is defined in the domain layer, while the entity continues being defined in the data layer.</span><br/>
<span>In this case, the repository must expose a</span> <kbd>Create</kbd> <span>method that returns an implementation of the interface; otherwise, the higher layers won't be able to create new instances that can be added to the storage engine since interfaces can't be created with</span> <kbd>new</kbd><span>. </span></li>
</ul>
<p style="padding-left: 60px" class="mce-root"><span>For instance, suppose that we would like to define a DDD interface called</span> <kbd>IDestination</kbd> <span>for the</span> <kbd>Destination</kbd> <span>class defined in the</span> <em>Defining DB Entities</em><span> subsection of</span> <span><a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a></span><span>, </span><em>Interacting with Data in C# – Entity Framework Core</em><span>, and suppose we would like to expose the</span> <kbd>Id</kbd><span>,</span> <kbd>Name</kbd><span>, and</span> <kbd>Country</kbd> <span>properties as read-only since once a</span> destination <span>is created they can't be</span> modified <span>anymore. Here, it is enough to let</span> <kbd>Destination</kbd> <span>implement </span><kbd>IDestination</kbd> <span>and to define</span> <kbd>Id</kbd><span>, </span><kbd>Name</kbd><span>, </span><span>and </span><kbd>Country</kbd> <span>as read-only in</span> <kbd>IDestination</kbd><span>:</span></p>
<pre style="color: black;padding-left: 60px">public interface IDestination<br/>{ <br/>    int Id { get; }<br/>    string Name { get; }   <br/>    string Country { get; }<br/>    string Description { get; set; }<br/>    ...<br/>}</pre>
<p>Now that we've discussed the basic patterns of DDD and how to adapt the Entity Framework for the needs of DDD, we can discuss more advanced DDD patterns. In the next subsection, we will introduce the CQRS pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command Query Responsibility Segregation (CQRS) pattern</h1>
                </header>
            
            <article>
                
<p><span>In its more general form, t</span>he usage of this pattern is quite easy: use different structures to store and query data. Here, the requirements regarding how to store and update data differ from the requirements of queries. In the case of DDD, the unit of storage is the <em>aggregate</em>, so additions, deletions, and updation involve aggregates, while queries usually involve more or less complicated transformations of properties that have been taken from several aggregates.</p>
<p>Moreover, usually, we don't perform business operations on query results <span>–</span> we just use them to compute other data (averages, sums, and so on). Therefore, while updates require entities with full object-oriented semantics (methods, validation rules, encapsulated information, and so on), query results just need sets of property/values pairs, so DTOs with only public properties and no methods work well.</p>
<p>In its more common form, the pattern can be depicted as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c535aa97-526c-4dff-8fe5-4fe14d85f1fb.png"/></p>
<p>The main takeaway from this is that the extraction of query results don't need to pass through the construction of entities and aggregates, but the fields shown in the query must be extracted from the storage engine and projected into ad hoc DTOs. If queries are implemented with LINQ, we need to use the <kbd>Select</kbd> clause to project the necessary properties into DTOs:</p>
<pre>ctx.MyTable.Where(...)....Select(new MyDto{...}).ToList();</pre>
<p>However, in more complex situations, the CQRS may be implemented in a stronger form. Namely, we can use different Bounded Contexts to store preprocessed query results. This approach is common when queries involve data stored in different Bounded Contexts that's handled by different distributed microservices.</p>
<p>In fact, the other option would be an aggregator microservice that queries all the necessary microservices in order to assemble each query result. However, recursive calls to other microservices to build an answer may result in unacceptable response times. Moreover, factoring out some preprocessing ensures better usage of the available resources. This pattern is implemented by sending changes caused by Bounded Context updates to all the microservices that need them for computing their preprocessed query results.</p>
<p>The usage of this stronger form of the <span>CQRS pattern transforms usual local database transactions into complex time-consuming distributed transactions since a failure in a single query preprocessor microservice should invalidate the whole transaction. As we explained in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>, implementing distributed transactions is usually unacceptable for performance reasons, so the common solution is to renounce to immediate overall coherent database and to accept that the overall database will eventually be coherent after each update. Transient failures can be solved with the retry policies that we analyzed in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>, while permanent failures are handled by performing corrective actions on the already committed local transactions instead of pretending to implement an overall globally distributed transaction.</span></p>
<p><span>As we discussed in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>, communication between microservices is often implemented with the publisher/subscriber pattern to improve microservice separation.</span></p>
<p>At this point, you may be asking the following question:</p>
<div class="packt_quote">"Why do we need to keep the original data once we have all the preprocessed query results? We will never use them to answer queries!"</div>
<p>Some of the answers to this are as follows:</p>
<ul>
<li>They are the source of <kbd>truth</kbd> that we may need to recover from failures.</li>
<li>We need them to compute new preprocessed results when we add new queries.</li>
<li>We need them to process new updates. In fact, processing updates usually requires that some of the data is retrieved from the database, possibly shown to the user, and then modified. For instance, to modify an item in an existing purchase order, we need the whole order so that we can show it to the user and compute the changes so that we can forward it to other microservices. Moreover, whenever we modify or add data to the storage engine, we must verify the coherence of the overall database (unique key constraints, foreign key constraints, and so on).</li>
</ul>
<p>In the next section, we will describe a common pattern that's used for handling operations that span several aggregates or several Bounded Contexts.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command handlers and domain events</h1>
                </header>
            
            <article>
                
<p>To keep aggregates separated, usually, interactions with other aggregates and other Bounded Contexts is done through events. It is good practice to store all the events when they are computed during each aggregate process instead of processing them immediately in order to avoid them interfering with the ongoing computation. This is easily achieved by adding the following code to the abstract Entity class defined in the <em>Entities and value objects</em> subsection of this chapter, as follows:</p>
<pre>public List&lt;IEventNotification&gt; DomainEvents { get; private set; }<br/>public void AddDomainEvent(IEventNotification evt)<br/>{<br/>    DomainEvents = DomainEvents ?? new List&lt;IEventNotification&gt;();<br/>    DomainEvents.Add(evt);<br/>}<br/>public void RemoveDomainEvent(IEventNotification evt)<br/>{<br/>    DomainEvents?.Remove(evt);<br/>}</pre>
<p>Here, <kbd>IEventNotification</kbd> is an empty interface that's used to mark classes as events.</p>
<p>Event processing is usually performed immediately before changes are stored in the storage engine. Accordingly, a good place to perform event processing is in the <kbd>SaveEntitiesAsync()</kbd> method of each <kbd>IUnitOfWork</kbd> implementation (see the <em>The repository and Unit of Work patterns</em> subsection).</p>
<p>Subscriptions to an event, <kbd>T</kbd>, can be provided as an implementation of the <kbd>IEventHandler&lt;T&gt;</kbd> interface:</p>
<pre>public interface <span>IEventHandler&lt;T&gt;<br/>    where T: IEventNotification<br/>{<br/>    Task HandleAsync(T ev);<br/>}<br/></span></pre>
<p>Analogously, business operations can be described by the <kbd>command</kbd> object, which contains all the input data of the operation, while the code that implements the actual operation can be provided through the implementation of an <kbd>ICommandHandler&lt;T&gt;</kbd> interface:</p>
<pre>public interface <span>ICommandHandler&lt;T&gt;<br/>    where T: ICommand<br/>{<br/>    Task HandleAsync(T command);<br/>}</span></pre>
<p>Here, <kbd>ICommand</kbd> is an empty interface that's used to mark classes as commands. <kbd>ICommandHandler&lt;T&gt;</kbd> and <kbd>IEventHandler&lt;T&gt;</kbd> are examples of the command pattern we described in <a href="a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml">Chapter 9</a><span>, </span><em>Design Patterns and .NET Core Implementation</em>. </p>
<p>Each <kbd>ICommandHandler&lt;T&gt;</kbd> can be registered in the dependency injection engine so that classes that need to execute a command, <kbd>T</kbd>, can use <kbd>ICommandHandler&lt;T&gt;</kbd> in their constructor. This way, we decouple the abstract definition of a command (command class) from the way it is executed.</p>
<p>The same construction can't be applied to events, <kbd>T</kbd>, and their <kbd>IEventHandler&lt;T&gt;</kbd> because when an event is triggered, we need to retrieve several <kbd>IEventHandler&lt;T&gt;</kbd> and not just one. We need to do this since each event may have several subscriptions. However, a few lines of code can easily solve this difficulty. First, we need to define a class that hosts all the handlers for a given event type:</p>
<pre>public class EventTrigger&lt;T&gt;<br/>        where T: IEventNotification<br/>    {<br/>        private IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers;<br/>        public EventTrigger(IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers)<br/>        {<br/>            this.handlers = handlers;<br/>        }<br/>        public async Task Trigger(T ev)<br/>        {<br/>            foreach (var handler in handlers)<br/>                await handler.HandleAsync(ev);<br/>        }<br/>    }</pre>
<p>The idea is that each class that needs to trigger event <kbd>T</kbd> requires an <kbd>EventTrigger&lt;T&gt;</kbd> and then passes <span>the event to be</span><span> triggered to its <kbd>Trigger</kbd> method, which, in turn, invokes all the handlers.</span></p>
<p>Then, we need to register <kbd>EventTrigger&lt;T&gt;</kbd> in the dependency injection engine. A good idea is to define the dependency injection extensions that we can invoke to declare each event, as follows:</p>
<pre>        service.AddEventHandler&lt;MyEventType, MyHandlerType&gt;()</pre>
<p>This <kbd>AddEventHandler</kbd> extension must automatically produce a DI definition for <kbd>EventTrigger&lt;T&gt;</kbd> and must process all the handlers that are declared with <kbd>AddEventHandler</kbd> for each type, <kbd>T</kbd>.</p>
<p>The following extension class does this for us:</p>
<pre>public static class EventDIExtensions<br/>{<br/>    private static IDictionary&lt;Type, List&lt;Type&gt;&gt; eventDictionary = <br/>        new Dictionary&lt;Type, List&lt;Type&gt;&gt;();<br/>    public static IServiceCollection AddEventHandler&lt;T, H&gt;<br/>        (this IServiceCollection service)<br/>        where T : IEventNotification<br/>        where H: class, IEventHandler&lt;T&gt; <br/>    {<br/>        service.AddScoped&lt;H&gt;();<br/>        List&lt;Type&gt; list = null;<br/>        eventDictionary.TryGetValue(typeof(T), out list);<br/>        if(list == null)<br/>        {<br/>            list = new List&lt;Type&gt;();<br/>            eventDictionary.Add(typeof(T), list);<br/>            service.AddScoped&lt;EventTrigger&lt;T&gt;&gt;(p =&gt;<br/>            {<br/>                var handlers = new List&lt;IEventHandler&lt;T&gt;&gt;();<br/>                foreach(var type in eventDictionary[typeof(T)])<br/>                {<br/>                    handlers.Add(p.GetService(type) as IEventHandler&lt;T&gt;);<br/>                }<br/>                return new EventTrigger&lt;T&gt;(handlers);<br/>            });<br/>        }<br/>        list.Add(typeof(H));<br/>            <br/>        return service;<br/>    }<br/>    ...<br/>    ...<br/>}</pre>
<p>The <kbd>H</kbd> types of all the handlers associated with each event, <kbd>T</kbd>, are recorded in a list contained in an entry of a dictionary indexed by the <kbd>T</kbd> type of the event. Then, each <kbd>H</kbd> is recorded in the dependency injection engine.</p>
<p>The first time an entry for an event, <kbd>T</kbd>, is added, the corresponding dictionary entry is created (a <kbd>List&lt;Type&gt;</kbd>) and the corresponding <kbd>EventTrigger&lt;T&gt;</kbd> is added to the dependency injection engine. The <kbd>EventTrigger&lt;T&gt;</kbd> instance is created by a function that's passed to <kbd>AddSingleton&lt;EventTrigger&lt;T&gt;&gt;</kbd>, which uses the dictionary entry for <kbd>T</kbd> to get all the handler types. Then, all the handler types are used to retrieve the instances for the dependency injection engine with <kbd>p.GetService(type)</kbd>. We can use this operation since all the handler types were registered in the dependency injection engine. Finally, the list of all the handlers is used to create the required instance of <kbd>EventTrigger&lt;T&gt;</kbd>.</p>
<p>When the program starts up, all the <kbd>ICommandHandler&lt;T&gt;</kbd> and <kbd>IEventHandler&lt;T&gt;</kbd> implementations can be retrieved with reflection and registered automatically. To help with automatic discovery, they inherit from <kbd>ICommandHandler</kbd> and <kbd>IEventHandler</kbd>, which are both empty interfaces. The <kbd>EventDIExtensions</kbd> class, which is available in this book's GitHub repository, contains methods for the automatic discovery and registration of command handlers and event handlers. The GitHub repository also contains an <kbd>IEventMediator</kbd> interface and its <kbd>EventMediator</kbd> interface, whose <kbd>TriggerEvents(IEnumerable&lt;IEventNotification&gt; events)</kbd> method retrieves all the handlers associated with the events it receives in its argument from the dependency injection engine and executes them. It is enough to have <kbd>IEventMediator</kbd> injected into a class so that it can trigger events. <kbd>EventDIExtensions</kbd> also contains an extension method that discovers all the queries that implement the empty <kbd>IQuery</kbd> interface and adds them to the dependency injection engine.</p>
<p>A more sophisticated implementation is given by the <kbd>MediatR</kbd> NuGet package. The previous subsection is dedicated to an extreme implementation of the <span>CQRS pattern.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event sourcing</h1>
                </header>
            
            <article>
                
<p>Event sourcing is an extreme implementation of the stronger form of CQRS. It is useful when the original Bounded Context isn't used at all to retrieve information and just as a <em>source of truth</em> is used for new queries and for recovering from failures. In this case, instead of updating data, we simply add events that describe the operation that was performed: <em>deleted record Id 15</em>, changed the name to <em>John in Id 21</em>, and so on. These events are immediately sent to all the dependent Bounded Contexts, and in the case of failures and/or the addition of new queries, all we have to do is to reprocess some of them.</p>
<p> While all of the techniques we've described up until now can be used in every type of project if minor modifications are made, event sourcing requires a deep analysis to be performed before it can be adopted since, in several cases, it may create bigger problems than the ones it can solve. To get an idea of the problems it may cause when it's misused, imagine that we apply it to purchase orders that have been modified and validated by several users before being approved. Since purchase orders need to be retrieved before they're updated/validated, the purchase order's Bounded Context isn't used just as a <span><em>source of truth</em>, so event sourcing should not be applied to it</span>. If this isn't the case, then we can apply event sourcing to it, in which case our code would be forced to rebuild the whole order from the recorded events each time the order is updated.</p>
<p>An example of its usage is the revenue logging system we described at the end of <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a><span>, </span><em>Applying a Microservice Architecture to Your Enterprise Application</em>. Single revenues are recorded with event sourcing and then sent to the microservice we described in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a><span>, </span><em>Applying a Microservice Architecture to Your Enterprise Application</em>, which, in turn, uses them to preprocess future queries, that is, to compute daily revenues. </p>
<p>In the next section, we will learn how DDD can be applied to this book's WWTravelClub use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case – understanding the domains of the use case</h1>
                </header>
            
            <article>
                
<p>From the requirements listed in the <em>Case study – WWTravelClub</em> section of <a href="14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml">Chapter 1</a>, <em>Understanding the Importance of Software Architecture</em>, and for the analy<span>sis in the <em>Use case – where do I store data?</em> section of <a href="77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml">Chapter 7</a>, <em>How to Choose Your Data Storage in the Cloud</em>, we know that the WWTravelClu</span><span>b system is composed of the following parts:</span></p>
<ul>
<li>Information about the available destinations and packages. We implemented the first prototype of this subsystem's data layer in <a href="77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml">Chapter 7</a><span>, </span><em>How to Choose Your Data Storage in the Cloud</em>.</li>
<li>Reservation/purchase orders subsystem. </li>
<li>Communication with the experts/reviews subsystem.</li>
<li>Payment subsystem. We briefly analyzed the features of this subsystem and its relationship with the reservation purchase subsystem at the beginning of the <em>Domain-driven design</em> section of this chapter.</li>
<li>User accounts subsystem.</li>
<li>Statistics reporting subsystem.</li>
</ul>
<p>Do the preceding subsystems represent different <em>Bounded Contexts</em>? Can some subsystems be split into different Bounded Contexts? The answers to these questions are given by <em>the languages</em> that are spoken in each subsystem:</p>
<ul>
<li><span>The language that's spoken in subsystem 1</span> is the language of <em>travel agencies</em>. There is no concept of a customer; just of locations, packages, and their features.</li>
<li>The language that's spoken in subsystem 2 is common to all service purchases, such as the available resources, reservations, and purchase orders. This is a separate Bounded Context.</li>
<li>The language that's spoken in subsystem 3 has a lot in common with subsystem 1's language. However, there are also typical <em>social media</em> concepts, such as rating, chats, post sharing, media sharing, and so on. This subsystem can be split into two parts: a social media subsystem that has a new bounded context and an <em>available information</em> subsystem that is part of the Bounded Context of subsystem 1<span>.</span></li>
<li>As we pointed out in the <em>Domain-driven design</em> section, in subsystem 4, we speak the language of <em>banking</em>. This subsystem communicates with the reservation purchase subsystem and executes tasks that are needed to carry out a purchase. From these observations, we can see that it is a different Bounded Context and has a customer/supplier relationship with the purchase/reservation system.</li>
<li>Subsystem 5 is definitely a separate Bounded Context (as in almost all web applications). It has a relationship with all the Bounded Contexts that either have a concept of a user or a concept of a customer because the concept of user accounts always maps to these concepts. But how? Simple—the currently logged-in user is assumed to be the social media user of the social media Bounded Context, the customer of the reservation/purchase Bounded Context, and the payer of the payment Bounded Context.</li>
<li>The query-only subsystem, that is, 6, speaks the language of analytics and statistics and differs a lot from the languages that are spoken in the other subsystems. However, it has a connection with almost all the Bounded Contexts since it takes all its input from them. The preceding constraints force us to adopt CQRS in its strong form, thereby considering it a query-only separated Bounded Context. We implemented a part of it in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a><span>, </span><em>Applying a Microservice Architecture to Your Enterprise Application</em>, by using a microservice that conforms to a strong form of CQRS. </li>
</ul>
<p class="mce-root"/>
<p>In conclusion, each of the listed subsystems defines a different Bounded Context, but part of the <em>communication with the experts/reviews subsystem</em> must be included in the <em>Information about available destinations and packages</em> Bounded Context.</p>
<p>As the analysis continues and a prototype is implemented, some Bounded Contexts may split and some others may be added, but it is fundamental to <span>immediately </span>start modeling the system and to <span>immediately </span>start analyzing the relations among the Bounded Contexts with the partial information we have since this will drive further investigations and will help us define the communication protocols and Ubiquitous Languages that are needed so that we can interact with the domain experts.</p>
<p>The following is a basic first sketch of the domain map:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/070f378b-16a3-47ff-bfd1-dd1a800fade6.png" style="width:38.08em;height:27.58em;"/></p>
<p>For simplicity, we've omitted the <strong>Statistics reporting</strong> Bounded Context. Here, we're assuming that the <strong>User accounts</strong> and <strong>Social</strong> Bounded Contexts have a <em>conformist</em> relationship with all the other Bounded Contexts that communicate with them because they are implemented with already existing software, so all the other components must adapt to them.</p>
<p>As we mentioned previously, the relationship between <strong>Reservation</strong> and <strong>Payments</strong> is <em>customer/supplier</em> because <em>Payments</em> furnishes services that are used to execute the tasks of <em>Reservation</em>. All the other relationships are classed as <em>Partners</em>. The various concepts of customer/user that most Bounded Contexts have are coordinated by the <strong>User accounts</strong> authorization token, which indirectly takes care of mapping these concepts between all the Bounded Contexts.</p>
<p>The <em>Packages/location</em> subsystem not only communicates the packages information that's needed for carrying out a reservation/purchase <span>–</span> it also takes care of informing pending purchase orders of possible price changes. Finally, we can see that social interactions are started from an existing review or location, thereby creating communication with the <em>Package/locations</em> Bounded Context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we analyzed the main reasons for the adoption of domain-driven design and why and how it faces the needs of the market. Here, we described how to identify domains and how to coordinate the teams that work on different domains of the same application with domain maps. Then, we analyzed the way DDD represents data with entities, value objects and aggregates, furnishing advice, and code snippets so that we could implement them in practice. </p>
<p>We also covered some typical patterns that are used with DDD, that is, the repository and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. Then, we learned how to implement them in practice. We also showed you how to implement domain events and the command pattern with decoupled handling so that we can add furnishing code snippets to real-world projects.</p>
<p>Finally, we used the principles of DDD in practice to define domains and to create the first sketch of a domain map for this book's WWTravelClub use case.</p>
<p>In the next chapter, you will learn how to maximize code reuse in your projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What furnishes the main hints so that we can discover domain boundaries?</li>
<li>What is the main tool that's used for coordinating the development of a separate Bounded Context?</li>
<li>Is it true that each entry that composes an aggregate communicates with the remainder of the system with its own methods?</li>
<li>Why is there a single aggregate root?</li>
<li>How many repositories can manage an aggregate?</li>
<li>How does a repository interact with the application layer?</li>
<li>Why is the Unit of Work pattern needed?</li>
<li>What are the reasons for the light form of CQRS? What about the reasons for its strongest form?</li>
<li>What is the main tool that allows us to couple commands/domain events with their handlers?</li>
<li>Is it true that event sourcing can be used to implement any Bounded Context?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>More resources on domain-driven design can be found here: <a href="https://domainlanguage.com/ddd/">https://domainlanguage.com/ddd/</a></li>
<li>A detailed discussion of CQRS design principles can be found here: <a href="http://udidahan.com/2009/12/09/clarified-cqrs/">http://udidahan.com/2009/12/09/clarified-cqrs/</a></li>
<li>More information on MediatR can be found on MediatR's GitHub repository: <a href="https://github.com/jbogard/MediatR">https://github.com/jbogard/MediatR</a></li>
<li>A good description of event sourcing, along with an example of it, can be seen in the following blog post by Martin Fowler: <a href="https://martinfowler.com/eaaDev/EventSourcing.html">https://martinfowler.com/eaaDev/EventSourcing.html </a></li>
</ul>


            </article>

            
        </section>
    </body></html>