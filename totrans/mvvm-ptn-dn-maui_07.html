<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor119"/>7</h1>
<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/>Dependency Injection, Services, and Messaging</h1>
<p>As we continue building our <em class="italic">Recipes!</em> app using .NET MAUI, we want to make the most of the MVVM design pattern. MVVM is great for keeping our code organized and also promotes industry-standard practices that make our code base more maintainable and testable. In this chapter, we will focus on two critical concepts that are central to a solid MVVM architecture: <strong class="bold">Dependency</strong> <strong class="bold">Injection </strong>(<strong class="bold">DI</strong>) and <strong class="bold">messaging</strong>. DI promotes separation of concerns and allows our code to be much more testable. Messaging helps us keep different parts of our code from getting tangled up with each other. It allows different areas of our app to talk to each other in a loosely coupled way. Both concepts are extremely important to ensure that our MVVM architecture truly stands out.</p>
<p>Let’s take a look at what this chapter covers:</p>
<ul>
<li>Inversion of Control through Dependency Injection</li>
<li>Registering, resolving, and injecting services</li>
<li>Messaging</li>
</ul>
<p>By the end of this chapter, you’ll have a good understanding of these concepts as we implement them in our <em class="italic">Recipes!</em> app. So, let’s go ahead and get into it.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/>Technical requirements</h1>
<p>Throughout this chapter, we will be enhancing the functionality of the <em class="italic">Recipes!</em> app. All the resources, including additional classes and code required for the topics covered in this chapter, are available on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07</a>. To follow along with this chapter’s content, you can start with the provided <code>Start</code> folder. It contains the initial code and necessary classes specific to this chapter. This code serves as the foundation, building upon what we have learned in the previous chapters. If you want to reference or compare the completed code, including all the code written throughout this chapter, you can find it in the <code>Finish</code> folder.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor122"/>Inversion of Control through Dependency Injection</h1>
<p><strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) is a<a id="_idIndexMarker476"/> programming <a id="_idIndexMarker477"/>principle where the control over certain aspects of a program’s flow is handed over from the main code to a framework or a container. In simple terms, instead of a component being responsible for managing its dependencies and life cycle, these responsibilities are inverted or delegated to an external controller. This approach is particularly useful for creating modular and flexible systems.</p>
<p>In a typical software design without IoC, a class that requires certain functionalities from other classes would create or manage these dependent objects within itself. With IoC, this creation and management is handled by an external component, hence inverting the control.</p>
<p>IoC can be achieved through various methods such as DI, Factory Pattern, Service Locator, and more. Among these, DI is the most commonly used method in the context of MVVM.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Dependency Injection</h2>
<p>DI, a specific form<a id="_idIndexMarker478"/> of IoC, involves injecting the dependencies of an object (such as services or components) into the object by an external entity rather than having the object create them. This is typically done through the constructor.</p>
<p>Using DI brings a lot of advantages. Let’s take a look:</p>
<ul>
<li><strong class="bold">Separation of concerns</strong>: Each<a id="_idIndexMarker479"/> component or class focuses on its core responsibility. The creation and life cycle management of its dependencies are handled externally.</li>
<li><strong class="bold">Testability</strong>: DI makes it much easier to test components by allowing mock dependencies to be injected. This is crucial because, in unit testing, you want to isolate the component being tested and not have to worry about the dependencies. For example, if a ViewModel depends on a service that fetches data, you can inject a mock data service that simulates data retrieval without actually hitting a database or API. This makes tests faster, repeatable, and more reliable.</li>
<li><strong class="bold">Reusability and maintainability</strong>: Components become more reusable and maintainable because they are not tightly coupled with their dependencies.</li>
<li><strong class="bold">Flexibility</strong>: It becomes<a id="_idIndexMarker480"/> easier to change or swap implementations of dependencies without altering the dependent class.</li>
</ul>
<p>By allowing dependencies to be injected from the outside, DI supports the creation of more loosely coupled code. This not only results in a more maintainable and scalable system but is also highly advantageous for testing. Through the injection of mock or stub implementations during testing, you can focus on testing the functionality of individual components in isolation, without the complexity and unpredictability of the entire system.</p>
<p>The ability to inject different implementations is one of the powerful aspects of DI and is central to creating<a id="_idIndexMarker481"/> robust and flexible architectures.</p>
<p>Remember, back in <a href="B20941_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">What Is the MVVM Design Pattern?,</em> where we had a <code>MainPageViewModel</code> and its constructor accepted an interface called <code>IQuoteService</code>? Let’s have a look:</p>
<pre class="source-code">
public class MainPageViewModel : INotifyPropertyChanged
{
    private readonly IQuoteService quoteService;
    public MainPageViewModel(<strong class="bold">IQuoteService quoteService</strong>)
    {
        this.quoteService = quoteService;
    }
...
}</pre> <p>This is a textbook example of DI. <code>MainPageViewModel</code> should not be responsible for retrieving the “quote of the day.” Instead, this should be the responsibility of another class. <code>MainPageViewModel</code> is dependent on an instance of a class that implements <code>IQuoteService</code> for that functionality. However, instead of directly creating or managing an instance of this service, it receives the instance through its constructor. This is what’s <a id="_idIndexMarker482"/>known as <code>IQuoteService</code> dependency through its constructor, <code>MainPageViewModel</code> adheres to the principle<a id="_idIndexMarker483"/> of <code>MainPageViewModel</code> class’s responsibility is to provide data for the view, while the responsibility to fetch the actual data is delegated to <code>IQuoteService</code>.</p>
<p>Here, <code>MainPageViewModel</code> has no knowledge about where the class implementing the <code>IQuoteService</code> interface comes from, how it’s instantiated, or how its life cycle is managed. It simply receives an instance and uses it. This makes the ViewModel independent from the concrete implementation of the <code>IQuoteService</code> interface and it can be any class that implements this interface.</p>
<p>This <code>IQuoteService</code> interface, we can just create a new class that implements it and fetch data from the API. We can then inject this new class into our ViewModel without having to change any code inside <code>MainPageViewModel</code> itself. The ViewModel is only concerned with the fact it has a class implementing the <code>IQuoteService</code> interface to work with, not the details of how it accomplishes its tasks.</p>
<p class="callout-heading">Note</p>
<p class="callout">While it’s common to see DI used with interfaces, it’s not a strict requirement. Interfaces are popular in DI because they promote loose coupling. However, abstract classes or even concrete classes can be injected as well. The choice depends on the specific needs of your application and your design goals.</p>
<p>The advantage of this decoupling becomes even more evident when it comes to testing. Let’s say we want to write unit tests for <code>MainPageViewModel</code>. To make these tests reliable, we need to ensure they’re not affected by the unpredictability of external dependencies. With DI, we can easily achieve this by creating a mock implementation of <code>IQuoteService</code> that returns controlled data, perfect for testing scenarios. This way, we can test all aspects of <code>MainPageViewModel</code> in isolation, without any unpredictable <a id="_idIndexMarker486"/>behavior from external dependencies.</p>
<p>Let’s see DI in action and have a look at how we can register, resolve, and inject dependencies.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor124"/>Registering, resolving, and injecting services</h1>
<p>.NET MAUI comes with built-in support for DI. It has been designed with DI in mind, which allows for easier configuration and management of services that your application relies on. By providing out-of-the-box support for DI, .NET MAUI enables developers to leverage the concept of DI and IoC to make their code more maintainable and more loosely coupled. As the MVVM pattern benefits tremendously from DI and IoC, it shows again that MVVM and .NET MAUI are a perfect match!</p>
<p>The <code>Microsoft.Extensions.DependencyInjection</code> namespace is where .NET MAUI gets its default implementation for DI. However, it’s important to note that .NET MAUI is DI container agnostic, which means you’re not limited to the default. If you prefer a third-party DI container, you’re free to replace the default with your preferred choice. Let’s see how we can register services using .NET MAUI’s default DI implementation.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>Registering services</h2>
<p>.NET MAUI hosts a DI <a id="_idIndexMarker487"/>container and makes it accessible throughout your application. When your application starts, you have the opportunity to configure the services that will be available for injection. This is done using the <code>Services</code> property of the <code>MauiAppBuilder</code> instance. If you have worked with ASP.NET before, then you already know how this works. Through the <code>Services</code> property, we can set up services for use throughout your application.</p>
<p>The <code>Services</code> property on <code>MauiAppBuilder</code> is of type <code>IServiceCollection</code>, which is a framework-provided interface for a collection of service descriptors. It provides methods to register services in the container. In the following example, the <code>AddSingleton</code> method is used to register <code>QuoteService</code> as a Singleton service for the <code>IQuoteService</code> interface:</p>
<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    ...
    <strong class="bold">builder.Services.AddTransient&lt;IQuoteService,</strong>
<strong class="bold">      QuoteService&gt;();</strong>
    ...
    return builder.Build();
}</pre> <p>The preceding code shows how we can associate a concrete implementation (<code>QuoteService</code>) with an interface (<code>IQuoteService</code>). As a consequence, when the app’s <code>IServiceProvider</code> needs to<a id="_idIndexMarker488"/> resolve an instance of a class that implements the <code>IQuoteService</code>, it will create (or reuse) an instance of the <code>QuoteService</code> class. <code>IServiceProvider</code> represents a service container, which is a collection of service registrations. It’s essentially the object that is responsible for resolving and providing instances of services, which were registered through the associated <code>IServiceCollection</code>, when they are needed. Registering a concrete implementation for a particular interface allows us to decouple the implementation from the actual usage in our code. It’s good practice to code against interfaces and not against implementations and this is exactly what we can achieve here.</p>
<p>However, in the <a id="_idIndexMarker489"/>case of ViewModels or other classes that don’t necessarily have an associated interface, we can register them directly, as the following snippet shows:</p>
<pre class="source-code">
builder.Services.AddTransient&lt;MainPageViewModel&gt;();</pre> <p>When we do this, every time an instance of <code>MainPageViewModel</code> is requested from the DI container, it will provide an instance of the class and manage its life cycle.</p>
<p>Services can be registered in different ways, depending on their intended lifetimes:</p>
<ul>
<li><strong class="bold">Transient</strong>: Transient services are created each time they’re requested from the container. This lifetime works best for lightweight, stateless services. In theory, Transient services take up more memory because a new instance is created every time the service is requested. However, because each instance can be garbage-collected as soon as it’s no longer in use, this memory can be reclaimed quickly.</li>
<li><strong class="bold">Singleton</strong>: Singleton services are created once, and the same instance is used throughout the application’s lifetime. This works best for stateful services that need to maintain consistency across the app, or for heavy services that would be expensive to create multiple times. Singleton services take up the least amount of memory because only one instance is ever created. However, because the same instance is used throughout the entire application, it stays in memory for as long as the application is running.</li>
<li><strong class="bold">Scoped</strong>: Scoped services are created once per scope. However, in a .NET MAUI application, this is similar to Singleton since there is generally only one scope.</li>
</ul>
<p>Choosing between these lifetimes depends entirely on the specific needs of the service. If your service is stateless and lightweight, a Transient lifetime might be appropriate. If your service needs to maintain state across the entire application, or if it’s expensive to create, a Singleton lifetime might be the best option. Choosing the right lifetime for your services is important. It can affect how your app behaves and performs, so think about it carefully. In my experience, I usually choose Transient as much as possible for my services. I do this because I aim to keep my services simple and without state. This way, they use memory more efficiently since they’re removed as soon as they’re not needed. Also, it helps to avoid problems that can come up when a shared state is changed in different places, especially in multi-threaded situations. But remember, there’s no one-size-fits-all solution <a id="_idIndexMarker490"/>here. Each service is unique and so is your app. Depending on what your service does and what your app needs, you might have to choose a different lifetime. That’s why it’s key to understand these concepts and make smart choices for your specific app.</p>
<p>Let’s see how we can resolve and inject these registered services.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Resolving and injecting services</h2>
<p>DI containers, such<a id="_idIndexMarker491"/> as the one built into .NET MAUI, are <a id="_idIndexMarker492"/>capable of resolving not only direct dependencies but also nested dependencies.</p>
<p>In essence, when an instance of a class or service is being resolved by the container, all of its dependencies, and the dependencies of those dependencies, are automatically resolved and injected as well. This forms a complete object graph where every class has its dependencies satisfied.</p>
<p>If a particular class has a dependency that needs to be injected, it is as simple as defining the dependency as a parameter of the class’s constructor. That’s exactly what we did with <code>MainPageViewModel</code>: it has a constructor that requires an instance of a class implementing the <code>IQuoteService</code> interface.</p>
<p class="callout-heading">Which constructor does the DI container use?</p>
<p class="callout">As the DI container can instantiate classes for us, you might wonder which constructor it uses when the class has multiple constructors. The answer is pretty simple: it uses the constructor with the most parameters that it can resolve. If there are two or more constructors with the same number of parameters the DI container can resolve, or when no constructor is found for which all dependencies could be resolved, an exception will be thrown.</p>
<p>We are also able to resolve services on the fly, so long as we get a hold of the app’s <code>IServiceProvider</code> container. This interface exposes a <code>GetService&lt;T&gt;</code> method that we can call to get an instance of a class that was associated with the provided generic type parameter. The following code block shows how we can create a static <code>ServiceProvider</code> class that we could use to access the services container from anywhere in our app:</p>
<pre class="source-code">
public static class ServiceProvider
{
    public static TService GetService&lt;TService&gt;()
        =&gt; Current.GetService&lt;TService&gt;();
    public static IServiceProvider Current
        =&gt;
#if WINDOWS10_0_17763_0_OR_GREATER
        MauiWinUIApplication.Current.Services;
#elif ANDROID
        MauiApplication.Current.Services;
#elif IOS || MACCATALYST
       MauiUIApplicationDelegate.Current.Services;
#else
      null;
#endif
}</pre> <p>So, instead of instantiating a <code>MainPageViewModel</code> in the code behind the <code>MainPage_MVVM</code> class, and needing to manually provide an instance of a class that<a id="_idIndexMarker493"/> implements IQuoteService, we <a id="_idIndexMarker494"/>can do the following:</p>
<pre class="source-code">
public MainPage_MVVM()
{
    InitializeComponent();
    BindingContext = <strong class="bold">ServiceProvider</strong>
<strong class="bold">        .GetService&lt;MainPageViewModel&gt;();</strong>
}</pre> <p>Because we have registered <code>MainPageViewModel</code> as a service and <code>QuoteService</code>, which we associated with the <code>IQuoteService</code> interface, the <code>GetService</code> method will return an instance of <code>MainPageViewModel</code>, which is instantiated by injecting an instance of the <code>QuoteService</code> class through its constructor. This <code>ServiceProvider</code> class can be very helpful to resolve instances of classes on the fly from the DI container. However, for this particular example, we could take this a step further and avoid the need to manually resolve an instance of <code>MainPageViewModel</code>. We can achieve this by adding an instance of <code>MainPageViewModel</code> as a dependency to the <code>MainPage_MVVM</code> class, as shown here:</p>
<pre class="source-code">
public MainPage_MVVM(<strong class="bold">MainPageViewModel vm</strong>)
{
    InitializeComponent();
    <strong class="bold">BindingContext = vm;</strong>
}</pre> <p>The following code snippet shows how we can register the <code>MainPage_MVVM</code> class as well:</p>
<pre class="source-code">
builder.Services.AddTransient&lt;MainPage_MVVM&gt;();</pre> <p>In this sample app, we’re using .NET MAUI Shell for navigation. This allows an instance of a page to be dynamically resolved during the navigation process. So, when we navigate to the <code>MainPage_MVVM</code> page, the DI container springs into action. It resolves an instance of the <code>MainPage_MVVM</code> page and all of its dependencies.</p>
<p class="callout-heading">What is .NET MAUI Shell?</p>
<p class="callout">In <a href="B20941_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Navigation in MVVM</em>, we will dive much deeper into the aspects of navigation<a id="_idIndexMarker495"/> and .NET MAUI Shell.</p>
<p>Now that we’ve got a taste of DI with the <em class="italic">Quote of the Day</em> app, let’s take things up a notch by applying what we’ve learned to our feature-rich <em class="italic">Recipes!</em> app. This will allow us to delve<a id="_idIndexMarker496"/> deeper<a id="_idIndexMarker497"/> into DI and see how it can be skillfully utilized in a more complex project. So, roll up your sleeves, and let’s get cooking with DI in the <em class="italic">Recipes!</em> app.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Applying Dependency Injection</h2>
<p>So far, in the ViewModels<a id="_idIndexMarker498"/> in our <em class="italic">Recipes!</em> app we have been working with hard-coded data. Now, it’s time to breathe more life into our application by introducing services that can fetch and manage data dynamically. The <code>Begin</code> directory in the GitHub repository for this chapter presents some updates and additional code that includes new service interfaces such as <code>IRecipeService</code>, <code>IFavoritesService</code>, and <code>IRatingsService</code>, along with their respective implementations. These services will play crucial roles in our application: the <code>IRecipeService</code> interface defines a contract for a service that will load and manage recipe data. Similarly, <code>IFavoritesService</code> outlines the rules for a service that will handle the user’s favorite recipes, and the <code>IRatingsService</code> interface does the same for a service managing recipe ratings. As we move forward, we’ll explore how to use these services within the MVVM architecture and how DI brings it all together in a clean, manageable manner.</p>
<p>To introduce DI in our <em class="italic">Recipes!</em> app, we need to make sure that, unlike what we have been doing up until now, we don’t initialize ViewModels in the code-behind ourselves. Instead, these ViewModels <a id="_idIndexMarker499"/>need to be injected and assigned to the page’s <code>BindingContext</code>. Let’s have a look at this before we update the ViewModels.</p>
<h3>Adding dependencies to pages</h3>
<p>To add the dependency<a id="_idIndexMarker500"/> of a particular ViewModel to a page, we simply need to add the type of ViewModel as a parameter to the constructor. Also, we need to make sure that both the page and the ViewModel are registered in the DI container:</p>
<ol>
<li>Head over to the code-behind of <code>RecipesOverviewPage</code> and add a parameter of type <code>RecipeOverviewViewModel</code> to the page’s constructor, as shown in the following snippet:<pre class="source-code">
public RecipesOverviewPage(RecipesOverviewViewModel
  viewModel)
{
    InitializeComponent();
    BindingContext = viewModel;
}</pre></li> <li>Next, we need to make sure the <code>RecipesOverviewPage</code> and <code>RecipeOverviewViewModel</code> classes are registered with the DI container. Only then can the DI container resolve <code>RecipesOverviewPage</code> and resolve its dependency, an instance of <code>RecipesOverviewViewModel</code>. Head over to <code>MauiProgram</code> and add the following lines of code:<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
    ...
    <strong class="bold">builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipesOverviewPage&gt;();</strong>
    <strong class="bold">builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipesOverviewViewModel&gt;();</strong>
    ...
}</pre></li> <li>Similarly, we need to<a id="_idIndexMarker501"/> do the same for <code>RecipeDetailPage</code> and <code>RecipeRatingDetailPage</code>: add their respective ViewModels as dependencies by including them as parameters. This is what it looks like for <code>RecipesOverviewPage</code>:<pre class="source-code">
public RecipesOverviewPage(
    RecipesOverviewViewModel viewModel)
{
    InitializeComponent();
    BindingContext = viewModel;
}</pre><p class="list-inset">And likewise, for <code>RecipeRatingDetailPage</code>, we must do the following, where we want to inject <code>RecipeRatingsDetailViewModel</code>:</p><pre class="source-code">public RecipeRatingDetailPage(
    RecipeRatingsDetailViewModel viewModel)
{
    InitializeComponent();
    BindingContext = viewModel;
}</pre></li> <li>Now, just like we did before, let’s register these additional pages and their ViewModels in the<a id="_idIndexMarker502"/> DI container within the <code>MauiProgram</code> class:<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
    ...
    builder.Services
        .AddTransient&lt;RecipesOverviewPage&gt;();
    builder.Services
        .AddTransient&lt;RecipesOverviewViewModel&gt;();
    <strong class="bold">builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeDetailPage&gt;();</strong>
<strong class="bold">    builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeDetailViewModel&gt;();</strong>
<strong class="bold">    builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeRatingDetailPage&gt;();</strong>
<strong class="bold">    builder.Services</strong>
<strong class="bold">        .AddTransient&lt;RecipeRatingsDetailViewModel&gt;();</strong>
...
}</pre></li> </ol>
<p>With these modifications in place, we’ve successfully implemented the foundational elements of DI in our <em class="italic">Recipes!</em> app. By registering the pages and their corresponding ViewModels with the DI container, we’ve ensured that whenever these components are needed, they can be easily resolved and provided by the DI container. Moreover, by injecting the ViewModels into our pages through their constructors, we’ve shifted the responsibility of creating and managing ViewModel instances away from the pages themselves and toward the DI container. This sets up a more flexible and maintainable structure for our application, paving the way for us to further enhance it with additional services and<a id="_idIndexMarker503"/> functionality.</p>
<p>Now, let’s take a closer look at the specific changes we need to make to our ViewModels to fully incorporate DI.</p>
<h3>Adding dependencies to ViewModels</h3>
<p>We no longer <a id="_idIndexMarker504"/>want our ViewModels to contain <a id="_idIndexMarker505"/>hard-coded data, nor do we want them to be responsible for retrieving data. So, let’s introduce some dependencies to our ViewModels:</p>
<ol>
<li>At the very top of the <code>RecipesOverviewViewModel</code> class, we can start by removing the <code>items</code> field. We’re moving away from hard-coded data and will use services to fetch data instead.</li>
<li>The following code snippet shows how we introduce two fields to this class: <code>recipeService</code>, which is of type <code>IRecipeService</code>, and <code>favoritesService</code>, which is of type <code>IFavoritesService</code>:<pre class="source-code">
private readonly IRecipeService recipeService;
private readonly IFavoritesService favoritesService;</pre><p class="list-inset">These services will take responsibility for loading the recipes on this page and displaying whether they are favorited by the user or not. Both of these services are dependencies that will be injected into the ViewModel.</p></li> <li>This code block shows exactly how these dependencies can get injected through the constructor of the ViewModel:<pre class="source-code">
public RecipesOverviewViewModel(
    <strong class="bold">IRecipeService recipeService</strong>,
    <strong class="bold">IFavoritesService favoritesService</strong>)
{
    <strong class="bold">this.recipeService = recipeService;</strong>
    <strong class="bold">this.favoritesService = favoritesService;</strong>
    Recipes = new ();
    TryLoadMoreItemsCommand =
        new AsyncRelayCommand(TryLoadMoreItems);
    NavigateToSelectedDetailCommand =
        new AsyncRelayCommand
          (NavigateToSelectedDetail);
    LoadRecipes(7, 0);
}</pre><p class="list-inset">By defining <a id="_idIndexMarker506"/>these<a id="_idIndexMarker507"/> two parameters in the constructor for <code>RecipesOverviewViewModel</code>, the DI container will attempt to resolve instances for both when creating a <code>RecipesOverviewViewModel</code>. The resolved instances are then passed as parameters to the constructor, where we can assign them to the fields we created earlier.</p></li> <li>When we examine the <code>LoadRecipes</code> method, we can see how we utilize these services to load the data we need:<pre class="source-code">
private async Task LoadRecipes(int pageSize, int page)
{
    var loadRecipesTask =
        <strong class="bold">recipeService.LoadRecipes(pageSize, page);</strong>
    var loadFavoritesTask =
        <strong class="bold">favoritesService.LoadFavorites();</strong>
   ...
}</pre><p class="list-inset">The ViewModel doesn’t concern itself with where these recipes or favorites are coming from. It only trusts that the injected services – <code>recipeService</code> and <code>favoritesService</code> – adhere to the specified interfaces and deliver the required functionality. The exact implementation is abstracted away from the ViewModel, highlighting one of the main benefits of DI.</p></li> <li>Head over to <code>RecipeDetailViewModel</code>. In this class, we also want to remove all hard-coded data: <code>Title</code>, <code>Allergens</code>, <code>Calories</code>, and so on. And while we are at it, we should update the properties to “full” properties that trigger the <code>PropertyChanged</code> event. This is needed because the data on the ViewModel <a id="_idIndexMarker508"/>will be<a id="_idIndexMarker509"/> loaded asynchronously, so it won’t be there when the page is being rendered. As a result, the <code>PropertyChanged</code> event for each property needs to be triggered when the data is loaded to reflect the loaded values on the UI. The following snippet shows some of the updated properties:<pre class="source-code">
string _title;
public string Title
{
    get =&gt; _title;
    set =&gt; SetProperty(ref _title, value);
}
string[] _allergens = new string[0];
public string[] Allergens
{
    get =&gt; _allergens;
    set =&gt; SetProperty(ref _allergens, value);
}
int? _calories;
public int? Calories
{
    get =&gt; _calories;
    set =&gt; SetProperty(ref _calories, value);
}</pre></li> <li>Now is also the time to update the binding mode on the label, which shows the recipe’s title. Up until now, this was defined as a <code>OneTime</code> binding, but as we now load the data of the recipe after the ViewModel is set as the <code>BindingContext</code> of the <code>RecipeDetailPage</code>, we need to make sure the updated<a id="_idIndexMarker510"/> value is<a id="_idIndexMarker511"/> shown on the screen as well. Let’s update the binding mode to <code>OneWay</code> so that when the <code>PropertyChanged</code> event is triggered after the value of the <code>Title</code> property is set, the binding engine updates the value on the UI. The following snippet shows the updated label:<pre class="source-code">
&lt;Label
    FontAttributes="Bold"
    FontSize="22"
    Text="{Binding Path=Title, <strong class="bold">Mode=OneWay</strong>}"
    VerticalOptions="Center" /&gt;</pre></li> <li>Let’s update the constructor of <code>RecipeDetailViewModel</code> so that it accepts an instance of <code>IRecipeService</code>, <code>IFavoritesService</code>, and <code>IRatingsService</code>, as shown here:<pre class="source-code">
public RecipeDetailViewModel(
    IRecipeService recipeService,
    IFavoritesService favoritesService,
    IRatingsService ratingsService)
{
    this.recipeService = recipeService;
    this.favoritesService  = favoritesService;
    this.ratingsService = ratingsService;
...
}</pre></li> <li>These services (<code>recipeService</code>, <code>favoritesService</code>, and <code>ratingsService</code>) are <code>readonly</code> fields that we should define in the ViewModel, as demonstrated in the following snippet:<pre class="source-code">
private readonly IRecipeService recipeService;
private readonly IFavoritesService favoritesService;
private readonly IRatingsService ratingsService;</pre></li> <li>The following<a id="_idIndexMarker512"/> code<a id="_idIndexMarker513"/> block shows <code>LoadRecipe</code>, which accepts the ID of the recipe to load as a parameter. This method uses the injected services to load all relevant data for this ViewModel:<pre class="source-code">
private async Task LoadRecipe(string recipeId)
{
    var loadRecipeTask =
        <strong class="bold">recipeService.LoadRecipe(recipeId);</strong>
    var loadIsFavoriteTask =
        <strong class="bold">favoritesService.IsFavorite(recipeId);</strong>
    var loadRatingsTask =
        <strong class="bold">ratingsService.LoadRatingsSummary(recipeId);</strong>
    await Task.WhenAll(loadRecipeTask,
        loadRecipeTask, loadRatingsTask);
    if(loadRecipeTask.Result is not null)
        MapRecipeData(
            loadRecipeTask.Result,
            loadRatingsTask.Result,
            loadIsFavoriteTask.Result);
}</pre><p class="list-inset">The three async tasks that retrieve <code>RecipeDetailDto</code>, <code>RatingsSummaryDto</code>, and the <code>bool</code> value indicating whether the recipe is a favorite or not are launched in parallel. Through the <code>Task.WhenAll</code> method, we wait for all<a id="_idIndexMarker514"/> three to complete. Beyond <a id="_idIndexMarker515"/>this point, the <code>Result</code> property of the tasks holds the retrieved data. This data is then mapped to the ViewModel through the <code>MapRecipeData</code> method.</p></li> <li>In the next chapter, <a href="B20941_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Navigation in MVVM</em>, we’ll have a look at how we can pass the ID of the selected recipe from <code>RecipesOverviewViewModel</code> to <code>RecipeDetailViewModel</code> to load the recipe details of the chosen recipe. For now, let’s add the following snippet at the end of the ViewModel’s constructor to load the details of the recipe with an ID of <code>3</code>:<pre class="source-code">
LoadRecipe("3");</pre></li> <li>Finally, we also need to update <code>RecipeRatingsDetailViewModel</code>. As before, we want to remove all hard-coded data and update the constructor so that it accepts an instance of a class that implements <code>IRecipeService</code> and one that implements the <code>IRatingsService</code> interface. The following snippet shows the updated constructor, where we also deleted the initialization of both the <code>Reviews</code> and <code>GroupedReviews</code> properties:<pre class="source-code">
public RecipeRatingsDetailViewModel(
    IRecipeService recipeService,
    IRatingsService ratingsService)
{
    this.recipeService = recipeService;
    this.ratingsService = ratingsService;
    ...
}</pre></li> <li>The <code>Reviews</code> property can be removed and we should make sure the <code>RecipeTitle</code> property calls the <code>PropertyChanged</code> event when it is being updated. Again, like we did previously, we must do this because the data is loaded asynchronously and we must notify the UI about the updated values. The following code block shows the updated <code>RecipeTitle</code> property, which uses the <code>SetProperty</code> method of the <code>ObservableObject</code> class to assign the value <a id="_idIndexMarker516"/>and trigger the <code>PropertyChanged</code> event. It also shows the <a id="_idIndexMarker517"/>fields that we added, to which we assign the injected dependencies in the constructor:<pre class="source-code">
public class RecipeRatingsDetailViewModel :
  ObservableObject
{
    private readonly IRatingsService ratingsService;
    private readonly IRecipeService recipeService;
    string _recipeTitle = string.Empty;
    public string RecipeTitle
    {
        get =&gt; _recipeTitle;
        set =&gt; SetProperty(ref _recipeTitle, value);
    }
    …
}</pre></li> <li>Let’s also add the <code>LoadData</code> method, which accepts the ID of the recipe we want to load the rating for. It uses the injected services to dynamically load the data <a id="_idIndexMarker518"/>needed <a id="_idIndexMarker519"/>in this ViewModel. Let’s take a look:<pre class="source-code">
private async Task LoadData(string recipeId)
{
    var recipeTask =
        <strong class="bold">recipeService.LoadRecipe(recipeId);</strong>
    var ratingsTask =
        <strong class="bold">ratingsService.LoadRatings(recipeId);</strong>
    await Task.WhenAll(recipeTask, ratingsTask);
    RecipeTitle =
        recipeTask.Result?.Name ?? string.Empty;
    GroupedReviews = ratingsTask.Result
        ...
        .ToList();
}</pre></li> <li>For now, let’s call the <code>LoadData</code> method from the constructor so that it loads some data when we initialize the ViewModel:<pre class="source-code">
LoadData("3");</pre></li> </ol>
<p>With all the updates<a id="_idIndexMarker520"/> done on the ViewModels, let’s<a id="_idIndexMarker521"/> finish up by registering the services that our updated ViewModels now have as dependencies.</p>
<h3>Registering services</h3>
<p>Now that <a id="_idIndexMarker522"/>our ViewModels have some dependencies, we have to make sure these dependencies get registered so that the DI container can resolve them.</p>
<p>Registering the required dependencies is done again in the <code>MauiProgram</code> class. The following snippet shows how we register <code>FavoritesService</code>, which is very straightforward:</p>
<pre class="source-code">
builder.Services.AddSingleton&lt;IFavoritesService,
  FavoritesService&gt;();</pre> <p>We intentionally register <code>FavoritesService</code> as a Singleton because this particular implementation stores the user’s favorites in memory. If we were to register it as Transient, a new instance would be created each time it’s injected as a dependency, which would result in the favorites not persisting between page navigations. It’s worth noting, however, that keeping favorites in memory isn’t ideal, but for the sake of this example, it will serve our purpose. In a real-life scenario, we would want the favorites to be persisted in an (online) data store.</p>
<p>Registering <code>RecipeService</code> involves a slightly more complex process. The reason for this is that the constructor of <code>RecipeService</code> requires a <code>Task</code> property that returns a stream to a JSON file that holds all the recipe information. This is shown in the constructor of <code>RecipeService</code>:</p>
<pre class="source-code">
public RecipeService(Task&lt;Stream&gt; recipesJsonStreamTask)
{
    this.recipesJsonStreamTask = recipesJsonStreamTask;
}</pre> <p>We can’t register <code>RecipeService</code> in the same way we did with <code>FavoritesService</code> or other services we registered in earlier examples. This is because the DI container needs to know what parameter to pass to the constructor. In previous examples, it was straightforward: we just specified the concrete type that we wanted to associate with an interface or base class, or with the type itself. The container could then create an instance of the concrete class by invoking its default constructor or injecting other resolved dependencies.</p>
<p>However, in the case of <code>RecipeService</code>, the required parameter for creating an instance isn’t something we plan to register, meaning it cannot be resolved by the DI container. To tackle scenarios like this, the <code>AddTransient</code>, <code>AddSingleton</code>, and <code>AddScoped</code> methods provide an overload. This overload lets us pass in a function that returns an instance of the type we want to associate with the given base type. This function is invoked every time the associated type needs to be resolved. What’s more, the function’s parameter is <code>IServiceProvider</code> itself, allowing us to resolve any additional dependencies if necessary. The following code block shows how we can register <code>RecipeService</code>, using the overloaded function, while passing in a function that creates an instance of this class:</p>
<pre class="source-code">
builder.Services.AddTransient&lt;IRecipeService&gt;(
    serviceProvider =&gt; new RecipeService( FileSystem.
      OpenAppPackageFileAsync("recipedetails.json")));</pre> <p>The passed-in<a id="_idIndexMarker523"/> function will be invoked every time an object of <code>IRecipeService</code> needs to be resolved by the DI container. However, as the <code>AddSingleton</code> method was used, the function would be invoked only once. This means that in this specific use case, registering the service as a Singleton could be a sensible decision as it would ensure that the JSON file only gets read once, keeping the recipes in memory, and thereby optimizing the application’s performance.</p>
<p>The same thing goes for the registration of <code>RatingsService</code>. Just like <code>RecipeService</code>, this class will also read from a local file to get the ratings. So, as before, we want to register this service using the overloaded <code>AddTransient</code> method, as shown here:</p>
<pre class="source-code">
builder.Services.AddSingleton&lt;IRatingsService&gt;(
    serviceProvider =&gt; new RatingsService( FileSystem.
       OpenAppPackageFileAsync("ratings.json")));</pre> <p>Once all these services have been registered, we can go ahead and run the <em class="italic">Recipes!</em> app. Our code now leverages DI, a practice that greatly enhances the modularity and testability of our application. By injecting dependencies, we decouple concrete classes with interfaces or base classes, allowing us to change or swap underlying implementations without affecting dependent classes. In the context of the MVVM pattern, DI allows us to provide ViewModels with the necessary services to handle their tasks, such as data fetching or business logic, without hard-coding these dependencies, promoting a clean separation of concerns. Moreover, we have even taken this concept a step further by using DI to inject ViewModels directly into our views, further emphasizing the flexibility and versatility this practice provides in our app development process.</p>
<p class="callout-heading">Note</p>
<p class="callout">While we’ve primarily discussed constructor-based DI in .NET MAUI, it’s worth mentioning that in broader contexts, dependencies can also be injected via properties or methods. However, such methods are not natively supported in .NET MAUI. The essence of DI is providing the class with its dependencies, irrespective of the method. Constructor injection is often preferred for clarity, but the technique that’s used might vary based on the platform and the design goals.</p>
<p>DI plays a crucial <a id="_idIndexMarker524"/>role in keeping our application’s components decoupled. Next, we’ll delve into another mechanism that promotes decoupling in our application.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor128"/>Messaging</h1>
<p>Messaging is a <a id="_idIndexMarker525"/>software architectural pattern that facilitates communication between different parts of an application. In the context of .NET MAUI and MVVM architecture, messaging is typically used to send notifications between loosely coupled components, such as between ViewModels, or from a Model to a ViewModel. This decouples the components and promotes a more modular and maintainable code base.</p>
<p>The concept of messaging is especially useful when data needs to be passed or events need to be communicated between parts of your application that do not have a direct relationship. Instead of tightly coupling these parts by having them directly call each other, you can use a messaging system where one part sends a message that any interested part of your application can receive and react to.</p>
<p>This pattern is a form<a id="_idIndexMarker526"/> of the <strong class="bold">Observer</strong> pattern, where an object, named the <strong class="bold">Subject</strong>, maintains a list of its dependents, called <strong class="bold">Observers</strong>, and notifies them automatically of any state changes, typically by calling one of their methods. Similarly, in MVVM, messaging is used to communicate between decoupled components of the application: any object in your application, including a ViewModel, a service, or a model class or service can send a message, and any other class that is subscribed to that particular type of message will be <a id="_idIndexMarker527"/>notified and can react accordingly.</p>
<p class="callout-heading">About MessagingCenter</p>
<p class="callout"><code>MessagingCenter</code>, originally <a id="_idIndexMarker528"/>introduced in Xamarin.Forms as a mechanism for loosely-coupled communication between components, is present but marked as obsolete in .NET MAUI. While it’s retained in .NET 8 for transition scenarios, its use is discouraged!</p>
<p>Typically, in the context of MVVM, as shown in the following figure, the messaging system itself maintains a list of observers and handles passing messages from senders to appropriate receivers:</p>
<div><div><img alt="Figure 7.1: Messaging overview" height="568" src="img/B20941_07_01.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Messaging overview</p>
<p>One notable challenge with the messaging pattern is its inherent opacity: it can be difficult to determine which parts of the application are subscribing to a particular message. This lack of transparency can lead to unforeseen side effects when altering the code and makes the code base more challenging to navigate and debug. When I do use messaging, I use it with caution. Keeping messages minimal and focused on a specific task can help mitigate this challenge. Another potential risk of using messaging is inadvertently causing memory leaks. This can occur when an object subscribes to a message but never unsubscribes. If this happens, the messaging system continues to hold a reference to the subscriber object, preventing it from being garbage collected even if there are no other references to it in the application. Over time, this can lead to increased memory usage and can eventually degrade the performance of the application.</p>
<p>This issue is particularly important in the context of MVVM, where ViewModels might subscribe to messages<a id="_idIndexMarker529"/> during their initialization and then get replaced by new ViewModels as the user navigates through the application. If these ViewModels don’t unsubscribe from the messages when they’re no longer in use, they will stay in memory indefinitely.</p>
<p>That’s where <code>WeakReferenceMessenger</code> comes in.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor129"/>WeakReferenceMessenger</h2>
<p>The MVVM <a id="_idIndexMarker530"/>Toolkit, which we discussed earlier, provides us with a robust messenger implementation called <code>WeakReferenceMessenger</code>. Designed with MVVM applications in mind, this messenger ensures we can enjoy the benefits of messaging without worrying about potential memory leaks.</p>
<p>Unlike a traditional messenger, which holds strong references to its subscribers, <code>WeakReferenceMessenger</code> holds weak references. This means it doesn’t prevent its subscribers from being garbage collected. So, even if you forget to unsubscribe, the garbage collector can still clean up your ViewModel when it’s no longer in use, preventing memory leaks.</p>
<p class="callout-heading">Note</p>
<p class="callout">In this section, we’ll be using <code>WeakReferenceMessenger</code> from the MVVM Toolkit as our messaging system. However, it’s important to note that other messaging systems are available as well. While we’re focusing on <code>WeakReferenceMessenger</code>, the core concepts we’ll be discussing here – such as sending and receiving messages – apply to most messaging systems. Always remember to study and understand the specific messaging system you’re working with to make the most of its features and avoid potential pitfalls.</p>
<p><code>WeakReferenceMessenger</code> uses a type-based messaging system. This means that when you send a <a id="_idIndexMarker531"/>message, you specify a message type and only the recipients that have subscribed to that specific type will receive the message. The message type is typically defined as a class, and the message data is stored as properties of that class.</p>
<p>To send a message, you must use the <code>Send</code> method, passing in the message object and, optionally, a sender and target. The messenger will then deliver the message to all the registered recipients for the specified message type. To receive messages, a class needs to register with the messenger by calling the <code>Register</code> method, specifying the message type it wishes to receive, and providing a callback method that will be invoked when a message of that type is sent.</p>
<p>Let’s take a <a id="_idIndexMarker532"/>look at how we can update our code and make it more loosely coupled by using <code>WeakReferenceMessenger</code>.</p>
<h3>Updating the number of servings</h3>
<p>Through<a id="_idIndexMarker533"/> messaging, ViewModels can communicate with each other in a loosely coupled manner. As an example, let’s take a look at <code>IngredientsListViewModel</code>. When updating the value of the <code>NumberOfServings</code> property, we loop through all elements in the <code>Ingredients</code> collection (which are <code>RecipeIngredientViewModel</code> objects) and call their <code>UpdateServings</code> method, passing in the updated value:</p>
<pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set
    {
        if (SetProperty(ref _numberOfServings, value))
        {
            <strong class="bold">Ingredients</strong>
<strong class="bold">                .ForEach(i =&gt; i.UpdateServings(value));</strong>
        }
    }
}</pre> <p>This approach is tightly coupled since the property knows about the implementation details of other objects, specifically <code>RecipeIngredientViewModel</code>. Also, it doesn’t adhere well to the <strong class="bold">Single Responsibility Principle</strong>: <em class="italic">the property doesn’t only concern itself; it is also responsible for updating the values of </em><em class="italic">other properties.</em></p>
<p>So, let’s introduce messaging here!</p>
<ul>
<li>As <code>WeakReferenceMessenger</code> is a type-based messaging system, we must create a new type that we can send and subscribe to whenever the number of servings is being updated by the user. Right-click the <code>Messages</code>.</li>
<li>Right-click the <code>ServingsChangedMessage</code>.</li>
</ul>
<p>Although <code>WeakReferenceMessenger</code> can send messages of any type, there are some base message classes you might want to inherit from. In this case, we could inherit from the generic <code>CommunityToolkit.Mvvm.Messaging.Messages.ValueChanged</code> class because that is exactly what <code>ServingsChangedMessage</code> is for.</p>
<p>The following code block shows the implementation of this class:</p>
<pre class="source-code">
using CommunityToolkit.Mvvm.Messaging.Messages;
namespace Recipes.Client.Core.Messages;
public class ServingsChangedMessage :
    ValueChangedMessage&lt;int&gt;
{
    public ServingsChangedMessage(int value)
        : base(value)
    { }
}</pre> <p>We can now <a id="_idIndexMarker534"/>go ahead and update the <code>NumberOfServings</code> method on the <code>IngredientsListViewModel</code> class. Instead of looping over every item in the ingredients list and calling its <code>UpdateServings</code> method, we can now send <code>ServingsChangedMessage</code>, as shown here:</p>
<pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set
    {
        if (SetProperty(ref _numberOfServings, value))
        {
            <strong class="bold">WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">                new ServingsChangedMessage(value));</strong>
        }
    }
}</pre> <p>Sending a message is as easy as calling the <code>Send</code> method on an instance of <code>WeakReferenceMessenger</code>, passing the message you want to send.</p>
<p>Finally, we need to update <code>RecipeIngredientViewModel</code>. This class will need to subscribe to <code>ServingsChangedMessage</code> so that it can react to it. Registering to a type of message is done by calling the generic <code>Register</code> method on <code>WeakReferenceMessenger</code>. As a type parameter, you need to pass in the type of message you want to listen to. Here is one way to register to the <code>ServingsChangedMessage</code>:</p>
<pre class="source-code">
public RecipeIngredientViewModel(...)
{
...
    WeakReferenceMessenger.Default
    .Register&lt;ServingsChangedMessage&gt;(this, (r, m) =&gt;
    ((RecipeIngredientViewModel)r)
    .UpdateServings(m.Value));
}</pre> <p>The first parameter<a id="_idIndexMarker535"/> of the <code>Register</code> method is the recipient of the message, which in our case will be the class itself. The second parameter is the handler that gets invoked when the message is received. The first parameter of the handler is the receiver and the second one is the message itself. The passed-in receiver allows the Lambda expression to not capture <code>this</code>, which improves performance. It might also be a good idea to update the access modifier of the <code>UpdateServings</code> method to <code>private</code> as no public access to this method is needed anymore.</p>
<p>With this updated implementation, the <code>NumberOfServings</code> property in <code>IngredientsListViewModel</code> no longer needs to know about the <code>RecipeIngredientViewModel</code> objects. Instead, it simply sends a message when its value changes. The <code>RecipeIngredientViewModel</code> objects, which are subscribed to these messages, can update their state accordingly. This decouples the two classes and ensures that each is only responsible for managing its own state, adhering to the single responsibility principle and separation of concerns.</p>
<p>In the following <a id="_idIndexMarker536"/>example, we’ll have a look at the fact that messaging isn’t only valuable between ViewModels. A service might also send messages that ViewModels can respond to.</p>
<h3>Keeping favorites in sync</h3>
<p>In the <em class="italic">Recipes!</em> app, the <code>RecipesOverviewPage</code> displays<a id="_idIndexMarker537"/> all recipes, and users can mark favorites on the <code>RecipeDetailPage</code>. However, without reloading <code>RecipesOverviewPage</code>, newly favorited recipes aren’t highlighted. Given that the recipes database isn’t frequently updated, constant page reloads would be overkill and could be bad for the user experience.</p>
<p>A more efficient strategy involves using messaging. When a recipe is favorited, a message is dispatched. The individual <code>RecipeListItemViewModel</code>s contained within <code>RecipesOverviewViewModel</code> subscribe to this message, and upon receiving it, they update their favorite status in real time. This approach prevents unnecessary data fetches, thereby enhancing the app’s performance and responsiveness. Let’s see what we need to do to make this work:</p>
<ol>
<li>First, let’s add a new message type. Right-click the <code>FavoriteUpdateMessage</code> as the class name.</li>
<li>Add the following code to the <code>FavoriteUpdateMessage</code> class:<pre class="source-code">
public class FavoriteUpdateMessage
{
    public string RecipeId { get; }
    public bool IsFavorite { get; }
    public FavoriteUpdateMessage(string recipeId,
        bool isFavorite)
    {
        RecipeId = recipeId;
        IsFavorite = isFavorite;
    }
}</pre><p class="list-inset">This class holds two properties, <code>RecipeId</code> and <code>IsFavorite</code>, so that with this message, we can signal which recipe has been marked or removed as a favorite.</p></li> <li>The following<a id="_idIndexMarker538"/> code block shows how we can send this <code>FavoriteUpdateMessage</code> from the <code>FavoritesService</code> whenever a recipe is added as a favorite:<pre class="source-code">
public Task Add(string id)
{
    if(!favorites.Contains(id))
    {
        favorites.Add(id);
<strong class="bold">        WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">            new FavoriteUpdateMessage(id, true));</strong>
    }
    return Task.CompletedTask;
}</pre></li> <li>Similarly, when a recipe is removed as a favorite, a <code>FavoriteUpdateMessage</code> can be sent, as shown here:<pre class="source-code">
public Task Remove(string id)
{
    if (favorites.Contains(id))
    {
        favorites.Remove(id);
        <strong class="bold">WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">            new FavoriteUpdateMessage(id, false));</strong>
    }
    return Task.CompletedTask;
}</pre></li> <li>The final step involves subscribing to this message in <code>RecipeListItemViewModel</code>. This ensures that when a <code>FavoriteUpdateMessage</code> arrives, the <code>IsFavorite</code> property can be updated accordingly. Unlike the previous example, where we defined a message handler <a id="_idIndexMarker539"/>using the <code>Register</code> method, we’ll use a different approach this time by implementing the <code>IRecipient</code> interface. Here’s how we can do this:<pre class="source-code">
public class RecipeListItemViewModel :
    ObservableObject,
    <strong class="bold">IRecipient&lt;FavoriteUpdateMessage&gt;</strong>
{
...
    public RecipeListItemViewModel(...)
    {
        ...
        <strong class="bold">WeakReferenceMessenger.Default.Register(this);</strong>
    }
    <strong class="bold">void IRecipient&lt;FavoriteUpdateMessage&gt;</strong>
<strong class="bold">        .Receive(FavoriteUpdateMessage message)</strong>
    {
        if (message.RecipeId == Id)
        {
            IsFavorite = message.IsFavorite;
        }
    }
}</pre><p class="list-inset">By implementing the <code>CommunityToolkit.Mvvm.Messaging.IRecipient&lt;TMessage&gt;</code> interface, where <code>TMessage</code> is <code>FavoriteUpdateMessage</code> in this case, we’re specifying the type of message we want to handle. Implementing this interface allows us to call the <code>Register</code> method of <code>WeakReferenceMessenger</code> and pass the class itself as the only parameter. The interface requires us to implement the <code>Receive</code> method, which is invoked when a message of the specified type is received.</p></li> </ol>
<p>Through the <a id="_idIndexMarker540"/>updated code, a message is dispatched whenever a user adds or removes a recipe as a favorite. Instances of <code>RecipeListItemViewModel</code> are set to listen for this message and update their <code>IsFavorite</code> property accordingly. As a result, when the user navigates back from a detail page, where the favorite status was updated, the refreshed status is immediately visible on the overview page – all without reloading any data.</p>
<p class="callout-heading">Note</p>
<p class="callout">While <code>WeakReferenceMessenger</code> provides a robust solution for many messaging scenarios, it’s important to use it with caution when dealing with a large number of listeners. Always monitor the performance and behavior of your application, especially when dispatching messages to thousands of listeners, and consider optimizing or reevaluating your design if necessary.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Summary</h1>
<p>In this chapter, we delved into two pivotal topics in the architecture of modern applications: DI and messaging. First, we explored DI, a technique for achieving loose coupling between objects and their dependencies. In the context of the MVVM pattern, we utilized this technique to inject services and other dependencies into our ViewModels, enhancing their testability and maintainability.</p>
<p>The latter part of this chapter focused on messaging, another integral component in MVVM applications for promoting decoupled communication between components. We examined <code>WeakReferenceMessenger</code> provided by the MVVM Toolkit, which facilitates loose coupling in the application.</p>
<p>In essence, this chapter aimed to reinforce the importance of loose coupling in software design, showcasing how both DI and messaging contribute significantly to the creation of maintainable and testable applications.</p>
<p>In the upcoming chapter, we’ll delve deep into the intricacies of navigation in .NET MAUI and how we can integrate navigation into our MVVM architecture.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor131"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Dependency injection: <a href="https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection">https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection</a></li>
<li>MVVM Toolkit messenger: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger</a></li>
</ul>
</div>
</div></body></html>