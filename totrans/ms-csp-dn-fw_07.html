<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. NoSQL Database Programming</h1></div></div></div><p>In this chapter, we're going to review an emerging database paradigm that totally remodels the structure <a id="id548" class="indexterm"/>of data, <strong>NoSQL databases</strong>.</p><p>In brief, I will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">A historical context about NoSQL databases and their role in current development</li><li class="listitem">Available offers in this area and their main advantages and disadvantages</li><li class="listitem">The architectural model followed by the distinct flavors of NoSQL databases</li><li class="listitem">MongoDB as the NoSQL database of choice and its foundations and main features</li><li class="listitem">CRUD operations in MongoDB</li><li class="listitem">We'll end with a review on how to integrate and use MongoDB from Visual Studio and manage CRUD operations within the IDE</li></ul></div><p>In the last few years, companies such as Google, eBay, Facebook, Bosch, Forbes, LinkedIn, Marriot, PayPal, Ryan Air, Symantec, or Yammer have solutions that use these databases, to name just a few.</p><p>If we take a look at the statistics published by the specialized site DB-Engines, results showing utilization rates are pretty clear, where some no-SQL databases appear among the top 10 in use today (especially MongoDB):</p><div><img src="img/image00554.jpeg" alt="NoSQL Database Programming"/></div><p style="clear:both; height: 1em;"> </p><p>Therefore, there's a growing trend around these database systems, and it's especially meaningful that <a id="id549" class="indexterm"/>MongoDb shows up in the fourth position. The first five companies mentioned earlier use MongoDb for different purposes and scenarios.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec33"/>A brief historical context</h1></div></div></div><p>Until the second half of the nineties, nobody would doubt that SQL and Relational Model databases were the <em>de facto</em> standard and a large majority of commercial implementations in use those days were based on this assumption.</p><p>Historical examples are IBM, Oracle, SQL Server, Watcom, Gupta SQLBase, and so on. However, with time, some voices started to claim against what was already called <em>impedance mismatch</em>, the different representations of data and source code that happen when programming in object-oriented languages to these databases.</p><p>This is something that's<a id="id550" class="indexterm"/> clearly revealed when objects or class definitions have to be mapped in some fashion to databases (either tables or relational schemas).</p><p>Other problems<a id="id551" class="indexterm"/> arose from the different data types supported by both worlds, especially in scalar types and their operation semantics (for example, collations for different string interpretations), although OOP languages only consider this aspect in sort routines and strings are not treated as fixed, such as in RDBMS systems.</p><p>Besides, there were structural and integrity differences between both, not to mention other operational dissimilarities in manipulation and transactions.</p><p>So, new proposals <a id="id552" class="indexterm"/>were made about object-oriented databases, in which information would be stored in a such a way that it becomes simple and straightforward to make the correspondence between the two worlds. However, these proposals didn't reach the commercial arena, and <a id="id553" class="indexterm"/>actually, only some niche areas, such as engineering and spatial databases, high energy physics, some telecommunications projects, and molecular biology solutions, were actually using this approach.</p><p>One of the problems, in the words of Martin Fowler, was that people were doing a lot of integration in classical databases, making it really hard to change this paradigm.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec34"/>The NoSQL world</h1></div></div></div><p>As social media became huge, data requirements increased too. The need to store and retrieve large amounts of data immediately, led to some companies involved in the problem to think about possible alternatives.</p><p>So, projects such<a id="id554" class="indexterm"/> as BigTable (Google) and Dynamo (Amazon) were among the first few attempts to find a solution to this problem. These projects encouraged a new movement that we now know as the NoSQL initiative, the term being proposed by Johan Oskarsson in a conference in California about these topics, for which he created the Twitter hashtag #NoSQL.</p><p>We can define the NoSQL movement as a broad class of system-management databases that differ from the classical model of relational databases (RDBMS) in important facets, the most noticeable one being that they are not using SQL as the primary query language.</p><p>Stored data does not require fixed structures such as tables. The result? They don't support JOIN operations, and they <a id="id555" class="indexterm"/>do not fully guarantee <strong>ACID</strong> (<strong>atomicity</strong>, <strong>consistency</strong>, <strong>isolation</strong>, and <strong>durability</strong>) features, which are the soul of the relational model. Besides, they usually scale horizontally in a very efficient manner.</p><p>As a reminder: the four ACID features are defined as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Atomicity</strong>: This is key to the<a id="id556" class="indexterm"/> Relational Model; an operation consisting of more than one action shall not fail in the middle. Otherwise, data will be left in an inconsistent state. The whole set of operations is considered a unit.</li><li class="listitem"><strong>Consistency</strong>: This extends to<a id="id557" class="indexterm"/> the previous and posterior state of the database after any action.</li><li class="listitem"><strong>Isolation</strong>: Along with the<a id="id558" class="indexterm"/> previous considerations, no collateral effects should be noticed after a transaction has finished in the database.</li><li class="listitem"><strong>Durability</strong>: If an operation <a id="id559" class="indexterm"/>ends correctly, it will not be reversed by the system.</li></ul></div><p>NoSQL systems are sometimes called <em>not only SQL</em> in order to underline the fact that they can also support query languages such as SQL, although this characteristic depends on the implementation and the type of database.</p><p>Academic researchers refer to<a id="id560" class="indexterm"/> these databases as structured storage databases, a term that also covers classical relational databases. Often, NoSQL databases are classified according to how they store data and include categories such as Key-Value (Redis), BigTable/Column Family (Cassandra, HBase), Document Databases (MongoDb, Couch DB, Raven DB), and Graph Oriented Databases (Neo4j).</p><p>With the growth of real-time websites, it became clear that an increase in processing power for large volumes of data was required. And the solution of organizing data in similar horizontal structures reached corporative consensus, since it can support millions of requests per second.</p><p>Many attempts have been made to categorize the different offers now found in the NoSQL world according to various aspects: Scalability, Flexibility, Functionality, and so on. One of these<a id="id561" class="indexterm"/> divisions, established by Scofield and Popescu (<a class="ulink" href="http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting">http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting</a>), categorizes NoSQL databases according to the following criteria:</p><div><table border="1"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th valign="bottom"> </th><th valign="bottom">
<p>Performance</p>
</th><th valign="bottom">
<p>Scalability</p>
</th><th valign="bottom">
<p>Flexibility</p>
</th><th valign="bottom">
<p>Complexity</p>
</th><th valign="bottom">
<p>Functionality</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<strong>Key-value stores</strong>
</p>
</td><td valign="top">
<p>High </p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>None</p>
</td><td valign="top">
<p>Variable (none)</p>
</td></tr><tr><td valign="top">
<p>
<strong>Column stores</strong>
</p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>Moderate</p>
</td><td valign="top">
<p>Low</p>
</td><td valign="top">
<p>Minimal</p>
</td></tr><tr><td valign="top">
<p>
<strong>Document stores</strong>
</p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>Variable (high)</p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>Low</p>
</td><td valign="top">
<p>Variable (low)</p>
</td></tr><tr><td valign="top">
<p>
<strong>Graph databases</strong>
</p>
</td><td valign="top">
<p>Variable </p>
</td><td valign="top">
<p>Variable</p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>High</p>
</td><td valign="top">
<p>Graph theory</p>
</td></tr><tr><td valign="top">
<p>
<strong>Relational databases</strong>
</p>
</td><td valign="top">
<p>Variable</p>
</td><td valign="top">
<p>Variable</p>
</td><td valign="top">
<p>Low</p>
</td><td valign="top">
<p>Moderate</p>
</td><td valign="top">
<p>Relational algebra</p>
</td></tr></tbody></table></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Architectural changes with respect to RDBMS</h2></div></div></div><p>So, the first point to clarify <a id="id562" class="indexterm"/>at the time of using one of these models is to identify clearly which model suits our needs better. Let's quickly review these unequal approaches in architecture:</p><div><ul class="itemizedlist"><li class="listitem">The key/value proposal is<a id="id563" class="indexterm"/> similar to other lightweight storage systems used today on the Web, especially the <code class="literal">localStorage</code> and <code class="literal">sessionStorage</code> APIs. They allow read/write operations for a web page in the local system's dedicated area. Storage is structured in pairs, the left-hand side being the key we'll use later on to retrieve the associated value.<p>These databases don't care about the type of information being saved as the value type (either numbers, documents, multimedia, and so on), although there might be some limitations.</p></li><li class="listitem">The document offer is made of simple documents, where a document can be a complex data structure:<div><ul class="itemizedlist"><li class="listitem">Normally, such data is represented using a JSON format, the most common format in use today, especially in web contexts.</li><li class="listitem">The architecture allows you to read even fragments of a document or change or insert other fragments without being constrained by any schema.</li><li class="listitem">The absence of a schema, which—for many—is considered one of the best features of NoSQL databases, has a few drawbacks.</li><li class="listitem">One of the drawbacks is that when we recover some data, let's say from a person (a name or an account), you're assuming an <em>implicit schema</em>, as <a id="id564" class="indexterm"/>Fowler names it. It's taken for granted that a person has a name field or an account field.</li><li class="listitem">Actually, most of implementations rely on the existence of an ID, which works like the key in a key/value store in practice.</li><li class="listitem">So, we can think of these two approaches as similar and belonging to a type of aggregate oriented structure.</li></ul></div></li><li class="listitem">In the Column family model, the structure defines a single key (named a row key), and associated with it, you can store families of columns where each one is a set of related information.<div><ul class="itemizedlist"><li class="listitem">Thus, in this model, the way to access information is using the row key and the column family name, so you need two values for data access, but still, the model reminds the idea of the aggregated model.</li></ul></div></li><li class="listitem">Finally, the graph-oriented model fragments information in even smaller units and relates those<a id="id565" class="indexterm"/> units in a very rich, connected manner.<div><ul class="itemizedlist"><li class="listitem">They define a special language to allow complex interweaving to take place in a way that would be difficult to express in other types of databases, including RDBMs.</li></ul></div></li></ul></div><p>As we mentioned earlier, most NoSQL databases don't have the capacity of performing joins in queries. Consequently, the database schema needs to be designed in another way.</p><p>This has led to several techniques when relational data has to be managed in a NoSQL database.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec46"/>Querying multiple queries</h3></div></div></div><p>This idea relies on the fast<a id="id566" class="indexterm"/> response feature typical of these databases. In lieu of getting all data in a simple request, several queries are chained in order to get the desired information.</p><p>If the performance penalty is not acceptable, other approaches are possible.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec47"/>The problem of nonnormalized data</h3></div></div></div><p>The issue in this case is <a id="id567" class="indexterm"/>solved with a distinct approach: instead of storing foreign keys, the corresponding foreign values are stored together with the model's data.</p><p>Let's imagine blog entries. Each one can also relate and save both username and user ID, so we can read the username without requiring an extra query.</p><p>The shortcoming is that when the username changes, the modification will have to be stored in more than one place in the database. So, this kind of approach is handy when the average of reads (with respect to write operations) is fairly substantial.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec48"/>Data nesting</h3></div></div></div><p>As we will see in the <a id="id568" class="indexterm"/>practices with MongoDB, a common practice is based on placing more data in a smaller number of collections. Translated into practice, this means that in the blogging application we imagined earlier, we could store comments in the same document as the blog's post document.</p><p>In this way, a single query gets all the related comments. In this methodology, there's only a single document that contains all the data you need for a specific task.</p><p>Actually, this practice has become a de facto practice given the absence of a fixed schema in these databases.</p><div><h3 class="title"><a id="tip13"/>Tip</h3><p>In other words, the philosophy followed here is more or less <em>save your data in such a way that the number of storage units implied in a query is minimum</em> (optimally, only one).</p></div><p>The terminology<a id="id569" class="indexterm"/> that's used changes as well. The following table succinctly explains the equivalence in terms of relations between SQL and NoSQL databases:</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>SQL</p>
</th><th valign="bottom">
<p>MongoDB</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>Database</p>
</td><td valign="top">
<p>Database</p>
</td></tr><tr><td valign="top">
<p>Table</p>
</td><td valign="top">
<p>Collection</p>
</td></tr><tr><td valign="top">
<p>Row</p>
</td><td valign="top">
<p>Document or BSON document</p>
</td></tr><tr><td valign="top">
<p>Column</p>
</td><td valign="top">
<p>Field</p>
</td></tr><tr><td valign="top">
<p>Index</p>
</td><td valign="top">
<p>Index</p>
</td></tr><tr><td valign="top">
<p>Table joins</p>
</td><td valign="top">
<p>Embedded documents (with linking)</p>
</td></tr><tr><td valign="top">
<p>Primary key (unique column or column combinations)</p>
</td><td valign="top">
<p>Primary key (automatically set to the <code class="literal">_id</code> field in MongoDB)</p>
</td></tr><tr><td valign="top">
<p>Aggregation (for example, by group)</p>
</td><td valign="top">
<p>Aggregation pipeline</p>
</td></tr></tbody></table></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>About CRUD operations</h2></div></div></div><p>In the case of <a id="id570" class="indexterm"/>MongoDB, which we'll use in this chapter, a read operation is a query that targets a specific collection of documents. Queries specify criteria (conditions) that identify which documents MongoDB has to return to the client.</p><p>Any query needs to express the fields required in the output. This is solved using a projection: a syntax expression that enumerates the fields indicating the matching documents. The behavior of MongoDB follows these rules:</p><div><ul class="itemizedlist"><li class="listitem">Any query is <a id="id571" class="indexterm"/>aimed for a single collection</li><li class="listitem">The query syntax allows you to establish filters, ordering, and other related limitations</li><li class="listitem">No predefined order is used unless the <code class="literal">sort()</code> method forms a part of the query</li><li class="listitem">All CRUD operations use the same syntax, with no difference between reading and modification operations</li><li class="listitem">Queries with<a id="id572" class="indexterm"/> a statistical character (aggregation queries) use the $match pipeline to allow access to the queries' structure</li></ul></div><p>Traditionally, even in the relational model, those operations that change information (create, update, or delete) have their own syntax (DDL or DML in que SQL world). In MongoDB, they are noted as data modification operations, since they modify data in a single collection. However, for update operations, a conceptual division is usually made in order to distinguish punctual updates (modifications) from totally changing updates (replacements). In<a id="id573" class="indexterm"/> this case, only the <code class="literal">_id</code> field is preserved.</p><p>To summarize, the operational offer can be resumed in this way:</p><div><ul class="itemizedlist"><li class="listitem">Adding information is<a id="id574" class="indexterm"/> performed with insert operations (either with new data to an existing collection or by adding a new document)</li><li class="listitem">Changes adopt two forms: while updates modify the existing data, remove operations totally delete data from a given collection</li><li class="listitem">These three operations don't affect more than one document in a single process</li><li class="listitem">As mentioned earlier, update and remove can use different criteria to establish which documents are updated or removed:<div><ul class="itemizedlist"><li class="listitem">There is a clear similarity in the syntax used for these operations and the one used in pure reading queries</li><li class="listitem">Actually, some of these operations are piped, that is, linked to the previous query by chained calls</li></ul></div></li></ul></div><p>So, in the case of MongoDB, we would have a schema like what is shown in below:</p><div><img src="img/image00555.jpeg" alt="About CRUD operations"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec35"/>MongoDB on Windows</h1></div></div></div><p>Of course, if we want to<a id="id575" class="indexterm"/> follow the samples in this chapter, an installation of MongoDB is required on our local machine. You can do this from the official site (<a class="ulink" href="https://www.mongodb.com">https://www.mongodb.com</a>), where you'll find the installation software<a id="id576" class="indexterm"/> for the most popular operating systems (Windows, Mac, Linux, and Solaris).</p><p>You'll also find different editions of the product, including an Enterprise version for different flavors of Mongo. For the purpose of this topic, we can use the popular Community Edition Server version and download and install it using the <code class="literal">.msi</code> file resulting from the process.</p><p>As the documentation indicates, the installer includes all other software dependencies and will automatically upgrade any older version of MongoDB that's previously been installed. The current version (at the time of writing this) is 3.2.6, and it changes periodically. The process only takes a few seconds:</p><div><img src="img/image00556.jpeg" alt="MongoDB on Windows"/></div><p style="clear:both; height: 1em;"> </p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>File structure and default configuration</h2></div></div></div><p>As a result of the installation, a set of files will appear in the <code class="literal">Program Files/MongoDB</code> directory, containing a <a id="id577" class="indexterm"/>number of utilities and tools, plus the server itself. The main files to keep track of are <code class="literal">mongod.exe</code>, which is the server executable, and the command-line utility (<code class="literal">mongo.exe</code>), which provides a set of interactive options and allows data operations as well.</p><p>If you launch the server, a command <a id="id578" class="indexterm"/>window will show up, presenting some default configuration parameters:</p><div><ul class="itemizedlist"><li class="listitem">It creates a default data directory in <code class="literal">c:\data\db</code>, which is the default physical location of its internal data as well as the user's. Within this directory, a journal data file is created by default. It can be changed with a <code class="literal">mondod –dbpath U:\datapath</code> command.</li><li class="listitem">Another storing location is initialized in <code class="literal">c:\data\db\diagnostic.data</code>, especially dedicated to activity monitoring.</li><li class="listitem">Port <code class="literal">27017</code> is assigned to start listening for connections via TCP. You can change it in the configuration or by calling <code class="literal">Mongod.exe</code> with the <code class="literal">--port</code> [number] argument.</li></ul></div><p>At this point, you can start interacting with the database. To do this, in a command-line fashion, you should use <code class="literal">mongo.exe</code>. Once launched, you can ask for help, and an initial list of commands will be presented.</p><p>A simple <code class="literal">show dbs</code> command <a id="id579" class="indexterm"/>will output, in my case, two databases<a id="id580" class="indexterm"/> that are present (previous databases of prior installations are not deleted, since they are located at another directory):</p><div><img src="img/image00557.jpeg" alt="File structure and default configuration"/></div><p style="clear:both; height: 1em;"> </p><p>In order to connect to a given database, we can type <code class="literal">use &lt;db_name&gt;</code> as the capture shows. This command also allows the creation of a new database. Hence, if the database exists, MongoDB switches to it; otherwise, it creates a new one.</p><p>A more useful feature allows you to ask for help on a concrete database. For example, if our <code class="literal">Personal</code> database contains a <code class="literal">People</code> collection, we can ask for specific help with a commands such as the following:</p><div><pre class="programlisting">
<strong>use Personal</strong>
<strong>db.Personal.help()</strong>
</pre></div><p>Another helpful utility is <code class="literal">mongoimport.exe</code>, which allows you to import data from a physical file we might have. We'll use this tool to import a flat JSON file obtained from the Union Cicliste International (<a class="ulink" href="http://www.uci.ch/road/ranking/">http://www.uci.ch/road/ranking/</a>) with the stats for 2016. Once we <a id="id581" class="indexterm"/>move the file to the <code class="literal">c:\data\db</code> directory (this can be done from another location anyway), we can use the following command to import this data into a new database:</p><div><pre class="programlisting">
<strong>mongoimport --jsonArray --db Cyclists --collection Ranking16 &lt; c:\data\db\Ranking15.json</strong>
<strong>2016-05-06T13:57:49.755+0200    connected to: localhost</strong>
<strong>2016-05-06T13:57:49.759+0200    imported 40 documents</strong>
</pre></div><p>After this, we can<a id="id582" class="indexterm"/> start querying the database once we <a id="id583" class="indexterm"/>switch into it and find the first document in our collection:</p><div><img src="img/image00558.jpeg" alt="File structure and default configuration"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the first command tells us the number of documents inserted, and the next one retrieves the first document. There's something to point out here, and that is the <code class="literal">_id</code> element in the document. It is automatically inserted by the importing process in order to uniquely identify each document in the collection.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec49"/>Some useful commands</h3></div></div></div><p>Usually, we can use the big collection of commands provided by Mongo to query the database in different <a id="id584" class="indexterm"/>ways. For example, if I want to list all cyclists from Great Britain, I can write the following:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( {"Nation": "Great Britain"} )</strong>
<strong>{ "_id" : ObjectId("572c8b77e8200fb42f000019"), "Rank" : "25 (24)", "Name" : "Geraint THOMAS", "Nation" : "Great Britain", "Team" : "SKY", "Age*" : 30, "Points" : 743 }</strong>
<strong>{ "_id" : ObjectId("572c8b77e8200fb42f000022"), "Rank" : "34 (32)", "Name" : "Ian STANNARD", "Nation" : "Great Britain", "Team" : "SKY", "Age*" : 29, "Points" : 601 }</strong>
<strong>{ "_id" : ObjectId("572c8b77e8200fb42f000025"), "Rank" : "37 (35)", "Name" : "Ben SWIFT", "Nation" : "Great Britain", "Team" : "SKY", "Age*" : 29, "Points" : 556 }</strong>
</pre></div><p>So, in order to filter information, the <code class="literal">find()</code> method expects a criteria written using the object notation syntax, which is typical of JavaScript. However, we can also select one from the total number of results, indicating it with an array syntax:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( {"Nation": "Great Britain"} )[0]</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("572c8b77e8200fb42f000019"),</strong>
<strong>  "Rank" : "25 (24)",</strong>
<strong>  "Name" : "Geraint THOMAS",</strong>
<strong>  "Nation" : "Great Britain",</strong>
<strong>  "Team" : "SKY",</strong>
<strong>  "Age*" : 30,</strong>
<strong>  "Points" : 743</strong>
<strong>}</strong>
</pre></div><p>As you can imagine, other options allow the projection of the required elements in a document instead of retrieving the whole one. For instance, we can ask for the names and ages of all the cyclists from Spain in this list using the following:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( {"Nation": "Spain"}, {"Name":1, "Age*":1} )</strong>
<strong>{ "_id" : ObjectId("572c8b77e8200fb42f000006"), "Name" : "Alberto CONTADOR VELASCO", "Age*" : 34 }</strong>
<strong>{ "_id" : ObjectId("572c8b77e8200fb42f00000a"), "Name" : "Alejandro VALVERDE BELMONTE", "Age*" : 36 }</strong>
<strong>{ "_id" : ObjectId("572c8b77e8200fb42f00000e"), "Name" : "Jon IZAGUIRRE INSAUSTI", "Age*" : 27 }</strong>
<strong>{ "_id" : ObjectId("572c8b77e8200fb42f00001c"), "Name" : "Samuel SANCHEZ GONZALEZ", "Age*" : 38 }</strong>
</pre></div><p>The numbers associated with the fields to be retrieved only indicate presence required (we want them in the output list) if they're bigger than 0 or absence if they are 0.</p><p>Let's say we need the list of Italian cyclists with their names and teams and no other field. We can type the following:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( {"Nation": "Italy"}, {"Name":1, "Team":1, "_id": 0 } )</strong>
<strong>{ "Name" : "Sonny COLBRELLI", "Team" : "BAR" }</strong>
<strong>{ "Name" : "Enrico GASPAROTTO", "Team" : "WGG" }</strong>
<strong>{ "Name" : "Diego ULISSI", "Team" : "LAM" }</strong>
<strong>{ "Name" : "Giovanni VISCONTI", "Team" : "MOV" }</strong>
</pre></div><p>Other combinations <a id="id585" class="indexterm"/>allow you to use JavaScript declarations to retrieve partial information that can be used later to get another result set. Here, we load the query into a variable and call it directly:</p><div><pre class="programlisting">
<strong>&gt; var fellows = db.Ranking16.find({"Nation":"Australia"} , { "Name":1 , "Nation":1, "_id":0 });</strong>
<strong>&gt; fellows</strong>
<strong>{ "Name" : "Richie PORTE", "Nation" : "Australia" }</strong>
<strong>{ "Name" : "Simon GERRANS", "Nation" : "Australia" }</strong>
<strong>{ "Name" : "Michael MATTHEWS", "Nation" : "Australia" }</strong>
</pre></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec11"/>Operators</h4></div></div></div><p>The list of available operators in MongoDB is quite large, and they can be categorized according to the <a id="id586" class="indexterm"/>purpose in three main categories, as the official documentation shows:</p><div><ul class="itemizedlist"><li class="listitem">Query and projection</li><li class="listitem">Update</li><li class="listitem">Aggregation pipeline</li></ul></div><p>Each of these categories contains a large number of options, so you can refer to the official documentation for more details (<a class="ulink" href="https://docs.mongodb.com/manual/reference/operator/">https://docs.mongodb.com/manual/reference/operator/</a>). For the purpose of this chapter, we'll use a few of the most<a id="id587" class="indexterm"/> common operators that appear in everyday work with MongoDB. The following table lists the most used operators:</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Operator</p>
</th><th valign="bottom">
<p>Description </p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">$eq</code>
</p>
</td><td valign="top">
<p>Matches values that are equal to a specified value</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">$gt</code>
</p>
</td><td valign="top">
<p>Matches values that are greater than a specified value</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">$gte</code>
</p>
</td><td valign="top">
<p>Matches values that are greater than or equal to a specified value</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">$lt</code>
</p>
</td><td valign="top">
<p>Matches values that are less than a specified value</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">$lte</code>
</p>
</td><td valign="top">
<p>Matches values that are less than or equal to a specified value</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">$ne</code>
</p>
</td><td valign="top">
<p>Matches all values that are not equal to a specified value</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">$in</code>
</p>
</td><td valign="top">
<p>Matches any of the values specified in an array</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">$nin</code>
</p>
</td><td valign="top">
<p>Matches none of the values specified in an array</p>
</td></tr></tbody></table></div><p>Note that you can find some of these operators in different contexts or domain queries: for instance, most of the operators in the preceding table are also present in the set of operators linked to the Aggregation pipeline.</p><p>Another important clue is that these areas provide mechanisms to deal with information in many ways depending on the context. Actually, many of the operators that we find available in the SQL Server or Oracle RDBMS have an equivalent here, always preceded by the <code class="literal">$</code> sign. For <a id="id588" class="indexterm"/>example, you can use the arithmetic operators in the Aggregation pipeline to create calculated fields, or you can use some mathematical operators defined as MongoDB commands, that remind, even syntactically, those that we can find in the Math static class in C# or JavaScript: <code class="literal">$abs</code>, <code class="literal">$ceil</code>, <code class="literal">$log</code>, <code class="literal">$sqrt</code>, and so on.</p><p>This happens with other typical RDBMS operators, such as the aggregation operators commonly used in statistical queries: <code class="literal">$sum</code>, <code class="literal">$avg</code>, <code class="literal">$first</code>, and so on. Other common families of operators that facilitate management operations are Date operators, String operators, Array operators, and Set operators.</p><p>The way to use them always depends on the context of the operation to be performed. In queries, we can embed them as part of the expressions that serve as the filtering criteria. However, keep in mind that the operand and operator form an object expression criteria. Also, remember that several of these expressions can be indicated with comma separation.</p><p>Let's imagine that we want the list of cyclists with more than 1,000 points and less than 1,300 points. We could express it as follows:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( {"Points": {$gt:1000, $lte: 1300}}, {"Name":1, "_id": 0 } )</strong>
<strong>{ "Name" : "Alexander KRISTOFF" }</strong>
<strong>{ "Name" : "Sep VANMARCKE" }</strong>
<strong>{ "Name" : "Ilnur ZAKARIN" }</strong>
<strong>{ "Name" : "Alejandro VALVERDE BELMONTE" }</strong>
<strong>{ "Name" : "Sergio Luis HENAO MONTOYA" }</strong>
<strong>{ "Name" : "Richie PORTE" }</strong>
<strong>{ "Name" : "Wouter POELS" }</strong>
</pre></div><p>Observe that there's an implicit AND operator in the way we express the points limits (the minimum and maximum) separated by commas.</p><p>The OR operator can also be expressed in this manner (<code class="literal">$or</code>), but the syntax for some cases requires careful separation of concerns. Let's imagine a case where we need to find a cyclist belonging to Commonwealth, for example. We need an <code class="literal">$or</code> operator to express this condition according to this syntax (we're omitting other nations not present on the list for brevity):</p><div><pre class="programlisting">
<strong>{ $or: [ {"Nation" : "Great Britain"}, { "Nation": "Ireland" }, {"Nation" : "Australia"} ] }</strong>
</pre></div><p>Effectively, the results<a id="id589" class="indexterm"/> of such query would be as follows:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( { $or : [ {"Nation": "Great Britain"}, { "Nation" : "Ireland"}, { "Nation": "Australia" } ] } , {"Name":1, "_id": 0 } )</strong>
<strong>{ "Name" : "Richie PORTE" }</strong>
<strong>{ "Name" : "Simon GERRANS" }</strong>
<strong>{ "Name" : "Geraint THOMAS" }</strong>
<strong>{ "Name" : "Michael MATTHEWS" }</strong>
<strong>{ "Name" : "Daniel MARTIN" }</strong>
<strong>{ "Name" : "Ian STANNARD" }</strong>
<strong>{ "Name" : "Ben SWIFT" }</strong>
</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Altering data – the rest of CRUD operations</h2></div></div></div><p>The operations that modify the contents of our database are represented by three methods:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Add</strong>: <code class="literal">insert()</code></li><li class="listitem"><strong>Delete</strong>: <code class="literal">remove()</code></li><li class="listitem"><strong>Modify</strong>: <code class="literal">update()</code></li></ul></div><p>For example, in<a id="id590" class="indexterm"/> the first case, we can express the insertion in a<a id="id591" class="indexterm"/> JavaScript variable<a id="id592" class="indexterm"/> and use that <a id="id593" class="indexterm"/>variable to pass it to to the <code class="literal">insert()</code> method:</p><div><pre class="programlisting">
<strong>&gt; var newCyclist = {</strong>
<strong>... "Rank" : 139,</strong>
<strong>... "Name": "Lawson CRADDOCK",</strong>
<strong>... "Nation": "United States",</strong>
<strong>... "Team" : "CPT",</strong>
<strong>... "Age*": 24,</strong>
<strong>... "Points": 208</strong>
<strong>... }</strong>
<strong>&gt; db.Ranking16.insert(newCyclist)</strong>
<strong>WriteResult({ "nInserted" : 1 })</strong>
</pre></div><p>We can see that there's an extra line from Mongo, indicating that a new document has been inserted (also, an array can be passed for a multiple insertion).</p><p>Besides, there's another important factor we already mentioned, which has to do with flexibility. Let's say we want to include another important runner from the US, such as Tejay Van Garderen, but in this case, we have some extra information related to the details of his nation, such as <code class="literal">State</code> (<code class="literal">Washington</code>) and <code class="literal">City</code> (<code class="literal">Tacoma</code>) he was born in. We want to include this information in the collection.</p><p>We will proceed in the same way, only assigning to the <code class="literal">Nation</code> value a complex value made of three fields: <code class="literal">Name</code>, <code class="literal">State</code>, and <code class="literal">City</code>. We can proceed in exactly the same way as earlier but with these<a id="id594" class="indexterm"/> changes included.</p><p>After the process, a look at the content will show the information structure inserted, along with its new values:</p><div><pre class="programlisting">
<strong>&gt; newCyclist</strong>
<strong>{</strong>
<strong>  "Rank" : 139,</strong>
<strong>  "Name" : "Lawson CRADDOCK",</strong>
<strong>  "Nation" : {</strong>
<strong>    "Name" : "United States",</strong>
<strong>    "State" : "Washington",</strong>
<strong>    "City" : "Tacoma"</strong>
<strong>  },</strong>
<strong>  "Team" : "CPT",</strong>
<strong>  "Age*" : 24,</strong>
<strong>  "Points" : 208</strong>
<strong>}</strong>
</pre></div><p>The insertion went fine, but I made a (copy/paste) mistake and didn't change the name of the runner properly (the rest of the data is fine, but the name has to be modified). So, we can  use the <code class="literal">update()</code> command in order to achieve this goal.</p><p>It's simple; we just have to localize the target document as the first parameter and indicate the new data as the second parameter:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.update({ "Name": "Lawson CRADDOCK" }, { "Name" : "Tejay VAN GARDEREN"})</strong>
<strong>WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })</strong>
</pre></div><p>The results: one document found and one modified.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec50"/>Text indexes</h3></div></div></div><p>Now, we want to list all the <a id="id595" class="indexterm"/>cyclists from the United States in our collection. MongoDB provides an interesting possibility: create a text index to be used later in text searches. At creation time, we can indicate which text fields (along with their data types) need to be included in the index; for example, take a look at the following:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.createIndex( { Name: "text", Nation: "text"} )</strong>
<strong>{</strong>
<strong>  "createdCollectionAutomatically" : false,</strong>
<strong>  "numIndexesBefore" : 1,</strong>
<strong>  "numIndexesAfter" : 2,</strong>
<strong>  "ok" : 1</strong>
<strong>}</strong>
</pre></div><p>With the previous code, we have indexed two fields, and the total number of indexes now is two (remember that the <code class="literal">_id</code> index is created automatically). This is perfect for practical usage, since we now<a id="id596" class="indexterm"/> can write the following:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( { $text: { $search: "Tejay Lawson" } }).pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("572cdb8c03caae1d2e97b8f1"),</strong>
<strong>  "Rank" : 52,</strong>
<strong>  "Name" : "Tejay VAN GARDEREN",</strong>
<strong>  "Nation" : {</strong>
<strong>    "Name" : "United States",</strong>
<strong>    "State" : "Washington",</strong>
<strong>    "City" : "Tacoma"</strong>
<strong>  },</strong>
<strong>  "Team" : "BMC",</strong>
<strong>  "Age*" : 28,</strong>
<strong>  "Points" : 437</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("572cdcc103caae1d2e97b8f2"),</strong>
<strong>  "Rank" : 139,</strong>
<strong>  "Name" : "Lawson CRADDOCK",</strong>
<strong>  "Nation" : "United States",</strong>
<strong>  "Team" : "CPT",</strong>
<strong>  "Age*" : 24,</strong>
<strong>  "Points" : 308</strong>
<strong>}</strong>
</pre></div><p>Note that the search was made without indicating the position of the string in the field. The output shows both documents with their different data structures for the <code class="literal">Nation</code> field.</p><p>If we don't have any indexes, it is also possible to use other operators for search, such as <code class="literal">$in</code>, which uses the following syntax prototype:</p><div><pre class="programlisting">
<strong>{ field: { $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] } }</strong>
</pre></div><p>So, we can rewrite a similar query containing all cyclists from France and Spain as follows:</p><div><pre class="programlisting">
<strong>&gt; db.Ranking16.find( {"Nation": { $in: ["France", "Spain"] }}, {"_id":0, "Rank":0, "Points":0, "Age*":0, "Team":0})</strong>
<strong>{ "Name" : "Thibaut PINOT", "Nation" : "France" }</strong>
<strong>{ "Name" : "Alberto CONTADOR VELASCO", "Nation" : "Spain" }</strong>
<strong>{ "Name" : "Alejandro VALVERDE BELMONTE", "Nation" : "Spain" }</strong>
<strong>{ "Name" : "Jon IZAGUIRRE INSAUSTI", "Nation" : "Spain" }</strong>
<strong>{ "Name" : "Arnaud DEMARE", "Nation" : "France" }</strong>
<strong>{ "Name" : "Bryan COQUARD", "Nation" : "France" }</strong>
<strong>{ "Name" : "Nacer BOUHANNI", "Nation" : "France" }</strong>
<strong>{ "Name" : "Samuel SANCHEZ GONZALEZ", "Nation" : "Spain" }</strong>
<strong>{ "Name" : "Romain BARDET", "Nation" : "France" }</strong>
<strong>{ "Name" : "Julian ALAPHILIPPE", "Nation" : "France" }</strong>
</pre></div><p>For deletion, the<a id="id597" class="indexterm"/> procedure is pretty straightforward. Just remember that deletions affect one or more documents depending on the criteria defined for the operation. In this case, remember that there is no equivalent to the cascade behavior we might configure in the relational model.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>MongoDB from Visual Studio</h1></div></div></div><p>You can find plenty of drivers for MongoDB directly on the MongoDB official site, including several versions for the C# language, which currently stands for version 2.2.3. This driver provides support for the version of MongoDB I'm using in this book (v. 3.2).</p><p>Actually, this version was<a id="id598" class="indexterm"/> created and tested in Visual Studio 2015, so that's another reason to use it here. You can find a whole page with explanations, links to other resources, videos, articles, community supported tools, presentations, and so<a id="id599" class="indexterm"/> on at the <a class="ulink" href="https://docs.mongodb.com/ecosystem/drivers/csharp/">https://docs.mongodb.com/ecosystem/drivers/csharp/</a> address. This driver is the officially supported driver for MongoDB.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec74"/>First demo: a simple query from Visual Studio</h2></div></div></div><p>There are several approaches<a id="id600" class="indexterm"/> for driver's installation, but you can install it using NuGet from Visual Studio, so we'll start by building a new Console project (ConsoleMongo1), and after that, select the NuGet Window interactive. Once there, typing <code class="literal">MongoDB</code> will show a bunch of libraries, including the official driver in the first position.</p><p>As you can see in the following screenshot, three libraries are installed: two versions of MongoDB driver (core and standard) and Mongo.BSon, which contains a serialization infrastructure that you can use to build high-performance serializers:</p><div><img src="img/image00559.jpeg" alt="First demo: a simple query from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>To work with MongoDB from C#, the driver offers a set of convenient objects, which in great part, represent those we have been using in the Mongo Command Window to perform previous operations.</p><p>Before any operation, it's important to remember that NoSQL structures are flexible, but in order to work properly from the C# side, it's more useful to have a structure for our data (a data model <a id="id601" class="indexterm"/>or contract). To do this, we can copy and paste a single document from our database and use the <strong>Paste as JSON</strong> option, which will convert the structure to a set of classes containing the keys defined in the document as classes' fields.</p><p>For the demos in this part, I've opted for another database source, which is more similar to what we would use in a real application. For this purpose, a possible source is the NorthWind JSON website, which offers JSON versions of the popular NorthWind database used for years in Microsoft Access and SQL Server as the demo database. You can find the <a id="id602" class="indexterm"/>database at <a class="ulink" href="http://northwind.servicestack.net/customers?format=json">http://northwind.servicestack.net/customers?format=json</a>. I've downloaded two tables from here: <code class="literal">Customers</code> and <code class="literal">Orders</code>. Remember that through the import process, a new field named <code class="literal">_id</code> will be generated.</p><p>When you use the <strong>Paste as JSON</strong> option, its <code class="literal">_id</code> field will be assigned to a string, but internally, it is really an <code class="literal">ObjectId</code> type. To avoid problems later, you can change it manually to have a definition like this:</p><div><pre class="programlisting">public class Customer
{
  public ObjectId _id { get; set; }
  public string CustomerID { get; set; }
  public string CompanyName { get; set; }
  public string ContactName { get; set; }
  public string ContactTitle { get; set; }
  public string Address { get; set; }
  public string City { get; set; }
  public object Region { get; set; }
  public string PostalCode { get; set; }
  public string Country { get; set; }
  public string Phone { get; set; }
  public string Fax { get; set; }
}</pre></div><p>Now let's make a simple query that we can list in the Console window. To achieve this, we need to reference<a id="id603" class="indexterm"/> the previously mentioned libraries and follow the basic steps: connect to the NorthWind database, get a reference to a collection, define the query (we can use Linq and/or a generic functionality for this purpose), and present the results.</p><p>An initial, simple approach would be as follows:</p><div><pre class="programlisting">class Program
{
  static IMongoClient client;
  static IMongoDatabase db;
  static void Main(string[] args)
  {
    BasicQuery();
  }
  private static void BasicQuery()
  {
    client = new MongoClient();
    db = client.GetDatabase("NorthWind");
    var coll = db.GetCollection&lt;Customer&gt;("Customers");

    var americanCustomers = coll.Find(c =&gt; c.Country == "USA")
    .ToListAsync().Result;
    string title = "Customers from United States";
    Console.WriteLine(title);
    Console.WriteLine(string.Concat(Enumerable.Repeat("-", title.Length)));
    foreach (var c in americanCustomers)
    {
      Console.WriteLine($"Name: {c.ContactName}, \t City: {c.City} ");
    }
    Console.Read();
  }
}</pre></div><p>If you launch the application, a Console window will show the requested set of customers:</p><div><img src="img/image00560.jpeg" alt="First demo: a simple query from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>So, let's quickly review the process here. MongoClient represents a connection to the MongoDB server. It follows a reference to the required database. Once there, we get the Customers<a id="id604" class="indexterm"/> collection, but since we already know the customers type and its members, we can use generics to express that, indicating that the result of calling <code class="literal">GetCollection&lt;Customer&gt;("Customers")</code> is of that type (note that the collection is a plural name).</p><p>When the collection variable is ready, it can be used as any other generic collection, so we can use lambda expressions, LINQ, and all other resources just the same as we did in previous chapters.</p><p>Note, though, that we've run a query in a synchronous mode. When the amount of data available (to search for) is high, asynchronous operations are recommended. Therefore, let's make the query a bit more complex and run it this way.</p><p>For example, let's assume that we need to know which customers from the United States or the United Kingdom are owners as well (the <code class="literal">CustomerTitle</code> field values <code class="literal">Owner</code>). So, we need a bit more complex filter. And we also want the process to be asynchronous, to avoid blocking<a id="id605" class="indexterm"/> errors or unresponsive user interfaces. Thus, we'll use the <code class="literal">async</code>/<code class="literal">await</code> operators to build a method in this manner:</p><div><pre class="programlisting">async private static void CustomerQueryAsync()
{
  client = new MongoClient();
  db = client.GetDatabase("NorthWind");
  var coll = db.GetCollection&lt;Customer&gt;("Customers");
  var owners = await coll.FindAsync(c =&gt;
    (c.Country == "USA" || c.Country == "UK") &amp;&amp; c.ContactTitle == "Owner")
  .Result.ToListAsync();
  string title = "Owners from USA or UK";
  Console.WriteLine(title);
  Console.WriteLine(string.Concat(Enumerable.Repeat("-", title.Length)));
  foreach (var c in owners)
  {
    Console.WriteLine($"Name: {c.ContactName}, \t City: {c.City} ");
  }
}</pre></div><p>So, now we perform the query asynchronously (in a non-blocking fashion), with just a few changes, getting a couple of entries:</p><div><img src="img/image00561.jpeg" alt="First demo: a simple query from Visual Studio"/></div><p style="clear:both; height: 1em;"> </p><p>Note that besides using the <code class="literal">async</code>/<code class="literal">await</code> operators, the end of the query varies a little. We now call the <code class="literal">toListAsync()</code> method from the <code class="literal">Result</code> object in order to get the final collection. The rest is like what is done in the previous (synchronous) method.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec75"/>CRUD operations</h2></div></div></div><p>As you can imagine, CRUD operations are fully supported, especially when using this new version of the driver, which includes various new possibilities.</p><p>Most of these operations are presented in two main families depending on whether you want to deal with only one or <a id="id606" class="indexterm"/>many documents in the collection. Consequently, we find methods such as <code class="literal">DeleteOne</code>/<code class="literal">DeleteMany, InsertOne</code>/<code class="literal">InsertMany</code>, <code class="literal">ReplaceOne</code>/<code class="literal">ReplaceMany</code>, and so on. In turn, they present synchronous and asynchronous versions for each one.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec51"/>Deletion</h3></div></div></div><p>For instance, in order to<a id="id607" class="indexterm"/> delete a single customer, we can use the following:</p><div><pre class="programlisting">async private static void DeleteCustomerAsync()
{
  var CustDel = await coll.FindOneAndDeleteAsync(c =&gt; c.CustomerID == "CHOPS");
  // List customers from Switzerland to check deletion
  BasicQuery("Switzerland");
}</pre></div><p>You can see that we're using a very convenient method, which allows us to find and delete a single document in a sole (atomic) operation (<code class="literal">FindOneAndDeleteAsync</code>).</p><p>Also, we've changed the <code class="literal">BasicQuery</code> method to receive a string with the country to be listed, and we call that method again just after the deletion to check whether everything was okay. Now there's only one customer from that country:</p><div><img src="img/image00562.jpeg" alt="Deletion"/></div><p style="clear:both; height: 1em;"> </p><p>As a note, remember that if no document is found, any possible exception thrown by the application, should be handled in the usual manner.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec52"/>Insertion</h3></div></div></div><p>Insertion follows a similar <a id="id608" class="indexterm"/>pattern. We create a new customer following the contract definition and insert it asynchronously using a simple, straightforward code:</p><div><pre class="programlisting">async private static void InsertCustomerAsync()
{
  Customer newCustomer = new Customer()
  {
    CustomerID = "ZZZZZ",
    CompanyName = "The Z Company",
    ContactName = "Zachary Zabek",
    City = "Zeeland",
    Region = "Michigan",
    Country = "USA"
  };
  await coll.InsertOneAsync(newCustomer);
  BasicQuery("USA");
  Console.Read();
}</pre></div><p>If everything's okay, we'll be shown an output like what is shown in the following screenshot:</p><div><img src="img/image00563.jpeg" alt="Insertion"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec53"/>Modifications and replacements</h3></div></div></div><p>Working with document collections, it's common to distinguish between updates and replacements. In the first case, we're managing something similar to the <code class="literal">UPDATE</code> clause in standard SQL language.</p><p>The second situation deals <a id="id609" class="indexterm"/>with a total replacement of a document, with an exception made of the <code class="literal">_id</code> field, which is immutable. In this case, since there's no fixed model to follow, the information replaced could be totally different from the previous one.</p><p>To replace content, it's handy to<a id="id610" class="indexterm"/> use static methods of the <code class="literal">Builders</code> class, which provides the C# driver. We can define a generic <code class="literal">Builder</code> class for our customers and use the <code class="literal">Filter</code> and <code class="literal">Update</code> methods to locate and replace a given document.</p><p>The following code does exactly that: it locates the previously inserted company and changes the <code class="literal">CompanyName</code> field to another string:</p><div><pre class="programlisting">async private static void ModifyCustomerAsync()
{
  var filter = Builders&lt;Customer&gt;.Filter.Eq("CompanyName", "The Z Company");
  var update = Builders&lt;Customer&gt;.Update
  .Set("CompanyName", "ZZZZZ Enterprises");
  var result = await coll.UpdateOneAsync(filter, update);
  BasicQueryByCompany("USA");
}</pre></div><p>Note I have included another version of the <code class="literal">BasicQuery</code> method, called <code class="literal">BasicQueryByCompany</code>, in order to allow the returning of the modified field in the output:</p><div><img src="img/image00564.jpeg" alt="Modifications and replacements"/></div><p style="clear:both; height: 1em;"> </p><p>In the case of replacements, you <a id="id611" class="indexterm"/>can use the <code class="literal">ReplaceOneAsync</code> and <code class="literal">ReplaceManyAsync</code> methods, just like what we did for the update.</p><p>In addition, most typical <a id="id612" class="indexterm"/>operations you might be used to in SQL databases are present here as well: grouping, statistical results, security configuration, and so on.</p><p>Adoption of NoSQL databases is another story: scalability, availability, previous knowledge of NoSQL, and the learning curve are only a few of the considerations you might ponder at the time of selecting one of these databases in a new project. Whatever the case may be, support from most of the available NoSQL databases from the .NET platform is guaranteed for the majority of implementations, so that shouldn't be an issue.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Summary</h1></div></div></div><p>Along the course of this chapter, we went through the foundations and basics of NoSQL databases, starting with their historical evolution and the several types of architectures and peculiarities linked to this storage approach and a list of the most typical implementations we can find today.</p><p>We also explored the correct manner in which the CRUD operations should be managed in these contexts from a general-purpose point of view.</p><p>Then, we moved on to MongoDB, analyzing the details of its installation and management in a Windows system, prior to starting the use of a MongoDB instance by means of its default (command-line) tools in order to operate and import, manipulate, list, and modify its contents without any external tool in order to study the low-level mechanisms behind its usage.</p><p>Finally, we used the C# driver available on the official MongoDB website in order to accomplish the same CRUD operations from a Console application, including the most typical actions required in LOB applications.</p><p>In the next chapter, we'll look at how to use some of the—many—resources and projects available as Open Source, which are monitored and actively supported by Microsoft these days, and that includes the Roselyn services, the new TypeScript language, and others.</p></div></body></html>