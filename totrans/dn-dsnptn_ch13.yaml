- en: Chapter 13. Reactive Programming Using RxJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章. 使用 RxJS 进行响应式编程
- en: 'In the previous chapter, we saw how .NET **Reactive Extensions** (**Rx**) aided
    natural programming in terms of composability, scalability, and responsiveness.
    We saw how streams enable natural state management with respect to time. Some
    of the constructs were dealt with in detail as well. More importantly, we saw
    how reactive constructs could be integrated seamlessly into the MVVM pattern,
    in terms of achieving data synchronization between View and Model via the View
    Model layer. Now, in this chapter, we will take a deep dive into the **Reactive
    Extensions for JavaScript** (**RxJS**) library, and look at how to write asynchronous
    and event-driven programs using observable collections. We will also take a detailed
    look at some interesting use cases, and their implementations with RxJS, to clearly
    understand how the RxJS library is leveraged to create concurrent and responsive
    applications. This will cover the reactive spectrum of web and Windows programming
    and, by the end of this chapter, you will be in a position to appreciate the possibilities
    of JavaScript and confidently leverage RxJS by having a jump start at it. This
    chapter includes the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 .NET **响应式扩展**（**Rx**）如何从可组合性、可扩展性和响应性方面帮助自然编程。我们看到了流如何使时间相关的自然状态管理成为可能。一些结构被详细处理了。更重要的是，我们看到了如何将响应式结构无缝集成到
    MVVM 模式，通过视图模型层实现视图和模型之间的数据同步。现在，在这一章中，我们将深入探讨 **JavaScript 的响应式扩展库**（**RxJS**），并了解如何使用可观察集合编写异步和事件驱动程序。我们还将详细探讨一些有趣的用例及其使用
    RxJS 的实现，以清楚地了解 RxJS 库是如何被利用来创建并发和响应式应用的。这将涵盖 Web 和 Windows 编程的响应式范围，到本章结束时，你将能够欣赏
    JavaScript 的可能性，并通过对 RxJS 的初步了解来自信地利用它。本章包括以下内容：
- en: A refresher on JavaScript execution context
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 执行上下文的复习
- en: An analogy of RxJS with YieldJS (a custom JS framework created by the authors)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS 与 YieldJS（作者创建的定制 JS 框架）的类比
- en: A detailed outline on RxJS foundations and formalisms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS 基础和形式主义的详细概述
- en: Detailed code samples that demonstrate RxJS in action
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示 RxJS 动作的详细代码示例
- en: The JS world
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 世界
- en: It is important to recap one's understanding of some of the JavaScript world's
    state of affairs. The most important aspect is that the language is single-threaded
    and, given this, the only option left for developers to write asynchronous code
    is by using callbacks, promises, and events. As a developer, you should be comfortable
    with the functional programming aspects of JS (in addition to its innate dynamic
    nature), including closures, higher-order functions, anonymous functions, and
    extension methods (augmenting types). We also cannot discount the advancements
    that have been made in the language core itself, with Node.js now becoming a preferred
    backend for serious scalability involving async I/O. Let's have a quick peek into
    these core concepts before we dive into RxJS.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾自己对 JavaScript 世界一些现状的理解是很重要的。最重要的方面是，该语言是单线程的，鉴于这一点，开发者编写异步代码的唯一选择是通过使用回调、承诺和事件。作为一名开发者，你应该熟悉
    JS 的函数式编程方面（除了其固有的动态性质），包括闭包、高阶函数、匿名函数和扩展方法（增强类型）。我们也不能忽视语言核心本身所取得的进步，现在 Node.js
    已经成为涉及异步 I/O 的严肃可扩展性的首选后端。在我们深入 RxJS 之前，让我们快速了解一下这些核心概念。
- en: As we all know (we presume you do), functions are objects in JavaScript, and
    they are first-class citizens, which makes JS a functional programming language
    as well (although it is formally classified as a dynamic language). We already
    discussed and saw in [Chapter 10](dn-dsnptn_ch10.html "Chapter 10. Pattern Implementation
    Using Object/Functional Programming"), *Pattern Implementation Using Object/Functional
    Programming* (that too, in depth), how higher-order functions, along with closures,
    enable you to compose programs naturally, now that we have been thinning the OOP
    wall for some time (at least from Chapter 10 onwards). Well, we don't intend to
    imply that JS is an exception.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知（我们假设你也是），函数在 JavaScript 中是对象，并且它们是一等公民，这使得 JS 也是一种函数式编程语言（尽管它正式被分类为动态语言）。我们已经在
    [第 10 章](dn-dsnptn_ch10.html "第 10 章。使用对象/函数式编程实现模式") 中讨论并看到了 *使用对象/函数式编程实现模式*（而且深入讨论），高阶函数以及闭包如何使你能够自然地组合程序，因为我们已经从第
    10 章开始就一直在削弱 OOP 的墙。好吧，我们并不打算暗示 JS 是一个例外。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JS supports OOP through prototypal inheritance compared to classic inheritance
    in C#. This is important to understand how types can be augmented (analogous to
    our extension methods in C#).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JS通过原型继承支持OOP，与C#中的经典继承相比。理解这一点对于了解类型如何被增强（类似于我们在C#中使用的扩展方法）非常重要。
- en: 'Let''s look at a higher-order function, which leverages callback (yet another
    function, which typically gets called for notification and continuation purposes):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个高阶函数，它利用回调（另一个函数，通常用于通知和继续目的）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code snippet, the callback (`onComplete`) is passed as an attribute
    to a function (`doSomething`), thus making it (`doSomething`) a higher-order function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，回调（`onComplete`）作为属性传递给一个函数（`doSomething`），从而使它（`doSomething`）成为一个高阶函数。
- en: 'Now let''s look at a Closure in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看闭包的实际应用：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, `add` is a higher-order function (as it can be assigned
    to a variable), and `x` becomes a closure (lexical closure) within this function
    (irrespective of any nested/sub functions within). The results presented as comments
    against the respective statements speak for themselves. Also, see how anonymous
    functions (in this case, the inner function within the `add` function) are so
    natural in the JS realm. If you remember (from [Chapter 9](dn-dsnptn_ch09.html
    "Chapter 9. Functional Programming Techniques for Better State Management"), *Functional
    Programming Techniques for Better State Management*), this also touches upon currying
    (an important concept in the functional programming world, which we've already
    dealt with in detail), a formalism that breaks any function with arity greater
    than one into a series of function evaluations (each accepting one argument at
    a time).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`add`是一个高阶函数（因为它可以被赋值给变量），而`x`在这个函数内部成为了一个闭包（词法闭包）（无论是否有嵌套/子函数）。相关的注释已经说明了结果。此外，您还可以看到在JS领域中匿名函数（在这种情况下，`add`函数内部的内部函数）是多么自然。如果您记得（从[第9章](dn-dsnptn_ch09.html
    "第9章。更好的状态管理功能编程技术")，*更好的状态管理功能编程技术*），这也涉及到柯里化（功能编程世界中的一个重要概念，我们已经在详细处理过），这是一种将任何大于一元的函数分解为一系列函数评估（每次接受一个参数）的形式主义。
- en: Another important concept to understand is augmenting types in JS. This provides
    an amazing way to impart capabilities to a type (just like the way we use extension
    methods in C#). Let's quickly look at the power of this, using the following example
    in terms of dynamically adding error-handling capability to functions (ones that
    don't have it) at runtime. Ever thought of that?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要理解的重要概念是在JS中增强类型。这提供了一种赋予类型能力的方法（就像我们在C#中使用扩展方法的方式）。让我们快速看看它的强大之处，以下是一个示例，展示了如何在运行时动态地为函数（那些没有错误处理能力的函数）添加错误处理能力。你有没有想过这一点？
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This preceding code essentially augments a function object by adding the `throws`
    method to its prototype object (the base object). It deftly leverages some nifty
    features in the JS language (including array slicing, `arguments` object, function
    context capture using closure, and the `apply` method used for function evaluation).
    We suggest you look it up in case you are unable to follow the code. The candidate
    function, which deliberately throws an exception and one that should gracefully
    exit function evaluation is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码本质上通过向其原型对象（基本对象）添加`throws`方法来增强一个函数对象。它巧妙地利用了JS语言中的一些巧妙特性（包括数组切片、`arguments`对象、使用闭包捕获函数上下文以及用于函数评估的`apply`方法）。如果您无法理解代码，我们建议您查阅相关资料。被故意抛出异常并应该优雅地退出函数评估的候选函数如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code (line 1) can be used in place of direct function evaluation
    (line 2), where the program throws a runtime error (ReferenceError: RxJS is not defined)
    and breaks execution. What is important to note is the preservation of arity for
    these functions despite using the decorator. This is where you will understand
    the relevance of the arguments object and the `apply` method. Here, our decorator
    assumes the semantics - that of issuing the first argument with the error message
    followed by the function arguments in the exact same order! You can easily achieve
    this with a find and replace in your code file, can''t you?'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码（行1）可以用作直接函数评估（行2）的替代，其中程序会抛出一个运行时错误（ReferenceError: RxJS is not defined）并中断执行。需要注意的是，尽管使用了装饰器，这些函数仍然保留了arity。这就是你将理解arguments对象和`apply`方法的相关性的地方。在这里，我们的装饰器假设了语义——即首先传递错误消息作为第一个参数，然后是函数参数，顺序完全相同！你可以在你的代码文件中通过查找和替换轻松实现这一点，不是吗？'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We guess that now you've got a handle on how things work in the JS world. It's
    important to know these as we move forward to explore reactive programming using
    RxJS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们猜测现在你已经掌握了在JS世界中事物是如何工作的。当我们继续探索使用RxJS进行响应式编程时，了解这些内容是非常重要的。
- en: 'To try out the code samples in this chapter, please ensure you have **Node.js**
    set up and RxJS dependencies installed through `npm`, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试本章中的代码示例，请确保你已经设置了**Node.js**，并通过`npm`安装了RxJS依赖项，如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rx foundations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rx基础
- en: Although it may sound repetitive, it is so important to understand the foundations
    of Rx and the key design patterns that govern Rx. Being a book on patterns and
    idioms, it would be really gratifying to know if any interested reader would benefit
    from understanding the underpinnings of these keys concepts as they are realized
    in the host language (JS in this case) directly or via libraries.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能听起来有些重复，但理解Rx的基础以及支配Rx的关键设计模式是非常重要的。作为一本关于模式和习惯用法的书，如果任何感兴趣的读者能从理解这些关键概念在宿主语言（在这种情况下是JS）中的实现中受益，那将是非常令人欣慰的。
- en: The two key design patterns based on which Rx works are the **observer** and
    **iterator** patterns. Let's have a quick look at how these patterns are implemented,
    and then speculate or peek at a possible implementation of RxJS. This way of learning
    would really help in forming a deeper understanding of the core concepts. And
    not to hide the fact that the authors themselves have attempted to create a JS
    library (code-named `YieldJS` on GitHub at [http://shinexavier.github.io/YieldJS/](http://shinexavier.github.io/YieldJS/)),
    which gives the rudimentary capability of RxJS despite being a pull-based implementation.
    However, one thing to keep in mind is that this library was never intended to
    be created as an RxJS clone, but to bring in the **yield** (from the C# world)
    capability to JS prior to ES 6.0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Rx工作的两个关键设计模式是**观察者**和**迭代器**模式。让我们快速看一下这些模式是如何实现的，然后推测或窥视RxJS的可能实现。这种方式的学习将真正有助于形成对核心概念的深入理解。而且，不妨透露一下，作者本人也尝试创建了一个JS库（在GitHub上以`YieldJS`命名，网址为[http://shinexavier.github.io/YieldJS/](http://shinexavier.github.io/YieldJS/)），尽管它是一个基于拉取的实现，但仍然提供了RxJS的基本功能。然而，需要注意的是，这个库从未打算被创建为一个RxJS克隆，而是为了在ES
    6.0之前将C#世界的**yield**（生成器）能力引入JS。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The strategy was very straightforward, since the language ES 5.0 didn't have
    inherent support for **yield** where you would want a generator object, which
    would continuously yield the next computed value and at the same time provide
    an option for forward iteration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 策略非常直接，因为语言ES 5.0没有内建的**yield**支持，你可能会需要一个生成器对象，它可以连续生成下一个计算值，同时提供正向迭代的选项。
- en: 'The preceding statement is very powerful with respect to the fact that this
    library would impart the following capabilities to a generator function in JS:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个库将赋予JS中的生成器函数以下能力的前述声明是非常有力的：
- en: Augmenting the generator function object to have forward iteration capability
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展生成器函数对象以具有正向迭代能力
- en: Accepting a series (unlimited) of iterator methods, which act as continuation
    methods to the core yielded elements
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一系列（无限）的迭代器方法，这些方法作为核心生成元素的后继方法
- en: Yielding the next valid result based on the continuous and sequenced (the very
    order in which it is specified during iteration) iterator function evaluations
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据连续和有序（迭代过程中指定的顺序）的迭代函数评估，生成下一个有效的结果
- en: Supporting lazy evaluation by yielding the computed value only when requested
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仅在请求时提供计算值来支持延迟评估
- en: 'What do you think the authors had in mind when they set on this task of creating
    this library? In case you are still wondering, it was a novel attempt to create
    LINQ capability for sequences created by any generator object (functions, in our
    case) in JS. A subset of the library implementation is depicted in the following
    code, as this helps reason about a possible implementation of RxJS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当作者着手创建这个库的任务时，他们心中想的是什么？如果你仍然感到困惑，那是一个新颖的尝试，为任何生成器对象（在我们的例子中是函数）创建 JS 中的 LINQ
    功能。以下代码展示了库实现的一部分，因为这有助于推理 RxJS 的可能实现：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As highlighted in the preceding code, the key to this implementation is the
    state object `fnContext`, which holds information regarding every function (provided
    during iteration) and its evaluation details. This is critical for the continuation
    needed during iteration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，此实现的关键是状态对象 `fnContext`，它保存有关每个函数（在迭代期间提供）及其评估细节的信息。这对于迭代期间所需的持续操作至关重要。
- en: 'As you can see, the generator would be a method, `getGenerator(numberOfElements)`,
    which augments any generator function (by accepting the number of elements to
    be generated) and has the following interfaces:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生成器将是一个方法，`getGenerator(numberOfElements)`，它增强任何生成器函数（通过接受要生成的元素数量）并具有以下接口：
- en: '**Properties**:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：'
- en: '`current`: Yields the current element during the course of a generation.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current`: 在生成过程中返回当前元素。'
- en: '**Methods**:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：'
- en: '`moveNext`: Attempts to generate the next element based on the generator function,
    increments the iteration pointer, and returns `true` if successful. If unsuccessful
    (primarily because the iteration pointer points to the last element returned by
    the generator function based on the number of elements specified), it returns
    `false`.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moveNext`: 尝试根据生成器函数生成下一个元素，增加迭代指针，如果成功则返回 `true`。如果失败（主要是因为迭代指针指向生成器函数根据指定元素数量返回的最后一个元素），则返回
    `false`。'
- en: 'From a usage standpoint, take a look at the following generic sequence generator:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从使用角度来看，请查看以下通用的序列生成器：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, this accepts a seed incremental value during sequence initialization,
    and returns the actual function (anonymous), which can be invoked multiple times
    to generate the seed sequences. Another critical thing would be the accumulator
    (`y` in our case), which holds the previous item in our sequence because of its
    closure property. Now, let''s see our generator in action:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它在序列初始化期间接受一个种子增量值，并返回一个实际函数（匿名），该函数可以被多次调用以生成种子序列。另一个关键点是累加器（在我们的例子中是
    `y`），由于它的闭包属性，它保存了我们序列中的前一个项。现在，让我们看看我们的生成器是如何工作的：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if you really look carefully, the preceding code snippet has the basic
    framework for creating a reactive library in terms of manipulating sequences (upon
    generation) to suit your needs. This is done using the iterator methods, which
    sort of become your LINQ operators. What really enables this are the context objects,
    which get created for each of the iterator functions. You will understand this
    when we look at some of the iterator methods shown next (ideally, the end users
    are just expected to write the sequence generator, and this library of iterator
    methods can be used for manipulating sequences in real time). Plus, the moment
    you understand how the context object provided during function evaluation can
    be used to write more iterator methods, it becomes all the more exciting and the
    possibilities seem endless. The context object provides the following attributes
    for creating various useful iterator functions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你真的仔细观察，前面的代码片段在创建一个用于操作序列（在生成时）以适应你需求的响应式库方面具有基本框架。这是通过使用迭代器方法完成的，这些方法有点像你的
    LINQ 操作符。真正使其成为可能的是上下文对象，为每个迭代器函数创建。当我们查看下面显示的一些迭代器方法时，你会理解这一点（理想情况下，最终用户只需编写序列生成器，而这个迭代器方法库可以用于实时操作序列）。此外，一旦你理解了在函数评估期间提供的上下文对象如何用于编写更多的迭代器方法，这会变得更加令人兴奋，可能性似乎无穷无尽。上下文对象为创建各种有用的迭代器函数提供了以下属性：
- en: '`index`: Gives the index of the current element in the iteration context'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`: 返回当前元素在迭代上下文中的索引'
- en: '`current`: Gives the current element in the iteration context'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current`: 返回迭代上下文中的当前元素'
- en: '`outList`: Gives the cumulative output collection/array till that point of
    iteration'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outList`: 返回到该迭代点为止的累积输出集合/数组'
- en: 'The usage is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a very standard use of transform operators, where the `current` element
    in the sequence is retrieved and manipulated (squared in this case):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常标准的转换运算符的使用，其中检索并操作序列中的`current`元素（在这种情况下是平方）：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, you clearly see how the `outList` property is leveraged
    for generating unique sequences! Typically, this property becomes very handy for
    implementing aggregation operators:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以清楚地看到如何利用`outList`属性生成唯一的序列！通常，这个属性在实现聚合运算符时非常有用：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is an interesting scenario, where a predicate function (`even`) is used
    in conjunction with an iterator function (`filter`) to filter those elements in
    the sequence that satisfy a certain condition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的场景，其中谓词函数（`even`）与迭代函数（`filter`）结合使用，以过滤满足特定条件的序列中的元素：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And finally, here you see how the `index` property is leveraged for skipping
    certain elements in the sequence!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这里你可以看到如何利用`index`属性跳过序列中的某些元素！
- en: 'Now, to see the entire thing in action, look at the following example usage:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到整个过程的实际应用，请看以下示例用法：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do you get the connection now? Do you see how the two iterator methods (a filter
    and a transformation operator in this case) are composed elegantly in a declarative
    manner? One that would chain these operators during an iteration as an element
    in the sequence is generated. This is reactive (except that, with the iteration,
    you pull as opposed to the conventional push)! Don't you get it? All we need is
    a callback to be passed to our generator object, which would get notified any
    time a new element in the sequence is generated! We will leave that entirely to
    any interested reader (depending on whether you like to be an API producer or
    a consumer) to toy around with this implementation (you are free to fork it on
    GitHub), or directly jump to RxJS and start benefiting from it. Either way, by
    now, we feel you are ready and have the foundation to lock horns with RxJS!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在明白了吗？你看到这两个迭代方法（在这种情况下是一个过滤和一个转换运算符）是如何优雅地以声明性方式组合的吗？它会在生成序列元素时链式调用这些运算符。这是反应性的（除了迭代时是拉取而不是传统的推）！你明白了吗？我们需要的只是一个回调函数传递给我们的生成器对象，这样它就会在序列中生成新元素时得到通知！我们将完全留给任何感兴趣的读者（取决于你是否喜欢成为API生产者或消费者）来尝试这个实现（你可以在GitHub上自由地分叉它），或者直接跳转到RxJS并开始从中受益。无论哪种方式，到现在为止，我们觉得你已经准备好了，并且有了与RxJS对抗的基础！
- en: RxJS formalism
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS形式化
- en: Now, unlike YieldJS, RxJS is push-based. Here, the subscribers would automatically
    receive new values from the publisher. A subscriber or listener is denoted by
    the `observer` object, and the publisher (that pushes/publishes new values) is
    denoted by the `Observable` object. Just like the way we specified iterator methods
    (our future operators) to compose our generated sequences, we can efficiently
    do the same (transform, filter, and so on) for all the elements in the observable
    sequence.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与YieldJS不同，RxJS是基于推的。在这里，订阅者会自动从发布者那里接收新值。订阅者或监听器用`observer`对象表示，发布者（推送/发布新值）用`Observable`对象表示。就像我们指定迭代方法（我们未来的运算符）来组合我们生成的序列一样，我们可以有效地对可观测序列中的所有元素执行相同的操作（转换、过滤等）。
- en: Observables and observers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观测值和观察者
- en: 'The generator becomes our observable, and the callback function, which would
    be interested in these sequences, becomes the observer. Having said this, creating
    `Observables` is pretty straightforward, as we saw in the earlier chapter with
    reactive extensions for .NET. The following code bares it all:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器成为我们的可观测值，而对这些序列感兴趣的回调函数成为观察者。话虽如此，创建`Observables`相当直接，正如我们在前面的章节中通过.NET的响应式扩展所看到的。以下代码展示了这一切：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The client in the preceding code is the `observer`, which has the three important
    callbacks (highlighted), namely, `OnNext`, `OnError`, and `OnCompleted`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的客户端是`observer`，它有三个重要的回调（突出显示），即`OnNext`、`OnError`和`OnCompleted`。
- en: 'As expected, this faithfully prints the following on the console:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它忠实地在控制台打印以下内容：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now let's look at some key bridges offered by RxJS when it comes to working
    with core language constructs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看RxJS在处理核心语言构造时提供的一些关键桥梁。
- en: Observables from arrays
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自数组的可观测值
- en: 'Let''s see how observables can be created from arrays using RxJS:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用RxJS从数组创建可观测值：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As highlighted in the preceding code, you can see that the `from` operator does
    the trick here, and you get the same results as earlier!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，你可以看到`from`操作符在这里起到了作用，并且你得到的结果与之前相同！
- en: Observables from events
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件的可观察性
- en: 'Similarly, we can create observables from events using the `fromEvent` operator.
    The following is an observable, which displays the mouse pointer coordinates whenever
    the mouse crosses diagonally across the window. Since we need the DOM elements
    (document and window) here, we will use the **JSbin** playground for running this
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`fromEvent`操作符从事件创建可观察性。以下是一个可观察性，当鼠标指针在窗口中对角线穿过时，它会显示鼠标指针的坐标。由于这里需要
    DOM 元素（文档和窗口），我们将使用**JSbin**沙盒来运行此代码：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you observe the preceding code, you''ll see that `allMoves` is the primary
    observable sequence, and then we derive the next `movesCrossingDiagonal` sequence
    from `allMoves`. All these sequences are immutable, and we just subscribe (the
    two subscribers are highlighted in code) to those that are of interest. We also
    see the use of the `filter` operator. See the following equivalent code executed
    in the JSbin editor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察前面的代码，你会看到`allMoves`是主要的可观察序列，然后我们从`allMoves`中推导出下一个`movesCrossingDiagonal`序列。所有这些序列都是不可变的，我们只订阅那些感兴趣的序列（代码中突出显示的两个订阅者）。我们还看到了`filter`操作符的使用。请看以下在
    JSbin 编辑器中执行的等效代码：
- en: '![Observables from events](img/B05691_13_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![事件的可观察性](img/B05691_13_01.jpg)'
- en: 'In the HTML code given in the preceding screenshot, you can see the Rx library
    included (you could simply do this in JSbin by using the **Add library** option
    shown in the web editor):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述截图中的 HTML 代码中，你可以看到包含了 Rx 库（你可以在 JSbin 中通过使用网络编辑器中显示的**添加库**选项来完成此操作）：
- en: '![Observables from events](img/B05691_13_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![事件的可观察性](img/B05691_13_02.jpg)'
- en: You will get these results, as seen in the preceding screenshot, the moment
    you move your mouse in the output window (not shown in this screenshot on account
    of brevity).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到前述截图所示的结果，当你将鼠标移至输出窗口时（由于篇幅限制，此截图未显示）。
- en: Observables from callbacks
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调的可观察性
- en: 'Creating observables from callbacks is indispensable when it comes to asynchronous
    and event-driven programming, and it truly completes the final dimension of possibilities
    that observables have to offer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到异步和事件驱动编程时，从回调创建可观察性是必不可少的，它真正完成了可观察性所能提供的最终维度：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s presume you have a file named `alas.tmp` within the `tmp` folder,
    and you modify its contents and save it. The observer would immediately get notified
    of this change, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你在`tmp`文件夹中有一个名为`alas.tmp`的文件，你修改了其内容并保存了它。观察者会立即通知这个变化，如下所示：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, this preceding code, as you can see, helps you with subscribing to a file
    system watcher (directory watcher in this case). There's a shortcoming though!
    Can you spot that before we address this in the coming sections?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如你所见，前述代码可以帮助你订阅文件系统监视器（在这种情况下是目录监视器）。但是有一个缺点！在我们接下来的章节中解决它之前，你能发现吗？
- en: Observable pipeline
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察性管道
- en: 'Remember the operator chaining we did with YieldJS a while ago? Well that''s
    precisely what an `Observable` pipeline is. And if you remember how we trickled
    the state across the chaining operations (as opposed to maintaining it outside),
    you are in good hands. RxJS offers the same, as the `Observable` pipeline is self-contained
    and the state flows from one chained operator to another:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前用 YieldJS 做的链式操作吗？嗯，这正是`Observable`管道。如果你记得我们是如何在链式操作中逐滴传递状态（而不是在外部维护它），那么你就掌握了主动权。RxJS
    提供了同样的功能，因为`Observable`管道是自包含的，状态从一个链式操作符流向另一个：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This preceding code yields the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码产生以下结果：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Another thing to note is that this pipeline is highly efficient in terms of
    evaluations (or, we say, the various steps in an algorithm). In place of conventionally
    having three iterations/passes (per operator), we can do this operator chaining
    in just one iteration for all the three operators. We saw how this is clearly
    achieved in YieldJS. Additionally, you get the benefit of lazy evaluations as
    well! Be sure to check out other operators that may become handy for your day-to-day
    development.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，这个管道在评估方面（或者说，我们说的算法中的各个步骤）非常高效。通常情况下，每个操作符需要三个迭代/遍历（每个操作符），而现在我们只需一个迭代就能完成所有三个操作符的链式操作。我们在
    YieldJS 中看到了这一点是如何明显实现的。此外，你还能享受到延迟评估的好处！务必查看其他可能对日常开发有帮助的操作符。
- en: Subject et al.
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题等
- en: 'As we saw in the previous chapter, we have subjects (those that implement both
    `Observer` and `Observable` types) within RxJS as well. This makes it a powerful
    mediator (a proxy object to be precise) between a source and downstream subscribers/observers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中看到的，RxJS 中也有主题（那些实现了 `Observer` 和 `Observable` 类型的主题）。这使得它成为源和下游订阅者/观察者之间强大的中介（确切地说是一个代理对象）：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following output is seen upon execution of the preceding code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，可以看到以下输出：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These are some of the specialized subjects which one could leverage based on
    their intent of usage:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是根据使用意图可以使用的某些专用主题：
- en: '`AsyncSubject`: Represents the result of an asynchronous action. It can be
    used like a `promise` object in JS. It caches and returns only the last value,
    thus making it ideal for use in asynchronous operations, including AJAX calls,
    file I/O, and so on.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncSubject`：表示异步操作的结果。它可以像 JS 中的 `promise` 对象一样使用。它缓存并只返回最后一个值，因此非常适合用于异步操作，包括
    AJAX 调用、文件 I/O 等。'
- en: '`BehaviorSubject`: This mandates a starting value, making it ideal for initializing
    with placeholder values during any asynchronous operation, including AJAX calls,
    file I/O, and so on.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`：它强制要求一个起始值，因此在任何异步操作中，包括 AJAX 调用、文件 I/O 等，使用占位符值初始化时非常理想。'
- en: '`ReplaySubject`: Caches values (based on the buffer size specified) and re-emits
    those to subscribers irrespective of the time they subscribe to it.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaySubject`：根据指定的缓冲区大小缓存值，并将这些值重新发射给订阅者，无论他们何时订阅。'
- en: Schedulers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度器
- en: 'As we saw earlier, schedulers are powerful tools to manage and handle concurrency.
    You have a lot more control in terms of the concurrency models you choose for
    notifications and subscriptions. You have the following three basic schedulers
    at your disposal:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所看到的，调度器是管理和处理并发的重要工具。在通知和订阅的并发模型选择方面，你拥有更多的控制权。你可以使用以下三个基本调度器：
- en: '**Immediate**: This is de-facto for most of the operators, and is synchronous
    in nature'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立即**：对于大多数操作符来说，这是事实上的默认设置，并且是同步的'
- en: '**Default**: This is asynchronous in nature, and leverages the event loop (using
    `nextTick` in the case of Node.js), `setTimeout`, and so on, behind the scenes'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：这是异步的，并在幕后使用事件循环（在 Node.js 的情况下使用 `nextTick`）、`setTimeout` 等。'
- en: '**Current t****hread**: This, again, is synchronous in nature, except that
    in the case of recursive operators (such as `repeat`), it enqueues executions'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前线程**：这同样是同步的，但在递归操作符（如 `repeat`）的情况下，它会排队执行'
- en: 'And we have two handy operators to help us here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个方便的操作符来帮助我们：
- en: '`observeOn`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observeOn`'
- en: '`subscribeOn`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribeOn`'
- en: Both these return observable instances, but give fine-grained control on concurrency
    by taking in the scheduler as an attribute.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都返回可观察实例，但通过接受调度器作为属性，提供了对并发的细粒度控制。
- en: Please do check out the RxJS references for a deeper understanding of these
    (as coverage of these needs a chapter on its own, and that is not the true intent
    of this book). Now that we have looked at some of the core formalisms in RxJS,
    let's try to explore the world of RxJS with more examples.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看 RxJS 参考，以更深入地了解这些内容（因为这些内容需要单独的一章来覆盖，而这并不是本书的真正目的）。现在我们已经研究了 RxJS 的一些核心形式化，让我们通过更多示例来探索
    RxJS 的世界。
- en: RxJS samples
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS 示例
- en: 'How can we even proceed without seeing our spell checker in action on a web
    page? For this, we need an ASP.NET Web API that provides the suggestions. We will
    reuse our earlier `NorvigSpellCheckerModel` class as-is for this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么能不看到我们的拼写检查器在网页上的实际效果呢？为此，我们需要一个提供建议的 ASP.NET Web API。我们将直接重用我们之前的 `NorvigSpellCheckerModel`
    类：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this preceding code, a `SearchContext` class has been created to pass in
    values for the get API! Also, a small change has been made to the `Global.asax.cs`
    file to accommodate JSONP responses (highlighted in the following code):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此前的代码中，已创建一个 `SearchContext` 类来传递 get API 的值！同时，对 `Global.asax.cs` 文件进行了一些小的修改，以适应
    JSONP 响应（以下代码中突出显示）：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following utility class, which helps you with formatting needs, is needed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实用类，用于满足格式化需求，是必需的：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s see how we can make a responsive frontend using RxJS:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 RxJS 创建响应式的前端：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As indicated here, you would need the following two JS files:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如此处所示，你需要以下两个 JS 文件：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following function (`initialize`) is called as soon as the DOM is loaded:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数（`initialize`）在 DOM 加载完毕后立即被调用：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we do some throttling, and do not overload the server
    with requests, by doing the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过以下方式进行了节流，以避免因请求过多而超载服务器：
- en: Transforming keyup DOM events into observable sequences
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将keyup DOM事件转换为可观察序列
- en: Focusing on the value entered (the `pluck` operator here serves this purpose)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于输入的值（这里的`pluck`操作符起到这个作用）
- en: Looking up search items which have more than three characters (using the `filter`
    operator)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`filter`操作符查找具有三个以上字符的搜索项
- en: Slowing down user input with a timeout of 500 milliseconds (using the `debounce`
    operator)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用500毫秒的超时时间来减缓用户输入（使用`debounce`操作符）
- en: 'Restricting lookup for distinct values in the input stream (using the `distinctUntilChanged`
    operator):'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制输入流中不同值的查找（使用`distinctUntilChanged`操作符）：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function issues the search against the web API, and gets back an observable:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数向Web API发起搜索，并返回一个可观察对象：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `clearSelector` and `createLineItem` functions are helper functions for
    DOM manipulations, which facilitate display:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearSelector`和`createLineItem`函数是DOM操作的帮助函数，它们有助于显示：'
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A sample output is shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例输出：
- en: '![RxJS samples](img/B05691_13_03.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![RxJS样本](img/B05691_13_03.jpg)'
- en: So, by now we have seen how to subscribe to observable sequences (both keyboard
    events and AJAX calls/responses).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们已经看到了如何订阅可观察序列（包括键盘事件和AJAX调用/响应）。
- en: The next sample we will deal with is a logical extension of what we discussed
    earlier. Remember we asked if you could spot a shortcoming in the file watcher
    sample that we discussed under observable from callbacks?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们将处理的示例是我们之前讨论内容的逻辑扩展。记得我们问你是否能在我们之前讨论的可观察对象从回调中讨论的文件监视器样本中找到不足之处？
- en: Real-time file watcher
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时文件监视器
- en: 'The earlier version would terminate the observable sequence upon detecting
    the first change, thus impairing its ability to continuously detect changes. The
    solution to this fix is shown as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本会在检测到第一个变化时终止可观察序列，从而损害其连续检测变化的能力。这个修复的解决方案如下所示：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see in the highlighted code, the fix to the earlier problem is recursive
    scheduling (using the `sceduleRecursive` operator) upon sequence completion (indicated
    using `onCompleted`) during an event detection by the file system watcher component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在突出显示的代码中所见，对早期问题的修复是通过文件系统监视器组件在事件检测期间序列完成时（使用`onCompleted`指示）进行递归调度（使用`sceduleRecursive`操作符）。
- en: 'The following result indicates that our fix works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果表明我们的修复是有效的：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Change galore
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变化多端
- en: 'This sample has a wider implication in various domains, especially logistics.
    The solution involves finding all the change sets for an amount with a given set
    of currency denominations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样本在各个领域都有更广泛的影响，尤其是在物流领域。解决方案涉及找到给定一组货币面额的金额的所有变化集：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see in the preceding code, here we have a global function (in order
    to clearly set a boundary on the global scope), which accepts the denominations
    (in an array) and the amount as two independent attributes. Now, what is important
    here is the strategy we employed to make the computation (or steps in the algorithm)
    asynchronous. For this, we used the default scheduler (`Rx.Scheduler.default`),
    which never blocks the event loop. In case you noticed, the resource cleanups
    are done in the `onCompleted` event:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面代码中所见，这里我们有一个全局函数（为了在全局范围内清楚地设置边界），它接受面额（在数组中）和金额作为两个独立的属性。现在，这里重要的是我们采用的策略，以使计算（或算法中的步骤）异步。为此，我们使用了默认调度器（`Rx.Scheduler.default`），它永远不会阻塞事件循环。如果您注意到了，资源清理是在`onCompleted`事件中完成的：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `printChangeSet` function again creates a local scope, and further employs
    the `findCombinationSet` function to shortlist the applicable `changeSets` out
    of the possible currency combinations (based on the available denominations).
    Another important thing to note here is the tail call optimization done for the
    recursion involving the `findCombinationSet` function (see highlighted code) by
    passing accumulated transient sums, thereby eliminating call-stack growth:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`printChangeSet`函数再次创建一个局部作用域，并进一步使用`findCombinationSet`函数从可能的货币组合中筛选出适用的`changeSets`（基于可用的面额）。这里还有一个需要注意的重要事项是，对于涉及`findCombinationSet`函数的递归，我们通过传递累积的瞬态总和进行了尾调用优化（见突出显示的代码），从而消除了调用栈的增长：'
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In case you are wondering about this `generateChangeSets` function, you guessed
    it right. This is the JS equivalent of the C# subset generation code we saw in
    [Chapter 9](dn-dsnptn_ch09.html "Chapter 9. Functional Programming Techniques
    for Better State Management"), *Functional Programming Techniques for Better State
    Management*. So, by now you would have got a hang on the algorithm employed here,
    which can be explained as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个 `generateChangeSets` 函数，如果你猜对了。这是我们在[第9章](dn-dsnptn_ch09.html "第9章。更好的状态管理功能编程技术")中看到的C#子集生成代码的JS等价物，即《更好的状态管理功能编程技术》。因此，到现在你应该已经熟悉了这里使用的算法，以下是对其的解释：
- en: Generate all possible subsets (possibly denomination combinations).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成所有可能的子集（可能是面额组合）。
- en: Try to determine possible counts per denomination.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试确定每种面额的可能计数。
- en: 'If step 2 is successful, do pretty printing, as shown in the following output
    for `calculateChange([1, 5, 10, 25], 25)`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果步骤2成功，则进行美观打印，如下面的输出所示 `calculateChange([1, 5, 10, 25], 25)`:'
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In case you didn't notice, the console logs appear first before the results
    are printed, clearly indicating that step 2 and beyond are asynchronous!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有注意到，控制台日志先于结果打印出来，这清楚地表明步骤2及以后的步骤是异步的！
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now you must have understood how reactive programming is employed for modeling
    solutions the way the world exists. The principle has been applied for various
    mainstream programming languages, as thought leaders such as Erik Meijer found
    this too natural to express and compose. And we got lucky in this discovery process.
    We believe, as developers, you must have have started appreciating the world of
    functional and reactive programming beyond OOP. In the next chapter, we will be
    specifying, in brief, some important topics which could not be covered in the
    book, such as polyglot programming, **domain specific languages** (**DSLs**),
    ontology, and AntiPatterns.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你必须已经理解了如何使用响应式编程来模拟世界存在的方式。这个原则已经被应用于各种主流编程语言，正如像Erik Meijer这样的思想领袖认为这太自然了，无法表达和组合。在这个发现过程中，我们也非常幸运。我们相信，作为开发者，你们必须已经开始欣赏函数式和响应式编程的世界，而不仅仅是面向对象编程。在下一章中，我们将简要介绍一些书中未能涵盖的重要主题，例如多语言编程、**领域特定语言**（**DSLs**）、本体论和反模式。
