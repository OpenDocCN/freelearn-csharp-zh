- en: HTTP in .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的HTTP
- en: In each of the previous chapters, we explored the fundamental building blocks
    with which network software is built. In this chapter, we'll use those building
    blocks to construct an application that leverages the most common network protocol,
    **Hypertext Transfer Protocol** (**HTTP**). We'll re-examine where in the **Open
    Systems Interconnection** (**OSI**) network stack HTTP falls, and why it is categorized
    as such. We'll more deeply consider the conventions around HTTP requests and responses,
    and spend some time exploring request, response, and content headers. We'll demonstrate
    how to use standard headers for specifying the content you want from an external
    HTTP resource, and how custom headers can be used to toggle specific features
    and functions of your application. Lastly, we'll explore how to serve content
    over the protocol to service HTTP requests made to your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的每一章中，我们探讨了构建网络软件的基本构建块。在本章中，我们将使用这些构建块来构建一个利用最常见网络协议**超文本传输协议**（**HTTP**）的应用程序。我们将重新审视HTTP在**开放系统互联**（**OSI**）网络堆栈中的位置，以及为什么它被归类为这样的类别。我们将更深入地考虑HTTP请求和响应的约定，并花一些时间探索请求、响应和内容头。我们将演示如何使用标准头指定您希望从外部HTTP资源获取的内容，以及如何使用自定义头切换应用程序的特定功能和功能。最后，我们将探索如何通过协议提供内容以服务对应用程序发出的HTTP请求。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The background for the HTTP protocol, and the strengths and limitations of its
    specification
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP协议的背景，以及其规范的优势和局限性
- en: The HTTP request methods, including how to generate, and respond to, those requests
    out of the box with C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求方法，包括如何生成和直接使用C#响应这些请求
- en: How to construct `HttpRequestMessage`, or use `HttpClient` to send requests,
    and the various classes available for responding to requests with a valid HTTP
    response
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构造`HttpRequestMessage`，或使用`HttpClient`发送请求，以及可用于以有效HTTP响应响应请求的各种类
- en: How HTTPS is implemented in C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中如何实现HTTPS
- en: New features supported by HTTP/2 and how to leverage those features in .NET
    Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2支持的新功能以及如何在.NET Core中利用这些功能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll be using sample applications available in the GitHub
    repository for the book here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    9](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%209).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用GitHub上本书的示例应用程序：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%209](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%209)。
- en: We'll also be using each of the tools we leveraged in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*. So, if you didn't take the time to install and start working
    with them before, I suggest you do so now. Specifically, I recommend installing
    Postman from here: [https://www.getpostman.com/apps](https://www.getpostman.com/apps).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用在第8章中使用的每个工具，*套接字和端口*。所以，如果您之前没有花时间安装并开始使用它们，我建议您现在就做。具体来说，我推荐从这里安装Postman：[https://www.getpostman.com/apps](https://www.getpostman.com/apps)。
- en: Alternatively, you can use the Insomnia REST client, which can be found here: [https://insomnia.rest/](https://insomnia.rest/)[.](https://insomnia.rest/)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用Insomnia REST客户端，您可以在以下链接找到它：[https://insomnia.rest/](https://insomnia.rest/)[.](https://insomnia.rest/)
- en: And, while it's not going to be featured heavily in this chapter, since deployment
    options will fall outside the scope of this chapter, I would encourage you to
    use this opportunity to begin working with Docker. I'll point out opportunities
    to modify and extend your Dockerfile and deploy your changes locally.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管它不会在本章中重点介绍，因为部署选项将超出本章的范围，但我鼓励您利用这个机会开始使用Docker。我会指出修改和扩展您的Dockerfile以及本地部署更改的机会。
- en: Check out the following video to see the code in action: [http://bit.ly/2HY5WaA](http://bit.ly/2HY5WaA)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际应用：[http://bit.ly/2HY5WaA](http://bit.ly/2HY5WaA)
- en: Cracking open HTTP
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开HTTP
- en: In [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication Protocols*,
    we had a section, *The application layer*, where we looked at why certain protocols
    fell at that layer. With a little bit more exposure to the nitty-gritty details
    of network transactions under our belt, I'm hoping it will be easier to distinguish
    between the transport layer and the application layer. With HTTP, we have the
    best opportunity to explore that distinction. As a protocol, it has by far the
    broadest, and most robust, support from out-of-the-box C# libraries. That depth
    of in-language resources will give us a sharp lens through which to view the distinction
    between the application layer and its underlying transport layer. So, before we
    learn how to use HTTP, let's learn just exactly what it is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)，*通信协议*中，我们有一个部分，*应用层*，我们探讨了为什么某些协议落在这个层次。在了解了网络事务的细节之后，我希望能够更容易地区分传输层和应用层。对于HTTP，我们有最好的机会来探索这种区别。作为一个协议，它从C#库中获得了最广泛、最稳健的支持。这种语言资源的深度将为我们提供一个锐利的视角，通过这个视角我们可以观察应用层及其底层传输层之间的区别。因此，在我们学习如何使用HTTP之前，让我们先弄清楚它究竟是什么。
- en: The nature of HTTP
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP的本质
- en: When we worked with low-level streams in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Ports and Sockets*, we saw the responsibility that falls on a developer when
    you have to work directly with byte streams, serializing and deserializing data,
    and manually parsing your input headers. There's a mountain of boilerplate code
    just to get a simple string from one machine to another. Obviously, writing the
    same boilerplate code every time you need to make an external resource request
    is tedious and error-prone. This is where protocols come in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第8章](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)，*端口和套接字*中处理低级流时，我们看到了当必须直接与字节流工作、序列化和反序列化数据以及手动解析输入头时，开发者所承担的责任。仅仅为了从一个机器到另一个机器获取一个简单的字符串，就需要大量的样板代码。显然，每次需要发出外部资源请求时都编写相同的样板代码是乏味且容易出错的。这就是协议发挥作用的地方。
- en: We discussed the topic briefly in [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml),
    *Communication Protocols*, where we looked at the protocols defined for each layer
    in the network stack. However, in the intervening chapters, we've established
    a better understanding of how different protocols are separated across the OSI
    stack. So, hopefully, some of the distinctions that may have been hazy back in
    [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication Protocols,*
    will be a bit more clear now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)，*通信协议*中简要讨论了这个话题，我们探讨了网络堆栈中每个层定义的协议。然而，在接下来的章节中，我们已经对如何在不同协议之间跨越OSI堆栈有了更好的理解。因此，希望那些在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)，*通信协议*中可能有些模糊的区别现在会变得更加清晰。
- en: When writing networked software in .NET, there are two primary tiers in the
    OSI stack on which we'll be working. The first, and most obvious, is the application
    layer. That's where HTTP lives, where FTP and SMTP live, and where any web application
    software that you likely have interacted with in the past would have lived. The
    other layer that's commonly written for in .NET, though, is the transport layer.
    Handling TCP and UDP calls directly within a listening server is easily done (and
    we'll see how in later chapters) using some of the versatile and easy-to-use utility
    classes you've likely come to expect from .NET Core. But what's the difference
    between those two layers, from the perspective of the programmer? When we're writing
    HTTP software, we're still very much concerned with the format and structure of
    our serialized data. So, why is that concern different when writing HTTP than
    when handling streams directly with a TCP client?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当在.NET中编写网络软件时，我们将主要在OSI堆栈的这两个层级上工作。第一个，也是最明显的，是应用层。HTTP就生活在这里，FTP和SMTP也在这里，而且你过去可能已经与之交互过的任何Web应用程序软件也都会在这里。然而，在.NET中，通常还会编写传输层。在监听服务器中直接处理TCP和UDP调用很容易（我们将在后面的章节中看到）使用一些你可能会从.NET
    Core中期待的多功能且易于使用的实用类。但程序员从哪个角度来看，这两层之间的区别是什么？当我们编写HTTP软件时，我们仍然非常关注我们序列化数据的格式和结构。那么，为什么在编写HTTP时与直接处理TCP客户端的流相比，这种关注是不同的呢？
- en: The application layer and the transport layer
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层和传输层
- en: The most important thing to internalize when you're trying to understand this
    distinction is the smallest piece of data with which each layer is concerned.
    The application layer is predominantly concerned with application objects*.* So,
    as long as the language you're working with provides a fully-realized abstraction
    of the rest of the network stack (as is the case with C#), you can write code
    that communicates with external resources exclusively through business and application
    models. You'll never have to worry about composing those models from their serialized
    datagrams, or wondering about the character encoding, or the endianness of integers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图理解这种区别时，需要内化的最重要的事情是每个层所关心的最小数据块。应用层主要关注**应用对象**。因此，只要你所使用的语言提供了对整个网络堆栈的完全实现的抽象（例如C#），你就可以编写仅通过业务和应用模型与外部资源通信的代码。你永远不必担心从它们的序列化数据报文组合这些模型，或者担心字符编码，或者整数的字节序。
- en: Instead, you'll be speaking and thinking in terms of the end result of the network
    transaction—for example, "*I'm requesting a database record,"* instead of "*I'm
    requesting a series of bytes for the database record."* If you find yourself falling
    into the anti-pattern of making your application layer software over-generalized
    and abstract, you'll quickly find that it doesn't provide any meaningful value.
    Application layer software should describe and rely on at least some concrete
    business models; otherwise, it's just an unnecessary additional layer in between
    the transport layer and the segment of your code that does use those business
    models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你将用网络事务的结果来思考和说话——例如，“*我正在请求一个数据库记录，*”而不是“*我正在请求数据库记录的一系列字节。*”如果你发现自己陷入了使你的应用层软件过度通用化和抽象的反模式，你很快就会发现自己没有提供任何有意义的价值。应用层软件应该描述并依赖于至少一些具体的业务模型；否则，它只是介于传输层和实际使用这些业务模型的代码段之间不必要的额外层。
- en: 'Meanwhile, on the other side of this conceptual coin, we have the transport
    layer. And as you''ve likely figured out, software written at this level needs
    no business context to be implemented properly and provide its expected value.
    In fact, any representation of non-primitive `Object`s beyond simple generics,
    such as `Serialize<T>()`, would render your transport layer software pretty much
    useless outside the context of a specific business application. Any architecture
    for transport-layered software built around concrete business objects would be
    like a house made out of toothpicks and held together with bubblegum: unstable
    and short-lived.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在这一概念硬币的另一面，我们有传输层。正如你可能已经猜到的，在这一层编写的软件不需要业务上下文就能正确实现并提供其预期的价值。事实上，任何非原始`Object`的表示，比如简单的泛型之外的`Serialize<T>()`，都会使你的传输层软件在没有特定业务应用上下文的情况下变得几乎无用。任何围绕具体业务对象构建的传输层软件架构都像是用牙签搭建的房子，用泡泡糖粘合在一起：不稳定且寿命短暂。
- en: I highlight the distinction between application- and transport-layer software
    now to make the content of the rest of this chapter more intuitive. Going forward,
    some of the classes we'll be working with and thinking about in .NET, and some
    of the advice I'll be giving you around this, will rely on your understanding
    of this distinction. Moreover, though, it's good to understand how HTTP came to
    be, and how it transformed into what it is today.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在强调应用层和传输层软件之间的区别，是为了使本章其余内容的内容更加直观。从现在开始，我们将要使用和思考的一些.NET中的类，以及我将给你的一些关于这方面的建议，都将依赖于你对这种区别的理解。此外，了解HTTP是如何产生，以及它如何演变成今天的样子也是很好的。
- en: The history of HTTP
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP的历史
- en: As I mentioned in [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication
    Protocols*, while, today, HTTP is the de-facto protocol of web-based software,
    its original design and intent is actually much simpler and more limited. Even
    its namesake, **hypertext**, has grown well beyond its original conception.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)中提到的，*通信协议*，虽然现在HTTP是网络软件的事实上的协议，但其原始设计和意图实际上要简单得多，限制也更多。甚至其同名的**超文本**，也已经远远超出了其原始概念。
- en: First described in 1965, hypertext was defined as a specification for rendering
    text on a computer, or other electronic device, with references to other hypertext
    documents, which could be immediately accessed through a system of references,
    known as **hyperlinks**. At its most basic, this describes little more than a
    primitive web page. In fact, you've undoubtedly already realized the link between *hypertext* as
    a concept and the hypertext markup language, or HTML, file format, which is used
    to render web pages. These basic specifications served as the precursor to the
    modern internet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本最早在 1965 年被描述，其定义为一个在计算机或其他电子设备上渲染文本的规范，其中包含对其他超文本文档的引用，这些文档可以通过称为 **超链接**
    的引用系统立即访问。在最基本的意义上，这描述的不过是原始的网页。事实上，你无疑已经意识到作为概念的 *超文本* 与用于渲染网页的超文本标记语言（HTML）文件格式之间的联系。这些基本规范成为了现代互联网的先驱。
- en: Like much of our modern world, the origins for hypertext, HTML, and HTTP can
    be traced back to an influential work of science fiction! A 1941 short story titled
    *The Garden of Forking Paths*, by Jorge Luis Borges, is often credited with being
    the inspiration for the first definition of hypertext.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们现代世界的许多事物一样，超文本、HTML 和 HTTP 的起源可以追溯到一部有影响力的科幻作品！1941 年，豪尔赫·路易斯·博尔赫斯（Jorge
    Luis Borges）所写的短篇小说《分叉的路径花园》（*The Garden of Forking Paths*）通常被认为是超文本第一定义的灵感来源。
- en: Decades later, in 1989, researchers at the **European Organization for Nuclear
    Research** (**CERN**) began to formalize their efforts to define the standards
    for a global computer network, now known as the **World Wide Web** (**WWW**).
    This work included defining a standard for document representation, as well as
    a protocol for transmitting those documents between machines. In 1991, the first
    ever formal definition for HTTP was drafted, and dubbed **v0.9**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数十年后，在 1989 年，欧洲核研究组织（**CERN**）的研究人员开始正式化他们定义全球计算机网络标准的努力，现在被称为 **万维网**（**WWW**）。这项工作包括定义文档表示的标准以及在这些机器之间传输这些文档的协议。1991
    年，HTTP 的第一个正式定义被起草，并命名为 **v0.9**。
- en: This original definition was extremely limited in its scope, intended only to
    define the process of requesting hypertext pages from a given server; the specification
    defined a single method, which is `GET`. As the early internet began to reach
    consumers, however, the needs of the wider audience forced the evolution of the
    standards for the network. By the time HTTP v1.0 was formalized and broadly recognized
    in 1996, the standard grew to include message headers, security, and a wider array
    of operations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原始定义在范围上极为有限，仅旨在定义从给定服务器请求超文本页面的过程；该规范定义了一种单一的方法，即 `GET`。然而，随着互联网在早期开始触及消费者，更广泛的受众需求迫使网络标准的演变。到了
    1996 年，HTTP v1.0 被正式化并在广泛范围内得到认可时，该标准已经扩展到包括消息头、安全性和更广泛的操作。
- en: Still, though, it was almost exclusively used to transmit web pages from servers
    to clients. Each request had to negotiate its own connection with the server,
    and once that request was serviced, the connection was closed. This kind of behavior
    makes sense if you're only requesting a static web page, but what if you wanted
    to incorporate user interaction? That connection negotiation comes at a cost.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管如此，它几乎仅用于从服务器向客户端传输网页。每个请求都必须与服务器协商自己的连接，一旦该请求得到处理，连接就会关闭。如果你只是请求一个静态网页，这种行为是有意义的，但如果你想要加入用户交互呢？这种连接协商是有代价的。
- en: The engineers at CERN recognized this, and in only one year, in 1997, they released
    an updated HTTP v1.1 (often written as HTTP/1.1) specification that provided an
    even richer feature set. This included headers to specify response-caching behavior,
    persistent connections, authentication and authorization, message syntax, and
    routing or redirection behavior. In fact, HTTP/1.1 remains largely unchanged and
    widely used today. However, while the protocol has remained largely unchanged
    until the recent advent of HTTP/2, introduced in 2015, the ways in which engineers
    *use* the protocol have grown exponentially.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CERN 的工程师们认识到了这一点，并在 1997 年仅用一年时间发布了更新的 HTTP v1.1（通常写作 HTTP/1.1）规范，该规范提供了一套更丰富的功能集。这包括用于指定响应缓存行为的头信息、持久连接、身份验证和授权、消息语法以及路由或重定向行为。事实上，HTTP/1.1
    仍然在很大程度上保持不变，并且至今仍被广泛使用。然而，尽管直到最近 HTTP/2 的出现（2015 年引入），该协议本身基本保持不变，但工程师们 *使用*
    该协议的方式却呈指数级增长。
- en: Web services and HTTP
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务和 HTTP
- en: As the internet began to grow from a niche utility for business and engineering
    professionals to share resources and information in the early-to-mid 1990s to
    the wide-spread platform it is today, the software written for the internet had
    to grow along with it. The simplicity and extensibility of HTTP provided such
    a reliable, broadly understood, and broadly supported protocol that it rapidly
    outgrew its original stated intent. Engineers began to leverage it for almost
    every instance of networked services and resource access. Now HTTP is the protocol
    of choice for almost any open API available on the internet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网从20世纪90年代初期的商业和工程专业人士分享资源和信息的利基工具，发展到今天广泛使用的平台，为互联网编写的软件也必须随之增长。HTTP的简单性和可扩展性提供了一个如此可靠、广泛理解和支持的协议，以至于它迅速超越了其最初声明的意图。工程师开始利用它来处理几乎所有的网络服务和资源访问实例。现在，HTTP几乎成为互联网上几乎所有开放API的首选协议。
- en: Early on, Microsoft recognized this, and when it released the first version
    of the .NET framework back in 2001, it did so with full support for HTTP as the
    de-facto application layer protocol for general-purpose network-resource access.
    Later, with the advent of the **Windows Communication Foundation** (**WCF**),
    along with the **Windows Presentation Foundation** (**WPF**), Microsoft continued
    to lean heavily on HTTP for application-layer network services.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 早期，微软就认识到了这一点，当它在2001年发布.NET框架的第一个版本时，它完全支持HTTP作为通用网络资源访问的事实应用层协议。后来，随着**Windows通信基础**（**WCF**）和**Windows表现基础**（**WPF**）的出现，微软继续在应用层网络服务上大量依赖HTTP。
- en: For those who may not know, WCF was Microsoft's suite of libraries and frameworks
    for network-specific, service-oriented application development. Meanwhile, WPF
    was Microsoft's framework for asynchronous user-interface code paradigms. It sought
    to provide the same rich set of features and controls for any desktop or web applications
    with a UI, with a consistent look and feel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能不知道的人来说，WCF是微软为网络特定、面向服务的应用程序开发提供的库和框架套件。同时，WPF是微软为异步用户界面代码范式提供的框架。它旨在为任何具有UI的桌面或Web应用程序提供相同丰富的一套功能和控件，以保持一致的外观和感觉。
- en: The advent of SOAP
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP的出现
- en: Much of WCF was tailored specifically to the implementation of **Simple Object
    Access Protocol** (**SOAP**) services. At first glance, SOAP seems to be an application-layer
    protocol in itself. However, in practice, it's actually a protocol that exists
    one layer above the actual OSI network stack. So, while an application that implements
    the SOAP protocol ensures reliable behavior for any consumers, it doesn't do so
    in any way that is necessary for interaction between network-available resources,
    as we discussed in [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication
    Protocols*. Instead, it sits comfortably on top of the OSI stack, interacting
    directly with application-layer protocols to service the actual network interactions
    required by SOAP applications and their consumers. So, while SOAP-based applications
    rigidly defined their interactions through a protocol, those interactions were
    still most often initiated over an HTTP network transaction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: WCF的大部分内容都是专门针对**简单对象访问协议**（**SOAP**）服务的实现而量身定制的。乍一看，SOAP似乎本身就是一个应用层协议。然而，在实践中，它实际上是一个存在于实际OSI网络栈之上的协议层。因此，虽然实现SOAP协议的应用程序确保了任何消费者都能获得可靠的行为，但它并不以任何必要的方式实现网络可用资源之间的交互，正如我们在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)“通信协议”中讨论的那样。相反，它舒适地位于OSI栈之上，直接与应用层协议交互，以服务SOAP应用程序及其消费者所需的实际网络交互。因此，虽然基于SOAP的应用程序通过协议严格定义了它们的交互，但这些交互仍然最常通过HTTP网络事务来启动。
- en: This had an interesting side effect, however. While SOAP services were leaning
    heavily on HTTP as their transport protocol of choice, it carried with it several
    drawbacks for the emerging web ecosystem of consumer-facing applications and services.
    SOAP was notoriously verbose in both its request and response message structure.
    It had slow transfer and message-parsing performance due to its heavy reliance
    on XML for serialization. Lastly, as a protocol, its implementations were heavily
    fragmented, leading to no reliable SOAP request pattern for use across the vast
    array of services that were, ostensibly, SOAP-based.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这产生了一个有趣的副作用。虽然 SOAP 服务在传输协议方面严重依赖 HTTP，但它给新兴的面向消费者的应用程序和服务网络带来了几个缺点。SOAP
    在其请求和响应消息结构中都非常冗长。由于其过度依赖 XML 进行序列化，它具有缓慢的传输和消息解析性能。最后，作为一个协议，其实现高度碎片化，导致在大量表面上基于
    SOAP 的服务中，没有可靠的 SOAP 请求模式可供使用。
- en: Beginning in the year 2007, with the release of the first iPhone, and continuing
    into the next decade, smartphones rapidly became a viable platform for dedicated,
    consumer-facing applications. While access to broadband internet connections was
    exploding across the globe, cellular networks, which served most of the internet-connected
    devices entering the market, were still several years behind in terms of performance
    and reliability. Meanwhile, all of the disadvantages of SOAP led to poor performance
    and longer development cycles for engineers writing applications to consume one
    or more SOAP-based web services. Across the industry, engineers were realizing
    that they needed an alternative. Millions of dollars were there to be made, but
    with the change needing to be made seemingly overnight for the mobile app market,
    there was almost no time for SOAP to adapt, or even for an alternative version
    to materialize.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2007 年开始，随着第一台 iPhone 的发布，并持续到下一个十年，智能手机迅速成为面向消费者的专用应用平台的可行选择。尽管宽带互联网连接在全球范围内爆炸式增长，但服务于大多数进入市场的互联网连接设备的蜂窝网络，在性能和可靠性方面仍然落后几年。与此同时，SOAP
    的所有缺点导致了工程师编写消费一个或多个基于 SOAP 的 Web 服务的应用程序时的性能低下和更长的开发周期。在整个行业中，工程师们意识到他们需要一个替代方案。数百万美元的利润在那里等着被赚取，但鉴于移动应用市场需要一夜之间进行改变，SOAP
    几乎没有时间进行适应，甚至没有时间出现一个替代版本。
- en: The rise of REST
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 的兴起
- en: So, how did engineers and leaders in the market space adapt? They went back
    to the basics and looked to leverage the underlying protocol more robustly—less
    bloat, fewer intermediary interactions, and less serializing and parsing and negotiating
    connections. Instead, they would use HTTP as the interaction protocol and leverage
    its features to allow for more dynamic and robust interaction while minimizing
    time spent writing custom, service-specific access protocols. To satisfy these
    goals, engineers across the world would leverage REST.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，市场空间中的工程师和领导者是如何适应的呢？他们回归基础，并寻求更稳健地利用底层协议——减少冗余，减少中间交互，以及减少序列化、解析和协商连接。相反，他们会使用
    HTTP 作为交互协议，并利用其特性以实现更动态和稳健的交互，同时最小化编写定制、特定服务的访问协议所花费的时间。为了满足这些目标，全世界的工程师都会利用
    REST。
- en: Short for **Representational State Transfer**, REST was designed as an architectural
    pattern, as opposed to an access protocol. It is convention-based, instead of
    contract-based. This means that anyone familiar with the conventions can use any
    RESTful web service simply by following those conventions. This reduces development
    time for engineers, because it means they can learn the architectural patterns
    once, and then use them everywhere that REST is used. This is obviously much more
    preferable than having to consume and develop for a given contract for a single
    SOAP service, and then having to do the same for each new contract for each new
    service they might have to consume.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**（代表表示状态转移）被设计为一个架构模式，而不是一个访问协议。它是基于约定的，而不是基于合同的。这意味着任何熟悉这些约定的人都可以通过遵循这些约定来使用任何
    RESTful Web 服务。这减少了工程师的开发时间，因为这意味着他们只需学习一次架构模式，然后就可以在 REST 所在的任何地方使用它们。这显然比必须消费和为单个
    SOAP 服务开发合同，然后为每个新服务可能需要消费的每个新合同进行相同的操作要优越得多。'
- en: By refusing to implement a custom protocol on top of the application layer of
    the OSI stack, REST reduces overhead in terms of message negotiation and parsing.
    And since HTTP is, far and away, the most common application-layer protocol used
    for REST services, those services are free to serve up their responses in whatever
    format HTTP can deliver. This means no more strict reliance on XML as your serialization
    language of choice. Instead, JSON has risen as the quick-to-serialize and quick-to-parse
    format of choice for RESTful web services.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拒绝在OSI堆栈的应用层之上实现自定义协议，REST减少了消息协商和解析的开销。由于HTTP远远超过其他应用层协议，成为REST服务的最常用协议，因此这些服务可以自由地以HTTP能够提供的任何格式提供其响应。这意味着不再严格依赖于XML作为首选的序列化语言。相反，JSON已成为RESTful
    Web服务的快速序列化和快速解析格式的首选。
- en: The improved performance and increased flexibility of pure HTTP meant that any
    APIs or services that were intended for consumption by mobile applications were,
    almost universally, REST services. So, in effect, REST rose to replace SOAP as
    the web service paradigm of choice for modern network interactions, and it did
    so on the back of HTTP.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 纯HTTP的改进性能和增加的灵活性意味着任何旨在由移动应用程序消费的API或服务几乎都是REST服务。因此，实际上，REST在HTTP的基础上崛起，取代了SOAP，成为现代网络交互的首选Web服务范式。
- en: HTTP web services in .NET core
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET核心中的HTTP Web服务
- en: 'With the broad applicability of the convention-based REST paradigm, Microsoft''s
    WCF has fallen, somewhat quickly, by the wayside. In its place has risen the web
    API template from ASP.NET, and now ASP.NET Core. Leveraging the patterns first
    formally described in the book *Design Patterns: Elements of Reusable Object-Oriented
    Software*, byGang of Four,ASP.NET released the **Model-View-Controller** (**MVC**)
    application template and libraries to enable the use of clean, convention-based
    software patterns right out of the box.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着基于约定的REST范式的广泛应用，微软的WCF迅速被遗弃。取而代之的是ASP.NET的Web API模板，现在则是ASP.NET Core。利用Gang
    of Four在其书《设计模式：可复用面向对象软件元素》中首次正式描述的图案，ASP.NET发布了**模型-视图-控制器**（**MVC**）应用程序模板和库，以允许直接使用基于约定的干净软件模式。
- en: 'For those not familiar with it, the MVC design pattern describes a strategy
    for isolating the logical responsibilities of complex, user-interactive software
    into logical groupings and organizational structures. The view tier was exactly
    what it sounds like: any UI code or markup that would be sent to the client (typically,
    a user''s web browser of choice). The model tier described your data models, and
    how you access them from whatever persistence mechanism the application is using.
    It typically includes your data-access code as well as any data models that are
    sent to or from your application. Finally, the controller tier describes the business
    application logic that ties your models into a useful context for your users,
    and ultimately returns that context to your user as a view. It serves as an intermediary
    between the other two tiers.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉它的人来说，MVC设计模式描述了一种将复杂、用户交互软件的逻辑责任隔离到逻辑分组和组织结构中的策略。视图层正是其名称所暗示的：任何将被发送到客户端（通常是用户选择的Web浏览器）的UI代码或标记。模型层描述了数据模型以及如何从应用程序使用的任何持久化机制中访问它们。它通常包括数据访问代码以及发送到或从应用程序发送的数据模型。最后，控制器层描述了将模型与用户有用的上下文联系在一起的业务应用逻辑，并最终将此上下文作为视图返回给用户。它充当其他两个层之间的中介。
- en: When the ASP.NET team wanted to define a newer, REST-based pattern for full-featured
    web applications that would leave the bloat of SOAP behind, its members looked
    to MVC. The MVC project template associates every available public resource (in
    the case of early MVC, this was almost always a web page, or a fragment of a web
    page) with a specific HTTP verb at a specific URI. This simplified access to resources,
    as developers only ever needed to know what the target address was and how to
    make a generic HTTP request against that address. It also communicated a lot about
    the nature of the resource based on the HTTP verb required to access it. We'll
    see more of this later in the chapter, but that correlation of semantic structure
    to operational use is a massive shortcut when working with new web services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当ASP.NET团队想要定义一个更新的、基于REST的、具有完整功能的Web应用程序模式，以摆脱SOAP的冗余时，其成员转向了MVC。MVC项目模板将每个可用的公共资源（在早期MVC的情况下，这几乎总是网页或网页的一部分）与特定URI上的特定HTTP动词关联起来。这简化了对资源的访问，因为开发者只需要知道目标地址以及如何对该地址发出通用的HTTP请求。它还根据访问该资源所需的HTTP动词传达了关于资源性质的大量信息。我们将在本章后面看到更多关于这一点的内容，但将语义结构与操作使用相关联是处理新Web服务时的巨大捷径。
- en: From MVC to web API
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从MVC到Web API
- en: Originally, MVC was designed for full-featured web applications serving a UI
    with which users could interact with their backend services. However, the extent
    to which the project template so closely matched the REST paradigm made it a popular
    choice for backend web services that provided no UI whatsoever. In the early 2010s,
    it was common for .NET developers to start from an MVC template, only to scrap
    any semblance of frontend UI code, instead allowing their controller components
    to return raw JSON responses. Needless to say, it didn't take very long for Microsoft
    to recognize the trend and release the Web API project template with an update
    to Visual Studio's project template library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，MVC是为了设计具有完整功能的Web应用程序而设计的，该应用程序提供用户可以与之交互的UI，以便与后端服务进行交互。然而，项目模板与REST范式的紧密匹配程度使其成为没有UI的Web服务的流行选择。在2010年代初，.NET开发者通常从MVC模板开始，然后丢弃任何前端UI代码，而是允许他们的控制器组件返回原始JSON响应。不用说，微软很快就意识到了这一趋势，并随着Visual
    Studio项目模板库的更新发布了Web API项目模板。
- en: With the Web API template, developers can have a basic, RESTful web service
    up and running with only two simple commands in the .NET Core CLI. Controller
    endpoints listen for designated HTTP request methods and return arbitrary responses,
    with no assumptions made about any corresponding UI components. Almost every modern
    REST API implemented in .NET will have been created with this project template
    as its starting point. To that end, we'll spend the rest of this chapter exploring
    HTTP from the context of a Web API project, which will both listen for, and respond
    to, incoming HTTP requests, as well as sending outgoing requests to external APIs.
    This pattern of writing an intermediary aggregator API is extremely common in
    modern enterprise web development, especially in the growing trend of microservices
    and cloud-hosted applications. With that in mind, let's stand up our application
    and start exploring how .NET makes HTTP programming enjoyable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web API模板，开发者只需在.NET Core CLI中输入两个简单的命令，就可以快速搭建一个基本的、RESTful的Web服务。控制器端点监听指定的HTTP请求方法，并返回任意响应，不对任何对应的UI组件做出假设。几乎在.NET中实现的每个现代REST
    API都是从这个项目模板开始的。为此，我们将在本章的剩余部分从Web API项目的角度探讨HTTP，该项目将监听并响应传入的HTTP请求，同时向外部API发送出站请求。在现代企业级Web开发中，编写中间聚合API的模式非常常见，尤其是在微服务和云托管应用程序日益增长的趋势中。考虑到这一点，让我们搭建我们的应用程序，并开始探索.NET如何使HTTP编程变得愉快。
- en: The many methods of HTTP
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP的多种方法
- en: 'While we took some time to explore the concept all the way back in [Chapter
    3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication Protocols*, in
    this section, we''ll take a much closer look at the modus operandi of HTTP: the methods.
    We''ll look at each one in the context of our Web API app, and discuss their intended
    use case, limitations, and the conventions of those methods that you would do
    well to follow. To do that, though, we''ll need our app up and running. So, let''s
    first take a look at how that happens with the Web API project created by the
    .NET CLI.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们早在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)“通信协议”中花了一些时间来探索这个概念，但在本节中，我们将更深入地研究HTTP的操作模式：方法。我们将从我们的Web
    API应用程序的上下文中查看每一个，并讨论它们的预期用例、限制以及那些方法你应该遵循的约定。不过，为了做到这一点，我们需要我们的应用程序运行起来。因此，让我们首先看看.NET
    CLI创建的Web API项目是如何发生的。
- en: Creating a web API project
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Web API项目
- en: 'Just as we did for our sample application in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*, we''ll be creating an instance of a Web API project with
    the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第8章](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)“套接字和端口”中为我们的示例应用所做的那样，我们将使用以下命令创建一个Web
    API项目的实例：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That name might seem odd, so let's describe our application's basic expected
    functionality, and then hopefully it will make more sense. We'll be writing an
    API that will allow users to track fitness activity over time, along with an almost
    identical API that will serve as our data source. This will give us an opportunity
    to see how to listen for different HTTP requests made of our own app, while also
    giving us just enough context to work with generating HTTP requests to an outbound
    service. The actual shape and functionality of our data store app will be almost
    identical to the user-facing API. The only difference is that when our `FitnessApp`
    needs to persist data, it will do so by making HTTP calls to our `FitnessDataStore`
    app. Meanwhile, when our `FitnessDataStore` app needs to store data, it will do
    so by writing to a file on disk.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字可能看起来有些奇怪，所以让我们描述一下我们应用程序的基本预期功能，这样可能就会更加清晰。我们将编写一个API，允许用户跟踪随时间变化的健身活动，以及一个几乎完全相同的API，它将作为我们的数据源。这将给我们一个机会看到如何监听我们自己的应用程序发出的不同HTTP请求，同时给我们足够的上下文来生成对出站服务的HTTP请求。我们的数据存储应用程序的实际形状和功能几乎与面向用户的API相同。唯一的区别是，当我们的`FitnessApp`需要持久化数据时，它将通过向我们的`FitnessDataStore`应用程序发出HTTP调用来实现。同时，当我们的`FitnessDataStore`应用程序需要存储数据时，它将通过写入磁盘上的文件来实现。
- en: The only code we'll be working with in this chapter will be the `FitnessApp`
    code, since that will encapsulate all of the interactions we'll want to learn
    about. The backend data service is available in the sample code for this chapter,
    though, so feel free to browse it, extend it, and modify it if you're curious.
    Also, since our focus will be on the HTTP interactions of this application, and
    it's for demonstration purposes only, we'll be making a lot of naive assumptions
    about data modeling, persistence, and error handling. Instead, I'll leave those
    considerations as an exercise for you to consider and re-evaluate in your own
    time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只处理`FitnessApp`的代码，因为这将封装我们想要了解的所有交互。不过，本章的示例代码中包含了后端数据服务，所以如果你感兴趣，可以自由地浏览、扩展和修改它。此外，由于我们的重点将放在这个应用程序的HTTP交互上，并且它仅用于演示目的，我们将对数据建模、持久化和错误处理做出许多天真假设。相反，我将把这些考虑留给你自己思考，并在你自己的时间里重新评估。
- en: Our application will allow consumers to create new workouts with titles; workout
    types and comments; look up previous workouts by their title, workout type, or
    the contents of their comments; retrieve a list of all previous workouts; edit
    an existing workout's comments; and, finally, it will allow users to delete previous
    workouts from their history. As I said before, each of these operations is specifically
    designed to highlight some aspect of HTTP, as implemented by a .NET Core Web API,
    so the implementation details of these operations will be somewhat simplistic
    and naive, or even overlooked entirely. What's important here is to understand
    the expected I/O and how to model these operations to their appropriate HTTP methods.
    With that in mind, let's look at the project we've just created for ourselves.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将允许消费者创建带有标题的新锻炼；锻炼类型和评论；通过标题、锻炼类型或评论内容查找之前的锻炼；检索所有之前的锻炼列表；编辑现有锻炼的评论；最后，它将允许用户从他们的历史记录中删除之前的锻炼。正如我之前所说，这些操作都是专门设计来突出HTTP的一些方面，正如.NET
    Core Web API所实现的那样，因此这些操作的实现细节将相对简单和直观，甚至可能完全被忽略。这里重要的是要理解预期的I/O以及如何将这些操作建模为适当的HTTP方法。考虑到这一点，让我们看看我们为自己创建的项目。
- en: The web server
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器
- en: 'Looking at our Solution Explorer, you''ll notice that there''s not a whole
    lot to this project template:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的解决方案资源管理器，你会注意到这个项目模板并没有太多内容：
- en: '![](img/89a7ad74-8f22-4e56-bf55-cef7100cbe7b.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89a7ad74-8f22-4e56-bf55-cef7100cbe7b.png)'
- en: There's just two configuration `.json` files, a single controller class, and
    then the initialization and program files. At this point, those new to web development
    in .NET Core might be wondering why we have both a `Program.cs` file and a `Startup.cs`
    file. This is because, like all .NET Core applications, our Web API project is
    actually a console application executed in the context of the `dotnet` host application
    running on the target machine. So, our `Program.cs` provides the conventional
    `Main()` method as the entry point for our `dotnet` execution context to start
    our application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个配置`.json`文件，一个控制器类，然后是初始化和程序文件。在这个时候，对于.NET Core Web开发的新手来说，可能会想知道为什么我们既有`Program.cs`文件又有`Startup.cs`文件。这是因为，像所有.NET
    Core应用程序一样，我们的Web API项目实际上是一个在目标机器上运行的`dotnet`宿主应用程序上下文中执行的控制台应用程序。因此，我们的`Program.cs`提供了传统的`Main()`方法作为我们的`dotnet`执行上下文的入口点来启动我们的应用程序。
- en: However, since we're running an active web application, we'll want to stand
    up a listening web server and provide it the context of our application so that
    it responds to requests appropriately. That's where the `Startup.cs` file comes
    in. This provides all of the configuration, including registering our concrete
    types for dependency injection, and defining the active features and services
    we intend to leverage. Once we've defined all of that, the `Startup` class is
    provided to our web server instance and used to configure the server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们正在运行一个活跃的Web应用程序，我们希望启动一个监听Web服务器，并为其提供应用程序的上下文，以便它能够适当地响应请求。这就是`Startup.cs`文件的作用所在。它提供了所有配置，包括注册我们的具体类型以进行依赖注入，以及定义我们打算利用的活跃功能和服务。一旦我们定义了所有这些，`Startup`类就会被提供给我们的Web服务器实例，并用于配置服务器。
- en: IWebHostBuilder
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IWebHostBuilder
- en: 'Looking at our `Program.cs` file, you can see that''s exactly what happens:
    the `Main()` method only builds our web host, and starts it running with no terminating
    condition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的`Program.cs`文件，你可以看到这正是发生的事情：`Main()`方法只构建我们的Web宿主，并启动它运行，没有终止条件：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `WebHost` class is part of the `Microsoft.AspNetCore` namespace, and its
    default implementation provides a running Kestrel web server that interacts with
    your application code using the `Startup.cs` file provided to the `UseStartup<T>()`
    method on the `IWebHostBuilder` instance you return to your `Main()` method to
    be run by your program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebHost`类是`Microsoft.AspNetCore`命名空间的一部分，它的默认实现提供了一个运行的Kestrel Web服务器，该服务器通过`Startup.cs`文件与你的应用程序代码交互，该文件被提供给`IWebHostBuilder`实例，该实例返回到你的`Main()`方法以由你的程序运行。'
- en: By default, the web server created by the call to `CreateDefaultBuilder()` is
    going to be an instance of a **Kestrel** web server. Kestrel is a cross-platform
    server that will acquire a designated port so it can listen for inbound requests
    against that port, passing all received requests through to your application code.
    It supports HTTP/HTTPS, WebSockets, Unix sockets, and HTTP/2, all out of the box.
    In modern .NET Core apps, there's rarely an occasion to use anything other than
    the default Kestrel server anymore. It can run as an edge server, which means
    it is the first point of contact for any incoming requests made of your application
    (listening at the edge or boundary of your host machine). Likewise, it can be
    run behind a reverse proxy, such as **Internet Information Services** (**IIS**)
    or Nginx, as discussed in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通过调用 `CreateDefaultBuilder()` 创建的 Web 服务器将是一个 **Kestrel** Web 服务器的实例。Kestrel
    是一个跨平台的服务器，它将获取指定的端口以便监听针对该端口的传入请求，并将所有接收到的请求传递到您的应用程序代码。它支持 HTTP/HTTPS、WebSockets、Unix
    套接字和 HTTP/2，所有这些功能都是开箱即用的。在现代 .NET Core 应用程序中，很少需要使用除默认 Kestrel 服务器之外的其他服务器。它可以作为边缘服务器运行，这意味着它是针对您的应用程序的任何传入请求的第一个接触点（在主机机器的边缘或边界处监听）。同样，它也可以在反向代理后面运行，例如
    **Internet Information Services** (**IIS**) 或 Nginx，如第 8 章 [Sockets and Ports](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)
    中所述。
- en: There are a number of advantages to running Kestrel behind a reverse proxy.
    For example, a reverse proxy allows your Kestrel instance to listen for requests
    targeting the same port registered for other listening applications, while running
    it as an edge server blocks the port it is registered to from being used by other
    applications. This leaves your Kestrel instance to handle every inbound request
    made to its registered port, regardless of the targeted URI path or host name
    specified in the requests headers. If the IP is resolved to your application's
    host machine, and the port is the one Kestrel is registered on, Kestrel will service
    it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向代理后面运行 Kestrel 有许多优点。例如，反向代理允许您的 Kestrel 实例监听针对其他监听应用程序已注册的同一端口的请求，而将其作为边缘服务器运行则会阻止其他应用程序使用其注册的端口。这使得您的
    Kestrel 实例能够处理针对其注册端口发出的每个传入请求，无论请求头中指定的目标 URI 路径或主机名如何。如果 IP 解析到您的应用程序的主机机器，并且端口是
    Kestrel 注册的端口，Kestrel 将提供服务。
- en: This port-blocking behavior might make perfect sense if your application is
    the only software deployed and running inside a Docker container published to
    a cloud-hosting platform. However, if it's deployed to an on-premises server hosting
    dozens or even hundreds of other web services, then managing the port registration,
    traffic load, and other resourcing or configuration would likely be unwise, or
    at the very least unpleasant. In that case, a reverse proxy would be the most
    reliable deployment solution. It's up to you to determine the pros and cons of
    using a reverse proxy or running Kestrel as an edge server, but whatever you choose,
    you'll have the tools you need to enable your decision.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序是唯一部署和运行在发布到云托管平台的 Docker 容器中的软件，那么这种端口阻止行为可能非常合理。然而，如果它部署到托管数十甚至数百个其他
    Web 服务的本地服务器上，那么管理端口注册、流量负载和其他资源或配置可能是不明智的，至少是不愉快的。在这种情况下，反向代理将是最可靠的部署解决方案。您需要确定使用反向代理或运行
    Kestrel 作为边缘服务器的利弊，但无论您选择哪种方式，您都将拥有使您的决策生效的工具。
- en: So, when you want to define the behavior of your application code, you do so
    in the `Startup.cs` file, whereas when you want to define the behavior of the
    Kestrel web server that exposes your application code, you do so with your `IWebHostBuilder`.
    Let's look at how to configure our server for now, and then dive into our application
    code's configuration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您想要定义应用程序代码的行为时，您在 `Startup.cs` 文件中这样做，而当您想要定义暴露应用程序代码的 Kestrel Web 服务器的行为时，您使用您的
    `IWebHostBuilder` 来定义。现在让我们看看如何配置我们的服务器，然后深入到我们的应用程序代码的配置中。
- en: First, let's set the URLs we want our application to listen on. For our purposes,
    we'll have direct control over the entire hosting context of any software on our
    machine, so we'll be running Kestrel as an edge server for simplicity's sake.
    Now, to register our server to listen at a specific port, we'll be using the extension
    methods made available on our `IWebHostBuilder` instance that are returned when
    we call `WebHost.CreateDefaultBuilder(args)`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们希望应用程序监听的URL。出于我们的目的，我们将直接控制我们机器上任何软件的整个托管上下文，因此我们将为了简单起见运行Kestrel作为边缘服务器。现在，为了将我们的服务器注册为在特定端口上监听，我们将使用在调用`WebHost.CreateDefaultBuilder(args)`时返回的`IWebHostBuilder`实例上提供的扩展方法。
- en: It might not be obvious when you look at it, but the `UseStartup<T>()` method
    is actually one of those extension methods. It just happens to be so common that
    the Web API project template pre-configures that for you whenever you create a
    new project. And this is a good thing. The methods in `Startup.cs` provide users
    with the opportunity to centralize a lot of boilerplate code and dynamically register
    their concrete classes for dependency injection at runtime. If you haven't used
    dependency injection before, you'll quickly see why this is a huge quality of
    life improvement, and why this little snippet of code is included by the default
    template.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看它时可能并不明显，但`UseStartup<T>()`方法实际上也是那些扩展方法之一。它只是碰巧非常常见，以至于Web API项目模板在创建新项目时为你预先配置了它。这是一件好事。`Startup.cs`中的方法为用户提供集中大量样板代码和动态注册其具体类以在运行时进行依赖注入的机会。如果你之前没有使用过依赖注入，你很快就会看到为什么这是一个巨大的生活质量提升，以及为什么这个小代码片段被默认模板包含。
- en: 'The first extension method we''ll use is the `UseUrls(string[])` method to
    register the IP addresses and ports on which our Kestrel instance will be actively
    listening for incoming requests. To do so, change the `CreateWebHostBuilder(string[]
    args)` method to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第一个扩展方法是`UseUrls(string[])`方法，用于注册Kestrel实例将积极监听请求的IP地址和端口。为此，将`CreateWebHostBuilder(string[]
    args)`方法更改为以下内容：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You'll note that I've registered our server to listen on multiple ports for
    both HTTP and HTTPS requests. I mostly did this for demonstration purposes. It's
    rare that you'll want to actively listen on multiple ports with a single application,
    but this highlights that the `UseUrls()` method will allow you to register and
    listen on an arbitrary number of available ports.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我已经将我们的服务器注册为同时监听HTTP和HTTPS请求的多个端口。我主要做这件事是为了演示目的。通常情况下，你不会希望一个应用程序主动监听多个端口，但这也突出了`UseUrls()`方法将允许你注册并监听任意数量的可用端口。
- en: This code won't work if you plan to ping your API using a mock host name by
    adding entries into your `hosts` file, as we did in [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml),
    *DNS and Resource Location. *Because any host entries you create will be explicitly
    mapped to the IP address `127.0.0.1`, you'll have to explicitly configure Kestrel
    to listen for that exact IP address. You can look at the `FitnessDataStore` sample
    code for an example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用模拟的主机名ping你的API，并将条目添加到你的`hosts`文件中，就像我们在[第2章](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml)中做的那样，*DNS和资源定位*，这段代码将不会工作。因为任何你创建的主机条目都将被明确映射到IP地址`127.0.0.1`，因此你必须明确配置Kestrel以监听该精确的IP地址。你可以查看`FitnessDataStore`示例代码以获取示例。
- en: Using launchSettings.json
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用launchSettings.json
- en: Alternately, you can define your application's listening URLs using the `launchSettings.json`
    file. This file allows you to specify behavior based on the specific environment
    your application is deployed under. Launch profiles can be customized based on
    the web server hosting your application (IIS Express, or Kestrel, which is defined
    as a profile under your project's name when you first create a project using the
    CLI).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`launchSettings.json`文件来定义应用程序的监听URL。此文件允许你根据应用程序部署的具体环境指定行为。启动配置文件可以根据托管应用程序的Web服务器（IIS
    Express或Kestrel，当你首次使用CLI创建项目时，它被定义为项目名称下的一个配置文件）进行自定义。
- en: When you launch your application with the `dotnet run` command, .NET will look
    for a `launchSettings.json` file, then search for the first profile whose `commandName`
    parameter has a value of `"Project"`, which will use the Kestrel web server. From
    within this profile, you can set environment variables that you intend to be leveraged
    by your application. Any environment variables you define in your launch profile
    will override the values of environment variables that exist on your host system.
    This allows you to define different values for environment variables for different
    circumstances, simply by setting them in their corresponding launch profile.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `dotnet run` 命令启动应用程序时，.NET 将查找 `launchSettings.json` 文件，然后搜索第一个 `commandName`
    参数值为 `"Project"` 的配置文件，该配置文件将使用 Kestrel Web 服务器。在此配置文件内，你可以设置你打算由应用程序利用的环境变量。你定义的任何环境变量都将覆盖宿主系统上存在的环境变量的值。这允许你通过在相应的启动配置文件中设置它们来为不同的情况定义不同的环境变量值。
- en: 'You can also set various configurations for your web server inside your launch
    profile. If you look in the `launchSettings.json` file that was created when we
    stood up our `FitnessApp`, you''ll see that it has a profile named `FitnessApp`,
    with a `commandName` value of `Property` as seen here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的启动配置文件中为你的 Web 服务器设置各种配置。如果你查看我们创建 `FitnessApp` 时创建的 `launchSettings.json`
    文件，你会看到它有一个名为 `FitnessApp` 的配置文件，其 `commandName` 值为 `Property`，如下所示：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pay special attention to the `applicationUrl` property there, as it will come
    up in just a moment, as we're running our app for the first time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意那里的 `applicationUrl` 属性，因为它将在我们第一次运行应用程序时立即出现。
- en: 'Now, for the sake of simplicity when using Postman, we''ll change our server
    settings to not use HTTPS redirection for inbound requests to `http://` URLs.
    This just prevents us from having to configure Postman to follow re-directs, and
    gives us a more direct correlation between the code we''re writing and the behavior
    we observe when we test it. To disable the behavior, simply navigate to your `Startup.cs`
    file and, near the bottom of the file, find and remove the line that reads as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了简化使用 Postman 的过程，我们将更改我们的服务器设置，使其不使用 HTTPS 重定向来处理 `http://` URL 的入站请求。这仅仅防止我们不得不配置
    Postman 来跟随重定向，并且让我们在编写代码和测试时观察到的行为之间有更直接的关联。要禁用此行为，只需导航到你的 `Startup.cs` 文件，并在文件底部附近找到并删除以下读取的行：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once that''s done, it''s time to run our application. Simply navigate to the
    folder you created the project in with your command prompt and then execute `dotnet
    run`. Once you have, you should see the following in your terminal:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，就是时候运行我们的应用程序了。只需使用命令提示符导航到你创建项目的文件夹，然后执行 `dotnet run`。一旦执行，你应该在你的终端中看到以下内容：
- en: '![](img/b887810c-c368-451f-8bdb-7ecc1cd2b084.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b887810c-c368-451f-8bdb-7ecc1cd2b084.png)'
- en: You probably noticed that the application is currently listening on each of
    the ports we specified in the array we passed to the `UseUrls()` method, but on
    none of the ports that were specified by the `launchSettings.json` profile.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，应用程序当前正在监听我们传递给 `UseUrls()` 方法的数组中指定的每个端口，但不在 `launchSettings.json`
    配置文件中指定的任何端口上。
- en: 'In order to test this code, you''ll first need to prevent Postman from checking
    for the SSL certificates it''s expecting whenever you navigate to an `https://
    url`. To do so, simply open your SETTINGS and disable SSL certificate verification,
    as seen here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试此代码，你首先需要防止 Postman 在你导航到 `https://` URL 时检查它期望的 SSL 证书。为此，只需打开你的设置并禁用 SSL
    证书验证，如下所示：
- en: '![](img/317f93f6-9df1-4863-a4a4-51ffd2624251.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/317f93f6-9df1-4863-a4a4-51ffd2624251.png)'
- en: 'We''ll look closer at SSL certificates and what this particular Postman setting
    means in [Chapter 13](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml), *Transport
    Layer Security*. For now, though, it''s sufficient to simply disable that setting
    and proceed accordingly. Once that''s done, open Postman and send `GET` requests
    to each of the following URLs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 13 章 [传输层安全性](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml)中更详细地探讨 SSL 证书以及这个特定的
    Postman 设置意味着什么。不过，现在，简单地禁用这个设置并相应地继续操作就足够了。一旦完成，打开 Postman 并向以下每个 URL 发送 `GET`
    请求：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following JSON get returned by all four:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到所有四个都返回以下 JSON：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might have noticed we didn't have to specify ports 80 or 443 in that list.
    This is because, as discussed in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*, each of those ports is reserved for HTTP and HTTPS, respectively.
    So, no port specification on an `http://` or `https://` request is the same as
    specifying 80 or 443.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在那个列表中我们没有指定端口80或443。这是因为，如第8章[《套接字和端口》](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)中讨论的那样，每个端口分别保留用于HTTP和HTTPS。因此，在`http://`或`https://`请求上不指定端口等同于指定80或443。
- en: Meanwhile, if you try to navigate to either of the URLs configured in the `launchSettings.json`
    file, you'll get no response at all. This is because, while settings configured
    in a launch profile in your `launchSettings.json` file will always override any
    system settings that have already been defined, settings configured inside your
    application code when you launch and run your Kestrel server will always override
    any launch profiles. Settings lower down in your scope will always override settings
    configured higher up in your scope.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果您尝试导航到`launchSettings.json`文件中配置的任一URL，您将完全得不到任何响应。这是因为，虽然您在`launchSettings.json`文件中的启动配置文件中配置的设置将始终覆盖任何已定义的系统设置，但您在启动并运行Kestrel服务器时在应用程序代码中配置的设置将始终覆盖任何启动配置文件。在您的范围内较低的设置将始终覆盖在您的范围内较高的设置中配置的设置。
- en: Since configuring your web server in your application's code will always override
    any other configuration values, you should only use that for the most important
    settings that you always want to behave in a single, specific way. Otherwise,
    the `ASPNETCORE_*` environment variables and launch profiles should be used. They
    provide a high degree of flexibility with a low maintenance cost.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在应用程序代码中配置您的Web服务器将始终覆盖任何其他配置值，因此您应该只为始终希望以单一、特定方式行为的最重要的设置使用它。否则，应使用`ASPNETCORE_*`环境变量和启动配置文件。它们提供了高度的灵活性，同时维护成本较低。
- en: Now that our web server is configured to listen for requests to our designated
    ports, let's use our `Startup.cs` file to set up our application to make HTTP
    requests of its own.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的Web服务器以监听对我们指定端口的请求，让我们使用我们的`Startup.cs`文件来设置我们的应用程序以发送自己的HTTP请求。
- en: Registering dependencies in startup.cs
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`Startup.cs`中注册依赖项
- en: 'We''ll be using the `ConfigureServices(IServiceCollection services)` method
    in our `Startup.cs` class to register our specific classes for dependency injection,
    starting with our `IHttpClientFactory` class instances. If you''ve never used
    it before, dependency injection is a great tool for creating loose coupling between
    different aspects of your software that are likely to change over time. Essentially,
    whenever one class (`ClassA`) leverages the properties or methods of another (`ClassB`)
    in order to perform its own functions, a dependency is created. We can say that
    `ClassA` depends on `ClassB`. There are a number of ways to resolve that dependency.
    The naive approach would have us creating instances of `ClassB` directly inside
    of `ClassA` wherever its methods are used, as seen here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Startup.cs`类中使用`ConfigureServices(IServiceCollection services)`方法来注册我们的特定类以进行依赖注入，从我们的`IHttpClientFactory`类实例开始。如果您以前从未使用过它，那么依赖注入是创建软件不同方面之间松散耦合的绝佳工具，这些方面可能会随着时间的推移而发生变化。本质上，每当一个类（`ClassA`）利用另一个类（`ClassB`）的属性或方法来执行其自身功能时，就会创建一个依赖项。我们可以这样说，`ClassA`依赖于`ClassB`。有几种方法可以解决这个依赖项。最简单的方法是在`ClassA`中使用`ClassB`的方法的地方直接创建`ClassB`的实例，如下所示：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But this brings with it a whole host of problems over the course of development.
    If `ClassB` ever needs to be changed, then we'll have to change it everywhere
    it's referenced. The more explicit dependencies we have, the more places we have
    to change it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会在开发过程中带来一系列问题。如果`ClassB`需要更改，那么我们必须在所有引用它的地方进行更改。我们拥有的显式依赖项越多，我们就需要更改的地方就越多。
- en: 'Instead, we can injectthe dependency. To do so, we define an interface for
    the useful functionality that `ClassB` provides for `ClassA` and then define `ClassB`
    as an implementer of that interface. In our example, this `IClassB` interface
    would need to define a method with the signature `string GetSpecialString();`
    and that''s it. Next, we can simply say that `ClassA` needs something that implements
    the `IClassB` interface. To make this dependency clear, without demanding an instance
    of the concrete `ClassB`, we define a constructor that accepts any implementer
    of `IClassB`. This changes our naive approach into the following definition for `ClassA`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以注入依赖项。为此，我们定义一个接口，用于 `ClassB` 为 `ClassA` 提供的有用功能，然后定义 `ClassB` 为该接口的实现者。在我们的例子中，这个
    `IClassB` 接口需要定义一个具有签名 `string GetSpecialString();` 的方法，仅此而已。接下来，我们可以说 `ClassA`
    需要实现 `IClassB` 接口的东西。为了使这个依赖项清晰，而不要求具体的 `ClassB` 实例，我们定义了一个接受 `IClassB` 实现者的构造函数。这改变了我们原始的方法，变成了以下对
    `ClassA` 的定义：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, now,  the `ClassA` class doesn't depend on the `ClassB` class; instead,
    we can say it depends on some functionality that the `ClassB` class happens to
    provide. But it doesn't concern itself with how it gets that functionality. Instead,
    determining what the best concrete class to use is falls on the calling code that
    instantiates `ClassA`. Whatever uses `ClassA` has to determine the best concrete
    instance of `IClassB`, create an instance of it, and then inject it into the newly
    created instance of `ClassA`. If the `IClassB` implementer will ever change based
    on context, or new project requirements, we can make those functional changes
    without having to modify `ClassA` at all. And that is dependency injection in
    a nutshell!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，`ClassA` 类不再依赖于 `ClassB` 类；相反，我们可以说它依赖于 `ClassB` 类偶然提供的一些功能。但它并不关心它是如何获得这些功能的。相反，确定使用最佳具体类的工作落在调用代码上，该代码实例化
    `ClassA`。任何使用 `ClassA` 的东西都必须确定 `IClassB` 的最佳具体实例，创建一个实例，然后将它注入到新创建的 `ClassA`
    实例中。如果 `IClassB` 实现者将根据上下文或新的项目需求而改变，我们可以在不修改 `ClassA` 的情况下进行这些功能更改。这就是依赖注入的精髓！
- en: There's actually a whole lot more to dependency injection when you find yourself
    using it in a professional context. Entire books have been written about the subject.
    And, as with any design pattern, you'll find as many opinions about it as engineers
    you ask for those opinions, and it can be a subject of heated debate in some circles.
    It is way beyond the scope of this chapter (and even this book) to go into detail
    about the many nuances of dependency injection. However, my hope is that this
    explanation will serve as enough of a primer for any readers who have never used
    it before to understand the concept enough to understand how to register dependencies
    in our `Startup.cs` file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在专业环境中使用依赖注入时，实际上还有很多内容。关于这个主题已经写了很多本书。而且，就像任何设计模式一样，你会发现关于它的意见和询问意见的工程师一样多，在某些圈子中，它可能是一个激烈辩论的主题。详细探讨依赖注入的许多细微差别远远超出了本章（甚至这本书）的范围。然而，我的希望是，这个解释将足够作为任何从未使用过它的读者的入门，使他们能够理解这个概念，足够理解如何在我们的
    `Startup.cs` 文件中注册依赖项。
- en: The IHttpClientFactory class
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`IHttpClientFactory` 类'
- en: The first service we'll want to register will be our `HttpClientFactory`. This
    class is an incredibly useful factory class that will provide managed instances
    of the `HttpClient` class. Prior to this wrapper class managing instances of `HttpClient`
    for us, there was actually a very painful and difficult-to-track-down bug that
    would arise when using common patterns for creating and disposing of instances
    of `HttpClient` by hand. Since the `HttpClient` class implements the `IDisposable`
    interface, many developers would instantiate it within the context of a `using(var
    client = new HttpClient())` statement. While this is the recommended pattern for
    almost every other class that implements `IDisposable`, in the specific case of
    `HttpClient`, there was an issue with instances of the client failing to release
    their listening threads. This bug lead to infrequent and inconsistent thread starvation
    in applications with high volumes of outbound HTTP requests. It was a painful
    problem, and the solution we have for it is the `HttpClientFactory` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要注册的服务将是我们的`HttpClientFactory`。这个类是一个极其有用的工厂类，它将提供`HttpClient`类的管理实例。在包装类为我们管理`HttpClient`实例之前，实际上在使用手动创建和销毁`HttpClient`实例的常见模式时，会出现一个非常痛苦且难以追踪的bug。由于`HttpClient`类实现了`IDisposable`接口，许多开发者会在`using(var
    client = new HttpClient())`语句的上下文中实例化它。虽然这是几乎每个实现`IDisposable`接口的类的推荐模式，但在`HttpClient`的具体情况下，存在一个问题，即客户端实例未能释放其监听线程。这个bug导致了在高流量出站HTTP请求的应用程序中，线程饥饿的频繁和不一致。这是一个痛苦的问题，我们为此提供的解决方案是`HttpClientFactory`类。
- en: With this class, we can request instances of `HttpClient` and trust that they
    will be allocated resources on the thread pool properly, and reused wherever possible
    to reduce memory overhead and performance concerns. Given that, it only seems
    appropriate that this is where we take our first steps with registering our dependencies
    in the `Startup.cs` folder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，我们可以请求`HttpClient`的实例，并相信它们将在线程池中正确分配资源，并在可能的情况下重用，以减少内存开销和性能问题。鉴于这一点，这似乎是我们开始在`Startup.cs`文件夹中注册依赖项的第一步。
- en: First, though, we'll need to create a class thathasa dependency on the `HttpClientFactory`
    class. In the root of your project folder, create a new folder named `Services`,
    and inside that folder, create a new class file named `FitnessDataStoreClient.cs`.
    This is the class we'll eventually use to write our data back to our `FitnessDataStore`
    API, which means this is the class that will need an `HttpClient` class to send
    those requests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个依赖于`HttpClientFactory`类的类。在你的项目文件夹根目录下，创建一个名为`Services`的新文件夹，并在该文件夹内创建一个名为`FitnessDataStoreClient.cs`的新类文件。这个类是我们最终用来将数据写回到我们的`FitnessDataStore`
    API的类，这意味着这个类需要一个`HttpClient`类来发送这些请求。
- en: 'Once you have the file created, add a `private readonly` instance of the `IHttpClientFactory`
    interface. Then create a single constructor for your new class that accepts an
    instance of `IHttpClientFactory` as its only argument. Finally, assign the argument
    instance to your private member variable. After doing so, your file should look
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了文件，添加一个`private readonly`的`IHttpClientFactory`接口实例。然后为你的新类创建一个单构造函数，该构造函数接受一个`IHttpClientFactory`实例作为其唯一参数。最后，将参数实例分配给你的私有成员变量。完成这些操作后，你的文件应该看起来像这样：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might be wondering why you can assign to a variable that's marked as `readonly`.
    Any class property or member variable that is marked as `readonly` can be written
    to only in the constructors for the class, or when they are explicitly declared.
    This little feature of the language is especially nice in the case of dependency
    injection, as it gives developers the opportunity to inject dependencies that
    might otherwise need to remain immutable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么你可以对一个标记为`readonly`的变量进行赋值。任何标记为`readonly`的类属性或成员变量只能在类的构造函数中写入，或者当它们被明确声明时。这种语言的小特性在依赖注入的情况下特别有用，因为它给开发者提供了注入可能需要保持不可变性的依赖项的机会。
- en: 'And now that we''ve established our dependency, we''ll need to register a concrete
    instance of it for use in our `Startup.cs` file. With this particular class, since
    the need for an `HttpClient` class is so common in so many web applications, there''s
    actually an extension method on the `IServiceCollection` to register an `IHttpClientFactory`
    instance for injection. To use it in its most basic form, we''ll only need to
    add a single line to our file. In the `ConfigureServices(IServiceCollection services)`
    method, simply insert the following line:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经建立了依赖关系，我们还需要在我们的 `Startup.cs` 文件中注册它的一个具体实例。对于这个特定的类，由于在许多网络应用程序中需要 `HttpClient`
    类的需求非常普遍，实际上在 `IServiceCollection` 上有一个扩展方法来注册一个 `IHttpClientFactory` 实例以供注入。要使用其最基本的形式，我们只需在我们的文件中添加一行。在
    `ConfigureServices(IServiceCollection services)` 方法中，只需插入以下行：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And just like that, when you run your application, your `FitnessDataStoreClient`
    will have access to a valid instance of `HttpClientFactory`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，当你运行你的应用程序时，你的 `FitnessDataStoreClient` 将能够访问一个有效的 `HttpClientFactory` 实例。
- en: Unfortunately, though, this implementation is fairly basic. With what we've
    written, we'll have to configure our `HttpClient` instance every time we request
    it from the factory class. That means defining the base URL, any default headers
    we may want to apply, and other minutia. Instead, we can use the overload method
    of `AddHttpClient()` to create a named client. By doing this, we can centralize
    some of the boilerplate client configuration into our `Startup.cs` file, and then
    when we invoke the named client in our application code, we can skip straight
    ahead to sending requests with it. Using named clients also gives us a simple
    way to manage the need to connect to multiple distinct data sources. Doing so
    not only makes our code easier by eliminating some of the boilerplate of establishing
    a connection for HTTP requests, but can also improve performance by sharing connections
    between various references to the same named `HttpClient` instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个实现相当基础。根据我们所写的，每次我们从工厂类请求 `HttpClient` 实例时，我们都需要配置它。这意味着定义基本 URL、我们可能想要应用的任何默认头信息以及其他细节。相反，我们可以使用
    `AddHttpClient()` 方法的重载版本来创建一个命名的客户端。通过这样做，我们可以将一些客户端配置的样板代码集中到我们的 `Startup.cs`
    文件中，然后当我们在应用程序代码中调用命名的客户端时，我们可以直接发送请求。使用命名的客户端还给我们提供了一个简单的方法来管理连接到多个不同数据源的需求。这样做不仅通过消除建立
    HTTP 请求连接的一些样板代码使我们的代码更易于编写，而且还可以通过在相同的命名 `HttpClient` 实例的各种引用之间共享连接来提高性能。
- en: 'To demonstrate this, I''ll actually be creating two distinct aliases in my
    hosts file for the `FitnessDataStore` API. So, even though, behind the scenes,
    all requests to that API will be going to the same IP address, from the perspective
    of our `FitnessApp` API, it will look as though we''re leveraging two distinct
    APIs with two distinct URLs, and two distinct named `HttpClient` instances. To
    test out this code for yourself, add the following lines to your hosts file, similar
    to how we did it in [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml), *DNS
    and Resource Location*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我实际上将在我的主机文件中为 `FitnessDataStore` API 创建两个不同的别名。所以，尽管在幕后，所有对该 API 的请求都将发送到同一个
    IP 地址，但从我们的 `FitnessApp` API 的角度来看，它看起来就像我们正在利用两个不同的 API，具有两个不同的 URL 和两个不同的命名
    `HttpClient` 实例。要测试这段代码，请将以下行添加到您的 hosts 文件中，类似于我们在 [第 2 章](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml)
    中所做的那样，*DNS 和资源定位*：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we can configure our `HttpClient` instances for each of these host names.
    With named instances of `HttpClientFactory`, we can specify the name by which
    we''ll identify the specific instance we want to create, as well as define some
    default behavior for the client we''re naming. We''ll just call our different
    clients `WRITER` and `READER` for now. So, modify our `ConfigureServices(IServiceCollection
    services)` method as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为这些主机名中的每一个配置我们的 `HttpClient` 实例。使用命名的 `HttpClientFactory` 实例，我们可以指定我们将用来识别我们想要创建的特定实例的名称，以及为我们要命名客户端定义一些默认行为。现在，我们将我们的不同客户端称为
    `WRITER` 和 `READER`。因此，修改我们的 `ConfigureServices(IServiceCollection services)`
    方法如下：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While the `Accept` header isn't usually the most important thing to concern
    ourselves with, this should be sufficient to demonstrate how you might configure
    the common properties for all requests bound generated by the named client. If
    you have a common authorization scheme, you can simply define those values once,
    in your `Startup.cs` class, and not have to concern yourself with updating authentication
    or authorization keys everywhere in your code that makes requests using those
    keys.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Accept`头通常不是我们最关心的事情，但这应该足以展示你如何配置由命名客户端生成的所有请求的常见属性。如果你有一个常见的授权方案，你可以在`Startup.cs`类中一次性定义这些值，而无需担心更新使用这些密钥进行请求的代码中的身份验证或授权密钥。
- en: Since named `HttpClient` instances must be created using the same name they
    were registered with, it's usually best to keep the names in a central configuration
    file, and then reference the value out of that file in both the `Startup.cs` code
    that registers the named client, as well as the application code that requests
    it. Always avoid magic strings wherever possible.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用相同名称注册的`HttpClient`实例必须使用该名称创建，因此通常最好将名称保存在一个中央配置文件中，然后在注册命名客户端的`Startup.cs`代码以及请求该客户端的应用程序代码中引用该文件中的值。尽可能避免使用魔法字符串。
- en: Now that we have our named clients registered, let's get our data-access client
    set up to register with the dependency injection framework so we can start working
    with our controller class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了命名客户端，让我们设置我们的数据访问客户端以注册到依赖注入框架中，这样我们就可以开始使用我们的控制器类工作了。
- en: Registering services in Startup.cs
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`Startup.cs`中注册服务
- en: 'In the sample code, you''ll find a simple model representing a record in our
    fitness activity database. I placed it in a `Models` folder, which is located
    in the root of the `project` directory. This is a common convention in MVC/Web
    API applications, but you can organize your code however makes the most sense
    for you. This class itself is relatively straightforward, and represents all the
    fields described in the project requirements I set out at the start of this section:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，你可以找到一个简单的模型，它代表我们健身活动数据库中的记录。我将其放置在`Models`文件夹中，该文件夹位于`project`目录的根目录。这是MVC/Web
    API应用程序中的常见约定，但你可以根据自己的理解组织代码。这个类本身相对简单，代表了我在这节开头设定的项目要求中描述的所有字段：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, now, inside our `FitnessDataStoreClient` class, we''ll want to define the
    operations we expect to be able to perform on our data store. According to our
    specs, we''ll want to be able to look up all current records, look up individual
    records by their unique `title` property, look up records by `workoutType`, modify
    the `comments` field, and delete a record with a given `title`. For now, let''s
    define those methods to return either a mock response, or just throw `NotImplementedException()`
    to satisfy our build system. We''ll come back to fill out the implementation later
    in the chapter when we look at formatting and generating our requests using `HttpClient`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，在我们的`FitnessDataStoreClient`类中，我们将想要定义我们期望能够在我们的数据存储上执行的操作。根据我们的规范，我们将想要能够查找所有当前记录，通过其唯一的`title`属性查找单个记录，通过`workoutType`查找记录，修改`comments`字段，以及通过给定的`title`删除记录。目前，让我们定义这些方法以返回模拟响应，或者只是抛出`NotImplementedException()`来满足我们的构建系统。我们将在本章后面查看格式化和生成请求时返回到实现：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While we have our implementation defined, we still need to define the interface
    that we''ll use to register the class for dependency injection into our controller.
    We''ve already declared our `FitnessDataStoreClient` class to implement `IDataStoreClient`,
    so that''s the name of the interface we''ll create for dependency injection. So,
    either at the top of the current file, or in a new file located in the same folder,
    add the following interface definition:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经定义了实现，但我们仍然需要定义我们将用于将类注册到控制器中的依赖注入的接口。我们已经声明了`FitnessDataStoreClient`类以实现`IDataStoreClient`，因此我们将创建用于依赖注入的接口名称。因此，无论是在当前文件的顶部还是在同一文件夹中的新文件中，添加以下接口定义：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And since our data store client is going to be entirely stateless (that is
    to say, having no instance properties that might vary between instances of the
    class), we can safely register it as a singleton instance in our `Startup.cs`
    file. So, from inside the `ConfigureServices(...)` method, add the following line:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据存储客户端将完全是无状态的（也就是说，没有可能在类的实例之间变化的实例属性），我们可以在`Startup.cs`文件中安全地将它注册为单例实例。因此，从`ConfigureServices(...)`方法内部，添加以下行：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This particular helper method will allow our dependency injection container
    to create a single instance of the concrete class the first time the class is
    created. The dependency injection container will then provide a reference to that
    single created instance for all subsequent requests for an instance. `WebHost`
    will then inject a reference to that single instance into each other class that
    requests an implementer of the `IDataStoreClient` interface for dependency injection.
    If you need multiple instances created for requesting your API handles, you can
    use the `services.AddScoped<Interface, Implementation>()` variant of this method,
    as this allows new instances to be created with a state that lives only as long
    as it takes to return a response for a given request. Alternatively, if you need
    a new instance every time an instance is injected anywhere in your application,
    regardless of scope, you can use the `services.AddTransient<Interface, Implementation>()`
    variant. Each of these alternatives will provide the same inversion of control
    that is necessary for dependency injection without holding a single managed instance
    of the implementation class over the lifetime of the application, as is the case
    with `AddSingleton()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的辅助方法将允许我们的依赖注入容器在第一次创建类时创建一个具体类的单例实例。依赖注入容器随后将为所有后续请求的实例提供一个对该单例实例的引用。`WebHost`将把对该单例实例的引用注入到请求实现`IDataStoreClient`接口的每个其他类中，用于依赖注入。如果你需要为请求你的API处理程序创建多个实例，你可以使用`services.AddScoped<Interface,
    Implementation>()`这个方法的变体，因为这允许创建具有仅存在于返回给定请求响应所需时间内的状态的新的实例。或者，如果你需要在应用程序的任何地方注入实例时都需要一个新的实例，无论范围如何，你可以使用`services.AddTransient<Interface,
    Implementation>()`这个变体。这些变体中的每一个都将提供必要的控制反转，以实现依赖注入，而不需要在应用程序的生命周期内保持实现类的单个管理实例，就像`AddSingleton()`那样。
- en: Handling incoming HTTP methods
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理传入的HTTP方法
- en: 'Now that we have our service class defined and registered for use in our `Startup.cs`
    file, it''s time to leverage it in our controller and start responding to incoming
    HTTP requests. First, though, we''ll want to modify our controller class so it''s
    a bit more useful for our purposes. Start by changing the name of the class to `FitnessController` and
    removing all of the method stubs provided by the initial project template. At
    the top of the class definition, you''ll see two DataAttributes defined, like
    so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义并注册了服务类，用于在`Startup.cs`文件中调用，现在是时候在我们的控制器中利用它并开始响应传入的HTTP请求了。不过，首先我们需要修改我们的控制器类，使其对我们的目的更有用。首先，将类名改为`FitnessController`，并移除初始项目模板提供的所有方法占位符。在类定义的顶部，你会看到定义了两个数据属性，如下所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These provide context for your `WebServer` about the nature of this class file.
    The first one specifies that your `WebServer` should respond to all requests to
    the URI path `api/[controller]` by looking for valid methods inside this particular
    class. Now, here, `[controller]` is a special placeholder that is replaced with
    the name of your controller class (the segment of your class name that prefixes
    `controller`), so when we change the name of our class file to `FitnessController`
    and run the application, we should begin seeing valid responses by navigating
    to `http://localhost/api/fitness`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些为你的`WebServer`提供了关于此类文件性质的上下文。第一个指定你的`WebServer`应该响应所有对URI路径`api/[controller]`的请求，通过在这个特定类中查找有效的方
    法。现在，这里的`[controller]`是一个特殊的占位符，它将被你的控制器类名（类名前缀为`controller`的部分）替换，所以当我们把我们的类文件名改为`FitnessController`并运行应用程序时，我们应该通过导航到`http://localhost/api/fitness`开始看到有效的响应。
- en: The second DataAttribute, `[ApiController]` method, is actually very important
    if we want our controller to behave as expected. Using that attribute at the top
    of a type definition tells our `WebHostBuilder` to use this particular class as
    a controller and explore its method signatures to discover endpoints that should
    be exposed by the server. It also notifies our `WebServer` to perform automatic
    model-binding validation. What that means is that whenever a request comes in
    targeting one of the controller's endpoints, the inputs specified in the signature
    of the endpoint should match the shape of the request message. By specifying our
    controller as an `ApiController`, `WebServer` will make sure that requests messages
    match our expected inputs before it invokes our controller's methods.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`DataAttribute`，`[ApiController]`方法，如果我们想让我们的控制器按预期行为，实际上非常重要。在类型定义的顶部使用该属性告诉我们的`WebHostBuilder`使用这个特定的类作为控制器，并探索其方法签名以发现服务器应该公开的端点。它还通知我们的`WebServer`执行自动模型绑定验证。这意味着每当有请求针对控制器的一个端点时，端点签名中指定的输入应与请求消息的形状相匹配。通过指定我们的控制器为`ApiController`，`WebServer`将确保在调用我们控制器的任何方法之前，请求消息与我们的预期输入相匹配。
- en: 'With the name changed, and the methods removed, we need to set up our controller
    to use the registered instance of the `IDataStoreClient` implementation. So, let''s
    create a private member variable and inject our instance with a constructor for
    our controller:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 名称更改和删除方法后，我们需要设置我们的控制器以使用注册的`IDataStoreClient`实现实例。因此，让我们创建一个私有成员变量，并使用我们的控制器构造函数注入我们的实例：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, with the `IDataStoreClient` operations as our guide, we can start implementing
    our controller endpoints. Each of our endpoints will demonstrate a different HTTP
    method, so let's consider how those methods are used and how that impacts the
    implementation of our endpoints.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以`IDataStoreClient`操作为指导，我们可以开始实现我们的控制器端点。我们的每个端点都将演示不同的HTTP方法，因此让我们考虑这些方法的使用方式以及它们如何影响我们端点的实现。
- en: The GET method
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GET`方法'
- en: The first and most basic method we'll implement a listener for is the `GET`
    method. This method is used to access a resource at a specific endpoint, and,
    conventionally, `GET` requests carry no content, as specific constraints on the
    lookup are typically passed along as either segments of the URL path, or as key-value
    specifications sent as part of the URL's query parameters. It's up to you (or
    your project's specifications) to enforce those conventions, if you choose to.
    It's worth noting, though, that for most engineers, and for the `HttpClient` methods
    implemented by C#, the assumption is that those conventions will be followed by
    active HTTP services.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现一个监听器的最基本的方法是`GET`方法。此方法用于访问特定端点的资源，并且传统上，`GET`请求不携带内容，因为特定的查找约束通常作为URL路径的段或作为URL查询参数的一部分发送。如果你选择这样做，这取决于你（或你项目的规范）来强制执行这些规范。值得注意的是，对于大多数工程师来说，以及由C#实现的`HttpClient`方法，假设这些规范将被活动的HTTP服务遵循。
- en: One other important note about the `GET` method is that it is generally considered
    both *safe* and *idempotent*. For an HTTP method to be considered *safe*, then
    a request of that method must not have any impact on the state of the resource
    on which the request was made. So, if I request a list of names from a server
    using a simple `GET` request, the server should still have those names stored
    in its database. The server should be exactly the same after it services my request
    as it was before it serviced my request. Meanwhile, if an operation is not safe,
    that means that the state of information stored on the server will be different
    after it processes a request of that unsafe method. The only HTTP methods that
    are always considered safe are `OPTIONS`, `HEAD`, and `GET`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`GET`方法的一个其他重要注意事项是，它通常被认为既*安全*又*幂等*。如果一个HTTP方法被认为是*安全的*，那么该方法的请求不应影响请求的资源的状态。因此，如果我使用简单的`GET`请求从一个服务器请求一个名字列表，服务器应该仍然将其存储在其数据库中。服务器在服务我的请求之后应该与在服务我的请求之前完全相同。同时，如果一个操作不是安全的，这意味着在处理该不安全方法的请求后，服务器上存储的信息状态将不同。始终被认为是安全的唯一HTTP方法是`OPTIONS`、`HEAD`和`GET`。
- en: If you've never seen the word idempotent before, don't worry; it's nothing complicated.
    For a method or operation to be considered idempotent, you should be able to execute
    that operation any number of times without ever getting a different outcome from
    the first time you executed it. So, if I request a record with its ID, it doesn't
    matter how many times I request that record, I should always get the same response
    back that I got the first time I requested it. So, naturally, `GET` is considered
    an idempotent HTTP method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未见过“幂等”这个词，不要担心；它并不复杂。对于一个方法或操作被认为是幂等的，你应该能够多次执行该操作，而不会从第一次执行它以来得到不同的结果。所以，如果我请求一个带有其ID的记录，我不在乎我请求该记录多少次，我应该总是得到与第一次请求时相同的响应。因此，自然地，“GET”被认为是一个幂等的HTTP方法。
- en: 'So, now that we understand how a `GET` method should be handled (that is to
    say, safely, and in such a way to render `GET` requests idempotent), how do we
    configure our controller to respond to a `GET` request? Well, if you read the
    source code I told you to delete before you deleted it, you already know the answer
    to this. But for those who don''t know, we specify our methods as handlers for
    `GET` requests using the `[HttpGet]` method attribute. So, let''s look at all
    of our `read` operations and implement their methods in our controller using `IDataStoreClient`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们了解了应该如何处理`GET`方法（也就是说，安全地，并以使`GET`请求成为幂等的方式），我们如何配置我们的控制器来响应`GET`请求呢？好吧，如果你阅读了我告诉你在删除它之前要删除的源代码，你已经知道答案了。但对于那些不知道的人来说，我们使用`[HttpGet]`方法属性将我们的方法指定为`GET`请求的处理程序。所以，让我们看看所有的`read`操作，并在我们的控制器中使用`IDataStoreClient`实现它们的方法：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the attribute takes an optional string argument specifying a more
    specific URL path that the annotated method is meant to respond to. When the attribute
    is used without the optional parameter, though, the method annotated by the `[HttpGet]`
    attribute will simply respond to any `[HttpGet]` requests made to whatever URL
    path is handled by the parent `Controller` class. So, in this case, our `Get()`
    method will respond to any `GET` requests made against the `api/fitness` path.
    Meanwhile, requests made to `api/fitness/type/{type}` will return all records
    whose `workoutType` field contains the value of the `{type}` parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该属性接受一个可选的字符串参数，指定了注解方法打算响应的更具体的URL路径。然而，当使用该属性而不带可选参数时，由`[HttpGet]`属性注解的方法将简单地响应针对由父`Controller`类处理的任何URL路径发出的任何`[HttpGet]`请求。所以，在这种情况下，我们的`Get()`方法将响应针对`api/fitness`路径的任何`GET`请求。同时，针对`api/fitness/type/{type}`的请求将返回所有`workoutType`字段包含`{type}`参数值的记录。
- en: I should also note here that (as you probably already guessed) the curly-brace
    syntax in the route specification is used as a placeholder for dynamic path variables.
    What's more, you can always safely reference any variable used inside curly braces
    in a route as an argument to your implementing method, and the web server will
    properly map whatever value was used in the request URL's path to its invocation
    of your method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该在这里指出（正如你可能已经猜到的），在路由规范中的花括号语法被用作动态路径变量的占位符。更重要的是，你总是可以安全地引用在路由内部花括号中使用的任何变量，作为实现方法的参数，并且网络服务器将正确地将请求URL路径中使用的任何值映射到你的方法调用。
- en: You may have also noticed that each of our methods has a return type of `ActionResult<T>`
    (ignoring the `Task<T>` outer type that's required for asynchronous methods).
    This is a custom wrapper around our return object that is applied to our methods'
    return values by `ControllerBase`. It will provide the appropriate HTTP status
    code and response headers for whatever result we return within our methods, and
    it does so entirely behind the scenes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，我们每个方法都有一个返回类型为`ActionResult<T>`（忽略异步方法所需的`Task<T>`外部类型）。这是`ControllerBase`应用于我们方法返回值的自定义包装器。它将为我们在方法中返回的任何结果提供适当的HTTP状态码和响应头，并且它完全在幕后完成。
- en: The POST method
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST方法
- en: So, with our `GET` requests serviced, let's look at what a `POST` request is,
    and how to handle it with our application. The `POST` method is typically used
    when a client needs to send a payload of content to the listening server, usually
    for storage or as an input to some calculation or processing that the server is
    responsible for. While, in some cases, some specific `POST` endpoints might be
    both safe and idempotent (because, again, it's up to each developer to adhere
    to the conventions of HTTP and RESTful API development), in the general case,
    `POST` as a method should be assumed to be neither safe nor idempotent.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的 `GET` 请求得到处理后，让我们看看 `POST` 请求是什么，以及如何使用我们的应用程序来处理它。`POST` 方法通常用于客户端需要向监听服务器发送内容负载的情况，通常用于存储或作为服务器负责的某些计算或处理的输入。虽然在某些情况下，一些特定的
    `POST` 端点可能既安全又幂等（因为，再次强调，这取决于每个开发者是否遵守 HTTP 和 RESTful API 开发的约定），但在一般情况下，`POST`
    作为一种方法应该假定既不安全也不幂等。
- en: 'The primary distinction between a `POST` request and a `GET` request is the
    payload associated with the `POST` request. So, let''s look at how we can access
    and parse that payload for processing by our Web API:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 请求与 `GET` 请求的主要区别是 `POST` 请求关联的负载。因此，让我们看看我们如何访问和解析该负载，以便我们的 Web API
    进行处理：'
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we're using the `[FromBody]` parameter attribute on our method's only
    argument, and we're specifying that we expect to receive an instance of the `FitnessRecord`
    class from our request's content body. This attribute will use the `Content-Type`
    header of the request to determine how to parse the incoming message's content
    body and attempt to de-serialize the message into the type specified as the parameter.
    So, here, it would expect the message to be in the format of the `FitnessRecord`
    type. If the message body cannot be deserialized to the expected type, Web API
    will throw an appropriate 4XX status code response indicating some form of a bad
    request was sent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用方法唯一的 `[FromBody]` 参数属性，并指定我们期望从请求的内容体中接收 `FitnessRecord` 类的实例。此属性将使用请求的
    `Content-Type` 标头来确定如何解析传入消息的内容体，并尝试将消息反序列化为指定的类型。因此，这里它期望消息以 `FitnessRecord`
    类型的格式。如果消息体无法反序列化为预期的类型，Web API 将抛出一个适当的 4XX 状态码响应，指示发送了一个不良请求。
- en: I've used the `[FromBody]` attribute here primarily for demonstration purposes,
    as a way to illustrate the various `[From*]` attributes. Interestingly, though,
    because of our use of the `[ApiController]` attribute at the top of our class
    definition, we actually already reap the benefits of this input validation without
    needing to specify the `[FromBody]` attribute when we only have a single class
    specified as the input for a `POST` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里主要使用 `[FromBody]` 属性来演示，作为一种展示 `[From*]` 属性的方法。有趣的是，尽管如此，由于我们在类定义的顶部使用了
    `[ApiController]` 属性，我们实际上已经获得了这种输入验证的好处，而无需在只有一个类指定为 `POST` 方法的输入时指定 `[FromBody]`
    属性。
- en: 'There are a number of `[From*]` attributes you can apply to incoming messages
    to map your formal argument variable to some part of the incoming request. These
    include the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以应用多个 `[From*]` 属性到传入的消息中，以将你的形式参数变量映射到传入请求的某个部分。以下是一些例子：
- en: '`[FromBody]`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromBody]`'
- en: '`[FromForm]`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromForm]`'
- en: '`[FromQuery]`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromQuery]`'
- en: '`[FromRoute]`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromRoute]`'
- en: '`[FromHeader]`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromHeader]`'
- en: Each of these parameter bindings will attempt to retrieve your the value of
    your formal parameter from the target location, and, if possible, will attempt
    to de-serialize the specific message component into the simple type you've declared
    for your formal parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些参数绑定都将尝试从目标位置检索你的形式参数的值，并且如果可能的话，将尝试将特定的消息组件反序列化为你为形式参数声明的简单类型。
- en: Additionally, there is a `[FromServices]` attribute. This is unique from the
    others in that it doesn't actually attempt to parse the designated argument from
    any part of your incoming message. Instead, this allows you to retrieve an instance
    of a dependency-injected interface from your registered services and assign it
    to a variable scoped to that single method, instead of having a class member variable
    whose value is assigned in the constructor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `[FromServices]` 属性。与其他属性不同，它实际上并不尝试从你的传入消息的任何部分解析指定的参数。相反，这允许你从注册的服务中检索依赖注入的接口的实例，并将其分配给仅限于该单个方法的变量，而不是分配给在构造函数中赋值的类成员变量。
- en: The other interesting concept we've introduced with this method is sending generalized
    HTTP responses using the built-in methods of the `BaseController` class. Our two
    possible return values are determined by the `Ok()` and `StatusCode()` methods.
    Each of these will do the work of formatting an `HttpResponse` object for the
    desired `StatusCode`, with `Ok()` obviously returning a `200` code, and the `StatusCode()`
    method returning a response with whichever status code you specify as your argument.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种方法引入的另一个有趣的概念是使用`BaseController`类的内置方法发送通用HTTP响应。我们两个可能的返回值由`Ok()`和`StatusCode()`方法确定。这些方法中的每一个都会为所需的`StatusCode`格式化一个`HttpResponse`对象，其中`Ok()`显然返回`200`代码，而`StatusCode()`方法返回一个带有你指定的状态码作为参数的响应。
- en: The PUT and PATCH methods
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PUT`和`PATCH`方法'
- en: Next let's look at the HTTP methods that will allow us to apply updates to records
    that already exist on the server. This can be done with either of the `PUT` or
    `PATCH` methods. Now, since I've just described them as updating the state of
    the server, it should be obvious that neither of these methods are considered
    safe. However, a `PUT`  method should be idempotent (when properly implemented).
    We'll see why momentarily, but `PATCH` is not considered generally idempotent.
    The difference between the two is subtle, and often they are implemented in a
    way as to be interchangeable, so let's learn how they work and think about which
    is the most appropriate for our update operation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看那些允许我们对服务器上已经存在的记录应用更新的HTTP方法。这可以通过`PUT`或`PATCH`方法中的任何一个来完成。既然我已经将它们描述为更新服务器状态，那么很明显，这两种方法都不被认为是安全的。然而，`PUT`方法应该是幂等的（如果正确实现）。我们将稍后看到原因，但`PATCH`通常不被认为是幂等的。两者之间的区别很微妙，并且它们通常以可互换的方式实现，所以让我们学习它们是如何工作的，并考虑哪个最适合我们的更新操作。
- en: When a `PUT` method has been implemented to the HTTP standard, the client is
    expected to provide a full instance of a minimum payload and a target destination
    for that payload. If there is a record at that target destination, then the payload
    is considered an update to that record, and the entire existing record is overwritten
    with the payload. Meanwhile, if there is no record at that target destination,
    then the payload is inserted, just as with `POST`, at the target URI. So, now,
    hopefully, you can see why this operation is idempotent. Using a single given
    payload, it doesn't matter how many times we execute the `PUT` method; it will
    always set the record at the target location to the value of that same payload.
    Subsequent executions have no effect after the first operation succeeds.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当`PUT`方法被实现为HTTP标准的一部分时，客户端应提供该最小有效负载的完整实例以及该负载的目标目的地。如果在该目标目的地存在记录，则该负载被视为对该记录的更新，并且整个现有记录将被负载覆盖。同时，如果在该目标目的地没有记录，则负载将被插入，就像`POST`方法一样，在目标URI处。因此，现在，希望你能看到为什么这个操作是幂等的。使用单个给定的负载，无论我们执行`PUT`方法的次数多少；它总会将目标位置的记录设置为相同负载的值。第一次操作成功后，后续执行不再产生影响。
- en: Some of the more astute readers may have identified a risk inherent to the `PUT`
    operation. Specifically, unless you have the most up-to-date version of the record
    you intend to update, you run the risk of overwriting recent changes to the record
    that you were unaware of with your `PUT`. Thus, it's usually wise to do a `GET`
     operation on the target record prior to applying any `PUT` updates to it to ensure
    that no recent updates are accidentally reverted. This introduces a performance
    hit in the form of additional round trips to your server, and, likely, a resource-locking
    mechanism to ensure that no one updates your target record in the time between
    your `GET` and your `PUT`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更敏锐的读者可能已经识别出`PUT`操作固有的风险。具体来说，除非你有你打算更新的记录的最新版本，否则你冒着用`PUT`覆盖你未知的记录最近更改的风险。因此，在应用任何`PUT`更新之前，通常明智的做法是在目标记录上执行`GET`操作，以确保不会意外地撤销最近更新。这引入了性能损失，表现为额外的往返服务器，以及可能的一个资源锁定机制，以确保在`GET`和`PUT`之间没有人更新你的目标记录。
- en: 'The `PATCH` method, on the other hand, only requires that a *set of changes,
    as described in the request payload*, be applied to an entity identified by the
    request URI. This means that our payload could describe a change be made to only
    a specific property on the target resource, without having to send the new, wholly
    updated state of the record with each `PATCH` request. For example, a properly
    formatted `PATCH` request could have a payload that describes your changes as
    follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`PATCH`方法仅要求将请求负载中描述的*更改集*应用于由请求URI标识的实体。这意味着我们的负载可以描述对目标资源上的特定属性进行更改，而无需在每次`PATCH`请求中发送记录的新、完全更新的状态。例如，一个格式正确的`PATCH`请求可以有一个负载，如下所示描述您的更改：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Thus, when the operation is called, your API would have the information necessary
    to update only the relevant field you hope to update. You''ll note, though, that
    the definition of a patch is vague enough that you could describe a set of changes
    that apply new content and change the state of the server with each subsequent
    request. For example, imagine the following description:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调用操作时，您的API将拥有更新您希望更新的相关字段所需的信息。然而，请注意，补丁的定义足够模糊，您可以在每个后续请求中描述一组应用新内容并更改服务器状态的更改。例如，想象以下描述：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If this operation appended the value of a suffix to the target property, then
    each subsequent `PATCH` with the same payload would result in a longer and longer
    `comments` field. Because of this broad spectrum of a possible *set of changes,
    as described by the payload*, the `PATCH` operation is not assumed to be idempotent.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此操作将后缀值附加到目标属性上，那么具有相同负载的每个后续`PATCH`操作都会导致`comments`字段越来越长。由于这种由负载描述的可能*更改集*范围很广，因此假设`PATCH`操作不是幂等的。
- en: 'Now, technically, the standard produced by the **Internet Engineering Task
    Force** (**IETF**) that describes the `PATCH` operation (RFC 5789) specifies that
    the payload of a `PATCH` request contains a set of instructions describing how
    a resource currently residing on the origin server should be modified to produce
    the new version. This seems to indicate that the payload actually explicitly describes
    a sequence of operations to perform on the target resource, as opposed to representing
    a partial object state with only the fields that are meant to be updated. Under
    this interpretation, the following `PATCH` payload might be considered non-standard,
    or incorrect:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从技术上讲，由**互联网工程任务组**（**IETF**）制定的描述`PATCH`操作（RFC 5789）的标准规定，`PATCH`请求的负载包含一组指令，说明如何修改当前位于原始服务器上的资源以生成新版本。这似乎表明负载实际上明确描述了要在目标资源上执行的操作序列，而不是仅用要更新的字段表示部分对象状态。根据这种解释，以下`PATCH`负载可能被视为非标准或不正确：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In fact, there are a number of purists who insist that using `PATCH` to send
    only partial object structures is an explicitly incorrect use of the method as
    defined in the standard. However, I would argue that a payload containing a partial
    object structure is itself a highly streamlined description of a set of changes
    to apply to the resource. I would actually make the case that such an implementation
    does not violate the spirit or letter of the standard. To wit, the stated intent
    of RFC 5789 is to provide the partial-update functionality that is not provided
    by the `PUT` operation, and a partial object structure does exactly that. In fact,
    there is even a new standard out for comment that specifies that exact payload
    structure: RFC 7936.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有许多纯粹主义者坚持认为，使用`PATCH`仅发送部分对象结构是明确错误地使用标准中定义的方法。然而，我会争辩说，包含部分对象结构的负载本身就是对应用资源的一组更改的高度精简描述。我实际上会提出这样的实现并不违反标准的意图或文字。具体来说，RFC
    5789声明的意图是提供`PUT`操作未提供的部分更新功能，而部分对象结构正好做到了这一点。事实上，甚至还有一个新的标准出来指定了确切的负载结构：RFC 7936。
- en: 'As you decide how to implement `PATCH`, I would encourage you to read the opinions
    of others on how it should be written so as to meet the standard, and then decide
    for yourself whether you should take a more pure approach, or allow the partial
    object structure. I''ve already explained my reasoning for accepting the partial
    object approach, and so that''s how we''ll implement our comment-update method
    in our API:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定如何实现`PATCH`时，我鼓励你阅读其他人关于如何编写的意见，以便满足标准，然后自己决定你是否应该采取更纯粹的方法，或者允许部分对象结构。我已经解释了我接受部分对象方法的原因，因此我们将按照这种方式在我们的API中实现我们的评论更新方法：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, since we're only allowing our users to update their comments, we'll use
    the REST paradigm of using our path to describe the most specific part of our
    system that we want to interact with. Thus, our path and method specify that we
    want to `PATCH` the value of the comments at the record with the given title.
    This, semantically, communicates everything we need to know about this operation,
    and I would assert accomplishes all of the goals of RESTful design, within the
    standards of the HTTP operation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，由于我们只允许用户更新他们的评论，我们将使用REST范式，通过我们的路径来描述我们想要与之交互的系统中最具体的部分。因此，我们的路径和方法指定了我们想要在给定标题的记录中`PATCH`评论的值。从语义上讲，这传达了我们需要了解的所有关于这个操作的信息，并且我会断言，在HTTP操作的标准内，这实现了RESTful设计的所有目标。
- en: The DELETE method
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE方法
- en: 'Finally, we''ll look at perhaps the most intuitive method described for HTTP,
    the `DELETE` method. Sending a `DELETE` request to a target resource will do exactly
    that: it will delete the resource from the server, replacing it with nothing.
    Since this updates the state on the server, the method is not safe. However, since
    you can''t delete a record that''s already been deleted, the operation is considered
    idempotent.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨HTTP中描述的最直观的方法之一，即`DELETE`方法。向目标资源发送`DELETE`请求将正好做到这一点：它将从服务器删除资源，并用空值替换它。由于这个方法更新了服务器上的状态，所以这个方法是不安全的。然而，由于你不能删除已经删除的记录，所以这个操作被认为是幂等的。
- en: 'A `DELETE` request may receive a response with a body describing the object
    that was deleted, or the success or failure of the operation, but, typically,
    just a 2XX status code message is delivered on a successful deletion. This method
    is as simple as it sounds, so let''s implement it in our controller:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`DELETE`请求可能会收到一个包含被删除对象描述、操作的成功或失败信息的响应，但通常，在成功删除的情况下，只会发送一个2XX状态码的消息。这个方法听起来很简单，所以让我们在我们的控制器中实现它：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Exactly as you would expect, the method is defined as a valid handler for `DELETE`
    requests using the `[HttpDelete("{title}")]` attribute, and merely returns a status
    code of either `200` or `400`, with a success message.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，该方法被定义为`DELETE`请求的有效处理程序，使用`[HttpDelete("{title}")]`属性，并且仅返回`200`或`400`状态码，以及一个成功消息。
- en: And just like that, we've written a service that will listen for and properly
    respond to the full suite of valid HTTP methods for which you'll be expected to
    write custom software. So, now that we can handle incoming HTTP requests, let's
    look at how to build and send outbound requests of our own.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经编写了一个服务，该服务将监听并正确响应所有有效的HTTP方法，对于这些方法，你将需要编写自定义软件。因此，现在我们能够处理传入的HTTP请求后，让我们来看看如何构建和发送我们自己的出站请求。
- en: HTTP request formatting
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求格式
- en: With it being such a common aspect of most modern software projects, it should
    come as no surprise that generating HTTP requests has been so thoroughly streamlined
    by the .NET Core standard that it's an absolute breeze to use. We'll be using
    the `HttpClient` class to send outbound requests that perfectly mirror the `FitnessApp`
    API we just defined in our controller class, so understanding the expected paths
    and inputs should be a straightforward endeavor. So, with that in mind, let's
    crack open our `FitnessDataStoreClient` class and start generating requests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是大多数现代软件项目的一个如此常见的方面，因此生成HTTP请求被.NET Core标准彻底简化，使用起来绝对轻松。我们将使用`HttpClient`类来发送与我们在控制器类中定义的`FitnessApp`
    API完美匹配的出站请求，因此理解预期的路径和输入应该是一项直接的任务。所以，考虑到这一点，让我们打开我们的`FitnessDataStoreClient`类并开始生成请求。
- en: Creating HttpClient instances
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HttpClient实例
- en: 'We''ll start with the simple read operations in our API, but in order to do
    that, we''ll need to spin up an instance of the `HttpClient` class for use to
    use to generate our requests. To do this, we''ll want to request the instance
    of the class that we registered for read operations. This is as simple as calling
    `CreateClient()` with the same key we used to register the `READER` instance in
    the first place. So, inside our `GetAllRecords()` method, simply add the following
    line to the start of the method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从API中的简单读取操作开始，但为了做到这一点，我们需要启动`HttpClient`类的实例以便我们使用它来生成我们的请求。为此，我们将想要请求我们为读取操作注册的类的实例。这就像用最初注册`READER`实例时使用的相同密钥调用`CreateClient()`一样简单。因此，在我们的`GetAllRecords()`方法中，只需在方法开始处添加以下行即可：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And now, our client variable contains an instance of `HttpClient` that's already
    configured with the `BaseAddress` and `DefaultHeaders` properties we set in our
    `Startup.cs` file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的客户端变量包含了一个已经配置了我们在`Startup.cs`文件中设置的`BaseAddress`和`DefaultHeaders`属性的`HttpClient`实例。
- en: If you ever need to create an `HttpClient` class without pre-registering it
    (suppose you needed it to access a URL that you don't know the value of until
    runtime), you can do so by simply leaving the arguments of the `CreateClient()`
    call empty. You'll then be responsible for setting the `BaseAddress`  property
    for your requests and any necessary headers on your newly created client, but
    that's done in exactly the same way as we did it in our `Startup.cs` file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个没有预先注册的`HttpClient`类（假设你需要它来访问在运行时才知道值的URL），你可以通过简单地使`CreateClient()`调用的参数为空来实现。然后，你将负责为你的请求设置`BaseAddress`属性以及任何必要的头信息在你的新创建的客户端上，但这与我们在`Startup.cs`文件中所做的方式完全相同。
- en: Building a request message
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建请求消息
- en: 'Now that we have our client, creating an outbound `GET` request is as simple
    as defining an `HttpRequestMessage` instance and specifying the method and target
    path we intend to send our request with. And since `GET` requests conventionally
    have no content body, that initial `HttpRequestMessage` definition is sufficient
    to give to our `HttpClient` for transmission. If you need to apply headers, you
    can do so with the `Headers` property of the `HttpRequestMessage` class, but since
    we don''t, let''s just create our message, and send it with our client:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的客户端，创建一个出站`GET`请求就像定义一个`HttpRequestMessage`实例并指定我们打算发送请求的方法和目标路径一样简单。由于`GET`请求传统上没有内容主体，所以最初的`HttpRequestMessage`定义就足够给我们的`HttpClient`进行传输了。如果你需要应用头信息，你可以使用`HttpRequestMessage`类的`Headers`属性来实现，但由于我们不需要，让我们只创建我们的消息，并通过我们的客户端发送它：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And just like that, we have the response from our server in a variable for
    us to work with. Before we proceed with parsing the response message, though,
    we''ll want to make sure that our operation completed successfully. A common pattern
    is to wrap any error-handling code (which we won''t be implementing here, for
    brevity''s sake) in a conditional clause checking the success of the request.
    Once we''ve confirmed that behavior, though, we can safely attempt to parse our
    `response` object:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们有了来自服务器的响应，可以用来工作。在我们继续解析响应消息之前，我们想要确保我们的操作已经成功完成。一个常见的模式是将任何错误处理代码（为了简洁起见，我们在这里不会实现）包裹在一个条件语句中，该语句检查请求的成功。一旦我们确认了这种行为，我们就可以安全地尝试解析我们的`response`对象：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `response` object we get back represents the entirety of the HTTP response
    from the server, including any headers the server sent back, and the status code,
    and even the content of the original request message. Typically, though, you'll
    only be concerned with the `StatusCode` property, and the `Content` property.
    The `StatusCode` property is actually an enum type that enumerates all valid HTTP
    response status codes, and is what's used to determine the result of the derived
    `IsSuccessStatusCode` property. Meanwhile, the `Content` property is an instance
    of the `HttpContent` class, which contains an array of headers specific to the
    content, as well as a number of utility methods for reading and parsing the body
    of the content.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的`response`对象代表了来自服务器的整个HTTP响应，包括服务器发送的任何头信息、状态码，甚至是原始请求消息的内容。通常情况下，你只会关心`StatusCode`属性和`Content`属性。`StatusCode`属性实际上是一个枚举类型，它列出了所有有效的HTTP响应状态码，并且用于确定派生的`IsSuccessStatusCode`属性的结果。同时，`Content`属性是`HttpContent`类的一个实例，它包含了一个特定于内容的头信息数组，以及一些用于读取和解析内容主体的实用方法。
- en: 'Since we know that the output of our request will be the JSON representation
    of a list of fitness records, we can use the `JsonConvert` static class to de-serialize
    and return the response content. And with that simple pattern, we can proceed
    to define the rest of our `GET` operations. First, we have the `GetAllRecords()`
    method, which will simply return the list of any records stored in our data source:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道我们的请求输出将是健身记录列表的 JSON 表示，我们可以使用 `JsonConvert` 静态类来反序列化和返回响应内容。有了这个简单的模式，我们可以继续定义我们其余的
    `GET` 操作。首先，我们有 `GetAllRecords()` 方法，它将简单地返回存储在我们数据源中的任何记录列表：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we have our `GetRecordsByWorkoutType()` method, which allows the user
    to filter based on the `workoutType` field of the fitness record:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们拥有我们的 `GetRecordsByWorkoutType()` 方法，它允许用户根据健身记录的 `workoutType` 字段进行筛选：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we''ll implement our `GetRecordByTitle()` method, which allows us
    to search our fitness records by the (presumably) unique `title` assigned to them:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现我们的 `GetRecordByTitle()` 方法，它允许我们通过（假设是）唯一的 `title` 搜索我们的健身记录：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With each of these methods, you'll notice that we're not actually implementing
    any additional filtering logic inside our data service class. Instead, we're relying
    on that work to be done by the server. The abstraction we're introducing is over
    the direct interaction with the server, and not on the logic of filtering the
    records. So, now that we have our `GET` operations in place, we can look at what
    additional steps we need to take to `POST` data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法中的每一个，你会发现我们实际上并没有在我们的数据服务类内部实现任何额外的过滤逻辑。相反，我们依赖于服务器来完成这项工作。我们引入的抽象是关于直接与服务器交互，而不是关于过滤记录的逻辑。因此，现在我们已经设置了
    `GET` 操作，我们可以看看为了 `POST` 数据我们需要采取哪些额外步骤。
- en: Posting request content
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布请求内容
- en: 'Since the main difference between a `GET` request and a `POST` request is the
    content attached to the `POST` request, let''s take a look at how to apply our
    content to our request message. First, we''ll change the method specified when
    we create our `HttpRequestMessage` instance:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `GET` 请求和 `POST` 请求之间的主要区别是附加到 `POST` 请求的内容，让我们看看如何将我们的内容应用到我们的请求消息中。首先，我们将更改创建
    `HttpRequestMessage` 实例时指定的方法：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, we'll need to create our `Content`. The `HttpContent` class is an abstract
    class instantiated by a variety of sub-classes that each implement different valid
    formats for `POST` content. You can define `FormContent` for an `x-www-form-urlencoded`
    request; `MultiPartFormContent` for large messages, file transfer, or binary data
    transmitted in several discrete chunks; `StreamContent` to represent an open and
    active stream connection; and many more. For our purposes, though, since we'll
    be serializing to and from JSON, we'll just define the payload as an instance
    of `StringContent`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建我们的 `Content`。`HttpContent` 类是一个抽象类，由各种子类实例化，每个子类实现了不同的有效 `POST` 内容格式。你可以定义
    `FormContent` 用于 `x-www-form-urlencoded` 请求；`MultiPartFormContent` 用于大型消息、文件传输或以几个离散块传输的二进制数据；`StreamContent`
    用于表示一个打开和活动的流连接；还有更多。然而，对于我们的目的，由于我们将序列化和反序列化 JSON，我们只需将有效载荷定义为 `StringContent`
    的一个实例。
- en: 'When you''re using `StringContent`, there are several override implementations
    that allow you to specify the specific character encoding and the media type for
    the message. This is used by the `HttpClient` class to apply the appropriate content-type
    header to the request, which means that in most cases, you''ll never have to concern
    yourself with that specific value. Since our string will be well-formed JSON,
    the `HttpClient` class will be able to infer our media type from the string alone,
    so applying the `POST` body is a fairly straightforward task:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `StringContent` 时，有几个覆盖实现允许你指定消息的特定字符编码和媒体类型。这被 `HttpClient` 类用来应用适当的 `content-type`
    标头到请求中，这意味着在大多数情况下，你无需担心这个特定值。由于我们的字符串将是格式良好的 JSON，`HttpClient` 类将能够仅从字符串中推断出我们的媒体类型，因此应用
    `POST` 主体是一个相当直接的任务：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With our message body in place, the rest of our code proceeds exactly as it
    did with our `GET` requests, leaving us with a final implementation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的消息体就绪后，我们的代码其余部分与我们的 `GET` 请求完全相同，最终实现如下：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, with this pattern in place, we can complete our implementation by adding
    the code to update and delete records:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了这种模式，我们可以通过添加更新和删除记录的代码来完成我们的实现：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Running this application side by side with the `FitnessDataStore` app, you should
    see all of the expected behavior described in our initial project description.
    Fire them up, bring up your REST client of choice, and start hitting every endpoint.
    Set breakpoints in your code, and see what happens every step of the way. And
    with that, we've covered the essentials of HTTP in .NET Core.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用程序与`FitnessDataStore`应用程序并排运行，你应该会看到我们初始项目描述中描述的所有预期行为。启动它们，打开你选择的REST客户端，并开始对每个端点进行操作。在你的代码中设置断点，并查看每一步发生的情况。就这样，我们已经涵盖了.NET
    Core中HTTP的基本知识。
- en: HTTPS – security over HTTP
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS – 在HTTP之上的安全
- en: While we'll discuss it more in [Chapter 13](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml),
    *Transport Layer Security*, we should take a moment to consider how to establish
    secure connections at the application layer. In the HTTP protocol, security is
    achieved through **Hypertext Transfer Protocol Secure** (**HTTPS**). This provides
    a mechanism for authenticating the source of a remote resource, such as a web
    page or an API response. HTTPS also provides protection of the data in transit
    that is passed between client and server with each request/response interaction.
    This is done by leveraging the **Secure Sockets Layer** (**SSL**) or, more recently,
    the **Transport Layer Security** (**TLS**) on the underlying transport-layer interactions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[第13章](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml)中我们会更详细地讨论，但我们应该花点时间考虑如何在应用层建立安全连接。在HTTP协议中，安全是通过**超文本传输协议安全**（**HTTPS**）实现的。这提供了一种机制来验证远程资源（如网页或API响应）的来源。HTTPS还提供了保护在客户端和服务器之间每个请求/响应交互中传输的数据。这是通过利用底层的**安全套接字层**（**SSL**）或更近期的**传输层安全**（**TLS**）来实现的。
- en: Establishing outbound HTTPS connections
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立出站HTTPS连接
- en: With outbound connections, using HTTPS is as simple as defining the schema in
    your request URL to be of type `https://...`. While this may seem trivial, the
    value in HTTPS connections comes from a trusted and validated server certificate,
    usually signed by a third party, which gives consumers confidence that the site
    they are trying to access is, in fact, the site they intended to access.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于出站连接，使用HTTPS就像在请求URL中定义方案为`https://...`一样简单。虽然这可能看起来微不足道，但HTTPS连接的价值在于一个受信任并经过验证的服务器证书，通常由第三方签署，这给消费者带来了信心，即他们试图访问的网站确实是他们想要访问的网站。
- en: In many cases, you'll want to test out your application on a development server
    using production-ready configurations. Typically, in these scenarios, you won't
    have the requested **Certificate Authority** (**CA**) provide you with a trusted,
    signed SSL certificate for that development server. When that happens, your calling
    code will throw an error warning users that the HTTPS connection couldn't be validated
    with an SSL certificate signed by a trusted CA. This happens because, behind the
    scenes of the `HttpClient` class, there is an `HttpClientHandler` function that
    validates any outbound HTTPS connections before checking for an SSL certificate
    signed by a trusted CA. This means that, in a case where you're connecting to
    a trusted and certified resource over HTTPS, you don't have to do any additional
    work to ensure that security. A successful connection with your `HttpClient` ensures
    that security.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能会想在开发服务器上使用生产就绪的配置来测试你的应用程序。通常，在这些场景中，你不会从请求的**证书颁发机构**（**CA**）那里获得一个受信任的、已签署的SSL证书用于该开发服务器。当这种情况发生时，你的调用代码将抛出一个错误，警告用户HTTPS连接无法通过受信任的CA签发的SSL证书进行验证。这是因为，在`HttpClient`类的幕后，有一个`HttpClientHandler`函数在检查由受信任的CA签发的SSL证书之前，会验证任何出站的HTTPS连接。这意味着，在你通过HTTPS连接到受信任和认证的资源的情况下，你不需要做任何额外的工作来确保安全性。与`HttpClient`的成功连接确保了安全性。
- en: There is a way to override that behavior with a custom server certificate validator,
    which we'll look at in later chapters focusing on security. In general, though,
    if you're getting that error from any remote resource that you don't directly
    control, *listen to it*. It's a fantastic warning system that you get for free
    from .NET Core, and you'd be wise to leverage it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以通过自定义服务器证书验证器来覆盖这种行为，我们将在后续的章节中探讨，这些章节将重点介绍安全性。不过，一般来说，如果你从任何你直接不控制的远程资源收到那个错误，*要重视它*。这是.NET
    Core免费提供给你的一个出色的警告系统，而且明智的做法是利用它。
- en: Supporting HTTPS on your server
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上支持HTTPS
- en: 'This should come as no surprise to any of you, but we''ve already seen exactly
    how we can support HTTPS for incoming HTTP requests being made of our application.
    It''s that tricky little line of code we keep removing:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这点对你们中的任何人都应该不会感到意外，但我们已经看到了如何支持我们的应用程序对传入的HTTP请求使用HTTPS。就是那条我们不断移除的棘手的小代码行：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Provided we have this line of code, and our web server is configured to listen
    over at least an HTTPS URL, our application will support HTTPS. With this value
    set, the web server will respond to all incoming HTTP connection attempts with
    a `302`, which is a redirection status code notifying the client that their request
    should be redirected to the HTTPS URI for processing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有这条代码行，并且我们的Web服务器配置为至少监听一个HTTPS URL，我们的应用程序将支持HTTPS。设置此值后，Web服务器将对所有传入的HTTP连接尝试响应一个`302`状态码，这表示客户端的请求应该被重定向到HTTPS
    URI进行处理。
- en: The reason I've been removing this particular piece of code and using HTTP in
    all of our examples so far is because of what I mentioned in the previous section titled
    *Establishing outbound HTTPS connections.* Trying to connect to a server over
    HTTPS will cause our software (and most REST clients such as Postman or Insomnia)
    to attempt to validate an SSL certificate. However, while we're in development,
    our local machines typically won't have a signed certificate to return with HTTPS
    responses. So, by removing the `UseHttpsRedirection()` method, we simply remove
    that variable from the equation while we're still in development. However, once
    you're ready to deploy your code to a production environment, you'll want to enforce
    HTTPS wherever possible, and I would even go so far as to recommend you configure
    your server to only listen on HTTPS URLs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么一直在移除这块特定的代码，并在我们所有的示例中使用HTTP，是因为我在上一节中提到的内容，标题为*建立出站HTTPS连接*。尝试通过HTTPS连接到服务器将导致我们的软件（以及大多数如Postman或Insomnia之类的REST客户端）尝试验证SSL证书。然而，在我们开发过程中，我们的本地机器通常不会有用于HTTPS响应的签名证书。因此，通过移除`UseHttpsRedirection()`方法，我们只是在开发过程中从等式中移除了这个变量。然而，一旦你准备好将代码部署到生产环境，你将希望尽可能强制执行HTTPS，我甚至会建议你配置服务器以仅监听HTTPS
    URL。
- en: HTTP/2
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2
- en: In 2015, the **Internet Engineering Task Force** (**IETF**) introduced the first
    major revision of the HTTP standard since HTTP 1.1 was codified in 1997\. This
    new protocol, now named HTTP/2, introduces a number of extension features on top
    of the existing HTTP 1.1 protocol definition, while leaving the expected behavior
    of the previous standard almost entirely unchanged.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年，**互联网工程任务组**（**IETF**）推出了自1997年HTTP 1.1被编码以来HTTP标准的第一次重大修订。这个新协议，现在命名为HTTP/2，在现有的HTTP
    1.1协议定义之上引入了多项扩展功能，同时几乎完全保留了先前标准的预期行为。
- en: New features of HTTP/2
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2的新特性
- en: 'Originally developed by Google under the moniker **SPDY** (short for *speedy*),
    HTTP/2 was designed to provide major speed improvements over HTTP 1.1\. Its objectives
    were to reduce latency to improve the performance of web browsers loading content.
    This latency reduction is accomplished by the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最初由谷歌在**SPDY**（即“快速”）的代号下开发，HTTP/2旨在在HTTP 1.1之上提供重大的速度提升。其目标是减少延迟以改善浏览器加载内容时的性能。这种延迟减少是通过以下方式实现的：
- en: '**Header compression:** All transmission headers are compressed with either
    gzip or DEFLATE compression mechanisms by default. The reduced packet size and
    volume for basic protocol/request negotiation has a noticeable impact on high-latency
    network connections, such as cellular networks (thus improving page-load performance
    on mobile devices, such as Google''s Android phones).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部压缩**：默认情况下，所有传输头部都使用gzip或DEFLATE压缩机制进行压缩。基本协议/请求协商的减少的包大小和体积对高延迟网络连接（如蜂窝网络）有显著影响，从而提高了移动设备（如谷歌的Android手机）上的页面加载性能。'
- en: '**Request multiplexing:** Sends multiple queued outbound requests over a single
    active connection. This can prevent bottlenecks of outbound requests for web resources
    on pages with a lot of content, and head-of-line blocking, which occurs when the
    first request in a queue hangs, preventing the processing of subsequent, potentially
    smaller and faster requests, from resolving.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求多路复用**：通过单个活动连接发送多个队列中的出站请求。这可以防止在内容丰富的页面上的Web资源出站请求瓶颈，以及当队列中的第一个请求挂起时发生的头阻塞，这阻止了后续的、可能更小、更快的请求的处理，从而解决问题。'
- en: '**Server push:** This allows a server to send content directly with a client
    over a previously established connection. This is useful if, for instance, you
    know that every request for a web page will be shortly followed by requests for
    additional resources referenced by the web page. Instead of forcing the client
    to initiate an additional HTTP request cycle for those additional resources, the
    server can simply push out the data directly and, if configured properly, the
    client can handle the incoming data without the overhead of processing the full
    HTTP message structure.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器推送：** 这允许服务器通过之前建立的连接直接向客户端发送内容。例如，如果你知道每个网页请求很快就会被网页中引用的额外资源请求所跟随，那么这非常有用。而不是强迫客户端为这些额外资源发起额外的HTTP请求周期，服务器可以简单地直接推送数据，如果配置得当，客户端可以处理传入的数据，而无需处理完整的HTTP消息结构。'
- en: '**Request prioritization:** This enables the developer to determine which requests
    will most likely need to be resolved first and provide priorities to ensure they
    are. Similar to multiplexing, it seeks to reduce the impact of head-of-line blocking,
    but can do so without needing to fully support a multiplexing transport mechanism.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求优先级：** 这使开发者能够确定哪些请求最有可能需要首先解决，并提供优先级以确保它们得到解决。类似于多路复用，它旨在减少首字节阻塞的影响，但无需完全支持多路复用传输机制。'
- en: HTTP/2 in .NET core
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET core中的HTTP/2
- en: Configuring your application to start leveraging these features happens at with
    your `WebHostBuilder`, since the web server negotiates all of the incoming HTTP
    requests and determines support for various protocols. Once that's done, though,
    your clients will begin seeing the benefits of the protocol extensions without
    any additional change in your code to support it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 配置你的应用程序开始利用这些功能是在你的 `WebHostBuilder` 中进行的，因为Web服务器协商所有传入的HTTP请求并确定对各种协议的支持。然而，一旦完成，你的客户端将开始看到协议扩展的好处，而无需对你的代码进行任何额外的更改以支持它。
- en: Unfortunately, at the time of writing, Kestrel doesn't support some features,
    such as server push and stream prioritization. So, while the client can send a
    prioritization tag with its requests, Kestrel simply won't act on that request.
    And one other caveat to HTTP/2 support is that your hosting environment's native
    cryptography library must support **Application Layer Protocol Negotiation** (**ALPN**)
    to establish the secure connection necessary for HTTP/2\. That means HTTP2 is
    supported only for .NET Core apps deployed to either Windows environments or Linux
    hosts with OpenSSL 1.0.2 or higher. Thankfully, though, if your environment doesn't
    support HTTP/2, Kestrel will silently fall back to using standard HTTP 1.1 request
    processing. That means you can configure the protocol and deploy it to any environment
    without worrying about environment specific Kestrel configurations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，Kestrel不支持一些功能，例如服务器推送和流优先级。因此，尽管客户端可以在其请求中发送优先级标签，但Kestrel将不会对此请求采取行动。另一个关于HTTP/2支持的注意事项是，你的托管环境的本地加密库必须支持**应用层协议协商**（**ALPN**）以建立HTTP/2所需的加密连接。这意味着HTTP2仅支持部署到Windows环境或具有OpenSSL
    1.0.2或更高版本的Linux主机的.NET Core应用程序。幸运的是，如果你的环境不支持HTTP/2，Kestrel将默默地回退到使用标准的HTTP
    1.1请求处理。这意味着你可以配置协议并将其部署到任何环境，而无需担心特定环境的Kestrel配置。
- en: 'If you want to support HTTP/2, simply leverage the `ConfigureKestrel()` method
    on your `WebHostBuilder`, like so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要支持HTTP/2，只需在你的 `WebHostBuilder` 上使用 `ConfigureKestrel()` 方法，如下所示：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And just like that, you've got support for multiplexing, header compression,
    and request streaming, out of the box, with no change to your application code.
    And I'll note that further support for HTTP/2 is on the horizon for Kestrel, so
    as the protocol matures (it's only been a standard for about three years at the
    time of writing), expect to see wider adoption, and the improved performance that
    goes with it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你就可以获得多路复用、头部压缩和请求流的支持，无需对应用程序代码进行任何更改。我还将指出，Kestrel对HTTP/2的支持正在路上，随着协议的成熟（在撰写本文时，它只是一个标准大约三年），预计将看到更广泛的应用，以及随之而来的性能提升。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot in this chapter, and for good reason. HTTP is, as I suggest
    in the title of this chapter, integral to programming software being able to function
    on the web. We learned about the distinctions between application-layer protocols
    and transport-layer protocols with a bit more clarity and context. We explored
    the history of HTTP, and saw how its design lent itself for use far beyond its
    original intended purpose.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了大量的内容，这是有充分理由的。HTTP正如我在本章标题中所建议的，对于软件能够在网络上运行是至关重要的。我们更清晰地了解了应用层协议和传输层协议之间的区别。我们探讨了HTTP的历史，并看到了其设计如何使其用途远远超出其原始预期目的。
- en: Once we had that background, we looked at the Web API project template, and
    learned how .NET Core leverages the cross-platform Kestrel web server to expose
    network-aware applications to incoming requests. We looked at how to configure
    our web server using the `WebHostBuilder` extension classes. We learned how to
    configure our application code for use on our web server, in our given hosting
    environment, using the `Startup.cs` class. Then we took the time to set up our
    application to leverage ASP.NET Core's dependency injection framework for our
    service and utility classes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个背景知识之后，我们研究了Web API项目模板，并学习了.NET Core如何利用跨平台的Kestrel网络服务器来暴露对传入请求的网络感知应用程序。我们研究了如何使用`WebHostBuilder`扩展类来配置我们的网络服务器。我们学习了如何使用`Startup.cs`类来配置我们的应用程序代码，以便在给定的托管环境中使用我们的网络服务器。然后我们花时间设置我们的应用程序，以便利用ASP.NET
    Core的依赖注入框架来为我们的服务类和实用工具类提供支持。
- en: With our application wired up and ready to go, we looked at how to expose the
    controller endpoints to listen for each specific HTTP method at specific routes,
    and the various ways we could respond to those requests. Then we looked at how
    to format outbound HTTP messages of our own, including building a content body,
    formatting and applying request headers, and finally sending our requests using
    the `HttpClient`. Finally, we took some time to consider how to allow secure connections
    with HTTPS, and what the future holds with the HTTP/2 specification. With this
    perspective, we're well positioned to explore how some of the other application-layer
    protocols are tuned to their specific use cases in the next chapter, where we'll
    dive into the **File Transfer Protocol** (**FTP**) and the **Simple Mail Transfer
    Protocol** (**SMTP**).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序连接好并准备就绪后，我们探讨了如何将控制器端点暴露出来，以便在特定路由上监听每个特定的HTTP方法，以及我们响应这些请求的各种方式。然后我们研究了如何格式化我们自己的出站HTTP消息，包括构建内容主体、格式化和应用请求头，最后使用`HttpClient`发送我们的请求。最后，我们花了一些时间考虑如何允许使用HTTPS进行安全连接，以及HTTP/2规范的未来前景。有了这个视角，我们很好地定位了在下一章中探索其他应用层协议如何针对其特定用例进行调整，我们将深入探讨**文件传输协议**（**FTP**）和**简单邮件传输协议**（**SMTP**）。
- en: Questions
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the definition of HTTP?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP的定义是什么？
- en: What does SOAP mean? What does REST mean?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOAP是什么意思？REST是什么意思？
- en: What are some of the primary differences between SOAP services and REST services?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOAP服务和REST服务之间有哪些主要区别？
- en: What does MVC stand for, and how does it apply to the Web API project template?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC代表什么，它如何应用于Web API项目模板？
- en: What is Kestrel and how is it used in ASP.NET Core?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kestrel是什么？它在ASP.NET Core中是如何使用的？
- en: What are the various methods of HTTP? Which are safe? Why are they safe?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP有哪些不同的方法？哪些是安全的？为什么它们是安全的？
- en: What does HTTPS stand for? How does it provide security?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTPS代表什么？它是如何提供安全性的？
- en: What new features are supported in HTTP/2? What requirements must be met to
    leverage it?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP/2支持哪些新功能？要利用它必须满足哪些要求？
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about HTTP in .NET Core, or using ASP.NET Core, you have
    a wealth of resources at your disposal. Particularly, I'd recommend *Hands-On
    Full-Stack Web Development with ASP.NET Core*, by Tamir Dresher, Amir Zuker, and
    Shay Friedman, available through Packt Publishing here: [https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core](https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于.NET Core中的HTTP或使用ASP.NET Core的更多信息，您有丰富的资源可供选择。特别是，我推荐Tamir Dresher、Amir
    Zuker和Shay Friedman合著的《Hands-On Full-Stack Web Development with ASP.NET Core》，通过Packt
    Publishing提供：[https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core](https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core)。
- en: If you want to take a deeper dive into the patterns and principles that informed
    the developers of ASP.NET Core, I'd recommend reading *ASP.NET Core 2 Fundamentals*,
    by Onur Gumus and Mugilan T S Ragupathi. It's also available from Packt, and you
    can find it here: [https://www.packtpub.com/web-development/aspnet-core-2-fundamentals](https://www.packtpub.com/web-development/aspnet-core-2-fundamentals).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解启发 ASP.NET Core 开发者的模式和原则，我推荐阅读 Onur Gumus 和 Mugilan T S Ragupathi
    所著的 *ASP.NET Core 2 Fundamentals*。这本书也可以在 Packt 购买，你可以在这里找到它：[https://www.packtpub.com/web-development/aspnet-core-2-fundamentals](https://www.packtpub.com/web-development/aspnet-core-2-fundamentals)。
- en: If you're more interested in the fundamentals of the MVC design pattern, and
    how ASP.NET Core uses it to provide clean architectural templates for web applications,
    check out *ASP.NET Core MVC 2.0 Cookbook*, by Engin Polat and Stephane Belkheraz.
    That book can be found through Packt Publishing here: [https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook](https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更感兴趣于 MVC 设计模式的基础，以及 ASP.NET Core 如何利用它为网络应用提供干净的架构模板，请查看 Engin Polat 和 Stephane
    Belkheraz 所著的 *ASP.NET Core MVC 2.0 Cookbook*。这本书可以通过 Packt 出版公司找到：[https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook](https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook)。
