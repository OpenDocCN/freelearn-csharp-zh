- en: Concealing Complexity with a Facade Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: The Facade pattern is an easy pattern to grasp because its name implies its
    purpose. The primary intent of the Facade pattern is to offer a simplified front-facing
    interface that abstracts the intricate inner workings of a complex system. This
    approach is beneficial for game development because games are composed of complex
    interactions between various systems. As a use case, we will write code that simulates
    the behavior and interactions of a vehicle's engine core components and then offers
    a simple interface to interact with the overall system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Facade pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a bike engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a bike engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic implementation of a vehicle's engine with the Facade pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section includes a simplified version of the implementation of an engine
    for simplicity and brevity reasons. A complete implementation of this code example
    can be found in the `/FPP` folder of the GitHub project—the link is available
    under the *Technical requirements* section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a hands-on chapter, so you will need to have a basic understanding of
    Unity and C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/36wJdxe](https://bit.ly/36wJdxe)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Facade pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Facade pattern''s name is analogous to the facade of a building—as the
    name implies, it''s an exterior face that hides a complex inner structure. Contrary
    to building architecture, in software development, the goal of a facade is not
    to beautify; instead, it is to simplify. As we are going to see in the following
    diagram, an implementation of the Facade pattern is usually limited to a single
    class that acts as a simplified interface to a collection of interacting subsystems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7948ddd6-8d2d-4779-a345-a4a5cccf0d76.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Unified Modeling Language (UML) diagram of the Facade pattern
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding diagram, `EngineFacade` acts as an interface
    to the various components of the engine, thereupon the client is unaware of what
    is happening behind the scenes when calling `StartEngine()` on `EngineFacade`.
    It's unaware of the components that make up the engine and how to reach them;
    it only knows what it needs to know. This is similar to what happens when you
    turn the ignition key in your car—you don't see what's happening under the hood,
    and you don't need to; your only concern is that the engine starts. And so, the
    Facade pattern offers this same level of abstraction in your code, keeping the
    details of the system under the hood.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The Facade pattern is part of the structural pattern category. Patterns in this
    classification are concerned with how classes and objects are composed to form
    larger structures.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some **benefits** of the Facade pattern:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified interface to a complex body of code**: A solid Facade class will
    conceal complexity from a client while providing a simplified interface to interact
    with an intricate system.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy refactoring**: It''s easier to refactor code that''s isolated behind
    a Facade because the system''s interface remains consistent to the client while
    its components are being modified behind the scenes.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some **drawbacks** to watch out for:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**It makes it easier to hide the mess**: Using the Facade pattern to hide messy
    code behind a clean front-facing interface will defeat the pattern''s core benefits
    in the long run, but this pattern does offer a way to mask some code smells until
    you have time to refactor them. However, expecting to have enough time later to
    fix stuff is a trap in itself because we rarely have enough time to refactor things
    correctly.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Too many facades**: Globally accessible manager classes that act as facades
    to core systems are popular among Unity developers; they often implement them
    by combining the Singleton and Facade patterns. Unfortunately, it''s too easy
    to abuse this combination and end up with a code base comprising too many manager
    classes, each dependent on the other to function. As a consequence, debugging,
    refactoring, and unit testing components becomes very difficult.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Facade pattern establishes a new interface, whereas the Adapter pattern
    adapts an old interface. Therefore, when implementing patterns that might look
    and sound similar, it's essential to keep in mind that they're not necessarily
    identical in their purpose.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Designing a bike engine
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not aiming to implement a complete simulation of an actual gas engine
    for a bike; this will take too long and demands an in-depth understanding of the
    physics and mechanics of a real-world engine. But we will aim to simulate, to
    a minimal degree, some standard components of a high-speed vehicle''s motor. So
    first, let''s break down the expected behavior of each part of our engine, as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Cooling system**: The cooling system is responsible for making sure the engine
    is not overheating. When the turbocharger is activated, the cooling system shuts
    down during a turbocharge. This behavior means that if the player overuses the
    turbocharger, this can overheat the engine, and in consequence, the engine will
    stop or explode and the bike will stop moving.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuel pump**: This component is responsible for managing the fuel consumption
    of the bike. It knows the amount of gas remaining and stops the engine if it runs
    out of it.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turbocharger**: If the turbocharger is activated, the vehicle''s top speed
    is increased, but the cooling system shuts down temporarily so that the engine''s
    circuitry can relay power to the charger.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will implement a skeleton class for each of these components
    and establish an engine `Facade` class so that clients can start and stop the
    engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The design intention of having the cooling system shut down when the turbocharger
    is activated is to create a sense of risk versus reward. The player must balance
    the desire to go faster with the potential consequence of overheating the engine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a bike engine
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are going to see, the Facade pattern is straightforward, so we will keep
    the following code example simple and straight to the point. To start, we will
    write the classes for each of the core components that make up the bike''s engine,
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the fuel pump; the purpose of this component is to simulate
    the consumption of fuel so that it knows the amount remaining and shuts down the
    engine when it runs out. Here''s the code you''ll need:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up is the cooling system, which is responsible for preventing the engine
    from overheating but gets deactivated if the turbocharger is activated. The code
    is illustrated in the following snippet:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And finally, the turbocharger, when activated, increases the bike''s top speed,
    but for it to function, it needs to deactivate the cooling system temporarily.
    Here''s the code to accomplish this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have the core components of our engine ready, we need to implement
    a class that will permit a client to interact with them seamlessly. So, we will
    implement a Facade class called `BikeEngine` that will offer an interface for
    a client to start and stop the engine and toggle the turbocharger. But because
    the following code example is so long, we will review it in two parts. Here''s
    the first part:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first part of this class is initialization code and is self-explanatory,
    but the following segment is the important part:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the `EngineFacade` class exposes the available functionality
    that the bike engine offers but, at the same time, conceals the interaction between
    its components. If we want to start the engine, we just need to call the `StartEngine()`
    method. If we didn't have a Facade pattern such as the one we just implemented,
    we would have to initialize each engine component individually and know each of
    their parameters to set and the methods to call. The Facade pattern permits us
    to tuck all the complexity away behind a clean interface.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: But suppose we wished to add another engine component, such as a nitro injector;
    in that case, we would only need to modify the `BikeFacade` class and expose a
    new public method to allow us to trigger the injector.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Testing the engine facade
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can quickly test the code we just implemented by adding the following client
    script to a GameObject in an empty Unity scene:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the client class, we see that it's not aware of the engine's inner workings,
    and this is the effect we want to achieve when using the Facade pattern. The only
    thing the client class knows is that it can start and stop the engine and toggle
    on a turbocharged feature by calling the public methods made available by the `BikeEngine` class.
    To put it another way, just as in real life, we don't need to open the hood to
    start the engine; we turn the ignition key, and the components start working together
    without us knowing how they are interacting with each other.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端类中，我们看到它并不了解引擎的内部工作原理，这就是我们使用外观模式时想要达到的效果。客户端类唯一知道的是，它可以调用由`BikeEngine`类提供的公共方法来启动和停止引擎，以及切换涡轮增压功能。换句话说，就像现实生活中一样，我们不需要打开引擎盖来启动引擎；我们转动点火钥匙，组件就会开始协同工作，而我们不需要知道它们是如何相互作用的。
- en: In the next section, we will review alternative solutions to consider before
    deciding on using the Facade pattern.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾在决定使用外观模式之前需要考虑的备选解决方案。
- en: In a potentially more advanced version of this code example, the engine would
    calculate the current **revolutions per minute** (**RPM**)—also known as the engine's
    speed—and we could connect it to a gear system regulated by a shifter input with
    which the player could control the bike's speed. Thus, we could easily enhance
    the level of realism at any time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例的更高级版本中，引擎将计算当前的每分钟转速（RPM）——也称为引擎速度——并且我们可以将其连接到一个由换挡输入调节的齿轮系统，玩家可以通过这个系统来控制自行车的速度。因此，我们可以在任何时候轻松地提高现实感水平。
- en: Reviewing alternative solutions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查备选解决方案
- en: 'There are several alternatives to keep in mind before considering the Facade
    pattern, depending on what you are actually trying to accomplish. These are listed
    here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑使用外观模式之前，有几个备选方案需要考虑，具体取决于你实际上想要实现什么。这些方案在此列出：
- en: '**Abstract Factory pattern:** If you only want to conceal how subsystem objects
    are initialized from the client code, you should consider using the Abstract Factory
    pattern instead of the Facade pattern.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂模式**：如果你只想从客户端代码中隐藏子系统对象的初始化方式，你应该考虑使用抽象工厂模式而不是外观模式。'
- en: '**Adapter**: If you are intending to write a "wrapper" over existing classes
    with the intent to bridge two incompatible interfaces, then you should consider
    using the Adapter pattern.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：如果你打算编写一个“包装器”来覆盖现有的类，目的是连接两个不兼容的接口，那么你应该考虑使用适配器模式。'
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Even though the Facade pattern is sometimes used to hide messy code, when you
    use it as intended, it can enhance your code base's readability and usability
    by masking underlying complex interactions of subsystems behind a singular front-facing
    interface. Thus, it's a pattern that can be very beneficial for game programming,
    but one to use wisely and with good intent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管外观模式有时被用来隐藏混乱的代码，但当你按照预期使用它时，它可以通过隐藏子系统背后的复杂交互，通过单一的前端界面来增强代码库的可读性和可用性。因此，它对于游戏编程来说是一个非常有益的模式，但需要谨慎且带有良好的意图来使用。
- en: In the upcoming chapter, we will explore a pattern named Service Locator, which
    we will use to manage global dependencies and expose core services.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，我们将探讨一个名为服务定位器（Service Locator）的模式，我们将使用它来管理全局依赖项并公开核心服务。
