- en: '*Chapter 15*: Testing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：测试'
- en: The success of any application depends on how easy it is for users to use it.
    The longevity of any software product depends directly on the quality of the product.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的成功取决于用户使用它的难易程度。任何软件产品的寿命直接取决于产品的质量。
- en: Testing is an important aspect of the **Software Development Life Cycle** (**SDLC**)
    and ensures that a product meets the customer's requirements and the quality requirements.
    Testing is also important, as the cost of fixing bugs increases as we move toward
    the later stages of the SDLC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是**软件开发生命周期**（**SDLC**）的一个重要方面，并确保产品满足客户的要求和质量要求。测试同样重要，因为随着我们进入SDLC的后期阶段，修复错误的成本会增加。
- en: In this chapter, we will learn about the different types of testing and the
    tools that Visual Studio provides for testing, as well as looking at third-party
    tools that we can use to ensure the quality of the products we build in .NET 6.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习不同类型的测试以及Visual Studio为测试提供的工具，以及查看我们可以使用的第三方工具，以确保我们在.NET 6中构建的产品质量。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Types of testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类型
- en: Unit testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Functional testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Understanding the importance of load testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解负载测试的重要性
- en: By the end of this chapter, you will know everything you need to know about
    ensuring the quality of a product.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解确保产品质量所需的一切知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Visual Studio 2022 Community Edition. (Certain sections require
    Enterprise Edition.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要Visual Studio 2022社区版。（某些部分需要企业版。）
- en: 'Along with Visual Studio, you will need JMeter, which can be downloaded from
    here: [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    You will also need a basic understanding of Microsoft .NET.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Visual Studio，您还需要JMeter，可以从这里下载：[https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi)。您还需要对Microsoft
    .NET有基本的了解。
- en: Introducing testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍测试
- en: Software testing is a way to check whether an application is performing according
    to expectations. These expectations could be to do with functionality, responsiveness,
    or the resources that the software consumes while running.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一种检查应用程序是否按预期执行的方法。这些期望可能与功能、响应性或软件在运行时消耗的资源有关。
- en: 'Software testing can be broadly categorized into the following two categories
    based on the way it is performed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据执行方式，软件测试可以大致分为以下两类：
- en: '**Manual testing**: In manual testing, testers execute test cases manually
    by using the application under test and validating the expected outcome. Manual
    testing requires more effort than the alternative.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动测试**：在手动测试中，测试人员通过使用测试的应用程序手动执行测试用例，并验证预期的结果。手动测试比替代方案需要更多的努力。'
- en: '**Automated testing**: Automated testing is performed by special automated
    testing software. This automated software runs on the application under test in
    a specialized environment and validates the expected output. Automated testing
    saves a lot of time and manpower. In some cases, it might take a lot of effort
    to have 100% automation and maintain the automation with considerably less **Return
    on Investment** (**ROI**).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试**：自动化测试由专门的自动化测试软件执行。此自动化软件在测试的应用程序中运行于特定环境中，并验证预期的输出。自动化测试可以节省大量时间和人力。在某些情况下，实现100%的自动化可能需要付出很多努力，并且以相对较低的**投资回报率**（**ROI**）来维护自动化。'
- en: 'In terms of the information known about the internals of the application under
    test (such as the code flow and dependent modules integration), software testing
    can also be broadly categorized in the following ways:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对测试应用程序内部信息（如代码流和依赖模块集成）的了解，软件测试也可以广泛地按以下方式进行分类：
- en: '**Black-box testing**: In black-box testing, the individual responsible for
    testing does not have information about the internals of the system. The focus
    here is on the behavior of the system.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑盒测试**：在黑盒测试中，负责测试的个人没有关于系统内部的信息。这里的重点是系统的行为。'
- en: '**White-box testing**: In white-box testing, the tester has information about
    the internal structure, design, and implementation of the system. The focus of
    white-box testing is testing the alternate paths that exist in the implementation.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白盒测试**：在白盒测试中，测试人员了解系统的内部结构、设计和实现。白盒测试的重点是测试实现中存在的替代路径。'
- en: 'In software testing, we validate different aspects of an application. Software
    testing also has the following variants, based on the aspect of an application
    that it validates and the tools or frameworks it uses:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件测试中，我们验证应用程序的不同方面。软件测试还有以下变体，基于它验证的应用程序方面以及它使用的工具或框架：
- en: '**Unit testing**: Unit testing focuses on the smallest unit of an application.
    Here, we validate individual classes or functions. This is mostly done during
    the development phase.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试关注应用程序的最小单元。在这里，我们验证单个类或函数。这通常在开发阶段完成。'
- en: '**Functional testing**: This is often termed **integration testing**. The main
    objective of this is to ensure that an application is performing as per the requirements.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：这通常被称为**集成测试**。其主要目的是确保应用程序按要求执行。'
- en: '**Regression testing**: A regression test ensures that any recent changes have
    not adversely affected application performance and that the existing functionality
    is not affected by any changes. In regression testing, all or some of the functional
    test cases are executed, depending upon the change introduced in the application.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：回归测试确保任何最近的变化都没有对应用程序性能产生不利影响，并且现有功能没有受到任何变化的影响。在回归测试中，根据应用程序中引入的变化，执行所有或部分功能测试用例。'
- en: '**Smoke test**: A smoke test is done after every deployment to ensure that
    the application is stable and ready for rollout. This is also known as a **Build
    Verification Test** (**BVT**).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烟雾测试**：在每次部署后进行烟雾测试，以确保应用程序稳定且准备就绪。这也被称为**构建验证测试**（**BVT**）。'
- en: '**Load test**: A load test is used to determine the overall effectiveness of
    the system. During a load test, we simulate the projected load on an integrated
    system.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：负载测试用于确定系统的整体有效性。在负载测试期间，我们模拟集成系统上的预期负载。'
- en: '**Stress testing**: In stress tests, we push the system beyond the intended
    capacity or load. This helps us identify the bottlenecks in the system and identify
    the points of failure. Performance testing is the umbrella term used for both
    stress and load testing.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：在压力测试中，我们将系统推到预期容量或负载之外。这有助于我们识别系统中的瓶颈和故障点。性能测试是用于压力测试和负载测试的通用术语。'
- en: '**Security testing**: Security testing is performed to ensure the flawless
    execution of the application. In security testing, we focus on evaluating various
    elements of security aspects such as integrity, confidentiality, and authenticity,
    among others.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全测试**：安全测试是为了确保应用程序的完美执行。在安全测试中，我们专注于评估安全方面的各种元素，如完整性、机密性和真实性等。'
- en: '**Accessibility testing**: Accessibility testing is designed to determine whether
    differently-abled individuals will be able to use an application.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性测试**：可访问性测试旨在确定不同能力的人是否能够使用应用程序。'
- en: Now that we have seen the different types of testing, in the sections ahead,
    we will be covering unit testing, functional testing, and load testing in detail,
    as they are critical to ensuring the stability of an application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了不同类型的测试，在接下来的章节中，我们将详细介绍单元测试、功能测试和负载测试，因为它们对于确保应用程序的稳定性至关重要。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To explore more on security, try security testing with static code analysis
    tools: [https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview](https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview).
    More on accessibility can be found here: [https://accessibilityinsights.io/](https://accessibilityinsights.io/).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解安全方面，请尝试使用静态代码分析工具进行安全测试：[https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview](https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview)。更多关于可访问性的信息可以在这里找到：[https://accessibilityinsights.io/](https://accessibilityinsights.io/)。
- en: Performance tests, accessibility tests, and security tests are the tests that
    we perform to assess the non-functional aspects of the application, such as performance,
    usability, reliability, security, and accessibility.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试、可访问性测试和安全测试是我们执行以评估应用程序非功能性方面的测试，例如性能、可用性、可靠性、安全性和可访问性。
- en: Now, let's see how to perform unit testing for our e-commerce application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为我们电子商务应用程序执行单元测试。
- en: Unit testing
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is a way to test the smallest isolated unit of an application.
    It is an important step in software development that helps isolate a problem early.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试应用程序最小隔离单元的一种方式。它是软件开发中的重要步骤，有助于早期隔离问题。
- en: Unit testing has a direct impact on the quality of the software we build. It
    is always recommended to write a unit test as soon as you write any method. If
    we follow the methodology of **test-driven development** (**TDD**), we write the
    test case first and then proceed to implement the functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对我们构建的软件质量有直接影响。建议在编写任何方法后立即编写单元测试。如果我们遵循**测试驱动开发**（**TDD**）的方法论，我们首先编写测试用例，然后继续实现功能。
- en: In the next section, we will learn about creating unit tests and running them
    from Visual Studio.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在Visual Studio中创建单元测试并运行它们。
- en: Unit testing in Visual Studio
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio中的单元测试
- en: We chose to use Visual Studio as it has powerful tooling to create and manage
    test cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用Visual Studio，因为它具有创建和管理测试用例的强大工具。
- en: With Visual Studio, we can create, debug, and run unit test cases. We can also
    check the code coverage of the tests that are executed. Additionally, it has a
    **Live Unit** test feature, which runs unit test cases while we modify the code
    and shows the results in real time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio，我们可以创建、调试和运行单元测试用例。我们还可以检查已执行的测试的代码覆盖率。此外，它还具有**实时单元测试**功能，在修改代码的同时运行单元测试，并将结果实时显示。
- en: We will explore all these features in the subsequent sections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中探讨所有这些功能。
- en: Creating and running unit tests
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和运行单元测试
- en: Let's go ahead and create a unit test project to perform unit testing on the
    `Packt.ECommerce.Order` project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个单元测试项目，以对`Packt.ECommerce.Order`项目进行单元测试。
- en: 'Perform the following steps to create unit test cases:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建单元测试用例：
- en: 'Add a new project of the `Tests` folder, and name the project `Packt.ECommerce.Order.UnitTest`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tests`文件夹中添加一个新的项目，并将其命名为`Packt.ECommerce.Order.UnitTest`：
- en: '![Figure 15.1 – Visual Studio xUnit test project'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.1 – Visual Studio xUnit测试项目'
- en: '](img/Figure_15.1_B18507.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_15.1_B18507.jpg]'
- en: Figure 15.1 – Visual Studio xUnit test project
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – Visual Studio xUnit测试项目
- en: Add a project reference of `Packt.ECommerce.Order` to the newly created test
    project.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Packt.ECommerce.Order`项目添加到新创建的测试项目中。
- en: Add a new class to the test project and name it `OrdersControllerTest`. We are
    going to add all the test cases related to `OrdersController` in this class.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向测试项目添加一个新类，并将其命名为`OrdersControllerTest`。我们将在这个类中添加所有与`OrdersController`相关的测试用例。
- en: 'Now, let''s add a simple test to test the constructor of the `OrdersController`
    controller. The test we will be performing is to assert the successful creation
    of the `OrderController` controller. Let''s now add the test, as shown in the
    following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个简单的测试来测试`OrdersController`控制器的构造函数。我们将进行的测试是断言成功创建`OrderController`控制器。现在让我们添加测试，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Create_Object_OfType_OrderController` test method is attributed with `Fact`;
    this is required for the `xUnit` framework to discover the test method. Here,
    we are asserting by checking the `null` condition of the object created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Create_Object_OfType_OrderController`测试方法被赋予`Fact`属性；这是`xUnit`框架发现测试方法所必需的。在这里，我们通过检查创建的对象的`null`条件来进行断言。'
- en: Visual Studio provides **Test Explorer** to manage and run tests. Let's open
    it by going to **Test** | **Test Explorer**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio提供**测试资源管理器**来管理和运行测试。让我们通过转到**测试** | **测试资源管理器**来打开它。
- en: Build the solution to see the tests in **Test Explorer**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建解决方案以在**测试资源管理器**中查看测试。
- en: 'In `OrderController_Constructor` test we created by right-clicking on it and
    selecting **Run** from the context menu:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过右键单击并从上下文菜单中选择**运行**创建的`OrderController_Constructor`测试中：
- en: '![Figure 15.2 – Test Run context menu from the Test Explorer window'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.2 – 从测试资源管理器窗口的测试运行上下文菜单'
- en: '](img/Figure_15.2_B18507.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_15.2_B18507.jpg]'
- en: Figure 15.2 – Test Run context menu from the Test Explorer window
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – 从测试资源管理器窗口的测试运行上下文菜单
- en: 'Once the test is executed, we can see the test result in the right pane. From
    the result, we can see that the test was executed and run successfully, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试执行完毕，我们可以在右侧窗格中看到测试结果。从结果中，我们可以看到测试已成功执行，如下所示：
- en: '![Figure 15.3 – Test results from Test Explorer'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.3 – 从测试资源管理器获取的测试结果'
- en: '](img/Figure_15.3_B18507.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_15.3_B18507.jpg]'
- en: Figure 15.3 – Test results from Test Explorer
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 从测试资源管理器获取的测试结果
- en: We have created and executed a simple test in Visual Studio. In the next section,
    we will learn how to mock the dependencies of `OrdersController` to validate the
    functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Visual Studio中创建并执行了一个简单的测试。在下一节中，我们将学习如何模拟`OrdersController`的依赖项以验证功能。
- en: Mocking dependencies with Moq
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Moq模拟依赖项
- en: Often, a method under test calls other external methods or services, which we
    call dependencies. To ensure the functionality of the method under test, we isolate
    the behavior of dependencies by creating mock objects for the dependencies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，被测试的方法会调用其他外部方法或服务，我们称之为依赖项。为了确保被测试方法的函数性，我们通过为依赖项创建模拟对象来隔离依赖项的行为。
- en: In an application, classes may be dependent on other classes; for instance,
    our `OrdersController` class is dependent on `OrderService`. While testing `OrdersController`,
    we should be isolating the behavior of `OrderService`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用程序中，类可能依赖于其他类；例如，我们的`OrdersController`类依赖于`OrderService`。在测试`OrdersController`时，我们应该隔离`OrderService`的行为。
- en: To understand mocking, let's create the unit test for the `GetOrdersAsync` action
    method of `OrdersController`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解模拟，让我们为`OrdersController`的`GetOrdersAsync`操作方法创建单元测试。
- en: 'Let''s have a look at the `GetOrderById` method for which we are writing the
    unit test case:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们正在为其编写单元测试用例的`GetOrderById`方法：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this method, the call is made to `GetOrderByIdAsync` of `orderService` in
    order to fetch the orders based on the `id` instance passed in. The controller
    action will return the order `id` retrieved from `OrderService`; otherwise, the
    `NotFound` action is returned.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，调用`orderService`的`GetOrderByIdAsync`以根据传入的`id`实例获取订单。控制器操作将返回从`OrderService`检索到的订单`id`；否则，返回`NotFound`操作。
- en: 'As we have seen, there are two paths for the code flow:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，代码流有两个路径：
- en: One path is for when the order is present.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条路径是当订单存在时。
- en: The other is for when the order is not present.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一条路径是当订单不存在时。
- en: With a unit test, we should be able to cover both paths. So, now, the question
    that arises is, how do we simulate these two cases?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单元测试，我们应该能够覆盖这两个路径。所以，现在出现的问题是，我们如何模拟这两个情况？
- en: What we want here is to mock the response of `OrderService`. To mock the response
    of `OrderService`, we can leverage the `Moq` library. To leverage Moq, we need
    to add a NuGet reference to the `Moq` package to the `Packt.ECommerce.Order.UnitTest`
    test project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在这里模拟`OrderService`的响应。为了模拟`OrderService`的响应，我们可以利用`Moq`库。为了利用Moq，我们需要将`Moq`包的NuGet引用添加到`Packt.ECommerce.Order.UnitTest`测试项目中。
- en: 'Let''s add the test method in the `OrdersControllerTest` class, as shown in
    the following code, to test `GetOrderById` of `OrdersController` to validate the
    case where the order object is returned by `OrderService`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`OrdersControllerTest`类中添加测试方法，如下所示，以测试`OrdersController`的`GetOrderById`方法，以验证当`OrderService`返回订单对象的情况：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From the code, we can observe the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中，我们可以观察到以下内容：
- en: Since `IOrderService` is injected to `OrderController` via controller injection,
    we can inject a mocked `OrderService` to `OrderController`, which will help us
    to test all the code paths of `OrderController` by altering the mock object behavior.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`IOrderService`通过控制器注入注入到`OrderController`中，我们可以向`OrderController`注入一个模拟的`OrderService`，这将帮助我们通过改变模拟对象的行为来测试`OrderController`的所有代码路径。
- en: We leverage the `Mock` class to create a stub (also known as a mock) for `IOrderService`
    and overwrite the `GetOrderByIdAsync` behavior, as shown in the preceding code.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们利用`Mock`类为`IOrderService`创建一个存根（也称为模拟），并覆盖前面的代码中的`GetOrderByIdAsync`行为。
- en: We create an instance of the `Mock` object for the `IOrderService` interface
    and set up the behavior for `GetOrderByIdAsync` by calling the `Setup` method
    on the `Mock` object.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为`IOrderService`接口创建一个`Mock`对象实例，并通过在`Mock`对象上调用`Setup`方法来设置`GetOrderByIdAsync`的行为。
- en: The `GetOrderByIdAsync` method is mocked such that for any parameter value that
    it receives, the `mock` object will return the object of `OrderDetailsViewModel`
    with `Id` as `1`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetOrderByIdAsync`方法被模拟，使得对于它接收到的任何参数值，`mock`对象将返回具有`Id`为`1`的`OrderDetailsViewModel`对象。'
- en: Since we injected the mocked object into `OrderService` via constructor injection,
    whenever there is a call to any method in `IOrderService`, the call will go to
    the mocked implementation of `IOrderService`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们通过构造函数注入将模拟对象注入到`OrderService`中，因此每当调用`IOrderService`中的任何方法时，调用将转到`IOrderService`的模拟实现。
- en: Finally, we assert the test result by validating the type of result that is
    returned from `OrderController` to `OkObjectResult`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们通过验证从`OrderController`返回到`OkObjectResult`的结果类型来断言测试结果。
- en: 'Now, let''s add a test case to validate the behavior, where we receive the
    `NotFound` result if the order is not present, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个测试用例来验证当订单不存在时接收`NotFound`结果的行为，如下所示：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this test case, we simulated the behavior of the order not being present
    by returning a `null` value from the `OrderService` stub. This will make the `GetOrderById`
    action method of `OrdersController` return `NotFoundResult`, and this is validated
    in the test case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，我们通过从`OrderService`存根返回一个`null`值来模拟订单不存在的行为。这将使`OrdersController`的`GetOrderById`操作方法返回`NotFoundResult`，并在测试用例中进行验证。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `OrderService` class depends on `IHttpClientFactory`, `IOptions`, `Mapper`,
    and `DistributedCacheService`. So, to add a unit test for this, we should be mocking
    them all. You can take a look at the `When_GetOrderByIdAsync_with_ExistingOrder_receive_Order`
    test method in the `OrderServiceTest` test class of the GitHub code samples for
    more details.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderService`类依赖于`IHttpClientFactory`、`IOptions`、`Mapper`和`DistributedCacheService`。因此，为了为这个添加单元测试，我们应该模拟它们所有。您可以在GitHub代码示例的`OrderServiceTest`测试类中的`When_GetOrderByIdAsync_with_ExistingOrder_receive_Order`测试方法中查看更多详细信息。'
- en: 'In this section, we have seen how to leverage the `xUnit` framework to create
    unit tests. There are several other test frameworks available to create unit tests
    in .NET. Two such frameworks worth mentioning here are MSTest and NUnit. Though
    there are a few differences in the way the tests are executed between these frameworks,
    all these frameworks are brilliant and provide features such as mocking and parallel
    execution. Because of its simplicity and extensibility, xUnit has a little advantage
    over competing frameworks. We can also write data-driven tests using `Theory`
    in xUnit, as shown in the following code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何利用`xUnit`框架创建单元测试。还有几个其他测试框架可用于在.NET中创建单元测试。这里值得提到的两个框架是MSTest和NUnit。尽管这些框架在测试执行方式上存在一些差异，但所有这些框架都非常出色，并提供诸如模拟和并行执行等功能。由于其简单性和可扩展性，xUnit相对于竞争框架有一定的优势。我们还可以使用xUnit中的`Theory`编写数据驱动测试，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code snippet, the test method is executed with the test data
    passed through the `InlineData` attribute.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，测试方法通过`InlineData`属性传递的测试数据执行。
- en: 'In unit testing, our aim is to test a specific class by mocking the behavior
    of dependent classes. If we test these classes along with other dependent classes,
    we call that **integration testing**. We write integration tests at various levels:
    at the level of a specific module or assembly, at the microservice level, or the
    entire application level.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，我们的目标是通过对依赖类的行为进行模拟来测试一个特定的类。如果我们与其他依赖类一起测试这些类，我们称之为**集成测试**。我们在各种级别编写集成测试：在特定模块或程序集的级别，在微服务级别，或在整个应用级别。
- en: Now that we have added unit test cases to our e-commerce solution, in the next
    section, we will check the code coverage for these tests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的电子商务解决方案添加了单元测试用例，在下一节中，我们将检查这些测试的代码覆盖率。
- en: Code coverage
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: 'Code coverage is a measure to describe how much of the code is covered by our
    test cases. Visual Studio provides a tool to find the code coverage of unit tests.
    We can run **Test** | **Analyze Code Coverage** for all tests, as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是衡量我们的测试用例覆盖了多少代码的一个指标。Visual Studio提供了一个工具来查找单元测试的代码覆盖率。我们可以运行**测试** |
    **分析代码覆盖率**来对所有测试进行操作，如下所示：
- en: '![Figure 15.4 – The Analyze Code Coverage context option in Text Explorer'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.4 – 文本探索器中的“分析代码覆盖率”上下文选项]'
- en: '](img/Figure_15.4_B18507.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.4_B18507.jpg)'
- en: Figure 15.4 – The Analyze Code Coverage context option in Text Explorer
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 文本探索器中的“分析代码覆盖率”上下文选项
- en: This can also be done from the **Context** menu in **Test Explorer**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以从**测试资源管理器**的**上下文**菜单中完成。
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **Analyze Code Coverage** feature is only available in the Enterprise Edition
    of Visual Studio. If you are using the Community Edition, you can use the Visual
    Studio free extension, [https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage](https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage),
    to view the code coverage results.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析代码覆盖率**功能仅在Visual Studio的企业版中可用。如果您使用的是社区版，您可以使用Visual Studio免费扩展程序，[https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage](https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage)，来查看代码覆盖率结果。'
- en: 'This will run all the test cases and identify any code blocks that are not
    tested. We can see the code coverage results in the following **Code Coverage
    Results** window:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行所有测试用例并识别任何未测试的代码块。我们可以在以下**代码覆盖率结果**窗口中查看代码覆盖率结果：
- en: '![Figure 15.5 – Visual Studio Code Coverage Results window'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.5 – Visual Studio代码覆盖率结果窗口]'
- en: '](img/Figure_15.5_B18507.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.5_B18507](img/Figure_15.5_B18507.jpg)'
- en: Figure 15.5 – Visual Studio Code Coverage Results window
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – Visual Studio Code覆盖率结果窗口
- en: '`GetOrderByIdAsync`, the code coverage for that method is `GetOrdersAsync`
    is **0.00%**, as we did not have any test cases to test it. The code coverage
    gives us a good indication of how effective our unit testing is.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetOrderByIdAsync`，该方法的代码覆盖率是`GetOrdersAsync`为**0.00**%，因为我们没有测试用例来测试它。代码覆盖率为我们提供了关于我们的单元测试有效性的良好指示。'
- en: It is recommended to create unit test cases for all the classes in a solution.
    By adding unit tests to validate all the classes and functionality, a higher percentage
    of code will be covered by unit test cases. With higher code coverage, we will
    be able to catch more errors early in the development while making changes to
    a solution. We should ensure that all the test cases pass before we commit changes.
    In the next chapter, [*Chapter 16*](B18507_16_Epub.xhtml#_idTextAnchor1932), *Deploying
    the Application in Azure*, we will learn how to integrate running test cases with
    Azure DevOps pipelines.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 建议为解决方案中的所有类创建单元测试用例。通过添加单元测试来验证所有类和功能，将会有更高比例的代码被单元测试用例覆盖。随着代码覆盖率的提高，我们将在开发过程中对解决方案进行更改时能够更早地捕获更多错误。我们应该在提交更改之前确保所有测试用例都通过。在下一章，[*第16章*](B18507_16_Epub.xhtml#_idTextAnchor1932)，*在Azure中部署应用程序*，我们将学习如何将运行测试用例与Azure
    DevOps管道集成。
- en: So far, we have tested individual modules or classes by mocking dependencies
    and writing unit test cases. It is also important to test functionality after
    integrating and deploying an entire solution. In the next section, we will learn
    about how to perform functional testing for our e-commerce application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过模拟依赖关系和编写单元测试用例来测试单个模块或类。在集成和部署整个解决方案后测试功能也很重要。在下一节中，我们将学习如何为我们电子商务应用执行功能测试。
- en: Tip
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Visual Studio''s code metrics and code analysis tools are useful to ensure
    the maintainability and readability of the code that we write. You can find details
    on code metrics here: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio的代码指标和代码分析工具对于确保我们编写的代码的可维护性和可读性非常有用。您可以在以下位置找到有关代码指标的信息：[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022)。
- en: 'For code analysis, go here: [https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码分析，请访问此处：[https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview)。
- en: Functional testing
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: In functional testing, we validate the application we have built against the
    functional requirements. Functional testing is performed by providing some input
    and asserting the response or output of the application. While performing functional
    testing, we consider the application as a whole; we are not validating individual
    internal components.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能测试中，我们验证我们构建的应用是否符合功能需求。功能测试通过提供一些输入并断言应用的响应或输出来进行。在进行功能测试时，我们将应用视为一个整体；我们不是验证单个内部组件。
- en: 'Functional testing can be split into three tasks:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试可以分为三个任务：
- en: Identifying the functionalities of the system to be tested
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别待测试系统的功能
- en: Determining the input with the expected output
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定具有预期输出的输入
- en: Executing these tests to assess whether the system is responding according to
    expectations
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行这些测试以评估系统是否按预期响应
- en: The execution of functional tests can be done manually by performing the test
    steps on the application, or we can automate them using tools. The time to market
    for an application can be drastically reduced by automating functional tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试的执行可以通过在应用上执行测试步骤手动进行，或者我们可以使用工具来自动化它们。通过自动化功能测试，可以显著缩短应用的上市时间。
- en: In the next section, we will learn about automating functional test cases.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何自动化功能测试用例。
- en: Automating functional test cases
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化功能测试用例
- en: Executing functional test cases manually is still relevant in application testing.
    However, given the fact of shorter deployment cycles and customers expecting new
    features quickly, manual testing can be prohibitively time-consuming and inefficient
    in terms of identifying bugs early. Using automation, we can gain new efficiencies,
    accelerate the testing process, and improve software quality. There are multiple
    tools and frameworks available to automate functional test cases.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行功能测试用例在应用程序测试中仍然相关。然而，考虑到更短的部署周期和客户对快速获取新功能的期望，手动测试可能会非常耗时且效率低下，尤其是在早期识别缺陷方面。使用自动化，我们可以获得新的效率，加速测试过程，并提高软件质量。有多种工具和框架可用于自动化功能测试用例。
- en: 'In this section, we will learn about the most popular automation framework,
    **Selenium**. Let''s begin:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解最受欢迎的自动化框架 **Selenium**。让我们开始：
- en: To start with, let's create an `MSTest` project and name it `Packt.ECommerce.FunctionalTest`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 `MSTest` 的项目，并将其命名为 `Packt.ECommerce.FunctionalTest`。
- en: To this project, add the `Selenium.WebDriver`, `Selenium.WebDriver.ChromeDriver`,
    and `WebDriverManager` NuGet packages. These packages are required for us to run
    Selenium tests.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此项目添加 `Selenium.WebDriver`、`Selenium.WebDriver.ChromeDriver` 和 `WebDriverManager`
    NuGet 包。这些包是我们运行 Selenium 测试所必需的。
- en: 'Let''s start with a simple test that validates the title of our e-commerce
    application. To do this, create a `HomePageTest` test class and a `When_Application_Launched_Title_Should_be_ECommerce_Packt`
    test method, as we did in the *Unit testing* section, as shown in the following
    code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一项简单的测试开始，以验证我们电子商务应用程序的标题。为此，创建一个名为 `HomePageTest` 的测试类和一个名为 `When_Application_Launched_Title_Should_be_ECommerce_Packt`
    的测试方法，就像我们在 *单元测试* 部分所做的那样，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To execute our functional tests, we should launch a browser and use that browser
    to navigate to the e-commerce application. The `MSTest` framework provides a special
    function to perform the initialization and cleanup operations required for our
    tests. We will be creating a Chrome web driver to perform a functional test.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行我们的功能测试，我们应该启动一个浏览器并使用该浏览器导航到电子商务应用程序。`MSTest` 框架提供了一个特殊函数来执行测试所需的初始化和清理操作。我们将创建一个
    Chrome 网络驱动程序来执行功能测试。
- en: 'Let''s go ahead and add the initialize and cleanup methods, as shown in the
    following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加初始化和清理方法，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding code, the `InitializeDriver` method is attributed with `TestInitialize`
    to notify the framework that this is the test initialization method. In test initialization,
    we are creating `ChromeDriver` and initializing the class variable. After the
    completion of the test case, we should close the browser instance; we do this
    in the `WebDriverCleanup` method by calling the `Quit` method. To notify the test
    framework that it is the cleanup method, it should be attributed as `TestCleanup`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`InitializeDriver` 方法被赋予 `TestInitialize` 属性，以通知框架这是一个测试初始化方法。在测试初始化中，我们创建
    `ChromeDriver` 并初始化类变量。测试用例完成后，我们应该关闭浏览器实例；我们通过在 `WebDriverCleanup` 方法中调用 `Quit`
    方法来完成此操作。为了通知测试框架这是一个清理方法，它应该被赋予 `TestCleanup` 属性。
- en: 'Now, let''s go and add the test case to navigate to the e-commerce application
    and validate the title, as shown in the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加测试用例以导航到电子商务应用程序并验证标题，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Call `GoToUrl` on our Chrome web driver to navigate to the e-commerce application.
    Once navigated, we can validate the title of the page by asserting the `Title`
    property of the web driver.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Chrome 网络驱动程序上调用 `GoToUrl` 以导航到电子商务应用程序。一旦导航成功，我们可以通过断言网络驱动程序的 `Title`
    属性来验证页面标题。
- en: 'Go ahead and run the test case from `When_Application_Launched_Title_Should_be_ECommerce_Pact`
    test case and selecting **Run**. This will open the Chrome browser and navigate
    to the specified e-commerce URL, and then it will assert the title of the page.
    After the execution of the test case, the browser will be closed. We see the results
    in **Test Explorer**, as shown in the following screenshot:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `When_Application_Launched_Title_Should_be_ECommerce_Pact` 测试用例运行测试用例，并选择
    **运行**。这将打开 Chrome 浏览器并导航到指定的电子商务 URL，然后断言页面标题。测试用例执行完毕后，浏览器将被关闭。我们可以在 **测试资源管理器**
    中看到结果，如下面的截图所示：
- en: '![Figure 15.6 – Solution structure after the creation of the test project'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.6 – 创建测试项目后的解决方案结构'
- en: '](img/Figure_15.6_B18507.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.6_B18507.jpg)'
- en: Figure 15.6 – Solution structure after the creation of the test project
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – 创建测试项目后的解决方案结构
- en: Now, we will extend the functional test to validate the search functionality.
    To test this functionality, we should enter text in the search box and click on
    the **Search** button. Then, check the results to see whether the returned test
    results are only for the searched product.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将扩展功能测试以验证搜索功能。为了测试这个功能，我们应该在搜索框中输入文本并点击**搜索**按钮。然后，检查结果以查看返回的测试结果是否仅针对搜索的产品。
- en: 'Let''s automate the test case by adding the `When_Searched_For_Item` test method,
    as shown in the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加`When_Searched_For_Item`测试方法来自动化测试用例，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this test case, after navigating to the home page, enter the search text
    in the `search` string.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，在导航到主页后，在`search`字符串中输入搜索文本。
- en: Selenium makes it so easy to write functional tests. We should try to automate
    all functional test cases, such as user management, adding products to the cart,
    and placing an order. With all the functional test cases automated, we will be
    in a better position to test and validate the functionality of new releases and
    maintain the quality of our application. There are other functional testing tools
    available, such as QTP and Visual Studio Coded UI tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 使得编写功能测试变得非常简单。我们应该尝试自动化所有功能测试用例，例如用户管理、将产品添加到购物车和下订单。当所有功能测试用例都自动化后，我们将处于更好的位置来测试和验证新版本的功能，并保持我们应用程序的质量。还有其他功能测试工具可用，例如
    QTP 和 Visual Studio Coded UI 测试。
- en: We have looked at functional testing, which validates the functionality of an
    application. It is equally important to assess the responsiveness of an application
    to see how it responds to a particular load. In the next section, we will learn
    how we can perform performance testing on our e-commerce application. We can leverage
    automated functional test cases to perform BVT or regression testing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了功能测试，它验证了应用程序的功能。同样重要的是评估应用程序对特定负载的响应能力。在下一节中，我们将学习如何在我们的电子商务应用程序上执行性能测试。我们可以利用自动化的功能测试用例来执行
    BVT 或回归测试。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Refer to the documentation to explore more about Selenium testing: [https://www.selenium.dev/documentation/en/](https://www.selenium.dev/documentation/en/).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅文档以了解更多关于 Selenium 测试的信息：[https://www.selenium.dev/documentation/en/](https://www.selenium.dev/documentation/en/)。
- en: Load testing
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力测试
- en: Users expect an application to respond quickly to their actions. Any sluggishness
    in response will lead to user frustration, and ultimately, we will lose them.
    Even if an application works fine under a normal load, we should know how our
    application behaves when there is a sudden peak in demand and be prepared for
    it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用户期望应用程序能够快速响应用户的操作。任何响应缓慢都会导致用户沮丧，最终我们可能会失去他们。即使应用程序在正常负载下运行良好，我们也应该知道我们的应用程序在需求突然增加时的表现，并为此做好准备。
- en: The main goal of load testing is not to find bugs but to eradicate the performance
    bottlenecks of the application. A load test is done to provide stakeholders with
    information about the speed, scalability, and stability of their application.
    In the next section, we will learn how to perform a load test using JMeter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试的主要目标不是寻找错误，而是消除应用程序的性能瓶颈。进行压力测试是为了向利益相关者提供有关其应用程序速度、可扩展性和稳定性的信息。在下一节中，我们将学习如何使用
    JMeter 进行压力测试。
- en: Load testing with JMeter
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JMeter 进行压力测试
- en: '**JMeter** is an open source testing tool built by the Apache Software Foundation.
    It is one of the most popular tools available to perform load testing. JMeter
    can simulate a heavy load on an application by creating virtual concurrent users
    of a web server.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**JMeter** 是由 Apache 软件基金会构建的开源测试工具。它是用于执行压力测试的最受欢迎的工具之一。JMeter 可以通过创建虚拟并发用户来模拟对应用程序的重负载。'
- en: Let's go ahead and create a JMeter load test for our e-commerce application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的电子商务应用程序的 JMeter 压力测试。
- en: 'To learn how to use JMeter to do a load test, we will be creating a test with
    two home pages and product search pages. Try the following steps to create the
    load test:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 JMeter 进行压力测试，我们将创建一个包含两个主页和产品搜索页面的测试。尝试以下步骤来创建压力测试：
- en: 'Launch Apache JMeter from the download location. We will see the window as
    follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载位置启动 Apache JMeter。我们将看到如下窗口：
- en: '![Figure 15.7 – Apache JMeter'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.7 – Apache JMeter]'
- en: '](img/Figure_15.7_B18507.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_15.7_B18507.jpg]'
- en: Figure 15.7 – Apache JMeter
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 15.7 – Apache JMeter
- en: Add a thread group by right-clicking on **Test Plan** in the left pane and selecting
    **Add** | **Threads (Users)** | **Thread Group**. The thread group defines the
    pool of users that will execute the test case against our application. With it,
    we can configure the number of users simulated, the time to start all the users,
    and the number of times to perform the test.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在左侧面板的**测试计划**上右键单击并选择**添加** | **线程（用户）** | **线程组**，添加一个线程组。线程组定义了将执行测试用例的用户池。有了它，我们可以配置模拟的用户数量、启动所有用户的时长以及执行测试的次数。
- en: 'Let''s name the thread group `Load and Query Products` and set the number of
    users to `30`. Set `5` seconds, as shown in the following screenshot:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们命名线程组为`Load and Query Products`并将用户数量设置为`30`。设置`5`秒，如下截图所示：
- en: '![Figure 15.8 – Adding a thread group in Apache JMeter'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.8 – Adding a thread group in Apache JMeter'
- en: '](img/Image87474.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Image87474.jpg]'
- en: Figure 15.8 – Adding a thread group in Apache JMeter
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 在Apache JMeter中添加线程组
- en: This will simulate a user load of `30` within `5` seconds. Using **Thread Group**,
    we can also control the number of times the test should run.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`5`秒内模拟`30`个用户负载。使用**线程组**，我们还可以控制测试应该运行多少次。
- en: To add the test request, right-click on **Thread Group** and select **Add**
    | **Sampler** | **HTTP Request**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加测试请求，右键单击**线程组**并选择**添加** | **采样器** | **HTTP请求**。
- en: 'Let''s set `https`, `localhost`, and `44365` (the port number of the locally
    running e-commerce portal). Name this test `Home Page`, as shown in the following
    screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置`https`、`localhost`和`44365`（本地运行的电子商务门户的端口号）。将此测试命名为`Home Page`，如下截图所示：
- en: '![Figure 15.9 – Adding the Home Page HTTP request in JMeter'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.9 – Adding the Home Page HTTP request in JMeter'
- en: '](img/Image87486.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Image87486.jpg]'
- en: Figure 15.9 – Adding the Home Page HTTP request in JMeter
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – 在JMeter中添加主页面的HTTP请求
- en: 'Let''s also add one more HTTP request sampler to get the details of a specific
    product. For this request, set the `productId` query parameter as `Cloth.3` and
    `productName` as `Orange%20Shirt`, as shown in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个HTTP请求采样器来获取特定产品的详细信息。对于此请求，将`productId`查询参数设置为`Cloth.3`，将`productName`设置为`Orange%20Shirt`，如下截图所示：
- en: '![Figure 15.10 – Adding the Product Details page HTTP request in JMeter'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.10 – Adding the Product Details page HTTP request in JMeter'
- en: '](img/Figure_15.10_B18507.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_15.10_B18507.jpg]'
- en: Figure 15.10 – Adding the Product Details page HTTP request in JMeter
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – 在JMeter中添加产品详情页面的HTTP请求
- en: Save this test plan by clicking on the `ECommerce`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`ECommerce`保存此测试计划。
- en: To view the results, we should add a listener to this test. Right-click on the
    test group and select **Add** | **Listener** | **View Results in Table**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看结果，我们应该为此测试添加一个监听器。右键单击测试组并选择**添加** | **监听器** | **以表格形式查看结果**。
- en: Once the listener is added, go ahead and run the test by selecting **Run** |
    **Start**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了监听器，就可以通过选择**运行** | **开始**来运行测试。
- en: 'After the test run is complete, you will see the results as shown in the following
    screenshot. This will give us the response time for each request:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试运行完成后，你将看到如下截图所示的结果。这将给我们每个请求的响应时间：
- en: '![Figure 15.11 – Test results table in JMeter'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.11 – Test results table in JMeter'
- en: '](img/Figure_15.11_B18507.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_15.11_B18507.jpg]'
- en: Figure 15.11 – Test results table in JMeter
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 – JMeter中的测试结果表格
- en: There are multiple listeners available in JMeter to view the results, such as
    **Summary report** and **Graph results**, which will give another representation
    of the test results. We can configure different kinds of samplers easily with
    JMeter, as well as configuring requests with different HTTP methods and dynamic
    tests, where requests are dependent on another API's response. Once a test plan
    is in JMeter, we can leverage the JMeter command-line utility to run it from multiple
    data centers to simulate a load across geographies and collate the results.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: JMeter提供了多种监听器来查看结果，例如**摘要报告**和**图形结果**，它们将以另一种方式展示测试结果。我们可以轻松地使用JMeter配置不同类型的采样器，以及配置使用不同HTTP方法和动态测试的请求，其中请求依赖于另一个API的响应。一旦测试计划在JMeter中，我们可以利用JMeter命令行工具从多个数据中心运行它，以模拟地理分布的负载并汇总结果。
- en: The flexibility that JMeter provides, along with its extensive documentation,
    makes it the most-used performance testing tool. JMeter can also be leveraged
    to perform functional testing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: JMeter提供的灵活性，以及其广泛的文档，使其成为最常用的性能测试工具。JMeter还可以用于执行功能测试。
- en: We can use the Azure Load Testing service to generate high-scale load using
    the JMeter test that we created in this section. The infrastructure required to
    execute your JMeter script and load test your application is abstracted by Azure
    Load Testing. Azure Load Testing gathers precise resource data for Azure-based
    applications to assist you in identifying performance bottlenecks across your
    Azure application components.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Azure负载测试服务来生成高负载，使用我们在本节中创建的JMeter测试。Azure负载测试抽象化了执行JMeter脚本和负载测试应用程序所需的基础设施。Azure负载测试收集基于Azure的应用程序的确切资源数据，以帮助您识别Azure应用程序组件中的性能瓶颈。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, Azure Load Testing is in preview. More details
    about load testing can be found in the Azure documentation at [https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing](https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing).
    It is recommended to run a load test with one and a half to two times the anticipated
    load. After running the performance test, it is recommended to use **Application
    Insights** to analyze the server response time of requests, how dependent APIs
    are responding during the load conditions, and more importantly, any failures
    that occur while the test is in progress.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Azure负载测试处于预览阶段。有关负载测试的更多详细信息，请参阅Azure文档中的[https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing](https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing)。建议使用预期负载的一倍半到两倍进行负载测试。在运行性能测试后，建议使用**Application
    Insights**来分析请求的服务器响应时间，API在负载条件下的响应依赖性，以及更重要的是，测试进行过程中发生的任何故障。
- en: Tip
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is recommended to run automated tests using Azure DevOps pipelines. Use
    the documentation to see how to integrate tests with an Azure DevOps pipeline:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用Azure DevOps管道运行自动化测试。使用文档了解如何将测试与Azure DevOps管道集成：
- en: 'Selenium: [https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium：[https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops)
- en: 'JMeter tests: [https://github.com/Azure-Samples/jmeter-aci-terraform](https://github.com/Azure-Samples/jmeter-aci-terraform)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: JMeter测试：[https://github.com/Azure-Samples/jmeter-aci-terraform](https://github.com/Azure-Samples/jmeter-aci-terraform)
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored a very important aspect of software development:
    testing. We have learned about the different kinds of testing and the stages at
    which we should be using them in the SDLC.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了软件开发的一个重要方面：测试。我们学习了不同类型的测试以及我们在SDLC中应该使用它们的阶段。
- en: We learned about the concepts of unit testing and how to focus our testing on
    specific calls by mocking dependencies using the `Moq` framework. We were also
    introduced to the creation of automated functional tests using Selenium to test
    the functionality of our e-commerce application before releasing it to production.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了单元测试的概念以及如何通过使用`Moq`框架模拟依赖项来关注特定的调用进行测试。我们还介绍了使用Selenium创建自动化功能测试，以在将电子商务应用程序发布到生产之前测试其功能。
- en: Toward the end, we learned about JMeter, which is the most-used tool for performing
    load testing. The next chapter will focus on deploying applications in Azure.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了JMeter，这是进行负载测试最常用的工具。下一章将专注于在Azure中部署应用程序。
- en: Questions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: True or false? We should only start to think about testing an application after
    the completion of its development.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正误判断？我们只有在应用程序开发完成后才开始考虑测试。
- en: a. True
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: b**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: Which of the following is a kind of software testing?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项是软件测试的一种类型？
- en: a. Security testing
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: a. 安全测试
- en: b. Functional testing
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: b. 功能测试
- en: c. Accessibility testing
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: c. 可访问性测试
- en: d. All of the above
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: d. 所有上述选项
- en: '**Answer: d**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：d**'
- en: True or false? A higher code coverage percentage for unit tests is desirable
    to achieve a shorter time to market.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正误判断？单元测试的更高代码覆盖率百分比有助于缩短上市时间。
- en: a. True
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: a**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
