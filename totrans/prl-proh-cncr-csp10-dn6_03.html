<html><head></head><body>
<div><div><h1 id="_idParaDest-35"><em class="italic"><a id="_idTextAnchor034"/>Chapter 2</em>: Evolution of Multithreaded Programming in .NET</h1>
<p>As .NET and C# have evolved over the last 20 years, new and innovative approaches to multithreaded programming have been introduced. C# has added new language features to support asynchronous programming, and .NET Framework and .NET Core have added new types to support the languages. The most impactful improvements were introduced with C# 5 and .NET Framework 4.0 when Microsoft added the <code>async</code> and <code>await</code> keywords.</p>
<p>This chapter will introduce concepts and features that will be explored in greater depth in subsequent chapters. These<a id="_idIndexMarker063"/> concepts<a id="_idIndexMarker064"/> include the .NET <code>async</code> and <code>await</code>, concurrent collections, and parallelism. We will start by discovering when and why threading features were added to .NET and C#. Then, we will create some practical examples of how to use the new concepts. Finally, we will wrap up the chapter by discussing when it makes sense to use these new features in your own projects. It is important to select the best tool for every real-world scenario.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>.NET threading through the years</li>
<li>Beyond threading basics</li>
<li>Introduction to parallelism</li>
<li>Introduction to concurrency</li>
<li>Basics of <code>async</code> and <code>await</code></li>
<li>Choosing the right path forward</li>
</ul>
<p>By the end of this chapter, you will have learned how your options have expanded when selecting how to approach concurrency in your .NET applications.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows users:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later.</li>
<li>.NET 6.</li>
<li>To use the WorkingWithTimers project, you will need to install the Visual Studio workload for <strong class="bold">.NET desktop development</strong>.</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02</a>.</p>
<p>Let’s start the chapter with a .NET and C# history lesson.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>.NET threading through the years</h1>
<p>Working with threads in .NET and C# has undergone much evolution since .NET Framework 1.0 and C# 1.0 were introduced in 2002. Most of the concepts discussed in <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, regarding the <code>System.Threading.Thread</code> objects have been available since those early days of .NET. While the <code>Thread</code> object is still available in .NET 6 and can be useful for simple scenarios, there are more elegant and modern solutions that are available today.</p>
<p>This section will highlight when the most impactful parallelism and concurrency features were added. We will begin by skipping ahead 8 years to 2010.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>C# 4 and .NET Framework 4.0</h2>
<p>In 2010, Microsoft<a id="_idIndexMarker065"/> released Visual Studio 2010 alongside C# 4 and .NET Framework 4.0. While some earlier language and framework features <a id="_idIndexMarker066"/>such <a id="_idIndexMarker067"/>as <strong class="bold">generics</strong>, <strong class="bold">lambda expressions</strong>, and <strong class="bold">anonymous methods</strong> would <a id="_idIndexMarker068"/>help facilitate later threading features, these 2010 releases were the most significant for threading since 2002. .NET Framework included the following features that will be explored<a id="_idIndexMarker069"/> in more detail in the subsequent sections and chapters:</p>
<ul>
<li><code>System.Collections.Concurrent</code> namespace to provide safe access to collections of data in multithreaded code.</li>
<li><code>Parallel.For</code> and <code>Parallel.ForEach</code> and for invoking parallel operations with <code>Parallel.Invoke</code>.</li>
<li><code>AsParallel</code>, <code>WithCancellation</code>, and <code>WithDegreeOfParallelism</code>.</li>
</ul>
<p>We will cover these features in the <em class="italic">Introduction to concurrency</em> and <em class="italic">Introduction to parallelism</em> sections. Next, we will learn about the important threading features that were included in .NET and C# two years later.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>C# 5 and 6 and .NET Framework 4.5.x</h2>
<p>In 2012, Microsoft released<a id="_idIndexMarker073"/> what could be <a id="_idIndexMarker074"/>considered the most important feature for modern multithreaded programming with .NET: asynchronous programming with <code>async</code> and <code>await</code>. The <code>async</code> and <code>await</code> keywords were added to C# 5 in the same release when .NET Framework 4.5 added the TPL. The centerpiece of the TPL was the <code>Task</code> class in the new <code>System.Threading.Tasks</code> namespace. </p>
<p>The <code>Task</code> object returns from an <code>async</code> operation, providing a way for developers to check the status of the operation or wait for its completion. The work of an <code>async</code> task is performed on a background thread on the thread pool, rather than in the main thread. We will learn more about thread pools in the <em class="italic">Beyond threading basics</em> section. The basics of the TPL will be discussed in the <em class="italic">Basics of async and await</em> section of this chapter and in more depth in <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<p>Some tooling and language features related to async programming were added in the following years. In 2013, .NET Framework 4.5.1 was released. This release corresponded to the release of Visual Studio 2013, which added async debugging features to the <code>catch</code> and <code>finally</code> blocks of exception handlers.</p>
<p>The next features came in 2017 with Microsoft’s continued shift from .NET Framework to .NET Core.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>C# 7.x and .NET Core 2.0</h2>
<p>The<a id="_idIndexMarker077"/> second major version of .NET Core released by the .NET team included the new <code>ValueTask</code> and <code>ValueTask&lt;TResult&gt;</code> types. A <code>ValueTask</code> type is a structure that wraps a <code>Task</code> or an <code>IValueTaskSource</code> instance and includes some additional fields. It is only available when using C# 7.0 or later. The <code>ValueTask</code> type was added because many async operations, in practice, complete synchronously but still incur the overhead of allocating a <code>Task</code> instance to return to the caller. In these cases, performance can be improved by replacing <code>Task</code> with <code>ValueTask</code>, which does not incur any allocation when completing its work synchronously. To read more about the motivation behind the introduction of <code>ValueTask</code> and when to use it, you can read the following blog post by Stephen Toub of the .NET team: <a href="">https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/</a>. </p>
<p class="callout-heading">Note</p>
<p class="callout">If you are not familiar with Stephen Toub, he is a Partner Software Engineer for Microsoft and works as a developer on the .NET Team. His work on the .NET team was key in bringing <code>async</code>, <code>await</code>, and the TPL to the .NET developer community. You can read some of his other articles on the .NET Parallel Programming blog at <a href="">https://devblogs.microsoft.com/pfxteam/author/toub/</a>. </p>
<p>C# 7.0 also<a id="_idIndexMarker078"/> introduced <code>_</code>) to replace an intentionally unused variable. A <code>Task</code> instance returned by an async call. By using a discard in this scenario, it signals to the compiler explicitly that you want to ignore the returned <code>Task</code> instance. Discards can be used as placeholders for variables in other scenarios, too. Using discards can make the intent of <a id="_idIndexMarker080"/>your code clearer and, in some cases, reduce memory allocation. You can read more about their use on the Microsoft Docs website at <a href="">https://docs.microsoft.com/dotnet/csharp/fundamentals/functional/discards</a>. </p>
<p>Later in 2017, C# 7.1 was released, adding a feature of note for async programming: the ability to declare the <code>Main</code> method of a class as async. This made it possible to await other async methods directly from the <code>Main</code> method.</p>
<p>The next async features of note came along in 2019 with C# 8.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>C# 8 and .NET Core 3.0</h2>
<p>When C# 8 and .NET Core 3.0 <a id="_idIndexMarker081"/>were released in 2019, several languages and .NET features were added to support the new <code>IAsyncEnumerable</code> type to provide a streaming source of asynchronous data.</p>
<p>Let’s examine a code snippet that uses <code>IAsyncEnumerable</code>:</p>
<pre class="source-code">public async IAsyncEnumerable&lt;Order&gt; </pre>
<pre class="source-code">    GetLargeOrdersForCustomerAsync(int custId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await foreach (var order in </pre>
<pre class="source-code">        GetOrdersByCustomerAsync(custId))</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (order.Items.Count &gt; 10) yield return order;</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>In this example, the new <code>await foreach</code> language feature is used to call an async method to get all the orders for a customer. It then uses a <code>yield return</code> operation to return each <code>order</code> object with more than 10 items via the <code>IAsyncEnumerable</code> type as it is processed. We will cover some more real-world scenarios of using <code>IAsyncEnumerable</code> in <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<p>The <a id="_idIndexMarker083"/>other async feature added in C# 8 was the <code>System.IAsyncDisposable</code> interface. When implementing <code>IAsyncDisposable</code>, your class must implement a parameterless <code>DisposeAsync</code> method. If your class consumes managed resources that implement <code>IAsyncDisposable</code>, and they cannot be disposed of in line with an <code>async using</code> block, you should implement <code>IAsyncDisposable</code> and clean up these resources in a protected <code>DisposeAsyncCore</code> method. For a comprehensive example that uses both <code>IDisposable</code> and <code>IAsyncDisposable</code>, you can review the Microsoft Docs example at <a href="">https://docs.microsoft.com/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns</a>. </p>
<p>This brings us to the most recent releases of C# and .NET. Let’s review what’s new for async developers in these 2021 releases.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>C# 10 and .NET 6</h2>
<p>.NET 6 was<a id="_idIndexMarker084"/> released in November 2021 along with C# 10. One of the new features in .NET 6 was the ability of <code>System.Text.Json</code> to serialize and deserialize an <code>IAsyncEnumerable</code> type. Prior to .NET 6, a serialized <code>IAsyncEnumerable</code> type would contain an empty JSON object. This is considered a breaking change in .NET 6, but it is a change for the better. The primary motivation behind the change was to support <code>IAsyncEnumerable&lt;T&gt;</code> responses in the ASP.NET Core MVC controller methods.</p>
<p>The other .NET 6 feature of note for async developers is that the C# project templates in Visual Studio 2021 were modernized to leverage several recent language features, including the <code>async Main</code> method available in C# 7.1 and later. The .NET team blogged about these updated templates when .NET 6 release candidate 2 was released in October 2021: <a href="">https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/#net-sdk-c-project-templates-modernized</a>.</p>
<p>This should give you an idea of when each of the significant threading features was added to C# and .NET, and it sets the stage for the upcoming sections of this chapter, where we will cover some of the basics of parallel programming and concurrency. Let’s begin by looking at some more features of threading, starting with the .NET thread pool.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Beyond threading basics</h1>
<p>Before we introduce parallel programming, concurrency, and async programming with .NET and C#, we have a few more threading concepts to cover. The most important of these is the .NET managed thread pool, which is used by awaited method calls that execute asynchronously in C#.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Managed thread pool</h2>
<p>The <code>ThreadPool</code> class <a id="_idIndexMarker085"/>in the <code>System.Threading</code> namespace has been part of .NET since the beginning. It provides developers with a pool of worker threads that they can leverage to perform tasks in the background. In fact, that is one of the key characteristics of thread pool threads. They are background threads that run at the default priority. When one of these threads completes its task, it is returned to the pool of available threads to await its next task. You can queue as many tasks to the thread pool as the available memory will support, but the number of active threads is limited by the number that the operating system can allocate to your application, based on the processor capacity and other running processes.</p>
<p>If you were to use the <code>ThreadPool</code> class in a .NET 6 application, you would typically do so through the TPL, but let’s explore how it can be used directly with <code>ThreadPool.QueueUserWorkItem</code>. The following code takes the example scenario of <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, but uses a <code>ThreadPool</code> thread to perform the background process:</p>
<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
<pre class="source-code">ThreadPool.QueueUserWorkItem((o) =&gt;</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    for (int i = 0; i &lt; 20; i++)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool isNetworkUp = System.Net.NetworkInformation.</pre>
<pre class="source-code">            NetworkInterface.GetIsNetworkAvailable();</pre>
<pre class="source-code">        Console.WriteLine($"Is network available? Answer: </pre>
<pre class="source-code">            {isNetworkUp}");</pre>
<pre class="source-code">        Thread.Sleep(100);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">});</pre>
<pre class="source-code">for (int i = 0; i &lt; 10; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine("Main thread working...");</pre>
<pre class="source-code">    Task.Delay(500);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">Console.WriteLine("Done");</pre>
<pre class="source-code">Console.ReadKey();</pre>
<p>Here, the<a id="_idIndexMarker086"/> key differences are that there is no need to set <code>IsBackground</code> to <code>true</code>, and you do not call <code>Start()</code>. The process will start either as soon as the item is queued on <code>ThreadPool</code> or when the next <code>ThreadPool</code> becomes available. While you might not explicitly use <code>ThreadPool</code> frequently in your code, it is leveraged by many of the common threading features in .NET. So, it’s important to have some understanding of how it works.</p>
<p>One of the common .NET features that use <code>ThreadPool</code> is timers. </p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Threading and timers</h2>
<p>In this <a id="_idIndexMarker087"/>section, we will examine two timer classes that use <code>ThreadPool</code>, <code>System.Timers.Timer</code> and <code>System.Threading.Timer</code>. Both of these<a id="_idIndexMarker088"/> types are safe to use with managed threading and are available on every platform supported by .NET 6.</p>
<p class="callout-heading">Note</p>
<p class="callout">Some additional timers are only applicable to either web or Windows platform development. This section will focus on the timers that are platform agnostic. To read more about the other timers, you can refer to the documentation on the Microsoft Docs website at <a href="">https://docs.microsoft.com/dotnet/standard/threading/timers</a>. </p>
<h3>System.Timers.Timer</h3>
<p>You are<a id="_idIndexMarker089"/> probably most familiar with the <code>Timer</code> object in the <code>System.Timers</code> namespace. This timer will raise an <code>Elapsed</code> event on a thread <a id="_idIndexMarker090"/>pool thread at the interval specified in the <code>Interval</code> property. The mechanism can be stopped or started by using the Boolean <code>Enabled</code> property. If you need the <code>Elapsed</code> event to only fire once, the <code>AutoReset</code> property can be set to <code>false</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">To follow along with the code in this example, download the code from the <strong class="bold">WorkingWithTimers</strong> project of this chapter’s GitHub repository: <a href="">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02</a>.</p>
<p>This example uses a <code>Timer</code> object to check for new messages and alert a user if any are found: </p>
<ol>
<li>Start by declaring a <code>Timer</code> object and setting it up in an <code>InitializeTimer</code> method:<pre>private System.Timers.Timer? _timer;
private void InitializeTimer()
{
    _timer = new System.Timers.Timer
    {
        Interval = 1000
    };
    _timer.Elapsed += _timer_Elapsed;
}</pre></li>
<li>Next, create<a id="_idIndexMarker091"/> the <code>_timer_Elapsed</code> event handler to <a id="_idIndexMarker092"/>check for messages and update the users:<pre>private void _timer_Elapsed(object? sender, 
    System.Timers.ElapsedEventArgs e)
{
    int messageCount = CheckForNewMessageCount();
    if (messageCount &gt; 0)
    {
        AlertUser(messageCount);
    }
}</pre></li>
<li>After the <code>_timer</code> object has its <code>Enabled</code> property set to <code>true</code>, the <code>Elapsed</code> event will fire every second. In the <code>StartTimer()</code> and <code>StopTimer()</code> methods in the <code>TimerSample</code> class:<pre>public void StartTimer()
{
    if (_timer == null)
    {
        InitializeTimer();
    }
    if (_timer != null &amp;&amp; !_timer.Enabled)
    {
        _timer.Enabled = true;
    }
}
public void StopTimer()
{
    if (_timer != null &amp;&amp; _timer.Enabled)
    {
        _timer.Enabled = false;
    }
}</pre></li>
<li>Run <a id="_idIndexMarker093"/>the <strong class="bold">WorkingWithTimers</strong> project and try using the <strong class="bold">Start Timer</strong> and <strong class="bold">Stop Timer</strong> buttons. </li>
</ol>
<p>You should see <a id="_idIndexMarker094"/>messages in Visual Studio’s debug <strong class="bold">Output</strong> window appearing every second while the timer is enabled.</p>
<p class="callout-heading">Note</p>
<p class="callout">Remember that timer events are firing on a thread pool thread. The code executing in these methods might not have access to<a id="_idIndexMarker095"/> update the UI. These timer examples are part of a <code>InvokeRequired</code> on the form or user control and then updating the UI with the <code>Invoke</code> method, if necessary. More information about how to update a WinForms UI can be found on the Microsoft Docs website at <a href="">https://docs.microsoft.com/dotnet/desktop/winforms/controls/how-to-make-thread-safe-calls</a>. </p>
<p>In your own applications, you would use the <code>AlertUser</code> method to present an alert message to the user or update a notification icon in the UI. Next, let’s try the <code>System.Threading.Timer</code> class.</p>
<h3>System.Threading.Timer</h3>
<p>Now, we will <a id="_idIndexMarker096"/>create <a id="_idIndexMarker097"/>the same example with the <code>System.Threading.Timer</code> class. This <code>Timer</code> class must be initialized a little differently:</p>
<p class="callout-heading">Note</p>
<p class="callout">To follow along with the code in this example, download the code from the <strong class="bold">WorkingWithTimers</strong> project of this chapter’s GitHub repository: <a href="">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02</a>.</p>
<ol>
<li value="1">Start by creating a new <code>InitializeTimer</code> method:<pre>private void InitializeTimer()
{
    var updater = new MessageUpdater();
    _timer = new System.Threading.Timer(
    callback: new TimerCallback(TimerFired),
    state: updater,
    dueTime: 500,
    period: 1000);
}</pre></li>
</ol>
<p>The constructor for the <code>Timer</code> class takes four parameters. The <code>callback</code> parameter is a delegate to invoke on the thread pool when the timer period elapses. The <code>state</code> parameter is an object to pass to the callback delegate. The <code>dueTime</code> parameter tells the timer how long (in milliseconds) to wait before triggering the timer for the first time. Finally, the <code>period</code> parameter specifies the interval (in milliseconds) between each delegate invocation.</p>
<ol>
<li value="2">After <a id="_idIndexMarker098"/>instantiating the timer, it will immediately start. There is <a id="_idIndexMarker099"/>no <code>Enabled</code> property to start or stop this timer. When you are done with it, you should dispose of it with either the <code>Dispose</code> method or the <code>DisposeAsync</code> method. This is happening in our <code>DisposeTimerAsync</code> method:<pre>public void StartTimer()
{
    if (_timer == null)
    {
        InitializeTimer();
    }
}
<strong class="bold">public async Task DisposeTimerAsync()</strong>
<strong class="bold">{</strong>
<strong class="bold">    if (_timer != null)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        await _timer.DisposeAsync();</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>
<li><code>MessageUpdater</code> is a class that is used as the <code>state</code> object provided to the <code>TimerCallback</code> method. It has a single method that handles updates to the message count. The logic to update the user about new messages can be encapsulated by this class. In our case, it will simply update the debug output with the number of new messages:<pre>internal class MessageUpdater
{
    internal void Update(int messageCount)
    {
        Debug.WriteLine($"You have {messageCount} new 
            messages!");
    }
}</pre></li>
<li>The <a id="_idIndexMarker100"/>final piece to examine is the <code>TimerFired</code> callback <a id="_idIndexMarker101"/>method:<pre>private void TimerFired(object? state)
{
    int messageCount = CheckForNewMessageCount();
    if (messageCount &gt; 0 &amp;&amp;
        state is MessageUpdater updater)
    {
        updater.Update(messageCount);
    }
}</pre></li>
</ol>
<p>Similar to the <code>_timer_Elapsed</code> method from the previous example, this method simply checks for new messages and triggers an update. However, this time, the update is performed by the <code>MessageUpdater</code> class, which, in your application, could be abstracted through an <code>IMessageUpdater</code> interface and injected into this class for improved separation of concerns and testability.</p>
<ol>
<li value="5">Try this example by using the <strong class="bold">Start Threading Timer</strong> and <strong class="bold">Stop Threading Timer</strong> buttons in the application. You should see a debug message appearing with new message counts in the <strong class="bold">Output</strong> window, as you did in the previous example.</li>
</ol>
<p>The two<a id="_idIndexMarker102"/> timers <a id="_idIndexMarker103"/>serve similar purposes; however, most of the time, you will want to use <code>System.Threading.Timer</code> to leverage its async nature. However, if you need to frequently stop and start your timer processes, the <code>System.Timers.Timer</code> class is a better choice.</p>
<p>Now that we have covered some additional managed threading concepts to level-set your knowledge, it’s time to shift gears and introduce the concept of parallel programming with C#.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Introduction to parallelism</h1>
<p>While <a id="_idIndexMarker104"/>exploring the history of threading in C# and .NET, we learned that parallelism was introduced to developers in .NET Framework 4.0. In this section, the aspects that will be explored are exposed in the TPL through the <code>System.Threading.Tasks.Parallel</code> class. In addition, we will cover some of the basics of PLINQ through examples. These data parallelism concepts will be covered in greater detail with real-world examples in <a href="B18552_06_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, and <a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>.</p>
<p>At a high level, parallelism is the concept of executing multiple tasks in parallel. These tasks could be related to one another, but this is not a requirement. In fact, related tasks running in parallel run a greater risk of encountering synchronization issues or blocking one another. For example, if your application loads order data from an orders service and user preferences and application state<a id="_idIndexMarker105"/> from an <strong class="bold">Azure blob store</strong>, these two processes can be run in parallel without having to worry about conflicts or data synchronization. On the other hand, if the application is loading order data from two different order services and combining the results in a single collection, you will need a synchronization strategy.</p>
<p>That type of scenario will be discussed, in greater depth, in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>. In this section, we will prepare for those advanced scenarios by learning some uses of the <code>Parallel</code> class. Let’s start with <code>Parallel.Invoke</code>.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Using Parallel.Invoke</h2>
<p><code>Parallel.Invoke</code> is a <a id="_idIndexMarker106"/>method that can execute multiple actions, and they could be executed in parallel. There is no guarantee of the order in which they will execute. Each action will be queued in the thread pool. The <code>Invoke</code> call will return when all the actions have been completed.</p>
<p>In this example, the <code>Parallel.Invoke</code> call will execute four actions: another method in the <code>ParallelInvokeExample</code> class named <code>DoComplexWork</code>, a lambda expression, an <code>Action</code> declared inline, and a <code>delegate</code>. Here is the complete <code>ParallelInvokeExample</code> class:</p>
<pre class="source-code">internal class ParallelInvokeExample</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    internal void DoWorkInParallel()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        Parallel.Invoke(</pre>
<pre class="source-code">            DoComplexWork,</pre>
<pre class="source-code">            () =&gt; {</pre>
<pre class="source-code">                Console.WriteLine($"Hello from lambda </pre>
<pre class="source-code">                expression. Thread id: </pre>
<pre class="source-code">                {Thread.CurrentThread.ManagedThreadId}");</pre>
<pre class="source-code">            },</pre>
<pre class="source-code">            new Action(() =&gt;</pre>
<pre class="source-code">            {</pre>
<pre class="source-code">                Console.WriteLine($"Hello from Action. </pre>
<pre class="source-code">                Thread id: {Thread.CurrentThread</pre>
<pre class="source-code">                .ManagedThreadId}");</pre>
<pre class="source-code">            }),</pre>
<pre class="source-code">            delegate ()</pre>
<pre class="source-code">            {</pre>
<pre class="source-code">                Console.WriteLine($"Hello from delegate. </pre>
<pre class="source-code">                Thread id: {Thread.CurrentThread</pre>
<pre class="source-code">                .ManagedThreadId}");</pre>
<pre class="source-code">            }</pre>
<pre class="source-code">        );</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void DoComplexWork()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        Console.WriteLine($"Hello from DoComplexWork </pre>
<pre class="source-code">        method. Thread id: {Thread.CurrentThread</pre>
<pre class="source-code">       .ManagedThreadId}");</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>Creating a<a id="_idIndexMarker107"/> new instance of <code>ParallelInvokeExample</code> and executing <code>DoWorkInParallel</code> from a console application will produce an output similar to the following, although the order of operations may vary:</p>
<div><div><img alt="Figure 2.1 – Output produced by the DoWorkInParallel method " height="653" src="img/Figure_2.1_B18552.jpg" width="1251"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Output produced by the DoWorkInParallel method</p>
<p>In the next section, we <a id="_idIndexMarker108"/>will learn how to implement a <code>Parallel.ForEach</code> loop and discuss when you might want to leverage it.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Using Parallel.ForEach</h2>
<p><code>Parallel.ForEach</code> is <a id="_idIndexMarker109"/>probably the most used member of the <code>Parallel</code> class in .NET. This is because, in many cases, you can simply take the body of a standard <code>foreach</code> loop and use it inside a <code>Parallel.ForEach</code> loop. However, when introducing any parallelism into a code base, you must be sure that the code being invoked is thread-safe. If the body of a <code>Parallel.ForEach</code> loop modifies any of the collections, you will either need to employ one of the synchronization methods discussed in <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, or use one of .NET’s concurrent collections. We will introduce concurrent collections in the <em class="italic">Introduction to concurrency</em> section.</p>
<p>As an example of using <code>Parallel.ForEach</code>, we will create a method that accepts a list of numbers and checks whether each number is contained in a string representation of the current time:</p>
<pre class="source-code">internal void ExecuteParallelForEach(IList&lt;int&gt; numbers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Parallel.ForEach(numbers, number =&gt;</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool timeContainsNumber = DateTime.Now.</pre>
<pre class="source-code">            ToLongTimeString().Contains(number.ToString());</pre>
<pre class="source-code">        if (timeContainsNumber)</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            Console.WriteLine($"The current time contains </pre>
<pre class="source-code">            number {number}. Thread id: {Thread.</pre>
<pre class="source-code">            CurrentThread.ManagedThreadId}");</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        else</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            Console.WriteLine($"The current time does not </pre>
<pre class="source-code">            contain number {number}. Thread id: </pre>
<pre class="source-code">            {Thread.CurrentThread.ManagedThreadId}");</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">    });</pre>
<pre class="source-code">}</pre>
<p>Here is the<a id="_idIndexMarker110"/> call to <code>ExecuteParallelForEach</code> from the console application’s <code>Main</code> method:</p>
<pre class="source-code">var numbers = new List&lt;int&gt; { 1, 3, 5, 7, 9, 0 };</pre>
<pre class="source-code">var foreachExample = new ParallelForEachExample();</pre>
<pre class="source-code">foreachExample.ExecuteParallelForEach(numbers);</pre>
<p>Execute the program, and examine the console output. You should see that more than one thread was used to process the loop:</p>
<div><div><img alt="Figure 2.2 – Console output from a Parallel.ForEach loop " height="657" src="img/Figure_2.2_B18552.jpg" width="1257"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Console output from a Parallel.ForEach loop</p>
<p>Next, we will <a id="_idIndexMarker111"/>wrap up this section on parallelism in .NET with an introduction to PLINQ.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Basics of Parallel LINQ</h2>
<p>This <a id="_idIndexMarker112"/>section will look at one of the simplest ways to add some parallelism to your code. By adding the <code>AsParallel</code> method to your LINQ query, you can transform it into a PLINQ query, with the operations after <code>AsParallel</code> being executed on the thread pool when necessary. There are many factors to consider when deciding when to use PLINQ. We will discuss those in some depth in <a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>. For this example, we will introduce <code>Where</code> clause that checks whether each given integer is an even number. To help illustrate how PLINQ can impact sequences, <code>Task.Delay</code> is also introduced. Here is the complete <code>ParallelLinqExample</code> class implementation:</p>
<pre class="source-code">internal void ExecuteLinqQuery(IList&lt;int&gt; numbers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var evenNumbers = numbers.Where(n =&gt; n % 2 == 0);</pre>
<pre class="source-code">    OutputNumbers(evenNumbers, "Regular");</pre>
<pre class="source-code">}</pre>
<pre class="source-code">internal void ExecuteParallelLinqQuery(IList&lt;int&gt; numbers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var evenNumbers = numbers.AsParallel().Where(n =&gt; </pre>
<pre class="source-code">        IsEven(n));</pre>
<pre class="source-code">    OutputNumbers(evenNumbers, "Parallel");</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private bool IsEven(int number)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Task.Delay(100);</pre>
<pre class="source-code">    return number % 2 == 0;</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private void OutputNumbers(IEnumerable&lt;int&gt; numbers, string </pre>
<pre class="source-code">    loopType)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var numberString = string.Join(",", numbers);</pre>
<pre class="source-code">    Console.WriteLine($"{loopType} number string: </pre>
<pre class="source-code">        {numberString}");</pre>
<pre class="source-code">}</pre>
<p>In the <code>Main</code> method <a id="_idIndexMarker113"/>of your console application, add some code to pass a list of integers to both the <code>ExecuteLinqQuery</code> and <code>ExecuteParallelLinqQuery</code> methods:</p>
<pre class="source-code">var linqNumbers = new List&lt;int&gt; { 0, 1, 2, 3, 4, 5, 6, 7, </pre>
<pre class="source-code">    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };</pre>
<pre class="source-code">var linqExample = new ParallelLinqExample();</pre>
<pre class="source-code">linqExample.ExecuteLinqQuery(linqNumbers);</pre>
<pre class="source-code">linqExample.ExecuteParallelLinqQuery(linqNumbers);</pre>
<p>Examine<a id="_idIndexMarker114"/> the output, and you should see that the order of the numbers in the PLINQ sequence has changed:</p>
<div><div><img alt="Figure 2.3 – Console output of the LINQ and PLINQ queries " height="570" src="img/Figure_2.3_B18552.jpg" width="1245"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Console output of the LINQ and PLINQ queries</p>
<p>We will explore more aspects of parallelism over several chapters in <em class="italic">Part 2</em>, <em class="italic">Parallel Programming and Concurrency with C#,</em> of this book. Let’s shift gears and learn about some concurrency patterns in C#.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Introduction to concurrency</h1>
<p>So, what is <a id="_idIndexMarker115"/>concurrency and how does it relate to parallelism in the context of C# and .NET? The terms are frequently used interchangeably, and if you think about it, they do have similar meanings. When multiple threads are executing in parallel, they are running concurrently. In this book, we will use the term concurrency when discussing patterns to follow when designing for managed threading. Additionally, we will discuss concurrency in the context of the concurrent collections that were introduced to .NET developers in .NET Framework 4.0. Let’s start by learning about the concurrent collections in the <code>System.Collections.Concurrent</code> namespace.</p>
<p>.NET has several <a id="_idIndexMarker116"/>collections that have been created with thread safety built-in. These collections can all be found in the <code>System.Collections.Concurrent</code> namespace. In this section, we will introduce five of the collections. The remaining three are variations of <code>Partitioner</code>. These will be explored in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, where we will work with each of the collection types through practical examples.</p>
<p class="callout-heading">Note</p>
<p class="callout">While your code does not require the use of locks when using concurrent collections, different techniques for synchronization are being employed inside these collections. Some of them do use locking, while others have retry mechanisms to deal with contention. To read more about how concurrent collections handle contention, check out this Microsoft blog post on the .NET Parallel Programming blog: <a href="">https://devblogs.microsoft.com/pfxteam/faq-are-all-of-the-new-concurrent-collections-lock-free/</a>.</p>
<p>The first collection we will introduce is <code>ConcurrentBag&lt;T&gt;</code>.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>ConcurrentBag&lt;T&gt;</h2>
<p>The <code>ConcurrentBag&lt;T&gt;</code> collection <a id="_idIndexMarker117"/>is a concurrent collection intended to hold a collection of unordered objects. Duplicate values are allowed, as are null values when <code>T</code> is a nullable type. It makes an excellent thread-safe replacement for an array, <code>List&lt;T&gt;</code>, or other <code>IEnumerable&lt;T&gt;</code> instances where the ordering of items is not a requirement.</p>
<p>Internally, <code>ConcurrentBag&lt;T&gt;</code> stores a linked list of items for each thread adding items. As items are taken or peeked at from the collection, priority will be given to the internal list, which had items added by the current thread. Let’s suppose thread 1 adds items A, B, and C and thread 2 adds items D, E, F, and G. If thread 1 calls <code>TryPeek</code> or <code>TryTake</code> four times, <code>ConcurrentBag&lt;T&gt;</code> will get items from the A, B, and C list first before taking items from the linked list containing items from thread 2.</p>
<p>The following list details the properties and methods of <code>ConcurrentBag&lt;T&gt;</code> that you are likely to use<a id="_idIndexMarker118"/> in most implementations:</p>
<ul>
<li><code>Add(T)</code>: This adds an object to the bag.</li>
<li><code>TryPeek(out T)</code>: This tries to fetch a value from the bag with an <code>out</code> parameter but does not remove that item.</li>
<li><code>TryTake(out T)</code>: This attempts to fetch a value from the bag with an <code>out</code> parameter and removes it.</li>
<li><code>Clear()</code>: This clears all of the objects from the bag.</li>
<li><code>Count</code>: This returns the number of objects in the bag.</li>
<li><code>IsEmpty</code>: This returns a <code>bool</code> value indicating whether the bag is empty.</li>
<li><code>ToArray()</code>: This returns an array of objects of type <code>T</code>.</li>
</ul>
<p>The <code>ConcurrentBag&lt;T&gt;</code> collection has two constructors. One constructor takes no parameters and simply creates a new empty bag. The other accepts an <code>IEnumerable&lt;T&gt;</code> type of object to be copied to the new bag.</p>
<p>Next, let’s take a quick look at the <code>ConcurrentQueue&lt;T&gt;</code> collection.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>ConcurrentQueue&lt;T&gt;</h2>
<p>The .NET <code>ConcurrentQueue&lt;T&gt;</code> collection<a id="_idIndexMarker119"/> is similar in implementation to its thread-unsafe counterpart, <code>Queue&lt;T&gt;</code>. As such, it makes a great replacement for <code>Queue&lt;T&gt;</code> when managed threading is introduced to an existing code base. <code>ConcurrentQueue&lt;T&gt;</code> is a strongly typed list of objects that enforces <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) logic, which is the<a id="_idIndexMarker120"/> definition of a <strong class="bold">queue</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="bold">FIFO</strong> logic <a id="_idIndexMarker121"/>is commonly seen in the manufacturing industry and in warehouse management software. When working with perishable goods, it is important to use your oldest raw materials first. Therefore, those pallets of goods that were the first to be put into the warehouse should be the first to be pulled when a pallet of that type is requested by the system.</p>
<p>These are the commonly used members of the <code>ConcurrentQueue&lt;T&gt;</code> type:</p>
<ul>
<li><code>Enqueue(T)</code>: This adds a new object to the queue.</li>
<li><code>TryPeek(out T)</code>: This attempts to get the object at the front of the queue without removing it.</li>
<li><code>TryDequeue(out T)</code>: This tries to get the object at the front of the queue and removes it.</li>
<li><code>Clear()</code>: This clears the queue.</li>
<li><code>Count</code>: This returns the number of objects in the queue.</li>
<li><code>IsEmpty</code>: This returns a <code>bool</code> value indicating whether the queue is empty.</li>
<li><code>ToArray()</code>: This returns the objects in the queue as an array of type <code>T</code>.</li>
</ul>
<p>Similar to<a id="_idIndexMarker122"/> the <code>ConcurrentBag&lt;T&gt;</code> collection, the <code>ConcurrentQueue&lt;T&gt;</code> collection has two constructors: one parameterless and one that takes an <code>Ienumerable&lt;T&gt;</code> type to populate the new queue. Next, let’s introduce a similar collection: <code>ConcurrentStack&lt;T&gt;</code>.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>ConcurrentStack&lt;T&gt;</h2>
<p><code>ConcurrentStack&lt;T&gt;</code> can <a id="_idIndexMarker123"/>be thought of as <code>ConcurrentQueue&lt;T&gt;</code>, but it <a id="_idIndexMarker124"/>uses <code>Push</code> method instead of <code>Enqueue</code>, and removing items uses a <code>TryPop</code> method instead of <code>TryDequeue</code>. Another advantage of the <code>ConcurrentStack&lt;T&gt;</code> collection is that it can add or remove multiple objects in one operation. These range operations are supported by using the <code>PushRange</code> and <code>TryPopRange</code> methods. The range operations take arrays of <code>T</code> as parameters.</p>
<p>C<code>oncurrentStack&lt;T&gt;</code> and <code>ConcurrentQueue&lt;T&gt;</code> in .NET 6 both implement the <code>IReadOnlyCollection&lt;T&gt;</code> interface. This means that once the collection has been created, it is read-only and cannot be reassigned or set to <code>null</code>. You can only add or remove items or use <code>Clear()</code> to empty the collection.</p>
<p>Let’s move on to one of the most powerful concurrent collections, <code>BlockingCollection&lt;T&gt;</code>.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>BlockingCollection&lt;T&gt;</h2>
<p><code>BlockingCollection&lt;T&gt;</code> is a thread-safe collection of objects that implements <a id="_idIndexMarker126"/>several interfaces, including <code>IProducerConsumerCollection&lt;T&gt;</code>. The <code>IProducerConsumerCollection&lt;T&gt;</code> interface provides a set of members intended to support applications that <a id="_idIndexMarker127"/>need to implement the <strong class="bold">producer/consumer pattern</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The producer/consumer pattern is a concurrency design pattern where a set of data is concurrently fed by one or more producer threads. At the same time, there are one or more consumer threads monitoring and fetching the data being produced to consume and process it concurrently. The <code>BlockingCollection&lt;T&gt;</code> collection is the data store in this producer/consumer pattern. You can read more about producer/consumer on Wikipedia at <a href="">https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem</a>. </p>
<p><code>BlockingCollection&lt;T&gt;</code> has several methods and properties that assist in a producer/consumer workflow. You can indicate that the producer process is done adding items to the collection by calling the <code>CompleteAdding</code> method. Once this method is called, no more items can be added to the collection with the <code>Add</code> or <code>TryAdd</code> methods. If you plan to use <code>CompleteAdding</code> in your workflow, it is best to always use <code>TryAdd</code> and check the Boolean result when adding objects to the collection. If the collection has been marked as complete for adding, calling <code>Add</code> will throw <code>InvalidOperationException</code>. Additionally, you can check the <code>IsAddingCompleted</code> property to find out whether <code>CompleteAdding</code> has already been called.</p>
<p>Items are removed from <code>BlockingCollection&lt;T&gt;</code> by a consumer process with the <code>Take</code> or <code>TryTake</code> methods. Again, it is safer to use <code>TryTake</code> to avoid any exceptions when the collection is empty. If <code>CompleteAdding</code> has been called and all objects have been <a id="_idIndexMarker128"/>removed from the collection, the <code>IsCompleted</code> property will return true.</p>
<p>We will walk through a real-world producer/consumer implementation in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a><em class="italic"> .NET</em>. Now, let’s move on to our final concurrent collection in this section, <code>ConcurrentDictionary&lt;T&gt;</code>.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>ConcurrentDictionary&lt;TKey, TValue&gt;</h2>
<p>As you <a id="_idIndexMarker129"/>have probably guessed, <code>ConcurrentDictionary&lt;TKey,</code> <code>TValue&gt;</code> is a great replacement for <code>Dictionary&lt;TKey, TValue&gt;</code> when working with managed threading. Both collections implement the <code>IDictionary&lt;TKey, TValue&gt;</code> interface. The concurrent version of this collection adds the following methods for working with data concurrently:</p>
<ul>
<li><code>TryAdd</code>: This<a id="_idIndexMarker130"/> tries to add a new key/value pair to the dictionary and returns a Boolean value indicating whether the object was successfully added to the dictionary. If the key already exists, the method will return <code>false</code>.</li>
<li><code>TryUpdate</code>: This <a id="_idIndexMarker131"/>operation passes a key along with the existing and new values for the item. It will update the existing item to the new value if it exists in the dictionary with the existing value provided. The Boolean value that is returned indicates whether the object was successfully updated in the dictionary.</li>
<li><code>AddOrUpdate</code>: This <a id="_idIndexMarker132"/>method will add or update an item in the dictionary based on whether the key exists and uses an update delegate to perform any logic based on the current and new values for the item.</li>
<li><code>GetOrAdd</code>: This<a id="_idIndexMarker133"/> method will add an item if the key does not already exist. If it does exist, the existing value is returned.</li>
</ul>
<p>These are the most important and common concurrent collections in .NET to understand. We will cover some examples of each and learn about more of the collections in <code>System.Collections.Concurrent</code> later, but this section should provide a solid base for understanding what is to come.</p>
<p>In the next section, we will introduce the C# <code>async</code> and <code>await</code> keywords that were added to C# 5.0.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Basics of async and await</h1>
<p>When the TPL was introduced in .NET Framework 4.5, C# 5.0 also added language support for task-based asynchronous programming with the <code>async</code> and <code>await</code> keywords. This immediately became the default method of implementing asynchronous workflows in C# and .NET. Now, 10 years later, <code>async</code>/<code>await</code> and the TPL have become an integral part of building robust, scalable .NET applications. You might be wondering why it is so important to adopt async programming in your applications.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Understanding the async keyword</h2>
<p>There are <a id="_idIndexMarker134"/>many reasons for writing async code. If you’re writing server-side code on a web server, using async allows the server to handle additional requests while your code is awaiting a long-running operation. On a client application, freeing the UI thread to perform other operations with async code allows your UI to remain responsive to users. </p>
<p>Another important reason to adopt async programming in .NET is that many third-party and open source libraries are using <code>async</code>/<code>await</code>. Even .NET itself is exposing more APIs as async in every release, especially those involving IO operations: networking, file, and database access.</p>
<p>Let’s try writing your first async method with C#.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Writing an async method</h2>
<p>Creating and <a id="_idIndexMarker135"/>consuming an async method is easy. Let’s try a simple example with a new console application:</p>
<ol>
<li value="1">Create a new console application in Visual Studio and name it <strong class="bold">AsyncConsoleExample</strong>.</li>
<li>Add a class to the project, named <code>NetworkHelper</code>, and add the following methods <a id="_idIndexMarker136"/>to the class:<pre>internal async Task CheckNetworkStatusAsync()
{
    Task t = NetworkCheckInternalAsync();
    for (int i = 0; i &lt; 8; i++)
    {
        Console.WriteLine("Top level method 
           working...");
        await Task.Delay(500);
    }
    await t;
}
private async Task NetworkCheckInternalAsync()
{
    for (int i = 0; i &lt; 10; i++)
    {
        bool isNetworkUp = System.Net.
           NetworkInformation.NetworkInterface
               .GetIsNetworkAvailable();
        Console.WriteLine($"Is network available? 
            Answer: {isNetworkUp}");
        await Task.Delay(100);
    }
}</pre></li>
</ol>
<p>There are a few things to point out in the preceding code. Both methods have an <code>async</code> modifier, indicating that they will be awaiting some work and will run asynchronously. Inside the methods, we are using the <code>await</code> keyword with the calls to <code>Task.Delay</code>. This will ensure that no code after this point will execute until the awaited method has been completed. However, during this time, the active thread can be released to perform other work elsewhere.</p>
<p>Finally, look at <a id="_idIndexMarker137"/>the call to <code>NetworkCheckInternalAsync</code>. Instead of awaiting this call, we are capturing the returned <code>Task</code> instance in a variable named <code>t</code>, and we don’t <code>await</code> it until after the <code>for</code> loop. This means that the <code>for</code> loops in both methods will run concurrently. If we had, instead, awaited <code>NetworkCheckInternalAsync</code>, its <code>for</code> loop would have been completed before the <code>for</code> loop in <code>CheckNetworkStatusAsync</code> could begin.</p>
<ol>
<li value="3">Next, replace the code in <code>Program.cs</code> with the following:<pre>using AsyncConsoleExample;
Console.WriteLine("Hello, async!");
var networkHelper = new NetworkHelper();
await networkHelper.CheckNetworkStatusAsync();
Console.WriteLine("Main method complete.");
Console.ReadKey();</pre></li>
</ol>
<p>We are awaiting the call to <code>CheckNetworkStatusAsync</code>. This is possible because the default <code>Main</code> method in a .NET 6 console application is <code>async</code> by default. If you try to <code>await</code> something in a method that is not marked as <code>async</code>, you will get a compiler error. We will explore some of the options you can use when you must call async methods from existing non-async code in <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<ol>
<li value="4">Finally, run the application and examine the output:</li>
</ol>
<div><div><img alt="Figure 2.4 – Console output for the async sample application " height="628" src="img/Figure_2.4_B18552.jpg" width="1069"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Console output for the async sample application</p>
<p>As expected, capturing <a id="_idIndexMarker138"/>the async method’s result allowed the two loops to run concurrently. Try awaiting the call to <code>NetworkCheckInternalAsync</code> and see how the output changes. You should see that all the output from the private method will appear before the output from the <code>for</code> loop in <code>CheckNetworkStatusAsync</code> begins.</p>
<p>This was a brief introduction to the world of async programming with C#. We’ll be working with it quite a lot throughout the rest of this book. Let’s wrap things up by discussing how to choose which of these options to leverage when building a new project or enhancing an existing application.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Choosing the right path forward</h1>
<p>Now that you <a id="_idIndexMarker139"/>have been introduced to some advanced managed threading concepts, parallel programming, concurrent collections, and the async/await paradigm, let’s discuss how they all fit together in the real world. Choosing the right path forward with multithreaded development in .NET will usually involve more than one of these concepts.</p>
<p>When working with .NET 6, you should usually choose to create <code>async</code> methods in your projects. The reasons discussed in this chapter are compelling. Asynchronous programming keeps both client and server applications responsive, and <code>async</code> is used extensively throughout .NET itself.</p>
<p>Some <a id="_idIndexMarker140"/>of the <code>Parallel</code> class operations can be leveraged when your code needs to process a set of items quickly and the underlying code doing the processing is thread-safe. This is one place where concurrent collections can be introduced. If any parallel or async operations are manipulating shared data, the data should be stored in one of the .NET concurrent collections.</p>
<p>If you are working with existing code, often, the most prudent path is to limit how much multithreaded code is added. Legacy projects such as these are a great place to incrementally add some <code>ThreadPool</code> or <code>Parallel</code> operations and test the results. It is important to test the application functionally and for performance. Performance testing tools for managed threading will be covered in <a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a>.</p>
<p>This preliminary guidance will help you get an idea of where you can boost your applications’ performance with managed threading. We will build on your learning and this guidance throughout the rest of the book. Let’s wrap up and discuss what you have learned in this chapter.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Summary</h1>
<p>In this chapter, we started by looking at a brief history of C#, .NET, and managed threading. We discussed how Microsoft has added features for asynchronous and parallel programming over the last 20 years. Next, we took a tour of parallel programming with .NET, concurrent collections, and asynchronous development with C#. Finally, we examined when you might choose each of these concepts for your own applications and why you will often choose more than one of them. You will be able to take what you learned in this chapter and start thinking about practical applications of managed threading in your day-to-day work.</p>
<p>In the next chapter, we will take what you have learned so far and discuss some of the best practices for the practical application of the concepts.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Questions</h1>
<ol>
<li value="1">Which class in .NET manages the thread pool threads available to your application?</li>
<li>In which version of C# were the <code>async</code> and <code>await</code> keywords introduced?</li>
<li>In which version of .NET was the TPL introduced?</li>
<li>In which version of .NET Core was <code>IAsyncEnumerable</code> introduced?</li>
<li>What type should every <code>async</code> method return?</li>
<li>Which concurrent collection would you choose to replace <code>Dictionary&lt;TKey, TValue&gt;</code> in a multithreaded scenario?</li>
<li>Which concurrent collection is frequently used with the producer/consumer design pattern in .NET?</li>
<li>Which parallel feature in .NET features the <code>AsParallel</code> method?</li>
</ol>
</div>
</div>
</body></html>