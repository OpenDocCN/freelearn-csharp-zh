<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-102"><a id="_idTextAnchor101"/>5</h1>
<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Object-Oriented Refactoring</h1>
<p>In the last chapter, we saw how refactoring can help improve classes and their methods. In this chapter, we’ll explore the bigger picture with creative uses of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) to refactor <a id="_idIndexMarker257"/>a series of classes into more maintainable forms. These tools will help you perform larger and more impactful refactorings and make a bigger difference in improving your code.</p>
<p>We’ll cover the following topics in this chapter:</p>
<ul>
<li>Organizing classes via refactoring</li>
<li>Refactoring and inheritance</li>
<li>Controlling inheritance with abstract</li>
<li>Refactoring for better encapsulation</li>
<li>Improving classes with interfaces and polymorphism</li>
</ul>
<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Technical requirements</h1>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter05/Ch5BeginningCode</code> folder.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Refactoring the flight search system</h1>
<p>This chapter’s <a id="_idIndexMarker258"/>code focuses on a flight scheduling system for Cloudy Skies Airlines.</p>
<p>The flight scheduling system<a id="_idIndexMarker259"/> is a simple one that tracks all active flights through a <code>FlightScheduler</code> class and allows external callers to search for flights of interest. This class in turn tracks flights through a collection of <code>IFlightInfo</code> instances, which may either be a <code>PassengerFlightInfo</code> or a <code>FreightFlightInfo</code> instance, depending on whether the flight carries passenger or freight.</p>
<p>The high-level interactions of these classes can be seen in <em class="italic">Figure 5</em><em class="italic">.1</em>:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling system" src="img/B21324_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling system</p>
<p>The code currently <a id="_idIndexMarker260"/>works and even uses<a id="_idIndexMarker261"/> polymorphism effectively to track a variety of different flights. That being said, there are some opportunities for improvement, as we’ll see. Throughout this chapter, we’ll make targeted improvements while demonstrating the breadth of refactoring possibilities present when using object-oriented programming.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Organizing classes via refactoring</h1>
<p>It’s not <a id="_idIndexMarker262"/>uncommon for solutions to have organizational challenges such as misnamed files or types existing in the wrong file or namespace.</p>
<p>These problems may seem small, but they can make it harder for developers to find the code they’re looking for – particularly when first joining the project.</p>
<p>Let’s look at a few refactorings that help developers navigate code more easily.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Moving classes to individual files</h2>
<p>One common<a id="_idIndexMarker263"/> mistake I’ve seen teams make is putting multiple types inside of the same file. Usually, a file starts with a single class or interface and then a developer decides to add a related type. Instead of putting the new type in a file of its own, the class gets added to the existing file. Once this happens for a few small classes, it tends to snowball after that with developers continuing to add new types to the file as time goes on.</p>
<p class="callout-heading">Types</p>
<p class="callout">If you’re not familiar with the use of the word “type” in the .NET world, a type is a generic term that refers to anything supported by <a id="_idIndexMarker264"/>the <strong class="bold">common type system </strong>(<strong class="bold">CTS</strong>). Essentially, if you can use it to declare a variable, it’s probably a type. Some examples of types include classes, interfaces, structs, enums, and the various record type variants.</p>
<p>The <code>IFlightInfo.cs</code> file from the Flight Scheduling System has a few different types defined in it:</p>
<pre class="source-code">
public interface <strong class="bold">IFlightInfo</strong> {
  // Details omitted....
}
public class <strong class="bold">PassengerFlightInfo</strong> : IFlightInfo {
  // Details omitted...
}
public class <strong class="bold">FreightFlightInfo</strong> : IFlightInfo {
  // Details omitted...
}</pre>
<p>While this <a id="_idIndexMarker265"/>example might not seem so bad, having multiple types in a single file does cause a few problems:</p>
<ol>
<li>New developers who are looking for a specific type have trouble finding which file contains that type without using search features.</li>
<li>Version control systems, such as git, track changes to each file. This can increase confusion when teams must merge code or even determine what changed in any given software release.</li>
</ol>
<p>The fix for this is to move each type to its own dedicated file. This can be done by going to the <strong class="bold">Quick Actions</strong> menu on a type whose name doesn’t match the file name. Next, select the <strong class="bold">Move type to [new file name].cs</strong> option as shown in <em class="italic">Figure 5</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 5.2 – Moving a type to its own file" src="img/B21324_05_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Moving a type to its own file</p>
<p>Selecting this option removes the type from the original file and creates a new file containing only the type you selected.</p>
<p>You’ll need <a id="_idIndexMarker266"/>to repeat this for every type that doesn’t match the name of the file in Visual Studio. One of the extra refactoring tools that ReSharper and Rider provide allows you to perform this refactoring for every type in the file, folder, or solution. This can be particularly handy if you encounter a single file with hundreds of types in it.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Renaming files and classes</h2>
<p>Occasionally, you’ll<a id="_idIndexMarker267"/> find cases where a file and the type that it contains don’t match. This often happens when developers create a new class and then decide to rename it later without using the rename refactoring built into Visual Studio.</p>
<p>The <code>AirportInfo.cs</code> file and its <code>Airport</code> class are an example of this:</p>
<pre class="source-code">
namespace Packt.CloudySkiesAir.Chapter5.AirTravel;
public class <strong class="bold">Airport</strong> {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
}</pre>
<p>Usually, the fix for this is to rename the file to match the name of the type (though occasionally you’ll determine the file was named correctly) and the class should be renamed to match the name of the file.</p>
<p>With either option, open the <strong class="bold">Quick Actions</strong> menu on the type in question and select either <strong class="bold">Rename file</strong> or <strong class="bold">Rename type</strong> to ensure the file and type name match. See the following figure:</p>
<div><div><img alt="Figure 5.3 – Options to rename the file or rename the type" src="img/B21324_05_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Options to rename the file or rename the type</p>
<p>I chose to<a id="_idIndexMarker268"/> rename the file to <code>Airport.cs</code>, as either option will ensure that the file and type have the same name. This naming consistency is a small improvement, but it helps developers navigate your project more easily over time.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>Changing namespaces</h2>
<p>.NET uses <strong class="bold">namespaces</strong> to <a id="_idIndexMarker269"/>organize<a id="_idIndexMarker270"/> types into a hierarchical structure. By convention, these namespaces should match the folders inside the project in <strong class="bold">Solution Explorer</strong>.</p>
<p>The project will start with a namespace such as <code>Packt.CloudySkiesAir.Chapter5</code>, and each folder nested inside of a project adds to this namespace. For example, a <code>Filters</code> folder in that project should use a <code>Packt.CloudySkiesAir.Chapter5.Filters</code> namespace.</p>
<p>When classes don’t use the expected namespace, it can lead to confusion.</p>
<p>As a practical example, let’s look at the <code>Airport.cs</code> file in the root of the <code>Chapter5</code> project as shown in <em class="italic">Figure 5</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 5.4 – A project with the Airport class directly nested inside of the project" src="img/B21324_05_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – A project with the Airport class directly nested inside of the project</p>
<p>In this scenario, you would expect the <code>Airport</code> class to live in the <code>Packt.CloudySkiesAir.Chapter5</code> namespace. However, the file uses a different <a id="_idIndexMarker271"/>namespace, as shown in the following code:</p>
<pre class="source-code">
<strong class="bold">namespace Packt.CloudySkiesAir.Chapter5.AirTravel;</strong>
public class Airport {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
}</pre>
<p>This discrepancy can be fixed through manual editing of the namespace declaration or by using the <strong class="bold">Change namespace to match folder structure</strong> under <strong class="bold">Quick Action</strong> refactoring, as shown in <em class="italic">Figure 5</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 5.5 – Changing the namespace to match the folder structure" src="img/B21324_05_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Changing the namespace to match the folder structure</p>
<p>I personally recommend using the <code>using</code> statements to other files as needed to support the namespace change.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Avoiding partial classes and regions</h2>
<p>Before we <a id="_idIndexMarker273"/>move on to refactoring and inheritance, I want to cover two related <strong class="bold">anti-patterns</strong> I’ve seen<a id="_idIndexMarker274"/> in C# code when dealing with large classes.</p>
<p>When developers have large classes with many different blocks of related code, there’s a temptation to use several language features to make organizing the file easier.</p>
<p>Many developers use the <code>#region</code> preprocessor directive to create regions of code that can expand and collapse.</p>
<p>For example, you could use a statement such as <code>#region Stuff I don't want to look at right now</code> with a matching <code>#endregion</code> statement on its own line. This would create a collapsible region of code in the editor, as the collapsed region from lines 33–84 in <em class="italic">Figure </em><em class="italic">5</em><em class="italic">.6</em> illustrates:</p>
<div><div><img alt="Figure 5.6 – A collapsed region of code" src="img/B21324_05_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – A collapsed region of code</p>
<p><code>#region</code> is viewed as a bad thing to rely on for code organization; it leads to extremely large classes instead of refactoring code into more maintainable patterns.</p>
<p>So, why does it exist at all?</p>
<p>The <code>#region</code> directive was introduced to help hide auto-generated code commonly built into older versions of .NET applications. This is code that developers were not expected to work with and often encouraged not to modify for fear of breaking things.</p>
<p>Eventually, .NET got <strong class="bold">partial classes</strong> to<a id="_idIndexMarker275"/> help in scenarios that regions were previously used in.</p>
<p>Partial classes are <a id="_idIndexMarker276"/>classes that are defined in <em class="italic">multiple files</em> within the <em class="italic">same project</em>. This will allow you to have <code>FlightScheduler.ItemManagement.cs</code> and <code>FlightScheduler.Search.cs</code> files that each contain parts of the larger class. This lets you define a large class over multiple files:</p>
<pre class="source-code">
public <strong class="bold">partial</strong> class FlightScheduler {
  // Details omitted...
}</pre>
<p>Like region directives, partial classes are intended to support automatically generated code. While I personally prefer partial classes to <code>#region</code> directives, I view both as anti-patterns when they are applied to reducing pains caused by large classes.</p>
<p>Usually, when your classes are big enough for you to want to consider <code>#region</code> or partial classes, you are violating the single responsibility principle and your class should be broken up into <a id="_idIndexMarker277"/>multiple smaller classes that are distinctly different from one another.</p>
<p>We’ll discuss the single responsibility principle and other design principles in <a href="B21324_08.xhtml#_idTextAnchor173"><em class="italic">Chapter 8</em></a>, <em class="italic">Avoiding Code Anti-patterns </em><em class="italic">with SOLID</em>.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>Refactoring and inheritance</h1>
<p>Now that we’ve covered some of the ways refactoring can help organize your code, let’s dive into refactorings related to inheritance. This is a collection of refactorings that involve either overriding methods, introducing inheritance, or altering in-place inheritance relationships to improve the maintainability of code.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Overriding ToString</h2>
<p><code>ToString</code> is one <a id="_idIndexMarker278"/>of the four methods that any .NET object is guaranteed to have due to the <code>virtual</code> definition of <code>ToString</code> on <code>System.Object</code>. This method is used whenever an object is converted to a string and can be particularly handy for logging and debugging purposes.</p>
<p>Sometimes overriding <code>ToString</code> can simplify your code in unexpected ways.</p>
<p>Let’s look at the <code>BuildFlightIdentifier</code> method in <code>FreightFlightInfo.cs</code>. This method relies on the <code>DepartureLocation</code> and <code>ArrivalLocation</code> properties of type <code>Airport</code> to produce a string:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FreightFlightInfo.cs</p>
<pre class="source-code">
public string BuildFlightIdentifier() =&gt;
  $"{Id} {<strong class="bold">DepartureLocation.Code</strong>}-" +
  $"{<strong class="bold">ArrivalLocation.Code}</strong> carrying " +
  $"{Cargo} for {CharterCompany}";</pre>
<p>It’s annoying to have to drill into these location properties to reach their <code>Code</code> property.</p>
<p>If <code>Airport</code> overrides the <code>ToString</code> method and returns the airport code, we would be able to simplify the readability of our code:</p>
<pre class="source-code">
public string BuildFlightIdentifier() =&gt;
  $"{Id} {<strong class="bold">DepartureLocation</strong>}-{<strong class="bold">ArrivalLocation</strong>} " +
  $"carrying {Cargo} for {CharterCompany}";</pre>
<p>To do this, you can either go to <code>Airport.cs</code> and add the override manually or use the built-in refactoring option through the <strong class="bold">Generate overrides...</strong> refactoring (see <em class="italic">Figure 5</em><em class="italic">.7</em>):</p>
<div><div><img alt="Figure 5.7 – Generating overrides on a class" src="img/B21324_05_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Generating overrides on a class</p>
<p>From there, you’ll <a id="_idIndexMarker279"/>need to specify which methods or properties you want to override. As shown in the following image, any abstract or virtual member of a class you’re inheriting from will be available:</p>
<div><div><img alt="Figure 5.8 – Selecting the members to override" src="img/B21324_05_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Selecting the members to override</p>
<p>Selecting <code>ToString()</code> and clicking <strong class="bold">OK</strong> generates a stubbed-out method that can be quickly replaced with an actual implementation.</p>
<p>In this class, the <code>ToString</code> method should return the airport code:</p>
<pre class="source-code">
public class Airport {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
  <strong class="bold">public override string? ToString() =&gt; Code;</strong>
}</pre>
<p>With this<a id="_idIndexMarker280"/> override in place, existing code can still use the <code>Code</code> property without issues. However, any code that previously tried to write an <code>Airport</code> object to the console now will see its code instead of the namespace and name of the class.</p>
<p class="callout-heading">Note</p>
<p class="callout">The default implementation of <code>ToString</code> in .NET is to return a string with the namespace and the name of the type. In this case that would have been <code>Packt.CloudySkiesAir.Chapter5.AirTravel.Airport</code>.</p>
<p>Next, we should look at everywhere the <code>Code</code> property is currently being read from and see if it would be more readable to rely on the <code>ToString</code> override instead.</p>
<p>You can do this in any edition of Visual Studio 2022 by right-clicking on the <code>Code</code> property declaration and choosing <strong class="bold">Find All References</strong>, as shown in <em class="italic">Figure 5</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 5.9 – The Find All References context menu option" src="img/B21324_05_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The Find All References context menu option</p>
<p>This opens a new pane with all references of that property highlighted:</p>
<div><div><img alt="Figure 5.10 – Find All References results" src="img/B21324_05_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Find All References results</p>
<p>You can then <a id="_idIndexMarker281"/>modify these areas to use <code>ToString</code> where appropriate, such as in this modification to <code>PassengerFlightInfo</code>:</p>
<pre class="source-code">
public string BuildFlightIdentifier() =&gt;
  $"{Id} {<strong class="bold">DepartureLocation</strong>}-{<strong class="bold">ArrivalLocation</strong>} " +
  $"carrying {_passengers} people";</pre>
<p>One added benefit of overriding <code>ToString</code> in your objects is an improved display of the class when viewing the Visual Studio debugger:</p>
<div><div><img alt="Figure 5.11 – ToString override displaying in debugging tools" src="img/B21324_05_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – ToString override displaying in debugging tools</p>
<p>We’ll explore debugging more in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a><em class="italic">: Defensive </em><em class="italic">Coding Techniques</em>.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Generating equality methods</h2>
<p>In C#, equality<a id="_idIndexMarker282"/> for reference types (such as classes) is done<a id="_idIndexMarker283"/> using <strong class="bold">reference equality</strong> –determining whether the two objects are located at the same location in <a id="_idIndexMarker284"/>the <strong class="bold">heap</strong>.</p>
<p>Sometimes it’s more convenient to compare different properties on two objects to see if their values are equivalent, even if the two objects represent two separate locations on the heap.</p>
<p>The following code from the <code>FlightScheduler</code> class shows how its <code>Search</code> method checks to make sure the airport you’re searching for has the same airport code and country. Note the repeated logic when determining if two airports are equivalent:</p>
<pre class="source-code">
if (depart != null) {
  results = results.Where(f =&gt;
<strong class="bold">    f.DepartureLocation.Code == depart.Code &amp;&amp;</strong>
<strong class="bold">    f.DepartureLocation.Country == depart.Country</strong>
  );
}
if (arrive != null) {
  results = results.Where(f =&gt;
<strong class="bold">    f.ArrivalLocation.Code == arrive.Code &amp;&amp;</strong>
<strong class="bold">    f.ArrivalLocation.Country == arrive.Country</strong>
  );
}</pre>
<p>This code could be simplified by overriding equality members with our own customized implementation.</p>
<p class="callout-heading">Equality members</p>
<p class="callout">.NET provides two methods to determine equality: <code>Equals</code> and <code>GetHashCode</code>. The <code>Equals</code> method determines whether two objects are equivalent while <code>GetHashCode</code> is used to determine which major “bucket” an object is sorted into<a id="_idIndexMarker285"/> for <code>Dictionary</code> and <code>HashSet</code>.</p>
<p class="callout">You should never override only one of these two methods; whenever you override <code>Equals</code>, you will need to override <code>GetHashCode</code> as well. Furthermore, you want to make sure you use a good implementation of <code>GetHashCode</code> that evenly and consistently distributes objects in your class into different hash values.</p>
<p class="callout">.NET also provides an <code>IEquatable&lt;T&gt;</code> interface that you can implement for strongly typed equality comparisons, which can improve performance. Implementing <code>IEquatable&lt;T&gt;</code> is generally recommended when overriding equality members but is not detailed in this book. See the <em class="italic">Further reading</em> section for more information.</p>
<p>Equality and<a id="_idIndexMarker286"/> hash codes can get complex very quickly, but thankfully we have some very good tooling for generating equality members in Visual Studio. Just select your class and then choose <strong class="bold">Generate Equals and GetHashCode…</strong> from the <strong class="bold">Quick Actions</strong> menu, as shown in <em class="italic">Figure 5</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 5.12 – Generating equality member overrides" src="img/B21324_05_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Generating equality member overrides</p>
<p>Once you select this, Visual Studio will ask you what members should contribute to equality and hash code checks, as shown in <em class="italic">Figure 5</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 5.13 – Selecting equality members" src="img/B21324_05_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – Selecting equality members</p>
<p>Select the <a id="_idIndexMarker287"/>members that <em class="italic">must</em> be equal and click <strong class="bold">OK</strong> to generate your overrides:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Airport.cs</p>
<pre class="source-code">
public class Airport {
  public string Country { get; set; }
  public string Code { get; set; }
  public string Name { get; set; }
<strong class="bold">  public override bool Equals(object? obj) {</strong>
<strong class="bold">    return obj is Airport airport &amp;&amp;</strong>
<strong class="bold">           Country == airport.Country &amp;&amp;</strong>
<strong class="bold">           Code == airport.Code;</strong>
<strong class="bold">  </strong><strong class="bold">}</strong>
<strong class="bold">  public override int GetHashCode() {</strong>
<strong class="bold">    return HashCode.Combine(Country, Code);</strong>
<strong class="bold">  }</strong>
  public override string? ToString() =&gt; Code;
}</pre>
<p>Here, Visual Studio<a id="_idIndexMarker288"/> generated a pattern matching the <code>Equals</code> implementation that compares the relevant properties. Additionally, the <code>GetHashCode</code> implementation uses the newer <code>HashCode.Combine</code> method to safely simplify the process of hash code generation for you.</p>
<p class="callout-heading">Updating equality members</p>
<p class="callout">If you ever add new properties to your class that should factor into equality checks, be sure to update <code>Equals</code> and <code>GetHashCode</code> to include these properties.</p>
<p>With custom equality members in place, code that previously checked both the airport <code>Code</code> and <code>Country</code> can be simplified to use the equality operator (<code>==</code>) instead:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightScheduler.cs – Search</p>
<pre class="source-code">
if (depart != null) {
  results=results.Where(f=&gt; <strong class="bold">f.DepartureLocation == depart</strong>);
}
if (arrive != null) {
  results=results.Where(f=&gt; <strong class="bold">f.ArrivalLocation == arrive</strong>);
}</pre>
<p>Overriding equality members can be handy when you have many similar objects on the heap that contain identical values. This can happen when working <a id="_idIndexMarker289"/>with <strong class="bold">web services</strong> or other places <a id="_idIndexMarker290"/>where <strong class="bold">deserialization</strong> occurs.</p>
<p class="callout-heading">Equality and records</p>
<p class="callout">You don’t always need to override equality members to get value-based equality. In <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a><em class="italic">: Defensive Coding Techniques</em>, we’ll explore strategic uses of the <code>record</code> keyword for controlling equality. In fact, whenever I find myself thinking about overriding equality members, I usually decide to make my class a record instead.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Extracting a base class</h2>
<p>Sometimes<a id="_idIndexMarker291"/> you’ll encounter cases with a high degree of duplication between classes. These classes are conceptually related and share not just similar member signatures, but identical implementations of those members.</p>
<p>In these cases, it often makes sense to introduce a base class that defines the common shared code. <strong class="bold">Inheritance</strong> then<a id="_idIndexMarker292"/> allows us to remove the common code from multiple classes in the system and maintain it in a centralized place.</p>
<p>In our flight scheduler example (see <em class="italic">Figure 5</em><em class="italic">.14</em>), the passenger and freight flight classes have several shared properties:</p>
<div><div><img alt="Figure 5.14 – Shared members between freight and passenger flights" src="img/B21324_05_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Shared members between freight and passenger flights</p>
<p>To address this, go to either of the two classes and choose <strong class="bold">Extract base class...</strong> from the <strong class="bold">Quick </strong><strong class="bold">Actions</strong> menu:</p>
<div><div><img alt="Figure 5.15 – Extracting a base class" src="img/B21324_05_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – Extracting a base class</p>
<p>Next, name the <a id="_idIndexMarker293"/>new class and select which members you want to move into it, as shown in <em class="italic">Figure 5</em><em class="italic">.16</em>. You can also decide whether you want any of those members to be declared as abstract, but note that this will mark your class as abstract as well.</p>
<div><div><img alt="Figure 5.16 – Configuring the new base class" src="img/B21324_05_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16 – Configuring the new base class</p>
<p>Once you click <strong class="bold">OK</strong>, the new class will be created:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightInfoBase.cs</p>
<pre class="source-code">
public class <strong class="bold">FlightInfoBase</strong> {
  public Airport ArrivalLocation { get; set; }
  public DateTime ArrivalTime { get; set; }
  public Airport DepartureLocation { get; set; }
  public DateTime DepartureTime { get; set; }
  public TimeSpan Duration =&gt; DepartureTime - ArrivalTime;
  public string Id { get; set; }
}</pre>
<p>The class <a id="_idIndexMarker294"/>you started with now inherits from this new class and the non-abstract members you selected have been removed from the file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PassengerFlightInfo.cs</p>
<pre class="source-code">
public class PassengerFlightInfo : <strong class="bold">FlightInfoBase,</strong>
<strong class="bold">                                   IFlightInfo</strong> {
  private int _passengers;
  public void Load(int passengers) =&gt;
    _passengers = passengers;
  public void Unload() =&gt;
    _passengers = 0;
  public string BuildFlightIdentifier() =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} carrying"
    + $" {_passengers} people";
  public override string ToString() =&gt;
    BuildFlightIdentifier();
}</pre>
<p>Extracting a base class can be very helpful for promoting code reuse, but it’s only half of the refactoring work; extracting a base class did not modify your other class.</p>
<p>If you want <a id="_idIndexMarker295"/>the related flight class to also inherit from the new class, you’ll have to make that change manually by specifying the base class and removing any members that were “pulled up” to that class:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FreightFlightInfo.cs</p>
<pre class="source-code">
public class FreightFlightInfo : <strong class="bold">FlightInfoBase</strong>,
                                 IFlightInfo {
  public string CharterCompany { get; set; }
  public string Cargo { get; set; }
  public string BuildFlightIdentifier() =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} " +
    $"carrying {Cargo} for {CharterCompany}";
  public override string ToString() =&gt;
    BuildFlightIdentifier();
}</pre>
<p>The result of this is that our two flight classes are now focused on the things that are distinct to them. Additionally, if new logic needs to be added for every flight, it can now be added to the base class and all inheriting classes will receive it.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Moving interface implementations up the inheritance tree</h2>
<p>One oddity<a id="_idIndexMarker296"/> you might have noticed in the last two code listings is that even though <code>FreightFlightInfo</code> and <code>PassengerFlightInfo</code> both now inherit from <code>FlightInfoBase</code>, they both separately implement the <code>IFlightInfo</code> interface, as shown in <em class="italic">Figure 5</em><em class="italic">.17</em>:</p>
<div><div><img alt="Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo" src="img/B21324_05_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo</p>
<p>When every class<a id="_idIndexMarker297"/> inheriting from a base class implements an interface, there’s usually a good chance that you can pull the interface implementation up into the base class itself.</p>
<p>In this case, <code>FlightInfoBase</code> has all required members defined by the <code>IFlightInfo</code> interface. So, it makes sense to implement the interface, as shown here:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightInfoBase.cs</p>
<pre class="source-code">
public class FlightInfoBase <strong class="bold">: IFlightInfo</strong> {
  public Airport ArrivalLocation { get; set; }
  public DateTime ArrivalTime { get; set; }
  public Airport DepartureLocation { get; set; }
  public DateTime DepartureTime { get; set; }
  public TimeSpan Duration =&gt; DepartureTime – ArrivalTime;
  public string Id { get; set; }
}</pre>
<p>With the change in place, we can remove the <code>IFlightInfo</code> implementation from both <code>PassengerFlightInfo</code> and <code>FreightFlightInfo</code>. This simplifies the class definitions while still inheriting the interface implementation, as pictured here:</p>
<div><div><img alt="Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase" src="img/B21324_05_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase</p>
<p>By pulling the<a id="_idIndexMarker298"/> interface up into the base class, we now <em class="italic">guarantee</em> that any class inheriting from this class will also implement the <code>IFlightInfo</code> interface.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>Controlling inheritance with abstract</h1>
<p>Now that we’ve covered some refactoring patterns around inheritance, let’s look at using <strong class="bold">abstract classes</strong> and <a id="_idIndexMarker299"/>other C# features to restrict our classes and ensure they’re used appropriately.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Communicating intent with abstract</h2>
<p>One quirk <a id="_idIndexMarker300"/>about our current design is that it is possible to instantiate a new instance of <code>FlightInfoBase</code> simply by writing the following code:</p>
<pre class="source-code">
FlightInfoBase flight = new FlightInfoBase();</pre>
<p>While it might not make sense to you – for a new flight to exist that isn’t explicitly a passenger or freight flight, because the <code>FlightInfoBase</code> class is not marked as abstract – there’s nothing preventing anyone from instantiating it.</p>
<p>To mark a class as abstract, add the <code>abstract</code> keyword to its signature:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightInfoBase.cs</p>
<pre class="source-code">
public <strong class="bold">abstract</strong> class FlightInfoBase : IFlightInfo {
  public Airport ArrivalLocation { get; set; }
  public DateTime ArrivalTime { get; set; }
  public Airport DepartureLocation { get; set; }
  public DateTime DepartureTime { get; set; }
  public TimeSpan Duration =&gt; DepartureTime - ArrivalTime;
  public string Id { get; set; }
}</pre>
<p>Marking classes as abstract when you do not intend for anyone to instantiate them accomplishes a few things:</p>
<ul>
<li>It communicates that the class is not intended to be instantiated</li>
<li>The compiler now prevents others from instantiating your class</li>
<li>As we’ll see next, it allows you to add abstract members to your class</li>
</ul>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Introducing abstract members</h2>
<p>Now that <code>FlightInfoBase</code> is abstract, it <a id="_idIndexMarker301"/>opens new <a id="_idIndexMarker302"/>possibilities for refactoring.</p>
<p>For example, both <code>FreightFlightInfo</code> and <code>PassengerFlightInfo</code> have <code>BuildFlightIdentifier</code> methods and <code>ToString</code> overrides.</p>
<div><div><img alt="Figure 5.19 – Repeated members in flight info classes" src="img/B21324_05_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19 – Repeated members in flight info classes</p>
<p>While the implementation details of the <code>BuildFlightIdentifier</code> method differ, <code>ToString</code> overrides the return of the result of <code>BuildFlightIdentifier</code>.</p>
<p>We can take advantage of these commonalities by pulling both methods into the base class using <strong class="bold">Pull [Member name] up...</strong>, as shown in <em class="italic">Figure 5</em><em class="italic">.20</em>:</p>
<div><div><img alt="Figure 5.20 – Pulling members up to the base type" src="img/B21324_05_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20 – Pulling members up to the base type</p>
<p>Next, select the <a id="_idIndexMarker303"/>members you want to pull up into the parent class, making sure to check the <strong class="bold">Mark abstract</strong> checkbox for any member you want the <em class="italic">definition</em> of to be pulled up without also having its <em class="italic">implementation</em> pulled up.</p>
<div><div><img alt="Figure 5.21 – Selecting destination and making members abstract" src="img/B21324_05_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.21 – Selecting destination and making members abstract</p>
<p>The result of this is that <code>FlightInfoBase</code> now has the <code>ToString</code> override as well as an abstract definition for the <code>BuildFlightIdentifier</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightInfoBase.cs</p>
<pre class="source-code">
public abstract class FlightInfoBase : IFlightInfo {
  // Other members omitted...
<strong class="bold">  </strong><strong class="bold">public abstract string BuildFlightIdentifier();</strong>
<strong class="bold">  public override string ToString() =&gt;</strong>
<strong class="bold">    BuildFlightIdentifier();</strong>
}</pre>
<p>With <code>BuildFlightIdentifier</code> abstract, our original method call remains in place, but it is now<a id="_idIndexMarker304"/> marked as an override:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PassengerFlightInfo.cs</p>
<pre class="source-code">
public class PassengerFlightInfo : FlightInfoBase {
  // Other members omitted...
  <strong class="bold">public override string BuildFlightIdentifier()</strong> =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} carrying"
    + $" {_passengers} people";
}</pre>
<p>Unfortunately, the <strong class="bold">Pull Members Up</strong> refactoring does not modify other classes that also inherit from the same base class, so you now must add the override manually in the other flight class:</p>
<pre class="source-code">
public class FreightFlightInfo : FlightInfoBase {
  // Other members omitted...
  public <strong class="bold">override</strong> string BuildFlightIdentifier() =&gt;
    $"{Id} {DepartureLocation}-{ArrivalLocation} " +
    $"carrying {Cargo} for {CharterCompany}";
}</pre>
<p>Making this refactoring has simplified our code: the individual flight classes no longer need to override <code>ToString</code>. More importantly, if we ever add a new type of flight, the compiler will force it to <a id="_idIndexMarker305"/>provide a valid flight identifier through a <code>BuildFlightIdentifier</code> override.</p>
<p class="callout-heading">Sealed methods and classes</p>
<p class="callout">While we’re talking about abstract, virtual, and overriding methods, we should touch on <code>sealed</code>. The <code>sealed</code> keyword has almost the opposite effect. When a class is marked with <code>sealed</code>, it cannot be inherited from. When a <em class="italic">method</em> is marked with <code>sealed</code>, that method may not be overridden further in inheriting classes. Both uses of the <code>sealed</code> keyword exist to protect what a class does from external modification. Additionally, there can be some performance benefits to marking members as sealed.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Converting abstract methods to virtual methods</h2>
<p>Occasionally, you’ll<a id="_idIndexMarker307"/> mark a method as abstract and later realize that many overrides of this method have similar implementations. When this occurs, it can make sense to move the method from <code>abstract</code> to <code>virtual</code> in order to provide a base implementation that others can <em class="italic">optionally</em> override.</p>
<p>Our <code>FlightInfoBase</code> class defines <code>BuildFlightIdentifier</code> as abstract:</p>
<pre class="source-code">
public abstract string BuildFlightIdentifier();</pre>
<p>This would imply that each implementation of this method <em class="italic">should</em> be different from the others. However, let’s take a look at the actual implementations of this:</p>
<ul>
<li>PassengerFlightInfo.cs<pre class="source-code">
public override string BuildFlightIdentifier() =&gt;</pre><pre class="source-code">
  $"<strong class="bold">{Id} {DepartureLocation}-{ArrivalLocation}</strong></pre><pre class="source-code">
    carrying " +</pre><pre class="source-code">
  $"{_passengers} people";</pre></li>
<li>FreightFlightInfo.cs<pre class="source-code">
public override string BuildFlightIdentifier() =&gt;</pre><pre class="source-code">
  $"<strong class="bold">{Id} {DepartureLocation}-{ArrivalLocation}</strong></pre><pre class="source-code">
    carrying " +</pre><pre class="source-code">
  $"{Cargo} for {CharterCompany}";</pre></li>
</ul>
<p>While the strings for both methods are built, they both start with the flight identifier, the departure airport, and the arrival airport.</p>
<p>If we ever wanted to change the way all flights display this basic information, we’d need to change every class inheriting from <code>FlightInfoBase</code>.</p>
<p>Instead, we can modify <code>FlightInfoBase</code> to provide a good starting point with this shared information:</p>
<pre class="source-code">
public <strong class="bold">virtual</strong> string BuildFlightIdentifier() <strong class="bold">=&gt;</strong>
<strong class="bold">  $"{Id} {DepartureLocation}-{ArrivalLocation}";</strong></pre>
<p>With this change, two things have happened:</p>
<ul>
<li>New<a id="_idIndexMarker308"/> flight classes no longer <em class="italic">need</em> to override <code>BuildFlightIdentifier</code></li>
<li>Existing overrides can call <code>base.BuildFlightIdentifier()</code> to get the common format of the basic flight information</li>
</ul>
<p>In our case, it makes sense to continue to override the method, but we can now change the code to take advantage of common formatting at the base level:</p>
<ul>
<li><code>PassengerFlightInfo.cs</code><pre class="source-code">
public override string BuildFlightIdentifier() =&gt;</pre><pre class="source-code">
  <strong class="bold">base.BuildFlightIdentifier() +</strong></pre><pre class="source-code">
  $" carrying {_passengers} people";</pre></li>
<li><code>FreightFlightInfo.cs</code><pre class="source-code">
public override string BuildFlightIdentifier() =&gt;</pre><pre class="source-code">
  <strong class="bold">base.BuildFlightIdentifier() +</strong></pre><pre class="source-code">
  $" carrying {Cargo} for {CharterCompany}";</pre></li>
</ul>
<p>Combining our <a id="_idIndexMarker309"/>abstract class with a virtual method lets us keep flight formatting logic in one centralized place while still giving us the freedom to extend the class and modify its behavior.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Refactoring for better encapsulation</h1>
<p>Another core tenet of object-oriented <a id="_idIndexMarker310"/>programming is <strong class="bold">encapsulation</strong>. With encapsulation, you assert control of the data in your classes and ensure others work with data in ways that make sense both immediately and as the code grows over time.</p>
<p>The following refactorings deal with the various pieces of data composing classes along with the data passed along to methods as parameters.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Encapsulating fields</h2>
<p>The simplest <a id="_idIndexMarker311"/>encapsulation refactoring allows you to wrap all uses of a field into a property.</p>
<p>In the following code example, the <code>PassengerFlightInfo</code> class has a <code>_passengers</code> field storing the count of passengers on the flight, and this field is used throughout the class when referring to the passenger count:</p>
<pre class="source-code">
public class PassengerFlightInfo : FlightInfoBase {
  <strong class="bold">private int _passengers;</strong>
  public void Load(int passengers) =&gt;
    <strong class="bold">_passengers = passengers;</strong>
  public void Unload() =&gt;
    <strong class="bold">_passengers = 0;</strong>
  public override string BuildFlightIdentifier() =&gt;
    base.BuildFlightIdentifier() +
    $" carrying <strong class="bold">{_passengers</strong>} people";
}</pre>
<p>This <a id="_idIndexMarker312"/>code isn’t bad, and I’d be fine with this logic in a production application. However, it does have a few potential drawbacks:</p>
<ul>
<li>Nothing outside of the class can read the count of passengers on the flight.</li>
<li>Several places modify the <code>_passengers</code> field. If we wanted to add validation or do something every time the value changes, we’d have to modify several different methods.</li>
</ul>
<p>Wrapping all uses of the <code>_passengers</code> field into a property can help with this by giving us a centralized place to perform validation and a property for things outside of the class to read.</p>
<p>You can use the <strong class="bold">Encapsulate field</strong> refactoring in the <strong class="bold">Quick Action</strong> menu to quickly wrap an existing field into a property:</p>
<div><div><img alt="Figure 5.22 – Encapsulating the passengers field into a property" src="img/B21324_05_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.22 – Encapsulating the passengers field into a property</p>
<p>This adds a property that your class can use to read and modify the value in a centralized location:</p>
<pre class="source-code">
public sealed class PassengerFlightInfo : FlightInfoBase {
  private int _passengers;
<strong class="bold">  public int Passengers {</strong>
<strong class="bold">    get =&gt; _passengers;</strong>
<strong class="bold">    set =&gt; _passengers = value;</strong>
<strong class="bold">  }</strong>
  public void Load(int passengers) =&gt;
    <strong class="bold">Passengers = passengers;</strong>
  public void Unload() =&gt;
    <strong class="bold">Passengers = 0;</strong>
  public override string BuildFlightIdentifier() =&gt;
    base.BuildFlightIdentifier() +
    $" carrying {<strong class="bold">Passengers</strong>} people";
}</pre>
<p>Keep in <a id="_idIndexMarker313"/>mind that this refactoring does make the setter public by default, which would allow code outside of the class to modify the <code>passengers</code> value. If you don’t want this, you can mark the property as having a <code>private</code> or <code>protected</code> set instead.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Wrapping parameters into a class</h2>
<p>As software<a id="_idIndexMarker314"/> systems grow, more features get added along with the code needed to support them. This can cause methods that were once simple to grow significantly in complexity and the information they require to operate.</p>
<p>It’s not unusual for a method that took three parameters in the early days of a project to suddenly find itself needing seven or eight parameters to function after a significant amount of development occurs.</p>
<p><code>FlightScheduler</code>’s search method is an example of this since there are so many things that can factor into a flight search:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightScheduler.cs</p>
<pre class="source-code">
public IEnumerable&lt;IFlightInfo&gt; Search(
  <strong class="bold">Airport? depart, Airport? arrive,</strong>
<strong class="bold">  DateTime? minDepartTime, DateTime? maxDepartTime,</strong>
<strong class="bold">  DateTime? minArriveTime, DateTime? maxArriveTime,</strong>
<strong class="bold">  TimeSpan? minLength, TimeSpan? maxLength</strong>) {</pre>
<p>This method currently takes in eight different pieces of information, which makes calls to the method extremely hard to read:</p>
<pre class="source-code">
IEnumerable&lt;IflightInfo&gt; flights = <strong class="bold">scheduler.Search(cmh,</strong>
<strong class="bold">  dfw, new DateTime(2024,3,1), new DateTime(2024,3,5),</strong>
<strong class="bold">  new DateTime(2024,3,10), new DateTime(2024,3,13),</strong>
<strong class="bold">  TimeSpan.FromHours(2.5), TimeSpan.FromHours(4.5))</strong>;</pre>
<p>While I <a id="_idIndexMarker315"/>made that example a little hard to read on purpose, in my experience, complex method signatures exist in the real world. These complex methods can lead to subtle bugs due to confusion over which value you’re passing to which parameter as you read a long list of parameters.</p>
<p>Looking at this code, it’s easy to imagine new things that someone might want to search for with regard to flights, including low and high prices, in-flight beverage service, free Wi-Fi, and the type of aircraft being flown. Each one of these new search features would further expand both the method definition and every caller to the method.</p>
<p>One common solution to this problem is to encapsulate related pieces of information into a new class. In our case, we can define a new <code>FlightSearch</code> class to wrap everything related to searching for a flight:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightSearch.cs</p>
<pre class="source-code">
public class FlightSearch {
  public Airport? Depart { get; set; }
  public Airport? Arrive { get; set; }
  public DateTime? MinArrive { get; set; }
  public DateTime? MaxArrive { get; set; }
  public DateTime? MinDepart { get; set; }
  public DateTime? MaxDepart { get; set; }
  public TimeSpan? MinLength { get; set; }
  public TimeSpan? MaxLength { get; set; }
}</pre>
<p>This new <a id="_idIndexMarker316"/>class allows us to track information on searches in a centralized place and significantly improves the signature of the search method:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightScheduler.cs</p>
<pre class="source-code">
public IEnumerable&lt;IFlightInfo&gt; Search(<strong class="bold">FlightSearch s</strong>) {
  IEnumerable&lt;IFlightInfo&gt; results = _flights;
  if (<strong class="bold">s.Depart</strong> != null) {
    results =
      results.Where(f =&gt; f.DepartureLocation == <strong class="bold">s.Depart</strong>);
  }
  // Other filters omitted for brevity...
  return results;
}</pre>
<p>Adding the <code>FlightSearch</code> class shrunk the method signature from eight parameters to just one. Additionally, if new search logic needs to be added in the future, these pieces of information can be added to the <code>FlightSearch</code> object without needing to further modify the <code>Search</code> method’s signature.</p>
<p>Unfortunately, changing the signature of the search method breaks callers to the method until they are updated to use the new search object. To fix this, you have a few options:</p>
<ul>
<li>Update all usages of the <code>Search</code> method to pass a <code>FlightSearch</code> object</li>
<li>Create a temporary overload of the Search method that passes a <code>FlightSearch</code> object to the new method.</li>
</ul>
<p>The first option is somewhat self-explanatory, so let’s take a look at the second option.</p>
<p>Here, we’ll<a id="_idIndexMarker317"/> create an overload of the <code>Search</code> method that takes in the eight old parameters, creates a <code>FlightSearch</code> object, and passes it to the new method:</p>
<pre class="source-code">
<strong class="bold">[Obsolete("Use the overload that takes a FlightSearch")]</strong>
public IEnumerable&lt;IFlightInfo&gt; Search(
  Airport? depart, Airport? arrive,
  DateTime? minDepartTime, DateTime? maxDepartTime,
  DateTime? minArriveTime, DateTime? maxArriveTime,
  TimeSpan? minLength, TimeSpan? maxLength) {
  <strong class="bold">FlightSearch searchParams = new() {</strong>
    Arrive = arrive,
    MinArrive = minArriveTime,
    MaxArrive = maxArriveTime,
    Depart = depart,
    MinDepart = minDepartTime,
    MaxDepart = maxDepartTime,
    MinLength = minLength,
    MaxLength = maxLength
  <strong class="bold">};</strong>
  <strong class="bold">return Search(searchParams);</strong>
}</pre>
<p>Note that we marked this method as obsolete. This will warn programmers trying to use it and tell them what method to use instead (see <em class="italic">Figure 5</em><em class="italic">.23</em>). Marking things with the <code>Obsolete</code> attribute helps guide developers towards the more recent version. Typically, a method will be marked as obsolete and then removed from the project later.</p>
<div><div><img alt="Figure 5.23 – An obsolete warning telling the developer which method to use instead" src="img/B21324_05_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.23 – An obsolete warning telling the developer which method to use instead</p>
<p>The result of this is that we were able to simplify our method and provide a safe place for the data <a id="_idIndexMarker318"/>that the method needs to grow over time by introducing a class.</p>
<p>Introducing classes for common sets of parameters significantly speeds up development time for teams, particularly when these same objects are passed around throughout the system.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Wrapping properties into a class</h2>
<p>Sometimes you’ll <a id="_idIndexMarker319"/>find classes with sets of properties that are related to each other. For example, the <code>FlightInfoBase</code> class needs to track both the airport a plane departs from or arrives at and the time and date of that event:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightInfoBase.cs</p>
<pre class="source-code">
public abstract class FlightInfoBase : IFlightInfo {
<strong class="bold">  public Airport ArrivalLocation { get; set; }</strong>
<strong class="bold">  public DateTime ArrivalTime { get; set; }</strong>
<strong class="bold">  public Airport DepartureLocation { get; set; }</strong>
<strong class="bold">  public DateTime DepartureTime { get; set; }</strong>
  // Other members omitted ...
}</pre>
<p>In this scenario, information about the arrival and departure need both their <code>Airport</code> and the associated <code>DateTime</code> to make sense. If we needed to track the terminal, gate, or runway in the future, we’d need to add in properties for both arrival and departure.</p>
<p>Because these sets of properties grow together, it makes sense to wrap them together in their own <code>AirportEvent</code> class:</p>
<pre class="source-code">
public class AirportEvent {
  public Airport Location { get; set; }
  public DateTime Time { get; set; }
}</pre>
<p>Now, if we<a id="_idIndexMarker320"/> need to expand the information we track on each leg of a flight, we can add it to this class and it will be available to both arrivals and departures.</p>
<p>Of course, for this to fully work we’ll need to modify <code>FlightInfoBase</code> to use the new class instead of tracking its properties separately:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightInfoBase.cs</p>
<pre class="source-code">
public abstract class FlightInfoBase : IFlightInfo {
<strong class="bold">  public AirportEvent Arrival { get; set; }</strong>
<strong class="bold">  public AirportEvent Departure { get; set; }</strong>
  public TimeSpan Duration =&gt; <strong class="bold">Departure.Time</strong>-<strong class="bold">Arrival.Time</strong>;
  public string Id { get; set; }
  public virtual string BuildFlightIdentifier() =&gt;
    $"{Id} {<strong class="bold">Departure.Location</strong>}-{<strong class="bold">Arrival.Location</strong>}";
  public sealed override string ToString() =&gt;
    BuildFlightIdentifier();
}</pre>
<p>However, this change on its own won’t be enough until we update the <code>IFlightInfo</code> interface to match our new signature:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">IFlightInfo.cs</p>
<pre class="source-code">
public interface IFlightInfo {
  string Id { get; }
<strong class="bold">  AirportEvent Arrival { get; set; }</strong>
<strong class="bold">  AirportEvent Departure { get; set; }</strong>
  TimeSpan Duration { get; }
}</pre>
<p>With this<a id="_idIndexMarker321"/> change, the compiler is now satisfied with our flight classes, but there are now compiler errors in <code>FlightScheduler</code>’s <code>ScheduleFlight</code> method:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightScheduler.cs</p>
<pre class="source-code">
PassengerFlightInfo flight = new() {
  Id = id,
<strong class="bold">  ArrivalLocation = arrive,</strong>
<strong class="bold">  ArrivalTime = arriveTime,</strong>
<strong class="bold">  DepartureLocation = depart,</strong>
<strong class="bold">  DepartureTime = departTime,</strong>
};</pre>
<p>This method is still trying to set the old properties, so it will need to be updated to use <code>AirportEvent</code> objects instead:</p>
<pre class="source-code">
PassengerFlightInfo flight = new() {
  Id = id,
  <strong class="bold">Arrival =</strong> <strong class="bold">new AirportEvent {</strong>
<strong class="bold">    Location = arrive,</strong>
<strong class="bold">    Time = arriveTime,</strong>
<strong class="bold">  }</strong>,
  <strong class="bold">Departure = new AirportEvent {</strong>
<strong class="bold">    Location = depart,</strong>
<strong class="bold">    Time = departTime,</strong>
<strong class="bold">  }</strong>,
};</pre>
<p><code>FlightScheduler</code> also has a few more compiler errors in the search method due to uses of the old properties:</p>
<pre class="source-code">
if (s.Depart != null) {
  results =
    results.Where(f =&gt; f.<strong class="bold">DepartureLocation</strong> == s.Depart);
}</pre>
<p>These pieces of code will need to reference the new properties instead:</p>
<pre class="source-code">
if (s.Depart != null) {
  results =
    results.Where(f =&gt; <strong class="bold">f.Departure.Location</strong> == s.Depart);
}</pre>
<p>You may <a id="_idIndexMarker322"/>have noticed that for this simple change of wrapping properties together into a new object we had to make a number of changes just to get the code to compile again.</p>
<p>This can be normal when making structural changes like this, but the compiler supports you on your refactoring journey here by ensuring your code makes structural sense as you make your changes. In fact, I wouldn’t be brave enough to make some of these changes without being able to lean a little on the compiler to help me find places where I missed using the old way of doing things. I would encourage you to view the compiler as an ally on your refactoring journey.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Favoring composition over inheritance</h2>
<p>Let’s close<a id="_idIndexMarker323"/> our discussion on encapsulation by exploring the directive to <em class="italic">favor composition over inheritance</em>. This was a phrase I heard a lot in the early days of my career, though it took me a while to grasp its meaning and implications.</p>
<p>By favoring composition over inheritance, we make a conscious decision that classes should <em class="italic">have something</em> instead of <em class="italic">being something</em>. If a class has another object it can hand off a responsibility instead of relying on inheritance to make the class more special and able to handle a specific scenario.</p>
<p>Let’s look at the flight scheduling system, for example.</p>
<p>Cloudy Skies Airlines has decided it wants to offer charter flights. These are small flights that carry both passengers and cargo paid for by various companies. In this case, a charter flight is neither a passenger flight nor a freight flight, but in fact a bit of both.</p>
<p>A direct implementation of this using inheritance would look something like this:</p>
<pre class="source-code">
public class CharterFlightInfo : FlightInfoBase {
<strong class="bold">  public string CharterCompany { get; set; }</strong>
<strong class="bold">  public string Cargo { get; set; }</strong>
<strong class="bold">  public int Passengers { get; set; }</strong>
  public override string BuildFlightIdentifier() =&gt;
    base.BuildFlightIdentifier() +
<strong class="bold">    $" carrying {Cargo} for {CharterCompany}" +</strong>
<strong class="bold">    $" and {Passengers} passengers";</strong>
}</pre>
<p>Note here that a single class has both cargo and passengers.</p>
<p>On its own, this isn’t so bad, but what if we wanted our charter flight to hold multiple pieces of cargo? We’d now need to have a collection of cargo strings with their charter companies (which might be different from one another).</p>
<p>Any customizations to this cargo or how it would be displayed would require either additional customization of this class or a separate but related class also inheriting from <code>FlightInfoBase</code>. It’s not too hard to imagine this system spawning a swarm of related classes such as <code>BulkCargoFlightInfo</code>, <code>ExpressFlightInfo</code>, <code>MedicalFlightInfo</code>, <code>HazardousCargoFlightInfo</code>, and more.</p>
<p>While this inheritance-based approach would work, using <strong class="bold">composition</strong> will result in more maintainable code and fewer <a id="_idIndexMarker324"/>classes.</p>
<p>Composition<a id="_idIndexMarker325"/> lets us say that an individual flight is <em class="italic">composed of</em> cargo items. Cargo items can be defined using a simple <code>CargoItem</code> class:</p>
<pre class="source-code">
public class CargoItem {
  public string ItemType { get; set; }
  public int Quantity { get; set; }
  public override string ToString() =&gt;
    $"{Quantity} {ItemType}";
}</pre>
<p>This simple approach stores the item type and its quantity and provides a string representation of the two.</p>
<p>We can then incorporate this into an alternative version of <code>CharterFlightInfo</code>:</p>
<pre class="source-code">
public class CharterFlightInfo : FlightInfoBase {
  <strong class="bold">public List&lt;CargoItem&gt; Cargo { get; } = new();</strong>
  public override string BuildFlightIdentifier() {
    StringBuilder sb = new(base.BuildFlightIdentifier());
    if (Cargo.Count != 0) {
      sb.Append(" carrying ");
<strong class="bold">      foreach (var cargo in Cargo) {</strong>
<strong class="bold">        sb.Append($"{cargo}, ");</strong>
<strong class="bold">      }</strong>
    }
    return sb.ToString();
  }
}</pre>
<p>This approach allows a charter flight to be composed of different cargo items. Each item is then displayed in the <code>BuildFlightIdentifier</code> method using its <code>ToString</code> method. See the following diagram:</p>
<div><div><img alt="Figure 5.24 – CharterFlightInfo is composed of CargoItems" src="img/B21324_05_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.24 – CharterFlightInfo is composed of CargoItems</p>
<p>Composing<a id="_idIndexMarker326"/> our charter flight with <code>CargoItems</code> gives us additional flexibility. Not only does this arrangement pattern allow a charter flight to have multiple cargo items, but it also allows it to do so without you having to declare different classes for different cargo loads.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Improving classes with interfaces and polymorphism</h1>
<p>We’re nearly at the close of this chapter on object-oriented refactoring. However, before we close the chapter, let’s discuss a few places where introducing interfaces and polymorphism can help further improve our code.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Extracting interfaces</h2>
<p>At the <a id="_idIndexMarker327"/>moment, our <code>CharterFlightInfo</code> class stores a list of <code>CargoItem</code>s representing its cargo:</p>
<pre class="source-code">
public class CharterFlightInfo : FlightInfoBase {
<strong class="bold">  public List&lt;CargoItem&gt; Cargo { get; } = new();</strong>
  // Other members omitted...
}</pre>
<p>Each cargo item the charter flight includes must be a <code>CargoItem</code> or something that inherits from it. For example, if we were to create the <code>HazardousCargoItem</code> we discussed in the last section and try to store it in the cargo collection, it <em class="italic">must</em> inherit from <code>CargoItem</code> to compile.</p>
<p>In many <a id="_idIndexMarker328"/>systems, you don’t want to force people to inherit from your classes if they want to customize the system’s behavior. In these places, it can be helpful to introduce an interface.</p>
<p>Let’s do that with our <code>CargoItem</code> class by selecting the class and then choosing <strong class="bold">Extract interface…</strong> from the <strong class="bold">Quick </strong><strong class="bold">Actions</strong> menu.</p>
<div><div><img alt="Figure 5.25 – Extracting an interface" src="img/B21324_05_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.25 – Extracting an interface</p>
<p>Once you’ve done this, as shown in <em class="italic">Figure 5</em><em class="italic">.25</em>, you now need to specify which members of the class should be included in the interface as well as what the interface should be called:</p>
<div><div><img alt="Figure 5.26 – Customizing the extracted interface" src="img/B21324_05_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.26 – Customizing the extracted interface</p>
<p>Name your <a id="_idIndexMarker329"/>interface <code>ICargoItem</code>, select both <code>ItemType</code> and <code>Quantity</code>, and then click <code>ICargoItem</code> interface in a new file:</p>
<pre class="source-code">
public interface ICargoItem {
  string ItemType { get; set; }
  int Quantity { get; set; }
}</pre>
<p>This will also modify <code>CargoItem</code> to implement this interface:</p>
<pre class="source-code">
public class CargoItem <strong class="bold">: ICargoItem</strong> {
  public string ItemType { get; set; }
  public int Quantity { get; set; }
  public override string ToString() =&gt;
    $"{Quantity} {ItemType}";
}</pre>
<p>Note that by default, extracting an interface will introduce both getters and setters on properties. If you do not need your interface to expose a way of modifying a property, you can remove the <code>set</code> from the property definition in the interface:</p>
<pre class="source-code">
public interface ICargoItem {
  string ItemType <strong class="bold">{ get; }</strong>
  int Quantity <strong class="bold">{ get; }</strong>
}</pre>
<p>Removing the set <em class="italic">does not prevent you</em> from having a setter on your property in <code>CargoItem</code>; it just means you’re not <em class="italic">required</em> to have a setter on the property.</p>
<p>With our new interface <a id="_idIndexMarker330"/>in hand, let’s go in and modify <code>CharterFlightInfo</code> to store <code>ICargoItem</code>s instead of <code>CargoItem</code>s:</p>
<pre class="source-code">
public class CharterFlightInfo : FlightInfoBase {
  public List&lt;<strong class="bold">ICargoItem</strong>&gt; Cargo { get; } = new();
  // Other members omitted...
}</pre>
<p>This change allows us to store anything that implements the interface and improves the flexibility of what <code>CharterFlightInfo</code> can store. However, this does introduce another interface to your code, which slightly increases the complexity and can slow down development time in the long run.</p>
<p>Be careful when introducing interfaces. Interfaces that exist for the sake of added abstraction will ultimately do more harm than good in your application. However, interfaces that are implemented by more than one class or designed to give another set of developers greater <a id="_idIndexMarker331"/>freedom or flexibility can ultimately do a lot of good in a software system.</p>
<p>We’ll talk more about the appropriate place for interfaces in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a> when we explore SOLID. For now, let’s move on to a newer feature in C# interfaces.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Providing default interface implementations</h2>
<p>While we’re <a id="_idIndexMarker332"/>exploring interfaces, let’s see how <strong class="bold">default interface implementations</strong> can <a id="_idIndexMarker333"/>simplify the experience of implementing an interface.</p>
<p>Default interface implementations allow you to provide a default implementation inside the interface. When a class chooses to implement this interface, it is not <em class="italic">forced to</em> provide implementations of methods with default implementations.</p>
<p>Let’s see what this means by adding a <code>ManifestText</code> property with a default getter and a <code>LogManifest</code> method with a default implementation to <code>ICargoItem</code>:</p>
<pre class="source-code">
public interface ICargoItem {
  string ItemType { get; }
  int Quantity { get; }
<strong class="bold">  string ManifestText =&gt; $"{ItemType} {Quantity}";</strong>
<strong class="bold">  void LogManifest() {</strong>
<strong class="bold">    Console.WriteLine(ManifestText);</strong>
<strong class="bold">  }</strong>
}</pre>
<p>By adding these new members to the interface, we’d normally break anything that implemented the interface, such as the <code>CargoItem</code> class, unless it had those members. However, because we provided a <em class="italic">default implementation</em> of both properties, <code>CargoItem</code> no longer <em class="italic">must</em> provide implementations. Instead, it effectively inherits these default implementations.</p>
<p>We can still provide a version of these new members. If we did, that version would be used instead of the default implementation:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">CargoItem.cs</p>
<pre class="source-code">
public class CargoItem : ICargoItem {
  public string ItemType { get; set; }
  public int Quantity { get; set; }
<strong class="bold">  public void LogManifest() {</strong>
<strong class="bold">    Console.WriteLine($"Customized: {ToString()}");</strong>
<strong class="bold">  }</strong>
  public override string ToString() =&gt;
    $"{Quantity} {ItemType}";
}</pre>
<p>I don’t like default interface implementations very much because they confuse the concept of an interface with a contract to provide certain members.</p>
<p>However, I must <a id="_idIndexMarker334"/>concede that when adding a simple member to an interface, it sometimes makes sense to add a default implementation so that you don’t need to change existing implementations of the interface. This can save you from having to add the same code to many different implementations of your interface throughout your solution. Additionally, default interface implementations reduce the work needed for classes trying to implement the interface by providing a default implementation.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Introducing polymorphism</h2>
<p>Whenever you are working with an interface, you are intentionally supporting <strong class="bold">polymorphism</strong> in<a id="_idIndexMarker335"/> your application. This is the ability to treat different objects based on their similarities instead of on their differences.</p>
<p>The <code>ICargoItem</code> approach<a id="_idIndexMarker336"/> introduced earlier with charter flights is an example of polymorphism. A charter flight doesn’t care about what type of cargo it has as long as the cargo implements the interface. This means that we can load a charter flight full of different types of cargo and the class works fine with them.</p>
<p>The chapter’s code has another place that could strongly benefit from polymorphism: the <code>FlightScheduler</code> <code>Search</code> method:</p>
<pre class="source-code">
public IEnumerable&lt;IFlightInfo&gt; Search(FlightSearch s) {
  IEnumerable&lt;IFlightInfo&gt; results = _flights;
  <strong class="bold">if (s.Depart != null) {</strong>
<strong class="bold">    results =</strong>
<strong class="bold">      results.Where(f =&gt; f.Departure.Location == s.Depart);</strong>
<strong class="bold">  }</strong>
  <strong class="bold">// Many filters omitted...</strong>
<strong class="bold">  </strong><strong class="bold">if (s.MaxLength != null) {</strong>
<strong class="bold">    results =</strong>
<strong class="bold">      results.Where(f =&gt; f.Duration &lt;= s.MaxLength);</strong>
<strong class="bold">  }</strong>
  return results;
}</pre>
<p>This method <a id="_idIndexMarker337"/>has some very repetitive code (much of it omitted) that checks to see if the search object specifies a property. If the property was specified, the potential results are filtered down to only include those that match the filter.</p>
<p>The search method uses this approach to filter based on:</p>
<ul>
<li>Departure and arrival locations</li>
<li>Minimum/maximum departure time</li>
<li>Minimum/maximum arrival time</li>
<li>Minimum/maximum flight length</li>
</ul>
<p>It’s not too hard to imagine new things we might filter for, such as the price of the flight, whether the flight has a beverage service or even the type of aircraft.</p>
<p>An alternative approach would be to take in a collection of filter objects. These filter objects would determine whether each flight should be included in the results through a common <code>FlightFilterBase</code> class and a <code>ShouldInclude</code> method:</p>
<pre class="source-code">
public abstract class FlightFilterBase {
  <strong class="bold">public abstract bool ShouldInclude(IFlightInfo flight)</strong>;
}</pre>
<p>With this change, <code>Search</code> could be modified to loop over all filters and only include results that pass through all the provided filters:</p>
<pre class="source-code">
List&lt;IFlightInfo&gt; Search(<strong class="bold">List&lt;FlightFilterBase&gt; rules</strong>) =&gt;
  <strong class="bold">_flights.Where(f =&gt; rules.All(r =&gt; r.ShouldInclude(f)))</strong>
<strong class="bold">          .ToList();</strong></pre>
<p>This cuts our <code>Search</code> method<a id="_idIndexMarker338"/> down from over 40 lines long to only 3 lines of code through polymorphism.</p>
<p class="callout-heading">Alternative implementation</p>
<p class="callout">An interface would also work fine instead of an abstract base class.</p>
<p>By following this design, we can create a series of classes that inherit from <code>FlightFilterBase</code> to provide specific filtering capabilities:</p>
<div><div><img alt="Figure 5.27 – Distinct filter classes to help simplify our search code" src="img/B21324_05_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.27 – Distinct filter classes to help simplify our search code</p>
<p>We now have <a id="_idIndexMarker339"/>dedicated filters that filter out flights that don’t match their specific criterion. For example, the <code>AirportFilter</code> would filter out flights that don’t specify an airport:</p>
<pre class="source-code">
public class AirportFilter : <strong class="bold">FlightFilterBase</strong> {
  public bool IsDeparture { get; set; }
  public Airport Airport { get; set; }
<strong class="bold">  public override bool ShouldInclude(IFlightInfo flight) {</strong>
<strong class="bold">    if (IsDeparture) {</strong>
<strong class="bold">      return flight.Departure.Location == Airport;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    return flight.Arrival.Location == Airport;</strong>
<strong class="bold">  }</strong>
}</pre>
<p>Each individual filter class is small and easy to understand, maintain, and test.</p>
<p>Additionally, if we want to add a new way of filtering flights in the future, all we need to do is add a new class inheriting from <code>FlightFilterBase</code>. No modifications would be needed for the <code>Search</code> method to support this because all the method needs is a collection of individual filters. The <code>Search</code> method doesn’t need to know which filters are involved – it just needs to call the <code>ShouldInclude</code> method and interpret the result.</p>
<p>I find a lot of beauty in polymorphic solutions and have found my programming style changing over the years in search of more opportunities to take advantage of polymorphism through inheritance or interfaces.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Reviewing and testing our refactored code</h1>
<p>With these <a id="_idIndexMarker340"/>changes made, let’s take a step back and look at the result.</p>
<p>We took a flight search system and used object-oriented programming techniques to improve its flexibility and maintainability by doing the following:</p>
<ul>
<li>Reorganizing the code into appropriate files and namespaces</li>
<li>Introducing a base class and improving code reuse in flight information</li>
<li>Controlling a large number of parameters by moving them into a new class</li>
<li>Introducing another new class to manage common information about airport events including both an airport and a time component</li>
<li>Adding a charter flight class with a flexible cargo tracking system</li>
<li>Introducing a polymorphic way of searching flights that will be more flexible and maintainable over time</li>
</ul>
<p class="callout-heading">Refactored code</p>
<p class="callout">The final refactored code from this chapter is available in the <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> repository inside of the <code>Chapter05/Ch5RefactoredCode</code> folder.</p>
<p>As always, refactoring <a id="_idIndexMarker341"/>should never be done without testing the code to make sure that no new defects were introduced in the refactoring process. Running the tests (see <em class="italic">Figure 5</em><em class="italic">.28</em>) provided in the solution shows a full slate of passing tests, which will suffice for now until we get to <em class="italic">Part 2</em> and explore testing in more depth.</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 5.28 – Test Explorer showing that all tests pass" src="img/B21324_05_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.28 – Test Explorer showing that all tests pass</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Summary</h1>
<p>In this chapter, we explored the various ways that object-oriented programming techniques such as inheritance, encapsulation, and polymorphism can be used to refactor code toward more maintainable forms.</p>
<p>Refactoring can be a complex endeavor, and yet so many of the fundamental concepts of object-oriented programming can come together to build elegant, flexible, and maintainable solutions.</p>
<p>This concludes <em class="italic">Part 1</em> of the book. In the next part of the book, we’ll look at how testing can give you the safety and freedom needed to safely refactor your code and move forward with confidence that your changes have improved the application without breaking anything.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Questions</h1>
<ol>
<li>Does your code follow a well-structured and consistent namespace hierarchy with not too many or too few classes in each namespace?</li>
<li>Is there any part of your code that might be improved by using inheritance to promote code reuse?</li>
<li>Can you think of any repetitive rules or other structures in your code that might benefit from polymorphism?</li>
</ol>
<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Further reading</h1>
<p>You can find more information about materials discussed in this chapter at these URLs:</p>
<ul>
<li><em class="italic">Inheritance in </em><em class="italic">C#:</em> <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance">https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance</a></li>
<li><em class="italic">Sealed </em><em class="italic">Modifier</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed</a></li>
<li><em class="italic">IEquatable&lt;T&gt;:</em> <a href="https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1">https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1</a></li>
</ul>
</div>


<div><h1 id="_idParaDest-133" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor132"/>Part 2: Refactoring Safely</h1>
<p>In the second part of the book, we’ll cover coding techniques such as unit tests that help ensure your refactoring efforts don’t result in unintentional changes.</p>
<p>This chapter focuses on various testing frameworks and standard testing practices before moving on to discussions about programming best practices and writing SOLID code.</p>
<p>The final two chapters in this part focus on more advanced testing strategies and ways the C# language can help you detect and prevent errors from reaching your users.</p>
<p>This part contains the following chapters:</p>
<ul>
<li><a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a><em class="italic">, Unit Testing</em></li>
<li><a href="B21324_07.xhtml#_idTextAnchor161"><em class="italic">Chapter 7</em></a><em class="italic">, Test-Driven Development</em></li>
<li><a href="B21324_08.xhtml#_idTextAnchor173"><em class="italic">Chapter 8</em></a><em class="italic">, Avoiding Code Anti-Patterns with SOLID</em></li>
<li><a href="B21324_09.xhtml#_idTextAnchor189"><em class="italic">Chapter 9</em></a><em class="italic">, Advanced Unit Testing</em></li>
<li><a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a><em class="italic">, Defensive Coding Techniques</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>