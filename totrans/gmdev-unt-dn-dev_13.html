<html><head></head><body>
		<div id="_idContainer548">
			<p><a id="_idTextAnchor180"/></p>
			<h1 id="_idParaDest-177"><em class="italic"><a id="_idTextAnchor181"/>Chapter 10</em>: Serialization System and Assets Management in Unity and Azure</h1>
			<p>In the last chapter, <a href="B17146_09_Final_ASB_ePub.xhtml#_idTextAnchor165"><em class="italic">Chapter 9</em></a>, <em class="italic">Using Data-Oriented Technology Stack in Unity</em>, we learned what the data-oriented technology stack is and how you can use this technology to take advantage of multicore processors to improve the performance of your game. In this chapter, we will cover some other important topics in Unity development, namely, <strong class="bold">serialization</strong> and <strong class="bold">asset management</strong> in Unity. Usually, a game not only has code but also consists of many different kinds of assets, such as models, textures, and audio. Hence, understanding what the serialization system in Unity is and what the assets workflow is can help you better develop games with Unity. </p>
			<p>In the last section of this chapter, we will also explore an interesting topic – how to use the <strong class="bold">Azure Cloud storage</strong> services to host the content of a Unity game and load the content from the Azure Cloud to the Unity game by using Unity's <strong class="bold">Addressable Assets system</strong>.</p>
			<p>The following key topics will be included in our learning path:</p>
			<ul>
				<li>Serialization system in Unity</li>
				<li>The Assets workflow in Unity</li>
				<li>Introducing the special folders in Unity</li>
				<li>Azure Blob storage with Unity's Addressable Assets system</li>
			</ul>
			<p>By the end of this chapter, you will not only understand the serialization system and assets management in Unity, but you will also be familiar with Azure Cloud storage services.</p>
			<p>Sounds exciting! </p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor182"/>Technical requirements</h1>
			<p>Since this chapter will be covering Azure's Storage account service, if you don't have an Azure account available, I recommend you set up a free Azure trial account first before starting this chapter. You can click the following link to create a free Azure trial account with $200 credit:</p>
			<p><a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a></p>
			<div>
				<div id="_idContainer469" class="IMG---Figure">
					<img src="image/Figure_10.01_B17146.jpg" alt="Figure 10.1 – Microsoft Azure page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 <a id="_idTextAnchor183"/>– Microsoft Azure page</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor184"/>Serialization system in Unity </h1>
			<p>When developing a game, adding a reliable content saving and loading feature is a critical part of the development process. If you're using a game engine editor, such as the Unity engine editor, you'll also need some common editor features, such as undo, saving editor settings, and more. All of this, whether the game saves or loads content at runtime, or whether the<a id="_idIndexMarker863"/> developer uses the editor to develop the game, is built on <strong class="bold">serialization</strong>. </p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor185"/>What is Unity's serialization system?</h2>
			<p>So, what is <strong class="bold">serialization</strong>? According<a id="_idIndexMarker864"/> to Wikipedia, the definition of serialization is <em class="italic">the process of translating a data structure or object state into a format that can be stored or transmitted and reconstructed later</em>. The opposite operation is <strong class="source-inline">deserialization</strong>.</p>
			<p>In Unity, there are three <a id="_idIndexMarker865"/>serialization formats, namely the following:</p>
			<ul>
				<li>Binary serialization</li>
				<li><strong class="source-inline">YAML</strong> serialization</li>
				<li><strong class="source-inline">JSON</strong> serialization </li>
			</ul>
			<h3>YAML and binary serialization in Unity</h3>
			<p>Assets created by <a id="_idIndexMarker866"/>Unity, such as <strong class="source-inline">Scenes</strong> and <strong class="source-inline">Prefabs</strong>, will be<a id="_idIndexMarker867"/> saved in <strong class="source-inline">YAML</strong> format by default. For example, if we open the <a id="_idIndexMarker868"/>Scene of this chapter, namely, <strong class="source-inline">Chapter10.unity</strong>, in a text <a id="_idIndexMarker869"/>editor such as <strong class="bold">Sublime Text</strong>, you can <a id="_idIndexMarker870"/>see that this Scene is serialized in YAML format, and you will see that there are options including <strong class="source-inline">OcclusionCullingSettings</strong> and <strong class="source-inline">RenderSettings</strong>. If you scroll down, you can also find the GameObjects and components contained in this Scene.</p>
			<div>
				<div id="_idContainer470" class="IMG---Figure">
					<img src="image/Figure_10.02_B17146.jpg" alt="Figure 10.2 – The Scene in YAML format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – The Scene in YAML format</p>
			<p>As shown in <em class="italic">Figure 10.2</em>, there is no doubt that the YAML format is human-readable and makes it easy for the version control tools to work with. However, YAML is a text-based format, so you can also choose <a id="_idIndexMarker871"/>to use binary serialization for the more <a id="_idIndexMarker872"/>efficient use of space and increased security. Let's perform the following steps to set Unity's serialization mode:</p>
			<ol>
				<li>Open the <strong class="bold">Project Settings</strong> window by clicking the <strong class="bold">Edit | Project Settings...</strong> item in the Unity<a id="_idIndexMarker873"/> Editor toolbar, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer471" class="IMG---Figure">
					<img src="image/Figure_10.03_B17146.jpg" alt="Figure 10.3 – Opening the Project Settings window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Opening the Project Settings window</p>
			<ol>
				<li value="2">Next, click the <strong class="bold">Editor </strong>item <a id="_idIndexMarker874"/>in the category list on the left to open the <strong class="bold">Editor</strong><strong class="source-inline"> </strong>settings panel, as shown in <em class="italic">Figure 10.4</em>: </li>
			</ol>
			<div>
				<div id="_idContainer472" class="IMG---Figure">
					<img src="image/Figure_10.04_B17146.jpg" alt="Figure 10.4 – The Editor settings panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – The Editor settings panel</p>
			<ol>
				<li value="3">In the <strong class="bold">Asset Serialization</strong> section, we can find that the <strong class="bold">Mode</strong> option is <strong class="bold">Force Text</strong> by default. In this mode, all the assets created by Unity will be serialized in YAML format. This is also the recommended setting if you use a version<a id="_idIndexMarker875"/> management tool such as Git, as using plain text serialization can often avoid unresolvable merge conflicts. As shown in <em class="italic">Figure 10.5</em>, in the drop-down window, we can select <strong class="bold">Force Binary</strong> mode to convert all the assets to binary format, and we can also choose the <strong class="bold">Mixed</strong> mode option to retain the serialization format of the current assets; that is, the assets that are serialized in binary format are still in binary format, and assets that are serialized using YAML format are still in YAML format. However, newly created assets will be serialized in binary format.</li>
			</ol>
			<div>
				<div id="_idContainer473" class="IMG---Figure">
					<img src="image/Figure_10.05_B17146.jpg" alt="Figure 10.5 – Asset Serialization mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Asset Serialization mode</p>
			<ol>
				<li value="4">Here, we can select <strong class="bold">Force Binary</strong> mode and check the same Scene file in our text editor again. The Scene file is converted to binary format, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer474" class="IMG---Figure">
					<img src="image/Figure_10.06_B17146.jpg" alt="Figure 10.6 – The Scene file in binary format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – The Scene file in binary format</p>
			<p>As we mentioned earlier, serialization is <a id="_idIndexMarker876"/>also an important part of implementing the Unity Editor. Not only are the assets created by Unity as used in the game, such as game Scenes, serialized by Unity, but the various settings in the Unity Editor are also serialized by Unity. </p>
			<p>In the project root directory, we can find the <strong class="source-inline">ProjectSettings</strong> folder, which is automatically created by the Unity Editor when the project is created, as shown in <em class="italic">Figure 10.7</em>:</p>
			<div>
				<div id="_idContainer475" class="IMG---Figure">
					<img src="image/Figure_10.07_B17146.jpg" alt="Figure 10.7 – The ProjectSettings folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – The ProjectSettings folder</p>
			<p>Double-click this folder to open it. We can find all the settings files of the current project here.</p>
			<div>
				<div id="_idContainer476" class="IMG---Figure">
					<img src="image/Figure_10.08_B17146.jpg" alt="Figure 10.8 – The settings files in the ProjectSettings folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – The settings files in the ProjectSettings folder</p>
			<p>Next, we still use the text editor<a id="_idIndexMarker877"/> to open a settings file, such as <strong class="source-inline">GraphicsSettings.asset</strong>, and serialize this file using Unity's binary serialization mode and text serialization mode, respectively. <em class="italic">Figure 10.9</em> shows the settings file serialized in binary format:</p>
			<div>
				<div id="_idContainer477" class="IMG---Figure">
					<img src="image/Figure_10.09_B17146.jpg" alt="Figure 10.9 – The settings file in binary format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – The settings file in binary format</p>
			<p>On the other hand, you can see the settings file serialized in YAML format in <em class="italic">Figure 10.10</em>: </p>
			<div>
				<div id="_idContainer478" class="IMG---Figure">
					<img src="image/Figure_10.10_B17146.jpg" alt="Figure 10.10 – The settings file in YAML format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – The settings file in YAML format</p>
			<p>So far, we've discussed<a id="_idIndexMarker878"/> Unity's binary serialization and text-based YAML serialization, but we haven't covered the JSON serialization provided by Unity yet. Next, let's take a look at JSON serialization in Unity. </p>
			<h3>JsonUtility class and JSON serialization in Unity</h3>
			<p>If you have previous experience of developing .NET projects, you are probably familiar with <a id="_idIndexMarker879"/>JSON serialization. You can choose the solutions provided by .NET, such as <a id="_idIndexMarker880"/>using the <strong class="source-inline">DataContractJsonSerializer</strong> class defined in the <strong class="source-inline">System.Runtime.Serialization.Json</strong> namespace or using the <strong class="source-inline">JsonSerializer</strong> class defined in the <strong class="source-inline">System.Text.Json</strong> namespace, and there are also solutions from the open source community, such as <strong class="source-inline">Newtonsoft.Json</strong>, which is a very popular JSON framework for .NET. Unity also provides game developers with JSON serialization capabilities in Unity development, namely, the <strong class="source-inline">JsonUtility</strong> class. We can call <strong class="source-inline">JsonUtility</strong>'s <strong class="source-inline">ToJson</strong> method to serialize an object into a JSON string, and conversely, <strong class="source-inline">JsonUtility</strong>'s <strong class="source-inline">FromJson</strong> method can deserialize a JSON string into an object. Next, let's look at an example of how to use<a id="_idIndexMarker881"/> the <strong class="source-inline">JsonUtility</strong> class in Unity:</p>
			<ol>
				<li value="1">Create a new folder named <strong class="source-inline">Scripts</strong> by clicking the <strong class="bold">Create | Folder</strong> item in the <strong class="bold">Project</strong> window.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer479" class="IMG---Figure">
					<img src="image/Figure_10.11_B17146.jpg" alt="Figure 10.11 – Creating the Scripts folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – Creating the Scripts folder</p>
			<ol>
				<li value="2">Double-click on the <strong class="source-inline">Scripts</strong> folder to enter it, and then create a new C# script in this folder, name it <strong class="source-inline">PlayerData</strong>, and add the following to this script. The <strong class="source-inline">PlayerData</strong> struct is used to store the data of a player, and an object of it will be serialized to a<a id="_idIndexMarker882"/> JSON string later. And you should note that fields of the structs or classes should be <strong class="source-inline">public</strong>; otherwise, the Unity serializer will ignore these fields:<p class="source-code">public struct PlayerData</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">public</strong> string Name;</p><p class="source-code">    <strong class="bold">public</strong> int Age;</p><p class="source-code">    <strong class="bold">public</strong> float HP;</p><p class="source-code">    <strong class="bold">public</strong> float Attack;</p><p class="source-code">    public PlayerData(string name, int age, float hp,</p><p class="source-code">      float attack)</p><p class="source-code">    {</p><p class="source-code">        Name = name;</p><p class="source-code">        Age = age;</p><p class="source-code">        HP = hp;</p><p class="source-code">        Attack = attack;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, we also <a id="_idIndexMarker883"/>need to create another C# script in the same folder and name it <strong class="source-inline">JSONSerializationSample</strong>. The code in <strong class="source-inline">JSONSerializationSample</strong> is as follows. In the <strong class="source-inline">Start</strong> method, we create a new <strong class="source-inline">PlayerData</strong> object and assign values to its fields, and then call the <strong class="source-inline">JsonUtility.ToJson</strong> method to serialize this object into a JSON string and print the string to the <strong class="source-inline">Console</strong> window:<p class="source-code">using UnityEngine;</p><p class="source-code">public class JSONSerializationSample : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        var playerData = new PlayerData("player1", 50,</p><p class="source-code">          100, 100);</p><p class="source-code">        var jsonString =</p><p class="source-code">          <strong class="bold">JsonUtility.ToJson</strong>(playerData);</p><p class="source-code">        Debug.Log(jsonString);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a new <a id="_idIndexMarker884"/>GameObject in the Scene, attach the <strong class="source-inline">JSONSerializationSample</strong> script to it, and run the game in the editor. The JSON string, as shown in the following screenshot, will be printed:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer480" class="IMG---Figure">
					<img src="image/Figure_10.12_B17146.jpg" alt="Figure 10.12 – The JSON string&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – The JSON string</p>
			<ol>
				<li value="5">Deserializing a JSON string to an object is fairly straightforward; you just need to call <strong class="source-inline">JsonUtility.FromJson&lt;T&gt;</strong>, which is a generic method. If you don't know about generic methods in C#, generic methods are methods declared with type parameters. So, let's go back to <strong class="source-inline">JSONSerializationSample</strong> and update the code in the <strong class="source-inline">Start</strong> method. This code will deserialize the JSON string into a new object, and the object's <strong class="source-inline">Name</strong> field will be printed in the <strong class="bold">Console </strong>window:<p class="source-code">using UnityEngine;</p><p class="source-code">public class JSONSerializationSample : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        var playerData = new PlayerData("player1", 50,</p><p class="source-code">          100, 100);</p><p class="source-code">        var jsonString =</p><p class="source-code">          JsonUtility.ToJson(playerData);</p><p class="source-code">        Debug.Log(jsonString);</p><p class="source-code">        var deserializedObject =</p><p class="source-code">         <strong class="bold">JsonUtility.FromJson&lt;PlayerData&gt;(jsonString);</strong></p><p class="source-code">        Debug.Log(deserializedObject.Name);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Run the game<a id="_idIndexMarker885"/> in the editor. The name of this player is printed as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer481" class="IMG---Figure">
					<img src="image/Figure_10.13_B17146.jpg" alt="Figure 10.13 – Deserializing the JSON string&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.13 – Deserializing the JSON string</p>
			<ol>
				<li value="7">If you want <strong class="source-inline">PlayerData</strong> as a field of another class and you want to serialize this class, <strong class="source-inline">PlayerData</strong> needs to be marked with the <strong class="source-inline">[System.Serializable]</strong> attribute, otherwise, <strong class="source-inline">PlayerData</strong> as a field won't be serialized correctly. So, let's go back to <strong class="source-inline">PlayerData</strong> and update the code to add the <strong class="source-inline">[System.Serializable]</strong> attribute:<p class="source-code"><strong class="bold">[System.Serializable]</strong></p><p class="source-code">public struct PlayerData</p><p class="source-code">{</p><p class="source-code">   //No Change</p><p class="source-code">}</p></li>
			</ol>
			<p>Now that you <a id="_idIndexMarker886"/>know how to use the <strong class="source-inline">JsonUtility</strong> class to serialize an object to a JSON string and deserialize a JSON string to an object in Unity, it's time to discuss the advantages and limitations of Unity's <strong class="source-inline">JsonUtility</strong> class.</p>
			<h4>Advantages and limitations of Unity's JsonUtility class</h4>
			<p>Let's start with the<a id="_idIndexMarker887"/> advantages of Unity's <strong class="source-inline">JsonUtility</strong> class. Using the <strong class="source-inline">JsonUtility</strong> class in Unity can achieve relatively high performance in terms of serializing and deserializing JSON. The <strong class="source-inline">ToJson</strong> method and the <strong class="source-inline">FromJson</strong> method of <strong class="source-inline">JsonUtility</strong> use the Unity serializer internally, and it has better support for some built-in types of Unity, such as <strong class="source-inline">Vector2</strong> and <strong class="source-inline">Vector3</strong>. In addition, since it is provided by the Unity game engine, there is no need to install additional packages. </p>
			<p>However, <strong class="source-inline">JsonUtility</strong> has limited functionality compared to other popular JSON frameworks such as <strong class="source-inline">Newtonsoft.Json</strong>. The two most obvious limitations are that <strong class="source-inline">JsonUtility</strong> does not support the serialization of dictionaries and that the root element must be an object, not an array or a list. Let's look at an example of the limitations of the <strong class="source-inline">JsonUtility</strong> class:</p>
			<ol>
				<li value="1">Create a new<a id="_idIndexMarker888"/> C# script in the <strong class="source-inline">Scripts</strong> folder, name it <strong class="source-inline">TeamData</strong>, and add the following to this script. As shown in the following code, this class has two fields, a <strong class="source-inline">PlayerData</strong> list and a dictionary:<p class="source-code">using System.Collections.Generic;</p><p class="source-code">public class TeamData</p><p class="source-code">{</p><p class="source-code">    public <strong class="bold">List&lt;PlayerData&gt;</strong> Players;</p><p class="source-code">    public <strong class="bold">Dictionary&lt;string, PlayerData&gt;</strong> Roles;</p><p class="source-code">    public TeamData()</p><p class="source-code">    {</p><p class="source-code">        Players = new List&lt;PlayerData&gt;();</p><p class="source-code">        Roles = new Dictionary&lt;string, PlayerData&gt;();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, we also <a id="_idIndexMarker889"/>need to create another C# script in the same folder and name it <strong class="source-inline">JsonUtilityLimitationsSample</strong>. The code in <strong class="source-inline">JsonUtilityLimitationsSample</strong> is as follows. In the <strong class="source-inline">Start</strong> method, we create a new <strong class="source-inline">TeamData</strong> object, add an element to the <strong class="source-inline">Players</strong> list, and add a key and value to the <strong class="source-inline">Roles</strong> dictionary. Then, call the <strong class="source-inline">JsonUtility.ToJson</strong> method to serialize this object into a JSON string and print the string to the <strong class="bold">Console</strong> window:<p class="source-code">using UnityEngine;</p><p class="source-code">public class JsonUtilityLimitationsSample :</p><p class="source-code">  MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        var playerData = new PlayerData("player1", 50,</p><p class="source-code">          100, 100);</p><p class="source-code">        var teamData = new TeamData();</p><p class="source-code">        teamData.Players.Add(playerData);</p><p class="source-code">        teamData.Roles.Add("leader", playerData);</p><p class="source-code">        var jsonStringFromTeamData =</p><p class="source-code">          JsonUtility.ToJson(teamData);</p><p class="source-code">        Debug.Log(jsonStringFromTeamData);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Run the game<a id="_idIndexMarker890"/> in the editor; you can find that only the <strong class="source-inline">Players</strong> list is serialized, but the <strong class="source-inline">Roles</strong> dictionary is not serialized as expected, as shown in the following screenshot. This is because <strong class="source-inline">JsonUtility</strong> does not support serializing dictionaries in Unity.</li>
			</ol>
			<div>
				<div id="_idContainer482" class="IMG---Figure">
					<img src="image/Figure_10.14_B17146.jpg" alt="Figure 10.14 – The Roles dictionary is not serialized&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.14 – The Roles dictionary is not serialized</p>
			<ol>
				<li value="4">Then, let's go back to <strong class="source-inline">JsonUtilityLimitationsSample</strong> and update the code in the <strong class="source-inline">Start</strong> method to try to serialize the <strong class="source-inline">Players</strong> list individually:<p class="source-code">public class JsonUtilityLimitationsSample :</p><p class="source-code">  MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        // No Change</p><p class="source-code">        var jsonStringFromList =</p><p class="source-code">          JsonUtility.ToJson(<strong class="bold">teamData.Players</strong>);</p><p class="source-code">        Debug.Log(jsonStringFromList);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Run the <a id="_idIndexMarker891"/>game in the editor again and you will find that the <strong class="source-inline">Players</strong> list is not serialized this time, as shown in the following screenshot. This is because if using <strong class="source-inline">JsonUtility</strong> for serialization, the root element must be an object, not an array or list.</li>
			</ol>
			<div>
				<div id="_idContainer483" class="IMG---Figure">
					<img src="image/Figure_10.15_B17146.jpg" alt="Figure 10.15 – The Players list is not serialized&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15 – The Players list is not serialized</p>
			<h4>Newtonsoft.Json framework</h4>
			<p>It is a real headache to encounter the problems mentioned in the preceding example during development, so some other JSON frameworks may also be worth trying. Next, we will use <strong class="source-inline">Newtonsoft.Json</strong> to <a id="_idIndexMarker892"/>modify the preceding example so that the <strong class="source-inline">Roles</strong> dictionary in the <strong class="source-inline">TeamData</strong> class and the individual <strong class="source-inline">Players</strong> list can be serialized into JSON strings correctly: </p>
			<ol>
				<li value="1">First, if the <a id="_idIndexMarker893"/><strong class="source-inline">Newtonsoft.Json</strong> package is not installed in your project, you can install it through Unity's Package Manager. You can open it by clicking the <strong class="bold">Window | Package Manager</strong> item in the toolbar.</li>
			</ol>
			<div>
				<div id="_idContainer484" class="IMG---Figure">
					<img src="image/Figure_10.16_B17146.jpg" alt="Figure 10.16 – Opening Package Manager&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.16 – Opening Package Manager</p>
			<ol>
				<li value="2">Then, click the <strong class="bold">+</strong> in the upper-left corner to open the drop-down menu, and select the <strong class="bold">Add package from git URL…</strong> item in the drop-down menu.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer485" class="IMG---Figure">
					<img src="image/Figure_10.17_B17146.jpg" alt="Figure 10.17 – Add package from git URL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.17 – Add package from git URL</p>
			<ol>
				<li value="3">Enter <strong class="source-inline">com.unity.nuget.newtonsoft-json</strong> in the input box that appears, click the <strong class="bold">Add</strong> button, and wait for Package Manager to install this package.</li>
			</ol>
			<div>
				<div id="_idContainer486" class="IMG---Figure">
					<img src="image/Figure_10.18_B17146.jpg" alt="Figure 10.18 – Adding Newtonsoft.Json&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.18 – Adding Newtonsoft.Json</p>
			<ol>
				<li value="4">After installing the <a id="_idIndexMarker894"/>package in the project, we can use the <strong class="source-inline">Newtonsoft.Json</strong> framework in our C# script, so let's go back to <strong class="source-inline">JsonUtilityLimitationsSample.cs</strong> and update the code:<p class="source-code">using UnityEngine;</p><p class="source-code"><strong class="bold">using Newtonsoft.Json;</strong></p><p class="source-code">public class JsonUtilityLimitationsSample :</p><p class="source-code">  MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">      var playerData = new PlayerData("player1", 50,</p><p class="source-code">        100, 100);</p><p class="source-code">      var teamData = new TeamData();</p><p class="source-code">      teamData.Players.Add(playerData);</p><p class="source-code">      teamData.Roles.Add("leader", playerData);</p><p class="source-code">      var jsonStringFromTeamData =</p><p class="source-code">        <strong class="bold">JsonConvert.SerializeObject(teamData);</strong></p><p class="source-code">      Debug.Log(jsonStringFromTeamData);</p><p class="source-code">      var jsonStringFromList =</p><p class="source-code">        <strong class="bold">JsonConvert.SerializeObject(teamData.Players);</strong></p><p class="source-code">      Debug.Log(jsonStringFromList);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Let's break down the code as follows:</p>
			<ul>
				<li>We add <a id="_idIndexMarker895"/>the <strong class="source-inline">Newtonsoft.Json</strong> namespace with the <strong class="source-inline">using</strong> keyword, which provides classes and methods for JSON serialization and deserialization.</li>
				<li>In the <strong class="source-inline">Start</strong> method, we replace the <strong class="source-inline">JsonUtility.ToJson</strong> method with the <strong class="source-inline">JsonConvert.SerializeObject</strong> method that is defined in the <strong class="source-inline">Newtonsoft.Json</strong> namespace.</li>
			</ul>
			<ol>
				<li value="5">Run the game. You will find that the <strong class="source-inline">Roles</strong> dictionary field of the <strong class="source-inline">TeamData</strong> object is serialized as expected, while the <strong class="source-inline">Players</strong> list as the root element is also serialized correctly.</li>
			</ol>
			<p class="figure-caption">   </p>
			<div>
				<div id="_idContainer487" class="IMG---Figure">
					<img src="image/Figure_10.19_B17146.jpg" alt="Figure 10.19 – Newtonsoft.Json works correctly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.19 – Newtonsoft.Json works correctly</p>
			<p>In this section, we have explained what Unity's serialization system is and how to use JSON serialization in your Unity project. Now I think you're ready to continue exploring how assets in your game project are managed by the Unity engine!</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor186"/>The assets workflow in Unity</h1>
			<p>Unity's assets<a id="_idIndexMarker896"/> workflow is another very interesting topic that is also very closely related to serialization. So, what is an <strong class="source-inline">asset</strong> in Unity? If you look at a Unity project, you will find that there is a folder called <strong class="source-inline">Assets</strong> in the root directory of this project, and an asset is a file stored in this folder. </p>
			<p>In Unity development, assets can be divided into the following two categories according to their sources: </p>
			<ul>
				<li>External assets that are imported into Unity; the most common in this case are <strong class="source-inline">models,</strong> <strong class="source-inline">textures,</strong> and <strong class="source-inline">audio</strong>. They are often created by third-party tools, such as <strong class="source-inline">Maya,</strong> <strong class="source-inline">3Ds Max,</strong> and <strong class="source-inline">Photoshop</strong>, and then imported into Unity for use. </li>
				<li>Assets created by Unity itself, such as <strong class="source-inline">Prefab</strong> and <strong class="source-inline">Scene</strong> files.</li>
			</ul>
			<p>Whether it's an imported asset or an asset created by Unity, Unity does the following three things with them:</p>
			<ol>
				<li value="1">Unity will assign a GUID to this asset.</li>
				<li>Then, a meta file will be created automatically by Unity to store some additional information about the asset, such as the GUID and the import settings of this asset. <em class="italic">Figure 10.20</em> shows an example of an automatically created meta file. When a PNG file named <strong class="source-inline">SampleTexture</strong> is imported into the Unity project, Unity automatically creates a meta file and names it <strong class="source-inline">SampleTexture.PNG.meta</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer488" class="IMG---Figure">
					<img src="image/Figure_10.20_B17146.jpg" alt="Figure 10.20 – A meta file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.20 – A meta file</p>
			<ol>
				<li value="3">Finally, Unity will <a id="_idIndexMarker897"/>process the asset file, convert its content into an internal representation in Unity, and store the internal representation in the <strong class="source-inline">Library</strong> folder in the project root. We will cover this in detail when we introduce the <strong class="source-inline">Library</strong> folder later.</li>
			</ol>
			<div>
				<div id="_idContainer489" class="IMG---Figure">
					<img src="image/Figure_10.21_B17146.jpg" alt="Figure 10.21 – The Library folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.21 – The Library folder</p>
			<p>Armed with an understanding of Unity's assets workflow, let's introduce the three things involved in this workflow in more detail: GUID and File ID, meta files, and the <strong class="source-inline">Libary</strong> folder.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor187"/>GUID and File ID</h2>
			<p>GUID<a id="_idIndexMarker898"/> and File ID are obviously an important topic when we discuss Unity's asset workflow. This is<a id="_idIndexMarker899"/> because no matter whether we use Unity to create an asset or import an external asset, Unity has to uniquely identify this asset, and this unique value is the GUID. File ID is often used together with GUID; it is not used to identify an asset like GUID, but is used to identify a reference to another object within an object. </p>
			<p>Now that we have a brief understanding of GUID and File ID, it's time to move on to exploring GUID and File ID in more detail!</p>
			<h3>GUID</h3>
			<p>As we just mentioned, Unity assigns a GUID<a id="_idIndexMarker900"/> to each asset in the <strong class="source-inline">Assets</strong> folder as the asset's <a id="_idIndexMarker901"/>identifier. We can use a text editor to open the meta file associated with this asset to find the GUID of this asset within the Unity engine.</p>
			<p>Let's now perform the following steps to create a new C# script as an asset and check the <strong class="source-inline">GUID</strong> of this C# script in Unity:</p>
			<ol>
				<li value="1">Create a new C# script in the <strong class="source-inline">Scripts</strong> folder, name it <strong class="source-inline">AssetSample</strong>, and add the following to this script. As shown in the following code, this class has a <strong class="source-inline">Texture</strong> field:<p class="source-code">public class AssetSample : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    [SerializeField]</p><p class="source-code">    private <strong class="bold">Texture _texture</strong>;</p><p class="source-code">}</p></li>
				<li>A meta file called <strong class="source-inline">AssetSample.cs.meta</strong> is created next to the C# script file in the file explorer, as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer490" class="IMG---Figure">
					<img src="image/Figure_10.22_B17146.jpg" alt="Figure 10.22 – The AssetSample.cs.meta file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.22 – The AssetSample.cs.meta file</p>
			<ol>
				<li value="3">Open <a id="_idIndexMarker902"/>the <strong class="source-inline">AssetSample.cs.meta</strong> file in a text editor, and you will discover that the <a id="_idIndexMarker903"/>GUID of this C# script asset in Unity is <strong class="source-inline">e35f96b75211edd4bad6451a26675090</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer491" class="IMG---Figure">
					<img src="image/Figure_10.23_B17146.jpg" alt="Figure 10.23 – The GUID of this C# script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.23 – The GUID of this C# script</p>
			<p>After reading this, you should know how to find the GUID of an asset in Unity; however, where is the File ID stored, and how does Unity use it to create and maintain references between objects? So, let's continue our journey with another example.</p>
			<h3>File ID</h3>
			<p>We mentioned earlier that Unity<a id="_idIndexMarker904"/> uses a <strong class="source-inline">File ID</strong> to refer to another object within an <a id="_idIndexMarker905"/>object, which is the unique ID of the object referenced within that object. </p>
			<p>Now, let's take a look at an example to learn how to find the <strong class="source-inline">File IDs</strong> and how Unity uses the <strong class="source-inline">File IDs</strong> to maintain the reference relationship between objects. In this example, we will still use the <strong class="source-inline">AssetSample</strong> script we just created, so now let's get started!</p>
			<ol>
				<li value="1">First, create a new GameObject in the Scene and name it <strong class="source-inline">AssetSampleGameObject</strong>. You already know that a <strong class="source-inline">Transform</strong> component is automatically created and attached to this GameObject, as shown in <em class="italic">Figure 10.24</em>:</li>
			</ol>
			<div>
				<div id="_idContainer492" class="IMG---Figure">
					<img src="image/Figure_10.24_B17146.jpg" alt="Figure 10.24 – Creating an AssetSampleGameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.24 – Creating an AssetSampleGameObject</p>
			<ol>
				<li value="2">Attach an <strong class="source-inline">AssetSample</strong> component to <strong class="source-inline">AssetSampleGameObject</strong>, and then assign a texture from the <strong class="bold">Project</strong> window to the <strong class="source-inline">Texture</strong> field of <strong class="source-inline">AssetSample</strong>. Then, attach another <strong class="source-inline">AssetSample</strong> component to the same GameObject; however, this time, we set the <strong class="bold">Texture</strong> field of <strong class="source-inline">AssetSample</strong> to <strong class="bold">None</strong> and save the Scene.</li>
			</ol>
			<div>
				<div id="_idContainer493" class="IMG---Figure">
					<img src="image/Figure_10.25_B17146.jpg" alt="Figure 10.25 – Adding AssetSample components to the GameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.25 – Adding AssetSample components to the GameObject</p>
			<ol>
				<li value="3">Make sure your<a id="_idIndexMarker906"/> project's <strong class="bold">Asset Serialization</strong> mode <a id="_idIndexMarker907"/>is now <strong class="bold">Force Text</strong> (we covered this topic in the <em class="italic">YAML and binary serialization in Unity </em>section), and then use a text editor to open the Scene file from <strong class="bold">File Explorer</strong>. You will see a lot of content in the Scene file, as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer494" class="IMG---Figure">
					<img src="image/Figure_10.26_B17146.jpg" alt="Figure 10.26 – Opening the Scene file in a text editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.26 – Opening the Scene file in a text editor</p>
			<p>This file gives us a lot of<a id="_idIndexMarker908"/> information, recording the GameObjects, components, and <a id="_idIndexMarker909"/>referenced assets in the Scene. So let's break it down:</p>
			<ul>
				<li>First of all, we can find the record of the GameObject called <strong class="source-inline">AssetSampleGameObject</strong> in the file. In the following screenshot, you can see that there are three components attached to this GameObject, with File IDs of <strong class="source-inline">306521988</strong>, <strong class="source-inline">306521989</strong>, and <strong class="source-inline">306521990</strong>, respectively:</li>
			</ul>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer495" class="IMG---Figure">
					<img src="image/Figure_10.27_B17146.jpg" alt="Figure 10.27 – The AssetSampleGameObject record&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.27 – The AssetSampleGameObject record</p>
			<ul>
				<li>If we search<a id="_idIndexMarker910"/> these three <strong class="source-inline">File IDs</strong>, we can find records for three<a id="_idIndexMarker911"/> components in this file – a <strong class="source-inline">Transform</strong> component, which is created and attached to this GameObject when the GameObject is created, and two <strong class="source-inline">MonoBehaviour</strong> components, which represent C# script components.</li>
			</ul>
			<div>
				<div id="_idContainer496" class="IMG---Figure">
					<img src="image/Figure_10.28_B17146.jpg" alt="Figure 10.28 – File IDs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.28 – File IDs</p>
			<ul>
				<li>So, what is the difference between File ID and GUID? If we focus on these two <strong class="source-inline">MonoBehaviour</strong> components, we can see that the <strong class="source-inline">m_Script</strong> field of both components references the same C# script with a GUID of <strong class="source-inline">e35f96b75211edd4bad6451a26675090</strong>.</li>
			</ul>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer497" class="IMG---Figure">
					<img src="image/Figure_10.29_B17146.jpg" alt="Figure 10.29 – The MonoBehaviour components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.29 – The MonoBehaviour components</p>
			<p>Therefore, we <a id="_idIndexMarker912"/>can find that although these two component objects <a id="_idIndexMarker913"/>refer to the same C# script, namely, <strong class="source-inline">AssetSample</strong>, they are two different instances of <strong class="source-inline">AssetSample</strong>; the file ID of the first <strong class="source-inline">MonoBehaviour</strong> component object is <strong class="source-inline">306521989</strong>, and the file ID of the second <strong class="source-inline">MonoBehaviour</strong> component object is <strong class="source-inline">306521990</strong>.</p>
			<p>Moreover, the <strong class="source-inline">_texture</strong> field of one instance refers to a texture asset, and the <strong class="source-inline">_texture</strong> field of the other instance does not refer to any texture asset. </p>
			<p>By reading this section, we learned that Unity uses GUID to identify an asset and File ID to identify a referenced object.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor188"/>Meta files</h2>
			<p>We already <a id="_idIndexMarker914"/>know that a meta <a id="_idIndexMarker915"/>file records the GUID of its associated asset in a Unity project, and that a meta file also records the import settings of this asset. In this section, we will talk about meta files that look inconspicuous but are actually very important.</p>
			<h3>Meta files and version management</h3>
			<p>A common mistake developers new to Unity make is not paying attention to these autogenerated meta files. One such example is ignoring meta files when using Git or other version control<a id="_idIndexMarker916"/> systems to manage the version of the Unity project. </p>
			<p>If you remember from the previous section, Unity assigns each asset a GUID, uses this GUID to identify the asset, and records this GUID in the meta file. </p>
			<p>So, if your version management system does not include meta files, your Unity development progress may be disrupted. </p>
			<p>To illustrate this, let's imagine a scenario where, when a Unity project that does not contain meta files is cloned from a remote repository to your colleague's local machine, the Unity Editor will reimport those assets and assign them new GUIDs and create meta files to store this information. As a result, references that previously existed between objects in your Unity project will <a id="_idIndexMarker917"/>no longer be valid.</p>
			<p>As an example, assuming that the <strong class="source-inline">AssetSample.cs.meta</strong> meta file of the <strong class="source-inline">AssetSample</strong> C# script we created earlier is not managed by the version management system, then you will encounter the <strong class="source-inline">Script Missing</strong> error, as shown in <em class="italic">Figure 10.30</em>, after cloning and opening the project on another computer:</p>
			<div>
				<div id="_idContainer498" class="IMG---Figure">
					<img src="image/Figure_10.30_B17146.jpg" alt="Figure 10.30 – The Script Missing error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.30 – The Script Missing error</p>
			<p>At this point, the script actually exists, but since its GUID has been regenerated, the previous reference relationship is invalid.</p>
			<p>Therefore, when developing a Unity project, please make sure that the meta files are managed by your version management tool.</p>
			<h3>Import settings in meta files</h3>
			<p>In addition to<a id="_idIndexMarker918"/> storing the GUID of an asset, a meta file also stores the import settings of this asset. Of course, the meta files that will be discussed in this subsection mainly refer to the meta files of assets created in third-party software and that are then imported into the Unity Editor, such as models, textures, and audio.</p>
			<p>Let's use a meta file of an audio asset as an example to see how the import settings of the asset are saved.</p>
			<p>The audio asset we are using here is from Unity's Asset Store and you can download it from here: <a href="https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047">https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047</a>.</p>
			<div>
				<div id="_idContainer499" class="IMG---Figure">
					<img src="image/Figure_10.31_B17146.jpg" alt="Figure 10.31 – Audio pack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.31 – Audio pack</p>
			<p>After importing the <a id="_idIndexMarker919"/>audio into the Unity project, we can select the first audio file in the <strong class="source-inline">Ultra SF Game Audio Weapons Pack v.1</strong> folder to open the audio's Inspector window in the Unity Editor, which shows the asset's import settings. Then we use a text editor to open the meta file of the same audio asset in the folder explorer and, as shown in <em class="italic">Figure 10.32</em>, we can see that <strong class="source-inline">AudioImporter</strong> in the meta file corresponds to the import settings in the editor:</p>
			<div>
				<div id="_idContainer500" class="IMG---Figure">
					<img src="image/Figure_10.32_B17146.jpg" alt="Figure 10.32 – WPN_SCI-FI_FIRE_01 audio's import settings and meta file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.32 – WPN_SCI-FI_FIRE_01 audio's import settings and meta file</p>
			<p>The import settings of a texture asset and a model asset are also stored in their meta files. The following screenshot shows the import settings for a texture and a model:</p>
			<div>
				<div id="_idContainer501" class="IMG---Figure">
					<img src="image/Figure_10.33_B17146.jpg" alt="Figure 10.33 – Import settings of a texture (left) and the import settings of a model (right)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.33 – Import settings of a texture (left) and the import settings of a model (right)</p>
			<p>Since the meta file <a id="_idIndexMarker920"/>stores the import settings of the asset, once we modify the import settings of the asset in the Unity Editor, the corresponding meta file will be updated. </p>
			<p>The import settings often affect how Unity processes these assets, so it is important to ensure that the import settings can be managed according to the requirements of the project. For example, in many mobile game projects, we should check the <strong class="bold">Force To Mono</strong> option on the audio import settings to reduce the memory usage of this audio file.</p>
			<p>Next, let's take a look at how to manage import settings through a C# script in Unity.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor189"/>The AssetPostprocessor class and the import pipeline</h2>
			<p>Unity provides<a id="_idIndexMarker921"/> the <strong class="source-inline">AssetPostprocessor</strong> class for game developers to <a id="_idIndexMarker922"/>hook into the assets import pipeline in Unity. When importing an asset, we can manage the import pipeline according to the asset type.</p>
			<p>In the following example, we will create a new C# script to set the <strong class="bold">Force To Mono</strong> option enabled in the import settings of all audio files in the Unity projec:</p>
			<ol>
				<li value="1">Create a subfolder in the <strong class="source-inline">Scripts</strong> folder and name it <strong class="source-inline">Editor</strong>. This is because the C# class that we will create inherits from the <strong class="source-inline">AssetPostprocessor</strong> class, which is a class for the editor, so it needs to be placed in an <strong class="source-inline">Editor</strong> folder. </li>
			</ol>
			<div>
				<div id="_idContainer502" class="IMG---Figure">
					<img src="image/Figure_10.34_B17146.jpg" alt="Figure 10.34 – Creating an Editor folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.34 – Creating an Editor folder</p>
			<ol>
				<li value="2">Double-click on the <strong class="source-inline">Editor</strong> folder to enter it, create a new C# script in this folder, name<a id="_idIndexMarker923"/> it <strong class="source-inline">AssetImporterSample</strong>, and then add the following to this script:<p class="source-code">using <strong class="bold">UnityEditor</strong>;</p><p class="source-code">public class AssetImporterSample : <strong class="bold">AssetPostprocessor</strong></p><p class="source-code">{</p><p class="source-code">    private void <strong class="bold">OnPreprocessAudio</strong>()</p><p class="source-code">    {</p><p class="source-code">        var audioImporter =</p><p class="source-code">          <strong class="bold">(AudioImporter)</strong>assetImporter;</p><p class="source-code">        if(audioImporter == null)</p><p class="source-code">        {</p><p class="source-code">            return;</p><p class="source-code">        }</p><p class="source-code">        audioImporter.<strong class="bold">forceToMono</strong> = true;</p><p class="source-code">        audioImporter.SaveAndReimport();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Let's break down how this works:</p>
			<ul>
				<li>First, the code is using the <strong class="source-inline">UnityEditor</strong> namespace. This is because the <strong class="source-inline">AssetPostprocessor</strong> class is defined in this namespace, which also means <a id="_idIndexMarker924"/>that the <strong class="source-inline">AssetImporterSample</strong> C# script is used in the Unity Editor and not at runtime.</li>
				<li>The <strong class="source-inline">AssetImporterSample</strong> class inherits the <strong class="source-inline">AssetPostprocessor</strong> class and implements the <strong class="source-inline">OnPreprocessAudio</strong> method, which will be called before the audio asset is imported. We can also implement other similar methods to be called when other asset types will be imported. For example, the <strong class="source-inline">OnPreprocessTexture</strong> method will be called before the texture asset is imported, and the <strong class="source-inline">OnPreprocessModel</strong> method will be called before the model asset is imported.</li>
				<li>In the <strong class="source-inline">OnPreprocessAudio</strong> method, we can get an instance of <strong class="source-inline">AudioImporter</strong>, set the <strong class="source-inline">forceToMono</strong> option to <strong class="source-inline">true</strong>, and then save and re-import the asset to ensure that the new import settings for the asset take effect.</li>
			</ul>
			<ol>
				<li value="3">Save the C# script and the Unity Editor should modify the import settings of these audio assets in the project and then re-import them, as shown in <em class="italic">Figure 10.35</em>:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer503" class="IMG---Figure">
					<img src="image/Figure_10.35_B17146.jpg" alt="Figure 10.35 – Importing audio assets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.35 – Importing audio assets</p>
			<ol>
				<li value="4">Let's now select an audio file to check its import settings. As shown in <em class="italic">Figure 10.36</em>, the new import settings work as expected:</li>
			</ol>
			<div>
				<div id="_idContainer504" class="IMG---Figure">
					<img src="image/Figure_10.36_B17146.jpg" alt="Figure 10.36 – New import settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.36 – New import settings</p>
			<p>In this subsection, we introduced how to use C# code to manage the asset import pipeline. Next, let's explore another assets workflow topic in Unity – the <strong class="source-inline">Library</strong> folder. </p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor190"/>The Library folder</h2>
			<p>In a <a id="_idIndexMarker925"/>Unity project, Unity will process and convert the external assets into Unity internal format assets and save them in<a id="_idIndexMarker926"/> the <strong class="source-inline">Library</strong> folder. Because the data stored in the <strong class="source-inline">Library</strong> folder is cached data that can always be regenerated from the source asset files based on the import settings, the <strong class="source-inline">Library</strong> folder should generally not be included in a version management system.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In addition to the <strong class="source-inline">Library</strong> folder, there are some other Unity folders that need to be excluded from version management, including <strong class="source-inline">Temp, Obj, </strong>and <strong class="source-inline">Logs</strong>. If you are using Git as your version management tool, you can find the <strong class="source-inline">.gitignore</strong> file for Unity projects at this link: <a href="https://github.com/github/gitignore/blob/main/Unity.gitignore">https://github.com/github/gitignore/blob/main/Unity.gitignore</a>.</p>
			<p>You can find the <strong class="source-inline">Library</strong> folder in <a id="_idIndexMarker927"/>the root directory of your Unity project, as shown in <em class="italic">Figure 10.37</em>. If there is no <strong class="source-inline">Libary</strong> folder in the root directory of your Unity project, you need to open the project with the Unity Editor. The Unity Editor will import the assets in the <strong class="source-inline">Assets</strong> folder and generate the <strong class="source-inline">Library</strong> folder automatically.</p>
			<div>
				<div id="_idContainer505" class="IMG---Figure">
					<img src="image/Figure_10.37_B17146.jpg" alt="Figure 10.37 – The Library folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.37 – The Library folder</p>
			<p>Double-click the <strong class="source-inline">Library</strong> folder to enter it and you will see the <strong class="source-inline">ScriptAssemblies</strong> subfolder, which saves the assemblies of the C# code in the project, and you can also see the <strong class="source-inline">PackageCache</strong> subfolder, which saves the cache of Unity packages used by the project. In addition to these, you also can see the <strong class="source-inline">Artifacts</strong> subfolder, where the assets processed by Unity are saved.</p>
			<div>
				<div id="_idContainer506" class="IMG---Figure">
					<img src="image/Figure_10.38_B17146.jpg" alt="Figure 10.38 – The Artifacts folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.38 – The Artifacts folder</p>
			<p>In this section, we introduced Unity's assets workflow, covering topics such as GUIDs, File IDs, meta files, and the <strong class="source-inline">Library</strong> folder. Next, let's take a look at the special folders created and managed by developers related to assets management in Unity.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor191"/>Introducing the special folders in Unity</h1>
			<p>We already covered some of these special folders related to scripting in Unity in <a href="B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025"><em class="italic">Chapter 2</em></a>, <em class="italic">Scripting Concepts in Unity</em>. In this section, we will introduce the remaining special folders, which are related to asset management in Unity.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor192"/>Resources folder</h2>
			<p>First, let's take a look at<a id="_idIndexMarker928"/> the <strong class="source-inline">Resources</strong> folder in Unity. <strong class="source-inline">Resources</strong> is a special folder name in Unity, but Unity does not automatically create a <strong class="source-inline">Resources</strong> folder for you. If you want to use a <strong class="source-inline">Resources</strong> folder to manage assets, you need to create it yourself. It should be noted that there can be multiple <strong class="source-inline">Resources</strong> folders in the <strong class="source-inline">Assets</strong> directory in a Unity project.</p>
			<p>Unity provides the <strong class="source-inline">Resources.Load</strong> method to load assets in <strong class="source-inline">Resources</strong> folders. Next, we will use an example to learn how to use <strong class="source-inline">Resources</strong> folders to manage assets:</p>
			<ol>
				<li value="1">Create a new <a id="_idIndexMarker929"/>folder named <strong class="source-inline">Resources</strong> by clicking the <strong class="bold">Create | Folder</strong> item in the <strong class="bold">Project</strong> window.</li>
			</ol>
			<div>
				<div id="_idContainer507" class="IMG---Figure">
					<img src="image/Figure_10.39_B17146.jpg" alt="Figure 10.39 – Creating a Resources folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.39 – Creating a Resources folder</p>
			<ol>
				<li value="2">Create an empty GameObject, name it <strong class="source-inline">SamplePrefab</strong>, and drag it into the <strong class="source-inline">Resources</strong> folder to create a new prefab, as shown in <em class="italic">Figure 10.40</em>:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer508" class="IMG---Figure">
					<img src="image/Figure_10.40_B17146.jpg" alt="Figure 10.40 – SamplePrefab &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.40 – SamplePrefab </p>
			<ol>
				<li value="3">Create a new<a id="_idIndexMarker930"/> C# script in the <strong class="bold">Scripts</strong> folder, name it <strong class="source-inline">ResourcesLoadExample</strong>, and add the following to this script:<p class="source-code">using UnityEngine;</p><p class="source-code">public class ResourcesLoadExample : MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    private GameObject _gameObjectInstance;</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        var samplePrefab =</p><p class="source-code">          <strong class="bold">Resources.Load&lt;GameObject&gt;("SamplePrefab");</strong></p><p class="source-code">        if(samplePrefab != null)</p><p class="source-code">        {</p><p class="source-code">            _gameObjectInstance =</p><p class="source-code">              Instantiate(samplePrefab);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Let's break<a id="_idIndexMarker931"/> down how this works:</p>
			<ol>
				<li>In the <strong class="source-inline">Start</strong> method, we call the <strong class="source-inline">Resources.Load</strong> method and pass the path to the asset to load as an argument to this method, which is <strong class="source-inline">SamplePrefab</strong>.</li>
				<li>Then, if the prefab asset is loaded, we instantiate it to create a new GameObject in the game Scene.</li>
			</ol>
			<ol>
				<li value="4">Create a new GameObject and attach the <strong class="source-inline">ResourcesLoadExample</strong> script to it. Run the game in the Unity Editor by clicking the <strong class="bold">Play</strong> button. We can see that a new instance of the prefab is created as expected.</li>
			</ol>
			<div>
				<div id="_idContainer509" class="IMG---Figure">
					<img src="image/Figure_10.41_B17146.jpg" alt="Figure 10.41 – Loading assets from the Resources folders&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.41 – Loading assets from the Resources folders</p>
			<p>Through this example, we see that using <strong class="source-inline">Resources</strong> folders to manage assets is very convenient, especially when you need to develop a prototype quickly, but managing assets in a Unity project by using <strong class="source-inline">Resources</strong> folders is not recommended for the following reasons:</p>
			<ul>
				<li>When the <a id="_idIndexMarker932"/>Unity Editor builds the game, the assets in <strong class="source-inline">Resources</strong> folders will be included in the build, even if the assets are not used, so improper use of the <strong class="source-inline">Resources</strong> folder may cause the build game to be too large. In addition, it will also affect the game's startup speed.</li>
				<li>Using <strong class="source-inline">Resources</strong> folders will make incremental content upgrades to the game very difficult or impossible.</li>
			</ul>
			<p>Now that we have an understanding of the <strong class="source-inline">Resources</strong> folders, we know the situations in which they will be suitable, such as developing a rapid prototype, as well as its limitations.</p>
			<p>Next, we will continue to introduce another special folder in Unity, namely, <strong class="source-inline">StreamingAssets</strong></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor193"/>StreamingAssets folder</h2>
			<p>In Unity, <strong class="source-inline">StreamingAssets</strong> is also <a id="_idIndexMarker933"/>a special folder name. We actually already covered this in <a href="B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095"><em class="italic">Chapter 6</em></a>, <em class="italic">Integrating Audio and Video in a Unity Project</em>. In this subsection, we will discuss it in more detail.</p>
			<p>We mentioned earlier that Unity will process assets in the <strong class="source-inline">Assets</strong> folder in a format that the Unity engine understands, but there is an exception. </p>
			<p>The assets in the <strong class="source-inline">StreamingAssets</strong> folder in the Unity project will still be in the original format and these assets will not be built into the game along with the other assets when Unity builds the game. Instead, all assets in the folder will be copied to a specific folder on the target device. </p>
			<p>Since the location of this special folder is different on different platforms, Unity provides the <strong class="source-inline">Application.streamingAssetsPath</strong> property so that we can access the correct path to this folder from C# code. </p>
			<p>The following code <a id="_idIndexMarker934"/>snippet is from the example used in <a href="B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095"><em class="italic">Chapter 6</em></a>, <em class="italic">Integrating Audio and Video in a Unity Project</em>. We can see how to use <strong class="source-inline">Application.streamingAssetsPath</strong> in C# code:</p>
			<p class="source-code">    public void OnClickSetVideoURL()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _videoPlayer.url =</p>
			<p class="source-code">          Path.Combine(<strong class="bold">Application.streamingAssetsPath</strong>,</p>
			<p class="source-code">          _videoFileName);</p>
			<p class="source-code">    }</p>
			<p>Similar<a id="_idIndexMarker935"/> to the <strong class="source-inline">Resources</strong> folder, Unity does not automatically create the <strong class="source-inline">StreamingAssets</strong> folder for you. If you wish to use it, you need to create it yourself, as shown in <em class="italic">Figure 10.42</em>:</p>
			<div>
				<div id="_idContainer510" class="IMG---Figure">
					<img src="image/Figure_10.42_B17146.jpg" alt="Figure 10.42 – Creating a StreamingAssets folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.42 – Creating a StreamingAssets folder</p>
			<p>Then we can place an audio WAV file in the <strong class="source-inline">StreamingAssets</strong> folder. As you can see from the following screenshot, the icon of this WAV file is not the same as the icon of an audio clip in Unity that we are already familiar with. This is because Unity does not process the WAV file; it still maintains its original format.</p>
			<div>
				<div id="_idContainer511" class="IMG---Figure">
					<img src="image/Figure_10.43_B17146.jpg" alt="Figure 10.43 – Placing a WAV file in the StreamingAssets folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.43 – Placing a WAV file in the StreamingAssets folder</p>
			<p>In this section, we explored the <strong class="source-inline">Resources</strong> folder and the <strong class="source-inline">StreamingAssets</strong> folder, which are special folders in Unity, and understood that what they do can help you better develop games with Unity. </p>
			<p>Next, we'll cover another interesting topic; how to use Azure Blob storage in the Azure Cloud with Unity's Addressable Asset system.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor194"/>Azure Blob storage with Unity's Addressable Asset system</h1>
			<p>In this section, we'll cover the Azure Blob storage service in Microsoft's Azure Cloud and how to use it with Unity's Addressable Asset system.</p>
			<p><strong class="bold">Azure Blob storage</strong> is a<a id="_idIndexMarker936"/> type of Azure Storage account in Azure. Other types of Azure Storage<a id="_idIndexMarker937"/> accounts include <strong class="bold">queues</strong>, <strong class="bold">file shares</strong>, and <strong class="bold">tables</strong>. Among them, Blob<a id="_idIndexMarker938"/> storage is very suitable for storing large amounts of <a id="_idIndexMarker939"/>unstructured data such as binary data.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find additional information and resources about the Azure Storage account<a id="_idIndexMarker940"/> in Microsoft's Azure Cloud at <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction">https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction</a>.</p>
			<p>Unity's Addressable Asset system, as the name suggests, provides a convenient method for loading specific assets, whether on the local or remote server, according to a specific address. When discussing the <strong class="source-inline">Resources</strong> folder in the previous section, we discussed various limitations when using it in terms of managing assets, and the Addressable Asset system can solve these problems very well; for example, the size of the game package can be well controlled, there is no need to include unnecessary assets in game builds, and assets can be hosted on remote servers, such as the Azure Cloud, to incrementally update assets within the game.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before the Addressable Asset system was introduced, developers could also use <strong class="source-inline">AssetBundles</strong> to manage<a id="_idIndexMarker941"/> assets; <strong class="source-inline">AssetBundles</strong> is beyond the scope of what we need here, but if you're interested, you can find out more at <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html">https://docs.unity3d.com/Manual/AssetBundlesIntro.html</a>.</p>
			<p>Well, now we have an understanding of Azure Blob storage and the Addressable Asset system. Next, we will explore how to use Azure Blob storage to host assets and use the Addressable Asset system to manage them.</p>
			<p>Let's start!</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor195"/>Setting up an Azure Blob storage service</h2>
			<p>First, make sure<a id="_idIndexMarker942"/> you have an available Azure subscription. You can apply for a free Azure trial account on the page introduced at the beginning of this chapter. </p>
			<p>If everything is ready, we can create our first resource in Azure, namely, an <strong class="bold">Azure resource group</strong>.</p>
			<h3>Creating a new resource group</h3>
			<p>Usually, a resource<a id="_idIndexMarker943"/> group is our first resource in the Azure Cloud. This is because a resource group is a container for holding other Azure resources.</p>
			<p>We can create a resource group in just a few steps:</p>
			<ol>
				<li value="1">Sign in to the Azure portal page with your account at <a href="https://portal.azure.com/">https://portal.azure.com/</a>.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer512" class="IMG---Figure">
					<img src="image/Figure_10.44_B17146.jpg" alt="Figure 10.44 – Azure portal page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.44 – Azure portal page</p>
			<ol>
				<li value="2">The <a id="_idIndexMarker944"/>Azure portal page does not display the portal menu by default. We can click the <strong class="bold">Show portal menu</strong> button in the upper-left corner of the page to open the portal menu.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer513" class="IMG---Figure">
					<img src="image/Figure_10.45_B17146.jpg" alt="Figure 10.45 – Show portal menu&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.45 – Show portal menu</p>
			<ol>
				<li value="3">Select <strong class="bold">Resource groups</strong> from the portal menu.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer514" class="IMG---Figure">
					<img src="image/Figure_10.46_B17146.jpg" alt="Figure 10.46 – Selecting the Resource groups service&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.46 – Selecting the Resource groups service</p>
			<ol>
				<li value="4">The <a id="_idIndexMarker945"/><strong class="bold">Resource groups</strong> page will then open. Click the <strong class="bold">Create</strong> button on this page, as shown in <em class="italic">Figure 10.47</em>:</li>
			</ol>
			<div>
				<div id="_idContainer515" class="IMG---Figure">
					<img src="image/Figure_10.47_B17146.jpg" alt="Figure 10.47 – Creating a resource group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.47 – Creating a resource group</p>
			<ol>
				<li value="5">Then, you will see the <strong class="bold">Create a resource group</strong> page. Select your Azure subscription and enter the name of the resource group. Here, it is <strong class="source-inline">rg-unitybook-dev-001</strong>. Select the region of the resource group as <strong class="source-inline">(Asia Pacific) Australia East</strong> and then click on <strong class="bold">Review + create</strong> to verify the settings of this resource group and create it, as shown in <em class="italic">Figure 10.48</em>:</li>
			</ol>
			<div>
				<div id="_idContainer516" class="IMG---Figure">
					<img src="image/Figure_10.48_B17146.jpg" alt="Figure 10.48 – Creating a resource group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.48 – Creating a resource group</p>
			<p>We've <a id="_idIndexMarker946"/>created a resource group in Azure. Next, let's create an Azure Storage account resource.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find additional information about the naming convention in Microsoft's Azure Cloud at <a href="https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming">https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming</a>.</p>
			<h3>Creating a new Azure Storage account resource</h3>
			<p>In order to set up an <a id="_idIndexMarker947"/>Azure Blob storage service, we will need to create an Azure Storage account to provide a unique namespace in Azure for the assets that will be hosted first. </p>
			<p>We will perform the following steps:</p>
			<ol>
				<li value="1">Go back to the <a id="_idIndexMarker948"/>Azure portal page, repeat the steps introduced previously to open the portal menu, and then click <strong class="bold">Storage accounts</strong> this time, as shown in <em class="italic">Figure 10.49</em>:</li>
			</ol>
			<div>
				<div id="_idContainer517" class="IMG---Figure">
					<img src="image/Figure_10.49_B17146.jpg" alt="Figure 10.49 – Clicking Storage accounts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.49 – Clicking Storage accounts</p>
			<ol>
				<li value="2">The Storage accounts page will then open. Click the <strong class="bold">Create</strong> button on this page, as shown in <em class="italic">Figure 10.50</em>:</li>
			</ol>
			<p class="figure-caption"><strong class="source-inline"> </strong></p>
			<div>
				<div id="_idContainer518" class="IMG---Figure">
					<img src="image/Figure_10.50_B17146.jpg" alt="Figure 10.50 – Creating a storage account&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.50 – Creating a storage account</p>
			<ol>
				<li value="3">Similar to creating a resource group, on the <strong class="bold">Create a storage account</strong> page, we also need to select the Azure subscription first and then select the resource group we just created. Then, in the <strong class="bold">Instance details</strong> section, enter the name of the storage account and the location of the resource, <strong class="source-inline">unitybookchapter10</strong> and <strong class="source-inline">(Asia Pacific) Australia East</strong>, respectively. The <a id="_idIndexMarker949"/>other settings can be left as their defaults, and then click the <strong class="bold">Review + create</strong> button to create the resource.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer519" class="IMG---Figure">
					<img src="image/Figure_10.51_B17146.jpg" alt="Figure 10.51 – Creating a storage account&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.51 – Creating a storage account</p>
			<ol>
				<li value="4">We can<a id="_idIndexMarker950"/> click the notifications button in the upper-right corner of the page to view the progress of the resource deployment. When the resource is deployed, we can click <strong class="bold">Go to resource</strong> to go to the resource page.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer520" class="IMG---Figure">
					<img src="image/Figure_10.52_B17146.jpg" alt="Figure 10.52 – Notifications&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.52 – Notifications</p>
			<ol>
				<li value="5">As<a id="_idIndexMarker951"/> shown in <em class="italic">Figure 10.53</em>, a Storage account named <strong class="source-inline">unitybookchapter10</strong> is created:</li>
			</ol>
			<div>
				<div id="_idContainer521" class="IMG---Figure">
					<img src="image/Figure_10.53_B17146.jpg" alt="Figure 10.53 – The Storage account page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.53 – The Storage account page</p>
			<p>At this point, we have set up a Storage account resource in Azure. Next, let's set up Blob Storage.</p>
			<h3>Creating a container</h3>
			<p>As we mentioned at the beginning of this section, Blob Storage is a type of Azure Storage account, so we can find the settings for Blob Storage on the Storage account page we just opened. We can perform the <a id="_idIndexMarker952"/>following steps to set up Blob Storage:</p>
			<ol>
				<li value="1">First, we need to create a container, similar to a directory in the filesystem on our computers, to organize a group of files, and a container to organize a group of blobs on the Azure Cloud. Scroll down the menu on the left side of the Storage account page and, in the <strong class="bold">Data storage</strong> section, we can see four different storage types. Then, select <strong class="bold">Containers</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer522" class="IMG---Figure">
					<img src="image/Figure_10.54_B17146.jpg" alt="Figure 10.54 – Selecting containers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.54 – Selecting containers</p>
			<ol>
				<li value="2">Then, click the <strong class="bold">+ Container</strong> button, as shown in <em class="italic">Figure 10.55</em>:</li>
			</ol>
			<div>
				<div id="_idContainer523" class="IMG---Figure">
					<img src="image/Figure_10.55_B17146.jpg" alt="Figure 10.55 – Clicking the + Container button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.55 – Clicking the + Container button</p>
			<ol>
				<li value="3">In the <strong class="bold">New container</strong> panel, we enter <strong class="source-inline">remotedata</strong> as the name of the container, and for simplicity, we set <strong class="bold">Public access level</strong> to <strong class="bold">Blob</strong> to allow anonymous access to blobs inside the container.</li>
			</ol>
			<div>
				<div id="_idContainer524" class="IMG---Figure">
					<img src="image/Figure_10.56_B17146.jpg" alt="Figure 10.56 – Creating a new container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.56 – Creating a new container</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For security purposes, you should try to manage access to blobs in a more secure way, for example, by using an <strong class="bold">access key</strong> for authorization, or by using a <strong class="bold">Shared Access Signature (SAS)</strong> to <a id="_idIndexMarker953"/>delegate access. If you're interested, you can find out more at <a href="https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal">https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal</a>.</p>
			<p>Now that we have set up Azure Blob storage, we also need to use the Addressable Assets system in Unity to create asset packages and deploy them to Azure.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor196"/>Installing the Addressable Assets system package</h2>
			<p>By default, the <a id="_idIndexMarker954"/>Addressable Asset system is not available in a Unity project. So, we need to install the <strong class="source-inline">Addressables</strong> package first.</p>
			<p>As shown in <em class="italic">Figure 10.57</em>, we can find this package in Unity's Package Manager and install it in our project.</p>
			<div>
				<div id="_idContainer525" class="IMG---Figure">
					<img src="image/Figure_10.57_B17146.jpg" alt="Figure 10.57 – Installing the Addressables package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.57 – Installing the Addressables package</p>
			<p>Once installed, you<a id="_idIndexMarker955"/> can find the <strong class="bold">Addressables</strong> item in the <strong class="bold">Window</strong> menu of the Unity Editor.</p>
			<div>
				<div id="_idContainer526" class="IMG---Figure">
					<img src="image/Figure_10.58_B17146.jpg" alt="Figure 10.58 – Addressables item&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.58 – Addressables item</p>
			<p>Next, let's build addressable content by using the Addressable Assets system.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor197"/>Building addressable content </h2>
			<p>Building addressable <a id="_idIndexMarker956"/>content that can be hosted on the Azure Cloud sounds complicated, but we can break this task down further into the following tasks: </p>
			<ol>
				<li value="1">First, mark an asset as addressable.</li>
				<li>Then, enable the remote catalog.</li>
				<li>And finally, build the content.</li>
			</ol>
			<p>Now, let's move on to explore the first task.</p>
			<h3>Marking addressable assets</h3>
			<p>In the Unity <a id="_idIndexMarker957"/>Editor, we can easily mark an asset as addressable. Before we mark an addressable asset, let's create a new asset first. We can create a new cube in the Scene, name it <strong class="source-inline">SampleContentOnAzure</strong>, and drag it into the <strong class="bold">Project</strong> window to create a new prefab asset.</p>
			<p>Then, select this new prefab to open its <strong class="bold">Inspector</strong> window and you can see the <strong class="bold">Addressable</strong> checkbox in the window, as shown in <em class="italic">Figure 10.59</em>:</p>
			<div>
				<div id="_idContainer527" class="IMG---Figure">
					<img src="image/Figure_10.59_B17146.jpg" alt="Figure 10.59 – Marking an addressable asset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.59 – Marking an addressable asset</p>
			<p>By checking this checkbox, we will mark the prefab asset as addressable.</p>
			<h3>Enabling the remote catalog</h3>
			<p>Before <a id="_idIndexMarker958"/>enabling the remote catalog in the <a id="_idIndexMarker959"/>Addressable Asset settings, we can first create a new profile that defines variables such as <strong class="source-inline">RemoteLoadPath</strong>.</p>
			<h4>Creating a profile</h4>
			<p>So, let's start by creating <a id="_idIndexMarker960"/>a profile using the following steps:</p>
			<ol>
				<li value="1">In the toolbar, click on <strong class="bold">Window | Asset Management | Addressables | Profiles</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer528" class="IMG---Figure">
					<img src="image/Figure_10.60_B17146.jpg" alt="Figure 10.60 – Opening the Profiles window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.60 – Opening the Profiles window</p>
			<ol>
				<li value="2">In the <strong class="bold">Addressables Profiles</strong> window, click the <strong class="bold">Create</strong> button and select <strong class="bold">Profile</strong> in the drop-down menu to create a new profile.</li>
			</ol>
			<div>
				<div id="_idContainer529" class="IMG---Figure">
					<img src="image/Figure_10.61_B17146.jpg" alt="Figure 10.61 – Creating a new profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.61 – Creating a new profile</p>
			<ol>
				<li value="3">Then, rename this new profile to <strong class="bold">AzureCloud</strong> and enter the URL of the Azure Blob container in relation to the <strong class="bold">RemoteLoadPath</strong> variable.</li>
			</ol>
			<div>
				<div id="_idContainer530" class="IMG---Figure">
					<img src="image/Figure_10.62_B17146.jpg" alt="Figure 10.62 – Setting up the new profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.62 – Setting up the new profile</p>
			<p>If you don't know the URL<a id="_idIndexMarker961"/> of the Azure Blob container, you can find it on the container's <strong class="bold">Properties</strong> page in Azure, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer531" class="IMG---Figure">
					<img src="image/Figure_10.63_B17146.jpg" alt="Figure 10.63 – Container Properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.63 – Container Properties</p>
			<h4>Creating a new addressables group</h4>
			<p>Next, we also need to<a id="_idIndexMarker962"/> create a new <strong class="bold">addressables group</strong>, which is a container for addressable assets and their data, and can determine whether the assets within the group will be hosted on a remote server or stored locally. We can then place assets that need to be hosted on a remote server in this new group without changing the local location configured in the default group.</p>
			<p>Let's perform the following steps:</p>
			<ol>
				<li value="1">In the toolbar, click<a id="_idIndexMarker963"/> on <strong class="bold">Window | Asset Management | Addressables | Groups</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer532" class="IMG---Figure">
					<img src="image/Figure_10.64_B17146.jpg" alt="Figure 10.64 – Opening the Groups window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.64 – Opening the Groups window</p>
			<ol>
				<li value="2">In the <strong class="bold">Addressables Groups</strong> window, click the <strong class="bold">Create</strong> button, then select<strong class="bold"> Group &gt; Packed Assets</strong> to create a new group. </li>
			</ol>
			<div>
				<div id="_idContainer533" class="IMG---Figure">
					<img src="image/Figure_10.65_B17146.jpg" alt="Figure 10.65 – Creating a new group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.65 – Creating a new group</p>
			<p>Rename it to <strong class="bold">Azure Remote Group</strong>.</p>
			<div>
				<div id="_idContainer534" class="IMG---Figure">
					<img src="image/Figure_10.66_B17146.jpg" alt="Figure 10.66 – Azure Remote Group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.66 – Azure Remote Group</p>
			<ol>
				<li value="3">Change the active <a id="_idIndexMarker964"/>profile from <strong class="bold">Default</strong> to <strong class="bold">AzureCloud</strong> so that the Addressable Assets system can access the variables in <strong class="bold">AzureCloud</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer535" class="IMG---Figure">
					<img src="image/Figure_10.67_B17146.jpg" alt="Figure 10.67 – Activating the AzureCloud profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.67 – Activating the AzureCloud profile</p>
			<ol>
				<li value="4">Select the Azure remote group in the <strong class="bold">Addressables Groups</strong> window to open its <strong class="bold">Inspector</strong> window and set <strong class="bold">Content Packing &amp; Loading</strong> using the remote path defined in the <strong class="bold">AzureCloud</strong> profile.</li>
			</ol>
			<div>
				<div id="_idContainer536" class="IMG---Figure">
					<img src="image/Figure_10.68_B17146.jpg" alt="Figure 10.68 – Setting up the addressables group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.68 – Setting up the addressables group</p>
			<ol>
				<li value="5">By default, the marked addressable asset will be under <strong class="bold">Default Local Group</strong>; we need to move it to the Azure remote group we just created. </li>
			</ol>
			<div>
				<div id="_idContainer537" class="IMG---Figure">
					<img src="image/Figure_10.69_B17146.jpg" alt="Figure 10.69 – Moving the asset to Azure Remote Group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.69 – Moving the asset to Azure Remote Group</p>
			<ol>
				<li value="6">Finally, we also need to set a label, <strong class="bold">Azure</strong>, for this asset. You can think of it as a key so that we can then load this specific asset through the <strong class="source-inline">Addressables.LoadResourceLocationsAsync</strong> method with this key in C# code.</li>
			</ol>
			<div>
				<div id="_idContainer538" class="IMG---Figure">
					<img src="image/Figure_10.70_B17146.jpg" alt="Figure 10.70 – Setting a label&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.70 – Setting a label</p>
			<p>Now that we've set up the <a id="_idIndexMarker965"/>addressables group, next, let's move on to enable the ability to build remote content.</p>
			<h4>Enabling the Build Remote Catalog checkbox</h4>
			<ol>
				<li value="1">Back to the<a id="_idIndexMarker966"/> toolbar, click on <strong class="bold">Window | Asset Management | Addressables | Settings</strong> to open the <strong class="bold">Addressable Asset Settings</strong> window.</li>
			</ol>
			<div>
				<div id="_idContainer539" class="IMG---Figure">
					<img src="image/Figure_10.71_B17146.jpg" alt="Figure 10.71 – Opening the Addressable Asset Settings window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.71 – Opening the Addressable Asset Settings window</p>
			<ol>
				<li value="2">Scroll down<a id="_idIndexMarker967"/> the window and you will find the <strong class="bold">Content Update</strong> section. Then, check the <strong class="bold">Build Remote Catalog</strong> checkbox and set the <strong class="bold">Build Path</strong> and <strong class="bold">Load Path</strong> fields, respectively. </li>
			</ol>
			<div>
				<div id="_idContainer540" class="IMG---Figure">
					<img src="image/Figure_10.72_B17146.jpg" alt="Figure 10.72 – The Build Remote Catalog settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.72 – The Build Remote Catalog settings</p>
			<p>Now that you know how to enable the remote catalog in the Addressable Asset system, I think you're ready and can't wait to learn how to build the content. Let's go!</p>
			<h3>Building the content</h3>
			<p>It's finally <a id="_idIndexMarker968"/>time to build the content with the help of the following steps:</p>
			<ol>
				<li value="1">Go back <a id="_idIndexMarker969"/>to the <strong class="bold">Addressables Groups</strong> window, click <strong class="bold">Play Mode Script</strong>, and select <strong class="bold">Use Existing Build (requires built groups)</strong> in the drop-down menu, as shown in <em class="italic">Figure 10.73</em>:</li>
			</ol>
			<div>
				<div id="_idContainer541" class="IMG---Figure">
					<img src="image/Figure_10.73_B17146.jpg" alt="Figure 10.73 – Setting up the Play mode scripts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.73 – Setting up the Play mode scripts</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Unity provides developers with three build scripts to create play mode data. Here, we are using <strong class="bold">Use Existing Build</strong> mode, which best matches the game build deployed. You can find more information about build scripts in the Addressable Asset system at <a href="mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html">https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html</a>.</p>
			<ol>
				<li value="2">Then, click <strong class="bold">Build | New Build | Default Build Script</strong> to build the content.</li>
			</ol>
			<div>
				<div id="_idContainer542" class="IMG---Figure">
					<img src="image/Figure_10.74_B17146.jpg" alt="Figure 10.74 – Building the content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.74 – Building the content</p>
			<ol>
				<li value="3">Wait for the<a id="_idIndexMarker970"/> build to complete and then you can find the build in the <strong class="source-inline">ServerData</strong> folder in your project root.</li>
			</ol>
			<div>
				<div id="_idContainer543" class="IMG---Figure">
					<img src="image/Figure_10.75_B17146.jpg" alt="Figure 10.75 – ServerData&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.75 – ServerData</p>
			<p>Now that you know how to build addressable content in the Addressable Asset system, next, let's move on to deploy the content to the Azure Cloud.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor198"/>Deploying content to the Azure Cloud</h2>
			<p>To deploy the <a id="_idIndexMarker971"/>addressable content we just <a id="_idIndexMarker972"/>built to the Azure Cloud, follow these steps:</p>
			<ol>
				<li value="1">Navigate to the <strong class="bold">remotedata</strong> container we created in Azure and then click the <strong class="bold">Upload</strong> button.</li>
			</ol>
			<div>
				<div id="_idContainer544" class="IMG---Figure">
					<img src="image/Figure_10.76_B17146.jpg" alt="Figure 10.76 – The remotedata container page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.76 – The remotedata container page</p>
			<ol>
				<li value="2">An <strong class="bold">Upload blob</strong> panel will then appear. Select the files you want to upload and click the <strong class="bold">Upload</strong> button. </li>
			</ol>
			<div>
				<div id="_idContainer545" class="IMG---Figure">
					<img src="image/Figure_10.77_B17146.jpg" alt="Figure 10.77 – Uploading the content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.77 – Uploading the content</p>
			<ol>
				<li value="3">Wait for<a id="_idIndexMarker973"/> the upload to finish and <a id="_idIndexMarker974"/>then we can see our addressable content in the blobs list in the <strong class="bold">remotedata</strong> container.</li>
			</ol>
			<div>
				<div id="_idContainer546" class="IMG---Figure">
					<img src="image/Figure_10.78_B17146.jpg" alt="Figure 10.78 – The addressable content in Azure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.78 – The addressable content in Azure</p>
			<p>Now that you know how to deploy addressable content to the Azure Cloud, next, let's move on to exploring how to load content into your game from Azure.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor199"/>Loading addressable content from the Azure Cloud</h2>
			<p>Since we<a id="_idIndexMarker975"/> are using the Addressable<a id="_idIndexMarker976"/> Asset system to manage assets, loading content from the Azure Cloud into the game also needs to use the methods provided by the Addressable Asset system.</p>
			<p>Let's get started!</p>
			<ol>
				<li value="1">Create a<a id="_idIndexMarker977"/> new C# script in the <strong class="source-inline">Scripts</strong> folder, name<a id="_idIndexMarker978"/> it <strong class="source-inline">LoadAddressableContentFromAzureCloud</strong>, and add the following to this script:<p class="source-code">using UnityEngine;</p><p class="source-code">using UnityEngine.AddressableAssets;</p><p class="source-code">public class LoadAddressableContentFromAzureCloud :</p><p class="source-code">  MonoBehaviour</p><p class="source-code">{</p><p class="source-code">    [SerializeField]</p><p class="source-code">    <strong class="bold">private string _assetKey</strong>;</p><p class="source-code">    private void Start()</p><p class="source-code">    {</p><p class="source-code">        GetContentFromAzureCloud();</p><p class="source-code">    }</p><p class="source-code">    private async void GetContentFromAzureCloud()</p><p class="source-code">    {</p><p class="source-code">        var resourceLocations = await</p><p class="source-code"><strong class="bold">          Addressables.LoadResourceLocationsAsync</strong></p><p class="source-code"><strong class="bold">          (_assetKey</strong>).Task;</p><p class="source-code">        foreach (var resourceLocation in</p><p class="source-code">          resourceLocations)</p><p class="source-code">        {</p><p class="source-code">            await <strong class="bold">Addressables.InstantiateAsync</strong></p><p class="source-code"><strong class="bold">              (resourceLocation).</strong>Task;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>As you can see in the code, we first provide <strong class="source-inline">_assetKey</strong>, whose value is the label of the asset we set in the previous section. Then, we call the <strong class="source-inline">Addressables.LoadResourceLocationsAsync</strong> method to load content and <strong class="source-inline">Addressables.InstantiateAsync</strong> to instantiate a GameObject. </p>
			<ol>
				<li value="2">Create a new <a id="_idIndexMarker979"/>GameObject, attach the <strong class="source-inline">LoadAddressableContentFromAzureCloud</strong> script to it, set the<a id="_idIndexMarker980"/> value of <strong class="source-inline">Asset Key</strong> to <strong class="source-inline">Azure</strong>, and then run the game in the Unity Editor by clicking the <strong class="bold">Play</strong> button. We can see that a new instance of the prefab is created as expected.</li>
			</ol>
			<div>
				<div id="_idContainer547" class="IMG---Figure">
					<img src="image/Figure_10.79_B17146.jpg" alt="Figure 10.79 – Loading the addressable content from the Azure Cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.79 – Loading the addressable content from the Azure Cloud</p>
			<p>By reading this section, you learned what the Azure Blob storage service in the Microsoft Azure Cloud is and how to use it with Unity's Addressable Asset system to host and update game content. This section also brings us to the end of the chapter!</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor200"/>Summary</h1>
			<p>We've come a long way in this chapter. We started by introducing Unity's serialization system, discussing binary serialization, YAML serialization, and JSON serialization in Unity. Then we explored the assets workflow in Unity, covering important concepts such as GUIDs, File IDs, meta files, the <strong class="source-inline">Library</strong> folder, and how to manage the assets import pipeline from C# code. Next, we discussed the <strong class="source-inline">Resources</strong> folder and the <strong class="source-inline">StreamingAssets</strong> folder in detail, which are special folders in Unity, and understood that what they do can help you better develop games with Unity. Finally, we covered quite a bit about Azure Blob storage and Unity's Addressable Asset system, from how to create an Azure Blob storage service in the Azure Cloud to how to load the addressable content from Azure into a Unity project. It's been an amazing journey!</p>
			<p>The knowledge you have acquired in this chapter will help you choose the appropriate serialization mode in Unity according to your needs, manage assets reasonably, and use the Azure Cloud to achieve incremental updates of game content.</p>
			<p>In the next chapter, we will continue this wonderful journey to explore how to create games with Unity, Microsoft Game Dev, and the Azure Cloud.</p>
		</div>
	</body></html>