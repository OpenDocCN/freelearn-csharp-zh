- en: '*Chapter 5*: Exploring Architecture Design Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the key principles of solution architecture.
    We also explored the most frequently used UML diagrams and when we should use
    each one to create a view of the solution architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the top architecture patterns that you
    must know to build a solid software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the architectural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring key architecture patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to choose the right pattern for your product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand architectural patterns. We will
    enrich our knowledge by exploring the top architecture patterns with example use
    cases. Additionally, we will explain the criteria that we should focus on when
    choosing the right architecture pattern for our software product.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin learning about these patterns, first, let's understand what
    an architectural pattern actually is.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the architectural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An architectural pattern is a reusable solution architecture to a common problem
    that we might face in different business industries and on various occasions.
    It offers predefined guidelines along with a set of rules to establish the underlying
    structure of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important not to mix up the **.NET** design patterns and the architectural
    patterns. The first one represents a way in which to organize classes to make
    your source code more reliable, scalable, and easy to maintain, which will solve
    various problems that are internal to a specific component or module in our system.
    In comparison, the second one has a broader scope within the entire solution as
    it defines the high-level abstract structure of the solution. As a solution architect,
    you must possess knowledge of both types of patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design Patterns** develop classes with object-oriented principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architectural Patterns** help to define and maintain the overall structure
    of the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the different levels of architectural decisions
    that you might need to make as a solution architect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: The various levels of architectural decisions](img/Figure_5.01_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The various levels of architectural decisions'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can see that choosing the architectural pattern
    is one of the earliest decisions that you must take. Following this, you should
    choose the right technology stack that you will use to build the product. After
    that, you need to decide upon the type of application and the design patterns
    that will help you to organize the code and make it both reusable and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's begin by getting to know the most popular architecture patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Popular architecture patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore five popular architectural patterns. We will
    explain the core concept of each pattern, and then we will outline the key components
    of each architecture pattern. This should help you learn about the usefulness
    of architecture patterns and support you in choosing the right pattern for a proposed
    solution. Let's begin with a layered architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Layered architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of architecture is widely known by most architects and developers
    as **n-tier architecture**. It is used to structure the system into different
    layers, where each layer consists of a set of classes grouped in one assembly
    based on a specific context. The layers are structured horizontally so that each
    layer can consume services from one layer or the many layers that are beneath
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, this architecture consists of three main layers, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: A typical 3-tier layered architecture](img/Figure_5.02_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: A typical 3-tier layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding diagram, these are the three main layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation Layer**: This layer represents the component that is responsible
    for handling all user interactions through pages, menus, buttons, links, reports,
    forms, and more. It contains all the graphical designs and defines what the application
    looks like. It is the only layer that is visible to end users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business Layer**: This contains the business logic, business rules, and entities
    that define the behavior of the entire solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Access Layer**: This contains the code responsible for manipulating
    the database layer, which is where all the data is stored (for example, **SQL
    Server**, **Oracle**, and **MongoDB**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the 3-tier architecture in **Visual Studio**
    using the **Razor Web App** and **.NET 5** class libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: 3-tier architecture in Visual Studio](img/Figure_5.03_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: 3-tier architecture in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example architecture, the **data access layer** is the lowest
    layer and does not reference any of the other layers. It should contain the **ADO.NET**
    call or the **EntityFramework** call to manipulate the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: The **business layer** references the **data access layer**. It should contain
    all the business logic and entities; here, the entities represent the business
    objects mapped to the database tables. As for the **presentation layer**, this
    is the **web app** that contains the user interface. It references the **business
    layer** and doesn't allow direct calls to the **data access layer**. The **web
    app** can be an MVC app or Razer app, as it is possible to mix these two patterns
    in order to build a solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's get to know the presentation architecture in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the major issues we could face in a solution's **User** **Interface**
    (**UI**) is the presence of messy code that's difficult to maintain and scale.
    We have seen this in many web form solutions. This makes the architectural presentation
    pattern of the utmost importance, as it organizes the source code with a clear
    separation of responsibilities along with low coupling, which removes any complications
    and makes the UI code well organized and manageable.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture pattern helps to solve primary UI issues, such as logic that
    is coupled with the UI, state management, and the synchronization between the
    UI elements and the business entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of presentation patterns, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: The various types of presentation patterns](img/Figure_5.04_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: The various types of presentation patterns'
  prefs: []
  type: TYPE_NORMAL
- en: All of these patterns focus on decoupling the UI from the logic, which allows
    for clean **HTML** markup. Let's explore these three types in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: MVC (Model, View, Controller)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MVC pattern gives you full control over the markup. It is very popular,
    and Visual Studio has adopted it as the default template for when we want to create
    a new **ASP.NET** project. It splits the application into three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This encapsulates the business logic and contains the data to display
    in the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This displays the content through the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This handles the user interaction, works with the model for
    data updates, and, finally, selects a view to render the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the three main components and illustrates which
    ones reference the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: The MVC pattern](img/Figure_5.05_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: The MVC pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example MVC project template using **Visual Studio 2019** and **.NET
    5**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: A typical MVC project template in Visual Studio](img/Figure_5.06_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: A typical MVC project template in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example architecture, you can see that the three components
    are encapsulated within the same project but exist in different folders. You can
    also create a separate project for each layer and then configure the references.
  prefs: []
  type: TYPE_NORMAL
- en: MVP (Model, View, Presenter)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MVP pattern is a UI presentation architecture and is considered to be a
    derivation of the MVC pattern. It separates the architecture into three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This contains the business logic of the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This contains the interfaces that enclose the data properties, which
    we will either send to or receive from the UI. In comparison to the MVC pattern,
    it doesn''t include the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presenter**: This retrieves data from the **Model** and binds it back to
    the view. It works as an intermediate layer between the **Model** layer and the
    **View** layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the three main components of the MVP pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: The MVP pattern](img/Figure_5.07_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: The MVP pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an MVP project template in Visual Studio using the **Razor Web App**
    and **.NET 5** class libraries. Check the references between the projects in order
    to gain an understanding of the relationships between the three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: A typical MVP project template in Visual Studio](img/Figure_5.08_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: A typical MVP project template in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example architecture, you can see that the UI is located in
    the web app, which references the **Model**, the **View**, and the **Presenter**
    layers. The View layer doesn't reference any other project. It contains the interfaces
    that are implemented in the Presenter layer. The Model layer contains the business
    entities and the business logic; it doesn't reference any other project. As for
    the Presenter layer, this contains the actual implementation of the interfaces
    defined in the View layer. It references the Model and the View layers because
    it plays an intermediate role between them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the third type of presentation architecture next.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM (Model, View, ViewModel)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This architecture is also considered an extension of the MVC pattern. It contains
    three main components, too. It combines the best strengths of MVC and MVP by offering
    a high level of reusability and scalability. The key concept of this architecture
    is that it moves the logic out of the controller and into **ViewModel**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This contains the business rules and the model classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This contains the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**: This is an intermediate layer between **View** and **Model**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the three components and how they interact with
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: The MVVM pattern](img/Figure_5.09_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: The MVVM pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Session`, `ViewBag`, or `TempData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example project template of the MVVM pattern using **Visual Studio**,
    **MVC**, and **.NET 5**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: A typical MVVM project template in Visual Studio](img/Figure_5.10_B17366.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: A typical MVVM project template in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the Razor Pages project template as it follows the MVVM pattern.
    This enables two-way data binding since the code of the model and the controller
    are attached to the Razor page, which allows for a simple development experience
    with a separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the difference between these three types of presentation
    architectures so that you know which pattern you should use for your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get to know clean architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Clean architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the n-tier layered architecture, we learned that everything depends on the
    database layer, which is considered to be a transitive dependency. Clean architecture
    is considered domain-centric architecture. The business logic and application
    layers are at the center of the design. Instead of having the business logic depend
    on the data access layer, as is the case in the n-tier architecture, clean architecture
    inverts this dependency by forcing the infrastructure and other layers to depend
    on the application core.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a typical technique that can be used to visualize
    this architecture. It uses a series of concentric circles, which are similar to
    the rings of an onion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Clean architecture onion view](img/Figure_5.11_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Clean architecture onion view'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the circles represent the different components of
    the system, and the application core consists of the entities and the use cases.
    The key factor influencing this architecture is the dependency rule. It forces
    the dependency of the components to flow toward the center. The components in
    the inner circle should never depend on anything in the outer circle.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, if we declare a function or a class in the outer circle, it should
    not be visible in the inner circle. In the diagram, you can see how the dependencies
    flow toward the center from the most outer circle to where the use cases and the
    entities are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the key components of this architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The entities represent the business rules, such as objects and related methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use cases represent the application core, where all the use cases of the
    system are implemented. It manages the flow of data from and to the entities.
    This layer is not affected by the changes that might occur in the external layers,
    such as the database or the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface adapters are the layers that will contain the MVC components,
    such as the controllers, the views, and the presenters. This layer plays an intermediate
    role in converting the data coming from the use cases and entities into a suitable
    format for the external components, such as the database and the controllers.
    The models in this layer are used as data structures to exchange data between
    the use cases and the presenters or the views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frameworks and drivers represent the outermost layer of this architecture.
    This layer contains the database and all of the UI code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows a horizontal view of this architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Clean architecture horizontal layer view](img/Figure_5.12_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Clean architecture horizontal layer view'
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, there are two types of dependencies, which are represented
    by the style of the arrow. The solid arrow refers to compile-time dependencies,
    while the dashed arrow represents a runtime-only dependency. The **User Interface**
    layer deals with the interfaces defined in the application core with no direct
    access to the implementation in the **Infrastructure** layer. These interfaces
    are bound to the concrete implementation at runtime through **dependency injection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is a software design pattern. The main purpose of this
    pattern is that it allows you to have loosely coupled code that supports architecture
    patterns, such as clean architecture, to reduce the tight coupling between the
    layers. It replaces the hardcoded dependencies between the classes by using a
    builder object to initialize objects and then inject those dependencies at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a clean architecture solution template in **Visual
    Studio** with **.NET 5** and **Angular 10**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: A typical project template using clean architecture](img/Figure_5.13_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: A typical project template using clean architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore each project in this .NET solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most inner layer is the `Domain` project. It doesn''t reference any other
    layer, as shown in the following screenshot. On the right-hand side, you can see
    one of the entity''s classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.14: The entities project in clean architecture](img/Figure_5.14_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: The entities project in clean architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `Application` project. As you can see, it references the
    `Domain` project. It contains all of the application logic by defining the interfaces
    that will be implemented in the infrastructure layer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.15: The Application project in clean architecture](img/Figure_5.15_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: The Application project in clean architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `Infrastructure` layer, which contains the concrete implementation
    of the interfaces defined in the `Application` layer. As per the following screenshot,
    you can see that it references the `Application` layer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.16: The Infrastructure project in clean architecture](img/Figure_5.16_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: The Infrastructure project in clean architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The last layer is `WebUI` (please refer to *Figure 5.13*). This is a single-page
    application that uses `Application` layer and the `Infrastructure` layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many .NET solution templates support this architecture, which can be found
    on **GitHub** or **NuGet**. You can download one of the templates from NuGet to
    get started using the clean architecture. The following screenshot shows the NuGet
    command line required to install the same template that we used to explore this
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: The command line required to install the clean architecture
    solution template](img/Figure_5.17_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: The command line required to install the clean architecture solution
    template'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about clean architecture along with its main components.
    In the next section, we will explore microservices architecture, which is considered
    to be one of the modern architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The microservices architecture allows you to divide the solution into various
    components. Each component is completely independent of the other components,
    and it provides a particular service. The following diagram shows the microservices
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: The Microservices architecture style](img/Figure_5.18_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: The Microservices architecture style'
  prefs: []
  type: TYPE_NORMAL
- en: As per the preceding diagram, you can see that the microservices architecture
    consists of a collection of independent services. Each service is self-contained
    and should provide a single business capability within a business domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the characteristics of this architecture pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices** are small, autonomous, and loosely coupled services. Each
    service has its own code base, and it can be developed and maintained by a small
    team of developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each **service** should be self-contained and deployed separately. Updating
    one service won't require you to redeploy the entire solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services are responsible for having their own data access layer, as each
    service has a private database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal implementation of each service is not visible nor accessible by
    any other service. The communication between the services is achieved through
    proper APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Client** app has no direct access to the services. Consuming these services
    is achieved through the API gateway, which forwards the call to the appropriate
    services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a basic microservice project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: An example microservice project](img/Figure_5.19_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: An example microservice project'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can see an order microservice that is consumed
    by an e-commerce solution. The main components of this microservice project are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Models`: These are the data entities that hold the properties mapped to database
    fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderContext`: This derives the entity framework, `DBContexts`. It is a bridge
    between the entity order and the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderRepository`: This holds the CRUD functions, such as `GetOrder`, `CreateOrder`,
    and `UpdateOrder`. This class should implement the `IOrderRepository` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderController`: This is a class that is derived from `ControllerBase`. It
    contains all of the API RESTful actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Docker`: This is the container that should simplify the deployment and testing
    of the microservice by bundling it along with all its dependencies into a single
    unit. It allows you to run the microservice in an isolated environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web API requests are handled by the `OrderController` class. The controller
    will call a function inside the repository that will use `DBContexts` along with
    the model to communicate with the database in order to return, add, or edit the
    requested data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore service-oriented architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Service-Oriented Architecture** (**SOA**) allows you to consume services
    that are available in the network. Its structure is similar to n-tier architecture;
    the difference is that the presentation layer can''t call the business layer directly,
    that is, it can only do so through the services. The following diagram shows the
    SOA in a layered structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: SOA](img/Figure_5.20_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: SOA'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **Service Layer** is an abstraction layer located between
    the **Presentation Layer** and the **Business Layer**. With the existence of this
    layer, the **Presentation Layer** doesn't need to communicate directly with the
    **Business Layer**. In this scenario, you could change the **Business Layer**
    without affecting the **Presentation Layer**.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the difference between microservices architecture and SOA?* Well,
    the answer is the scope. Microservices architecture is a cloud-based architecture;
    it promotes autonomous services that are self-contained, which target the application
    scope. While the SOA has an enterprise scope, each service does not need to have
    an independent database. It can handle multiple business capabilities; this is
    not the case for microservices, which only handle one single business capability
    at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of .NET technologies that support you in the implementation
    of services (SOA):'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Web service**: This is based on the **Web Services Description Language**
    (**WSDL**) (which is also known as **XML Web Service**). It is a service layer
    that contains a set of functions that uses a standardized XML messaging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Communication Foundation** (**WCF**): This is part of the .NET Framework
    and is used to build service-oriented solutions. By using WCF, you can send any
    type of data, such as asynchronous messages, from one endpoint to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET RESTful Web API**: This is also part of the .NET Framework. It is
    used to build HTTP services that can be consumed by any type of application including
    web and mobile applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we explored some popular architecture patterns that can help
    us to create a solid foundation for our proposed solution. Adopting an architecture
    pattern is vital because it makes our platform more scalable and enhances the
    overall performance of the product. Additionally, it will prevent code redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore another set of architecture patterns that
    you should know about.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring additional architecture patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dive into a set of additional architecture patterns
    that will allow you to perform high-level scalability and system decoupling. We
    will examine each pattern to understand how it functions. This will help us to
    build more optimized systems with reusable modules and an organized structure
    that allows for extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: The serverless pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Serverless architecture** promotes cloud platforms and cloud-native code.
    It is a pattern that allows us to host our solution in a third-party infrastructure.
    Using this approach, the developers will no longer have to worry about managing
    the server software and hardware. This pattern allows us to break up our application
    into small and autonomous functions that can be triggered and scaled individually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the serverless architecture of a single-page
    web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: The serverless architecture of a web app](img/Figure_5.21_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: The serverless architecture of a web app'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the **Azure** serverless infrastructure to implement this pattern.
    Azure functions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CDN**: This stands for **Content Delivery Network**. It caches the content
    for a better response time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Blob Storage**: This allows you to store large, unstructured data on
    **Microsoft**''s data storage platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function App**: This is an event-driven model that provides the capabilities
    to create autonomous functions that are triggered by the client through HTTP requests.
    The routing of the requests is managed by the API gateway, which is described
    next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Management**: This is an API gateway that is located in front of the
    functions. It allows you to decouple the frontend app from the functions located
    in the backend. With this API management, we can rewrite the HTTP URLs and manage
    requests before they reach the concrete functions in the backend. Azure API management
    is also used to overcome cross-cutting concerns such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. Caching HTTP responses
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Monitoring and audit logging HTTP requests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Enabling **Cross-Origin Requests Sharing** (**CORS**), which enables access
    across domains
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Enforcing policies such as checking HTTP requests and applying call rates
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e. Protecting your API by enforcing an authentication mechanism by using **Auth2.0
    authorization** with **Azure Active Directory (Azure AD)**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Azure Cosmos DB**: This is a **NoSQL** database service provided by Azure
    to build modern applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure AD**: This is the cloud version of the regular active directory. It
    is used to authenticate users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Monitor**: This collects performance metrics about the solution and
    the usage of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Pipelines**: This is another service provided by Microsoft Azure. It
    provides **Continuous Integration** (**CI**) and **Continuous Delivery** (**CD**)
    services to automatically build, test, and deploy your code to any accessible
    target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is perfect if you wish to implement the microservices architecture
    or if you want to scale your solution and benefit from pay-as-you-go services.
  prefs: []
  type: TYPE_NORMAL
- en: The client-server pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **client-server pattern** is a network architecture that involves two types
    of entities: the clients and the server. It is used in scenarios where you have
    a server playing the role of a service provider and multiple clients playing the
    role of service consumers. The following diagram describes the logic behind this
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: Client-server architecture](img/Figure_5.22_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Client-server architecture'
  prefs: []
  type: TYPE_NORMAL
- en: As you see in the preceding diagram, the **Client** components send an HTTP
    request over the **TCP/IP** protocol to the server. The request is processed,
    and the server connects to the database **Server** and then responds back to the
    **Client**.
  prefs: []
  type: TYPE_NORMAL
- en: The event-driven pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Event-driven architecture** is another pattern that allows us to highly decouple
    our applications. It is a pattern that consists of a set of services. Each service
    works asynchronously and publishes an event when its data is updated. The client
    components subscribe to the events to receive or send updates.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we are building an e-commerce solution where customers are
    using coupon codes while submitting an order. The system must ensure that the
    coupon code is only used once by the same customer. Since the customer information,
    the number of orders, and the coupon code details are located in different databases,
    the system cannot simply verify the usage of the coupon code. The solution is
    to use the event-driven pattern to maintain data consistency across the different
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the Azure event-driven architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Event-driven architecture](img/Figure_5.23_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Event-driven architecture'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, pay attention to how the **HR Application** is subscribing
    to the **Employee Events** and each event has its own logic and database.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe-filter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **pipe-filter pattern** consists of splitting a complex process into a
    group of smaller tasks. This approach is expected to improve the performance of
    our application as well as the reusability and maintainability of each task. A
    single event triggers a sequence of multiple steps, with each performing a specific
    task. The following diagram shows an example process that has been implemented
    using the pipe-filter architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: The pipe-filter pattern](img/Figure_5.24_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: The pipe-filter pattern'
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this pattern is **Azure Data Factory**, which allows you to
    create data-driven automated workflows in the cloud for data extraction, analysis
    and transformation, and loading.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored a set of architectural patterns that you should
    know about. Each one offers a unique methodology of implementation and delivers
    key advantages to your solution. In the next section, we will learn how to choose
    the right architecture pattern when designing a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned about major architectural patterns. However,
    you must have noticed that there are a few patterns that we didn't discuss in
    this chapter. In fact, some patterns will be introduced in the future. So, you
    will need a way in which to analyze a pattern and decide whether you want to choose
    it or not. One question that you could be asked is *how do we choose the right
    pattern for our solution?* Let's dig deep into this matter.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture design is the cornerstone of a solid and successful system. However,
    there is no one-size-fits-all solution when it comes to choosing the right architecture
    for your solution. Various perspectives should be taken into account when you
    want to decide which architecture pattern to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, the main selection criterion for choosing an architecture pattern
    is based on three factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software engineers** (who will work on the project): Software engineers should
    be familiar with the architecture you are proposing. This is so that they can
    easily navigate through the solution structure and start implementing new features
    as per the requirements. Then, at a later stage, when the product is delivered,
    it should be clear and straightforward to them how to fix any defects and which
    layers need to be modified. This is a very important factor to consider in order
    for the team to work efficiently and deliver a successful and stable product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: From the clients'' perspective, they are looking for a good quality
    product while maintaining efficiency. Additionally, they want to make sure that
    the implemented architecture can support additional features and modifications
    even after releasing the product. They want their product to be well-architected,
    scalable, and easy to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product type**: Note that it is not a good practice to select an architecture
    pattern just because it is widely popular or because it is trendy. Don''t assume
    that this will deliver a better product. However, an architecture pattern should
    be selected based on your requirements and the type of solution we want to build.
    This will allow you to deliver a successful product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have explored the three main factors that should affect your selection of
    the architecture. Furthermore, here is a criterion list with key characteristics
    that you should consider when selecting an architecture pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agility**: We should consider choosing the architecture that allows for high
    agility, which helps us to embrace and implement additional features and changes
    easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of deployment**: The architecture we choose should allow us to easily
    deploy the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: The architecture should allow for a high testability rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: This is an important factor. The architecture should allow
    for a high-performance rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: The architecture must allow us to scale our system, which
    means increasing its capacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of development**: The architecture should be well known by developers
    to ensure the easy development and implementation of the product. It should allow
    developers to troubleshoot the system and fix defects when needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the primary reasons that might cause complete system failure is choosing
    the wrong architecture pattern. That's why it is important to choose the right
    architecture pattern for your system, as it will solve various problems that you
    might face during the several phases of the project life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored key architecture patterns that are widely used
    in many solutions along with some modern patterns, such as clean architecture
    and microservices architecture. We also learned about a set of important architectural
    patterns that allow you to perform system decoupling and scalability. Finally,
    in this chapter, we explored the key factors that you need to consider when choosing
    the right architecture pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deep into core architecture considerations,
    such as the design quality attributes and how to properly plan for system caching,
    exception handling, and deployment.
  prefs: []
  type: TYPE_NORMAL
