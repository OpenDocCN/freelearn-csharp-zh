<html><head></head><body>
		<div><h1 id="_idParaDest-32" class="chapter-number"><a id="_idTextAnchor031"/>2</h1>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Minimal APIs – Creating REST Services</h1>
			<p>Since .NET 6, minimal APIs are the new way to create REST APIs. With later .NET versions, more and more enhancements have been made available, which makes them the preferred way to create REST services with .NET.</p>
			<p>In this chapter, you’ll learn how to create a data representation of the game with model types, use these types in a service to implement the game functionality, create a minimal API project to create games, update games by setting game moves, and return information about games.</p>
			<p>You’ll implement functionality to offer an OpenAPI description for developers accessing the service to get information about the service, and an easy way to create a client application.</p>
			<p>In this chapter, you’ll be exploring these topics:</p>
			<ul>
				<li>Creating models for the game</li>
				<li>Implementing an in-memory game repository</li>
				<li>Implementing the REST service of the game using minimal APIs</li>
				<li>Using OpenAPI to describe the service</li>
				<li>Testing the service using HTTP files</li>
				<li>Enabling .NET Aspire</li>
			</ul>
			<p>By the end of this chapter, you’ll have a running service implementing the Codebreaker Games API with an in-memory games store, accessible using HTTP requests.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the following GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>. The <code>ch02</code> source code folder contains the code samples for this chapter. You’ll find the code for the following:</p>
			<ul>
				<li><code>Codebreaker.GamesAPIs</code> – The Web API project</li>
				<li><code>Codebreaker.GamesAPIs.Models</code> – A library for the data models</li>
				<li><code>Codebreaker.GameAPIs.Analyzers</code> – A library containing game move analyzers for the game</li>
				<li><code>Codebreaker.GamesAPIs.Analyzers.Tests</code> – Unit tests for the game move analyzers</li>
				<li><code>Codebreaker.AppHost</code> – The host project for .NET Aspire</li>
				<li><code>Codebreaker.ServiceDefaults</code> – A library used by the .NET Aspire configuration</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You don’t implement the game move analyzers of the game in this chapter. The <code>Analyzers</code> project is just for reference purposes, but you can simply use a NuGet package for the analyzers (<code>CNinnovation.Codebreaker.Analyzers</code>) that has been made available for you to build the service.</p>
			<p>For the installation of Visual Studio, Visual Studio Code, and .NET Aspire, check the README file for this chapter in the repository.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>The game models</h1>
			<p>Before <a id="_idIndexMarker042"/>creating the REST API project, we start with a library that contains the models to represent the game along with a move of the game. This model will contain the main data part of the Codebreaker Game API service solution, which will be used to read and write to the database (in <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>), while the model also serves as an implementation of the main functionality of the game.</p>
			<p>The <a id="_idIndexMarker043"/>major types in a simplified version are shown in <em class="italic">Figure 2</em><em class="italic">.1</em>. The <code>Game</code> class implements the <code>IGame</code> interface. The <code>IGame</code> interface is used by the <code>Analyzers</code> package. A game contains a list of moves. A single game move is represented by the <code>Move</code> class.</p>
			<div><div><img src="img/B21217_02_01.jpg" alt="Figure 2.1 – The game model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The game model</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Exploring the game analyzers library</h2>
			<p>As the<a id="_idIndexMarker044"/> focus of this book is not implementing the game rules with .NET, you can use the existing project, <code>Codebreaker.GameAPIs.Analyzers</code>, or just reference the NuGet package that has been made available on the NuGet server. This library contains game move analyzers for these game types:</p>
			<ul>
				<li><code>Game6x4</code> – Six colors with four codes to guess</li>
				<li><code>Game8x5</code> – Eight colors with five codes</li>
				<li><code>Game6x4Mini</code> – Six colors with four codes with a <em class="italic">small </em><em class="italic">children</em> mode</li>
				<li><code>Game5x5x4</code> – Five colors and five shapes with four codes</li>
			</ul>
			<p>The analyzers <a id="_idIndexMarker045"/>work using the generic <code>IGame</code> interface, which you need to implement with the game models library.</p>
			<p>The <code>IGame</code> interface specifies some common functionalities for the <code>Codebreaker</code> games, as you can see in the following code snippet. Check the repository for the complete interface definition:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers/Contracts/IGame.cs</p>
			<pre class="source-code">
namespace Codebreaker.GameAPIs.Contracts;
public interface IGame
{
  Guid Id { get; }
  string GameType { get; }
  int NumberCodes { get; }
  int MaxMoves { get; }
  DateTime StartTime { get; }
  // code removed for brevity
  IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; FieldValues { get; }
  string[] Codes { get; }
}</pre>
			<p>The <code>IGame</code> interface defines game members used by the analyzers, such as the number of codes that must be set and the maximum number of moves allowed, which are used by the analyzer to verify correct input data. The <code>FieldValues</code> property of the <code>IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;</code> type defines the possible values to select from. With the color game types, this will be a list of colors. With the shape game type, this will be a list of colors and a list of shapes. The <code>Codes</code> property contains an <a id="_idIndexMarker046"/>array of strings. How the string looks is different based on the game type. The string array contains the correct solution for a game run.</p>
			<p>The <code>analyzers</code> library also contains record types that are supported by the analyzers implementation that you can use for the generic parameters of your game types.</p>
			<p>One example of such a type used for the generic parameters is <code>ColorField</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers/Fields/ColorField.cs</p>
			<pre class="source-code">
public partial record class ColorField(string Color)
{
  public override string ToString() =&gt; Color;
  public static implicit operator ColorField(string color) =&gt; 
    new(color);
}</pre>
			<p>The <code>ColorField</code> record class just contains a <code>color</code> string. This field type is used with all game types with the exception of the <code>Game5x5x4</code> game type, which uses the <code>ShapeAndColorField</code> record.</p>
			<p>To specify the results of a game move, three different types are available: <code>ColorResult</code>, <code>SimpleColorResult</code>, and <code>ShapeAndColorResult</code>. <code>SimpleColorResult</code> adds information for small children (which position has a correct color), whereas the <code>ColorResult</code> record struct just contains information on the number of colors placed in a correct hole, and the number of colors placed in an incorrect hole.</p>
			<p>The following code snippet shows the <code>ColorResult</code> record struct:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers/Results/ColorResult.cs</p>
			<pre class="source-code">
public readonly partial record struct ColorResult(int Correct, 
  int WrongPosition)
{
  private const char Separator = ':';
}</pre>
			<p>This<a id="_idIndexMarker047"/> record is implemented partially, separating parts of the implementation to simplify the source code. The other parts are defined in other source files and implement the <code>IParsable</code> and <code>IFormattable</code> interfaces. The <code>const</code> member called <code>Separator</code> is used with the other parts of the <code>ColorResult</code> type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>ColorField</code>, <code>ColorResult</code>, and the other classes representing a field and results are just used to analyze moves and return results. The <code>Game</code> and <code>Move</code> classes that you’ll implement in this chapter are just data holders and don’t contain any logic. The field guesses and results are all represented using strings, which makes them flexible for every game type available and easier to use with JSON serialization and database access. Converting the specific field and result types to and from strings is done using the <code>IParsable</code>, <code>ISpanParsable</code>, and <code>IFormattable</code> interfaces. The parsable interfaces are new since .NET 7 and are based on a C# 11 feature that allows static members with interfaces. These types are important in case you want to create your own game types and game analyzers.</p>
			<p class="callout">You can read the article at <a href="https://csharp.christiannagel.com/2023/04/14/iparsable/">https://csharp.christiannagel.com/2023/04/14/iparsable/</a> for more information about parsable interfaces.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Exploring game analyzers</h2>
			<p>The <a id="_idIndexMarker048"/>implementation of the game analyzers is done within the <code>GameGuessAnalyzer</code> base class and the <code>ColorGameGuessAnalyzer</code>, <code>SimpleGameGuessAnalyzer</code>, and <code>ShapeGameGuessAnalyzer</code> derived classes. The implementation of these analyzers is disconnected from the game model types. All these analyzers implement the <code>GetResult</code> method specified with the <code>IGameGuessAnalyzer&lt;Tresult&gt;</code> interface. After creating an instance of the analyzer passing the game, the guesses, and the move number, just the <code>GetResult</code> method needs to be invoked to calculate the result of the move.</p>
			<p>If you are<a id="_idIndexMarker049"/> interested in checking the analyzers, dive into the <code>Codebreaker.GameAPIs.Analyzers</code> project within the book’s source code repository. Working through the following steps, instead of referencing this project, you can add the <code>CNinnovation.Codebreaker.Analyzers</code> NuGet package. Just make sure to use the latest 3.x version of this package, as 4.x and newer versions might contain breaking changes.</p>
			<p>If you choose to, you can create an analyzer on your own and also add more game types. Make sure to read the information on the game rules in <a href="B21217_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Creating a .NET library</h2>
			<p>The <a id="_idIndexMarker050"/>model types are added to the <code>Codebreaker.GameAPIs.Models</code> .NET library. Having a library allows the creation of different data access libraries (in <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>) to offer a flexible data store choice for hosting the service.</p>
			<p>You can use the .NET CLI as shown to create the class library, or use Visual Studio to create a class library:</p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.GameAPIs.Models</pre>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Implementing classes for the model types</h2>
			<p>The <code>Game</code> class <a id="_idIndexMarker051"/>holding all the data needed by a game is shown here (check the GitHub repository for the complete implementation):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Game.cs</p>
			<pre class="source-code">
public class Game(
  Guid id,
  string gameType,
  string playerName,
  DateTime startTime,
  int numberCodes,
  int maxMoves) : IGame
{
  public Guid Id { get; } = id;
  public string GameType { get; } = gameType;
  public string PlayerName { get; } = playerName;
  public DateTime StartTime { get; } = startTime;
  // code removed for brevity
  public ICollection&lt;Move&gt; Moves { get; } = []
  public override string ToString() =&gt;   
    $"{Id}:{GameType} – {StartTime}";
}</pre>
			<p>This<a id="_idIndexMarker052"/> class implements the <code>IGame</code> interface to support the analyzer to check the correctness of a move and to set some game state. In addition to the members of the interface, the <code>Game</code> class also contains a collection of <code>Move</code> objects. Primary constructor syntax is used to reduce the number of needed code lines.</p>
			<p class="callout-heading">Primary constructors</p>
			<p class="callout">Several classes created in this book make use of primary constructors. Primary constructors have been in use with records since C# 9. With C# 12, primary constructors can be used with normal classes and structs. However, while primary constructors with records create properties, with classes, these are just parameters. The parameters can be assigned to fields and properties, or just be used within members.</p>
			<p>The <code>Move</code> class is simpler as it just represents the move of a player within a game along with its result:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Move.cs</p>
			<pre class="source-code">
public class Move(Guid id, int moveNumber)
{
  public Guid Id { get; private set; } = id;
  public int MoveNumber { get; private set; } = moveNumber;
  public required string[] GuessPegs { get; init; }
  public required string[] KeyPegs { get; init; }
  public override string ToString() =&gt; 
    $"{MoveNumber}. {string. Join(':', GuessPegs)}";
}</pre>
			<p>The <code>Move</code> class <a id="_idIndexMarker053"/>contains string arrays for the guesses (<code>GuessPegs</code>) and the results (<code>KeyPegs</code>). String arrays can be used for every game type.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Defining the game repository contract</h2>
			<p>To be <a id="_idIndexMarker054"/>independent of the data store, the <code>IGamesRepository</code> interface defines all the members needed from a data store when playing a game. The <code>AddGameAsync</code> method is invoked when a new game is started. Setting a move, the game needs to be updated invoking the <code>UpdateGameAsync</code> method. The <code>GetGameAsync</code> and <code>GetGamesAsync</code> methods are specified by the interface to retrieve games:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Data/IGamesRepository.cs</p>
			<pre class="source-code">
public interface IGamesRepository
{
  Task AddGameAsync(Game game, 
        CancellationToken cancellationToken = default);
     Task AddMoveAsync(Game game, Move move, 
       CancellationToken cancellationToken = default);
     Task&lt;bool&gt; DeleteGameAsync(Guid id, 
       CancellationToken cancellationToken = default);
     Task&lt;Game?&gt; GetGameAsync(Guid id, 
       CancellationToken cancellationToken = default);
     Task&lt;IEnumerable&lt;Game&gt;&gt; GetGamesAsync(GamesQuery gamesQuery, 
       CancellationToken cancellationToken = default);
     Task&lt;Game&gt; UpdateGameAsync(Game game, 
       CancellationToken cancellationToken = default);
}</pre>
			<p>This <a id="_idIndexMarker055"/>interface specifies asynchronous methods. This wouldn’t be required with the implementation in this chapter. The next chapter will add asynchronous implementations, thus the contract should be ready for this.</p>
			<p>Specifying asynchronous methods, it’s a good practice to allow passing a <code>CancellationToken</code>. This allows canceling long-running operations even across network boundaries.</p>
			<p>The <code>IGamesRepository</code> interface is specified in the <code>Codebreaker.GameAPIs.Models</code> library. This makes it possible to reference this interface from all the data store libraries that will be implemented later on. In this chapter, just an in-memory collection will be implemented as part of the next step.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>The minimal APIs project</h1>
			<p>After having<a id="_idIndexMarker056"/> the models and the repository contract in place, we can move over to creating the project hosting the REST API.</p>
			<p>Here, we’ll use ASP.NET Core with minimal APIs to create a REST API, and store games and moves in an in-memory repository. To create the running games API, we need to do the following:</p>
			<ol>
				<li>Create a Web API project.</li>
				<li>Implement the games repository.</li>
				<li>Create a games factory.</li>
				<li>Create data transfer objects.</li>
				<li>Create endpoints to run the game via HTTP requests.</li>
				<li>Configure the JSON serializer.</li>
				<li>Add endpoint filters.</li>
			</ol>
			<p>To better<a id="_idIndexMarker057"/> understand how the different classes interact in creating the game and setting a move, the flow of the functionality we need to implement is shown in the next two figures.</p>
			<p><em class="italic">Figure 2</em><em class="italic">.2</em> shows the sequence when a new game is created.  On invoking the API call, <code>GamesService</code> is invoked to start the game. This service class uses <code>GamesFactory</code> to create a new game based on the parameters received and returns random code values. For persistence, <code>GameMemoryRepository</code> is invoked from <code>GamesService</code> to add the game before the game is returned.</p>
			<div><div><img src="img/B21217_02_02.jpg" alt="Figure 2.2 – Creating a game"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Creating a game</p>
			<p><em class="italic">Figure 2</em><em class="italic">.3</em> shows the sequence when a game move is set. Because the client does not have the complete state of the game, <code>GamesService</code> retrieves the game from the repository. Then, <code>GamesFactory</code> is used again to select an analyzer based on the game type, and the analyzer is invoked to find the results of the game move. After the results are available with <code>GamesService</code>, the game is updated with the new move, and the results are<a id="_idIndexMarker058"/> returned to the game endpoint.</p>
			<div><div><img src="img/B21217_02_03.jpg" alt="Figure 2.3 – Setting a game move"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Setting a game move</p>
			<p>Let’s implement this functionality with the API.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Creating the Web API project</h2>
			<p>To <a id="_idIndexMarker059"/>create the Web API project, you can use the .NET CLI as shown or use the Web API project template from Visual Studio:</p>
			<pre class="console">
dotnet new webapi --use-minimal-apis --framework net8.0 -o Codebreaker.GameAPIs</pre>
			<p>The <code>--</code><code>use-minimal-apis</code> option is used to create minimal APIs instead of the traditional controllers. Because the API will be hosted behind an Ingress server, the Ingress server will offer HTTPS, while HTTP is okay in the backend. To allow but not require HTTPS remove the codeline <code>app.UseHttpsRedirection();</code> from the code.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Exploring WebApplicationBuilder and WebApplication</h2>
			<p>With the created project, <code>Program.cs</code> is created and contains the configuration for the dependency injection container with the <code>WebApplicationBuilder</code> class and the configuration of middleware with the <code>WebApplication</code> class. The project template creates a random weather service. However, as weather information is not needed with the games service, some of the created code can be removed.</p>
			<p>The part of the code that remains is shown in the next code snippet:</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
  app.UseSwagger();
  app.UseSwaggerUI();
}
app.Run();</pre>
			<p><code>WebApplication.CreateBuilder</code> returns <code>WebApplicationBuilder</code> and configures the dependency injection container, the default configuration, and default logging. The <code>AddEndpointsApiExplorer</code> and <code>AddSwaggerGen</code> methods add services to the dependency injection container. The services registered by these two methods are needed for the <code>OpenAPI</code> description of the services.</p>
			<p>Invoking the <code>Build</code> method returns a <code>WebApplication</code> instance. This instance is then used to configure the middleware. Middleware is invoked with every request to the service. The <code>UseSwagger</code> method registers the Swagger middleware to create an <code>OpenAPI</code> description of the service. The <code>UseSwaggerUI</code> method registers the <code>SwaggerUI</code> middleware to show a web page where the API is described and can be tested. As an API is not yet implemented, a description will not be generated yet.</p>
			<p class="callout-heading">What is the relationship between Swagger and OpenAPI?</p>
			<p class="callout">The Swagger specification was created to describe HTTP APIs. In 2015, SmartBear Software acquired the Swagger API specification and started to form a new organization in 2016 together with<a id="_idIndexMarker060"/> Google, IBM, Microsoft, PayPal, and others under the sponsorship of the Linux Foundation – the <strong class="bold">OpenAPI Initiative</strong>. New versions of this specification are defined with OpenAPI.</p>
			<p class="callout">The <code>SwaggerXX</code> method names originate from the original specification and haven’t been changed since. These methods are defined within the <code>Swashbuckle.AspNetCore</code> NuGet package that’s referenced with the Web API project template.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Implementing the repository</h2>
			<p>In the <a id="_idIndexMarker061"/>earlier <em class="italic">Defining the game repository contract</em> section, we created the <code>IGamesRepository</code> interface to specify the methods that need to be implemented by every data store used with the Games API. We can implement this contract now. The <code>GamesMemoryRepository</code> class implements the <code>IGamesRepository</code> interface:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Data/GamesMemoryRepository.cs</p>
			<pre class="source-code">
namespace Codebreaker.GameAPIs.Data.InMemory;
public class GamesMemoryRepository(ILogger&lt;GamesMemoryRepository&gt; 
   logger) : IGamesRepository
{
  private readonly ConcurrentDictionary&lt;Guid, Game&gt; _games = new();
  private readonly ILogger _logger = logger;
  public Task AddGameAsync(Game game, 
    CancellationToken cancellationToken = default)
  {
    if (!_games.TryAdd(game.Id, game))
    {
      _logger.LogWarning("id {Id} already exists", game.Id);
    }
    return Task.CompletedTask;
  }
  // code removed for brevity
  public Task AddMoveAsync(Game game, Move move, 
    CancellationToken cancellationToken = default)
  {
    _games[game.Id] = game;
    return Task.CompletedTask;
  }
}</pre>
			<p>With the <a id="_idIndexMarker062"/>implementation, the <code>ConcurrentDictionary</code> class is used for a thread-safe collection when multiple clients access the service concurrently. With the implemented <code>AddGameAsync</code>, <code>GetGameAsync</code>, and similar methods, games are added, updated, and removed from the dictionary. Here, all the games are just kept in memory.</p>
			<p class="callout-heading">Persistent state and multiple server instances</p>
			<p class="callout">This chapter’s implementation of the repository does not persist the state and also does not allow multiple server instances to run, as the state is only stored within the memory of the process. In the next chapter, other implementations of this interface will be used to store the games in a database.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Creating game objects initialized with random values</h2>
			<p>The <code>GamesFactory</code> class <a id="_idIndexMarker063"/>creates games with random values. The following code snippet shows creating a game with six colors and four holes; you can extend this to other game types as well:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesFactory.cs</p>
			<pre class="source-code">
public static class GamesFactory
{
  private static readonly string[] s_colors6 =
    [ Colors.Red, Colors.Green, Colors.Blue, Colors.Yellow, 
    Colors. Purple, Colors.Orange ];
  // code removed for brevity
  public static Game CreateGame(string gameType, string playerName)
  {
    Game Create6x4Game() =&gt;
      new(Guid.NewGuid(), gameType, playerName, DateTime.Now, 4, 12)
      {
        FieldValues = new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;()
        {
          { FieldCategories.Colors, s_colors6 }
        },
        Codes = Random.Shared.GetItems(s_colors6, 4)
      };
    // code removed for brevity
    return gameType switch
    {
      GameTypes.Game6x4Mini =&gt; Create6x4SimpleGame(),
      GameTypes.Game6x4 =&gt; Create6x4Game(),
      GameTypes.Game8x5 =&gt; Create8x5Game(),
      GameTypes.Game5x5x4 =&gt; Create5x5x4Game(),
      _ =&gt; throw new CodebreakerException("
      Invalid game type") { Code = CodebreakerExceptionCodes.
      InvalidGameType }
    };
  }
}</pre>
			<p>With the code, pattern <a id="_idIndexMarker064"/>matching is used. For every game type, a local function such as <code>Create6x4Game</code> is defined, which specifies the available colors or shapes, the random code, and the maximum number of moves.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Creating data transfer objects</h2>
			<p><code>BookData</code> class to write information to the database and a <code>BookDTO</code> class for communication, implementing the same properties. With such a design in place, a change to the book would result in changing <code>BookData</code> and <code>BookDTO</code>, as well as the implementation to transform these objects. Using the same <code>Book</code> class with every of these scenarios reduces the programming effort, and also reduces the memory and CPU usage during runtime.</p>
			<p>A reason to use different types for data access and communication is the requirements for the data mapping to the database and the requirements of the serializer used with communication. Nowadays, both EF Core and the <code>System.Text.Json</code> serializer support constructors with parameters, which might fill the requirements.</p>
			<p>If there are<a id="_idIndexMarker067"/> other requirements, DTOs can become important. With the games API, different data should be used with the communication than used internally with the service. In creating a game, not all the data for the game is coming from the client. Much of this data, such as the list of available fields as well as the code, is generated on the server. When sending a move from the client to the server, a game gets updated on the server, but there’s only a subset of a move needed that’s sent from the client to the server. When returning information from the server to the client, again, only a subset of data is required. This makes creating DTOs important.</p>
			<p>With the games API, to start a new game, we implement the <code>CreateGameRequest</code> and <code>CreateGameResponse</code> class record types:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Models/GameAPIModels.cs</p>
			<pre class="source-code">
public enum GameType
{
  Game6x4,
  Game6x4Mini,
  Game8x5,
  Game5x5x4
}
public record class CreateGameRequest(GameType GameType, 
  string PlayerName);
public record class CreateGameResponse(Guid id, GameType GameType, 
  string PlayerName, int NumberCodes, int MaxMoves)
{
  public required IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; 
    FieldValues { get; init; }
}</pre>
			<p>In creating <a id="_idIndexMarker068"/>a game, the client just needs to send the game type and the player’s name. This is all that’s needed from the client. In the backend, just a string is used for the game type. Using a string allows for easy enhancements of other game types. The API using an <code>enum</code> type allows showing the available game types with the OpenAPI description, as you’ll see in the section about OpenAPI.</p>
			<p>After the game is created, the client just needs to have the identifier of the game. For convenience, the game type and player name are also returned. The client should also know the possible fields that can be selected. This is specified by the <code>FieldValues</code> dictionary.</p>
			<p>To set a game move, we implement the <code>UpdateGameRequest</code> and <code>UpdateGameResponse</code> class record types:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Models/GameAPIModels.cs</p>
			<pre class="source-code">
public record class UpdateGameRequest(Guid Id, GameType GameType, string PlayerName, int MoveNumber, bool End = false)
{
  public string[]? GuessPegs { get; set; }
}
public record class UpdateGameResponse(
  Guid Id,
  GameType GameType,
  int MoveNumber,
  bool Ended,
  bool IsVictory,
  string[]? Results);</pre>
			<p>When<a id="_idIndexMarker069"/> sending a move, the client needs to send the list of guess pegs. With the API service, guess pegs and key pegs are represented with strings, such as the <code>GuessPegs</code> property. This makes it independent of any game type. With the analyzers, different types for every game type are implemented. The <code>IParsable</code> interface is used to convert string values.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Implementing the games service</h2>
			<p>To<a id="_idIndexMarker070"/> simplify the implementation of the endpoints, we create the <code>GamesService</code> class, which will be injected into the endpoints:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public class GamesService(IGamesRepository dataRepository) : IGamesService
{
  public async Task&lt;Game&gt; StartGameAsync(string gameType, 
    string playerName, CancellationToken cancellationToken = default)
  {
    Game game = GamesFactory.CreateGame(gameType, playerName);
    await dataRepository.AddGameAsync(game, cancellationToken);
    return game;
  }
// code removed for brevity</pre>
			<p><code>StartGameAsync</code> just invokes the <code>AddGameAsync</code> method with <code>IGamesRepository</code>. Such a simple implementation is the case with many other methods of <code>GamesService</code>. This will change in the next chapter when data will be cached in memory before accessing the database. When using the in-memory repository, this is not necessary.</p>
			<p>Implementing <code>SetMoveAsync</code> is more complex, as here we have to decide to use one of the <a id="_idIndexMarker071"/>game analyzers to calculate the game. For the game type selection and the calculation, the <code>ApplyMove</code> method is defined as an extension method for the <code>Game</code> type within the <code>GamesFactory</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesFactory.cs</p>
			<pre class="source-code">
public static Move ApplyMove(this Game game, string[] guesses, int moveNumber)
{
  static TField[] GetGuesses&lt;TField&gt;(IEnumerable&lt;string&gt; guesses)
    where TField: IParsable&lt;TField&gt; =&gt; guesses
      .Select(g =&gt; TField.Parse(g, default))
      .ToArray();
  string[] GetColorGameGuessAnalyzerResult()
  {
    ColorGameGuessAnalyzer analyzer = 
      new (game, GetGuesses&lt;ColorField&gt;(guesses), moveNumber);
    return analyzer.GetResult().ToStringResults();
  }
  // code removed for brevity
  string[] results = game.GameType switch
  {
    GameTypes.Game6x4 =&gt; GetColorGameGuessAnalyzerResult(),
    GameTypes.Game8x5 =&gt; GetColorGameAnalyzerResult(),
    // code removed for brevity
  };
  Move move = new(Guid.NewGuid(), moveNumber)
  {
    GuessPegs = guesses,
    KeyPegs = results
  }
  game.Moves.Add(move);
  return move;
}</pre>
			<p>The<a id="_idIndexMarker072"/> implementation of this method uses pattern matching with the <code>switch</code> expression to invoke the correct analyzer class to get the result of the game move.</p>
			<p>Having this <code>Game</code> extension method in place let’s us switch back to the implementation of the <code>SetMoveAsync</code> method of the <code>GamesService</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public async Task&lt;(Game game, string Result)&gt; SetMoveAsync(
  Guid id, string[] guesses, int moveNumber, 
    CancellationToken cancellationToken = default)
{
  Game? game = await dataRepository.GetGameAsync(id, cancellationToken);
  CodebreakerException.ThrowIfNull(game);
  CodebreakerException.ThrowIfEnded(game);
  Move move = game.ApplyMove(guesses, moveNumber);
  await dataRepository.AddMoveAsync(game, move, cancellationToken);
  return (game, move);
}</pre>
			<p>The <code>SetMoveAsync</code> method<a id="_idIndexMarker073"/> retrieves the game from the repository before invoking the <code>ApplyMove</code> method to do the calculation.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Converting transfer objects to and from the object model</h2>
			<p>In <a id="_idIndexMarker074"/>receiving a <code>CreateGameRequest</code> to create a new game, there’s no need for a conversion. The members of <code>CreateGameRequest</code> can directly be used when using <code>GamesService</code>. We need to create a conversion from a <code>Game</code> type to <code>CreateGameResponse</code>. This is done as an extension method for the <code>Game</code> type:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Extensions/ApiModelExtensions.cs</p>
			<pre class="source-code">
public static partial class ApiModelExtensions
{
  public static CreateGameResponse ToCreateGameResponse(
    this Game game) =&gt;
    new(game.Id, Enum.Parse&lt;GameType&gt;(game.GameType), game.PlayerName)
    {
      FieldValues = game.FieldValues;
    };
    // code removed for brevity</pre>
			<p>With the implementation, the needed data from the <code>Game</code> type is transferred to the <code>CreateGameResponse</code> type.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Creating endpoints for the Games API service</h2>
			<p>Before<a id="_idIndexMarker075"/> creating the endpoints, the services we created need to be registered with the dependency injection container to inject them within the endpoint:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
builder.Services.AddSingleton&lt;IGamesRepository, GamesMemoryRepository&gt;();
builder.Services.AddScoped&lt;IGamesService, GamesService&gt;();</pre>
			<p><code>GamesMemoryRepository</code> was created to store game objects in memory. This is registered as a singleton for creating a single instance that’s injected into the endpoints. Games should be kept as long as the server keeps running. <code>GamesMemoryRepository</code> implements <code>IGamesRepository</code>. In the next chapter, an EF Core context will be created to implement the same interface, which will allow changing<a id="_idIndexMarker076"/> the <code>GamesService</code> class implements the <code>IGamesService</code> interface. This service class is registered scoped; thus one instance is created with every HTTP request.</p>
			<p>With the middleware, we invoke one extension method that defines all the games API endpoints:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
<strong class="bold">app.MapGameEndpoints();</strong>
app.Run();</pre>
			<p>The <code>MapGameEndpoints</code> method is an extension method for the <code>IEndpointRouteBuilder</code> interface and is implemented next.</p>
			<p>In creating a REST API, different HTTP verbs are used to read and write resources:</p>
			<ul>
				<li><code>GET</code> – With an HTTP <code>GET</code> request, resources are returned from the service</li>
				<li><code>POST</code> – The HTTP <code>POST</code> request creates a new resource</li>
				<li><code>PUT</code> – <code>PUT</code> is usually used to update a complete resource</li>
				<li><code>PATCH</code> – With <code>PATCH</code>, a partial resource can be sent for an update</li>
				<li><code>DELETE</code> – The HTTP <code>DELETE</code> request deletes a resource</li>
			</ul>
			<h3>Creating games with HTTP POST</h3>
			<p>Let’s start <a id="_idIndexMarker077"/>with the endpoint to create a new game by mapping an HTTP <code>POST</code> request:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs</p>
			<pre class="source-code">
namespace Codebreaker.GameAPIs.Endpoints;
public static class GameEndpoints
{
<strong class="bold">  public static void MapGameEndpoints(</strong>
    <strong class="bold">this IEndpointRouteBuilder routes)</strong>
  {
<strong class="bold">    </strong><strong class="bold">var group = routes.MapGroup("/games");</strong>
<strong class="bold">    group.MapPost("/", async (</strong>
<strong class="bold">      CreateGameRequest request,</strong>
<strong class="bold">      IGamesService gameService,</strong>
<strong class="bold">      HttpContext context,</strong>
<strong class="bold">      CancellationToken cancellationToken)</strong> =&gt;
    {
      Game game;
      try
      {
        game = await gameService.StartGameAsync(request.
          GameType.ToString(), request.PlayerName, cancellationToken);
      }
      catch (CodebreakerException) when (
        ex.Code == CodebreakerExceptionCodes.InvalidGameType)
      {
        GameError error = new(ErrorCodes.InvalidGameType,
          $"Game type {request.GameType} does not exist",
          context.Request.GetDisplayUrl(),
          Enum.GetNames&lt;GameType&gt;());
        return Results.BadRequest(error);
    }
    return Results.Created($"/games/{game.Id}", 
      game.ToCreateGameResponse());
  });</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">In the source code repository, you will find the <code>GameEndpoints.cs</code> and <code>GameEndPoints1.cs</code> files. The current state of the endpoints is in the <code>GameEndpoints1.cs</code> file, but this will be changed later on when OpenAPI information is added. The file that gets compiled as defined in the project file is <code>GameEndpoints.cs</code>. If you want to compile the project from the repository with the current version, change the settings of the C# file in the project file.</p>
			<p>The <code>MapGameEndpoints</code> method is – as previously mentioned – an extension method for the <code>IEndpointRouteBuilder</code> interface. The first method invoked is <code>MapGroup</code> to define common functionality for the endpoints, which, in turn, uses the returned group variable (a <code>RouteGroupBuilder</code> object). With this code, the common functionality is the <code>/games</code> URI, which will be prefixed. You can use this for common authorization needs or common logging, which will be shown in later chapters of this book. Common functionality for OpenAPI will be shown later in this chapter in the section on OpenAPI.</p>
			<p>The<a id="_idIndexMarker078"/> created group is used with the <code>MapPost</code> method. The <code>MapPost</code> method will be invoked on an HTTP <code>POST</code> request. Similarly, <code>MapGet</code>, <code>MapPut</code>, and <code>MapDelete</code> are available as well. All these methods offer two overloads, where the overload with a pattern and the <code>Delegate</code> parameter are used. The <code>Delegate</code> parameter allows passing a lambda expression with any parameters and any return types – this is what minimal APIs take advantage of.</p>
			<p>The parameter types specified with the <code>MapPost</code> method are listed here:</p>
			<ul>
				<li><code>CreateGameRequest</code> – This comes from the HTTP body.</li>
				<li><code>IGamesService</code> – The value is injected from the DI container.</li>
				<li><code>HttpContext</code> and <code>CancellationToken</code> – These are special types bound with minimal APIs. Another special one is <code>ClaimsPrincipal</code>, which is used with authentication.</li>
			</ul>
			<p>Other binding sources that can be used are route values, query strings, headers, and HTML form values. You can also add custom binding to map a route, query, or header binding to custom types.</p>
			<p>You can add attributes such as <code>FromBody</code>, <code>FromRoute</code>, <code>FromServices</code>, and others, which can help with readability and also resolve issues if there’s a conflict.</p>
			<p>With the implementation of the lambda expression with the <code>MapPost</code> method, the injected <code>gameService</code> variable is used to start a game. Starting the game successfully, a <code>Game</code>-derived object is returned, which is converted to <code>CreateGameResponse</code> with the <code>ToCreateGameResponse</code> extension method. The method returns either <code>HTTP 201 Created</code> on success, or <code>HTTP 400 Bad Request</code> using the <code>Results</code> factory class. <code>Results</code> offers methods to return the different HTTP status codes.</p>
			<p>Using <code>Results.Created</code>, a URI is assigned to the first parameter of the method, and the second parameter receives the created object. The <code>201 Created</code> status code is used to <a id="_idIndexMarker079"/>return the HTTP location header with a link that can be remembered by the client to retrieve the same resource at a later time. The link that’s returned here can be used with an HTTP <code>GET</code> request to retrieve the game at a later time.</p>
			<h3>Defining an error object</h3>
			<p>In case of an<a id="_idIndexMarker080"/> error, the <code>MapPost</code> method returns <code>Results.BadRequest</code>. Here, we can define an object to return detailed error information to the client.</p>
			<p>The following code snippet shows the <code>GameError</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Errors/GameError.cs</p>
			<pre class="source-code">
public record class GameError(string Code, string Message, 
  string Target, string[]? Details = default);
public class ErrorCodes
{
  public const string InvalidGameType = nameof(InvalidGameType);
  // code removed for brevity
}</pre>
			<p>The <code>GameError</code> class defines the <code>Code</code>, <code>Message</code>, <code>Target</code>, and <code>Details</code> properties. With the <code>MapPost</code> method, in the case of requesting an invalid game type, the valid game types are returned with the details.</p>
			<h3>Returning games with HTTP GET</h3>
			<p>To fulfill a<a id="_idIndexMarker081"/> request to a single game, we use the <code>MapGet</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs</p>
			<pre class="source-code">
group.<strong class="bold">MapGet</strong>("/{id:guid}", async (
  Guid id,
  IGamesService gameService,
  CancellationToken cancellationToken
) =&gt;
{
  Game? game = await gameService.GetGameAsync(id, cancellationToken);
  if (game is null)
  {
    return Results.NotFound();
  }
  return Results.Ok(game);
});</pre>
			<p>With<a id="_idIndexMarker082"/> the lambda parameters, here, the <code>Guid</code> is received from the route parameter. Within curly braces, the same variable name is used that matches the variable of <code>Guid</code>. The implementation simply returns the game with the status code of <code>OK</code>, or <code>not found</code> if the game ID is not found within the repository.</p>
			<h3>Updating games by setting a move with HTTP PATCH</h3>
			<p>To set a<a id="_idIndexMarker083"/> move, a game is updated with a move without sending the complete game. That’s a partial update, thus we use the HTTP <code>PATCH</code> verb to invoke the <code>MapPatch</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs</p>
			<pre class="source-code">
group.MapPatch("/{id:guid} ", async (
  Guid id,
  UpdateGameRequest request,
  IGamesService gameService,
  HttpContext context,
  CancellationToken cancellationToken) =&gt;
{
  try
  {
    (Game game, string result) = await gameService.SetMoveAsync(
       id, request.GuessPegs, request.MoveNumber, cancellationToken);
    return Results.Ok(game.AsUpdateGameResponse(result));
  }
  catch (CodebreakerException ex) when (
    ex.Code == CodebreakerExceptionCodes.GameNotFound)
  {
    return Results.NotFound();
  }
  // code removed for brevity
});</pre>
			<p>The complete <a id="_idIndexMarker084"/>route for this request is <code>games/{id}</code> – prefixed with the pattern specified by the group. The <code>SetMoveAsync</code> method of <code>GamesService</code> does the main work. On success, the method returns  <code>UpdateGameResponse</code>, which is created from the <code>Game</code> object and the result string.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Configuring JSON serialization</h2>
			<p>To successfully<a id="_idIndexMarker085"/> run the application, the JSON serialization needs to be configured. The .NET JSON serializer has many configuration options – including polymorphic serialization (returning a hierarchy of objects). But with all these features supported from serialization and with ASP.NET Core, you need to pay attention to the client technologies you use, if the same support is available there. With the data types we transfer here, there’s not a lot to do.</p>
			<p>Just to serialize the enumeration value of game types, we prefer to use strings instead of just numbers, which would be returned by default. To return string values, the JSON options are configured:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Models/GameAPIModels.cs</p>
			<pre class="source-code">
<strong class="bold">[JsonConverter(typeof(JsonStringEnumConverter&lt;GameType&gt;))]</strong>
public enum GameType
{
    Game6x4,
    Game6x4Mini,
    Game8x5,
    Game5x5x4
}</pre>
			<p>The generic version of the <code>JsonStringEnumConverter</code> class is new since .NET 8 to support Native AOT. The non-generic version of this type uses reflection, which is incompatible with Native AOT.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Instead of using the attribute with the type, you can also configure the JSON serialization behavior with the dependency injection container. The <code>ConfigureHttpJsonOptions</code> extension method with <code>JsonOptions</code> from the <code>Microsoft.AspNetCore.Http.Json</code> namespace can be used to configure the JSON serialization for minimal APIs. Be aware that the OpenAPI generation still uses the MVC serializer configuration, thus, here, you need to use the <code>Configure</code> method with <code>Microsoft.AspNetCore.Mvc.JsonOptions</code> as a generic parameter.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Creating endpoint filters</h2>
			<p>To simplify<a id="_idIndexMarker086"/> the code for endpoints, as you’ve seen, endpoints don’t need to be specified within top-level statements. You can create multiple classes with extension methods to group endpoints together. Within one extension method, you can also group endpoints with common behaviors using the <code>MapGroup</code> method. We also used dependency injection to have the main functionality outside of the endpoint implementation in the <code>GameService</code> class.</p>
			<p>There’s another way to simplify the implementation of the endpoints – by using custom endpoint filters. Endpoint filters offer similar functionality as ASP.NET Core middleware, just with a different scope. By adding an endpoint filter to an endpoint, the filter code is invoked every time the endpoint is accessed. Adding multiple endpoint filters, the order of adding these is important: one filter is invoked after the other. You can also add an endpoint filter to a group; thus the filter is invoked with every endpoint specified with this group.</p>
			<p>With <code>ValidatePlayernameEndpointFilter</code>, we create a filter to validate the minimum length of the player’s name:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/ValidatePlayernameEndpointFilter.cs</p>
			<pre class="source-code">
public class ValidatePlayernameEndpointFilter : <strong class="bold">IEndpointFilter</strong>
{
  <strong class="bold">public async ValueTask&lt;object?&gt; </strong>
    <strong class="bold">InvokeAsync(EndpointFilterInvocationContext context, </strong>
    <strong class="bold">EndpointFilterDelegate next)</strong>
  {
    CreateGameRequest request = 
      context.GetArgument&lt;CreateGameRequest&gt;(0);
    if (request.PlayerName.Length &lt; 4)
    {
       return Results.BadRequest("
         Player name must be at least 4 characters long");
    }
    return <strong class="bold">await next(context);</strong>
  }
}</pre>
			<p>An endpoint filter implements the <code>IEndpointFilter</code> interface. This interface defines the <code>InvokeAsync</code> method with <code>EndpointFilterInvocationContext</code> and <code>EndpointFilterDelegate</code> parameters. By using <code>EndpointFilterInvocationContext</code>, you can access <code>HttpContext</code> to access all the<a id="_idIndexMarker087"/> information about the request and also add responses, as well as the parameters passed to the endpoint. With the implementation of <code>ValidatePlayernameEndpointFilter</code>, the player’s name is validated by accessing the first parameter of the endpoints lambda expression, accessing the <code>CreateGameRequest</code> object, and accessing the <code>PlayerName</code> property. An HTTP status code of <code>400 Bad Request</code> is returned in the case that this does not succeed. To access the different parameters, the index of the parameter is needed. With a successful validation, the next endpoint is invoked using the <code>next</code> variable received with the second parameter.</p>
			<p>Using an endpoint filter, you can also remove the exception handling code and create code with the filter that’s invoked before and after the next filter or the endpoint code is invoked. We implement this functionality with <code>CreateGameExceptionEndointFilter</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/CreateGameExceptionEndpointFilter.cs</p>
			<pre class="source-code">
public class CreateGameExceptionEndpointFilter : IEndpointFilter
{
  private readonly ILogger _logger;
  public CreateGameExceptionEndpointFilter
    (ILogger&lt;CreateGameExceptionEndpointFilter&gt; logger)
  {
    _logger = logger;
  }
  public async ValueTask&lt;object?&gt; 
    InvokeAsync(EndpointFilterInvocationContext context, 
    EndpointFilterDelegate next)
  {
    CreateGameRequest request = 
      context.GetArgument&lt;CreateGameRequest&gt;(1);
    try
    {
<strong class="bold">      return await next(context);</strong>
    }
    catch (CodebreakerException ex) when (
      ex.Code == CodebreakerExceptionCodes.InvalidGameType)
    {
<strong class="bold">      _logger.LogWarning("game type {gametype} not found", </strong>
        <strong class="bold">request.GameType);</strong>
<strong class="bold">      return Results.BadRequest("Gametype does not exist");</strong>
    }
  }
}</pre>
			<p>The <code>CreateGameExceptionEndpointFilter</code> endpoint filter defines a constructor<a id="_idIndexMarker088"/> to inject the <code>ILogger</code> interface. Everything registered with the dependency injection container can be injected with an endpoint filter. With this filter, the invocation of the next filter – or the endpoint itself, in this case – is surrounded by a <code>try</code>/<code>catch</code> block. Thus, <code>CodebreakerException</code> is caught with the endpoint invocation, logged, and a result returned. This way, the exception-handling code can be removed from the endpoint itself. The <a id="_idIndexMarker089"/>following code snippet shows the new code for the endpoint implementation with the configured filters:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints2.cs</p>
			<pre class="source-code">
group.MapPost("/", async (
  CreateGameRequest request,
  IGamesService gameService,
  CancellationToken cancellationToken) =&gt;
{
  Game game = await gameService.StartGameAsync(request.
    GameType.ToString(), request.PlayerName, cancellationToken);
  return Results.Created($"/games/{game.Id}", 
    game.ToCreateGameResponse());
        })<strong class="bold">.AddEndpointFilter&lt;ValidatePlayernameEndpointFilter&gt;()</strong>
          <strong class="bold">.AddEndpointFilter&lt;CreateGameExceptionEndpointFilter&gt;();</strong></pre>
			<p>With this implementation, the important main functionality of this endpoint is easily visible. Validation and error handling is moved outside of the endpoint implementation. Calculating all the code together, the code is not becoming smaller, just the main functionality of the endpoint is becoming easier.</p>
			<p>The real power of endpoint filters comes with shared functionality between different endpoints. In <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>, <em class="italic">Logging and Monitoring</em>, we will create an endpoint filter that logs information for every endpoint that is configured with this filter.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Running the service</h2>
			<p>With the<a id="_idIndexMarker090"/> endpoints implemented, you can run and test the application and see the Open API user interface, as shown in <em class="italic">Figure 2</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/B21217_02_04.jpg" alt="Figure 2.4 – OpenAPI UI without extra configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – OpenAPI UI without extra configuration</p>
			<p>You can now run the application sending a <code>POST</code> request from the Swagger page. After getting the game information returned, copy the unique ID from the game, and send a <code>PATCH</code> request to set a move.</p>
			<p>While the application is running, OpenAPI now lacks some information. The returned HTTP results are not listed, more description details should be shown, and the schema for return types is not available. This is solved in the next section.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>OpenAPI information</h1>
			<p>Since there are many .NET versions, the <a id="_idIndexMarker091"/>Web API templates reference the <code>Swashbuckle.AspNetCore</code> NuGet package to create an OpenAPI description. Over the years, with later .NET versions, more and more functionality from OpenAPI has been added to ASP.NET Core itself, such as the <code>OpenApiInfo</code> class, which is now part of the <code>Microsoft.OpenApis.Models</code> namespace. Swashbuckle was<a id="_idIndexMarker092"/> changed to use the new classes and was also changed to be based on the <code>System.Text.Json</code> serializer instead of <code>Newtonsoft.Json</code>.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Adding OpenAPI documentation</h2>
			<p>Next, let’s make use<a id="_idIndexMarker093"/> of classes from the <code>Microsoft.OpenApis.Models</code> namespace together with Swashbuckle to configure the OpenAPI documentation:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
builder.Services.AddEndpointsApiExplorer();
<strong class="bold">builder.Services.AddSwaggerGen</strong>(options =&gt;
{
<strong class="bold">  options.SwaggerDoc</strong>("v3", new OpenApiInfo
  {
    Version = "v3",
    Title = "Codebreaker Games API",
    Description = 
      "An ASP.NET Core minimal APIs to play Codebreaker games",
    TermsOfService = new Uri("https://www.cninnovation.com/terms"),
    Contact = new OpenApiContact
    {
      Name = "Christian Nagel",
      Url = new Uri("https://csharp.christiannagel.com")
    },
    License = new OpenApiLicense
    {
      Name="API usage license",
      Url= new Uri("https://www.cninnovation.com/apiusage")
    }
  });
});</pre>
			<p>The Codebreaker Games API is <a id="_idIndexMarker094"/>already in its third major version. With the Swagger configuration of the dependency <a id="_idIndexMarker095"/>injection container, the <code>AddSwaggerGen</code> method supports receiving configuration options. The <code>SwaggerDoc</code> method of the <code>SwaggerGenOptions</code> options parameter allows specifying different document values, such as the version number, title, description, terms of service, contact, and license information, as shown in the code snippet. The <code>OpenApiInfo</code>, <code>OpenApiContact</code>, and <code>OpenApiLicense</code> classes are part of the <code>Microsoft.OpenApi.Models</code> namespace. All this configured information will show up in the generated OpenAPI documentation.</p>
			<p>The middleware configuration needs to be updated as well:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
app.UseSwagger();
<strong class="bold">app.UseSwaggerUI(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">  options.SwaggerEndpoint("/swagger/v3/swagger.json", "v3");</strong>
});</pre>
			<p>Here, the version number is included with the OpenAPI endpoint invoking the <code>SwaggerEndpoint</code> method using the <code>SwaggerUIOptions</code> parameter. In case you prefer a different look for the generated document, you can create your own style sheet, and pass the style sheet file by invoking the <code>options.InjectStylesheet</code> method.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Documentation for the endpoints</h2>
			<p>Several <a id="_idIndexMarker096"/>extension methods are available to add OpenAPI documentation to the endpoints, as we’ll do within the <code>MapGameEndpoints</code> implementation:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
public static void MapGameEndpoints(this IEndpointRouteBuilder routes)
{
  var group = routes.MapGroup("/games")
<strong class="bold">    .WithTags</strong>("Games API");</pre>
			<p>The <code>WithTags</code> method could be added to every endpoint or, as shown here, to the endpoint group. <code>WithTags</code> adds a category name – or multiple names if the API should show up with multiple categories. With this, for the documentation for every tag name, a heading is used to show all the endpoints together that belong to the same category. If you don’t supply a tag name, the project name is used, and all the endpoints are listed in this category.</p>
			<p>Next, using <code>RouteHandlerBuilder</code> extension methods, documentation is added to every endpoint:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
group.MapPost("/", async Task&lt;Results&lt;Created&lt;CreateGameResponse&gt;, BadRequest&lt;GameError&gt;&gt;&gt; (
// code removed for brevity
})
.<strong class="bold">WithName</strong>("CreateGame")
.<strong class="bold">WithSummary</strong>("Creates and starts a game")
.<strong class="bold">WithOpenApi</strong>(op =&gt;
{
  op.RequestBody.Description = "
     The game type and the player name of the game to create";
  return op;
});</pre>
			<p>Using<a id="_idIndexMarker097"/> the <code>WithName</code>, <code>WithSummary</code>, and <code>WithOpenApi</code> methods, a name and description of the API – including a description of every parameter – can be added.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Adding return type information to OpenAPI</h2>
			<p>The <code>Produces</code> extension <a id="_idIndexMarker098"/>method could be used to define what types are returned from endpoints that need to be described. Since .NET 7, there’s a better option: using the <code>TypedResults</code> class instead of the <code>Results</code> class that was used earlier in implementing the endpoints. <code>TypedResults</code> adds the class specified to the OpenAPI documentation. However, if there is more than one type returned, we need to specify this with the return types of the endpoint lambda expression.</p>
			<p>The first method to be changed to <code>TypedResults</code> is <code>MapDelete</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
group.MapDelete("/{id:guid}", async (
  Guid id,
  IGamesService gameService,
  CancellationToken cancellationToken
) =&gt;
{
  await gameService.DeleteGameAsync(id, cancellationToken);
<strong class="bold">  </strong><strong class="bold">return TypedResults.NoContent();</strong>
})
// code removed for brevity</pre>
			<p>The<a id="_idIndexMarker099"/> implementation of the lambda expression for the <code>MapDelete</code> method just returns the HTTP status code <code>204</code> and doesn’t require a return type for the lambda expression.</p>
			<p>This is different with the <code>MapPatch</code> implementation:</p>
			<pre class="source-code">
group.MapPatch("/{id:guid}/moves", async <strong class="bold">Task&lt;Results&lt;Ok&lt;UpdateGameResponse&gt;, NotFound, BadRequest&lt;GameError&gt;&gt;&gt;</strong> (
  Guid id,
  UpdateGameRequest request,
  IGamesService gameService,
  HttpContext context,
  CancellationToken cancellationToken) =&gt;
{
  try
  {
    (Game game, string result) = await gameService.SetMoveAsync(id, 
     request.GuessPegs, request.MoveNumber, cancellationToken);
    return <strong class="bold">TypedResults.Ok</strong>(game.AsUpdateGameResponse(result));
  }
  catch (ArgumentException ex) when (ex.HResult &gt;= 4200 &amp;&amp; 
    ex.HResult &lt;= 4500)
  {
    string url = context.Request.GetDisplayUrl();
    return ex.HResult switch
    {
      4200 =&gt; <strong class="bold">TypedResults.BadRequest</strong>(new GameError(
        ErrorCodes.InvalidGuessNumber, "Invalid number of guesses 
        received", url)),
      4300 =&gt; <strong class="bold">TypedResults.BadRequest</strong>(new GameError(
        ErrorCodes.InvalidMoveNumber, "Invalid move number received", 
        url)),
  // code removed for brevity
    };
  }
  catch (GameNotFoundException)
  {
    return <strong class="bold">TypedResults.NotFound</strong>();
  }
})
// code removed for brevity</pre>
			<p>The<a id="_idIndexMarker100"/> implementation of the lambda expression contains several invocations of the <code>TypedResults</code> factory class. The <code>BadRequest</code>, <code>NotFound</code>, and <code>Ok</code> methods are invoked. With <code>BadRequest</code>, an object of the <code>GameError</code> type is returned. This is just a simple record class with a <code>Message</code> and other properties to return useful information for the clients. The <code>Ok</code> method returns an object of the <code>UpdateGameResponse</code> class. With two or more typed results returned, the lambda expression needs a return type. To specify the return type with the lambda expression, .NET 7 added generic <code>Results</code> types – for example, the type with two generic parameters: <code>Results&lt;TResult1, TResult2&gt;</code>. The generic types specify the constraint to require the <code>IResult</code> interface. The <code>Microsoft.AspNetCore.Http.HttpResults</code> namespace contains generic <code>Results</code> types from two to six generic parameters. By using <code>Results&lt;Ok&lt;UpdateGameResponse&gt;, NotFound, BadRequest&lt;InvalidGameMoveError&gt;&gt;</code>, it’s defined that the method either returns an <code>Ok</code> result with a <code>SetMoveError</code> object, <code>NotFound</code>, or <code>BadRequest</code> with an <code>InvalidGameMoveError</code> object. Because the lambda expression makes use of the <code>async</code> keyword, the complete result is put into a task: <code>Task&lt;Results&lt;Ok&lt;UpdateGameResponse&gt;, </code><code>NotFound, BadRequest&lt;InvalidGameMoveError&gt;&gt;&gt;</code>.</p>
			<p>With all this <a id="_idIndexMarker101"/>OpenAPI configuration in place, we can start the service, generate the documentation to describe the API, and use it from a web interface, as shown in <em class="italic">Figure 2</em><em class="italic">.5</em>.</p>
			<div><div><img src="img/B21217_02_05.jpg" alt="Figure 2.5 – OpenAPI documentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – OpenAPI documentation</p>
			<p>Opening an endpoint, you can see the different HTTP results returned and all the schemas created.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Testing the service</h1>
			<p>To run the<a id="_idIndexMarker102"/> service, the OpenAPI test page can be used. However, there’s a better way without leaving Visual Studio or Visual Studio Code. Visual Studio offers the <strong class="bold">Endpoints Explorer</strong> window to show all the API endpoints in your solution, as shown in <em class="italic">Figure 2</em><em class="italic">.6</em>. Open this window using <strong class="bold">View</strong> | <strong class="bold">Other Windows</strong> | <strong class="bold">Endpoints Explorer</strong>:</p>
			<div><div><img src="img/B21217_02_06.jpg" alt="Figure 2.6 – Endpoints Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Endpoints Explorer</p>
			<p>By selecting an endpoint and opening the context menu, you can generate a request. This creates an HTTP file that you can use to send HTTP requests, including the body, and see the returned results beside it.</p>
			<p class="callout-heading">Using HTTP files with Visual Studio Code</p>
			<p class="callout">If you use Visual Studio Code, install the <code>REST Client</code> extension from Huachao Mao.</p>
			<p>First, we start a game by sending a <code>POST</code> request:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Codebreaker.GameAPIs.http</p>
			<pre class="source-code">
@HostAddress = http://localhost:9400
@ContentType = application/json
### Create a game
POST {{HostAddress}}/games/
Content-Type: {{ContentType}}
{
  "gameType": "Game6x4",
  "playerName": "test"
}</pre>
			<p>The first two<a id="_idIndexMarker103"/> lines in the HTTP file specify variables that are referenced later surrounded by two curly braces. Every request specified needs to be separated by three hash characters, <code>###</code>. With this, using Visual Studio or the Visual Studio Code extension, you can see a green arrow that, when clicked, sends the request. To separate the HTTP header from the body, a blank line is required. The body to create a game contains the <code>gameType</code> and <code>playerName</code> JSON elements.</p>
			<p>After sending the request to create a game, you can set a move:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Codebreaker.GameAPIs.http</p>
			<pre class="source-code">
### Set a move
@id = 1eae1e79-a7fb-41a6-9be8-39f83537b7f3
PATCH {{HostAddress}}/games/{{id}}/moves
Content-Type: {{ContentType}}
{
  "gameType": "Game6x4",
  "playerName": "test",
  "moveNumber": 1,
  "guessPegs": [
    "Red",
    "Green",
    "Blue",
    "Yellow"
  ]
}</pre>
			<p>Before<a id="_idIndexMarker104"/> sending the move, get the ID that was returned on creation of the game, and paste it into the <code>id</code> variable used with the HTTP file. There’s no need to save this file; just clicking on the link will send the <code>PATCH</code> request. Remember to update the move number with every move.</p>
			<p>To get information about the game, send a <code>GET</code> request:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Codebreaker.GameAPIs.http</p>
			<pre class="source-code">
### Get game information
GET {{HostAddress}}/games/{{id}}</pre>
			<p>When sending the <code>GET</code> request, a body is not supplied. This request gives complete information about the game, including its moves, and the result code.</p>
			<p>By using HTTP files, you can easily debug the APIs without leaving Visual Studio. In case you’re in a debug session, you might need to change the <strong class="bold">Request timeout</strong> setting in <strong class="bold">Text Editor</strong> | <strong class="bold">Rest</strong> | <strong class="bold">Advanced settings</strong>. The HTTP files also serve as good documentation as part of the project.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Enabling .NET Aspire</h1>
			<p>Let’s<a id="_idIndexMarker105"/> add .NET Aspire to this solution. Using Visual Studio, you can select the Games API project in <strong class="bold">Solution explorer</strong> and use the context menu to select <strong class="bold">Add</strong> | <strong class="bold">.NET Aspire </strong><strong class="bold">Orchestrator Support…</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Instead of using Visual Studio, you can use the dotnet CLI to create a .NET Aspire project: <code>dotnet new aspire</code>. With the two projects created, you can connect the Games API project using the explanations from this section.</p>
			<p>This creates two projects (<code>{solution}.AppHost</code> and <code>{solution}.ServiceDefaults</code>) and makes small changes to the Games API project. The <code>AppHost</code> project is a web application that runs a dashboard to monitor all the configured services. <code>ServiceDefaults</code> is a library to specify default configurations. This library is referenced by the Games API. Let’s look into the details next.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Exploring the Aspire host</h2>
			<p>The source<a id="_idIndexMarker106"/> code of the startup code of the Aspire host is shown here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = <strong class="bold">DistributedApplication.CreateBuilder(args);</strong>
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis");</strong>
builder.Build().Run();</pre>
			<p>This Aspire host runs a web application that’s only used during development time. Here, the <code>DistributedApplication</code> class is used with the app builder pattern. The <code>CreateBuilder</code> method returns the <code>IDistributedApplicationBuilder</code> interface, which allows the configuration of all the services that should be orchestrated by the distributed application. Using this interface, similar to <code>WebApplicationBuilder</code>, the configuration and DI container can be configured. Contrary to <code>WebApplicationBuilder</code>, resources can be added that are orchestrated by the app host.</p>
			<p>A project <a id="_idIndexMarker107"/>resource is added to the resources of the builder by invoking the <code>AddProject</code> extension method. Adding a project reference to the <code>Codebreaker.GameAPIs</code> project creates the <code>Codebreaker_GameAPIs</code> class in the <code>Projects</code> namespace. The name passed with the parameter – <code>gameapis</code> – can be used when one service references another one. Currently, we only have one service in the <code>Codebreaker</code> solution, but this will change going forward with the chapters of this book.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Exploring the ServiceDefaults library</h2>
			<p>The <code>Codebreaker.ServiceDefaults</code> project is here to be referenced by all service projects <a id="_idIndexMarker108"/>making use of .NET Aspire functionality. This project adds references to NuGet packages for HTTP resiliency, service discovery, and several OpenTelemetry packages used for logging, metrics, and distributed tracing.</p>
			<p>This is the configuration defined by the <code>Extensions</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static IHostApplicationBuilder AddServiceDefaults(this IHostApplicationBuilder builder)
{
  builder.ConfigureOpenTelemetry();
  builder.AddDefaultHealthChecks();
  builder.Services.AddServiceDiscovery();
  builder.Services.ConfigureHttpClientDefaults(http =&gt;
  {
    http.AddStandardResilienceHandler();
    http.AddServiceDiscovery();
  });
  return builder;
}</pre>
			<p>The <code>AddServiceDefaults</code> method configures the DI container with OpenTelemetry for logging, default health checks, and service discovery, and configures the <code>HttpClient</code> class with resiliency.</p>
			<p>This<a id="_idIndexMarker109"/> complete configuration can be used from the Codebreaker Games API by invoking the <code>AddServiceDefaults</code> method with the application builder. This invocation is added from the Visual Studio .NET Aspire integration when adding Aspire orchestration. If you created the .NET Aspire projects from the command line, you need to add the invocation to the <code>AddServiceDefaults</code> method when configuring the DI container.</p>
			<p>Another extension method defined by the service defaults library is <code>MapDefaultEndpoints</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static WebApplication MapDefaultEndpoints(this WebApplication app)
{
  app.MapHealthChecks("/health");
  app.MapHealthChecks("/alive", new HealthCheckOptions
  {
    Predicate = r =&gt; r.Tags.Contains("live")
  });
  return app;
}</pre>
			<p>This is <a id="_idIndexMarker110"/>an extension method to configure the ASP.NET Core middleware with health checks. The <code>MapDefaultEndpoints</code> method needs to be invoked with the middleware configuration of the Games API.</p>
			<p>All the functionality mentioned here will be discussed in detail in the following chapters. Now, you can already start the Aspire host project, which, in turn, starts up the Games API.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Running the .NET Aspire host</h2>
			<p>When<a id="_idIndexMarker111"/> running the .NET Aspire host, a dashboard is shown that shows the <code>codebreaker.gameapis</code> project with the resources where you can access endpoints, check environment variables, and open log information, as shown in <em class="italic">Figure 2</em><em class="italic">.7</em>.</p>
			<div><div><img src="img/B21217_02_07.jpg" alt="Figure 2.7 – Resources in the .NET Aspire dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Resources in the .NET Aspire dashboard</p>
			<p>While the Aspire host is running, you can play games using the HTTP files created earlier, and now monitor the logs, metrics information, and traces (shown in <em class="italic">Figure 2</em><em class="italic">.8</em>).</p>
			<div><div><img src="img/B21217_02_08.jpg" alt="Figure 2.8 – Traces in the .NET Aspire dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Traces in the .NET Aspire dashboard</p>
			<p>Details on<a id="_idIndexMarker112"/> logging, metrics, tracing, and adding custom information are covered in <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>, <em class="italic">Logging </em><em class="italic">and Monitoring</em>.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Summary</h1>
			<p>In this chapter, we created a Web API using ASP.NET Core minimal APIs. We covered creating services and an in-memory repository, configured them with the dependency injection container, created models, and used game analyzer classes to calculate moves.</p>
			<p>We created endpoints to create, read, and update games, specified information to show up with the OpenAPI documentation, tested the service using HTTP files, and finally, added .NET Aspire for hosting and a dashboard.</p>
			<p>After working through this chapter, you deserve a break to play a game. Use the HTTP files to create a game and set moves until the answer returned shows that you won. Don’t cheat by making <code>GET</code> requests to the game before you find the answer!</p>
			<p>In the next chapter, we’ll replace the repository by using Entity Framework Core with SQL Server and Azure Cosmos DB to have a persistent games store.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li><em class="italic">Primary </em><em class="italic">constructors</em>: <a href="https://csharp.christiannagel.com/2023/03/28/primaryctors/">https://csharp.christiannagel.com/2023/03/28/primaryctors/</a></li>
				<li><em class="italic">Microsoft REST API </em><em class="italic">Guidelines</em>: <a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md">https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md</a></li>
				<li><em class="italic">The OpenAPI </em><em class="italic">Initiative</em>: <a href="https://www.openapis.org/">https://www.openapis.org/</a></li>
				<li><em class="italic">Minimal APIs parameter </em><em class="italic">binding</em>: https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis/parameter-binding</li>
				<li><em class="italic">JSON serialization </em><em class="italic">customization</em>: <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/">https://learn.microsoft.com/en-us/dotnet/standard/serialization/</a></li>
				<li>The <code>Swashbuckle.AspNetCore</code> GitHub repo: https://github.com/domaindrivendev/Swashbuckle.AspNetCore</li>
				<li>.NET Aspire documentation: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/">https://learn.microsoft.com/en-us/dotnet/aspire/</a></li>
			</ul>
		</div>
	</body></html>