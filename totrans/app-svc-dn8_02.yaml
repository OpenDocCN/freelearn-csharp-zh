- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Relational Data Using SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about managing relational data stored in SQL Server, Azure SQL
    Database, or Azure SQL Edge. First, you will learn how to manage the data using
    native Transact-SQL statements. Next, you will learn how to manage data at a low
    level using ADO.NET libraries (`Microsoft.Data.SqlClient`). Finally, you will
    use Dapper to make it easier to work with entity models.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data with Transact-SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing SQL Server data with low-level APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing SQL Server data with Dapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up data resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding modern databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the most common places to store data are in a **Relational Database Management
    System** (**RDBMS**) such as **SQL Server**, **PostgreSQL**, **MySQL**, and **SQLite**,
    or in a **NoSQL** database such as **Azure Cosmos DB**, **MongoDB**, **Redis**,
    and **Apache Cassandra**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the most popular RDBMS for Windows, which
    is SQL Server. This product is also available in a version for Linux. For cross-platform
    development, you can use either Azure SQL Database, which stores the data in the
    cloud, or Azure SQL Edge, which can run in a Docker container on Windows, macOS,
    or Linux, on both Intel and ARM architecture CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Using a sample relational database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn how to manage an RDBMS using .NET, it would be useful to have a sample
    one so that you can practice on a database that has a medium complexity and a
    decent number of sample records.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft offers several sample databases, most of which are too complex for
    our needs, so instead, we will use a database that was first created in the early
    1990s known as **Northwind**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a minute to look at a diagram of the Northwind database and its
    eight most important tables. You can use the diagram in *Figure 2.1* to refer
    to as we write code and queries throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The Northwind database tables and relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that:'
  prefs: []
  type: TYPE_NORMAL
- en: Each category has a unique identifier, name, description, and picture. The picture
    is stored as a byte array in JPEG format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product has a unique identifier, name, unit price, number of units in stock,
    and other columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product is associated with a category by storing the category’s unique
    identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship between `Categories` and `Products` is one-to-many, meaning
    each category can have zero, one, or more products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product is supplied by a supplier company indicated by storing the supplier’s
    unique identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quantity and unit price of a product is stored for each detail of an order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each order is made by a customer, taken by an employee, and shipped by a shipping
    company.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each employee has a name, address, contact details, birth, and hire dates, a
    reference to their manager (except for the boss, whose `ReportsTo` field is `null`),
    and a photo stored as a byte array in JPEG format. The table has a one-to-many
    relationship to itself because one employee can manage many other employees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a SQL Server database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect to a SQL Server database, we need to know multiple pieces of information,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the server (and the name of the instance if it has more than the
    default one). This can include the protocol, IP address, and port number if connecting
    over a network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security information, such as the username and password, or if we should pass
    the currently logged-on user’s credentials automatically using Windows Authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specify this information in a **connection string**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backward compatibility, there are multiple possible keywords we can use
    in a SQL Server connection string for the various parameters, as shown in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Data Source`, `server`, or `addr`: These keywords are the name of the server
    (and an optional instance). You can use a dot (`.`) to mean the local server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Initial Catalog` or `database`: These keywords are the name of the database
    that will be active initially. A SQL statement could change that using the command:
    `USE <databasename>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Integrated Security` or `trusted_connection`: These keywords are set to `true`
    or `SSPI` to pass the thread’s current user credentials using Windows Authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User Id` and `Password`: These keywords are used to authenticate with any
    edition of SQL Server. This is important for Azure SQL Database or Azure SQL Edge
    because they do not support Windows Authentication. The full edition of SQL Server
    on Windows supports both username with password and Windows Authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Authentication`: This keyword is used to authenticate by using Azure AD identities
    that can enable password-less authentication. Values can be `Active Directory
    Integrated`, `Active Directory Password`, and `Sql Password`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Persist Security Info`: If set to `false`, this keyword tells the connection
    to remove the `Password` from the connection string after authenticating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Encrypt`: If set to `true`, this keyword tells the connections to use SSL
    to encrypt transmissions between client and server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TrustServerCertificate`: Set to `true` if hosting locally and you get the
    error “A connection was successfully established with the server, but then an
    error occurred during the login process. (provider: SSL Provider, error: 0 - The
    certificate chain was issued by an authority that is not trusted.)”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connection Timeout`: This keyword defaults to 30 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultipleActiveResultSets`: This keyword is set to `true` to enable a single
    connection to be used to work with multiple tables simultaneously to improve efficiency.
    It is used for lazy loading rows from related tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As described in the list above, when you write code to connect to a SQL Server
    database, you need to know its server name. The server name depends on the edition
    and version of SQL Server that you will connect to, as shown in *Table 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SQL Server edition** | **Server name \ Instance name** |'
  prefs: []
  type: TYPE_TB
- en: '| LocalDB 2012 | `(localdb)\v11.0` |'
  prefs: []
  type: TYPE_TB
- en: '| LocalDB 2016 or later | `(localdb)\mssqllocaldb` |'
  prefs: []
  type: TYPE_TB
- en: '| Express | `.\sqlexpress` |'
  prefs: []
  type: TYPE_TB
- en: '| Full/Developer (default instance) | `.` |'
  prefs: []
  type: TYPE_TB
- en: '| Full/Developer (named instance) | `.\apps-services-book` |'
  prefs: []
  type: TYPE_TB
- en: '| Azure SQL Edge (local Docker) | `tcp:127.0.0.1,1433` |'
  prefs: []
  type: TYPE_TB
- en: '| Azure SQL Database | `tcp:[custom server name].database.windows.net,1433`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Server name examples for various editions of SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use a dot (.) as shorthand for the local computer name (localhost).
    Remember that server names for SQL Server can be made up of two parts: the name
    of the computer and the name of a SQL Server instance. You provide instance names
    during custom installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up SQL Server locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft offers various editions of its popular and capable SQL Server product
    for Windows, Linux, and Docker containers. If you have Windows, then you can use
    a free version that runs standalone, known as SQL Server Developer Edition. You
    can also use the Express edition or the free SQL Server LocalDB edition that can
    be installed with Visual Studio 2022 for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have a Windows computer or if you want to use a cross-platform
    database system, then you can skip ahead to the topic *Setting up Azure SQL Database*,
    or the online-only section *Installing Azure SQL Edge in Docker* found at the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch02-sql-edge.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch02-sql-edge.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to install SQL Server locally on Linux, then you will find instructions
    at the following link: [https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-setup](https://learn.microsoft.com/en-us/sql/linux/sql-server-linux-setup).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing SQL Server Developer Edition for Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Windows, if you want to use the full edition of SQL Server instead of the
    simplified LocalDB or Express editions, then you can find all SQL Server editions
    at the following link: [https://www.microsoft.com/en-us/sql-server/sql-server-downloads](https://www.microsoft.com/en-us/sql-server/sql-server-downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the **Developer** edition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Custom** installation type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a folder for the installation files and then click **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the 1.5 GB of installer files to download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **SQL Server Installation Center**, click **Installation**, and then click
    **New SQL Server stand-alone installation or add features to an existing installation**,
    as shown in *Figure 2.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Installing a new instance of SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Developer** as the free edition and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the license terms and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the **Microsoft Update** options and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the install rules, fix any issues although you might want to ignore any
    firewall warnings since you might not want to expose those ports anyway, and then
    click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Feature Selection**, select **Database Engine Services**, and then click
    **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Azure Extension for SQL Server**, you can turn this off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Instance Configuration**, select **Default instance**, and then click **Next**.
    If you already have a default instance configured, then you could create a named
    instance, perhaps called `apps-services-book`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Server Configuration**, note the **SQL Server Database Engine** is configured
    to start automatically. If not already set by default, then set the **SQL Server
    Browser** to start automatically, and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Database Engine Configuration**, on the **Server Configuration** tab, set
    **Authentication Mode** to **Mixed**, set the **sa** account password to a strong
    password, click **Add Current User**, and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Ready to Install**, review the actions that will be taken, and then click
    **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Complete**, note the successful actions taken, and then click **Close**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **SQL Server Installation Center**, in **Installation**, click **Install
    SQL Server Management Tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the browser window, click to download the latest version of SSMS, as shown
    in *Figure 2.3*:![](img/B19587_02_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.3: Downloading SQL Server Management Studio (SSMS)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The direct link to download SSMS is as follows: [https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms](https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the SSMS installer and click **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the installer has finished, click **Restart** if needed or **Close**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Azure Data Studio** (**ADS**) is automatically installed alongside SSMS.
    ADS is cross-platform and open-source, so you can use it to work with SQL Server
    databases on any desktop operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code extension for working with SQL Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many tools that make it easy to work with SQL Server. If you are
    using Visual Studio Code, then you can install the **SQL Server (mssql)** `ms-mssql.mssql`
    extension. If you install the extension, it adds a new view to the Primary Side
    Bar titled **SQL Server**, as shown in *Figure 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19587_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: SQL Server (mssql) extension for Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Northwind sample database locally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can run a database script to create the Northwind sample database locally
    on Windows using **SQL Server Management Studio** (**SSMS**):'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not previously downloaded or cloned the GitHub repository for this
    book, then do so now using the following link: [https://github.com/markjprice/apps-services-net8/](https://github.com/markjprice/apps-services-net8/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your `apps-services-net8` folder, create a folder named `Chapter02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the script to create the Northwind database for SQL Server from the following
    path in your local Git repository: `/scripts/sql-scripts/Northwind4SQLServer.sql`
    into the `Chapter02` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start **SQL Server Management Studio**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Connect to Server** dialog, for **Server name**, enter `.` (a dot),
    meaning the local computer name, and then click **Connect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Warning!** If you had to create a named instance, like `apps-services-book`,
    then enter `.\apps-services-book`. If you see an error about the server certificate,
    then click the **Options >>** button and select the **Trust server certificate**
    check box.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to **File** | **Open** | **File...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to select the `Northwind4SQLServer.sql` file and then click **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the toolbar, click **Execute**, and note the **Command(s) completed successfully**
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Object Explorer**, expand the **Northwind** database, and then expand **Tables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click **Products**, click **Select Top 1000 Rows**, and note the returned
    results, as shown in *Figure 2.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19587_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: The Products table in SQL Server Management Studio'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Object Explorer** toolbar, click the **Disconnect** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit **SQL Server Management Studio**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We did not have to use **SQL Server Management Studio** to execute the database
    script. We can also use tools in Visual Studio 2022, including the **SQL Server
    Object Explorer** and **Server Explorer**, or cross-platform tools like the Visual
    Studio Code extension for SQL Server, or **Azure Data Studio**, which you can
    download and install separately from the following link: [https://aka.ms/getazuredatastudio](https://aka.ms/getazuredatastudio).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Azure SQL Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you do not have a Windows computer, then you can create a cloud-hosted instance
    of SQL Server. You will need an Azure account. You can sign up at the following
    link: [https://signup.azure.com](https://signup.azure.com). Next, you need to
    take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your Azure account: [https://portal.azure.com/](https://portal.azure.com/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to [https://portal.azure.com/#create/hub](https://portal.azure.com/#create/hub).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for **Resource group** and then click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a resource group name of `apps-services-book` and select a suitable region
    close to you, and then click the **Review + create** button, as shown in *Figure
    2.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Creating a resource group in the Azure portal'
  prefs: []
  type: TYPE_NORMAL
- en: Review your choices and then click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another resource, search for **SQL Database**, and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create SQL Database** page, in the **Basics** tab, for the **Database
    name**, enter `Northwind`, and select the resource group that you created before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Server** section, click **Create New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following details for the SQL Database server, as shown in *Figure
    2.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Server name**: `apps-services-book-[your initials]` or something else entirely.
    The server name must be globally unique because it becomes part of a public URL.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location**: A region close to you. I chose **(Europe) UK South**. Not all
    regions support all types of resources. You will see an error if the region you
    select does not support SQL Database server resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication method**: Use SQL authentication.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server admin login**: [Your email or another username], for example, I entered
    `markjprice`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**/**Confirm password**: [Enter a strong password].'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B19587_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Entering the server details for a SQL Database instance'
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave **Want to use SQL elastic pool** set to **No**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Workload environment**, select **Development** (instead of **Production**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create SQL Database** page, in the **Compute + storage** section, click
    **Configure database**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Service tier**, select **Basic (For less demanding workloads)**. Note
    the maximum database size is 2 GB and the estimated cost is about $5 per month
    (or less than 1 cent per hour). You can delete the resources as soon as you have
    completed this chapter to reduce the cost further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create SQL Database** page, set **Backup storage redundancy** to **Locally-redundant
    backup storage**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Next : Networking** button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Network connectivity** section, select **Public endpoint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Firewall rules** section, set **Add current client IP address** to
    **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Next : Security** button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the options but leave them as the defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Next : Additional settings** button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the options but leave them as the defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Review + create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the deployment to complete, as shown in *Figure 2.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Deployment progress for SQL Database'
  prefs: []
  type: TYPE_NORMAL
- en: When deployment has completed, click **Go to resource**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Overview** and note the database details, as shown in *Figure 2.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: SQL Database details'
  prefs: []
  type: TYPE_NORMAL
- en: Click **See connection strings** (or click **Connection strings** in the left
    navigation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the **ADO.NET (SQL authentication)** connection string to your clipboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start **Notepad** or your preferred plain text editor, paste the connection
    string, and add carriage returns after each semicolon to separate each part to
    make them easier to work with, as shown in the following text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your `Server` value will be different because the custom server name part, for
    example, `apps-services-book`, is public and must be globally unique.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, save the Notepad file for future reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JetBrains Rider tool window for working with SQL Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use JetBrains Rider on any operating system, then you can use the following
    steps to connect with a SQL Server database:'
  prefs: []
  type: TYPE_NORMAL
- en: In JetBrains Rider, select **View** | **Tool Windows** | **Database**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Database** tool window, click **Connect to database...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Use connection string** option button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Database type** to **Microsoft SQL Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **String** box, enter the database connection string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `{your_password}` to the password you chose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, click **Test Connection** and correct any errors if necessary. If
    you get an **Inconsistent language** error, then you can ignore it as we are using
    SQL Server as the dialect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Connect to Database**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the Northwind sample database in the cloud
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can run a database script to create the Northwind sample database in
    the Azure SQL Database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred database tool to connect to the SQL server in Azure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio 2022, view **Server Explorer**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, start **SQL Server Management Studio**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Visual Studio Code, view the **SQL Server** tool.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In JetBrains Rider, navigate to **View** | **Tool Windows** | **Database**,
    and then click **Connect to database…**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a data connection, and fill in the dialog box with all the required connection
    string information, as shown in *Figure 2.10*:![](img/B19587_02_10.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.10: Connecting to your Azure SQL database from Visual Studio'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might also be prompted to **Choose** **Data Source**. Choose **Microsoft
    SQL Server**. You can select a checkbox to always use this selection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click the data connection and choose **New Query**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using JetBrains Rider, then right-click the SQL Server, in the popup
    menu, select **SQL Scripts** | **Run SQL Script…**, and then select the `Northwind4AzureSQLdatabase.sql`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy and paste the contents of the `Northwind4AzureSQLdatabase.sql` file into
    the query window and execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main difference between the `Northwind4SQLServer.sql` and `Northwind4AzureSQLdatabase.sql`
    scripts is that the local SQL Server script will delete and recreate the Northwind
    database. The Azure SQL database script will not because the database needs to
    be created as an Azure resource. You can download SQL script files from the following
    link: [https://github.com/markjprice/apps-services-net8/tree/main/scripts/sql-scripts](https://github.com/markjprice/apps-services-net8/tree/main/scripts/sql-scripts).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wait to see the **Command completed successfully** message. This can take a
    few minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Server Explorer**, right-click **Tables** and select **Refresh**, and note
    that 13 tables have been created, for example, **Categories**, **Customers**,
    and **Products**. Also note that dozens of views and stored procedures have also
    been created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have a running Azure SQL database in the cloud that you can connect
    to from a .NET project.
  prefs: []
  type: TYPE_NORMAL
- en: Managing data with Transact-SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Transact-SQL** (**T-SQL**) is SQL Server’s dialect of **Structured Query
    Language** (**SQL**). Some pronounce it *tee-sequel*, others *tee-es-queue-el*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C#, T-SQL is not case-sensitive; for example, you can use `int` or `INT`
    to specify the 32-bit integer data type, and you can use `SELECT` or `select`
    to start a query expression. Text data stored in SQL Server tables can be treated
    as case-sensitive or not, depending on the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete reference for T-SQL is found at the following link: [https://learn.microsoft.com/en-us/sql/t-sql/language-reference](https://learn.microsoft.com/en-us/sql/t-sql/language-reference).
    From that documentation starting page, use the left side navigation to view topics
    like **Data types**, **Queries**, and **Statements**.'
  prefs: []
  type: TYPE_NORMAL
- en: T-SQL data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'T-SQL has data types that are used for columns, variables, parameters, and
    so on, as shown in *Table 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| Numbers | `bigint`, `bit`, `decimal`, `float`, `int`, `money`, `numeric`,
    `real`, `smallint`, `smallmoney`, `tinyint` |'
  prefs: []
  type: TYPE_TB
- en: '| Date and time | `date`, `datetime2`, `datetime`, `datetimeoffset`, `smalldatetime`,
    `time` |'
  prefs: []
  type: TYPE_TB
- en: '| Text | `char`, `nchar`, `ntext`, `nvarchar`, `text`, `varchar` |'
  prefs: []
  type: TYPE_TB
- en: '| Binary | `binary`, `image`, `varbinary` |'
  prefs: []
  type: TYPE_TB
- en: '| Other | `cursor`, `hierarchyid`, `sql_variant`, `table`, `rowversion`, `uniqueidentifier`,
    `xml` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: Categories of SQL Server data types'
  prefs: []
  type: TYPE_NORMAL
- en: There is an `xml` data type but no JSON data type. Use `nvarchar` to store JSON
    values. T-SQL also has support for spatial `geometry` and `geography` types.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting with comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To comment out the rest of a line, use `--`, which is the equivalent of `//`.
  prefs: []
  type: TYPE_NORMAL
- en: To comment out a block, use `/*` at the start and `*/` at the end, just like
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Local variable names are prefixed with `@` and they are defined using `SET`,
    `SELECT`, or `DECLARE`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Global variables are prefixed with `@@`. For example, `@@ROWCOUNT` is a context-dependent
    value that returns the number of rows affected by a statement executed within
    the current scope, for example, the number of rows updated or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most types have a fixed size. For example, an `int` uses four bytes, a `smallint`
    uses two bytes, and a `tinyint` uses one byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'For text and binary types, you can either specify a type prefixed with `var`
    or `nvar` (meaning variable size), which will automatically change its size based
    on its current value up to a maximum, as shown in the following example: `varchar(40)`;
    or you can specify a fixed number of characters that will always be allocated,
    as shown in the following example: `char(40)`.'
  prefs: []
  type: TYPE_NORMAL
- en: For text types, the `n` prefix indicates Unicode, meaning it will use two bytes
    per character. Text types not prefixed with `n` use one byte per character.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: T-SQL has similar flow control keywords as C#, for example, `BREAK`, `CONTINUE`,
    `GOTO`, `IF...ELSE`, `CASE`, `THROW`, `TRY...CATCH`, `WHILE`, and `RETURN`. The
    main difference is the use of `BEGIN` and `END` to indicate the start and end
    of a block, the equivalent of curly braces in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: T-SQL has similar operators as C#, for example, `=` (assignment), `+`, `-`,
    `*`, `/`, `%`, `<`, `>`, `<=`, `==`, `!=`, `&`, `|`, `^`, and so on. It has logical
    operators like `AND`, `OR`, `NOT`, and LINQ-like operators like `ANY`, `ALL`,
    `SOME`, `EXISTS`, `BETWEEN`, and `IN`.
  prefs: []
  type: TYPE_NORMAL
- en: '`LIKE` is used for text pattern matching. The pattern can use `%` for any number
    of characters. The pattern can use `_` for a single character. The pattern can
    use `[]` to specify a range and set of allowed characters, for example, `[0-9A-Z.-,]`,
    which looks like a simplified regular expression syntax but keep in mind that
    it is *not* regular expression syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: If a table or column name contains spaces, then you must surround the name in
    square brackets, like `[Order Details]`. The SQL scripts to create the Northwind
    database include the command `set quoted_identifier on`, so you can also use double
    quotes, like `"Order Details"`. Single quotes are used for literal text, like
    `'USA'`.
  prefs: []
  type: TYPE_NORMAL
- en: Data Manipulation Language (DML)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DML is used to query and change data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common statement in DML is `SELECT`, which is used to retrieve data
    from one or more tables. `SELECT` is extremely complicated because it is so powerful.
    This book is not about learning T-SQL, so the quickest way to get a feel for `SELECT`
    is to see some examples, as shown in *Table 2.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT *``FROM Employees` | Get all columns of all the employees. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT FirstName, LastName``FROM Employees` | Get the first and last name
    columns of all employees. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT emp.FirstName, emp.LastName``FROM Employees AS emp` | Give an alias
    for the table name. Table name prefixes are not needed when there is only one
    table, but become useful to disambiguate when there are multiple tables that have
    columns with the same name, for example, `Customers.CustomerId` and `Orders.CustomerId`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT emp.FirstName, emp.LastName``FROM Employees emp` | Give an alias
    for the table name without needing the `AS` keyword. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT FirstName, LastName AS Surname``FROM Employees` | Give an alias for
    the column name. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT FirstName, LastName``FROM Employees``WHERE Country = ''USA''` | Filter
    the results to only include employees in the USA. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT DISTINCT Country``FROM Employees` | Get a list of countries used
    as values in the `Country` column of the `Employees` table without duplicates.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT UnitPrice * Quantity AS Subtotal``FROM [Order Details]` | Calculate
    a subtotal for each order detail row. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT OrderId,``SUM(UnitPrice * Quantity) AS Total``FROM [Order Details]``GROUP
    BY OrderId``ORDER BY Total DESC` | Calculate a total for each order and sort with
    the largest order value at the top. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT CompanyName``FROM Customers``UNION``SELECT CompanyName``FROM Suppliers`
    | Return all the company names of all customers and suppliers. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT CategoryName, ProductName``FROM Categories, Products` | Match *every*
    category with *every* product using a Cartesian join and output their names (not
    what you normally want!).616 rows (8 categories x 77 products). |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT CategoryName, ProductName``FROM Categories c, Products p``WHERE c.CategoryId
    = p.CategoryId` | Match each product with its category using a `WHERE` clause
    for the `CategoryId` column in each table and output the category name and product
    name.77 rows. |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT CategoryName, ProductName``FROM Categories c``INNER JOIN Products
    p``ON c.CategoryId = p.CategoryId` | Match each product with its category using
    an `INNER JOIN...ON` clause for the `CategoryId` column in each table and output
    the category name and product name. This is a modern alternative syntax to using
    `WHERE`, and it allows outer joins, which would also include non-matches.77 rows.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: Example SELECT statements with descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can read the full documentation for `SELECT` at the
    following link: [https://learn.microsoft.com/en-us/sql/t-sql/queries/select-transact-sql](https://learn.microsoft.com/en-us/sql/t-sql/queries/select-transact-sql).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite database querying tool, like Visual Studio’s **Server Explorer**
    or Visual Studio Code’s `mssql` extension, to connect to your Northwind database
    and try out some of the queries above, as shown in *Figure 2.11* and *Figure 2:12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Executing T-SQL queries using Visual Studio’s Server Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Executing T-SQL queries using Visual Studio Code’s mssql extension'
  prefs: []
  type: TYPE_NORMAL
- en: DML for adding, updating, and deleting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DML statements for adding, updating, and deleting data include those shown
    in *Table 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `INSERT Employees(FirstName, LastName)``VALUES(''Mark'', ''Price'')` | Add
    a new row to the `Employees` table. The `EmployeeId` primary key value is automatically
    assigned. Use `@@IDENTITY` to get this value. |'
  prefs: []
  type: TYPE_TB
- en: '| `UPDATE Employees``SET Country = ''UK''``WHERE FirstName = ''Mark''``AND
    LastName = ''Price''` | Update my employee row to set my `Country` to `UK`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE Employees``WHERE FirstName = ''Mark''``AND LastName = ''Price''`
    | Delete my employee row. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE Employees` | Delete all rows in the `Employees` table and record
    those deletions in the transaction log. |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUNCATE TABLE Employees` | Delete all rows in the `Employees` table more
    efficiently because it does not log the individual row deletions. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.4: Example DML statements with descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: The above examples use the `Employees` table in the `Northwind` database. That
    table has referential integrity constraints that would mean that, for example,
    deleting all rows in the table cannot happen because every employee has related
    data in other tables like `Orders`.
  prefs: []
  type: TYPE_NORMAL
- en: Data Definition Language (DDL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DDL statements change the structure of the database, including creating new
    objects like tables, functions, and stored procedures. The following table shows
    some examples of DDL statements to give you an idea, but the examples are simple
    and cannot be executed within the Northwind database, as shown in *Table 2.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `CREATE TABLE dbo.Shippers (``ShipperId INT PRIMARY KEY CLUSTERED,``CompanyName
    NVARCHAR(40)``);` | Create a table to store shippers. |'
  prefs: []
  type: TYPE_TB
- en: '| `ALTER TABLE Shippers``ADD Country NVARCHAR(40)` | Add a column to a table.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CREATE NONCLUSTERED INDEX IX_Country``ON Shippers(Country)` | Add a non-clustered
    index for a column in a table. |'
  prefs: []
  type: TYPE_TB
- en: '| `CREATE INDEX IX_FullName``ON Employees(LastName, FirstName DESC)``WITH (DROP_EXISTING
    = ON)` | Change an aggregate index with multiple columns and control the sort
    order. |'
  prefs: []
  type: TYPE_TB
- en: '| `DROP TABLE Employees` | Delete the `Employees` table. If it does not exist,
    then this throws an error. |'
  prefs: []
  type: TYPE_TB
- en: '| `DROP TABLE IF EXISTS Employees` | Delete the `Employees` table if it already
    exists. This avoids the potential error from using the statement in the previous
    row. |'
  prefs: []
  type: TYPE_TB
- en: '| `IF OBJECT_ID(N''Employees'', N''U'')``IS NOT NULL` | Check if a table exists.
    The `N` prefix before a text literal means Unicode. `''U''` means a user table
    as opposed to a system table. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.5: Example DDL statements with descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: Managing data with low-level APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Microsoft.Data.SqlClient` package provides database connectivity to SQL
    Server for .NET applications. It is also known as the **ADO.NET driver for SQL
    Server** and Azure SQL Database.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can find the GitHub repository for ADO.NET at the
    following link: [https://github.com/dotnet/SqlClient](https://github.com/dotnet/SqlClient).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Microsoft.Data.SqlClient` package supports the following .NET platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.6.2 and later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 3.1 and later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Standard 2.0 and later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the types in ADO.NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ADO.NET defines abstract types that represent minimal objects for working with
    data, like `DbConnection`, `DbCommand`, and `DbDataReader`. Database software
    manufacturers can inherit from and provide specific implementations that are optimized
    for and expose additional features for their database. Microsoft has done this
    for SQL Server. The most important types with their most used members are shown
    in *Table 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Properties** | **Methods** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlConnection` | `ConnectionString`,`State`,`ServerVersion` | `Open`, `Close`,`CreateCommand`,`RetrieveStatistics`
    | Manage the connection to the database. |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlConnectionStringBuilder` | `InitialCatalog`, `DataSource`, `Encrypt`,
    `UserID`, `Password`, `ConnectTimeout`, and so on | `Clear`, `ContainsKey`, `Remove`
    | Build a valid connection string for a SQL Server database.After setting all
    the relevant individual properties, get the `ConnectionString` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlCommand` | `Connection,``CommandType,``CommandText,``Parameters,``Transaction`
    | `ExecuteReader`,`ExecuteNonQuery`,`ExecuteXmlReader`,`CreateParameter` | Configure
    the command to execute. |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlParameter` | `ParameterName`,`Value`, `DbType,``SqlValue`,`SqlDbType,``Direction`,`IsNullable`
    |  | Configure a parameter for a command. |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlDataReader` | `FieldCount`,`HasRows`,`IsClosed`,`RecordsAffected` | `Read`,
    `Close`,`GetOrdinal`,`GetInt32`, `GetString`,`GetDecimal`,`GetFieldValue<T>` |
    Process the result set from executing a query. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.6: Important types in ADO.NET SqlClient'
  prefs: []
  type: TYPE_NORMAL
- en: '`SqlConnection` has two useful events: `StateChange` and `InfoMessage`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the `ExecuteXxx` methods of `SqlCommand` will execute any command. The
    one you use depends on what you expect to get back:'
  prefs: []
  type: TYPE_NORMAL
- en: If the command includes at least one `SELECT` statement that returns a result
    set, then call `ExecuteReader` to execute the command. This method returns a `DbDataReader`-derived
    object for reading row-by-row through the result set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command does not include at least one `SELECT` statement, then it is
    more efficient to call `ExecuteNonQuery`. This method returns an integer for the
    number of rows affected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command includes at least one `SELECT` statement that returns XML because
    it uses the `AS XML` command, then call `ExecuteXmlReader` to execute the command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a console app for working with ADO.NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a console app project for working with ADO.NET:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a console app project, as defined
    in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter02`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Console.SqlClient`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publish**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice:** For all the projects that you create for this book, keep
    your root path short and avoid using `#` in your folder and file names, or you
    might see compiler errors like `RSG002: TargetPath not specified for additional
    file`. For example, do *not* use `C:\My C# projects\` as your root path!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the project file, treat warnings as errors, add a package reference for
    the latest version of `Microsoft.Data.SqlClient`, and statically and globally
    import `System.Console`, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can check the most recent version of the package at the following link:
    [https://www.nuget.org/packages/Microsoft.Data.SqlClient#versions-body-tab](https://www.nuget.org/packages/Microsoft.Data.SqlClient#versions-body-tab).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the project to restore the referenced package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class file named `Program.Helpers.cs`, and modify its contents to
    define a method to configure the console to enable special characters like the
    Euro currency symbol and set the current culture, and a method that will output
    some text to the console in a specified color, with a default color of black,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default foreground color in the preceding code is white because I have assumed
    that most readers will have a default background color of black. On my computer,
    I set the default background color of the console to white so that I can take
    screenshots for this book. Set whatever default color is best for your computer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new class file named `Program.EventHandlers.cs`, and modify its contents
    to define methods that will act as event handlers for a database connection state
    change by showing the original and current states, and for when the database sends
    an `InfoMessage`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements. Add statements to connect
    to SQL Server locally, to Azure SQL Database, or to SQL Edge, using either SQL
    authentication with a user ID and password or Windows Authentication without a
    user ID and password, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: In this coding task, we prompt the user to enter the password
    to connect to the database. In a real-world app you are more likely to store the
    password in an environment variable or secure storage like Azure Key Vault. You
    must definitely never store passwords in your source code!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app, select options that work with your SQL Server setup, and
    note the results, including the state change event output written in dark yellow
    to make them easier to see, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following steps show the experience when connecting to Azure SQL Database
    or Azure SQL Edge, which require a username and password. If you are connecting
    to a local SQL Server using Windows Integrated Security, then you will not need
    to enter a password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app, select choices that require a user ID and password, for
    example, with Azure SQL Database, and note the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, select choices that require a user ID and password, enter
    a wrong password, and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, change the server name (the `DataSource` property) to something
    wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and note the result (depending on where your database is
    hosted, the exception message might be slightly different), as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When opening a SQL Server connection, the default timeout is 30 seconds for
    server connection problems, so be patient! We changed the timeout to 10 seconds
    to avoid having to wait so long.
  prefs: []
  type: TYPE_NORMAL
- en: Executing queries and working with data readers using ADO.NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a successful connection to the SQL Server database, we can
    run commands that retrieve rows from a table and process the results using a data
    reader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import the namespace for working with ADO.NET command types,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: To save space in this book, I will use the names `cmd` and
    `r` to represent an SQL command and an SQL data reader. In your code, give variables
    proper word names like `command` and `reader`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before the statement that closes the connection, add statements to define a
    command that selects the ID, name, and price from the `Products` table, executes
    it, and outputs the product IDs, names, and prices using a data reader, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We format the unit price using the `C` format, which uses the current culture
    to format currency values. The call to `ConfigureConsole` sets the current culture
    to US English so the output for all readers uses `$`. To test alternative cultures
    like French that use the Euro currency symbol, modify the call at the top of the
    `Program.cs` file, as shown in the following code: `ConfigureConsole("fr-FR");`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app and note the results, as shown in the following partial
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, modify the SQL statement to define a parameter for the unit
    price and use it to filter the results to products that cost more than that unit
    price, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, enter a unit price like `50`, and note the results, as
    shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Outputting statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An ADO.NET connection can track useful statistics during its lifetime, including
    those listed in *Table 2.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `BuffersReceived`, `BuffersSent`, `BytesReceived`, `BytesSent` | Data is
    transmitted as bytes stored in buffers. |'
  prefs: []
  type: TYPE_TB
- en: '| `CursorOpens` | Cursors are an expensive operation because they require state
    on the server, and should be avoided when possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `Prepares`, `PreparedExecs`, `UnpreparedExecs` | Number of prepares (compilations),
    executions of prepared commands, and executions of unprepared commands. |'
  prefs: []
  type: TYPE_TB
- en: '| `SelectCount`, `SelectRows` | Number of `SELECT` statements and rows returned
    by `SELECT` statements. |'
  prefs: []
  type: TYPE_TB
- en: '| `ServerRoundtrips`, `SumResultSets`, `Transactions` | Number of server round
    trips, result sets, and transactions. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionTime`, `ExecutionTime`, `NetworkServerTime` | Time in milliseconds
    spent connected, executing commands, or due to the network. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.7: Connection statistics that can be tracked'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s enable this and output some of those statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, import the namespaces for working with ADO.NET and
    common collections, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Helpers.cs`, in the partial `Program` class, add a method to output
    statistics about the current connection, with an array of string values to control
    which of the dozen or more statistics we want to output, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, after writing the SQL Server version to the console, add a
    statement to enable statistics for the connection, as shown highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, before closing the connection, add a statement to output statistics
    for the connection, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the statistics, as shown in the following partial
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with ADO.NET asynchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can improve the responsiveness of data access code by making it asynchronous.
    You will see more details of how asynchronous operations work in *Chapter 5*,*Multitasking
    and Concurrency*. For now, just enter the code as instructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to change the statements to work asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, change the statement to open the connection to make it asynchronous,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, change the statement to execute the command to make it asynchronous,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, change the statements to read the next row and get the field
    values to make them asynchronous, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, change the statements to close the data reader and connection
    to make them asynchronous, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console app and confirm that it has the same results as before, but
    it would run better in a multithreaded system, for example, not blocking the user
    interface in a GUI app, and not blocking I/O threads in a website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing stored procedures using ADO.NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to execute the same query or another SQL statement multiple times,
    it is best to create a **stored procedure**, often with parameters, so that it
    can be precompiled and optimized. Stored procedure parameters have a direction
    to indicate if they are inputs, outputs, or return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example that uses all three types of parameter direction. First,
    we will create the stored procedure in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: In your preferred database tool, connect to the `Northwind` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your preferred database tool, add a new stored procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using **SQL Server Management Studio**, then in **Object Explorer**,
    navigate to **Databases** | **Northwind** | **Programmability**, right-click **Stored
    Procedures**, and select **New** | **Stored Procedure**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 2022, then in **Server Explorer**, right-click
    **Stored Procedures** and select **Add New Stored Procedure**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Visual Studio Code, then in **SQL Server**, right-click your
    connection profile and select **New Query**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using JetBrains Rider, then in the **Database** toolbar, click the
    **Jump to Query Console…** button, and then remove any existing statements. As
    well as the following SQL statements, start with a command to set the active database
    to Northwind: `USE Northwind GO`. This should prevent JetBrains Rider from creating
    the stored procedure in the `master` database!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modify the SQL statements to define a stored procedure named `GetExpensiveProducts`
    with two parameters, an input parameter for the minimum unit price and an output
    parameter for the row count of matching products, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The stored procedure uses two `SELECT` statements. The first sets the `@count`
    output parameter to a count of the matching product rows. The second returns the
    matching product rows. It also calls the `PRINT` command, which will raise the
    `InfoMessage` event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click in the SQL statements and select **Execute** or **Execute Query**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click **Stored Procedures** and select **Refresh**. In JetBrains Rider,
    it is named **routines**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expand **GetExpensiveProducts** and note the `@price money` input, `@count
    int` input/output, and return value parameters, as shown in **SQL Server Management
    Studio** in *Figure 2.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Parameters of the GetExpensiveProducts stored procedure'
  prefs: []
  type: TYPE_NORMAL
- en: Close the SQL query without saving changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to allow the user to choose between running
    the text command and the stored procedure. Add statements defining the stored
    procedure and its parameters, and then execute the command, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the statement that closes the data reader, add statements to output the
    output parameter and the return value, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If a stored procedure returns result sets as well as parameters, then the data
    reader for the result sets must be closed before the parameters can be read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app and note the results if the price entered is `60`, and
    note the `InfoMessage` event handler writes a message in dark blue, as shown in
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Outputting streams with a data reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a real app or service, we would likely not output to the console. More likely,
    as we read each row with a data reader, we might output to a stream that writes
    HTML tags inside a web page, or text formats like XML and JSON for returning data
    from a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the ability to generate a JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import the namespace for working efficiently with JSON and
    to statically import the `Environment` and `Path` classes, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, before the `while` statement that processes the data reader,
    add statements to define a file path for a JSON file, create a file stream, and
    start a JSON array, then in the `while` block, write a JSON object that represents
    each product row, and finally, end the array and close the stream, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, enter a price of `60`, and note the path to the JSON file,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `products.json` file and note that the JSON is written with no whitespace,
    so it all appears on one line, as shown in the following file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using Visual Studio 2022, then you can right-click and select **Format
    Document**, and note that it is now easier to read, as shown in *Figure 2.14*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_02_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: The products.json file generated from a data reader'
  prefs: []
  type: TYPE_NORMAL
- en: Generating objects with a data reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For maximum flexibility, we likely want to convert the rows in a data reader
    into object instances stored in an array or collection. After that, we could serialize
    the object graph however we want. ADO.NET does not have a built-in ability to
    map a data reader row to an object, so we will have to do it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class file named `Product.cs`, and modify its contents to define
    a class to represent just the three columns we want from each row in the `Products`
    table, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: In this task, we will use this type only for read-only instances,
    so we could have used an immutable `record`. But later we will need to change
    property values after the object is created, so we have to define a `class` instead.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of `Program.cs`, import the `Northwind.Models` namespace so we can
    use `Product`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, before creating the file stream, instantiate a list of products
    with an initial storage for 77 items (but this is not a limit) because when first
    created the Northwind database has 77 products, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `while` block, add statements to instantiate the `Product` type per
    row in the data reader and add it to the list, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before closing the data reader, add a statement to use the static `Serialize`
    method of the `JsonSerializer` class to write the list of products to the console,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, enter a price of `60`, and note the JSON generated from
    the list of products, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of manually instantiating objects, to simplify even more, we can use
    a simple **object-relational mapper** (**ORM**) like Dapper.
  prefs: []
  type: TYPE_NORMAL
- en: Managing data with Dapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dapper uses ADO.NET underneath when working with SQL Server. Because it is a
    higher-level technology, it is not as efficient as using ADO.NET directly, but
    it can be easier. Dapper is an alternative ORM to EF Core. It is more efficient
    because it extends the low-level ADO.NET `IDbConnection` interface with very basic
    functionality without trying to be all things to all people.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper connection extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dapper adds three extension methods to any class that implements `IDbConnection`
    (like `SqlConnection`). They are `Query<T>`, `Query`, and `Execute`. Dapper will
    automatically open and close the associated connection as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query<T>` extension method is the most used because it runs any specified
    SQL command and then returns the results as an `IEnumerable<T>` (a sequence of
    objects). It is designed to run commands that retrieve data like `SELECT`. It
    has several parameters, as shown in *Table 2.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `string sql` | This is the only mandatory parameter. It is either the text
    of a SQL command or the name of a stored procedure. |'
  prefs: []
  type: TYPE_TB
- en: '| `object param = null` | A complex object for passing parameters used in the
    query. This can be an anonymous type. |'
  prefs: []
  type: TYPE_TB
- en: '| `IDbTransaction transaction = null` | To manage distributed transactions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bool buffered = true` | By default, it will buffer the entire reader on
    return. With large datasets, you can minimize memory and only load objects as
    needed by setting `buffered` to `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int? commandTimeout = null` | To change the default command timeout. |'
  prefs: []
  type: TYPE_TB
- en: '| `CommandType? commandType = null)` | To switch to a stored procedure instead
    of the default of text. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.8: Dapper’s Query<T> extension method parameters'
  prefs: []
  type: TYPE_NORMAL
- en: The `Query` extension method is a loosely-typed equivalent so it is less frequently
    used.
  prefs: []
  type: TYPE_NORMAL
- en: The `Execute` extension method runs any specified SQL command and then returns
    the number of rows affected as an `int`. It is designed to run commands like `INSERT`,
    `UPDATE`, and `DELETE`. It has the same parameters as the `Query<T>` extension
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Querying using Dapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see a simple example that queries the `Suppliers` table instead of the
    `Products` table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Northwind.Console.SqlClient` project, add a package reference for `Dapper`,
    as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the time of writing, the latest version of Dapper is 2.1.21, released on
    November 11, 2023\. You can check if it has been updated since then at the following
    link: [https://www.nuget.org/packages/Dapper](https://www.nuget.org/packages/Dapper).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class file named `Supplier.cs`, and modify its contents to define
    a class to represent four columns from each row in the `Suppliers` table, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add statements to retrieve `Supplier` entities
    in `Germany`, enumerate the collection outputting basic information about each
    one, and then serialize the collection as JSON to the console, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, and in the section where we used Dapper, note the same
    connection was used, so its events were raised while the Dapper query was executed,
    the enumerated collection output, and then JSON generated from the list of suppliers,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add statements to run the `GetExpensiveProducts`
    stored procedure, passing a `price` parameter value of `100`, enumerate the collection
    outputting basic information about each one, and then serialize the collection
    as JSON to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** With Dapper, you must pass a `param` object with all parameters,
    even if they are only used as output parameters. For example, we must define `count`,
    or an exception will be thrown. You must also remember to explicitly set the command
    type to stored procedure!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the console app, and in the section where we used Dapper to run the stored
    procedure to get the products that cost more than 100, note the same connection
    was used so its events were raised while the Dapper query was executed, the enumerated
    collection output, and then JSON generated from the list of products, as shown
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**More Information**: You can learn more about Dapper at the following link:
    [https://github.com/DapperLib/Dapper/blob/main/Readme.md](https://github.com/DapperLib/Dapper/blob/main/Readme.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up data resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are done with a SQL Server database, you can clean up the resources
    used.
  prefs: []
  type: TYPE_NORMAL
- en: The Northwind database is used in most chapters of this book so if you plan
    to immediately continue with more chapters after this one, do not delete Northwind
    yet! If you created the database on your local computer, then you can leave it
    forever.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Azure resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove the resources used by SQL Database to save costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** If you do not remove the resources used by an Azure SQL database,
    then you will incur costs.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Azure portal, find the resource group named `apps-services-book`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of the resource group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which NuGet package should you reference in a .NET project to get the best performance
    when working with data in SQL Server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the safest way to define a database connection string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What must T-SQL parameters and variables be prefixed with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What must you do before reading an output parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type does Dapper add its extension methods to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two most commonly used extension methods provided by Dapper?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 2.2 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-2---managing-relational-data-using-sql-server](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-2---managing-relational-data-using-sql-server)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.3 – Alternatives for storing secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Secrets like passwords and other values used in database connection strings,
    or values like keys to access a service, are often stored in environment variables.
    Other places for storing these values include App Secrets. You can learn more
    about them in the article *Safe storage of app secrets in development in ASP.NET
    Core*, found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets](https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For related guidance about handling connection strings, you can read the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/ef/core/miscellaneous/connection-strings](https://learn.microsoft.com/en-us/ef/core/miscellaneous/connection-strings)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to connect to an existing SQL Server database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to execute a simple query and process the results using fast and low-level
    ADO.NET.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to execute a simple query and process the results using Dapper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use the more powerful and complex
    ORM from Microsoft named EF Core.
  prefs: []
  type: TYPE_NORMAL
