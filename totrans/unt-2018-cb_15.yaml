- en: Editor Extensions and Immediate Mode GUI (IMGUI)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器扩展和即时模式GUI (IMGUI)
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Menu items to log messages and clear the console
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录消息和清除控制台的菜单项
- en: Displaying a panel with text data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示包含文本数据的面板
- en: An interactive panel and persistent storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个交互式面板和持久存储
- en: Creating GameObjects, parenting and registering Undo actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GameObject、设置父级和注册撤销操作
- en: Working with selected objects and deactivating menu items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与选定的对象一起工作并禁用菜单项
- en: Menu item to create 100 randomly positioned prefab clones
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建100个随机位置预制克隆的菜单项
- en: A progress bar to display proportion completed of Editor extension processing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示编辑器扩展处理完成比例的进度条
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，允许在设计时通过自定义检查器UI更改拾取类型（和参数）
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object's location in scene
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，具有一个对象创建GameObject，带有按钮在场景中十字准星对象的位置实例化不同的拾取物品
- en: Extensible class-based code architecture to manage complex IMGUIs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的基于类的代码架构，用于管理复杂的IMGUI
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One aspect of game development in general (and inventories as our particular
    examples in this chapter) is the distinction about when we undertake an activity.
    Runtime is when the game is running (and when all our software and UI choices
    take effect). However, design-time is the time when different members of our game
    design team work on constructing a wide range of game components, including the
    scripts, audio and visual assets, and the process of constructing each game level
    (or scene in Unity-speak).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发的一般方面（以及本章中我们特定的例子——库存）的一个方面是关于我们何时进行活动的区分。运行时是游戏运行时（以及我们所有的软件和UI选择生效时）。然而，设计时是我们游戏设计团队的不同成员在构建各种游戏组件时工作的时间，包括脚本、音频和视觉资产，以及构建每个游戏关卡（或Unity所说的场景）的过程。
- en: Unity's Editor extensions are scripting and multimedia components that enable
    a game software engineer to make design-time work easier and less likely to introduce
    errors. Editor extensions allow workflow improvements, thus allowing designers
    to achieve their goals quicker and more easily; for example, removing the need
    for any scripting knowledge when generating many randomly located inventory pickups
    in a scene via a menu choice or editing the type or properties of pickups being
    hand-placed in different locations in a level.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的编辑器扩展是脚本和多媒体组件，它使游戏软件工程师能够使设计时工作更简单，并减少引入错误的可能性。编辑器扩展允许工作流程改进，从而允许设计师更快、更轻松地实现目标；例如，通过菜单选择或在场景中不同位置手动放置拾取物品时，无需任何脚本知识即可生成许多随机位置的库存拾取。
- en: The Big picture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体概念
- en: Apart from plain text, there are four sections below will give you an idea of
    what this chapter is about.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯文本外，以下四个部分将为您提供一个关于本章内容的概览。
- en: Unity Immediate Mode GUI (IMGUI)
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity即时模式GUI (IMGUI)
- en: In the early versions of Unity, all **UI** components were created through code
    - there was no **Canvas**, or **Rect** Transform, or drag-and-drop **UI** control
    layout and so on. A few years ago (Unity 4.6), Unity introduced what we now know
    as the **UI** system. The new (play-mode) UI system is an example of a **Retained
    Mode UI**; the **UI** items we created are remembered frame-to-frame and don't
    need to be re-created/displayed by us as developers. However, the code-based GUI
    system still has an important role to play for Editor Extensions. The **IMGUI**
    system is called **Immediate Mode**, since its code executes one more times each
    frame. Therefore, there is no need to clear previous GUI displays, since that
    it automatic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的早期版本中，所有**UI**组件都是通过代码创建的——没有**Canvas**、**Rect**变换或拖放**UI**控制布局等。几年前（Unity
    4.6），Unity引入了我们现在所知道的**UI**系统。新的（播放模式）UI系统是**保留模式UI**的一个例子；我们创建的**UI**项目被帧帧记住，并且不需要我们作为开发者重新创建/显示。然而，基于代码的GUI系统在编辑器扩展中仍然扮演着重要的角色。**IMGUI**系统被称为**即时模式**，因为它的代码在每一帧执行一次。因此，没有必要清除之前的GUI显示，因为这是自动的。
- en: Identifying and saving changes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别和保存更改
- en: The concept of serialization is raised in the Editor extension recipes, whereby
    we need to remember that, when we are editing item properties in the Inspector,
    each change needs to be saved to disk, so that the updated property is correct
    when we next use or edit that item. This is achieved in the `OnInspectorGUI()`
    method by first calling the `serializedObject.Update()` method and, after all
    changes have been made in the Inspector, finally calling the `serializedObject.ApplyModifiedProperties()`
    method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器扩展菜谱中提出了序列化的概念，我们需要记住，当我们正在检查器中编辑项目属性时，每次更改都需要保存到磁盘，以便下次使用或编辑该项目时更新的属性是正确的。这是通过在`OnInspectorGUI()`方法中首先调用`serializedObject.Update()`方法，然后在检查器中完成所有更改后，最终调用`serializedObject.ApplyModifiedProperties()`方法来实现的。
- en: 'We can detect when the user has made a change to a GUI control by interrogating
    Unity''s special public bool value: `GUI.changed`. This is set to true if a GUI
    control has changed input data (for example, if the user has been typing or clicking
    GUI controls). Here is a simple example of using `GUI.changed` to log a message
    when the content of a text input field has been updated:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查询Unity的特殊公共布尔值`GUI.changed`来检测用户是否已更改GUI控件。如果GUI控件已更改输入数据（例如，如果用户正在输入或点击GUI控件），则将其设置为true。以下是一个使用`GUI.changed`记录消息的简单示例，当文本输入字段的内文更新时：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unity''s EditorGUI class provides `Begin-End ChangeCheck()` methods that will
    set GUI.changed to true if the user has changed one or more interactive GUI components
    in a block of statements delimited by these methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的EditorGUI类提供了`Begin-End ChangeCheck()`方法，如果用户在由这些方法分隔的语句块中更改了一个或多个交互式GUI组件，则将GUI.changed设置为true：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If they have, we can save a statement, since `EditorGUI.EndChangeCheck()`,
    as well as declaring the end of the block of statements for GUI.change. This also
    returns the bool value of GUI.changed. So, we can actually use this method call
    in our if-statement instead of GUI.changed. In essence:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们已经更改了，我们可以保存一个语句，因为`EditorGUI.EndChangeCheck()`，以及声明GUI.change的语句块的结束。这也返回GUI.changed的布尔值。因此，我们实际上可以在我们的if语句中使用这个方法调用而不是GUI.changed。本质上：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Memory - EditorPrefs persistent storage
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存 - EditorPrefs持久存储
- en: 'An issue with Immediate Mode systems is that everything is temporary and forgotten.
    Unity provides **EditorPrefs,** similar to **PlayerPrefs,** a facility for storing
    data that is remembered between the closing of a panel and its reopening. Just
    as with **PlayerPrefs,** different **types** of values can be stored and retrieved
    using `Get<>()` and `Set<>()` methods, including:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 立即模式系统的一个问题是一切都是临时的并且会被遗忘。Unity提供了**EditorPrefs**，类似于**PlayerPrefs**，这是一个用于存储在面板关闭和重新打开之间会被记住的数据的功能。正如与**PlayerPrefs**一样，可以使用`Get<>()`和`Set<>()`方法存储和检索不同**类型**的值，包括：
- en: '`SetString(<key>, <value>)`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetString(<key>, <value>)`'
- en: '`GetString(<key>)`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetString(<key>)`'
- en: And so on
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等
- en: Also provided are methods to delete all stored EditorPrefs data (`DeleteAll()`),
    to delete just one item for a given key (`DeleteKey(<key>)`), and to check if
    an item exists for a given key (`HasKey(<key>)`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了删除所有存储的EditorPrefs数据的方法（`DeleteAll()`），删除给定键的一个项目（`DeleteKey(<key>)`），以及检查给定键是否存在的方法（`HasKey(<key>)`）。
- en: Of course, `DeleteAll()` isn't something to be used without careful consideration.
    There is an example of `DeleteAll()` in the Unity documentation that ensures the
    game developer is first asked if they are sure they really want to delete all
    stored values: [https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html](https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`DeleteAll()`不是应该不加考虑就使用的东西。Unity文档中有一个`DeleteAll()`的示例，确保游戏开发者首先被询问是否真的想要删除所有存储的值：[https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html](https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html)
- en: 'Typically, values are **loaded** from **EditorPrefs** using getters (if the
    `<key>`s exist) each time the panel gets the focus. For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，值是在每次面板获得焦点时从**EditorPrefs**中**加载**的（如果存在`<key>`），例如：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Likewise, when panels lose focus (`OnLostFocus()`) or are closed (`OnDestroy()`)
    we may wish to automatically save any values to EditorPrefs using setters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当面板失去焦点（`OnLostFocus()`）或关闭（`OnDestroy()`）时，我们可能希望自动使用设置器将任何值保存到EditorPrefs中。
- en: Conclusions and further resources
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论和进一步资源
- en: While Editor extensions are quite an advanced topic, having someone on your
    team who can write custom editor components, such as those we illustrate, can
    greatly increase the productivity of a small team with only one or two members
    who are confident at scripting.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编辑器扩展是一个相当高级的话题，但如果你团队中有能够编写自定义编辑器组件的人，例如我们展示的那些，这将大大提高只有一两个成员且对脚本编写有信心的小型团队的效率。
- en: In this chapter, we introduce recipes demonstrating some Unity Editor extension
    scripts, illustrating how we can make things easier, less-script based, and less
    prone to errors, by limiting and controlling the properties of objects and how
    they are selected or changed via the Inspector.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了展示一些Unity编辑器扩展脚本的食谱，说明了我们如何通过限制和控制对象的属性以及它们如何通过检查器进行选择或更改，使事情变得更简单，减少脚本依赖，并降低出错的可能性。
- en: 'There is a lot to working with Editor Extensions and the IMGUI. Here is a list
    of resources to learn more about these topics:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与编辑器扩展和IMGUI一起工作有很多内容。以下是一些资源，可以帮助您了解更多关于这些主题的信息：
- en: Learn more about EditorPrefs in the Unity Documentation: [https://docs.unity3d.com/ScriptReference/EditorPrefs.html](https://docs.unity3d.com/ScriptReference/EditorPrefs.html)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity文档中了解更多关于EditorPrefs的信息：[https://docs.unity3d.com/ScriptReference/EditorPrefs.html](https://docs.unity3d.com/ScriptReference/EditorPrefs.html)
- en: 'Unity blog post about IMGUI: [https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/](https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity关于IMGUI的博客文章：[https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/](https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/)
- en: 'Video about IMGUI by Casey Muratori: [https://caseymuratori.com/blog_0001](https://caseymuratori.com/blog_0001)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Casey Muratori制作的IMGUI视频：[https://caseymuratori.com/blog_0001](https://caseymuratori.com/blog_0001)
- en: 'the Unity Immediate Mode GUI reference pages: [https://docs.unity3d.com/Manual/GUIScriptingGuide.html](https://docs.unity3d.com/Manual/GUIScriptingGuide.html)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity即时模式GUI参考页面：[https://docs.unity3d.com/Manual/GUIScriptingGuide.html](https://docs.unity3d.com/Manual/GUIScriptingGuide.html)
- en: The Unity GUI event scripting reference page: [https://docs.unity3d.com/ScriptReference/Event.html](https://docs.unity3d.com/ScriptReference/Event.html)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity GUI事件脚本参考页面：[https://docs.unity3d.com/ScriptReference/Event.html](https://docs.unity3d.com/ScriptReference/Event.html)
- en: 'Unity scripting OnGUI reference page: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity脚本OnGUI参考页面：[https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html)
- en: Ryan Meier's blog: [http://www.ryan-meier.com/blog/?p=72](http://www.ryan-meier.com/blog/?p=72)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ryan Meier的博客：[http://www.ryan-meier.com/blog/?p=72](http://www.ryan-meier.com/blog/?p=72)
- en: Tutsplus tutorials and custom scripts (including grids and color pickers): [http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047](http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tutsplus教程和自定义脚本（包括网格和颜色选择器）：[http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047](http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047)
- en: Gamasutra getting starting Editor Extensions article: [https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php](https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gamasutra关于Unity编辑器扩展入门文章：[https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php](https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php)
- en: Menu items: [https://docs.unity3d.com/ScriptReference/MenuItem.html](https://docs.unity3d.com/ScriptReference/MenuItem.html)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单项：[https://docs.unity3d.com/ScriptReference/MenuItem.html](https://docs.unity3d.com/ScriptReference/MenuItem.html)
- en: EditorGUI.BeingChangeCheck: [https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html](https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EditorGUI.BeginChangeCheck：[https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html](https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html)
- en: Menu items to log messages and clear the console
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于记录消息和清除控制台的菜单项
- en: 'Custom menus are a great way to offer game developers easy access to your Editor
    Extension features. Logging actions is a good way to display and keep a record
    of actions performance and object properties that have been changed. In this recipe,
    we''ll create a new menu for the Unity Editor application and a menu item that
    when selected logs a simple message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义菜单是向游戏开发者提供轻松访问你的编辑器扩展功能的好方法。记录操作是显示和记录操作性能以及已更改的对象属性的好方法。在本菜谱中，我们将为 Unity
    编辑器应用程序创建一个新菜单和一个菜单项，当选择该菜单项时，会记录一条简单消息：
- en: '![](img/83266c1e-2c0e-4c62-96d0-8d0956aba787.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83266c1e-2c0e-4c62-96d0-8d0956aba787.png)'
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a menu with a menu item to log messages to console, follow these
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个带有记录到控制台菜单项的菜单，请按照以下步骤操作：
- en: In the Project panel, create a new folder, Editor.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为 Editor 的新文件夹。
- en: 'In your new Editor folder, create a new C# script-class named `ConsoleUtilities.cs`,
    containing the following:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新编辑器文件夹中，创建一个名为 `ConsoleUtilities.cs` 的新 C# 脚本类，其中包含以下内容：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After a few seconds, you should now see a menu named My Utilities appear with
    two items Clear Console and Log a message.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，你现在应该看到一个名为我的工具的菜单出现，其中包含两个项目：清除控制台和记录消息。
- en: You should now be able to clear the console and generate Log messages with these
    menu items.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该能够使用这些菜单项清除控制台并生成日志消息。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: You created an editor extension script-class in a folder Editor that extends
    the `EditorWindow` class. You defined two methods; each method was immediately
    preceded by an attribute to add a menu item to a menu named My Utilities.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 Editor 文件夹中创建了一个扩展 `EditorWindow` 类的编辑器扩展脚本类。你定义了两个方法；每个方法紧接一个属性，用于将菜单项添加到名为我的工具的菜单中。
- en: 'The `ClearLogConsole()` method was immediately preceded by an attribute declaring
    a new menu, My Utilities, and its single menu item `Clear Console`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearLogConsole()` 方法紧接一个属性声明的新菜单，我的工具，以及其单个菜单项 `Clear Console`：'
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The MenuItem **attribute** immediately precedes a **static** method, that implements
    the actions to be executed if the menu item is selected by the user. The menu
    path is in the form:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuItem` 属性紧接在实现用户选择菜单项时要执行的动作的 **静态** 方法之前。菜单路径的形式为：'
- en: MenuName/MenuItemName or
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MenuName/MenuItemName 或
- en: MenuName/SubMenuName/MenuItemName and so on for submenus
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MenuName/SubMenuName/MenuItemName 以及子菜单的后续内容
- en: The `LogHello()` method creates a new Log message each time it is invoked.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogHello()` 方法在每次被调用时创建一个新的日志消息。'
- en: The `ClearLogConsole()` method gets a reference to the Unity logs and clears
    them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearLogConsole()` 方法获取 Unity 日志的引用并清除它们。'
- en: 'You can learn more about Editor Extensions for menus in the Unity tutorial
    on this topic: [https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items](https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Unity 关于此主题的教程中了解更多关于菜单的编辑器扩展的信息：[https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items](https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items)
- en: It should be noted that using Reflection is very slow and so generally only
    used for Editor scripts or scripts that are only executed once and a short delay
    will not impact upon the user's or game developer's quality of experience.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，使用反射非常慢，因此通常仅用于编辑器脚本或只执行一次且短暂延迟不会影响用户或游戏开发者的体验。
- en: There's more
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: There are some details that you don't want to miss.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Keyboard shortcuts
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘快捷键
- en: 'Special characters in the Menu Item string can be used to specify a keyboard
    shortcut for the menu item:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项字符串中的特殊字符可以用来指定菜单项的键盘快捷键：
- en: '% indicates the CTRL-key (Windows) or CMD-key (Mac)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '% 表示 CTRL 键（Windows）或 CMD 键（Mac）'
- en: indicate the SHIFT-key
  id: totrans-78
  prefs:
  - PREF_UL
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示 SHIFT 键
- en: <c> then the (lowercase) letter or character shortcut key (e.g. 'k' for the
    K-key)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <c> 然后是（小写）字母或字符快捷键（例如，'k' 用于 K 键）
- en: 'When keyboard shortcut has been defined, Unity also indicates this to the right
    of the menu item:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义了键盘快捷键后，Unity 也会在菜单项的右侧指示这一点：
- en: '![](img/15001952-a500-46a8-8342-4e63f2308462.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15001952-a500-46a8-8342-4e63f2308462.png)'
- en: 'So, let''s add shortcuts so that *CTRL*/*CMD*-*L* logs a message and *CTRL*/*CMD*-*K*
    clears the log (keys *L* and *K* are next to each other on the keyboard):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们添加快捷键，以便 *CTRL*/*CMD*-*L* 记录消息，*CTRL*/*CMD*-*K* 清除日志（键 *L* 和 *K* 在键盘上相邻）：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Learn more about Unity Menu Item Keyboard Shortcuts at `https://docs.unity3d.com/ScriptReference/MenuItem.html`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `https://docs.unity3d.com/ScriptReference/MenuItem.html` 了解更多关于 Unity 菜单项键盘快捷键的信息。
- en: Sub-menus
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子菜单
- en: 'You can create sub-menus by adding a third text item between forward slashes,
    in the following form:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在正斜杠之间添加第三个文本项来创建子菜单，形式如下：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, to have a menu Utilities with a sub-menu Console and two items for that
    submenu, you could write the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了有一个名为“实用工具”的菜单，一个名为“控制台”的子菜单以及该子菜单的两个项目，你可以编写以下内容：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Displaying a panel with text data
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示包含文本数据的面板
- en: 'Sometimes, we want to create and display a new panel as part of an Editor Extension.
    In this recipe, we create a menu item that creates and displays a new panel, displaying
    some text information:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在编辑器扩展中创建并显示一个新的面板。在这个菜谱中，我们创建了一个菜单项，用于创建并显示一个新的面板，显示一些文本信息：
- en: '![](img/c0f137bd-4fe3-40cb-bb0d-6bf2240af0b2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0f137bd-4fe3-40cb-bb0d-6bf2240af0b2.png)'
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To display a panel with text data, follow these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示包含文本数据的面板，请按照以下步骤操作：
- en: In the Project panel, create a new folder, Editor.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的文件夹，名为“编辑器”。
- en: 'In your new Editor folder, create a new C# script-class named `InformationPanel.cs`,
    containing the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新编辑器文件夹中，创建一个新的C#脚本类名为`InformationPanel.cs`，包含以下内容：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After a few seconds, you should now see a menu named My Game appear, with menu
    item Info Panel.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，你现在应该看到一个名为“我的游戏”的菜单出现，包含菜单项“信息面板”。
- en: Select menu item Info Panel - you should now see a new panel appear, entitled
    My Game and containing the two text messages.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单项“信息面板”- 你现在应该看到一个新面板出现，标题为“我的游戏”，包含两个文本消息。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You preceded the `ShowWindow()` method with an attribute to add a menu item
    Info Panel to a menu named My Game. The `GetWindow()` statement gets a reference
    to an InformationPanel object - if no such window-panel exists, it creates one.
    It searches for a window-panel of type (that is, for this script-class). The first
    argument is the title of the panel My Game. The true for the second argument tells
    Unity to make the window-panel have the focus (if a window panel already existed).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`ShowWindow()`方法之前添加了一个属性，将名为“信息面板”的菜单项添加到名为“我的游戏”的菜单中。`GetWindow()`语句获取一个InformationPanel对象的引用
    - 如果不存在这样的窗口面板，它将创建一个。它搜索类型为（即，对于这个脚本类）的窗口面板。第一个参数是面板标题“我的游戏”。第二个参数的true告诉Unity使窗口面板获得焦点（如果已经存在窗口面板）。
- en: If a new window panel has been created it will always be given the focus.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已创建新的窗口面板，它将始终获得焦点。
- en: The `OnGUI()` method, which executes a least once every frame, uses `GUILayout`
    to display two text labels. Since `GUILayout` begins adding items at the top-left,
    the first message Hello editor world appears in the top-left of the panel. Then
    there is a `FlexibleSpace()` statement. This tells the GUI layout manager to fill
    up as much (default - vertical) space as it can, while allowing space in the panel
    for any other content. The third statement displays a second text label. The result
    is that the second text label is pushed to the bottom of the panel by the `FlexibleSpace()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnGUI()`方法，它至少每帧执行一次，使用`GUILayout`显示两个文本标签。由于`GUILayout`从左上角开始添加项目，所以第一条消息“Hello
    editor world”出现在面板的左上角。然后是一个`FlexibleSpace()`语句。这告诉GUI布局管理器尽可能填充（默认为垂直）空间，同时为面板中的任何其他内容留出空间。第三个语句显示第二个文本标签。结果是第二个文本标签被`FlexibleSpace()`推到面板的底部。'
- en: Try resizing the panel; you'll see the second text label is always at the bottom.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整面板大小；你会看到第二个文本标签始终在底部。
- en: There's more
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: Here are some details that you won't want to miss throughout.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不想错过的细节。
- en: Vertical centering
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直居中
- en: 'If we wanted to vertically center some text, we can have a `FlexibleSpace()`
    statement both before and after the content. For example, the following code would
    vertically center text `Here is some important information`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要垂直居中文本，我们可以在内容前后都添加一个`FlexibleSpace()`语句。例如，以下代码将垂直居中文本“Here is some important
    information”：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Vertical and horizontal centering (middle of an area)
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直和水平居中（区域中间）
- en: 'To center horizontally, we need to change from the default vertical layout
    by starting (and ending) a horizontal layout, in the following form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要水平居中，我们需要通过开始（并结束）水平布局来改变默认的垂直布局，形式如下：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By the having `FlexibleSpace()` before and after the content in the horizontal
    layout, we can center content horizontally as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在水平布局中的内容前后添加`FlexibleSpace()`，我们可以水平居中内容。
- en: 'To center both vertically and horizontally, we use `FlexibleSpace()` before
    and after the horizontal layout, and also before and after the content inside
    the horizontal layout. For example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了水平和垂直居中，我们在水平布局之前和之后以及水平布局内部的内容之前和之后使用 `FlexibleSpace()`。例如：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This use of flexible spacing is illustrated in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活间距的使用在以下屏幕截图中有说明：
- en: '![](img/9a5319f2-cdbc-45f0-b8dd-af703305c03f.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a5319f2-cdbc-45f0-b8dd-af703305c03f.png)'
- en: An interactive panel with persistent storage
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有持久存储的交互式面板
- en: With Immediate Mode, we have to store the values of interactive controls like
    buttons and text inputs at the time we display them. Also, we need to decide if,
    and when, to persistently store values to be remembered when the panel is out
    of focus or closed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在即时模式中，我们必须在显示它们的时候存储交互式控件（如按钮和文本输入）的值。同时，我们需要决定何时以及如何持久化存储要记住的值，当面板失去焦点或关闭时。
- en: 'In this recipe, we display a text label saying hello to the player and using
    their name if it has been found in the EditorPrefs storage. We also offer a text
    input and a button and, when the button is clicked, we update the name being greeted:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们显示一个文本标签，向玩家问候，并使用在编辑器Prefs存储中找到的名称。我们还提供了一个文本输入框和一个按钮，当按钮被点击时，我们更新被问候的名称：
- en: '![](img/510a539f-d625-4cec-a4f9-c8aa242d7a97.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/510a539f-d625-4cec-a4f9-c8aa242d7a97.png)'
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To offer an interactive panel with persistent storage, follow these steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供一个具有持久存储的交互式面板，请按照以下步骤操作：
- en: In the Project panel, create a new Editor folder.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的编辑器文件夹。
- en: 'In your new Editor folder, create a new C# script-class named `Welcome.cs`
    containing the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的新编辑器文件夹中，创建一个名为 `Welcome.cs` 的新 C# 脚本类，包含以下内容：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After a few seconds, you should now see a menu named Welcome appear with menu
    item Hello Player.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，您现在应该看到一个名为“欢迎”的菜单出现，其中包含菜单项“Hello Player”。
- en: Select the menu item Hello Player. You should now see a new panel appear, entitled
    Welcome, displaying a hello message, a text input box, and a button labeled Update.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单项“Hello Player”。现在您应该看到一个新面板出现，标题为“欢迎”，显示问候信息、文本输入框和一个标签为“Update”的按钮。
- en: Enter your name in the text box and, when you press the button, you should see
    a message greeting you by name.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本框中输入您的名字，然后按按钮，您应该看到一个按您的名字问候您的消息。
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You preceded the `ShowWindow()`  method with an attribute to add a menu item,
    Hello Player, to a menu named Welcome. The `GetWindow()` statement gets a reference
    to an `EditorWindow` object of type (that is, for this script-class), creating
    a new one if no existing window-panel of this type can be found.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 `ShowWindow()` 方法之前使用了一个属性来添加一个名为“Hello Player”的菜单项到名为“欢迎”的菜单中。`GetWindow()`
    语句获取一个类型为 `EditorWindow` 的 `EditorWindow` 对象的引用（即，对于这个脚本类），如果找不到现有窗口面板，则创建一个新的。
- en: 'The `OnGUI()` method, which executes every frame, uses GUILayout to display
    the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnGUI()` 方法，它每帧执行一次，使用 GUILayout 显示以下内容：'
- en: A text label in the form Hello
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式的文本标签“Hello”
- en: A text input with the prompt Player name
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有提示“玩家名称”的文本输入
- en: An Update button
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更新按钮
- en: There is some `FlexibleSpace()` between the first item (greeting label) and
    the input box and button, so the input box and button appear at the bottom of
    the panel.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个项目（问候标签）和输入框以及按钮之间有一些 `FlexibleSpace()`，因此输入框和按钮出现在面板的底部。
- en: 'There are two private string variables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个私有字符串变量：
- en: '`playerName`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerName`'
- en: '`tempName`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tempName`'
- en: The `playerName` variable is used to decide what greeting to display. If the
    length of this string is greater than zero (in essence, it's not an empty string),
    then the hello message will be Hello. If `playerName` was empty, then the message
    will be Hello (no name).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerName` 变量用于决定显示什么问候语。如果这个字符串的长度大于零（本质上，它不是一个空字符串），那么问候信息将是“Hello”。如果
    `playerName` 为空，则信息将是“Hello (no name)”。'
- en: The second variable, `tempName`, is set to the value in the text box. This has
    to be re-assigned every frame (in `OnGUI()`), since the text box is redisplayed
    every frame. Each time the user types different text in the text box, the new
    text is immediately stored in the `tempName` variable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变量 `tempName` 被设置为文本框中的值。这必须在每一帧（在 `OnGUI()` 中）重新分配，因为文本框每帧都会重新显示。每次用户在文本框中输入不同的文本时，新的文本会立即存储在
    `tempName` 变量中。
- en: Finally, there is an `if` statement that displays the Update button. If, during
    a frame, the button is clicked by the user, then the `if-`statement will be executed,
    which copies the `tempName` from the text box into the `playerName` variable.
    The very next frame, we'll see the greeting change to reflect the new value inside
    `playerName`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个`if`语句会显示更新按钮。如果在某个帧中用户点击了该按钮，那么`if-`语句将被执行，它将从文本框中复制`tempName`到`playerName`变量中。在下一个帧，我们会看到问候语改变以反映`playerName`中的新值。
- en: We have used `EditorGUILayout.TextField(...)` for the text field entry, whereas
    the other methods are GUILayout methods. `The EditorGUILayout` methods make interactive
    controls easier, while the GUILayout methods make layout easier. For window-panels
    like this you can mix-and-match these GUI methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`EditorGUILayout.TextField(...)`进行文本字段输入，而其他方法是GUILayout方法。`EditorGUILayout`方法使交互式控件更容易，而GUILayout方法使布局更容易。对于这样的窗口-面板，你可以混合使用这些GUI方法。
- en: There's more
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: There are some details that you don't want to miss.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不应该错过。
- en: Persistent storage with EditorPrefs
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EditorPrefs的持久化存储
- en: At present, if the panel is closed (for example, due to a new panel layout being
    invoked), then any name that was being shown will be lost. However, we can add
    some code that uses the EditorPrefs system to store the new name each time the
    Update button is clicked. Additional code can then check for an EditorPrefs value
    when the panel is newly displayed and initialize `playerName` to the stored value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果面板被关闭（例如，由于调用了新的面板布局），那么任何正在显示的名称都将丢失。然而，我们可以添加一些代码，使用EditorPrefs系统在每次点击更新按钮时存储新名称。然后，额外的代码可以在面板新显示时检查EditorPrefs值，并将`playerName`初始化为存储的值。
- en: 'First, when the panel is created/gets the focus, let''s attempt to read an
    EditorPrefs item with the key `"PlayerName"`. If found, we''ll retrieve that string
    and assign the `playerName` variable to the stored value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当面板被创建/获得焦点时，让我们尝试使用键`"PlayerName"`读取一个EditorPrefs项。如果找到，我们将检索该字符串并将`playerName`变量分配给存储的值：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s create a method that will save the value in `playerName` into EditorPrefs,
    again using the key `"PlayerName"`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个方法，将`playerName`中的值保存到EditorPrefs中，再次使用键`"PlayerName"`：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are two times we may wish to ensure the value is saved, when the panel
    loses focus and when it is closed (destroyed). So, for both these events, we''ll
    write methods that will invoke our `SavePrefs()` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种情况我们可能希望确保值被保存，当面板失去焦点和当它被关闭（销毁）时。因此，对于这两个事件，我们将编写调用我们的`SavePrefs()`方法的方法：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: GUILayout versus EditorGUILayout
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUILayout与EditorGUILayout的比较
- en: 'You may have noticed there were two different `GUILayout` different method
    calls in this recipe:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在这个配方中有两个不同的`GUILayout`方法调用：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`GUILayout` and `EditorGUILayout` both perform very similar roles, in that
    they provide UI controls with some automated layout - that is, we don''t have
    to specify exact (x,y) values or rectangles for the window-panel size and position
    of each item. `GUILayout` offers some of the more flexible layout options, like
    `FlexibleSpace` and horizontal and vertical groups, which with `FlexibleSpace`
    can vertically and horizontally align items. However, `EditorGUILayout` offers
    easier and more powerful numeric and text input fields, as well as color selection
    widgets, foldout groups, and so on.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`GUILayout`和`EditorGUILayout`在提供带有一些自动化布局的UI控件方面执行非常相似的角色——也就是说，我们不需要指定每个窗口-面板大小和位置的精确(x,y)值或矩形。`GUILayout`提供了一些更灵活的布局选项，如`FlexibleSpace`和水平和垂直组，其中`FlexibleSpace`可以垂直和水平对齐项目。然而，`EditorGUILayout`提供了更简单、更强大的数字和文本输入字段，以及颜色选择小部件、折叠组等等。'
- en: 'DM Gregory, in a StackExchange post in 2017, lists many of the extra methods
    available when using `EditorGUILayout`: [https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout](https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: DM Gregory在2017年StackExchange帖子中列出了使用`EditorGUILayout`时可用的一些额外方法：[https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout](https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout)
- en: Creating GameObjects, parenting, and registering Undo actions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GameObject、设置父级和注册撤销操作
- en: 'Whether from a menu item, or an Inspector view, there are times when we want
    to create a new GameObject in the scene from an Editor Extension. In this recipe,
    we''ll create a new GameObject and set its position and color randomly:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是从菜单项还是从检查器视图中，有时我们希望从编辑器扩展中在场景中创建一个新的GameObject。在这个菜谱中，我们将创建一个新的GameObject并随机设置其位置和颜色：
- en: '![](img/8c5ba467-2b3e-4745-bb68-6d273af200dd.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c5ba467-2b3e-4745-bb68-6d273af200dd.png)'
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create an object and change its value follow these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个对象并更改其值，请按照以下步骤操作：
- en: In the Project panel, create a new folder, Editor.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个名为Editor的新文件夹。
- en: 'In your new Editor folder create a new C# script-class named `ObjectManager.cs`,
    containing the following:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新Editor文件夹中创建一个名为`ObjectManager.cs`的新C#脚本类，包含以下内容：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After a few seconds, you'll see added to the GameObject menu a new sub-menu
    named MyObjectManager appear, with menu item Create New Empty Game Object.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，你会在GameObject菜单中看到一个名为MyObjectManager的新子菜单出现，其中包含菜单项创建新空GameObject。
- en: 'Choose menu: GameObject | MyObjectManager | Create New Empty Game Object.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单：GameObject | MyObjectManager | 创建新空GameObject。
- en: You should now see a new GameObject named GameObject - custom - Empty created
    in the Hierarchy panel. If you select this object, it's position (x,y,z) values
    should be random, in the range -0.5 ... 0.5.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该在Hierarchy面板中看到一个名为GameObject - custom - Empty的新GameObject被创建。如果你选择此对象，它的位置（x,y,z）值应该是随机的，在-0.5
    ... 0.5的范围内。
- en: You can Undo this create GameObject from the Edit menu (or *CTRL/CMD-Z*).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从编辑菜单（或*CTRL/CMD-Z*）撤销创建GameObject的操作。
- en: '![](img/eb80dd6d-d551-41d9-ad44-547ba7ba622e.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb80dd6d-d551-41d9-ad44-547ba7ba622e.png)'
- en: 'With the new empty GameObject selected in the Hierarchy, right-mouse click
    to get the context menu for this object. Now, choose menu: Create | MyObjectManager
    | Create New Empty Game Object.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Hierarchy中选择新的空GameObject，右键单击以获取此对象的上下文菜单。现在，选择菜单：创建 | MyObjectManager | 创建新空GameObject。
- en: You should now see a second empty GameObject created as a child of the first
    one;
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该看到一个作为第一个空GameObject子对象的第二个空GameObject被创建；
- en: '![](img/db175896-d0cd-4921-9cc7-11ad781235e8.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db175896-d0cd-4921-9cc7-11ad781235e8.png)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You preceded the `CreateCustomEmptyGameObject(...)` method with an attribute
    to add to existing menu GameObject a sub-menu MyObjectManager with menu item Create
    New Empty Game Object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`CreateCustomEmptyGameObject(...)`方法之前添加了一个属性，以向现有的GameObject菜单添加一个名为MyObjectManager的子菜单，其中包含创建新空GameObject的菜单项。
- en: The `CreateCustomEmptyGameObject(...)` method creates a new, empty GameObject
    with the name GameObject - custom - Empty. It then sets the position property
    to a Vector3 random location, returned from method `RandomPosition(...)`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateCustomEmptyGameObject(...)`方法创建一个名为GameObject - custom - Empty的新空GameObject。然后，它将位置属性设置为从方法`RandomPosition(...)`返回的Vector3随机位置。 '
- en: The `CreateCustomEmptyGameObject(...)` method then uses the `GameObjectUtility.SetParentAndAlign(...)`
    method to parent the new GameObject to the object selected in the Hierarchy, if
    the menu was invoked in the contents of a selected GameObject. Otherwise, the
    new GameObject will have no parent in the Hierarchy.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateCustomEmptyGameObject(...)`方法随后使用`GameObjectUtility.SetParentAndAlign(...)`方法将新GameObject作为子对象添加到Hierarchy中选定的对象，如果菜单是在选定的GameObject的内容中调用的。否则，新GameObject在Hierarchy中将没有父对象。'
- en: The `RandomPosition(...)` method takes as input a float parameter <limit>, and
    generates three values (x,y,z) in the random range from negative to positive <limit>.
    It then creates and returns a new Vector3 object with these three values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomPosition(...)`方法接受一个float参数<limit>作为输入，并生成三个值（x,y,z）在从负到正的随机范围<limit>内。然后，它创建并返回一个包含这三个值的新Vector3对象。'
- en: 'Because we chose to add our action to the special GameObject menu, our sub-menu
    item appears in the Hierarchy panel''s content Create menu as: Create | MyObjectManager
    | Create New Empty Game Object.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们选择将我们的操作添加到特殊的GameObject菜单中，所以我们的子菜单项出现在Hierarchy面板的内容创建菜单中，如下所示：创建 | MyObjectManager
    | 创建新空GameObject。
- en: There's more
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: There are some details that you don't want to miss.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节你不希望错过。
- en: Registering object changes to allow Undo'ing of actions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册对象更改以允许撤销操作
- en: When we performance an object creation/deletion/change action in the Unity Editor,
    we should offer the user the change to Undo the action. Unity makes it very easy
    for us to facilitate this, through registration of the changed object by providing
    an Undo class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Unity编辑器中执行对象创建/删除/更改操作时，我们应该给用户提供撤销操作的机会。Unity通过注册已更改的对象并提供一个Undo类，使我们能够非常容易地实现这一点。
- en: 'We can add to `CreateCustomEmptyGameObject(...)` a call to the `Undo.RegisterCreatedObjectUndo(...)`
    method. This registers the GameObject creation in the Unity system Undo register
    so that the action can be undone if the uses wishes to do so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向`CreateCustomEmptyGameObject(...)`方法添加对`Undo.RegisterCreatedObjectUndo(...)`方法的调用。这将注册GameObject的创建到Unity系统的撤销注册中，以便如果用户希望这样做，可以撤销操作：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Learn more about the Undo features in the Unity documentation pages: [https://docs.unity3d.com/ScriptReference/Undo.html](https://docs.unity3d.com/ScriptReference/Undo.html)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity文档页面中了解更多关于撤销功能的信息：[https://docs.unity3d.com/ScriptReference/Undo.html](https://docs.unity3d.com/ScriptReference/Undo.html)
- en: Creating primitive 3D GameObjects with random colors
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用随机颜色创建原始3D GameObject
- en: 'Rather than creating empty GameObjects, we can create new GameObjects that
    are 3D primitives like cubes and spheres etc. We can do this using the `GameObject.CreatePrimitive(...)`
    method. By adding the following three methods, we''ll be able to create randomly
    positioned, randomly colored, random 3D GameObjects from a second menu item in
    our MyObjectManager sub-menu:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建空GameObject相比，我们可以创建新的GameObject，这些GameObject是3D原语，如立方体和球体等。我们可以使用`GameObject.CreatePrimitive(...)`方法来完成此操作。通过添加以下三个方法，我们将能够从我们的MyObjectManager子菜单的第二个菜单项中创建随机位置、随机颜色和随机的3D
    GameObject：
- en: '![](img/23903447-0d03-4556-a156-be5484f6ee2e.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23903447-0d03-4556-a156-be5484f6ee2e.png)'
- en: 'Let''s write a method to add a second menu item, which offers to create random
    GameObjects with 3D primitives:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个方法来添加第二个菜单项，该菜单项提供创建具有3D原语的随机GameObject的功能：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can choose a random integer from 0..3 to choose between Cube/Sphere/Capsule/Cylinder
    3D primitives for our new GameObject:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从0..3中选择一个随机整数，以在Cube/Sphere/Capsule/Cylinder 3D原语之间选择我们的新GameObject：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is the final method we need to create a new Material with a random color,
    that can be assigned to the new primitives sharedMaterial property:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要创建具有随机颜色的新材质的最终方法，该材质可以分配给新原语共享Material属性：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Working with selected objects and deactivating menu items
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与选定的对象一起工作并禁用菜单项
- en: 'Sometimes, we only want to execute some statements if an object is currently
    selected, related to those actions. In this recipe, we learn how to disable a
    menu item if nothing is selected. If a GameObject is selected, we''ll get a reference
    to that object and move it back to the origin (0,0,0):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只想在对象当前被选中时执行一些语句，这与那些动作相关。在这个菜谱中，我们学习如何在没有选择任何内容时禁用菜单项。如果选择了GameObject，我们将获取对该对象的引用并将其移回原点（0,0,0）：
- en: '![](img/2d2fce19-bada-4533-9dac-a2384ef117f4.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d2fce19-bada-4533-9dac-a2384ef117f4.png)'
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To work with selected objects and deactivate menu items follow these steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要与选定的对象一起工作并禁用菜单项，请按照以下步骤操作：
- en: In the Project panel, create a new folder, Editor.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的文件夹，Editor。
- en: 'In your new Editor folder create a new C# script-class named `SelectedObjectManager.cs`,
    containing the following:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新Editor文件夹中创建一个名为`SelectedObjectManager.cs`的新C#脚本类，包含以下内容：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After a few seconds, you'll see a new menu MyMenu created, with menu item Move
    To Origin.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，你会看到一个新创建的菜单MyMenu，其中包含菜单项“移动到原点”。
- en: If no GameObject is selected in the Hierarchy, then the Move To Origin menu
    item should be greyed out (inactive).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在层级中没有选择任何GameObject，那么“移动到原点”菜单项应该变灰（不活跃）。
- en: Create a new, empty GameObject and set its transform position to (5,6,7).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空GameObject，并将其变换位置设置为(5,6,7)。
- en: 'With this new GameObject selected in the Hierarchy, choose menu: MyMenu | Move
    To Origin. The menu item should be active, and once chosen the position of the
    GameObject should be zeroed to (0,0,0).'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择这个新的GameObject后，选择菜单：MyMenu | 移动到原点。菜单项应该是活跃的，一旦选择，GameObject的位置应该被设置为(0,0,0)。
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You preceded the `ZeroPosition()` method with a MenuItem attribute to create
    a new menu MyMenu with menu item Move To Origin. This method gets a reference
    to the currently selected GameObject using the `Selection.activeTransform.gameObject`
    property. The object is registered to the Undo systems property change record,
    and then its transform position is set to (0,0,0).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`ZeroPosition()`方法前添加了MenuItem属性来创建一个新的菜单MyMenu，其中包含菜单项“移动到原点”。此方法使用`Selection.activeTransform.gameObject`属性获取当前选中的GameObject的引用。对象被注册到撤销系统的属性更改记录中，然后将其变换位置设置为(0,0,0)。
- en: 'There is a second method, `ValidateZeroPosition()`. This method is preceded
    by a MenuItem attribute with the same **menu path** as method `ZeroPosition()`.
    The MenuItem attribute is passed true to indicate this is a validation method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有第二种方法，`ValidateZeroPosition()`。此方法前面有一个与 `ZeroPosition()` 方法相同的 **菜单路径** 的
    MenuItem 属性。MenuItem 属性传递 true 以指示这是一个验证方法：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Validation methods must be static methods, marked with the same MenuItem attribute
    as the item they are validating, and pass true to the validation argument. The
    method must return a bool true/false, to indicate whether the condition has been
    met for the menu item to be active.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 验证方法必须是静态方法，标记与它们验证的项相同的 MenuItem 属性，并将 true 传递给验证参数。该方法必须返回一个布尔值 true/false，以指示是否满足条件，使菜单项处于活动状态。
- en: '`ValidateZeroPosition()` returns the bool true/false value of the expression
    `Selection.activeTransform != null`. In other words, it returns true if there
    is a selected GameObject, and false if there is not.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidateZeroPosition()` 返回表达式 `Selection.activeTransform != null` 的布尔值 true/false。换句话说，如果有选中的
    GameObject，它返回 true，如果没有，则返回 false。'
- en: 'Learn more about Editor Extension menu items in the Unity tutorial: [https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items](https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 教程中了解更多关于编辑器扩展菜单项的信息：[https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items](https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items)
- en: Menu item to create 100 randomly positioned prefab clones
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 100 个随机位置预制件副本的菜单项
- en: 'Sometimes we want to create *lots* of pickups, randomly in our scene. Rather
    than doing this by hand, it is possible to add a custom menu and item to the Unity
    editor, which, when selected, will execute a script. In this recipe, we create
    a menu item that calls a script to create 100 randomly positioned star pickup
    prefabs in the Scene:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想在场景中随机创建 *很多* 拾取物。而不是手动这样做，我们可以在 Unity 编辑器中添加一个自定义菜单和项，当选择它时，将执行一个脚本。在这个食谱中，我们创建了一个调用脚本的菜单项，以在场景中创建
    100 个随机位置的星星拾取物预制件：
- en: '![](img/799bffad-3fcb-4213-acdf-c4c0e3ff159d.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/799bffad-3fcb-4213-acdf-c4c0e3ff159d.png)'
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml)*,
    Inventory UI*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您是从 [第 3 章](c6ad221f-b476-4471-8259-9ad448749a32.xhtml)*，库存 UI* 中的第一个食谱开始设置项目
    `Simple2Dgame_SpaceGirl`。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create an editor extension to add 100 randomly located copies of a prefab
    with one menu click, follow these steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个编辑器扩展，通过一个菜单点击添加 100 个随机位置的预制件副本，请按照以下步骤操作：
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的副本开始，使用 mini-game `Simple2Dgame_SpaceGirl`。
- en: In the Project panel, create a new folder named Prefabs. Inside this new folder,
    create a new empty prefab named `prefab_star`. Populate this prefab by dragging
    GameObject star from the Hierarchy panel over `prefab_star` in the Project panel.
    The prefab should now turn blue and have a copy of all of GameObject star's properties
    and components.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为 Prefabs 的新文件夹。在这个新文件夹内，创建一个名为 `prefab_star` 的新空预制件。通过将 Hierarchy
    面板中的 GameObject 星星拖动到项目面板中的 `prefab_star` 上，填充这个预制件。现在预制件应该变成蓝色，并具有 GameObject
    星星的全部属性和组件的副本。
- en: Delete GameObject star from the Hierarchy.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Hierarchy 中删除 GameObject 星星。
- en: 'In the Project panel, create a new folder named Editor. Inside this new folder,
    create a new C# script class named `MyGreatGameEditor`, with the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为 Editor 的新文件夹。在这个新文件夹内，创建一个名为 `MyGreatGameEditor` 的新 C# 脚本类，代码如下：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After a few seconds, depending on the speed of your computer, you should see
    a new menu appear, My Great Game, with a single menu item, Make 100 stars.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，根据您电脑的速度，您应该会看到一个新菜单出现，My Great Game，其中只有一个菜单项，制作 100 颗星星。
- en: Choose this menu item and, as if by magic, you should now see 100 new `prefab_star(Clone)`
    GameObjects appear in the scene!
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个菜单项，就像魔法一样，你现在应该会看到场景中出现 100 个新的 `prefab_star(Clone)` GameObjects！
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core aim of this recipe is to add a new menu, containing a single menu item
    that will execute the action we desire. `C# attribute [MenuItem("<menuName>/<menuItemName>")]`
    declares the menu name and the menu item name, and Unity will execute the static
    method that follows in the code listing, each time the menu item is selected by
    the user.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的核心目标是添加一个新的菜单，包含一个将执行我们所需操作的菜单项。`C#属性[MenuItem("<menuName>/<menuItemName>")]`声明了菜单名称和菜单项名称，并且每次用户选择菜单项时，Unity都会执行代码列表中跟随的静态方法。
- en: In this recipe, the `[MenuItem("My-Great-Game/Make 100 stars")]` statement declares
    the menu name as My-Great-Game and the menu item as Make 100 stars. The method
    immediately following this attribute is the `PlacePrefabs()` method. When this
    method is executed, it makes the `starPrefab` variable become a reference to the
    prefab found via the `Assets/Prefabs/prefab_star.prefab` path. Then, a For-loop
    is executed 100 times, each time calling the `CreateRandomInstance()` method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，`[MenuItem("My-Great-Game/Make 100 stars")]`语句声明了菜单名称为My-Great-Game，菜单项为Make
    100 stars。紧随此属性之后的方法是`PlacePrefabs()`方法。当此方法执行时，它使`starPrefab`变量成为通过`Assets/Prefabs/prefab_star.prefab`路径找到的预制件的引用。然后，执行一个循环100次，每次调用`CreateRandomInstance()`方法。
- en: The `RandomPosition()` method returns a Vector3 variable that is a random position,
    making use of `X_MAX` and `Y_MAX` constants (z is always zero).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomPosition()`方法返回一个Vector3变量，它是一个随机位置，使用了`X_MAX`和`Y_MAX`常量（z始终为零）。'
- en: The `CreateRandomInstance()` method get a Vector3 randomPosition by calling
    the `RandomPosition()` method. The `Instantiate(...`) built-in method is then
    used to create a new GameObject in the scene, making a clone of the prefab and
    locating it at the position defined by randomPosition.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateRandomInstance()`方法通过调用`RandomPosition()`方法获取一个Vector3随机位置。然后使用内置方法`Instantiate(...)`在场景中创建一个新的GameObject，制作预制件的克隆并将其定位在由randomPosition定义的位置。'
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Childing each new GameObject to a single parent, to avoid filling up the Hierarchy
    with 100s of new objects
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将每个新的GameObject分配给单个父对象，以避免在层次结构中填充100多个新对象
- en: 'Rather than having hundreds of new object clones fill up our Hierarchy panel,
    a good way to keep things tidy is to have an empty "parent" GameObject and child
    a collection of related GameObjects to it. Let''s have a GameObject in the Hierarchy
    named Star-container and child all the new stars to this object:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让数百个新对象克隆填充我们的层次结构面板，保持事物整洁的好方法是有一个新的“父”GameObject，并将相关的一组GameObject作为子对象添加到它。让我们在层次结构中有一个名为Star-container的GameObject，并将所有新的星星作为子对象添加到这个对象：
- en: '![](img/85e72b55-0d08-4081-be7e-4035aa2043e7.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85e72b55-0d08-4081-be7e-4035aa2043e7.png)'
- en: 'We need a variable that will be a reference to our container object, starContainerGO.
    We also need a new method, `CreateStarContainerGO()`, which will find a reference
    to GameObject star-container, if such an object already exists it is deleted,
    and then the method will create a new empty GameObject and give it this name.
    Add the following variable and method to our script class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个变量，它将是我们的容器对象starContainerGO的引用。我们还需要一个新的方法`CreateStarContainerGO()`，该方法将找到GameObject
    star-container的引用，如果该对象已存在，则将其删除，然后该方法将创建一个新的空GameObject并给它这个名称。将以下变量和方法添加到我们的脚本类中：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before we create the prefab clones, we need to first ensure we have created
    our star container GameObject. So, we need to call our new method as the first
    thing we do when the `PlacePrefabs()` method is executed, so add a statement to
    call this method at the beginning of the `PlacePrefabs()` method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建预制件克隆之前，我们需要首先确保我们已经创建了我们的星星容器GameObject。因此，我们需要在执行`PlacePrefabs()`方法时作为第一件事调用我们的新方法，所以在`PlacePrefabs()`方法的开始处添加一个调用此方法的语句：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we need to modify the `CreateRandomInstance()` method so that it gets
    a reference to the new GameObject it has just created and can then child this
    new object to our star-container GameObject variable starContainerGO. Modify the
    `CreateRandomInstance()` method so that it looks as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`CreateRandomInstance()`方法，使其获取它刚刚创建的新GameObject的引用，然后可以将这个新对象作为子对象添加到我们的star-container
    GameObject变量starContainerGO。修改`CreateRandomInstance()`方法，使其看起来如下：
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A progress bar to display proportion completed of Editor extension processing
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个进度条来显示编辑器扩展处理的完成比例
- en: 'If an **Editor** task is going to take more than half a second or so, then
    we should indicate progress complete/remaining to the user via a progress bar
    so that they understand that something is actually happening and the application
    has not crashed and frozen:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个**编辑器**任务需要超过半秒或更长时间，那么我们应该通过进度条向用户显示进度完成/剩余情况，这样他们就能理解实际上有事情在进行，应用程序并没有崩溃和冻结：
- en: '![](img/0ca27244-3283-4684-a2bd-5b611289e806.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ca27244-3283-4684-a2bd-5b611289e806.png)'
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方在先前的配方基础上增加了内容，所以请复制那个项目文件夹，并使用该副本来完成这个配方的任务。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To add a progress bar during the loop (and then remove it after the loop is
    complete), replace the `PlacePrefabs()` method with the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要在循环期间添加进度条（然后在循环完成后移除它），将`PlacePrefabs()`方法替换为以下代码：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As can be seen, inside the for loop, we call the `EditorUtility.DisplayProgressBar(...)`
    method, passing three parameters. The first is a string title for the progress
    bar dialog window, the second is a string to show below the bar itself (usually
    a percentage is sufficient), and the final parameter is a value between 0.0 and
    1.0, indicating the percentage complete to be displayed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，在for循环内部，我们调用`EditorUtility.DisplayProgressBar(...)`方法，传递三个参数。第一个是一个进度条对话框窗口的字符串标题，第二个是在进度条本身下方显示的字符串（通常百分比就足够了），最后一个参数是一个介于0.0和1.0之间的值，表示要显示的完成百分比。
- en: Since we have loop variable i that is a number from 1 to 100, we can display
    this integer followed by a percentage sign for our second parameter and just divide
    this number by 100 to get the decimal value needed to specify how much of the
    progress bar should be shown as completed. If the loop were running for some other
    number, we'd just divide the loop counter by the loop total to get our decimal
    progress value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个从1到100的循环变量i，我们可以显示这个整数，然后跟一个百分号作为第二个参数，只需将这个数字除以100，就可以得到指定进度条应该显示完成的百分比所需的十进制值。如果循环运行的是其他数字，我们只需将循环计数器除以循环总数，就可以得到我们的十进制进度值。
- en: Finally, after the loop has finished, we remove the progress bar with the `EditorUtility.ClearProgressBar()`
    statement. If we don't have this step, the progress bar window-panel will be left
    floating around - annoying the user!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在循环完成后，我们使用`EditorUtility.ClearProgressBar()`语句移除进度条。如果我们没有这一步，进度条窗口面板将漂浮在周围——这会令用户感到烦恼！
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，允许在设计时通过自定义检查器UI更改拾取类型（和参数）
- en: The use of **enums** and corresponding drop-down menus in the Inspector panel
    to restrict changes to one of a limited set often works fine (for example, pickup
    types for a pickup object). However, the trouble with this approach is, when two
    or more properties are related and need to be changed together, there is a danger
    of changing one property, for example, pickup type from Heart to Key, but forgetting
    to change corresponding properties; for example, leaving the Sprite Renderer component
    still showing a Heart sprite. Such mismatches cause problems both in terms of
    messing up intended level design and, of course, the frustration for the player
    when they collide with something showing one pickup image, but a different kind
    of pickup type is added to the inventory!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器面板中使用**枚举**和相应的下拉菜单来限制更改到有限集中的一个，通常效果很好（例如，拾取对象的拾取类型）。然而，这种方法的麻烦在于，当两个或多个属性相关并需要一起更改时，可能会忘记更改相应的属性；例如，从心形改为钥匙的拾取类型，但忘记更改相应的属性；例如，Sprite
    Renderer组件仍然显示心形精灵。这种不匹配既会搞乱预期的关卡设计，当然，当玩家与显示一个拾取图像但拾取类型不同的物品相撞时，也会让玩家感到沮丧！
- en: If a class of GameObject has several related properties or components, which
    all need to be changed together, then a good strategy is to use Unity Editor extensions
    to do all the associated changes each time a different choice is made from a drop-down
    menu showing the defined set of enumerated choices.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个GameObject类有几个相关的属性或组件，所有这些都需要一起更改，那么一个很好的策略是使用Unity编辑器扩展，在从显示定义的枚举选择集的下拉菜单中选择不同的选项时，对所有的相关更改进行操作。
- en: 'In this recipe, we introduce an Editor extension for `PickUp` components of
    GameObjects:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们介绍了一个用于GameObject的`PickUp`组件的编辑器扩展：
- en: '![](img/f0b3f7fc-bd92-4c7b-b8c9-a2135307ecc1.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0b3f7fc-bd92-4c7b-b8c9-a2135307ecc1.png)'
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe assumes you are starting with the `Simple2Dgame_SpaceGirl` project
    setup from the first recipe in *Chapter 3, Inventory UI*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设你从*第3章，库存UI*中的第一个配方开始，使用`Simple2Dgame_SpaceGirl`项目设置。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an editor extension to allow pickup type (and parameters) to be changed
    at Design Time via a custom Inspector UI, follow these steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个编辑器扩展，允许在设计时间通过自定义检查器UI更改拾取类型（和参数），请按照以下步骤操作：
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从mini游戏`Simple2Dgame_SpaceGirl`的新副本开始。
- en: 'In the Project panel, create a new folder named EditorSprites. Move the following
    images from folder Sprites into this new folder: star, healthheart, icon_key_green_100,
    icon_key_green_32, icon_star_32, and icon_heart_32:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为EditorSprites的新文件夹。将以下图片从Sprites文件夹移动到这个新文件夹：star、healthheart、icon_key_green_100、icon_key_green_32、icon_star_32和icon_heart_32：
- en: '![](img/b24734bd-643b-42d2-ba7e-8a8b6a53e77c.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b24734bd-643b-42d2-ba7e-8a8b6a53e77c.png)'
- en: In the Hierarchy panel, rename GameObject star to be named pickup.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中，将GameObject star重命名为pickup。
- en: Edit the tags, changing tag Star to Pickup. Ensure the pickup GameObject now
    has the tag Pickup.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑标签，将标签Star更改为Pickup。确保拾取GameObject现在具有Pickup标签。
- en: 'Create C# script-class `PickUp` and add an instance-object as a component to
    GameObject pickup in the Hierarchy:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建C#脚本类`PickUp`并将实例对象作为组件添加到层次结构中的GameObject拾取：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the Project panel, create a new folder named Editor.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为Editor的新文件夹。
- en: 'Inside this new Editor folder, create a new C# script class named `PickUpEditor`,
    with the following code:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新的Editor文件夹内，创建一个名为`PickUpEditor`的新C#脚本类，代码如下：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the Inspector panel, select GameObject pickup and choose different values
    of the drop-down menu PickUp Type. You should see corresponding changes in the
    image and icons in the Inspector for the Pick Up (Script) component (three icons
    with the name of the type in between). The Sprite property of the Sprite Renderer
    component for this GameObject should change. Also, in the Scene panel, you'll
    see the image in the scene change to the appropriate image for the pickup type
    you have chosen.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，选择GameObject拾取并选择下拉菜单拾取类型的不同值。你应该会在检查器中的拾取（脚本）组件（三个带有类型名称的图标）的图像和图标中看到相应的变化。这个GameObject的Sprite
    Renderer组件的Sprite属性应该会改变。此外，在场景面板中，你会看到场景中的图像变为你选择的拾取类型的适当图像。
- en: '![](img/22162569-212f-431a-9c3c-2979c10784a9.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22162569-212f-431a-9c3c-2979c10784a9.png)'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Our script class `PickUp` has the enum `PickUpType` with the three values:
    `Star`, `Health`, and `Key`. Also, there is the variable type, storing the type
    of the parent GameObject. Finally, there is a `SetSprite(...)` method that sets
    the Sprite Renderer component of the parent GameObject to be set to the provided
    Sprite parameter. It is this method that is called from the editor script each
    time the pickup type is changed from the drop-down menu (with the corresponding
    sprite for the new type being passed).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本类`PickUp`有一个枚举`PickUpType`，包含三个值：`Star`、`Health`和`Key`。还有一个变量类型，用于存储父GameObject的类型。最后，有一个`SetSprite(...)`方法，该方法将父GameObject的Sprite
    Renderer组件设置为提供的Sprite参数。每次从下拉菜单更改拾取类型时（传递对应新类型的相应sprite），都会调用此方法。
- en: 'The vast majority of the work for this recipe is the responsibility of the
    script class `PickUpEditor`. While there is a lot in this script, its work is
    relatively straightforward: for each frame, via method `OnInspectorGUI()`, a dropdown
    list of PickUpType values is presented to the user. Based on the value selected
    from this drop-down list, one of three methods is executed: `InspectorGUI_HEALTH()`,
    `InspectorGUI_KEY()`, or `InspectorGUI_STAR()`. Each of these methods displays
    three icons and the name of the type in the Inspector beneath the drop-down menu
    and ends by calling the `SetSprite(...)` method of the GameObject being edited
    in the Inspector to update the Sprite Renderer component of the parent GameObject
    with the appropriate sprite.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的绝大多数工作由脚本类`PickUpEditor`负责。虽然这个脚本中有很多内容，但其工作相对简单：对于每一帧，通过`OnInspectorGUI()`方法，向用户展示一个包含PickUpType值的下拉列表。根据从下拉列表中选择的值，执行三个方法之一：`InspectorGUI_HEALTH()`、`InspectorGUI_KEY()`或`InspectorGUI_STAR()`。每个方法都在下拉菜单下方显示三个图标和类型的名称，并在最后调用被编辑的GameObject的`SetSprite(...)`方法，以更新父GameObject的Sprite
    Renderer组件。
- en: The C# attribute `[CustomEditor(typeof(PickUp))]` appearing before our class
    is declared, tells Unity to use this special editor script to display component
    properties in the Inspector panel for Pick Up (Script) components of GameObjects,
    rather than Unity's default Inspector which displays public variables of such
    scripted components.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类声明之前出现的C#属性`[CustomEditor(typeof(PickUp))]`告诉Unity使用这个特殊的编辑器脚本来在检查器面板中显示GameObject的拾取（脚本）组件的属性，而不是Unity的默认检查器，该默认检查器显示此类脚本组件的公共变量。
- en: Before and after its main work, the `OnInspectorGUI()` method first ensures
    that any variables relating to the object being edited in the Inspector have been
    updated - `serializedObject.Update()`. The last statement of this method correspondingly
    ensures that any changes to variables in the editor script have been copied back
    to the GameObject being edited - `serializedObject.ApplyModifiedProperties()`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnInspectorGUI()`方法的主要工作之前和之后，该方法首先确保与在检查器中编辑的对象相关的任何变量都已更新 - `serializedObject.Update()`。该方法中的最后一条语句相应地确保编辑器脚本中变量的任何更改都已复制回正在编辑的GameObject
    - `serializedObject.ApplyModifiedProperties()`。
- en: The `OnEnable()` method of script class PickUpEditor loads the three small icons
    (for display in the Inspector) and the three larger sprite images (to update the
    Sprite Renderer for display in the Scene/Game panels). The `pickupObject`variable
    is set to be a reference to the PickUp scripted component, allowing us to call
    the `SetSprite(...)` method. The `pickUpType` variable is set to be linked to
    the type variable of the PickUp scripted component whose special Inspector editor
    view makes this script possible - `serializedObject.FindProperty ("type")`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickUpEditor`脚本类的`OnEnable()`方法加载三个小图标（用于在检查器中显示）和三个较大的精灵图像（用于更新场景/游戏面板中的Sprite
    Renderer）。`pickupObject`变量被设置为对拾取脚本组件的引用，允许我们调用`SetSprite(...)`方法。`pickUpType`变量被设置为与拾取脚本组件的类型变量链接，该组件的特殊检查器编辑器视图使此脚本成为可能
    - `serializedObject.FindProperty ("type")`。'
- en: There's more...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some details you don't want to miss.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不想错过的细节。
- en: Offer the custom editing of pickup parameters via Inspector
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过检查器提供拾取参数的自定义编辑
- en: "Many pickups have additional properties, rather than simply being an item being\
    \ carried. \LFor example, a health pickup may add health points to the player's\
    \ character, a coin pickup may add money points to the character's bank balance,\
    \ and so on. So, let's add an integer points variable to our PickUp class and\
    \ offer the user the ability to easily edit this points value via a GUI slider\
    \ in our customer Inspector editor:"
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 许多拾取项具有附加属性，而不仅仅是携带的物品。例如，一个健康拾取项可能为玩家的角色添加健康点，一个硬币拾取项可能为角色的银行余额添加金钱点，等等。因此，让我们在我们的拾取类中添加一个整数点变量，并允许用户通过我们的自定义检查器编辑器中的GUI滑块轻松编辑此点值：
- en: '![](img/06fa225e-b993-4694-8e80-de8e7188c895.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06fa225e-b993-4694-8e80-de8e7188c895.png)'
- en: 'To add an editable points property to our `PickUp` objects, follow these steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的`PickUp`对象添加可编辑的点属性，请按照以下步骤操作：
- en: 'Add the following extra line into C# script `PickUp` to create our new integer
    points variable:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下额外行添加到C#脚本`PickUp`中，以创建我们的新整数点变量：
- en: '[PRE32]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer points variable:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下额外行添加到C#脚本`PickUpEditor`中，以便与我们的新整数点变量一起工作：
- en: '[PRE33]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following extra line into the `OnEnable()` method in C# script `PickUpEditor`
    to associate our new points variable with its corresponding value in the `PickUp`
    scripted component of the GameObject being edited:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下额外行添加到C#脚本`PickUpEditor`中的`OnEnable()`方法中，以将我们的新点变量与其在GameObject的`PickUp`脚本组件中的对应值关联起来：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can add an extra line into each GUI method for the different `PickUp`
    types. For example, we can add a statement to display an `IntSlider` to the user
    to be able to see and modify the points value for a Health PickUp object. We add
    a new statement at the end of the `InspectorGUI_HEALTH()` method in C# script
    `PickUpEditor` to display a modifiable `IntSlider` representing our new points
    variable as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在每个不同`PickUp`类型的GUI方法中添加一个额外行。例如，我们可以添加一个语句来向用户显示一个`IntSlider`，以便能够查看和修改健康拾取对象的点值。我们在C#脚本`PickUpEditor`中的`InspectorGUI_HEALTH()`方法末尾添加一个新语句，以显示一个可修改的`IntSlider`，如下所示：
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We provide four parameters to the `IntSlider(...)` method. The first is the
    text label the user will see next to the slider. The second is the initial value
    the slider displays. The last two are the maximum and minimum values. In our example,
    we are permitting values from 0 to 100, but if health pickups only offer one,
    two, or three health points, then we'd just call with `EditorGUILayout.IntSlider`
    `("Health points, points.intValue, 1, 5")`. This method returns a new integer
    value based on where the slider has been positioned, and this new value is stored
    back into the integer value part of our `SerializedProperty` variable points.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `IntSlider(...)` 方法提供了四个参数。第一个是用户将在滑块旁边看到的文本标签。第二个是滑块显示的初始值。最后两个是最大值和最小值。在我们的例子中，我们允许从
    0 到 100 的值，但如果健康恢复物品只提供一、二或三个健康点，那么我们只需调用 `EditorGUILayout.IntSlider` `("Health
    points, points.intValue, 1, 5")`。此方法返回一个基于滑块位置的新整数值，并将此新值存储回我们的 `SerializedProperty`
    变量的整数值部分。
- en: Note that the loading and saving of values from the scripted component in the
    GameObject and our editor script is all part of the work undertaken by our calls
    to the `Update()` method and the `ApplyModifiedProperties()` method on the serialized
    object in the `OnInspectorGUI()` method.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从 GameObject 中的脚本组件加载和保存值以及我们编辑器脚本中的所有工作，都是通过在 `OnInspectorGUI()` 方法中对序列化对象调用
    `Update()` 方法和 `ApplyModifiedProperties()` 方法来完成的。
- en: Note that, since points may not have any meaning for some pickups, for example,
    keys, then we simply would not display any slider for the GUI Inspector editor
    when the user is editing `PickUp` objects of that type.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于某些拾取物品（例如钥匙）的点可能没有任何意义，那么我们简单地在用户编辑该类型的 `PickUp` 对象时不会在 GUI Inspector 编辑器中显示任何滑块。
- en: Offer a drop-down list of tags for key-pickup to fit via Inspector
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Inspector 提供适合钥匙拾取的标签下拉列表
- en: 'While the concept of points may have no meaning for a key pickup, the concept
    of the type of lock that a given key fits is certainly something we may wish to
    implement in a game. Since Unity offers us a defined (and editable) list of string
    tags for any GameObject, often it is sufficient, and straightforward, to represent
    the type of lock or door corresponding to a key via its tag. For example, a green
    key might fit all objects tagged LockGreen and so on:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于钥匙拾取物品，点的概念可能没有意义，但给定钥匙可以适配的锁的类型确实是我们可能希望在游戏中实现的概念。由于 Unity 为我们提供了任何 GameObject
    的定义（并可编辑）的字符串标签列表，通常通过标签来表示与钥匙对应的锁或门类型是足够简单直接的。例如，绿色钥匙可能适合所有标记为 LockGreen 的对象，依此类推：
- en: '![](img/311aa5a6-740a-4547-9412-0b2a02812fce.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/311aa5a6-740a-4547-9412-0b2a02812fce.png)'
- en: Therefore, it is very useful to be able to offer a custom Inspector editor for
    a string property of key pickups that stores the tag of the lock(s) the key can
    open. This task combines several actions, including using C# to retrieve an array
    of tags from the Unity editor, then the building and offering of a drop-down list
    of these tags to the user, with the current value already selected in this list.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够为可以打开锁的钥匙的字符串属性提供一个自定义的 Inspector 编辑器是非常有用的。这项任务结合了多个动作，包括使用 C# 从 Unity
    编辑器检索标签数组，然后构建并提供一个包含这些标签的下拉列表给用户，当前值已在此列表中选中。
- en: 'To add a selectable list of strings for the tag for lock(s) that a key fits,
    follow these steps:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要为钥匙可以锁定的标签添加一个可选择的字符串列表，请按照以下步骤操作：
- en: 'Add the following extra line into C# Script `PickUp` to create our new integer
    `fitsLockTag` variable:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下额外行添加到 C# 脚本 `PickUp` 中以创建我们新的整数 `fitsLockTag` 变量：
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer `fitsLockTag` variable:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下额外行添加到 C# 脚本 `PickUpEditor` 中以处理我们新的整数 `fitsLockTag` 变量：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following extra line into the `OnEnable()` method in C# script `PickUpEditor`
    to associate our new `fitsLockTag` variable with its corresponding value in the
    `PickUp` scripted component of the GameObject being edited:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下额外行添加到 C# 脚本 `PickUpEditor` 中的 `OnEnable()` 方法中，以将我们的新 `fitsLockTag` 变量与其对应的
    GameObject 中 `PickUp` 脚本组件的值关联起来：
- en: '[PRE38]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we need to add some extra lines of code into the GUI method for key PickUps.
    We need to add several statements to the end of method `InspectorGUI_KEY()` in
    C# script PickUpEditor to set up and display a selectable popup drop-down list
    representing our new `fitsLockTag` variable as follows. Replace the `InspectorGUI_KEY()`
    method with the following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在GUI方法中添加一些额外的代码行以处理钥匙拾取。我们需要在C#脚本`PickUpEditor`中的方法`InspectorGUI_KEY()`的末尾添加几个语句，以设置和显示一个可选择的弹出下拉列表，表示我们新的`fitsLockTag`变量，如下所示。用以下代码替换`InspectorGUI_KEY()`方法：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We've added several statements to the end of this method. First tags, an array
    of strings, is created (and sorted), containing the list of tags currently available
    in the Unity editor for the current game. We then attempt to find the location
    in this array of the current value of `fitsLockTag` - we can use the `BinarySearch(...)`
    method of built-in script class Array because we have alphabetically sorted our
    array (which also makes it easier for the user to navigate). If the string in
    `fitsLockTag` cannot be found in array tags, then the first item will be selected
    by default (index 0).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将几个语句添加到这个方法的末尾。首先创建（并排序）一个字符串数组`tags`，其中包含当前游戏中在Unity编辑器中可用的标签列表。然后我们尝试找到数组中`fitsLockTag`当前值的所在位置——由于我们已经按字母顺序排序了数组（这也使得用户导航更容易），我们可以使用内置脚本类`Array`的`BinarySearch(...)`方法。如果`fitsLockTag`中的字符串在数组标签中找不到，则默认选择第一个项目（索引0）。
- en: The user is then shown the drop-down list via the `GUILayout` method `EditorGUILayout.Popup(...)`
    and this method returns the index of whichever item is selected. The selected
    index is stored into `selectedTagIndex` and the last statement in the method extracts
    the corresponding string and stores that string into the `fitsLockTag` variable.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用户通过`GUILayout`方法的`EditorGUILayout.Popup(...)`显示下拉列表，此方法返回所选项目的索引。所选索引存储到`selectedTagIndex`中，方法中的最后一个语句提取相应的字符串，并将该字符串存储到`fitsLockTag`变量中。
- en: 'Note: Rather than displaying all possible tags, a further refinement might
    remove all items from array tags that do not have the prefix Lock. So the user
    is only presented with tags such as LockBlue and LockGreen, and so on.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了不显示所有可能的标签，进一步的改进可能需要从数组标签中移除所有没有前缀Lock的项。因此，用户只会看到如LockBlue和LockGreen等标签，等等。
- en: Logic to open doors with keys based on fitsLockTag
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于fitsLockTag打开门的逻辑
- en: In our player collision logic, we can now search through our inventory to see
    if any key items fit the lock we have collided with. For example, if a green door
    was collided with, and the player was carrying a key that could open such doors,
    then that item should be removed from the inventory `List<>` and the door should
    be opened.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的玩家碰撞逻辑中，我们现在可以搜索我们的库存，看看是否有任何关键物品适合我们与之碰撞的锁。例如，如果与一扇绿色门发生碰撞，并且玩家携带一把可以打开这种门的钥匙，那么该物品应该从库存`List<>`中移除，并且门应该被打开。
- en: 'To implement this, you would need to add an if test inside the `OnTriggerEnter()`
    method to detected collision with the item tagged `Door`, and then logic to attempt
    to open the door, and, if unsuccessful, do the appropriate action (for example,
    play sound) to inform the player they cannot open the door yet (we''ll assume
    we have written a door animation controller that plays the appropriate animation
    and sounds and when a door is to be opened):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要在`OnTriggerEnter()`方法中添加一个if测试，以检测与标记为`Door`的物品的碰撞，然后尝试打开门，如果失败，则执行适当的操作（例如，播放声音）以通知玩家他们目前还不能打开门（我们假设我们已经编写了一个门动画控制器，当门要打开时，它会播放适当的动画和声音）：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `OpenDoor()` method would need to identify which item (if any) in the inventory
    can open such a door, and, if found, then that item should be removed from the
    `List<>` and the door should be opened by the appropriate method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenDoor()`方法需要识别库存中哪些物品（如果有）可以打开这样的门，如果找到，则应该从`List<>`中移除该物品，并且应该通过适当的方法打开门：'
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is the code for a method to find the inventory list key item
    fitting a door tag:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个方法，用于找到与门标签匹配的库存列表中的关键物品的代码：
- en: '[PRE42]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The need to add [SerializeField] for private properties
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要为私有属性添加[Serializable]标记
- en: Note that, if we wished to create editor extensions to work with private variables,
    then we'd need to explicitly add `[SerializeField]` in the line immediately before
    the variable to be changed by the editor script. Public variables are serialized
    by default in Unity, so this was not required for our public type variable in
    script class PickUp, although it's good practice to flag ALL variables that are
    changeable via an Editor Extension in this way.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们希望创建用于处理私有变量的编辑器扩展，那么我们需要在变量被编辑器脚本更改的行之前显式添加 `[SerializeField]`。在 Unity
    中，公共变量默认是序列化的，因此对于脚本类 PickUp 中的公共类型变量，这并不是必需的，尽管将所有通过编辑器扩展可更改的变量以这种方式标记为良好实践。
- en: 'Learn more from the Unity editor scripts documentation pages: [http://docs.unity3d.com/ScriptReference/Editor.html](http://docs.unity3d.com/ScriptReference/Editor.html)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Unity 编辑器脚本文档页面了解更多信息：[http://docs.unity3d.com/ScriptReference/Editor.html](http://docs.unity3d.com/ScriptReference/Editor.html)
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object location in scene
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，具有对象创建器 GameObject，带有按钮，可以在场景中十字准线对象位置实例化不同的拾取物品
- en: If a level designer wishes to place each pickup carefully "by hand", we can
    still make this easier than having to drag copies of prefabs manually from the
    Projects panel. In this recipe, we provide a "cross-hairs" GameObject, with buttons
    in the Inspector allowing the game designer to create instances of three different
    kinds of prefab at precise locations by clicking the appropriate button when the
    center of the cross-hairs is at the desired location.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关卡设计师希望手动“逐个”放置拾取物品，我们仍然可以使这个过程比从项目面板手动拖动预制体副本更容易。在这个配方中，我们提供了一个“十字准线”GameObject，在检查器中有按钮，允许游戏设计师通过在十字准线的中心位于所需位置时点击相应的按钮，在精确位置创建三种不同类型的预制体的实例。
- en: A Unity Editor extension is at the heart of this recipe and illustrates how
    such extensions can allow less technical members of a game development team to
    take an active role in level creation within the Unity Editor.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 编辑器扩展是这个配方的核心，展示了此类扩展如何允许游戏开发团队中不太技术的人员在 Unity 编辑器中积极参与关卡创建。
- en: '![](img/23016e79-f90b-4f6d-aea8-0b6a444af84c.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23016e79-f90b-4f6d-aea8-0b6a444af84c.png)'
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you are starting with the `Simple2Dgame_SpaceGirl` project
    setup from the first recipe in [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml)*,
    Inventory UI*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方假设您是从 [第 3 章](c6ad221f-b476-4471-8259-9ad448749a32.xhtml)*，库存 UI* 中的第一个配方开始，使用
    `Simple2Dgame_SpaceGirl` 项目设置。
- en: For this recipe, we have prepared the cross-hairs image you need in a folder
    named Sprites in the `18_09` folder.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在 `18_09` 文件夹下的 Sprites 文件夹中准备了所需的十字准线图像。
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an object-creator GameObject, follow these steps:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个对象创建器 GameObject，请按照以下步骤操作：
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的 `Simple2Dgame_SpaceGirl` 游戏开始。
- en: In the Project panel, rename GameObject star as pickup.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，将 GameObject star 重命名为 pickup。
- en: In the Project panel, create a new folder named Prefabs. Inside this new folder,
    create three new empty prefabs named star, heart, and key.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为 Prefabs 的新文件夹。在这个新文件夹内，创建三个新的空预制体，分别命名为 star、heart 和 key。
- en: Populate the star prefab by dragging GameObject pickup from the Hierarchy panel
    over star in the Project panel. The prefab should now turn blue and have a copy
    of all of the star GameObject's properties and components.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 Hierarchy 面板中的 GameObject pickup 拖动到 Project 面板中的星形上，来填充星形预制体。现在，预制体应该变成蓝色，并具有星形
    GameObject 的所有属性和组件的副本。
- en: Add a new tag Heart in the Inspector. Select GameObject pickup in the Hierarchy
    panel and assign it the tag Heart. Also, drag from the Project panel (folder Sprites)
    the healthheart image into the Sprite property of GameObject pickup so that the
    player sees the heart image on screen for this pickup item.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中添加一个新的标签 Heart。在 Hierarchy 面板中选择 GameObject pickup 并将其分配给 Heart 标签。此外，从项目面板（Sprites
    文件夹）中将 healthheart 图像拖动到 GameObject pickup 的 Sprite 属性中，以便玩家在屏幕上看到这个拾取物品的心形图像。
- en: Populate the heart prefab by dragging GameObject pickup from the Hierarchy panel
    over heart in the Prefabs folder in the Project panel. The prefab should now turn
    blue and have a copy of all of the pickup GameObject's properties and components.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 Hierarchy 面板中的 GameObject pickup 拖动到 Project 面板中 Prefabs 文件夹中的心形上，来填充心形预制体。现在，预制体应该变成蓝色，并具有拾取
    GameObject 的所有属性和组件的副本。
- en: Add a new tag Key in the Inspector. Select GameObject's pickup in the Hierarchy
    panel and assign it this tag Key. Also, drag from the Project panel (folder Sprites)
    image icon_key_green_100 into the Sprite property of GameObject's pickup so that
    the player sees the key image on screen for this pickup item.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中添加一个新的标签Key。在层次结构面板中选择GameObject的拾取，并分配这个标签Key。此外，从项目面板（文件夹 Sprites）拖动图像图标_key_green_100到GameObject拾取的Sprite属性中，以便玩家在屏幕上看到这个拾取物品的钥匙图像。
- en: Populate the key prefab by dragging GameObject pickup from the Hierarchy panel
    over key in the Prefabs folder in the Project panel. The prefab should now turn
    blue and have a copy of all of the pickup GameObject's properties and components.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将GameObject拾取从层次结构面板拖动到项目面板中的Prefabs文件夹中的key上，来填充关键预制件。现在，预制件应该变成蓝色，并具有拾取GameObject的所有属性和组件的副本。
- en: Delete GameObject pickup from the Hierarchy.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中删除GameObject拾取。
- en: 'In the Project panel, create a new folder named Editor. Inside this new folder,
    create a new C# script class named `ObjectBuilderEditor`, with the following code:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为Editor的新文件夹。在这个新文件夹内，创建一个名为`ObjectBuilderEditor`的新C#脚本类，代码如下：
- en: '[PRE43]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Our Editor script is expecting to find the three icons in a folder named EditorSprites,
    so let's do this. First, create a new folder named EditorSprites. Next, drag the
    three 32 x 32 pixel icons from the Sprites folder into this new EditorSprites
    folder. Our Editor script should now be able to load these icons for image-based
    buttons that it will be drawing in the Inspector, from which the user chooses
    which pickup prefab object to clone into the scene.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的编辑器脚本期望在名为EditorSprites的文件夹中找到三个图标，所以让我们这样做。首先，创建一个名为EditorSprites的新文件夹。接下来，将三个32
    x 32像素的图标从 Sprites 文件夹拖动到这个新的EditorSprites文件夹中。现在，我们的编辑器脚本应该能够加载这些图标，用于在检查器中绘制的基于图像的按钮，用户可以通过它选择要克隆到场景中的拾取预制对象。
- en: '![](img/af577152-388f-4dca-ab3c-8162c0884ff7.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af577152-388f-4dca-ab3c-8162c0884ff7.png)'
- en: From the Project panel, drag `sprite cross_hairs.fw` into the Scene. Rename
    this GameObject object-creator-cross-hairs, and in its Sprite Renderer component
    in the Inspector, set Sorting Layer to Foreground.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中，将`sprite cross_hairs.fw`拖动到场景中。将这个GameObject对象-creator-cross-hairs重命名为object-creator-cross-hairs，并在检查器中的Sprite
    Renderer组件中，将排序层设置为前景。
- en: 'Attach the following C# script to GameObject object-creator-cross-hairs:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本附加到GameObject对象-creator-cross-hairs：
- en: '[PRE44]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Select the Rect Tool (shortcut key T), and as you drag gameObject object-creator-cross-hairs
    and click on the desired icon in the Inspector, new pickup GameObjects will be
    added to the scene's Hierarchy.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择矩形工具（快捷键T），当你拖动gameObject对象-creator-cross-hairs并在检查器中点击所需的图标时，新的拾取GameObject将被添加到场景的层次结构中。
- en: How it works...
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The script class `ObjectBuilderScript` has just two methods, one of which has
    just one statement - the `Awake()` method simply makes this GameObject become
    inactive when the game is running (since we don't want the user to see our cross-hairs
    created tool during gameplay). The `AddObjectToScene(...)` method receives a reference
    to a prefab as a parameter and instantiates a new clone of the prefab in the scene
    at the location of GameObject object-creator-cross-hairs at that point in time.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类`ObjectBuilderScript`有两个方法，其中一个只有一个语句 - `Awake()`方法简单地使这个GameObject在游戏运行时变为非活动状态（因为我们不希望用户在游戏过程中看到我们创建的十字准星工具）。`AddObjectToScene(...)`方法接收一个预制件的引用作为参数，并在该点在场景中实例化一个新的预制件副本，位置与GameObject对象-creator-cross-hairs相同。
- en: Script class `ObjectBuilderEditor` has a C# attribute `[CustomEditor(typeof(ObjectBuilderScript))]`
    immediately before the class is declared, telling Unity to use this class to control
    how `ObjectBuilderScript` GameObject properties and components are shown to the
    user in the Inspector.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类`ObjectBuilderEditor`在类声明之前有一个C#属性`[CustomEditor(typeof(ObjectBuilderScript))]`，告诉Unity使用这个类来控制`ObjectBuilderScript`
    GameObject属性和组件在检查器中如何显示给用户。
- en: There are six variables, three textures for the icons to form the buttons in
    the Inspector, and three GameObject references to the prefabs of which instances
    will be created. The `OnEnable()` method assigns values to these six variables
    using the built-in method `AssetDatabase.LoadAssetAtPath()`, retrieving the icons
    from the Project folder EditorSprites and getting references to the prefabs in
    the Project folder Prefabs.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个变量，三个用于在检查器中形成按钮的图标纹理，以及三个GameObject引用，这些引用将创建预制件的实例。`OnEnable()`方法使用内置方法`AssetDatabase.LoadAssetAtPath()`将这些六个变量赋值，从项目文件夹EditorSprites中检索图标，并获取项目文件夹Prefabs中预制件的引用。
- en: The `OnInspectorGUI()` method has a variable myScript, which is set to be a
    reference to the instance of scripted component `ObjectBuilderScript` in GameObject
    object-creator-cross-hairs (so we can call its method when a prefab has been chosen).
    The method then displays a mixture of empty text `Labels` (to get some vertical
    spacing) and `FlexibleSpace` (to get some horizontal spacing and centering) and
    displays three buttons to the user, with icons of star, heart, and key. The scripted
    GUI technique for Unity custom Inspector GUIs wraps an `if` statement around each
    button, and on the frame the user clicks the button, the statement block of the
    if statement will be executed. When any of the three buttons is clicked, a call
    is made to `AddObjectToScene(...)` of the scripted component `ObjectBuilderScript`,
    passing the prefab corresponding to the button that was clicked.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInspectorGUI()` 方法有一个名为 myScript 的变量，该变量被设置为对 GameObject 对象创建器十字准线中脚本组件
    `ObjectBuilderScript` 实例的引用（因此我们可以在选择预制件时调用其方法）。该方法随后显示一系列空文本 `Labels`（以获取一些垂直间距）和
    `FlexibleSpace`（以获取一些水平间距和居中对齐），并向用户显示三个按钮，按钮图标分别为星星、心形和钥匙。Unity 自定义 Inspector
    GUI 的脚本 GUI 技术将每个按钮周围包裹一个 `if` 语句，当用户点击按钮时，该 `if` 语句的语句块将被执行。当点击三个按钮中的任何一个时，都会调用脚本组件
    `ObjectBuilderScript` 的 `AddObjectToScene(...)` 方法，传递与被点击按钮对应的预制件。'
- en: Extensible class-based code architecture to manage complex IMGUIs
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于管理复杂 IMGUI 的可扩展基于类的代码架构
- en: For complex objects and editor interactions, you may find the number of GUI
    statements gets high, and code can quickly get hard to manage with very long `OnGUI()`
    methods. One approach to organise complex GUIs involves a list of items, and each
    item being an object-instance of a wrapper-class for a GUI control object. Each
    wrapper class will implement its own `OnGUI()` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂对象和编辑器交互，您可能会发现 GUI 语句的数量很高，并且代码可能会因为非常长的 `OnGUI()` 方法而快速变得难以管理。组织复杂 GUI
    的一种方法涉及一个项目列表，其中每个项目都是一个 GUI 控制对象包装类的对象实例。每个包装类将实现它自己的 `OnGUI()` 方法。
- en: 'In this recipe, we''ll use this approach to create a complex GUI with well-organised
    code. This recipe is adapted from an example posted by Statement on answers.unity.com
    in 2013 to a question about the different IMGUI libraries: [https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html](https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用这种方法来创建一个复杂且代码组织良好的 GUI。这个菜谱是从 2013 年在 answers.unity.com 上发布的关于不同
    IMGUI 库的问题的示例中改编的：[https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html](https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html)
- en: We'll create IMGUI static labels, interactive text boxes and a button, and illustrate
    some flexible space and centering using `BeginHorizontal()` and `EndHorizontal()`,
    where the fiddly GUILayout statements are put into their own classes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建 IMGUI 静态标签、交互式文本框和按钮，并使用 `BeginHorizontal()` 和 `EndHorizontal()` 来展示一些灵活的空间和居中对齐，其中繁琐的
    GUILayout 语句被放入它们自己的类中。
- en: '![](img/e71780bc-4b94-4685-99ac-9010da763561.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e71780bc-4b94-4685-99ac-9010da763561.png)'
- en: How to do it...
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create an extensible class-based code architecture to manage complex IMGUIs,
    follow these steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可扩展的基于类的代码架构来管理复杂的 IMGUI，请按照以下步骤操作：
- en: 'First let''s create an **interface**, that is, a template script-class that
    defines a method all implementing-classes must have. Create a folder Editor. Inside
    that create a folder MyGUI. Inside that create a new C# script-class named `IMyGUI`
    containing the following:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 **接口**，即一个模板脚本类，它定义了所有实现类必须拥有的方法。创建一个名为 Editor 的文件夹。在该文件夹内创建一个名为
    MyGUI 的文件夹。在该文件夹内创建一个新的 C# 脚本类，命名为 `IMyGUI`，包含以下内容：
- en: '[PRE45]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s define a FlexibleSpace class for our GUI library. Create a C# script
    class named `MyGUIFlexibleSpace` containing the following:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的 GUI 库定义一个 FlexibleSpace 类。创建一个名为 `MyGUIFlexibleSpace` 的 C# 脚本类，包含以下内容：
- en: '[PRE46]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we''ll create a button class. Create a C# script class named `MyGUIButton`
    containing the following:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个按钮类。创建一个名为 `MyGUIButton` 的 C# 脚本类，包含以下内容：
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we''ll create an input Text Field class. Create a C# script class named
    `MyGUITextField` containing the following:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个输入文本字段类。创建一个名为 `MyGUITextField` 的 C# 脚本类，包含以下内容：
- en: '[PRE48]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we''ll create a non-interactive text label class. Create a C# script class
    named `MyGUILabel` containing the following:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个非交互式文本标签类。创建一个名为 `MyGUILabel` 的 C# 脚本类，包含以下内容：
- en: '[PRE49]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In Editor folder, we''ll now create a class to display an interactive custom
    panel, making use of our `MyGUI` classes above. Create `C# script-class MyEditorWindow`
    containing the following to start with:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器文件夹中，我们现在将创建一个类来显示一个交互式自定义面板，利用我们上面的 `MyGUI` 类。创建包含以下内容的 `C# script-class
    MyEditorWindow` 以开始：
- en: '[PRE50]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ll now add the method to display a menu item to open our window-panel.
    Add the following to `C# script-class MyEditorWindow`:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一个方法来显示一个菜单项以打开我们的窗口面板。将以下内容添加到 `C# script-class MyEditorWindow` 中：
- en: '[PRE51]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ll now add a method to setup our `MyGUI` objects and add them to our GUI
    list of objects. Add the following to C# script-class` MyEditorWindow`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一个方法来设置我们的 `MyGUI` 对象并将它们添加到我们的 GUI 对象列表中。将以下内容添加到 C# 脚本类 `MyEditorWindow`
    中：
- en: '[PRE52]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''ll now add a method loop through and display all our GUI objects each frame.
    Add the following to C# script-class `MyEditorWindow`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一个方法来遍历并显示我们所有的 GUI 对象，每帧。将以下内容添加到 C# 脚本类 `MyEditorWindow` 中：
- en: '[PRE53]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we need to add a method to respond to the button clicks (`LogUser`).
    Also a method to ensure we re-register this method when the window is disabled
    (to avoid memory leaks). Add these two methods to C# script-`class MyEditorWindow`:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个方法来响应用户点击（`LogUser`）。还需要一个方法来确保当窗口被禁用时重新注册此方法（以避免内存泄漏）。将这两个方法添加到
    C# 脚本类 `MyEditorWindow` 中：
- en: '[PRE54]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After a few seconds, you should now see a menu named Example appear with a Show
    Window item.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，你现在应该看到一个名为 Example 的菜单出现，其中有一个 Show Window 项。
- en: You should now be able to display our custom registration panel by choosing
    this menu item.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该能够通过选择此菜单项来显示我们的自定义注册面板。
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since there are several C# script-classes, each shall be separately described
    in the following.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有多个 C# 脚本类，以下将分别描述每个。
- en: Script-class MyEditorWindow
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类 MyEditorWindow
- en: In C# script-class `MyEditorWindow`, you preceded the `ShowWindow()` method
    with an attribute to add a menu item Show Window to a menu named Example. The
    `GetWindow()` statement gets a reference to an `MyEditorWindow` object - if no
    such window-panel exists, it creates one. The first argument is the title of the
    panel My Reg Panel. The true for the second argument tells Unity to make the window-panel
    have the focus (if a window panel already existed).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 脚本类 `MyEditorWindow` 中，你使用属性在名为 Example 的菜单中添加了一个名为 Show Window 的菜单项，在
    `ShowWindow()` 方法之前。`GetWindow()` 语句获取一个 `MyEditorWindow` 对象的引用 - 如果不存在这样的窗口面板，它将创建一个。第一个参数是面板的标题
    My Reg Panel。第二个参数的 true 告诉 Unity 使窗口面板获得焦点（如果已经存在窗口面板）。
- en: The `OnEnable()` method is executed when the window-panel first becomes enabled
    (active). It creates 2 `MyGUITextField` objects for username and real name, and
    a register `MyGUIButton`. Each of these objects are based on the MyGUI component
    script-classes in folder `MyGUI.` Then GUI objects are added in the sequence we
    wish, to the list variable `guiCompoennts`. The first GUI component added to the
    list is a new object-instance of an non-interactive `MyGUILabel` (passing the
    text string Unity 2018 is great and a true for full centering). Then, we add the
    two text input components (username and real name), then a new `MyGUIFlexible`
    space object-instance, and finally a `MyGUIButton` with the label Register, whose
    `OnClick` event will cause the invocation of the `LogUser()` method.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnEnable()` 方法在窗口面板首次启用（激活）时执行。它创建了两个 `MyGUITextField` 对象用于用户名和真实姓名，以及一个注册
    `MyGUIButton`。这些对象都基于文件夹 `MyGUI` 中的 MyGUI 组件脚本类。然后，按照我们希望的顺序，将这些 GUI 对象添加到列表变量
    `guiComponents` 中。列表中第一个添加的 GUI 组件是一个新的非交互式 `MyGUILabel` 对象实例（传递文本字符串 Unity 2018
    是伟大的，并使用 true 进行完全居中）。然后，我们添加两个文本输入组件（用户名和真实姓名），接着是一个新的 `MyGUIFlexible` 空间对象实例，最后是一个带有标签
    Register 的 `MyGUIButton`，其 `OnClick` 事件将触发 `LogUser()` 方法的调用。'
- en: The `LogUser()` method logs the names in the two text fields to the Debug.Log.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogUser()` 方法将两个文本字段中的名称记录到 Debug.Log。'
- en: The `OnDisable()` method ensures that when the window-panel is being disabled/closed
    we de-register the `LogUser()` method from the OnClick event of the button object.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDisable()` 方法确保当窗口面板被禁用/关闭时，我们从按钮对象的 `OnClick` 事件中注销 `LogUser()` 方法。'
- en: The `OnGUI()` method, which executes every frame, simply loops through each
    GUI compoennt in list guiComponents, invoking the components' `OnGUI()` method.
    So each frame, our GUI is redisplayed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnGUI()` 方法，每帧执行一次，简单地遍历列表 `guiComponents` 中的每个 GUI 组件，调用组件的 `OnGUI()` 方法。因此，每帧，我们的
    GUI 都会重新显示。'
- en: Script-class IMyGUI
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类 IMyGUI
- en: This C# script-class declares an **interface named** IMyGUI. An interface is
    a template script-class that defines method(s) all implementing classes must implement.
    Our interface class is very simple, it simply requires all implementing classes
    must defined an `OnGUI()` method. There is a naming convention that recommends
    all interface classes have a capital letter I, before the upper-camel case class
    name.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这个C#脚本类声明了一个名为**IMyGUI**的接口。接口是一个模板脚本类，它定义了所有实现类必须实现的方法。我们的接口类非常简单，它只要求所有实现类必须定义一个`OnGUI()`方法。有一个命名约定建议所有接口类在首字母大写的类名前都有一个大写的I。
- en: By declaring this interface, we can now implement lots of different `IMyGUI`
    classes, which can all be treated the same way - that is, they can have their
    `OnGUI()` method invoked each frame.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明这个接口，我们现在可以实现许多不同的`IMyGUI`类，它们都可以以相同的方式处理——也就是说，它们可以在每一帧调用它们的`OnGUI()`方法。
- en: Script-class MyGUIFlexibleSpace
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类MyGUIFlexibleSpace
- en: This simple script-class adds a `GUILayout.FlexibleSpace()` to the IMGUI system
    when its `OnGUI()` method is invoked.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本类在其`OnGUI()`方法被调用时，向IMGUI系统添加一个`GUILayout.FlexibleSpace()`。
- en: Script-class MyGUITextField
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类MyGUITextField
- en: 'This class declares two public items: a public string (for the text the user
    can see and edit), and a public label. Its `OnGUI()` method displays the labelled
    text field, and stores its value back into variable text.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类声明了两个公共项：一个公共字符串（用于用户可以看到和编辑的文本），和一个公共标签。它的`OnGUI()`方法显示标记的文本字段，并将它的值存储回变量text。
- en: So our custom editor classes can set the initial text value and label, and also
    read any new value of the text from an object-instance of this class.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的自定义编辑类可以设置初始文本值和标签，并且可以从这个类的对象实例中读取任何新的文本值。
- en: Script-class MyGUILabel
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类MyGUILabel
- en: 'This class has two private values: the text to be displayed, and a bool, defining
    whether or not to fully center the text. Its `OnGUI()` method will add a `GUILayout.Lable()`
    to the GUI, and if the bool is true, it will add other GUILayout components before
    and after the label to ensure the label is both vertically and horizontally centered
    when displayed.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个私有值：要显示的文本和一个布尔值，定义是否完全居中文本。它的`OnGUI()`方法将添加一个`GUILayout.Label()`到GUI中，如果布尔值为真，它将在标签前后添加其他GUILayout组件，以确保标签在显示时垂直和水平居中。
- en: This is an example of how some of the complexity of an interface can be delegated
    to its own class like this. By setting a single bool to true, several Begin/End/Vertical/Horizontal
    statements and FlexibleSpace statements are added to the GUI that is output.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些接口复杂性的示例，如何将其委托给其自己的类，就像这样。通过设置一个布尔值设置为true，添加了几个Begin/End/Vertical/Horizontal语句和FlexibleSpace语句到输出的GUI中。
- en: 'The screenshot illustrates how the flexible space and vertical/horizonal groups
    result in the desired alignment and spacing in the window-panel the user sees:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 截图说明了灵活空间和垂直/水平分组如何导致用户在窗口面板中看到所需的对齐和间距：
- en: '![](img/466a14ac-e0db-4fff-86f4-4accbd7ed5c2.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/466a14ac-e0db-4fff-86f4-4accbd7ed5c2.png)'
- en: Script-class MyGUIButton
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类MyGUIButton
- en: This class declares a public label, and also a public `OnClick` event. During
    the execution of its `OnGUI()` method, if the button has been clicked any methods
    that have been registered to listen for, `OnClick` events will be invoked.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类声明了一个公共标签，以及一个公共`OnClick`事件。在其`OnGUI()`方法的执行过程中，如果按钮被点击，任何已注册监听`OnClick`事件的函数将被调用。
- en: There is a condition in the `OnGUI()` method, to ensure that if no methods are
    registered to list for `OnClick` events, then no statement is executed.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnGUI()`方法中有一个条件，以确保如果没有注册方法来监听`OnClick`事件，则不执行任何语句。
- en: 'We can see the `LogUser` method of the `MyEditorWindow` the window-panel object
    being registered for the `OnClick` event of the `registerButton` object, in its
    `OnEnable()` method:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`MyEditorWindow`的窗口面板对象中看到`LogUser`方法被注册为`registerButton`对象的`OnClick`事件，在其`OnEnable()`方法中：
- en: '[PRE55]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: While perhaps overkill for this simple window-panel, this recipe illusrtates
    how the use of an Interface and a list of GUI component objects, allows for an
    extensible system of custom GUI component classes to be created, while allowing
    the complexity of the `EditorWindow` classes to be maintained.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于这个简单的窗口面板来说可能有些过度，但这个配方说明了使用接口和GUI组件对象列表的使用，如何创建一个可扩展的自定义GUI组件类系统，同时保持`EditorWindow`类的复杂性。
- en: 'NOTE: An alternative to C# events would be to use Unity Events and in some
    cases lambda expressions. You can read a discussion of such topics in these online
    articles:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：C#事件的替代方案可以是使用Unity事件，在某些情况下使用lambda表达式。您可以在以下在线文章中阅读关于这些主题的讨论：
- en: '`http://www.blockypixel.com/2012/09/c-in-unity3d-dynamic-methods-with-lambda-expressions/`'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://www.blockypixel.com/2012/09/c-in-unity3d-dynamic-methods-with-lambda-expressions/`'
- en: '`https://forum.unity.com/threads/how-to-use-an-action.339952/`'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://forum.unity.com/threads/how-to-use-an-action.339952/`'
