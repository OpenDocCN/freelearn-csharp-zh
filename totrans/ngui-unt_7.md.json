["```cs\npublic void Initialize(float _movementDuration)\n{\n  //Get the Viewport's Background size\n  Vector2 bgSize = \n    transform.parent.parent.FindChild(\"Background\").GetComponent<UISprite>().localSize;\n  //Get this enemy's sprite size\n  Vector2 spriteSize = \n    transform.FindChild(\"Sprite\").GetComponent<UISprite>().localSize;\n  //Set its position to a random X, and Y of -(enemyHeight/2)\n  transform.localPosition = \n new Vector3(Random.Range(spriteSize.x *0.5f, bgSize.x - (spriteSize.x *0.5f)), -(spriteSize.y *0.5f), 0);\n  //Tween its position towards end of background\n  TweenPosition.Begin(gameObject, _movementDuration,\n    new Vector3(transform.localPosition.x, -bgSize.y + (spriteSize.y * 0.5f), 0));\n}\n```", "```cs\n//We need our Enemy Prefab for Instantiation\npublic Object enemyPrefab;\n//Random-control variables\npublic int firstEnemyDelay = 1;\n//Min and Max intervals between 2 spawns\npublic float minInterval = 4;\npublic float maxInterval = 15;\n//Min and Max Enemy MovementTime\npublic float minMovementTime = 20;\npublic float maxMovementTIme = 50;\n```", "```cs\n//Coroutine that spawns enemies\nIEnumerator SpawnEnemy()\n{\n  //First time, set to firstEnemyDelay\n  float delay = firstEnemyDelay;\n  //Loop while the game is running\n  while(true){\n    //Wait for the correct delay\n    yield return new WaitForSeconds(delay);\n    //Create a new enemy, stock its EnemyController\n    EnemyController newEnemy =\n      NGUITools.AddChild(gameObject, enemyPrefab as GameObject).GetComponent<EnemyController>();\n    //Initialize it with random speed\n    newEnemy.Initialize(Random.Range (minMovementTime, maxMovementTIme));\n    //Set the new random delay\n    delay = Random.Range(minInterval, maxInterval);\n  }\n}\n```", "```cs\nvoid Start ()\n{\n  //Start the Spawn Coroutine with first delay\n  StartCoroutine(SpawnEnemy());\n}\n```", "```cs\n//Set the Viewport as target for UIForwardEvents\nGetComponent<UIForwardEvents>().target = transform.parent.parent.gameObject;\n```", "```cs\n    private bool built = false;\n    ```", "```cs\n    //Set the build value to true and activate collider\n    built = true;\n    collider.enabled = true;\n    ```", "```cs\n    public void HitByEnemy(EnemyController enemy)\n    {\n      //If the barrier isn't built, don't go further\n      if(!built) return;\n      //Else, kill the enemy\n      StartCoroutine(enemy.Kill());\n      //Kill the barrier too\n      StartCoroutine(RemoveBarrier());\n    }\n    ```", "```cs\n    IEnumerator RemoveBarrier()\n    {\n      //Tween for smooth disappearance\n      TweenScale.Begin(gameObject, 0.2f, Vector3.zero);\n      //Notify the Viewport that a Barrier has been removed\n      transform.parent.SendMessage(\"BarrierRemoved\");\n      //Wait for end of tween, then destroy the barrier\n      yield return new WaitForSeconds(0.2f);\n      Destroy(gameObject);\n    }\n    ```", "```cs\n    void BarrierRemoved()\n    {\n      //Decrease the barrierCount value\n      barrierCount--;\n    }\n    ```", "```cs\n    public IEnumerator Kill()\n    {\n      //Tween for smooth disappearance\n      TweenScale.Begin(gameObject, 0.2f, Vector3.zero);\n      //Deactivate the collider now\n      collider.enabled = false;\n      //Wait end of tween, then destroy the enemy\n      yield return new WaitForSeconds(0.2f);\n      Destroy(gameObject);\n    }\n    ```", "```cs\n    void OnTriggerEnter(Collider other)\n    {\n      //Store the collided object's ActiveBarrierController\n      ActiveBarrierController barrierController = other.GetComponent<ActiveBarrierController>();\n      //If it has a BarrierController, call HitByEnemy\n      if(barrierController != null)\n      barrierController.HitByEnemy(this);\n    }\n    ```", "```cs\n//Static variable that will store this instance\npublic static HealthController Instance;\n//We will need the attached slider and a HP value\nprivate UISlider slider;\nprivate float hp = 100;\n\nvoid Awake()\n{\n  //Store this instance in the Instance variable\n  Instance = this;\n  //Get the slider Component\n  slider = GetComponent<UISlider>();\n}\n```", "```cs\npublic void Damage(float dmgValue)\n{\n  //Set new HP value with a clamp between 0 and 100\n  hp = Mathf.Clamp(hp - dmgValue, 0, 100);\n  //Update the slider to a value between 0 and 1\n  slider.value = hp * 0.01f;\n  //If hp <= 0, restart level\n  if(hp <= 0)\n  Application.LoadLevel(Application.loadedLevel);\n}\n```", "```cs\n    //Is the collided object a DamageZone?\n    if(other.CompareTag(\"DamageZone\"))\n    {\n      //In that case, hurt the player\n      HealthController.Instance.Damage(30f);\n      //Then, kill the enemy and don't go further\n      StartCoroutine(Kill());\n      return;\n    }\n    ```", "```cs\n//Hacking status\nCodeEncrypted = Code Encrypted\nHacking = [FF6666]Hacking...\n//Self-Destruct Codes\nSpace = space\nNeptune = neptune\nMoon = moon\nMars = mars\nJupiter = jupiter\n```", "```cs\n//Hacking status\nCodeEncrypted = Code CryptÃ©\nHacking = [FF6666]Piratage...\n//Self-Destruct Codes\nSpace = espace\nNeptune = neptune\nMoon = lune\nMars = mars\nJupiter = jupiter\n```", "```cs\n//Boolean to check if enemy is hacked or not\npublic bool hacked = false;\n//We will need the Self-Destruct Code Label\nprivate UILabel codeLabel;\n//We will also need the hacking slider\nprivate UISlider hackSlider;\n//We will need to store the destructCode\npublic string destructCode = \"\";\n//We will need a hackSpeed float\nfloat hackSpeed = 0.2f;\n```", "```cs\n//Get the hacking slider\nhackSlider = transform.FindChild(\"DestructCode\").GetComponent<UISlider>();\n//Get the hacking status label\ncodeLabel = hackSlider.transform.FindChild(\"Label\").GetComponent<UILabel>();\n```", "```cs\npublic void SetDestructCode(string randomWordKey)\n{\n  //If the randomWordKey is not empty...\n  if(!string.IsNullOrEmpty(randomWordKey))\n  {\n    //... Get the corresponding localized code\n    destructCode = Localization.instance.Get(randomWordKey);\n    //Set the Label to \"Code Encrypted\" \n    codeLabel.text = Localization.instance.Get(\"CodeEncrypted\");\n  }\n  //If the randomWordKey is empty, disable hacking slider\n  else\n  hackSlider.gameObject.SetActive(false);\n}\n```", "```cs\nIEnumerator Hack()\n{\n  //Set the Label to \"Hacking...\"\n  codeLabel.text = Localization.instance.Get(\"Hacking\");\n  //While hacking slider is not full\n  while(hackSlider.value < 1)\n  {\n    //Increase slider value, framerate independant\n    hackSlider.value += Time.deltaTime * hackSpeed;\n    //Wait for next frame\n    yield return null;\n  }\n  //Make sure slider is at 1\n  hackSlider.value = 1;\n  //Set the hacked bool to true for this enemy\n  hacked = true;\n  //Display the Self-Destruct code now\n  codeLabel.text = \"[99FF99]\" + destructCode;\n}\n```", "```cs\nvoid OnClick()\n{\n  //If the enemy has a destruct code, launch hacking\n  if(!string.IsNullOrEmpty(destructCode))\n    StartCoroutine(Hack());\n}\n```", "```cs\n//Include Lists\nusing System.Collections.Generic;\n```", "```cs\n//Chance for each enemy to have a destructCode\npublic float destructCodeChance = 60;\n//Array of strings to store destructCodes keys\npublic string[] wordKeys;\n//We will need a list of enemies\nprivate List<EnemyController> enemies;\n//We will need a static instance of this script\npublic static EnemySpawnController instance;\n//This will store the current word typed by the player\npublic string currentWord;\n```", "```cs\nvoid Awake()\n{\n  //Store the instance of this script\n  instance = this;\n  //Initialize the List\n  enemies = new List<EnemyController>();\n}\n```", "```cs\n//Create a new empty string for destruct code\nstring randomCode = \"\";\n//If the random is valid, get a random word\nif(Random.Range(0f,100f) < destructCodeChance)\nrandomCode = GetRandomWord();\n//Set the enemy's the DestructCode newEnemy.SetDestructCode(randomCode);\n//Add the enemy to the list of enemies\nenemies.Add(newEnemy);\n```", "```cs\nprivate string GetRandomWord()\n{\n  //Return a random Word Key\n  return wordKeys[Random.Range(0, wordKeys.Length)];\n}\n```", "```cs\npublic void EnemyDestroyed(EnemyController destroyedEnemy)\n{\n  //Remove the destroyed enemy from the List\n  enemies.Remove(destroyedEnemy);\n}\n```", "```cs\n//Remove enemy from the List\nEnemySpawnController.instance.EnemyDestroyed(this);\n```", "```cs\nvoid Update()\n{\n  //If the player has typed a character\n  if(!string.IsNullOrEmpty(Input.inputString)) \n  {\n    //Add this new character to the currentWord\n    currentWord += Input.inputString;\n    //We need to know if the code matches at least 1 enemy\n    bool codeMatches = false;\n    //Check enemies' destruct codes one by one\n    for each(EnemyController enemy in enemies)\n    {\n      //If the enemy has a destruct code AND is hacked\n      if(enemy.destructCode != \"\" && enemy.hacked)\n      {\n        //currentWord contain the destruct code?\n        if(currentWord.Contains(enemy.destructCode))\n        {\n          //Yes - Destroy it and update our bool\n          StartCoroutine(enemy.Kill());\n          codeMatches = true;\n        }\n      }\n    }\n    //Did the word match at least 1 enemy?\n    if(codeMatches)\n    //In that case, reset the currentWord to empty\n    currentWord = \"\";\n  }\n}\n```"]