<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Advanced Shading Techniques</h1>
                
            
            
                
<p class="calibre3"/>
<p class="calibre3">In this chapter, you will learn the following:</p>
<ul class="calibre11">
<li class="calibre12">Using Unity's built-in CgInclude files</li>
<li class="calibre12">Making your shader world modular with CgInclude</li>
<li class="calibre12">Implementing a Fur Shader</li>
<li class="calibre12">Implementing Heatmaps with arrays</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            
                
<p class="calibre3">This chapter covers some advanced shader techniques that you can use for your game. You should remember that many of the most eye-catching effects you see in games are made by testing the limits of what shaders can do. This book provides you with the technical foundations to modify and create shaders, but you are strongly encouraged to play and experiment with them as much as you can. Making a good game is not a quest for photorealism; you should not approach shaders with the intention of replicating reality because this is unlikely to happen. Instead, you should try to use shaders as a tool to make your game truly unique. With the knowledge of this chapter, you will be able to create the materials that you want.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using Unity's built-in CgInclude files</h1>
                
            
            
                
<p class="calibre3">Our first step in writing our own <kbd class="calibre13">CgInclude</kbd> files is to understand what Unity is already providing with us for shaders. When writing Surface Shaders, there is a lot happening under the hood, which makes the process of writing Surface Shaders so efficient. We can see this code in the included <kbd class="calibre13">CgInclude</kbd> files found in the directory that you installed Unity in at <kbd class="calibre13">Editor </kbd>| <kbd class="calibre13">Data </kbd>| <kbd class="calibre13">CGIncludes</kbd>. All the files contained within this folder do their part to render our objects with our shaders on the screen. Some of these files take care of shadows and lighting, some take care of helper functions, and some manage platform dependencies. Without them, our shader-writing experience would be much more laborious.</p>
<p class="calibre3">You can find a list of the information that Unity has provided us with at the following link:<br class="calibre7"/>
<a href="http://docs.unity3d.com/Documentation/Components/SL-BuiltinIncludes.html" class="calibre10">http://docs.unity3d.com/Documentation/Components/SL-BuiltinIncludes.html</a>.</p>
<p class="calibre3">Let's begin the process of understanding these built-in <kbd class="calibre13">CgInclude</kbd> files, using some of the built-in helper functions from the <kbd class="calibre13">UnityCG.cginc</kbd> file:</p>
<div><img src="img/00216.jpeg" class="calibre148"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Before we start diving into the meat of writing the shader, we need to get a few items set up in our scene. Let's do the following and then open the shader in your IDE of choice:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new scene and fill it with a simple sphere model.</li>
<li value="2" class="calibre12">Create a new shader (<kbd class="calibre13">Desaturate</kbd>) and material (<kbd class="calibre13">DesaturateMat</kbd>).</li>
<li value="3" class="calibre12">Attach the new shader to the new material and assign the material to the sphere.</li>
<li value="4" class="calibre12">Create a directional light and position it above your sphere.</li>
<li value="5" class="calibre12">Finally, open the <kbd class="calibre13">UnityCG.cginc</kbd> file from Unity's <kbd class="calibre13">CgInclude</kbd> folder located in Unity's install directory. This will let us analyze some of the helper functions' code so that we can understand what is happening when we use them.</li>
<li value="6" class="calibre12">You should now have a simple scene set up to work on the shader. Refer to the following screenshot, which is an example:</li>
</ol>
<div><img src="img/00217.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">With the scene prepared, we can now begin the process of experimenting with some of the built-in helper functions included with the <kbd class="calibre13">UnityCG.cginc</kbd> file. Double-click on the shader that was created for this scene in order to open it in your IDE of choice and insert the code given in the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Add the following code to the <kbd class="calibre13">Properties</kbd> block of the new shader file. We will need a single texture and slide for our example shader:</li>
</ol>
<pre class="calibre62">Properties 
{ 
    _MainTex ("Base (RGB)", 2D) = "white" {} 
    _DesatValue ("Desaturate", Range(0,1)) = 0.5 
} </pre>
<p class="calibre26">We then need to make sure that we create the data connection between our <kbd class="calibre13">Properties</kbd> and <kbd class="calibre13">CGPROGRAM</kbd> blocks.</p>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Use the following code, placed after the <kbd class="calibre13">CGPROGRAM</kbd> declaration and <kbd class="calibre13">#pragma</kbd> directives, removing the other default properties:</li>
</ol>
<pre class="calibre62">sampler2D _MainTex; 
<strong class="calibre1">fixed _DesatValue;</strong> </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Next, we just have to update our <kbd class="calibre13">surf()</kbd> function to include the following code. We introduce a new function that we haven't seen yet, which is built into Unity's <kbd class="calibre13">UnityCG.cginc</kbd> file:</li>
</ol>
<pre class="calibre62">void surf (Input IN, inout SurfaceOutputStandard o) <br class="title-page-name"/>{ <br class="title-page-name"/>  half4 c = tex2D (_MainTex, IN.uv_MainTex); <br class="title-page-name"/>  c.rgb = lerp(c.rgb, Luminance(c.rgb), _DesatValue); <br class="title-page-name"/> <br class="title-page-name"/>  o.Albedo = c.rgb; <br class="title-page-name"/>  o.Alpha = c.a; <br class="title-page-name"/>} </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Save your script and return to the Unity editor. From there, you should be able to assign a material to the <kbd class="calibre13">DesaturateMat</kbd> (I used the <kbd class="calibre13">TerrainBlend</kbd> texture from the <kbd class="calibre13">Chapter 3 </kbd>| <kbd class="calibre13">Textures</kbd> folder):</li>
</ol>
<div><img src="img/00218.jpeg" class="calibre149"/></div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">With the shader code modified, you should see something similar to the preceding screenshot. We have simply used a helper function, built into Unity's <kbd class="calibre13">CgInclude</kbd> file, to give us an effect of desaturating the main texture of our shader. Notice that if we change the value to <kbd class="calibre13">1</kbd>, all of the color leaves, giving us a grayscale effect:</li>
</ol>
<div><img src="img/00219.jpeg" class="calibre150"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">Using the built-in helper function named <kbd class="calibre13">Luminance()</kbd>, we are able to quickly get a desaturation or grayscale effect on our shaders. This is all possible because of the <kbd class="calibre13">UnityCG.cginc</kbd> file is brought automatically to our shader as we are using a Surface Shader.</p>
<p class="calibre3">If you search through the <kbd class="calibre13">UnityCG.cginc</kbd> file when opened in a script editor, you will find the implementation of this function at line <em class="calibre14">473</em>. The following snippet is taken from the file:</p>
<pre class="calibre19">// Converts color to luminance (grayscale)<br class="title-page-name"/>inline half Luminance(half3 rgb)<br class="title-page-name"/>{<br class="title-page-name"/>    return dot(rgb, unity_ColorSpaceLuminance.rgb);<br class="title-page-name"/>}</pre>
<p class="calibre3">As this function is included in the file and Unity automatically compiles with this file, we can use the function in our code as well, thereby reducing the amount of code that we have to write over and over again.</p>
<p class="calibre3">Notice there is also a <kbd class="calibre13">Lighting.cginc</kbd> file, which Unity comes with. This file houses all the lighting models that we use when we declare something like <kbd class="calibre13">#pragma Surface surf Lambert</kbd>. Sifting through this file reveals that all the built-in lighting models are defined here for reuse and modularity.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">You'll notice that the <kbd class="calibre13">Luminance</kbd> function we are using will return the dot product between the color passed in and a property called <kbd class="calibre13">unity_ColorSpaceLuminance</kbd>. To see what that is, you can use Find menu in your text editor (<em class="calibre14">Ctrl </em>+ <em class="calibre14">F</em>) and type it in. After searching for it, you should be able to see the following on line <em class="calibre14">28</em>:</p>
<pre class="calibre19">#ifdef UNITY_COLORSPACE_GAMMA<br class="title-page-name"/>#define unity_ColorSpaceGrey fixed4(0.5, 0.5, 0.5, 0.5)<br class="title-page-name"/>#define unity_ColorSpaceDouble fixed4(2.0, 2.0, 2.0, 2.0)<br class="title-page-name"/>#define unity_ColorSpaceDielectricSpec half4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301)<br class="title-page-name"/><strong class="calibre1">#define unity_ColorSpaceLuminance half4(0.22, 0.707, 0.071, 0.0) // Legacy: alpha is set to 0.0 to specify gamma mode</strong><br class="title-page-name"/>#else // Linear values<br class="title-page-name"/>#define unity_ColorSpaceGrey fixed4(0.214041144, 0.214041144, 0.214041144, 0.5)<br class="title-page-name"/>#define unity_ColorSpaceDouble fixed4(4.59479380, 4.59479380, 4.59479380, 2.0)<br class="title-page-name"/>#define unity_ColorSpaceDielectricSpec half4(0.04, 0.04, 0.04, 1.0 - 0.04) // standard dielectric reflectivity coef at incident angle (= 4%)<br class="title-page-name"/><strong class="calibre1">#define unity_ColorSpaceLuminance half4(0.0396819152, 0.458021790, 0.00609653955, 1.0) // Legacy: alpha is set to 1.0 to specify linear mode</strong><br class="title-page-name"/>#endif</pre>
<p class="calibre3">This means that, depending on the color space being used, the values given will change. By default, Unity uses a Gamma color space as only certain platforms support linear. To check what color space you are using in your project, you can go to Edit | Project Settings| Player | Other Settings and look at the Color Space property.</p>
<p>For more information on color spaces check out: <a href="http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ" class="calibre31">http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Making your shader world in a modular way with CgInclude</h1>
                
            
            
                
<p class="calibre3">Knowing about the built-in <kbd class="calibre13">CgInclude</kbd> files is great, but what if we want to build our own <kbd class="calibre13">CgInclude</kbd> files to store our own lighting models and helper functions? We can, in fact, create our own <kbd class="calibre13">CgInclude</kbd> files, but we need to learn a little more code syntax before we can start using them efficiently in our shader-writing pipelines. Let's take a look at the process of creating a new <kbd class="calibre13">CgInclude</kbd> file from scratch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Let's walk through the process of generating a new item for this recipe:</p>
<ol class="calibre15">
<li value="1" class="calibre12">From the Project tab, right-click on the <kbd class="calibre13">Assets</kbd> folder and select Show in Explorer. You should see your project folder. Then create a text file by right-clicking and selecting New | Text Document:</li>
</ol>
<div><img src="img/00220.jpeg" class="calibre25"/></div>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Rename the file to <kbd class="calibre13">MyCGInclude</kbd> and replace the <kbd class="calibre13">.txt</kbd> file extension with <kbd class="calibre13">.cginc</kbd>: </li>
</ol>
<div><img src="img/00221.jpeg" class="calibre25"/></div>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Windows will give you a warning message saying that the File may become unusable, but it will still work.</li>
<li value="4" class="calibre12">Import this new <kbd class="calibre13">.cginc</kbd> file into your Unity project and let it compile. If all goes well, you will see that Unity knew to compile it into a <kbd class="calibre13">CgInclude</kbd> file.</li>
</ol>
<p class="calibre3">We are now ready to begin creating our own custom <kbd class="calibre13">CgInclude</kbd> code. Simply double-click on the <kbd class="calibre13">CgInclude</kbd> file that you created in order to open it in your IDE of choice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">With our <kbd class="calibre13">CgInclude</kbd> file open, we can begin to enter the code that will get it working with our Surface Shaders. The following steps will get our <kbd class="calibre13">CgInclude</kbd> file ready for use within our Surface Shaders and allow us to continually add more code to it as we develop more shaders:</p>
<ol class="calibre15">
<li value="1" class="calibre12">We begin our <kbd class="calibre13">CgInclude</kbd> file with what is called a preprocessor directive. These are statements such as <kbd class="calibre13">#pragma</kbd> and <kbd class="calibre13">#include</kbd>. In this case, we want to define a new set of code that will be executed if our shader includes this file in its compiler directives. Enter the following code at the top of your <kbd class="calibre13">CgInclude</kbd> file:</li>
</ol>
<pre class="calibre62">#ifndef MY_CG_INCLUDE 
#define MY_CG_INCLUDE </pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">We always need to make sure that we close <kbd class="calibre13">#ifndef</kbd> or <kbd class="calibre13">#ifdef</kbd> with <kbd class="calibre13">#endif</kbd> to close the definition check, just like an <kbd class="calibre13">if</kbd> statement needs to be closed with two brackets in C#. Enter the following code just after the <kbd class="calibre13">#define</kbd> directive:</li>
</ol>
<pre class="calibre62">#endif </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">At this point, we just need to implement the contents of the <kbd class="calibre13">CgInclude</kbd> file. So, we finish off our <kbd class="calibre13">CgInclude</kbd> file by entering the following code after the <kbd class="calibre13">#define</kbd> and before the <kbd class="calibre13">#endif</kbd>:</li>
</ol>
<pre class="calibre62"><strong class="calibre1">fixed4 _MyColor; 
 
inline fixed4 LightingHalfLambert(SurfaceOutput s, fixed3 lightDir, fixed atten) 
{ 
    fixed diff = max(0, dot(s.Normal, lightDir)); 
    diff = (diff + 0.5)*0.5; 
 
    fixed4 c; 
    c.rgb = s.Albedo * _LightColor0.rgb * ((diff * _MyColor.rgb) * atten); 
    c.a = s.Alpha; 
    return c; 
}</strong> 
#endif </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">With this completed, you now have your very first <kbd class="calibre13">CgInclude</kbd> file. With just this little bit of code, we can greatly reduce the amount of code that we have to rewrite, and we can begin to store the lighting models that we use all the time here so that we never lose them. Your <kbd class="calibre13">CgInclude</kbd> file should look similar to the following code:</li>
</ol>
<pre class="calibre62">#ifndef MY_CG_INCLUDE 
#define MY_CG_INCLUDE 
 
fixed4 _MyColor; 
 
inline fixed4 LightingHalfLambert(SurfaceOutput s, fixed3 lightDir, fixed atten) 
{ 
    fixed diff = max(0, dot(s.Normal, lightDir)); 
    diff = (diff + 0.5)*0.5; 
 
    fixed4 c; 
    c.rgb = s.Albedo * _LightColor0.rgb * ((diff * _MyColor.rgb) * atten); 
    c.a = s.Alpha; 
    return c; 
} 
#endif </pre>
<p class="calibre3">There are a couple more steps that we need to complete before we can fully utilize this <kbd class="calibre13">CgInclude</kbd> file. We simply need to tell the current shader that we are working with to use this file and its code. To complete the process of creating and using <kbd class="calibre13">CgInclude</kbd> files, let's complete the next set of steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">We have to have our <kbd class="calibre13">CgInclude</kbd> file in the same directory as our shader, so drag and drop it into the <kbd class="calibre13">Chapter 11 </kbd>| <kbd class="calibre13">Shaders</kbd> folder from the Project tab.</li>
</ol>
<p>If <em class="calibre21">step 1</em> is not completed, you will get a compilation error.</p>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Now that we are in the folder, select the <kbd class="calibre13">Desaturate</kbd> shader created in the previous recipe and duplicate it (<em class="calibre2">Ctrl </em>+ <em class="calibre2">D</em>). Name the duplicate <kbd class="calibre13">Colorize</kbd>, and double-click on it to open it up.</li>
</ol>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">From there, update the shader name:</li>
</ol>
<pre class="calibre18">Shader "CookbookShaders/Chapter11/<strong class="calibre1">Colorize</strong>" </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">If you turn your attention to our shader, you will see that we need to tell our <kbd class="calibre13">CGPROGRAM</kbd> block to include our new <kbd class="calibre13">CgInclude</kbd> file, so that we can access the code it contains. Modify the directives of our <kbd class="calibre13">CGPROGRAM</kbd> block to include the following code:</li>
</ol>
<pre class="calibre18">CGPROGRAM<br class="title-page-name"/><strong class="calibre1">#include "MyCGInclude.cginc"</strong> <br class="title-page-name"/>// Physically based Standard lighting model, and enable shadows on all light types<br class="title-page-name"/>#pragma surface surf Standard fullforwardshadows</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Our current shader is currently using the built-in Standard lighting model, but we want to use the Half Lambert lighting model that we created in our <kbd class="calibre13">CgInclude</kbd>. As we have included the code from our <kbd class="calibre13">CgInclude</kbd> file, we can use the Half Lambert lighting model with the following code:</li>
</ol>
<pre class="calibre18">CGPROGRAM 
#include "MyCGInclude.cginc" 
<strong class="calibre1">#pragma surface surf HalfLambert</strong> </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Finally, we have also declared a custom variable in our <kbd class="calibre13">CgInclude</kbd> file to show that we can set up default variables for our shaders to use. To see this in action, enter the following code in the <kbd class="calibre13">Properties</kbd> block of your shader:</li>
</ol>
<pre class="calibre18">Properties 
{ 
    _MainTex ("Base (RGB)", 2D) = "white" {} 
    _DesatValue ("Desaturate", Range(0,1)) = 0.5 
    <strong class="calibre1">_MyColor ("My Color", Color) = (1,1,1,1)</strong> 
} </pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Lastly, we need to update our <kbd class="calibre13">surf</kbd> function header since we use <kbd class="calibre13">SurfaceOutput</kbd> in our <kbd class="calibre13">LightingHalfLambert</kbd> function:</li>
</ol>
<pre class="calibre18"> void surf (Input IN, inout<strong class="calibre1"> SurfaceOutput</strong> o) </pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">Back in Unity, create a new material that will use the newly created <kbd class="calibre13">Colorize</kbd> shader (<kbd class="calibre13">ColorizeMat</kbd>) and assign it to the sphere we created in the last recipe. Assign the material as normal and modify the MyColor value from the Inspector to see how it modifies the object. The following screenshot shows the result of using our <kbd class="calibre13">CgInclude</kbd> file:</li>
</ol>
<div><img src="img/00222.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">When using shaders, we can include other sets of code using the <kbd class="calibre13">#include</kbd> preprocessor directive. This tells Unity that we want to let the current shader use the code from within the included file in the shader; this is the reason why these files are called <kbd class="calibre13">CgInclude</kbd> files. We are including snippets of Cg code using the <kbd class="calibre13">#include</kbd> directive.</p>
<p class="calibre3">Once we have declared the <kbd class="calibre13">#include</kbd> directive and Unity is able to find the file in the project, Unity will then look for code snippets that have been defined. This is where we start to use the <kbd class="calibre13">#ifndef</kbd> and <kbd class="calibre13">#endif</kbd> directives. When we declare the <kbd class="calibre13">#ifndef</kbd> directive, we are simply saying "if not defined, define something with a name." In this recipe's case, we said we wanted to <kbd class="calibre13">#define MY_CG_INCLUDE</kbd>. So, if Unity doesn't find a definition called <kbd class="calibre13">MY_CG_INCLUDE</kbd>, it goes and creates it when the <kbd class="calibre13">CgInclude</kbd> file is compiled, thereby giving us access to the code that follows. The <kbd class="calibre13">#endif</kbd> method simply says that this is the end of this definition, so stop looking for more code.</p>
<p class="calibre3">You can now see how powerful this is we can now store all of our lighting models and custom variables in one file and greatly reduce the amount of code that we have to write. The real power is when you can begin to give your shaders flexibility by defining multiple states of functions in the <kbd class="calibre13">CgInclude</kbd> files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing a Fur Shader</h1>
                
            
            
                
<p class="calibre3">The look of a material depends on its physical structure. The shaders attempt to simulate them, but, in doing so, they oversimplify the way light behaves. Materials with a complex macroscopic structure are particularly hard to render. This is the case for many fabrics and animal furs. This recipe will show you how it is possible to simulate fur and other materials (such as grass) that are more than just a flat surface. In order to do this, the same material is drawn multiple times over and over, increasing in size every time. This creates the illusion of fur.</p>
<p class="calibre3">The shader presented here is based on the work of Jonathan Czeck and Aras Pranckevičius:</p>
<div><img src="img/00223.jpeg" class="calibre151"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">In order for this recipe to work, you will need a texture that shows how you wish to have your fur displayed: </p>
<div><img src="img/00224.jpeg" class="calibre152"/></div>
<p class="calibre3">I have provided two examples in <kbd class="calibre13">Chapter 11 </kbd>| <kbd class="calibre13">Textures</kbd> folder with the book's example code (<kbd class="calibre13">Faux Fur</kbd> and <kbd class="calibre13">panda</kbd>).</p>
<p class="calibre3">Like all the other shaders before, you will need to create a new Standard Surface Shader (<kbd class="calibre13">Fur</kbd>) and a material (<kbd class="calibre13">FurMat</kbd>) to host it, and attach it to a sphere for demonstration purposes:</p>
<div><img src="img/00225.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">In this recipe, we can start modifying a Standard Surface Shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Double-click on the <kbd class="calibre13">Fur</kbd> Shader to open it up in your IDE of choice. Once opened, add the following bolded <kbd class="calibre13">Properties</kbd>:</li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _Color ("Color", Color) = (1,1,1,1)<br class="title-page-name"/>  _MainTex ("Albedo (RGB)", 2D) = "white" {}<br class="title-page-name"/>  _Glossiness ("Smoothness", Range(0,1)) = 0.5<br class="title-page-name"/>  _Metallic ("Metallic", Range(0,1)) = 0.0<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  _FurLength ("Fur Length", Range (.0002, 1)) = .25</strong><br class="title-page-name"/><strong class="calibre1">  _Cutoff ("Alpha Cutoff", Range(0,1)) = 0.5 // how "thick"</strong><br class="title-page-name"/><strong class="calibre1">  _CutoffEnd ("Alpha Cutoff end", Range(0,1)) = 0.5 // how thick they are at the end</strong><br class="title-page-name"/><strong class="calibre1">  _EdgeFade ("Edge Fade", Range(0,1)) = 0.4</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  _Gravity ("Gravity Direction", Vector) = (0,0,1,0)</strong><br class="title-page-name"/><strong class="calibre1">  _GravityStrength ("Gravity Strength", Range(0,1)) = 0.25</strong><br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">This shader requires you to repeat the same pass several times. We will use the technique introduced in the <em class="calibre2">Making your shader world modular with CgIncludes </em>recipe to group all the code necessary from a single pass in an external file. Let's start creating a new <kbd class="calibre13">CgInclude</kbd> file called <kbd class="calibre13">FurPass.cginc</kbd> with the following code:</li>
</ol>
<pre class="calibre18">#pragma target 3.0<br class="title-page-name"/><br class="title-page-name"/>fixed4 _Color;<br class="title-page-name"/>sampler2D _MainTex;<br class="title-page-name"/>half _Glossiness;<br class="title-page-name"/>half _Metallic;<br class="title-page-name"/><br class="title-page-name"/>uniform float _FurLength;<br class="title-page-name"/>uniform float _Cutoff;<br class="title-page-name"/>uniform float _CutoffEnd;<br class="title-page-name"/>uniform float _EdgeFade;<br class="title-page-name"/><br class="title-page-name"/>uniform fixed3 _Gravity;<br class="title-page-name"/>uniform fixed _GravityStrength;<br class="title-page-name"/><br class="title-page-name"/>void vert (inout appdata_full v)<br class="title-page-name"/>{<br class="title-page-name"/>  fixed3 direction = lerp(v.normal, _Gravity * _GravityStrength + v.normal * (1-_GravityStrength), FUR_MULTIPLIER);<br class="title-page-name"/>  v.vertex.xyz += direction * _FurLength * FUR_MULTIPLIER * v.color.a;<br class="title-page-name"/>  //v.vertex.xyz += v.normal * _FurLength * FUR_MULTIPLIER * v.color.a;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>struct Input {<br class="title-page-name"/>  float2 uv_MainTex;<br class="title-page-name"/>  float3 viewDir;<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>  fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;<br class="title-page-name"/>  o.Albedo = c.rgb;<br class="title-page-name"/>  o.Metallic = _Metallic;<br class="title-page-name"/>  o.Smoothness = _Glossiness;<br class="title-page-name"/><br class="title-page-name"/>  //o.Alpha = step(_Cutoff, c.a);<br class="title-page-name"/>  o.Alpha = step(lerp(_Cutoff,_CutoffEnd,FUR_MULTIPLIER), c.a);<br class="title-page-name"/><br class="title-page-name"/>  float alpha = 1 - (FUR_MULTIPLIER * FUR_MULTIPLIER);<br class="title-page-name"/>  alpha += dot(IN.viewDir, o.Normal) - _EdgeFade;<br class="title-page-name"/><br class="title-page-name"/>  o.Alpha *= alpha;<br class="title-page-name"/>}</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Got back to your original shader and add this extra pass after the <kbd class="calibre13">ENDCG</kbd> section:</li>
</ol>
<pre class="calibre18">void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>  // Albedo comes from a texture tinted by color<br class="title-page-name"/>  fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;<br class="title-page-name"/>  o.Albedo = c.rgb;<br class="title-page-name"/>  // Metallic and smoothness come from slider variables<br class="title-page-name"/>  o.Metallic = _Metallic;<br class="title-page-name"/>  o.Smoothness = _Glossiness;<br class="title-page-name"/>  o.Alpha = c.a;<br class="title-page-name"/>}<br class="title-page-name"/>ENDCG<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">CGPROGRAM</strong><br class="title-page-name"/><strong class="calibre1">#pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert</strong><br class="title-page-name"/><strong class="calibre1">#define FUR_MULTIPLIER 0.05</strong><br class="title-page-name"/><strong class="calibre1">#include "FurPass.cginc"</strong><br class="title-page-name"/><strong class="calibre1">ENDCG</strong></pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Go back into Unity and assign the <kbd class="calibre13">FauxFur</kbd> texture in the Albedo (RGB) property. You should notice little dots along the shader:</li>
</ol>
<div><img src="img/00226.jpeg" class="calibre25"/></div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Add more passes, progressively increasing <kbd class="calibre13">FUR_MULTIPLIER</kbd>. You can get decent results with 20 passes, from <kbd class="calibre13">0.05</kbd> to <kbd class="calibre13">0.95</kbd>:</li>
</ol>
<pre class="calibre18">    CGPROGRAM<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert<br class="title-page-name"/>    #define FUR_MULTIPLIER 0.05<br class="title-page-name"/>    #include "FurPass.cginc"<br class="title-page-name"/>    ENDCG<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert<br class="title-page-name"/>    #define FUR_MULTIPLIER 0.1<br class="title-page-name"/>    #include "FurPass.cginc"<br class="title-page-name"/>    ENDCG<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert<br class="title-page-name"/>    #define FUR_MULTIPLIER 0.15<br class="title-page-name"/>    #include "FurPass.cginc"<br class="title-page-name"/>    ENDCG<br class="title-page-name"/><br class="title-page-name"/>    // ... 0.2 - 0.85 here<br class="title-page-name"/><br class="title-page-name"/>        CGPROGRAM<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert<br class="title-page-name"/>    #define FUR_MULTIPLIER 0.90<br class="title-page-name"/>    #include "FurPass.cginc"<br class="title-page-name"/>    ENDCG<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert<br class="title-page-name"/>    #define FUR_MULTIPLIER 0.95<br class="title-page-name"/>    #include "FurPass.cginc"<br class="title-page-name"/>    ENDCG<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  Fallback "Diffuse"<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Once the shader has been compiled and attached to a material, you can change its appearance from the Inspector.</li>
</ol>
<p class="calibre3">The <kbd class="calibre13">Fur Length</kbd> property determines the space between the fur shells, which will alter the length of the fur. Longer fur might require more passes to look realistic.</p>
<p class="calibre3"><kbd class="calibre13">Alpha Cutoff</kbd> and <kbd class="calibre13">Alpha Cutoff End</kbd> are used to control the density of the fur and how it gets progressively thinner.</p>
<p class="calibre3"><kbd class="calibre13">Edge Fade</kbd> determines the final transparency of the fur and how fuzzy it looks. Softer materials should have a high <kbd class="calibre13">Edge Fade</kbd>.</p>
<p class="calibre3">Finally, <kbd class="calibre13">Gravity Direction</kbd> and <kbd class="calibre13">Gravity Strength</kbd> curve the fur shells to simulate the effect of gravity:</p>
<div><img src="img/00227.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">The technique presented in this recipe is known as Lengyel's concentric fur-shell technique or simply the shell technique. It works by creating progressively bigger copies of the geometry that needs to be rendered. With the right transparency, it gives the illusion of a continuous thread of hair:</p>
<div><img src="img/00228.jpeg" class="calibre153"/></div>
<p class="calibre3">The shell technique is extremely versatile and relatively easy to implement. Realistic fur requires not only extruding the geometry of the model but also altering its vertices. This is possible with tessellation shaders, which are much more advanced and not covered in this book.</p>
<p class="calibre3">Each pass in this <kbd class="calibre13">Fur</kbd> Shader is contained in <kbd class="calibre13">FurPass.cginc</kbd>. The vertex function creates a slightly bigger version of the model, which is based on the principle of normal extrusion. Additionally, the effect of gravity is taken into account, so that it gets more intense the further we are from the center:</p>
<pre class="calibre19">void vert (inout appdata_full v) 
{ 
    fixed3 direction = lerp(v.normal, _Gravity * _GravityStrength + v.normal * (1-_GravityStrength), FUR_MULTIPLIER); 
    v.vertex.xyz += direction * _FurLength * FUR_MULTIPLIER * v.color.a; 
} </pre>
<p class="calibre3">In this example, the alpha channel is used to determine the final length of the <kbd class="calibre13">Fur</kbd>. This allows for more precise control.</p>
<p class="calibre3">Finally, the surface function reads the control mask from the alpha channel. It uses the cutoff value to determine which pixels to show and which ones to hide. This value changes from the first to the final fur shell to match <kbd class="calibre13">Alpha Cutoff</kbd> and <kbd class="calibre13">Alpha Cutoff End</kbd>:</p>
<pre class="calibre19">o.Alpha = step(lerp(_Cutoff,_CutoffEnd,FUR_MULTIPLIER), c.a); 
 
float alpha = 1 - (FUR_MULTIPLIER * FUR_MULTIPLIER); 
alpha += dot(IN.viewDir, o.Normal) - _EdgeFade; 
 
o.Alpha *= alpha; </pre>
<p class="calibre3">The final alpha value of the fur also depends on its angle from the camera, giving it a softer look.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">The <kbd class="calibre13">Fur</kbd> shader has been used to simulate fur. However, it can be used for a variety of other materials. It works very well for materials that are naturally made of multiple layers, such as forest canopies, fuzzy clouds, human hair, and even grass. </p>
<p class="calibre3">Some additional examples of the same shader being used by just tweaking the parameters can be seen in the book's example code:</p>
<div><img src="img/00229.jpeg" class="calibre25"/></div>
<p class="calibre3">There are many other improvements that can dramatically increase its realism. You can add a very simple wind animation by changing the direction of the gravity based on the current time. If calibrated correctly, this can give the impression that the fur is moving because of the wind.</p>
<p class="calibre3">Additionally, you can make your fur move when the character is moving. All these little tweaks contribute to the believability of your fur, giving the illusion that it is not just a static material drawn on the surface. Unfortunately, this shader comes at a price: 20 passes are very heavy to compute. The number of passes determines roughly how believable the material is. You should play with fur length and passes in order to get the effect that works best for you. Given the performance impact of this shader, it is advisable to have several materials with different numbers of passes; you can use them at different distances and save a lot of computation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing Heatmaps with arrays</h1>
                
            
            
                
<p class="calibre3">One characteristic that makes shaders hard to master is the lack of proper documentation. Most developers learn shaders by messing around with the code, without having a deep knowledge of what's going on. The problem is amplified by the fact that Cg/HLSL makes a lot of assumptions, some of which are not properly advertised. Unity3D allows C# scripts to communicate with shaders using methods such as <kbd class="calibre13">SetFloat</kbd>, <kbd class="calibre13">SetInt</kbd>, <kbd class="calibre13">SetVector</kbd>, and so on. Unfortunately, Unity3D doesn't have a <kbd class="calibre13">SetArray</kbd> method, which leads many developers to believe that <kbd class="calibre13">Cg/HLSL</kbd> doesn't support arrays either. This is not true. This post will show you how it's possible to pass arrays to shaders. Just remember that GPUs are highly optimized for parallel computations, and using for loops in a shader will dramatically decrease its performance.</p>
<p class="calibre3">For this recipe, we will implement a heatmap, as shown in the following screenshot:</p>
<div><img src="img/00230.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">The effect in this recipe creates a heatmap from a set of points. This heatmap can be overlaid on top of another picture, like in the preceding screenshot. The following steps are necessary:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a quad with the texture that you want to use for the <kbd class="calibre13">Heatmap</kbd> (<kbd class="calibre13">GameObject</kbd> | <kbd class="calibre13">3D Object</kbd> | <kbd class="calibre13">Quad</kbd>). In this example, a map of London has been used. In order to put the texture on the quad, create a new material (<kbd class="calibre13">Map</kbd>) using the Unlit/Texture shader, and assign the image to the Base (RGB) property. Once created, drag and drop that object onto the quad. The position of quad object must be set to (0, 0, 0).</li>
<li value="2" class="calibre12">Create another quad and place it on top of the previous one. Our <kbd class="calibre13">Heatmap</kbd> will appear on this quad.</li>
<li value="3" class="calibre12">Attach a new shader (<kbd class="calibre13">Heatmap</kbd>) and material (<kbd class="calibre13">HeatmapMat</kbd>) to the second quad:</li>
</ol>
<div><img src="img/00231.jpeg" class="calibre25"/></div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">For ease of visualization, I also selected the MainCamera and changed the Projection to <kbd class="calibre13">Orthographic</kbd> and the Size property to <kbd class="calibre13">0.5</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">This shader is quite different from the ones created before, yet it is relatively short. For this reason, the entire code is provided in the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Copy this code to the newly created shader:</li>
</ol>
<pre class="calibre18">shader " Heatmap" { 
    Properties { 
        _HeatTex ("Texture", 2D) = "white" {} 
    } 
    Subshader { 
        Tags {"Queue"="Transparent"} 
        Blend SrcAlpha OneMinusSrcAlpha // Alpha blend 
 
        Pass { 
            CGPROGRAM 
            #pragma vertex vert              
            #pragma fragment frag 
 
            struct vertInput { 
                float4 pos : POSITION; 
            };   
 
            struct vertOutput { 
                float4 pos : POSITION; 
                fixed3 worldPos : TEXCOORD1; 
            }; 
 
            vertOutput vert(vertInput input) { 
                vertOutput o; 
                o.pos = mul(UNITY_MATRIX_MVP, input.pos); 
                o.worldPos = mul(_Object2World, input.pos).xyz; 
                return o; 
            } 
 
            uniform int _Points_Length = 0; 
            uniform float3 _Points [20];        // (x, y, z) = position<br class="title-page-name"/>            uniform float2 _Properties [20];    // x = radius, y = intensity 
             
            sampler2D _HeatTex; 
 
            half4 frag(vertOutput output) : COLOR { 
                // Loops over all the points 
                half h = 0; 
                for (int i = 0; i &lt; _Points_Length; i ++) 
                { 
                    // Calculates the contribution of each point 
                    half di = distance(output.worldPos, _Points[i].xyz); 
 
                    half ri = _Properties[i].x; 
                    half hi = 1 - saturate(di / ri); 
 
                    h += hi * _Properties[i].y; 
                } 
 
                // Converts (0-1) according to the heat texture 
                h = saturate(h); 
                half4 color = tex2D(_HeatTex, fixed2(h, 0.5)); 
                return color; 
            } 
            ENDCG 
        } 
    }  
    Fallback "Diffuse" 
} </pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Once you have attached this script to your material, you should provide a ramp texture for the heatmap. It's important to configure it so that its Wrap Mode is set to Clamp:</li>
</ol>
<div><img src="img/00232.jpeg" class="calibre154"/></div>
<p>If your heatmap is going to be used as an overlay, then make sure that the ramp texture has an alpha channel and the texture is imported with the Alpha is Transparency option.</p>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Create a new script called <kbd class="calibre13">HeatmapDrawer</kbd> using the following code:</li>
</ol>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class HeatmapDrawer : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/><br class="title-page-name"/>    public Vector4[] positions;<br class="title-page-name"/>    public float[] radiuses;<br class="title-page-name"/>    public float[] intensities;<br class="title-page-name"/>    public Material material;<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        material.SetInt("_Points_Length", positions.Length);<br class="title-page-name"/><br class="title-page-name"/>        material.SetVectorArray("_Points", positions);<br class="title-page-name"/><br class="title-page-name"/>        Vector4[] properties = new Vector4[positions.Length];<br class="title-page-name"/><br class="title-page-name"/>        for (int i = 0; i &lt; positions.Length; i++)<br class="title-page-name"/><br class="title-page-name"/>        {<br class="title-page-name"/>            properties[i] = new Vector2(radiuses[i], intensities[i]);<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        material.SetVectorArray("_Properties", properties);<br class="title-page-name"/>      <br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Attach the script to an object in your scene, preferably to the quad. Then, drag the material created for this effect to the <kbd class="calibre13">Material</kbd> slot of the script. By doing this, the script will be able to access the <kbd class="calibre13">Material</kbd> and initialize it.</li>
</ol>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Lastly, expand the positions, radiuses, and intensities fields of your script and fill them with the values of your heatmap. Positions indicate the points (in world coordinates) of your heatmaps, radii indicate their size, and intensities indicate how strongly they affect the surrounding area:</li>
</ol>
<div><img src="img/00233.jpeg" class="calibre25"/></div>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">If all went well, once you play the game you should notice something similar to the following screenshot:</li>
</ol>
<div><img src="img/00234.jpeg" class="calibre25"/></div>
<p class="calibre3">If you do not see this, make sure that the heatmap is placed in front of the map quad and that both objects are in front of the camera.</p>
<p>If you get a warning saying the number of points has changed, go into your shader, modify the script by adding a space, and then save it again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">This shader relies on things that have not been introduced before in this book; the first one is arrays. Cg allows arrays that can be created with the following syntax:</p>
<pre class="calibre19">uniform float3 _Points [20];     </pre>
<p class="calibre3">Cg doesn't support arrays with an unknown size: you must preallocate all the space that you need beforehand. The preceding line of code creates an array of <kbd class="calibre13">20</kbd> elements.</p>
<p class="calibre3">Unity allows us to set arrays through using a number of methods, including <kbd class="calibre13">SetVectorArray</kbd>, <kbd class="calibre13">SetColorArray</kbd>, <kbd class="calibre13">SetFloatArray</kbd>, and <kbd class="calibre13">GetMatrixArray</kbd>.</p>
<p>The <kbd class="calibre37">SetVectorArray</kbd> function only works with the <kbd class="calibre37">Vector4</kbd> class at present. That will not cause us any issues, though, as you can automatically assign a <kbd class="calibre37">Vector3</kbd> to a <kbd class="calibre37">Vector4</kbd>, and Unity will automatically include a zero in for the last element. Also, it is possible to instead use our <kbd class="calibre37">Start</kbd> code in an <kbd class="calibre37">Update</kbd> loop to be able to see the values change as we're modifying them, but it would be computationally expensive.</p>
<p class="calibre3">In the fragment function of the shader, there is a similar for loop, which, for each pixel of the material, queries all the points to find their contribution to the heatmap:</p>
<pre class="calibre19">half h = 0; 
for (int i = 0; i &lt; _Points_Length; i ++) 
{ 
    // Calculates the contribution of each point 
    half di = distance(output.worldPos, _Points[i].xyz); 
 
    half ri = _Properties[i].x; 
    half hi = 1 - saturate(di / ri); 
 
    h += hi * _Properties[i].y; 
} </pre>
<p class="calibre3">The <kbd class="calibre13">h</kbd> variable stores the heat from all the points, given their radii and intensities. It is then used to look up which color to use from the ramp texture.</p>
<p class="calibre3">The shaders and arrays are a winning combination, especially as very few games are using them at their full potential. However, they introduce a significant bottleneck, as, for each pixel, the shader has to loop through all the points.</p>


            

            
        
    </body></html>