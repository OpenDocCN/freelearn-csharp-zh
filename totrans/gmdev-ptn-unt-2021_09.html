<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Implement a Replay System with the Command Pattern
                </header>
            
            <article>
                
<p>In this chapter, we will use a classic design pattern named Command to implement a replay system for our racing game. Its mechanism will record the player's controller inputs and the corresponding timestamp. This approach will permit us to play back the recorded inputs in the proper order and with the correct timing.</p>
<p class="mce-root">Replay features are often a must-have in racing games. With the Command pattern, we are going to implement this system in a scalable and modular manner. This pattern proposes a mechanism that permits encapsulating information needed to perform an "action" or trigger a state change. It also decouples the requester of an "action" from the object that will perform it. This encapsulation and decoupling permit us to queue action requests so we can execute them at a later time.</p>
<p class="mce-root">All of this might sound very abstract, but once we implement the system's core components, it will be made clear.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding the Command pattern</li>
<li>Designing a replay system</li>
<li>Implementing a replay system</li>
<li>Reviewing alternative solutions </li>
</ul>
<h1 id="uuid-97ef3b88-3b67-4a1d-a45c-579ad6a50b58">Technical requirements</h1>
<p>The following chapter is hands-on, so you will need to have a basic understanding of Unity and C#.</p>
<p>The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07</a>.<a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021"/></p>
<p class="mce-root">Check out the following video to see the code in action: <a href="https://bit.ly/3wAWYpb">https://bit.ly/3wAWYpb</a><a href="https://bit.ly/3wAWYpb">.</a></p>
<h1 id="uuid-0a7471fc-942e-4271-9e9e-89b783f81aed">Understanding the Command pattern</h1>
<p>Imagine a platform game in which you can jump over obstacles when you press the space bar. In this scenario, every time you press that input key, you are asking the character on the screen to change states and perform a jump action. In code, we could implement a simple <kbd>InputHandler</kbd>, which would listen for a space bar input from the player, and when the player hits it, we would call <kbd>CharacterController</kbd> to trigger the jump action. </p>
<p>The following very simplified pseudo-code sums up what we have in mind:</p>
<pre>using UnityEngine;<br/>using System.Collections;<br/><br/>public class InputHandler : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown("space"))<br/>        {<br/>            CharacterController.Jump();<br/>        }<br/>    }<br/>}</pre>
<p><span>As we can see, this approach can get the job done, but if we wanted to record, undo, or replay an input from the player at a later time, it could become complicated. However, the Command pattern permits us to decouple the object that invokes the operation from the one that knows how to execute it. In other words, our <kbd>InputHandler</kbd> doesn't need to know what exact action needs to be taken when the player presses the space bar. It just needs to make sure that the correct </span><em><span>command</span></em><span> is executed and let the Command pattern mechanism do its magic behind the scenes. </span></p>
<p>The following pseudo-code shows the difference in the way <span>we</span> implement <kbd>InputHandler</kbd> when <span>we are</span> using the Command pattern:</p>
<pre>using UnityEngine;<br/>using System.Collections;<br/><br/>public class InputHandler : MonoBehaviour<br/>{<br/>    [SerializedField]<br/>    private Controller _characterController;<br/><br/>    private Command _spaceButton;<br/><br/>    void Start()<br/>    {<br/>        _spaceButton = new JumpCommand();<br/>    }<br/><br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown("space"))<br/>            _spaceButton.Execute(_characterController);<br/>    }<br/>}</pre>
<p>As we can see, <span>we are</span> not just invoking <kbd>CharacterController</kbd> <span>directly </span>when the player presses the space bar. We are actually encapsulating all the information <span>we</span> need to perform the jump action into an object that <span>we</span> could put in a queue and re-invoke at a later time.</p>
<p>Let's review the following diagram, which illustrates an implementation of the Command pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1055bba6-6fa4-4b50-92da-48f9440eb790.png" style="width:61.00em;height:30.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 7.1 – UML diagram of the Command pattern</div>
<p>Trying to learn about the Command pattern by looking at a diagram is not the right approach, but it does help us isolate the fundamental classes that are participating in this pattern:</p>
<ul>
<li><kbd>Invoker</kbd><span> </span>is an object that knows how to execute a command and can also do the bookkeeping of executed commands.</li>
<li><kbd>Receiver</kbd><span> </span>is a type of object that can receive commands and execute them.</li>
<li><span><kbd>CommandBase</kbd> is an abstract class that an individual <kbd>ConcreteCommand</kbd> class must inherit, and it exposes an <kbd>Execute()</kbd> method that <kbd>Invoker</kbd> can call to execute a specific command.</span></li>
</ul>
<p class="mce-root">Each participant in the pattern has a distinct responsibility and a role to play. A solid implementation of the Command pattern should allow us to encapsulate action requests as an object that can be queued and executed immediately or at a later time.</p>
<div class="packt_infobox">The Command pattern is a part of the Behavioral pattern family; its close cousins are Memento, Observer, and Visitor. These types of patterns are often concerned with the assignment of responsibilities and how objects communicate with one another.</div>
<h2 id="uuid-50ba0a08-0000-4634-8d6c-d9518bf84671">Benefits and drawbacks of the Command pattern</h2>
<p>These are some of the benefits of the Command pattern:</p>
<ul>
<li class="mce-root"><strong>Decoupling</strong>:<span> </span>The pattern permits the decoupling of the object that invokes the operation from the one that knows how to execute it. This layer of separation allows the addition of an intermediary that will be able to bookkeep and sequence operations.</li>
<li class="mce-root"><strong>Sequencing</strong>: The Command pattern facilitates the process of queuing user inputs, which permits the implementation of undo/redo features, macros, and command queues.</li>
</ul>
<p>This is a potential drawback of the Command pattern:</p>
<ul>
<li><strong><span>Complexity</span></strong><span>:</span><span> It takes numerous classes to implement this pattern as each command is a class in itself. And it takes a good understanding of the pattern to maintain code built with it. In most cases, this is not an issue, but if you are using the Command pattern without a specific goal in mind, it can become an unnecessary layer of complexity and verbosity in your code base.</span></li>
</ul>
<div class="packt_tip">Benefits and drawbacks are usually contextual; the ones presented in this book are general, and not absolutes. Therefore, it's essential when choosing a pattern to analyze its benefits and drawbacks in the context of your own project, and to not consider or reject one based on general statements.</div>
<h2 id="uuid-8230c44e-a47e-40d0-bb1e-647bc6e1ea2c">When to use the Command pattern</h2>
<p>Here's a shortlist of possible uses for the Command pattern:</p>
<ul>
<li><strong>Undo</strong>: Implementing an undo/redo system that you find in most text and image editors.</li>
<li><strong>Macro</strong>: A macro recording system with which players can record a sequence of attack or defensive combos. Then, assign them on an input key to execute them automatically.</li>
<li><strong>Automation:</strong> Automate processes or behaviors by recording a set of commands that a bot will automatically and sequentially execute.</li>
</ul>
<p>In conclusion, it's a good pattern for features related to storing, timing, and sequencing user inputs. And if you get very creative with it, you could create some compelling game systems and mechanics.</p>
<div class="packt_tip">Design patterns are fun to use if you don't worry too much about staying true to the original academic descriptions. If you don't lose the original intent of the pattern while experimenting with it, you should retain its core benefits.</div>
<h1 id="uuid-9f9cb0cc-bc7c-43e2-9638-6a52386ebd2c">Designing a replay system</h1>
<p class="mce-root">Before describing the replay system design that <span>we</span> will be implementing in this chapter, <span>we</span> have to declare some specifications about our game that can influence the way in which <span>we</span> will implement it. </p>
<p class="mce-root">Specifications to keep in mind are as follows:</p>
<ul>
<li><strong>Deterministic</strong>: Everything in our game is deterministic, which means we don't have any entities with random behaviors, and that makes our replay system simpler to implement because we don't have to worry about recording positions or states of entities that move in our scene like enemy drones. We know they will move and behave the same way during the replay sequence.</li>
<li><strong>Physics</strong>: We are minimizing the use of the physics features of the Unity engine as our entities' movements are not determined by any physical properties or interactions. Therefore, we do not have to worry about unexpected behaviors when objects collide.</li>
<li><strong>Digital</strong>: All our inputs are digital, so we do not bother to capture or handle granular analog input data from a joystick or trigger button.</li>
<li><strong>Precision</strong>: We tolerate a lack of precision in the timing of when we replay inputs. Therefore, we do not expect the inputs to replay precisely within the same timeframe as they were recorded. <em>This tolerance level is subject to change depending on several factors related to the desired level of precision of the replay feature.</em></li>
</ul>
<p>Considering all these specifications, the replay system <span>we are</span> going to implement will only record the player's inputs but not the bike's current position. Because there are no in-between locations that the bike might be at, depending on the player's input, it will be on one rail or the other. Also, another essential detail to note is the fact that the bike does not move forward. It is the track that moves toward the player's position to give the illusion of movement and speed.</p>
<p class="mce-root CDPAlignLeft CDPAlign">In theory, if <span>we</span> record the player's controller inputs from the start and end of a race, then <span>we</span> could simulate a replay of the player's gameplay by replaying the recorded inputs at the beginning of a new race. W<span>e</span> have a diagram that illustrates the mechanism behind the replay system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3a1df14e-86fb-485c-b8de-c79880fb233f.png" style="width:78.00em;height:30.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 7.2 – Diagram of the replay system </div>
<p class="mce-root">As we can see in the diagram, <kbd>InputRecorder</kbd> records and serializes the inputs so that <kbd>ReplaySystem</kbd> can replay them later on. During a replay sequence, <kbd>ReplaySystem</kbd> acts similarly to a bot as it takes control of the bike and automatically maneuvers it by replaying the player's inputs. It is a simple form of automation that gives the illusion that we are watching a replay video.</p>
<p class="mce-root">In the next section, we will implement a simplified version of the system we just reviewed, and we will use the Command pattern as its foundation.</p>
<h1 id="uuid-89026374-57a4-4dd4-a43e-326a3e723fd6">Implementing a replay system</h1>
<div class="packt_infobox"><span>This section includes pseudo-code for the sake of simplicity and readability. If you wish to review a complete implementation in the context of an actual game project, open the </span><kbd>FPP</kbd><span> folder in the GitHub project. T</span><span>he link can be found under the </span><em>Technical requirements</em><span> section.</span></div>
<p>In this section, we are going to build up a simple input replay system prototype using the Command pattern as the foundation.</p>
<h2 id="uuid-dd25197f-7b57-49cf-a309-42de3921b77e">Implementing the replay system</h2>
<p class="mce-root">The implementation will be done in two parts. In the first part, <span>we</span> will code the core components of the Command pattern and then <span>we</span> will integrate the elements that are necessary to test the replay system:</p>
<ol>
<li class="mce-root"><span>To start,</span> <span>we are</span><span> implementing a base abstract class named <kbd>Command</kbd>, which has a singular method named <kbd>Execute()</kbd>:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">public abstract class Command<br/>{<br/>    public abstract void Execute();<br/>}</pre>
<ol start="2">
<li>Now we are going to write three concrete command classes that will derive from the <kbd>Command</kbd> base class, and then we will implement the <span><kbd>Execute()</kbd> method. Each of them encapsulates an action to execute.</span></li>
</ol>
<p style="padding-left: 60px"><span>The first one toggles the turbocharger on <kbd>BikeController</kbd>:</span></p>
<pre style="padding-left: 60px"><span>namespace </span>Chapter<span>.</span>Command<br/><span>{<br/></span><span>    </span><span>public class </span>ToggleTurbo : Command<br/>    <span>{<br/></span><span>        </span><span>private </span>BikeController _controller<span>;<br/></span><span><br/></span><span>        </span><span>public </span>ToggleTurbo<span>(</span>BikeController controller<span>)<br/></span><span>        {<br/></span><span>            </span>_controller <span>= </span>controller<span>;<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>public override void </span>Execute<span>()<br/></span><span>        {<br/></span><span>            </span>_controller<span>.</span>ToggleTurbo<span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<ol start="3">
<li>The following two commands are the <kbd>TurnLeft</kbd> and <kbd>TurnRight</kbd> commands. Each represents a different action and is mapped to a specific input key, as we are going to see when we implement <kbd>InputHandler</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><span>namespace </span><span>Chapter</span><span>.</span><span>Command<br/></span><span>{</span><span><br/></span><span>    </span><span>public class </span><span>TurnLeft </span>: <span>Command<br/></span><span>    </span><span>{<br/></span><span>        </span><span>private </span><span>BikeController </span><span>_controller</span><span>;<br/></span><span><br/></span><span>        </span><span>public </span><span>TurnLeft</span><span>(</span><span>BikeController </span><span>controller)<br/></span><span>        {<br/></span><span>            </span><span>_controller </span><span>= controller;<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>public override void </span><span>Execute</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>_controller</span><span>.</span><span>Turn</span><span>(</span><span>BikeController</span><span>.</span><span>Direction</span><span>.</span><span>Left</span><span>);<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<ol start="4">
<li>The following command represents the right turn action and, as its name implies, this turns the bike to the right:</li>
</ol>
<pre style="padding-left: 60px"><span>namespace </span><span>Chapter</span><span>.</span><span>Command<br/></span><span>{</span><span><br/></span><span>    </span><span>public class </span><span>TurnRight </span>: <span>Command<br/></span><span>    </span><span>{<br/></span><span>        </span><span>private </span><span>BikeController </span><span>_controller</span><span>;<br/></span><span><br/></span><span>        </span><span>public </span><span>TurnRight</span><span>(</span><span>BikeController </span><span>controller)<br/></span><span>        {<br/></span><span>            </span><span>_controller </span><span>= controller;<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>public override void </span><span>Execute</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>_controller</span><span>.</span><span>Turn</span><span>(</span><span>BikeController</span><span>.</span><span>Direction</span><span>.</span><span>Right</span><span>);<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p style="padding-left: 60px">Now that we have completed the encapsulation of each command into individual classes, it is time to code the critical ingredient that will make our replay system work – <kbd>Invoker</kbd>.</p>
<p style="padding-left: 60px" class="mce-root"><kbd>Invoker</kbd> is an attentive bookkeeper; it keeps track of the commands that have been executed in a ledger. We represent this ledger in code in the form of <kbd>SortedList</kbd>, a native C# sorted collection with a key/value structure. This list will keep track of when a specific command was executed.</p>
<ol start="5">
<li>Because this class is very long, we will review it in two segments. The following is the first part:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Linq</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Collections</span><span>.</span><span>Generic</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>Command<br/></span><span>{<br/></span><span>    </span><span>class </span><span>Invoker </span>: <span>MonoBehaviour<br/></span><span>    </span><span>{<br/></span><span>        </span><span>private bool </span><span>_isRecording</span><span>;<br/></span><span>        </span><span>private bool </span><span>_isReplaying</span><span>;<br/></span><span>        </span><span>private float </span><span>_replayTime</span><span>;<br/></span><span>        </span><span>private float </span><span>_recordingTime</span><span>;<br/></span><span>        </span><span>private </span><span>SortedList</span><span>&lt;</span><span>float</span><span>, </span><span>Command</span><span>&gt; </span><span>_recordedCommands </span><span>= <br/></span><span>            </span><span>new </span><span>SortedList&lt;float, Command&gt;</span><span>();<br/><br/>        </span><span>public void </span><span>ExecuteCommand</span><span>(</span><span>Command </span><span>command)<br/></span><span>        {<br/></span><span>            command.</span><span>Execute</span><span>();<br/><br/>            </span><span>if </span><span>(</span><span>_isRecording</span><span>) <br/></span><span>                </span><span>_recordedCommands</span><span>.</span><span>Add</span><span>(</span><span>_recordingTime</span><span>, command);<br/><br/>            </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Recorded Time: " </span><span>+ </span><span>_recordingTime</span><span>);<br/></span><span>            </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Recorded Command: " </span><span>+ command);<br/></span><span>        }<br/><br/>        </span><span>public void </span><span>Record</span><span>()<br/></span><span>        </span><span>{</span><span><br/></span><span>            </span><span>_recordingTime </span><span>= </span><span>0.0f</span><span>;<br/></span><span>            </span><span>_isRecording </span><span>= </span><span>true</span><span>;<br/></span><span>        </span><span>}</span></pre>
<p style="padding-left: 60px">In this part of the <kbd>Invoker</kbd> class, we add a command to the <kbd>_recordedCommands</kbd> sorted list every time <kbd>Invoker</kbd> executes a new one. However, we only do this when we start recording because we want to record the player inputs at specific moments, such as at the start of the race.</p>
<ol start="6">
<li>For the next section of the <kbd>Invoker</kbd> class, we are going to implement the replay behavior:</li>
</ol>
<pre style="padding-left: 60px">        <span>public void </span><span>Replay</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>_replayTime </span><span>= </span><span>0.0f</span><span>;<br/></span><span>            </span><span>_isReplaying </span><span>= </span><span>true</span><span>;<br/><br/>            </span><span>if </span><span>(</span><span>_recordedCommands</span><span>.</span><span>Count </span><span>&lt;= </span><span>0</span><span>)<br/></span><span>                </span><span>Debug</span><span>.</span><span>LogError</span><span>(</span><span>"No commands to replay!"</span><span>);<br/><br/>            </span><span>_recordedCommands</span><span>.</span><span>Reverse</span><span>();<br/></span><span>        }<br/><br/>        </span><span>void </span><span>FixedUpdate</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>if </span><span>(</span><span>_isRecording</span><span>) <br/></span><span>                </span><span>_recordingTime </span><span>+= </span><span>Time</span><span>.</span><span>fixedDeltaTime</span><span>;<br/><br/>            </span><span>if </span><span>(</span><span>_isReplaying</span><span>)<br/></span><span>            {<br/></span><span>                </span><span>_replayTime </span><span>+= </span><span>Time</span><span>.</span><span>deltaTime</span><span>;<br/><br/>                </span><span>if </span><span>(</span><span>_recordedCommands</span><span>.</span><span>Any</span><span>()) <br/></span><span>                {<br/></span><span>                    </span><span>if </span><span>(</span><span>Mathf</span><span>.</span><span>Approximately</span><span>(<br/></span><span>                        </span><span>_replayTime</span><span>, </span><span>_recordedCommands</span><span>.</span><span>Keys</span><span>[</span><span>0</span><span>])) {<br/><br/>                        </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Replay Time: " </span><span>+ </span><span>_replayTime</span><span>);<br/></span><span>                        </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Replay Command: " </span><span>+ <br/></span><span>                                  </span><span>_recordedCommands</span><span>.</span><span>Values</span><span>[</span><span>0</span><span>]);<br/><br/>                        </span><span>_recordedCommands</span><span>.</span><span>Values</span><span>[</span><span>0</span><span>].</span><span>Execute</span><span>();<br/></span><span>                        </span><span>_recordedCommands</span><span>.</span><span>RemoveAt</span><span>(</span><span>0</span><span>);<br/></span><span>                    }<br/></span><span>                }<br/></span><span>                </span><span>else<br/></span><span>                </span><span>{<br/></span><span>                    </span><span>_isReplaying </span><span>= </span><span>false</span><span>;<br/></span><span>                }<br/></span><span>            }<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>As you may have already noticed, we are using <kbd>FixedUpdate()</kbd> to record and replay commands. This might seem strange as we usually use <kbd>Update()</kbd> to listen for player inputs. However, <kbd>FixedUpdate()</kbd> has the advantage of running in fixed time steps and is helpful for time-dependent but frame rate-independent tasks.</p>
<p class="mce-root">Therefore, we know that the default engine time step is 0.02 seconds, and our timestamps will be in similar increments as we use <kbd>Time.fixedDeltaTime</kbd> to record the time of executed commands.</p>
<p class="mce-root">However, this also means that we lose precision during the recording phase, as our timestamp is bound to Unity's time-step settings. This loss of precision is tolerable in the context of this example. However, it could become an issue if there are significant inconsistencies between the game play and replay sequences.</p>
<p class="mce-root">In that case, we might need to consider a solution that includes <kbd>Update()</kbd>, <kbd>Time.deltaTime</kbd>, and a value that will permit us to set the degree of precision when comparing the recording and replay time. However, this is beyond the scope of this chapter.</p>
<p class="mce-root">We should take note that we are giving <kbd>Invoker</kbd> the responsibility of bookkeeping but also replaying. It can be argued that we have broken the single responsibility principle by giving <kbd>Invoker</kbd> too many responsibilities. In this context, this is not an issue; it is just a code example for educational purposes. Still, it would be wise to encapsulate the responsibilities of recording, saving, and replaying commands in a separate class.</p>
<h2 id="uuid-a2cd5ff3-1220-4364-8906-b347428298c0">Testing the replay system</h2>
<p>Now that we have the core ingredients of the Command pattern and our replay system in place, it is time to test whether it works:</p>
<ol>
<li>The first class we will implement is <kbd>InputHandler</kbd>. Its primary responsibility is to listen for the player's inputs and invoke the appropriate commands. However, because of its length, we will review it in two parts:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>Command<br/></span><span>{<br/></span><span>    </span><span>public class </span><span>InputHandler </span>: <span>MonoBehaviour<br/></span><span>    </span><span>{<br/></span><span>        </span><span>private </span><span>Invoker </span><span>_invoker</span><span>;<br/></span><span>        </span><span>private bool </span><span>_isReplaying</span><span>;<br/></span><span>        </span><span>private bool </span><span>_isRecording</span><span>;<br/></span><span>        </span><span>private </span><span>BikeController </span><span>_bikeController</span><span>;<br/></span><span>        </span><span>private </span><span>Command </span><span>_buttonA</span><span>, </span><span>_buttonD</span><span>, </span><span>_buttonW</span><span>;<br/><br/>        </span><span>void </span><span>Start</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>_invoker </span><span>= </span><span>gameObject</span><span>.</span><span>AddComponent</span><span>&lt;</span><span>Invoker</span><span>&gt;();<br/></span><span>            </span><span>_bikeController </span><span>= </span><span>FindObjectOfType</span><span>&lt;</span><span>BikeController</span><span>&gt;();<br/><br/>            </span><span>_buttonA </span><span>= </span><span>new </span><span>TurnLeft</span><span>(</span><span>_bikeController</span><span>);<br/></span><span>            </span><span>_buttonD </span><span>= </span><span>new </span><span>TurnRight</span><span>(</span><span>_bikeController</span><span>);<br/></span><span>            </span><span>_buttonW </span><span>= </span><span>new </span><span>ToggleTurbo</span><span>(</span><span>_bikeController</span><span>);<br/></span><span>        }<br/><br/>        </span><span>void </span><span>Update</span><span>()<br/></span><span>        </span><span>{</span><span><br/></span><span>            </span><span>if </span><span>(</span>!<span>_isReplaying </span><span>&amp;&amp; </span><span>_isRecording</span><span>)<br/></span><span>            {<br/></span><span>                </span><span>if </span><span>(</span><span>Input</span><span>.</span><span>GetKeyUp</span><span>(</span><span>KeyCode</span><span>.</span><span>A</span><span>)) <br/></span><span>                    </span><span>_invoker</span><span>.</span><span>ExecuteCommand</span><span>(</span><span>_buttonA</span><span>);<br/></span><span>                <br/></span><span>                </span><span>if </span><span>(</span><span>Input</span><span>.</span><span>GetKeyUp</span><span>(</span><span>KeyCode</span><span>.</span><span>D</span><span>)) <br/></span><span>                    </span><span>_invoker</span><span>.</span><span>ExecuteCommand</span><span>(</span><span>_buttonD</span><span>);<br/></span><span>                <br/></span><span>                </span><span>if </span><span>(</span><span>Input</span><span>.</span><span>GetKeyUp</span><span>(</span><span>KeyCode</span><span>.</span><span>W</span><span>)) <br/></span><span>                    </span><span>_invoker</span><span>.</span><span>ExecuteCommand</span><span>(</span><span>_buttonW</span><span>);<br/></span><span>            }<br/></span><span>        </span><span>}</span></pre>
<p style="padding-left: 60px" class="mce-root">In this section of the class, we are initializing our commands and mapping them to specific inputs. Notice that we are passing an instance of <kbd>BikeController</kbd> in the command's constructor. <kbd>InputHandler</kbd> is only aware that <kbd>BikeController</kbd> exists, but does not need to know how it functions. It is the responsibility of the individual command classes to call the proper public methods of the bike's controller depending on the desired action. In the <kbd>Update()</kbd> loop, we listen for specific key inputs and call on <kbd>Invoker</kbd> to execute a command associated with a particular input.</p>
<p style="padding-left: 60px" class="mce-root">This segment of code is what makes it possible to record the inputs of the player. We do not call <kbd>BikeController</kbd> directly, and we do not execute the commands. Instead, we allow <kbd>Invoker</kbd> to act like an intermediary and do all the work. This approach permits it to keep records of the player inputs in the background for later use.</p>
<ol start="2">
<li class="mce-root">For the final part of the <kbd>InputHandler</kbd> class, we are adding some GUI debug buttons that will help us test the replay system. This segment of code is for debugging and testing purposes only:</li>
</ol>
<pre style="padding-left: 60px">        <span>void </span><span>OnGUI</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>if </span><span>(</span><span>GUILayout</span><span>.</span><span>Button</span><span>(</span><span>"Start Recording"</span><span>))<br/></span><span>            {<br/></span><span>                </span><span>_bikeController</span><span>.</span><span>ResetPosition</span><span>();<br/></span><span>                </span><span>_isReplaying </span><span>= </span><span>false</span><span>;<br/></span><span>                </span><span>_isRecording </span><span>= </span><span>true</span><span>;<br/></span><span>                </span><span>_invoker</span><span>.</span><span>Record</span><span>();<br/></span><span>            }<br/><br/>            </span><span>if </span><span>(</span><span>GUILayout</span><span>.</span><span>Button</span><span>(</span><span>"Stop Recording"</span><span>))<br/></span><span>            {<br/></span><span>                </span><span>_bikeController</span><span>.</span><span>ResetPosition</span><span>();<br/></span><span>                </span><span>_isRecording </span><span>= </span><span>false</span><span>;<br/></span><span>            }<br/><br/>            </span><span>if </span><span>(</span>!<span>_isRecording</span><span>)<br/></span><span>            {<br/></span><span>                </span><span>if </span><span>(</span><span>GUILayout</span><span>.</span><span>Button</span><span>(</span><span>"Start Replay"</span><span>))<br/></span><span>                {<br/></span><span>                    </span><span>_bikeController</span><span>.</span><span>ResetPosition</span><span>();<br/></span><span>                    </span><span>_isRecording </span><span>= </span><span>false</span><span>;<br/></span><span>                    </span><span>_isReplaying </span><span>= </span><span>true</span><span>;<br/></span><span>                    </span><span>_invoker</span><span>.</span><span>Replay</span><span>();<br/></span><span>                }<br/></span><span>            }<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<ol start="3">
<li>For our final class, we will implement a skeleton version of the <kbd>BikeController</kbd> class for testing purposes. It acts like a receiver in the context of the Command pattern:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span><br/></span><span>public class </span><span>BikeController </span>: <span>MonoBehaviour<br/></span><span>{<br/></span><span>    </span><span>public enum </span><span>Direction<br/></span><span>    </span><span>{<br/></span><span>        </span><span>Left </span><span>= -</span><span>1</span><span>,<br/></span><span>        </span><span>Right </span><span>= </span><span>1<br/></span><span>    </span><span>}<br/><br/>    </span><span>private bool </span><span>_isTurboOn</span><span>;<br/></span><span>    </span><span>private float </span><span>_distance </span><span>= </span><span>1.0f</span><span>;<br/><br/>    </span><span>public void </span><span>ToggleTurbo</span><span>()<br/></span><span>    {<br/></span><span>        </span><span>_isTurboOn </span><span>= </span>!<span>_isTurboOn</span><span>;<br/></span><span>        </span><span>Debug</span><span>.</span><span>Log</span><span>(</span><span>"Turbo Active: " </span><span>+ </span><span>_isTurboOn</span><span>.ToString()</span><span>);<br/></span><span>    }<br/><br/>    </span><span>public void </span><span>Turn</span><span>(</span><span>Direction </span><span>direction)<br/></span><span>    {<br/></span><span>        </span><span>if </span><span>(direction == </span><span>Direction</span><span>.</span><span>Left</span><span>) <br/></span><span>            </span><span>transform</span><span>.</span><span>Translate</span><span>(</span><span>Vector3</span><span>.</span><span>left </span><span>* </span><span>_distance</span><span>);<br/></span><span>        <br/></span><span>        </span><span>if </span><span>(direction == </span><span>Direction</span><span>.</span><span>Right</span><span>)<br/></span><span>            </span><span>transform</span><span>.</span><span>Translate</span><span>(</span><span>Vector3</span><span>.</span><span>right </span><span>* </span><span>_distance</span><span>);<br/></span><span>    }<br/><br/>    </span><span>public void </span><span>ResetPosition</span><span>()<br/></span><span>    {<br/></span><span>        </span><span>transform</span><span>.</span><span>position </span><span>= </span><span>new </span><span>Vector3</span><span>(</span><span>0.0f</span><span>, </span><span>0.0f</span><span>, </span><span>0.0f</span><span>);<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p style="padding-left: 60px">The overall purpose and structure of the class are self-explanatory. <kbd>ToggleTurbo()</kbd> and <kbd>Turn()</kbd> are public methods that get called by the command classes. However, <kbd>ResetPosition()</kbd> is for debugging and testing purposes only and can be ignored.</p>
<p>To test this code in your instance of Unity, you need to complete the following steps:</p>
<ol>
<li>Start a new empty Unity scene that includes at least one light and camera.</li>
<li>Add a 3D GameObject <span>to the new scene</span>, such as a cube, and make it visible from the scene's main camera.</li>
<li>Attach the <kbd>InputHandler</kbd> and <kbd>BikeController</kbd> classes to the new GameObject.</li>
</ol>
<ol start="4">
<li>At runtime, if you have copied all the classes we have just reviewed in your project, you should see the following on your screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6930a7ab-085c-4dc5-8f7a-aced6162fbd0.png" style="width:69.33em;height:43.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 7.3 – Screenshot of the code in action inside Unity </div>
<p>When you start recording, you will be able to move the cube on a horizontal axis. Each input entered can be replayed in the same sequence and timing they were recorded.</p>
<h2 id="uuid-99ce5591-9ad3-45ca-802b-b34f2df809c6">Reviewing the implementation</h2>
<p>We completed the process of building a quick input replay system by using the Command pattern as our foundation. Of course, the code example in this chapter is not production-ready and very limited. Nevertheless, the goal of this chapter was to learn how to use the Command pattern with Unity, and not design an entire replay system.</p>
<p class="mce-root">In the game prototype project in the <kbd>FPP</kbd> folder of the GitHub project, we did implement a more advanced example of a replay system that includes serialization and a rewind feature. We recommend checking it out and, of course, modify it at your discretion.</p>
<p>In the next section, we will review some alternatives solutions and approaches that we could have used to build our replay system.</p>
<h1 id="uuid-0e1b34bd-82a7-48d1-9443-0dd414f7cbcd">Reviewing alternative solutions</h1>
<p>Even if the Command pattern was perfectly suited for our use case, there are some alternative patterns and solutions <span>we</span> could have considered:</p>
<ul>
<li><strong>Memento:</strong> The Memento pattern provides the ability to roll back an object to a previous state. This was not our first choice for our replay system because we are focusing on recording inputs and queuing them for replay at a later time, which is very compatible with the design intention of the Command pattern. However, if we implemented a system with a rollback to the previous state feature, the Memento pattern will probably be our first choice.</li>
<li><strong>Queue/Stack</strong>: Queues and stacks are not patterns, but data structures, but we could simply encode all our inputs and store them in a queue directly in our <kbd>InputHandler</kbd> class. It would have been more straightforward and less verbose than using the Command pattern. The choice between implementing a system with or without conventional design patterns is very contextual. If a system is simple enough, then the added verbosity and complexity that a design pattern might bring might exceed the potential benefits of using it.</li>
</ul>
<h1 id="uuid-aec3d919-1281-4ce5-b243-34bbd5f3a2d0">Summary</h1>
<p class="mce-root">In this chapter, we implemented a simple, but functional, replay system by using the Command pattern. Our goal with this chapter was not to show how to build a robust replay system, but instead showcase how to use the Command pattern to create something in Unity that might be useful for a game project.</p>
<p class="mce-root">I hope you will research alternative ways of implementing the Command pattern that might be better than shown in this book because, like most things in programming, there is no single way of doing things. Nevertheless, at least this chapter offers a first approach to using the Command pattern with Unity.</p>
<p class="mce-root">In the next part of the book, we will start optimizing our code with the Object pool. An essential aspect of a good racing game is consistent performance and frame rate. Everything must run smoothly at every moment, or it might cause our game to feel slow and sluggish.</p>


            </article>

            
        </section>
    </body></html>