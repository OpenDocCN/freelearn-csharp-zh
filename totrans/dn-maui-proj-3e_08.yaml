- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building a Weather App for Multiple Form Factors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多种形态构建天气应用
- en: '.NET MAUI isn’t just for creating apps for phones; it can also be used to create
    apps for tablets and desktop computers. In this chapter, we will build an app
    that will work on all of these platforms and optimize the user interface for each
    form factor. As well as using three different form factors, we are also going
    to be working on four different operating systems: iOS, macOS, Android, and Windows.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 不仅用于创建手机应用；它还可以用于创建平板电脑和桌面电脑的应用。在本章中，我们将构建一个适用于所有这些平台的应用，并为每个形态优化用户界面。除了使用三种不同的形态，我们还将针对四个不同的操作系统进行工作：iOS、macOS、Android
    和 Windows。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using `FlexLayout` in .NET MAUI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中使用 `FlexLayout`
- en: Using `VisualStateManager`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `VisualStateManager`
- en: Using different views for different form factors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同视图针对不同形态
- en: Using behaviors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为
- en: Let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work on this project, we need to have Visual Studio for Mac or PC installed,
    as well as the necessary .NET MAUI components. See *Chapter 1*, *Introduction
    to .NET MAUI*, for more details on how to set up your environment. To build an
    iOS app using Visual Studio for PC, you need to have a Mac connected. If you don’t
    have access to a Mac at all, you can choose to just work on the Windows and Android
    parts of this project. Similarly, if you only have a Mac, you can choose to work
    on only the iOS and Android parts of this project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理此项目，我们需要安装 Visual Studio for Mac 或 PC，以及必要的 .NET MAUI 组件。有关如何设置环境的更多详细信息，请参阅
    *第 1 章*，*.NET MAUI 简介*。如果你使用 Visual Studio for PC 构建 iOS 应用，你需要连接一台 Mac。如果你根本无法访问
    Mac，你可以选择只处理此项目的 Windows 和 Android 部分。同样，如果你只有 Mac，你可以选择只处理此项目的 iOS 和 Android
    部分。
- en: You can find the full source for the code in this chapter at [https://github.com/PacktPubliching/MAUI-Projects-3rd-Edition](https://github.com/PacktPubliching/MAUI-Projects-3rd-Edition).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章中找到代码的完整源代码，链接为 [https://github.com/PacktPubliching/MAUI-Projects-3rd-Edition](https://github.com/PacktPubliching/MAUI-Projects-3rd-Edition)。
- en: Project overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Applications for iOS and Android can run on both phones and tablets. Often,
    apps are just optimized for phones. In this chapter, we will build an app that
    will work on different form factors, but we aren’t going to stick to just phones
    and tablets – we are going to target desktop computers as well. The desktop version
    will be for **Window UI Library** (**WinUI**) and macOS via Mac Catalyst.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 和 Android 应用可以在手机和平板电脑上运行。通常，应用只是针对手机进行优化。在本章中，我们将构建一个适用于不同形态的应用，但不会仅限于手机和平板电脑——我们还将针对桌面电脑。桌面版本将使用
    **Window UI Library** （**WinUI**）和 macOS 通过 Mac Catalyst。
- en: The app that we are going to build is a weather app that displays the weather
    forecast based on the location of the user. For this chapter, we will be referencing
    Visual Studio for Mac in the instructions. If you are using Visual Studio for
    Windows, you should be able to follow along. Use one of the other chapters for
    reference if you need help.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用是一个天气应用，它根据用户的地理位置显示天气预报。对于本章，我们将使用 Visual Studio for Mac 的说明。如果你使用
    Visual Studio for Windows，你应该能够跟上。如果你需要帮助，可以使用其他章节进行参考。
- en: Building the weather app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建天气应用
- en: 'It’s time to start building the app. Create a new blank .NET MAUI app using
    the following steps for Visual Studio for Mac:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建应用了。按照以下步骤在 Visual Studio for Mac 中创建一个新的空白 .NET MAUI 应用：
- en: 'Open Visual Studio for Mac and click on **New**:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio for Mac 并点击 **新建**：
- en: '![Figure 8.1 – Visual Studio 2022 for Mac start screen](img/B19214_08_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – Visual Studio 2022 for Mac 启动屏幕](img/B19214_08_1.jpg)'
- en: Figure 8.1 – Visual Studio 2022 for Mac start screen
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Visual Studio 2022 for Mac 启动屏幕
- en: 'In the **Choose** **a template for your new project** dialog, use the **.NET
    MAUI App** template, which is under **Multiplatform | App**, then click **Continue**:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选择** **你的新项目模板** 对话框中，使用位于 **多平台 | 应用** 下的 **.NET MAUI 应用** 模板，然后点击 **继续**：
- en: '![Figure 8.2 – New project ](img/B19214_08_2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 新建项目](img/B19214_08_2.jpg)'
- en: Figure 8.2 – New project
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 新建项目
- en: 'In the **Configure** **your new .NET MAUI App** dialog, ensure the **.NET 7.0**
    target framework is selected, then click **Continue**:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **配置** **你的新 .NET MAUI 应用** 对话框中，确保已选择 **.NET 7.0** 目标框架，然后点击 **继续**：
- en: '![Figure 8.3 – Choosing the target framework](img/B19214_08_3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 选择目标框架](img/B19214_08_3.jpg)'
- en: Figure 8.3 – Choosing the target framework
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 选择目标框架
- en: 'In the `Weather`, then click **Create**:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Weather` 中，点击 **创建**：
- en: '![Figure 8.4 – Naming the new app](img/B19214_08_4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 命名新应用](img/B19214_08_4.jpg)'
- en: Figure 8.4 – Naming the new app
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 命名新应用
- en: 'If you run the app now, you should see something like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行该应用，你应该看到以下类似的内容：
- en: '![Figure 8.5 – Weather app on macOS](img/B19214_08_5.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – macOS 上的天气应用](img/B19214_08_5.jpg)'
- en: Figure 8.5 – Weather app on macOS
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – macOS 上的天气应用
- en: Now that we have created the project from a template, it’s time to start coding!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从模板创建了项目，是时候开始编码了！
- en: Creating models for the weather data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为天气数据创建模型
- en: Before we write the code to fetch data from the external weather service, we
    will create models to deserialize the results from the service. We will do this
    so that we have a common model that we can use to return data from the service.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写从外部天气服务获取数据的代码之前，我们将创建用于反序列化服务结果的模型。我们将这样做，以便我们有一个通用的模型，我们可以用它来从服务返回数据。
- en: As the data source for this app, we will use an external Weather API. This project
    will use **OpenWeatherMap**, a service that offers a couple of free APIs. You
    can find this service at [https://openweathermap.org/api](https://openweathermap.org/api).
    We will use the **5 day / 3 hour forecast** service in this project, which provides
    a 5-day forecast in 3-hour intervals. To use the OpenWeatherMap API, we have to
    create an account to get an API key. If you don’t want to create an API key, you
    can mock the data instead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此应用的数据源，我们将使用外部天气 API。本项目将使用 **OpenWeatherMap**，这是一个提供几个免费 API 的服务。你可以在 [https://openweathermap.org/api](https://openweathermap.org/api)
    找到这个服务。在本项目中，我们将使用 **5 天 / 3 小时预报**服务，该服务以 3 小时为间隔提供 5 天的预报。为了使用 OpenWeatherMap
    API，我们必须创建一个账户以获取 API 密钥。如果你不想创建 API 密钥，你可以模拟数据。
- en: Follow the instructions at [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up)
    to create your account and get your API key, which you will need to call the API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明在 [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up)
    创建你的账户并获取你的 API 密钥，你需要用它来调用 API。
- en: The easiest way to generate models to use when we are deserializing results
    from the service is to make a call to the service either in the browser or with
    a tool (such as `https://api.openweathermap.org/data/2.5/forecast?lat=44.34&lon=10.99&appid={API
    key}` in your browser, replacing `{API KEY}` with your API key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成用于反序列化服务结果的模型的最简单方法是，在浏览器或使用工具（如浏览器中的 `https://api.openweathermap.org/data/2.5/forecast?lat=44.34&lon=10.99&appid={API
    key}`）中对服务进行调用，将 `{API KEY}` 替换为你的 API 密钥。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you got a 401 error, please wait a couple of hours before you can use your
    API, as mentioned at [https://openweathermap.org/faq#error401](https://openweathermap.org/faq#error401).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了 401 错误，请等待几个小时后再使用你的 API，如 [https://openweathermap.org/faq#error401](https://openweathermap.org/faq#error401)
    中所述。
- en: We can create classes manually or use a tool that can generate C# classes from
    the JSON. One tool that can be used is **quicktype**, which can be found at [https://quicktype.io/](https://quicktype.io/).
    Just paste the output from the API call into quicktype to generate your C# models.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动创建类或使用一个可以从 JSON 生成 C# 类的工具。一个可以使用的工具是 **quicktype**，可以在 [https://quicktype.io/](https://quicktype.io/)
    找到。只需将 API 调用的输出粘贴到 quicktype 中，即可生成你的 C# 模型。
- en: If you generate them using a tool, make sure you set the namespace to `Weather.Models`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用工具生成它们，请确保将命名空间设置为 `Weather.Models`。
- en: As mentioned previously, you can also create these models manually. We will
    describe how to do this in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你也可以手动创建这些模型。我们将在下一节中描述如何进行此操作。
- en: Adding the Weather API models manually
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动添加天气 API 模型
- en: 'If you wish to add the models manually, then go through the following instructions.
    We will be adding a single code file called `WeatherData.cs`, which will contain
    multiple classes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望手动添加模型，请按照以下说明进行。我们将添加一个名为 `WeatherData.cs` 的单个代码文件，其中将包含多个类：
- en: Create a folder called `Models`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Models` 的文件夹。
- en: Add a file called `WeatherData.cs` to the newly created folder.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的文件夹中添加一个名为 `WeatherData.cs` 的文件。
- en: 'Add the following code to the `WeatherData.cs` file:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `WeatherData.cs` 文件中：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, there are quite a lot of classes. These classes map directly
    to the response we get from the service. In most cases, you only want to use these
    classes when communicating with the service. To represent the data in your app,
    you will need to use a second set of classes that exposes only the information
    you need in your app.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有很多类。这些类直接映射到我们从服务中获得的响应。在大多数情况下，您只想在与服务通信时使用这些类。为了在您的应用中表示数据，您将需要使用另一组仅公开您在应用中需要的信息的类。
- en: Adding the app-specific models
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加应用特定的模型
- en: 'In this section, we will create the models that our app will translate the
    Weather API models into. Let’s start by adding the `WeatherData` class (unless
    you created this manually in the preceding section):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建我们的应用将翻译天气 API 模型的模型。让我们先添加 `WeatherData` 类（除非你在前面的部分手动创建了它）：
- en: Create a new folder called `Models` in the `Weather` project.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Weather` 项目中创建一个名为 `Models` 的新文件夹。
- en: Add a new file called `WeatherData.cs`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `WeatherData.cs` 的新文件。
- en: Paste the generated code from quicktype or write the code for the classes based
    on the JSON. If code other than the properties is generated, ignore it and just
    use the properties.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 quicktype 生成的代码粘贴过来，或者根据 JSON 写出类的代码。如果生成了除属性以外的代码，忽略它，只使用属性。
- en: Rename `MainClass` (this is what `WeatherData`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名 `MainClass`（这是 `WeatherData` 的内容）。
- en: Now, we will create models based on the data we are interested in. This will
    make the rest of the code more loosely coupled to the data source.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建基于我们感兴趣的数据的模型。这将使其余的代码与数据源耦合得更松散。
- en: Adding the ForecastItem model
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 ForecastItem 模型
- en: 'The first model we are going to add is `ForecastItem`, which represents a specific
    forecast for a point in time. We can do this as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的第一个模型是 `ForecastItem`，它代表特定时间点的特定预测。我们可以这样做：
- en: In the `Weather` project and the `Models` folder, create a new class called
    `ForecastItem`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Weather` 项目和 `Models` 文件夹中，创建一个名为 `ForecastItem` 的新类。
- en: 'Add the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have a model for each forecast, we need a container model that will
    group `ForecastItems` by `City`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了每个预测的模型，我们需要一个容器模型来按 `City` 对 `ForecastItems` 进行分组。
- en: Adding the Forecast model
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 Forecast 模型
- en: 'In this section, we’ll create a model called `Forecast` that will keep track
    of a single forecast for a city. The `Forecast` model keeps a list of multiple
    `ForeCastItem` objects, each representing a forecast for a specific point in time.
    Let’s set this up:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个名为 `Forecast` 的模型，该模型将跟踪一个城市的单个预测。`Forecast` 模型保留多个 `ForeCastItem`
    对象的列表，每个对象代表特定时间点的预测。让我们设置它：
- en: Create a new class called `Forecast` in the `Models` folder.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中创建一个名为 `Forecast` 的新类。
- en: 'Add the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have our models for both the Weather API and the app, we need to
    fetch data from the Weather API.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了天气 API 和应用的两个模型，我们需要从天气 API 获取数据。
- en: Creating a service to fetch the weather data
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个获取天气数据的服务
- en: 'To make it easier to change the external weather service and to make the code
    more testable, we will create an interface for the service. Here’s how we can
    go about it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易更改外部天气服务并使代码更易于测试，我们将为服务创建一个接口。以下是我们可以如何进行：
- en: Create a new folder called `Services`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Services` 的新文件夹。
- en: Create a new `public interface` called `IWeatherService`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `IWeatherService` 的新 `public interface`。
- en: 'Add a method for fetching data based on the location of the user, as shown
    in the following code. Name the method `GetForecastAsync`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个基于用户位置获取数据的方法，如下所示。将方法命名为 `GetForecastAsync`：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have an interface, we can create an implementation for it, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个接口，我们可以创建一个实现，如下所示：
- en: In the `Services` folder, create a new class called `OpenWeatherMapWeatherService`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Services` 文件夹中，创建一个名为 `OpenWeatherMapWeatherService` 的新类。
- en: 'Implement the interface and add the `async` keyword to the `GetForecastAsync`
    method:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口，并将 `async` 关键字添加到 `GetForecastAsync` 方法中：
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we call the OpenWeatherMap API, we need to build a URI for the call
    to the Weather API. This will be a GET call, and the latitude and longitude of
    the position will be added as query parameters. We will also add the API key and
    the language that we would like the response to be in. Let’s set this up:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用 OpenWeatherMap API 之前，我们需要为对天气 API 的调用构建一个 URI。这将是一个 GET 调用，位置的位置纬度和经度将作为查询参数添加。我们还将添加
    API 密钥和我们希望响应使用的语言。让我们设置它：
- en: Open the `OpenWeatherMapWeatherService` class.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `OpenWeatherMapWeatherService` 类。
- en: 'Add the highlighted code in the following code snippet to the `OpenWeatherMap``WeatherService`
    class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段中高亮显示的代码添加到 `OpenWeatherMap` 的 `WeatherService` 类中：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Replace the {`AddYourApiKeyHere`} with the key you obtained from the *Creating
    models for the weather* *data* section
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `{`AddYourApiKeyHere`}` 替换为从 *Creating models for the weather* *data* 部分获得的密钥
- en: To deserialize the JSON that we will get from the external service, we will
    use `System.Text.JSON`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反序列化我们从外部服务获取的 JSON，我们将使用 `System.Text.JSON`。
- en: 'To make a call to the `Weather` service, we will use the `HttpClient` class
    and the `GetStringAsync` method, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 `Weather` 服务，我们将使用 `HttpClient` 类和 `GetStringAsync` 方法，如下所示：
- en: Create a new instance of the `HttpClient` class.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `HttpClient` 类的新实例。
- en: Call `GetStringAsync` and pass the URL as the argument.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `GetStringAsync` 并将 URL 作为参数传递。
- en: Use the `JsonSerializer` class and the `DeserializeObject` method from `System.Text.Json`
    to convert the JSON string into an object.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `System.Text.Json` 中的 `JsonSerializer` 类和 `DeserializeObject` 方法将 JSON 字符串转换为对象。
- en: Map the `WeatherData` object to a `Forecast` object.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `WeatherData` 对象映射到 `Forecast` 对象。
- en: 'The code for this should look like the highlighted code shown in the following
    snippet:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码应类似于以下代码片段中高亮显示的代码：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Performance tip
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提示
- en: 'To optimize the performance of the app, we can use `HttpClient` as a singleton
    and reuse it for all network calls in the application. The following information
    is from Microsoft’s documentation: “*HttpClient is intended to be instantiated
    once and reused throughout the life of an application. Instantiating an HttpClient
    class for every request will exhaust the number of sockets available under heavy
    loads. This will result in SocketException errors*.” This can be found at [https://learn.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0](https://learn.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化应用程序的性能，我们可以将 `HttpClient` 作为单例使用，并在应用程序的所有网络调用中重用它。以下信息来自 Microsoft 的文档：“*HttpClient
    旨在一次性实例化并在整个应用程序生命周期中重用。为每个请求实例化 HttpClient 类将在高负载下耗尽可用的套接字数量。这将导致 SocketException
    错误*。” 这可以在 [https://learn.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0](https://learn.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0)
    找到。
- en: 'In the preceding code, we have a call to a `ToDateTime` method, which is a
    method that we will need to create. This method converts the date from a Unix
    timestamp into a `DateTime` object, as shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个调用 `ToDateTime` 方法的调用，这是一个我们需要创建的方法。该方法将日期从 Unix 时间戳转换为 `DateTime`
    对象，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Performance tip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提示
- en: By default, `HttpClient` uses the Mono implementation of `HttpClient` (iOS and
    Android). To increase performance, we can use a platform-specific implementation
    instead. For iOS, use `NSUrlSession`. This can be set in the project settings
    of the iOS project under the **iOS Build** tab. For Android, use **Android**.
    This can be set in the project settings of the Android project under **Android
    Options** | **Advanced**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`HttpClient` 使用 `HttpClient` 的 Mono 实现（iOS 和 Android）。为了提高性能，我们可以使用特定平台的实现。对于
    iOS，使用 `NSUrlSession`。这可以在 iOS 项目的“**iOS 构建选项卡**”下的项目设置中设置。对于 Android，使用 **Android**。这可以在
    Android 项目的“**Android 选项**” | **高级**”下设置。
- en: Configuring the application platforms so that they use location services
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置应用程序平台以使用位置服务
- en: To be able to use location services, we need to carry out some configuration
    on each platform.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用位置服务，我们需要在每个平台上进行一些配置。
- en: Configuring the iOS platform so that it uses location services
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 iOS 平台以使用位置服务
- en: 'To use location services in an iOS app, we need to add a description to indicate
    why we want to use the location in the `info.plist` file. In this app, we only
    need to get the location when we are using the app, so we only need to add a description
    for this. Let’s set this up:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 iOS 应用程序中使用位置服务，我们需要在 `info.plist` 文件中添加一个描述，说明我们为什么想要使用位置。在这个应用程序中，我们只需要在我们使用应用程序时获取位置，所以我们只需要为此添加一个描述。让我们设置它：
- en: Open `info.plist` in `Platforms/iOS` with **XML (****Text) Editor**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **XML (****Text) Editor** 打开 `Platforms/iOS` 中的 `info.plist`。
- en: 'Add the `NSLocationWhenInUseUsageDescription` key using the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码添加 `NSLocationWhenInUseUsageDescription` 键：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Configuring the Android platform so that it uses location services
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Android 平台以使用位置服务
- en: 'For Android, we need to set up the app so that it requires the following two
    permissions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android，我们需要设置应用程序，使其需要以下两个权限：
- en: '**ACCESS_COARSE_LOCATION**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACCESS_COARSE_LOCATION**'
- en: '**ACCESS_FINE_LOCATION**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACCESS_FINE_LOCATION**'
- en: 'We can set this in the `AndroidManifest.xml` file, which can be found in the
    `Platforms\Android\` folder. However, we can also set this in the project properties
    on the **Android Manifest** tab, as shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `AndroidManifest.xml` 文件中设置此内容，该文件位于 `Platforms\Android\` 文件夹中。然而，我们也可以在项目属性中的
    **Android Manifest** 选项卡中设置此内容，如下面的截图所示：
- en: "![Figure 8.6 – Selecting \uFEFF\uFEFF\uFEFF\uFEFFlocation permissions](img/B19214_08_6.jpg)"
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 选择位置权限](img/B19214_08_6.jpg)'
- en: Figure 8.6 – Selecting location permissions
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 选择位置权限
- en: Configuring the WinUI platform so that it uses location services
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 WinUI 平台以使用位置服务
- en: 'Since we will be using location services in the WinUI platform, we need to
    add the `Location` capability under `Package.appxmanifest` file of the project,
    which is located in the `Platforms/Windows` folder, as shown in the following
    screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在 WinUI 平台中使用位置服务，我们需要在项目的 `Platforms/Windows` 文件夹中的 `Package.appxmanifest`
    文件下添加 `Location` 功能，如下面的截图所示：
- en: '![Figure 8.7 – Adding a location to the WinUI app](img/B19214_08_7.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 向 WinUI 应用添加位置](img/B19214_08_7.jpg)'
- en: Figure 8.7 – Adding a location to the WinUI app
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 向 WinUI 应用添加位置
- en: Creating the ViewModel class
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ViewModel 类
- en: 'Now that we have a service that’s responsible for fetching weather data from
    the external weather source, it’s time to create a `ViewModel`. First, however,
    we will create a base view model where we can put the code that can be shared
    between all the `ViewModels` of the app. Let’s set this up:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有一个负责从外部天气源获取天气数据的服务，那么是时候创建一个 `ViewModel` 了。然而，首先我们将创建一个基视图模型，我们可以在这里放置所有应用中
    `ViewModels` 之间可以共享的代码。让我们来设置它：
- en: Create a new folder called `ViewModels`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ViewModels` 的新文件夹。
- en: Create a new class called `ViewModel`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ViewModel` 的新类。
- en: Make the new class `public` and `abstract`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类设置为 `public` 和 `abstract`。
- en: 'Add a package reference to CommunityToolkit.MVVM:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 CommunityToolkit.MVVM 的包引用：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have a base view model. We can use this for the view model that we’re
    about to create.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基视图模型。我们可以使用它来创建我们即将创建的视图模型。
- en: 'Now, it’s time to create `MainViewModel`, which will be the ViewModel for our
    `MainView` in the app. Perform the following steps to do so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建 `MainViewModel` 了，它将是应用中 `MainView` 的 ViewModel。执行以下步骤来完成此操作：
- en: In the `ViewModels` folder, create a new class called `MainViewModel`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中，创建一个名为 `MainViewModel` 的新类。
- en: Add the abstract `ViewModel` class as a base class.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将抽象的 `ViewModel` 类添加为基类。
- en: Because we are going to use constructor injection, we will add a constructor
    with the `IWeatherService` interface as a parameter.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用构造函数注入，我们将添加一个带有 `IWeatherService` 接口参数的构造函数。
- en: 'Create a `read-only private` field. We will use this to store the `IweatherService`
    instance:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个 `read-only private` 字段。我们将使用它来存储 `IweatherService` 实例：
- en: '[PRE10]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MainViewModel` takes any object that implements `IWeatherService` and stores
    a reference to that service in a field. We will be adding functionality that will
    fetch weather data in the next section.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel` 接受任何实现 `IWeatherService` 的对象，并将对该服务的引用存储在一个字段中。我们将在下一节添加将获取天气数据的功能。'
- en: Getting the weather data
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取天气数据
- en: Now, we will create a new method for loading the data. This will be a three-step
    process. First, we will get the location of the user. Once we have this, we can
    fetch data related to that location. The final step is to prepare the data that
    the views can consume to create a user interface for the user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的加载数据的方法。这将是一个三步过程。首先，我们将获取用户的位置。一旦我们有了这个，我们就可以获取与该位置相关的数据。最后一步是为视图准备数据，以便创建用户界面。
- en: 'To get the location of the user, we will use the `Geolocation` class, which
    exposes methods that can fetch the location of the user. Perform the following
    steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取用户的位置，我们将使用 `Geolocation` 类，该类公开了可以获取用户位置的方法。执行以下步骤：
- en: Create a new method called `LoadDataAsync`. Make it an asynchronous method that
    returns `Task`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `LoadDataAsync` 的新方法。使其成为一个返回 `Task` 的异步方法。
- en: Use the `GetLocationAsync` method on the `Geolocation` class to get the location
    of the user.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Geolocation` 类中的 `GetLocationAsync` 方法来获取用户的位置。
- en: 'Pass the latitude and longitude from the result of the `GetLocationAsync` call
    and pass it to the `GetForecast` method on the object that implements `IWeatherService`
    using the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `GetLocationAsync` 调用的结果中传递纬度和经度，并使用以下代码将其传递给实现 `IWeatherService` 的对象上的 `GetForecast`
    方法：
- en: '[PRE11]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we can get data from the service, we need to structure it for our user
    interface by grouping the individual data items.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从服务中获取数据，我们需要通过分组单个数据项来为我们的用户界面结构化它。
- en: Grouping the weather data
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对天气数据进行分组
- en: 'When we present the weather data, we will group it by day so that all of the
    forecasts for one day will be under the same header. To do this, we will create
    a new model called `ForecastGroup`. To make it possible to use this model with
    the .NET MAUI `CollectionView`, it has to have an `IEnumerable` type as the base
    class. Let’s set this up:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示天气数据时，我们将按天对其进行分组，以便所有针对一天的预测都将位于同一标题下。为此，我们将创建一个新的模型，称为 `ForecastGroup`。为了使该模型能够与
    .NET MAUI 的 `CollectionView` 一起使用，它必须有一个 `IEnumerable` 类型作为基类。让我们设置它：
- en: Create a new class called `ForecastGroup` in the `Models` folder.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中创建一个新的类 `ForecastGroup`。
- en: Add `List<ForecastItem>` as the base class for the new model.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `List<ForecastItem>` 作为新模型的基类。
- en: Add an empty constructor and a constructor that has a list of `ForecastItem`
    instances as a parameter.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的构造函数和一个带有 `ForecastItem` 实例列表参数的构造函数。
- en: Add a `Date` property.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `Date` 属性。
- en: Add a property, `DateAsString`, that returns the `Date` property as a short
    date string.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `DateAsString` 的属性，它返回 `Date` 属性作为短日期字符串。
- en: 'Add a property, `Items`, that returns the list of `ForecastItem` instances,
    as shown in the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Items` 的属性，它返回 `ForecastItem` 实例的列表，如下所示：
- en: '[PRE12]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we have done this, we can update `MainViewModel` with two new properties,
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这个操作后，我们可以通过以下方式更新 `MainViewModel` 的两个新属性：
- en: Create a private field called `city` with the `ObservableProperty` attribute
    for the name of the city we are fetching the weather data.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `city` 的私有字段，并使用 `ObservableProperty` 属性来获取我们正在获取天气数据的城市的名称。
- en: Create a private field called `days` with the `ObservableProperty` attribute
    that will contain the grouped weather data.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `days` 的私有字段，并使用 `ObservableProperty` 属性，它将包含分组后的天气数据。
- en: 'The `MainViewModel` class should look like the highlighted code shown in the
    following snippet:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MainViewModel` 类应该看起来像以下代码片段中高亮显示的代码：'
- en: '[PRE13]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we are ready to group the data. We will do this in the `LoadDataAsync`
    method. We will loop through the data from the service and add items to various
    groups, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好对数据进行分组了。我们将在 `LoadDataAsync` 方法中这样做。我们将遍历服务中的数据，并将项目添加到不同的组中，如下所示：
- en: Create an `itemGroups` variable of the `List<ForecastGroup>` type.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `itemGroups` 变量，其类型为 `List<ForecastGroup>`。
- en: Create a `foreach` loop that loops through all the items in the `forecast` variable.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `foreach` 循环，遍历 `forecast` 变量中的所有项目。
- en: Add an `if` statement that checks whether the `itemGroups` property is empty.
    If it is empty, add a new `ForecastGroup` to the variable and continue to the
    next item in the item list.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `if` 语句来检查 `itemGroups` 属性是否为空。如果是空的，则向变量中添加一个新的 `ForecastGroup` 并继续到项目列表中的下一个项目。
- en: Use the `SingleOrDefault` method (this is an extension method from `System.Linq`)
    on the `itemGroups` variable to get a group based on the date of the current `ForecastItem`.
    Add the result to a new variable, `group`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `itemGroups` 变量上使用 `SingleOrDefault` 方法（这是来自 `System.Linq` 的扩展方法）来根据当前 `ForecastItem`
    的日期获取一个组。将结果添加到一个新变量 `group` 中。
- en: If the `group` property is `null`, then there is no group with the current day
    in the list of groups. If this is the case, a new `ForecastGroup` should be added
    to the list in the `itemGroups` variable. The code will continue executing until
    it gets to the next `forecast` item in the `forecast.Items` list. If a group is
    found, it should be added to the list in the `itemGroups` variable.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `group` 属性为 `null`，则当前天在组列表中没有组。如果是这种情况，应在 `itemGroups` 变量中添加一个新的 `ForecastGroup`。代码将继续执行，直到它到达
    `forecast.Items` 列表中的下一个 `forecast` 项目。如果找到组，则应将其添加到 `itemGroups` 变量中的列表。
- en: After the `foreach` loop, set the `Days` property with a new `ObservableCollection`
    **<ForecastGroup>** and use the `itemGroups` variable as an argument in the constructor.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foreach` 循环之后，使用新的 `ObservableCollection` **<ForecastGroup>** 设置 `Days` 属性，并将
    `itemGroups` 变量作为构造函数的参数。
- en: Set the `City` property to the `City` property of the `forecast` variable.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `City` 属性设置为 `forecast` 变量的 `City` 属性。
- en: 'The `LoadDataAsync` method should now look as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadDataAsync` 方法现在应该如下所示：'
- en: '[PRE14]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don’t use the `Add` method on `ObservableCollection` when you want to add more
    than a couple of items. It is better to create a new instance of `ObservableCollection`
    and pass a collection to the constructor. The reason for this is that every time
    you use the `Add` method, you will have a binding to it from the view, which will
    cause the view to be rendered. We will get better performance if we avoid using
    the `Add` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想添加超过几个项目时，不要在 `ObservableCollection` 上使用 `Add` 方法。最好创建一个新的 `ObservableCollection`
    实例并将集合传递给构造函数。这样做的原因是，每次你使用 `Add` 方法时，你都会从视图中绑定它，这将导致视图被渲染。如果我们避免使用 `Add` 方法，我们将获得更好的性能。
- en: Creating the view for tablets and desktop computers
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为平板电脑和桌面电脑创建视图
- en: 'The next step is to create the view that we will use when the app is running
    on a tablet or a desktop computer. Let’s set this up:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建当应用在平板电脑或桌面电脑上运行时我们将使用的视图。让我们设置它：
- en: Create a new folder in the `Weather` project called `Views`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Weather` 项目中创建一个名为 `Views` 的新文件夹。
- en: In the `Views` folder, create a new folder called `Desktop`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views` 文件夹中创建一个名为 `Desktop` 的新文件夹。
- en: 'Create a new `.NET MAUI ContentPage (XAML)` file called `MainView` in the `Views\Desktop`
    folder:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Desktop` 文件夹中创建一个名为 `MainView` 的新 `.NET MAUI ContentPage (XAML)` 文件：
- en: "![Figure 8.8 – Addi\uFEFFng a .NET MAUI XAML ContentPage](img/B19214_08_8.jpg)"
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 添加 .NET MAUI XAML ContentPage](img/B19214_08_8.jpg)'
- en: Figure 8.8 – Adding a .NET MAUI XAML ContentPage
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 添加 .NET MAUI XAML ContentPage
- en: 'Pass an instance of `MainViewModel` in the constructor of the view to set `BindingContext`,
    as shown in the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图的构造函数中传递 `MainViewModel` 的实例以设置 `BindingContext`，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Later, in the *Adding services and ViewModels to dependency injection* section,
    we will configure dependency injection to provide the instances for us.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在后面的 *添加服务和 ViewModels 到依赖注入* 部分中，我们将配置依赖注入以为我们提供实例。
- en: To trigger the `LoadDataAsync` method in `MainViewModel`, call the `LoadDataAsync`
    method by overriding the `OnNavigatedTo` method on the main thread. We need to
    make sure that the call is executed on the UI thread since it will interact with
    the user interface.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在主线程上触发 `MainViewModel` 中的 `LoadDataAsync` 方法，通过覆盖主线程上的 `OnNavigatedTo` 方法来调用
    `LoadDataAsync` 方法。我们需要确保调用是在 UI 线程上执行的，因为它将交互用户界面。
- en: 'To do this, perform the following steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请按照以下步骤操作：
- en: Open the `MainView.xaml.cs` file in the `Views\Desktop` folder.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Desktop` 文件夹中打开 `MainView.xaml.cs` 文件。
- en: Create an override of the `OnNavigatedTo` method.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `OnNavigatedTo` 方法的覆盖版本。
- en: 'Add the highlighted code shown in the following snippet to the `OnNavigateTo`
    method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段中突出显示的代码添加到 `OnNavigateTo` 方法中：
- en: '[PRE16]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `MainView` XAML file, add a binding for the `Title` property of `ContentPage`
    to the `City` property in `ViewModel`, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainView` XAML 文件中，将 `ContentPage` 的 `Title` 属性绑定到 `ViewModel` 中的 `City`
    属性，如下所示：
- en: Open the `MainView.xaml` file in the `Views\Desktop` folder.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Desktop` 文件夹中打开 `MainView.xaml` 文件。
- en: 'Add the `Title` binding to the `ContentPage` element, as highlighted in the
    following code snippet:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Title` 绑定添加到以下代码片段中突出显示的 `ContentPage` 元素中：
- en: '[PRE17]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this next section, we will use `FlexLayout` to render the data from the ViewModel
    onto the screen.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将使用 `FlexLayout` 将 ViewModel 中的数据渲染到屏幕上。
- en: Using FlexLayout
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 FlexLayout
- en: In .NET MAUI, we can use `CollectionView` or `ListView` if we want to show a
    collection of data. Using both `CollectionView` and `ListView` works great in
    most cases, and we will use `CollectionView` later in this chapter, but `ListView`
    can only show data vertically. In this app, we want to show data in both directions.
    In the vertical direction, we will have the days (we group forecasts based on
    days), while in the horizontal direction, we will have the forecasts within a
    particular day. We also want the forecasts within a day to wrap if there is not
    enough space for all of them in one row. `CollectionView` can show data in a horizontal
    direction, but it will not wrap. With `FlexLayout`, we can add items in both directions
    and we can use `BindableLayout` to bind items to it. When we use `BindableLayout`,
    we will use `ItemSource` and `ItemsTemplate` as attached properties.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中，如果我们想显示一组数据，可以使用`CollectionView`或`ListView`。在大多数情况下，使用`CollectionView`和`ListView`都很好，我们将在本章后面使用`CollectionView`，但`ListView`只能垂直显示数据。在这个应用中，我们希望两个方向都能显示数据。在垂直方向上，我们将有天数（我们根据天数分组预测），而在水平方向上，我们将有特定天内的预测。我们还希望如果在一行中不足以显示所有预测时，预测内容可以换行。`CollectionView`可以在水平方向显示数据，但它不会自动换行。使用`FlexLayout`，我们可以添加两个方向的项目，并且我们可以使用`BindableLayout`将其绑定。当我们使用`BindableLayout`时，我们将使用`ItemSource`和`ItemsTemplate`作为附加属性。
- en: 'Perform the following steps to build the view:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来构建视图：
- en: Add `Grid` as the root view of the page.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Grid`作为页面的根视图添加。
- en: Add `ScrollView` to `Grid`. We need this to be able to scroll if the content
    is higher than the height of the page.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ScrollView`添加到`Grid`中。我们需要这样做，以便如果内容高于页面高度，则可以滚动。
- en: Add `FlexLayout` to `ScrollView` and set the direction to `Column` so that the
    content will be in a vertical direction.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FlexLayout`添加到`ScrollView`中，并将方向设置为`Column`，以便内容将垂直排列。
- en: Add a binding to the `Days` property in `MainViewModel` using `BindableLayout.ItemsSource`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BindableLayout.ItemsSource`将`MainViewModel`中的`Days`属性添加绑定。
- en: 'Set `DataTemplate` to the content of `ItemsTemplate`, as shown in the following
    code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DataTemplate`设置为`ItemsTemplate`的内容，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The content for each item will be a header with the date and a horizontal `FlexLayout`
    with the forecasts for the day. Let’s set this up:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目的内联内容将是一个包含日期的标题以及一个水平`FlexLayout`，其中包含该天的预测。让我们设置如下：
- en: Open the `MainView.xaml` file.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainView.xaml`文件。
- en: Add `StackLayout` so that the children we add to it will be placed in a vertical
    direction.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`StackLayout`，以便我们将添加到其中的子项垂直排列。
- en: Add `ContentView` to `StackLayout` with `Padding` set to `10` and `BackgroundColor`
    set to `#9F5010`. This will be the header. The reason we need `ContentView` is
    that we want to have padding around the text.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ContentView`添加到`StackLayout`中，并将`Padding`设置为`10`，`BackgroundColor`设置为`#9F5010`。这将作为标题。我们需要`ContentView`的原因是我们希望文本周围有填充。
- en: Add `Label` to `ContentView` with `TextColor` set to `White` and `FontAttributes`
    set to `Bold`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Label`添加到`ContentView`中，并将`TextColor`设置为`White`，`FontAttributes`设置为`Bold`。
- en: Add a binding to `DateAsString` for the `Text` property of `Label`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Label`的`Text`属性添加对`DateAsString`的绑定。
- en: 'The code should be placed at the `<!-- Content will be added here -->` comment
    and should look as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应放置在`<!-- Content will be added here -->`注释中，并应如下所示：
- en: '[PRE19]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have the date in the user interface, we need to add a `FlexLayout`
    property, which will repeat through any items in `MainViewModel`. Perform the
    following steps to do so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在用户界面中有了日期，我们需要添加一个`FlexLayout`属性，该属性将在`MainViewModel`中的任何项目中重复。执行以下步骤来完成此操作：
- en: Add `FlexLayout` after the `</ContentView>` tag but before the `</``StackLayout>`
    tag.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`</ContentView>`标签之后但在`</StackLayout>`标签之前添加`FlexLayout`。
- en: Set `JustifyContent` to `Start` to set the items so that they’re added from
    the left-hand side, without distributing them over the available space.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`JustifyContent`设置为`Start`，以便将项目从左侧添加，而不在可用空间中分配它们。
- en: 'Set `AlignItems` to `Start` to set the content to the left of each item in
    `FlexLayout`, as shown in the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AlignItems`设置为`Start`，以便将内容设置为`FlexLayout`中每个项目的左侧，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After defining `FlexLayout`, we need to provide an `ItemsTemplate` property,
    which defines how each item in the list should be rendered. Continue adding the
    XAML directly under the `<FlexLayout>` tag you just added, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`FlexLayout`之后，我们需要提供一个`ItemsTemplate`属性，该属性定义了列表中每个项目应该如何渲染。继续在您刚刚添加的`<FlexLayout>`标签下直接添加XAML，如下所示：
- en: Set the `ItemsTemplate` property to `DataTemplate`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ItemsTemplate`属性设置为`DataTemplate`。
- en: '`FillDataTemplate` with elements, as shown in the following code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将元素添加到`FillDataTemplate`中：
- en: Tip
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If we want to add formatting to a binding, we can use `StringFormat`. In this
    case, we want to add the degree symbol after the temperature. We can do this by
    using the `{Binding Temperature, StringFormat=’{0}° C’}` phrase. With the `StringFormat`
    property of the binding, we can format data with the same arguments that we would
    use if we were to do this in C#. This is the same as `string.Format(“{0}° C”,
    Temperature)` in C#. We can also use it to format a date; for example, `{Binding
    Date, StringFormat=’yyyy’}`. In C#, this would look like `Date.ToString(“yyyy”)`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在绑定中添加格式，可以使用`StringFormat`。在这种情况下，我们想在温度后面添加度符号。我们可以通过使用`{Binding Temperature,
    StringFormat=’{0}° C’}`短语来实现。通过绑定的`StringFormat`属性，我们可以使用与在C#中执行此操作时相同的参数格式化数据。这相当于C#中的`string.Format(“{0}°
    C”, Temperature)`。我们还可以用它来格式化日期；例如，`{Binding Date, StringFormat=’yyyy’}`。在C#中，这看起来像`Date.ToString(“yyyy”)`。
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `AspectFill` phrase, as a value of the `Aspect` property for `Image`, means
    that the whole image will always be visible and that the aspects will not be changed.
    The `AspectFit` phrase will also keep the aspect of an image, but the image can
    be zoomed into and out of and cropped so that it fills the whole `Image` element.
    The last value that `Aspect` can be set to, `Fill`, means that the image can be
    stretched or compressed to match the `Image` view to ensure that the aspect ratio
    is kept.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`AspectFill`短语作为`Image`的`Aspect`属性的值，意味着整个图像始终可见，并且不会更改其比例。`AspectFit`短语也将保持图像的比例，但图像可以放大和缩小，并裁剪以填充整个`Image`元素。`Aspect`可以设置的最后一个值`Fill`意味着图像可以拉伸或压缩以匹配`Image`视图，从而确保保持宽高比。'
- en: Adding a toolbar item to refresh the weather data
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加工具栏项以刷新天气数据
- en: To be able to refresh the data without restarting the app, we will add a `Refresh`
    button to the toolbar. `MainViewModel` is responsible for handling any logic that
    we want to perform, and we must expose any action as an `ICommand` bindable that
    we can bind to.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在不重新启动应用程序的情况下刷新数据，我们将向工具栏添加一个`Refresh`按钮。`MainViewModel`负责处理我们想要执行的任何逻辑，并且我们必须将任何操作公开为可绑定的`ICommand`，以便我们可以将其绑定到。
- en: 'Let’s start by creating the `Refresh` command method on `MainViewModel`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`MainViewModel`上创建`Refresh`命令方法开始：
- en: Open the `MainViewModel` class.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainViewModel`类。
- en: 'Add a `using` declaration for `CommunityToolkit.Mvvm.Input`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CommunityToolkit.Mvvm.Input`添加`using`声明：
- en: '[PRE22]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a method called `RefreshAsync` that calls the `LoadDataAsync` method, as
    shown in the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`RefreshAsync`的方法，该方法调用`LoadDataAsync`方法，如下所示：
- en: '[PRE23]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since these methods are asynchronous, `Refresh` will return `Task`, and we can
    use `async` and `await` to call `LoadDataAsync` without blocking the UI thread.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这些方法是异步的，`Refresh`将返回`Task`，我们可以使用`async`和`await`来调用`LoadDataAsync`而不会阻塞UI线程。
- en: 'Add a `RelayCommand` attribute to the `RefreshAsync` method to auto-generate
    the `ICommand` bindable property to the method:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`RefreshAsync`方法添加`RelayCommand`属性以自动生成方法的可绑定`ICommand`属性：
- en: '[PRE24]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have defined the `Refresh` command, we need to bind it to the user
    interface so that when the user clicks the toolbar button, the action will be
    executed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`Refresh`命令，我们需要将其绑定到用户界面，以便当用户点击工具栏按钮时，将执行该操作。
- en: 'To do this, perform the following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，请执行以下步骤：
- en: Open the `MainView.xaml` file.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainView.xaml`文件。
- en: Download the `refresh.png` file from [https://raw.githubusercontent.com/PacktPublishing/MAUI-Projects-3rd-Edition/main/Chapter08/Weather/Resources/Images/refresh.png](https://raw.githubusercontent.com/PacktPublishing/MAUI-Projects-3rd-Edition/main/Chapter08/Weather/Resources/Images/refresh.png)
    and save it to the `Resources/Images` folder of the project.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://raw.githubusercontent.com/PacktPublishing/MAUI-Projects-3rd-Edition/main/Chapter08/Weather/Resources/Images/refresh.png](https://raw.githubusercontent.com/PacktPublishing/MAUI-Projects-3rd-Edition/main/Chapter08/Weather/Resources/Images/refresh.png)下载`refresh.png`文件，并将其保存到项目的`Resources/Images`文件夹中。
- en: Add a new `ToolbarItem` with the `Text` property set to `Refresh` to the `ToolbarItems`
    property of `ContentPage` and set the `IconImageSource` property to `refresh.png`
    (alternatively, you can set the `IconImageSource` property to the URL of the image
    and .NET MAUI will download the image).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`ContentPage`的`ToolbarItems`属性添加一个新的`ToolbarItem`，将`Text`属性设置为`Refresh`，并将`IconImageSource`属性设置为`refresh.png`（或者，您可以将`IconImageSource`属性设置为图片的URL，.NET
    MAUI将下载该图片）。
- en: 'Bind the `Command` property to the `Refresh` property in `MainViewModel`, as
    shown in the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Command` 属性绑定到 `MainViewModel` 中的 `Refresh` 属性，如下所示：
- en: '[PRE25]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That’s all for refreshing the data. Now, we need some kind of indicator that
    the data is loading.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 数据刷新的所有内容都已完成。现在，我们需要某种指示数据正在加载的指示器。
- en: Adding a loading indicator
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加加载指示器
- en: 'When we refresh the data, we want to show a loading indicator so that the user
    knows that something is happening. To do this, we will add `ActivityIndicator`,
    which is what this control is called in .NET MAUI. Let’s set this up:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刷新数据时，我们希望显示一个加载指示器，以便用户知道正在发生某些事情。为此，我们将添加 `ActivityIndicator`，这是 .NET MAUI
    中对该控件的称呼。让我们设置如下：
- en: Open the `MainViewModel` class.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainViewModel` 类。
- en: Add a `Boolean` field called `isRefreshing` to `MainViewModel`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainViewModel` 中添加一个名为 `isRefreshing` 的 `Boolean` 字段。
- en: Add the `ObservableProperty` attribute to `isRefreshingField` to generate the
    `IPropertyChanged` implementation.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `isRefreshingField` 上添加 `ObservableProperty` 属性以生成 `IPropertyChanged` 实现。
- en: Set the `IsRefreshing` property to `true` at the beginning of the `LoadDataAsync`
    method.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LoadDataAsync` 方法的开始处将 `IsRefreshing` 属性设置为 `true`。
- en: 'At the end of the `LoadDataAsync` method, set the `IsRefreshing` property to
    `false`, as shown in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LoadDataAsync` 方法的末尾，将 `IsRefreshing` 属性设置为 `false`，如下所示：
- en: '[PRE26]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have added some code to `MainViewModel`, we need to bind the `IsRefreshing`
    property to a user interface element that will be displayed when the `IsRefreshing`
    property is `true`, as shown in the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 `MainViewModel` 中添加了一些代码，我们需要将 `IsRefreshing` 属性绑定到当 `IsRefreshing`
    属性为 `true` 时将显示的用户界面元素，如下所示：
- en: In `MainView.xaml`, add `Frame` after `ScrollView` as the last element in `Grid`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainView.xaml` 中，将 `Frame` 添加到 `ScrollView` 之后，作为 `Grid` 中的最后一个元素。
- en: Bind the `IsVisible` property to the `IsRefreshing` method that we created in
    `MainViewModel`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IsVisible` 属性绑定到我们在 `MainViewModel` 中创建的 `IsRefreshing` 方法。
- en: Set `HeightRequest` and `WidthRequest` to `100`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `HeightRequest` 和 `WidthRequest` 设置为 `100`。
- en: Set `VerticalOptions` and `HorizontalOptions` to `Center` so that `Frame` will
    be in the middle of the view.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `VerticalOptions` 和 `HorizontalOptions` 设置为 `Center`，以便 `Frame` 将位于视图的中间。
- en: Set `BackgroundColor` to `#99000000` to set the background to white with a little
    bit of transparency.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BackgroundColor` 设置为 `#99000000` 以将背景设置为带有一定透明度的白色。
- en: 'Add `ActivityIndicator` to `Frame` with `Color` set to `Black` and `IsRunning`
    set to `True`, as shown in the following code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Frame` 中添加 `ActivityIndicator`，将 `Color` 设置为 `Black`，将 `IsRunning` 设置为 `True`，如下所示：
- en: '[PRE27]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will create a spinner that will be visible while data is loading, which
    is a really good practice when creating any user interface. Now, we’ll add a background
    image to make the app look a bit nicer.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个在数据加载时可见的旋转器，这在创建任何用户界面时都是一个非常好的实践。现在，我们将添加一个背景图像，使应用看起来更美观。
- en: Setting a background image
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置背景图像
- en: 'The last thing we will do to this view, for the moment, is add a background
    image. The image we will be using in this example is a result of a Google search
    for images that are free to use. Let’s set this up:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个视图，我们目前要做的最后一件事是添加一个背景图像。在这个例子中，我们将使用的是通过 Google 搜索免费使用图像的结果。让我们设置如下：
- en: Open the `MainView.xaml` file.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainView.xaml` 文件。
- en: Set the `Background` property of `ScrollView` to `Transparent`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ScrollView` 的 `Background` 属性设置为 `Transparent`。
- en: Add an `Image` element in `Grid` with `UriImageSource` as the value of the `Source`
    property.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Grid` 中添加一个 `Image` 元素，将 `UriImageSource` 设置为 `Source` 属性的值。
- en: Set the `CachingEnabled` property to true and `CacheValidity` to `5`. This means
    that the image will be cached for `5` days.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CachingEnabled` 属性设置为 `true`，将 `CacheValidity` 设置为 `5`。这意味着图像将被缓存 `5` 天。
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You could also set these properties if you used a URL for the `Refresh` `IconImageSource`
    property to avoid downloading the image on every run of the app.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了 URL 作为 `Refresh` `IconImageSource` 属性的值，也可以设置这些属性以避免在每次运行应用时下载图像。
- en: 'The XAML should now look as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XAML 现在应该看起来如下所示：
- en: '[PRE28]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can also set the URL directly in the `Source` property by using `<Image Source=”https://ourgreatimage.url”
    />`. However, if we do this, we can’t specify caching for the image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用 `<Image Source=”https://ourgreatimage.url” />` 直接在 `Source` 属性中设置
    URL。然而，如果我们这样做，我们无法指定对图像的缓存。
- en: With the desktop view complete, we need to consider how this page will look
    when we are running the app on a phone or tablet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面视图完成后，我们需要考虑当我们在手机或平板上运行应用时，这个页面将如何显示。
- en: Creating the view for phones
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建手机视图
- en: 'Structuring content on a tablet and a desktop computer is very similar in many
    ways. On phones, however, we are much more limited in what we can do. Therefore,
    in this section, we will create a specific view for this app when it’s used on
    phones. To do so, perform the following steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在平板电脑和台式计算机上结构化内容在很多方面非常相似。然而，在手机上，我们能够做的事情却非常有限。因此，在本节中，我们将为在手机上使用此应用时创建一个特定的视图。为此，请按照以下步骤操作：
- en: Create a new XAML-based `Views` folder.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的基于 XAML 的 `Views` 文件夹。
- en: In the `Views` folder, create a new folder called `Mobile`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views` 文件夹中，创建一个名为 `Mobile` 的新文件夹。
- en: 'Create a new `.NET MAUI ContentPage (XAML)` file called `MainView` in the `Views\Mobile`
    folder:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Mobile` 文件夹中创建一个名为 `MainView` 的新 `.NET MAUI ContentPage (XAML)` 文件：
- en: '![Figure 8.9 – Adding a .NET MAUI XAML ContentPage](img/B19214_08_9..jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 添加 .NET MAUI XAML ContentPage](img/B19214_08_9..jpg)'
- en: Figure 8.9 – Adding a .NET MAUI XAML ContentPage
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 添加 .NET MAUI XAML ContentPage
- en: 'Pass an instance of `MainViewModel` in the constructor of the view to set `BindingContext`,
    as shown in the following code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图的构造函数中传递 `MainViewModel` 的实例以设置 `BindingContext`，如下所示：
- en: '[PRE29]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Later, in the *Adding services and ViewModels to dependency injection* section,
    we will configure dependency injection to provide the instances for us.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *添加服务和 ViewModels 到依赖注入* 部分中，我们将配置依赖注入以为我们提供实例。
- en: To trigger the `LoadDataAsync` method in `MainViewModel`, call the `LoadDataAsync`
    method by overriding the `OnNavigatedTo` method on the main thread. We need to
    make sure that the call is executed on the UI thread since it will interact with
    the user interface.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发 `MainViewModel` 中的 `LoadDataAsync` 方法，通过在主线程上重写 `OnNavigatedTo` 方法来调用 `LoadDataAsync`
    方法。我们需要确保调用在 UI 线程上执行，因为它将交互用户界面。
- en: 'To do this, perform the following steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请按照以下步骤进行：
- en: Open the `MainView.xaml.cs` file in the `Views\Mobile` folder.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Mobile` 文件夹中打开 `MainView.xaml.cs` 文件。
- en: Create an override of the `OnNavigatedTo` method.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `OnNavigatedTo` 方法。
- en: 'Add the highlighted code in the following snippet to the `OnNavigateTo` method:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下片段中突出显示的代码添加到 `OnNavigateTo` 方法中：
- en: '[PRE30]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `MainView` XAML file, add a binding for the `Title` property of `ContentPage`
    to the `City` property in `ViewModel`, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainView` XAML 文件中，将 `ContentPage` 的 `Title` 属性绑定到 `ViewModel` 中的 `City`
    属性，如下所示：
- en: Open the `MainView.xaml` file in the `Views\Mobile` folder.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Mobile` 文件夹中打开 `MainView.xaml` 文件。
- en: 'Add the `Title` binding to the `ContentPage` element, as highlighted in the
    following code snippet:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Title` 绑定添加到以下代码片段中突出显示的 `ContentPage` 元素：
- en: '[PRE31]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the next section, we will use `CollectionView` to display the weather data
    instead of using `FlexView`, as we did for the desktop view.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 `CollectionView` 来显示天气数据，而不是像桌面视图那样使用 `FlexView`。
- en: Using a grouped CollectionView
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用分组 CollectionView
- en: We could use `FlexLayout` for the phone’s view, but because we want our user
    experience to be as good as possible, we will use `CollectionView` instead. To
    get the headers for each day, we will use grouping for `CollectionView`. For `FlexLayout`,
    we had `ScrollView`, but for `CollectionView`, we don’t need this because `CollectionView`
    can handle scrolling by default.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `FlexLayout` 来实现手机的视图，但由于我们希望用户体验尽可能好，我们将使用 `CollectionView`。为了获取每天的标题，我们将对
    `CollectionView` 使用分组。对于 `FlexLayout`，我们有 `ScrollView`，但对于 `CollectionView`，我们不需要这个，因为
    `CollectionView` 默认可以处理滚动。
- en: 'Let’s continue creating the user interface for the phone’s view:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续为手机的视图创建用户界面：
- en: Open the `MainView.xaml` file in the `Views\Mobile` folder.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views\Mobile` 文件夹中打开 `MainView.xaml` 文件。
- en: Add `CollectionView` to the root of the page.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CollectionView` 添加到页面的根处。
- en: Set a binding to the `Days` property in `MainViewModel` for the `ItemSource`
    property.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainViewModel` 中为 `ItemSource` 属性设置对 `Days` 属性的绑定。
- en: Set `IsGrouped` to `True` to enable grouping in `CollectionView`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IsGrouped` 设置为 `True` 以在 `CollectionView` 中启用分组。
- en: 'Set `BackgroundColor` to `Transparent`, as shown in the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BackgroundColor` 设置为 `Transparent`，如下所示：
- en: '[PRE32]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To format how each header will look, we will create a `DataTemplate` property,
    as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了格式化每个标题的外观，我们将创建一个 `DataTemplate` 属性，如下所示：
- en: Add a `DataTemplate` property to the `GroupHeaderTemplate` property of `CollectionView`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DataTemplate` 属性添加到 `CollectionView` 的 `GroupHeaderTemplate` 属性中。
- en: 'Add the content for the row to `DataTemplate`, as shown in the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行内容添加到 `DataTemplate` 中，如下所示：
- en: '[PRE33]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To format how each forecast will look, we will create a `DataTemplate` property,
    as we did with the group header. Let’s set this up:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了格式化每个预报的外观，我们将创建一个 `DataTemplate` 属性，就像我们对组标题所做的那样。让我们设置这个：
- en: Add a `DataTemplate` property to the `ItemTemplate` property of `CollectionView`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DataTemplate` 属性添加到 `CollectionView` 的 `ItemTemplate` 属性中。
- en: In `DataTemplate`, add a `Grid` property that contains four columns. Use the
    `ColumnDefinition` property to specify the width of the columns. The second column
    should be `50`; the other three will share the rest of the space. We will do this
    by setting `Width` to `*`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DataTemplate` 中添加一个包含四个列的 `Grid` 属性。使用 `ColumnDefinition` 属性指定列的宽度。第二列应该是
    `50`；其他三列将共享剩余的空间。我们将通过将 `Width` 设置为 `*` 来实现这一点。
- en: 'Add the following content to `Grid`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `Grid`：
- en: '[PRE34]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Adding pull-to-refresh functionality
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加下拉刷新功能
- en: For the tablet and desktop versions of the view, we added a button to the toolbar
    to refresh the weather forecast. In the phone version of the view, however, we
    will add pull-to-refresh functionality, which is a common way to refresh content
    in a list of data. `CollectionView` in .NET MAUI has no built-in support for pull-to-refresh
    as `ListView` has.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图的平板和桌面版本，我们在工具栏中添加了一个按钮来刷新天气预报。然而，在手机版本的视图中，我们将添加下拉刷新功能，这是在数据列表中刷新内容的一种常见方式。.NET
    MAUI 中的 `CollectionView` 没有内置下拉刷新的支持，就像 `ListView` 一样。
- en: 'Instead, we can use `RefreshView`. `RefreshView` can be used to add pull-to-refresh
    behavior to any control. Let’s set this up:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用 `RefreshView`。`RefreshView` 可以用于向任何控件添加下拉刷新行为。让我们设置这个：
- en: Go to `Views\Mobile\MainView.xaml`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `Views\Mobile\MainView.xaml`。
- en: Wrap `CollectionView` inside `RefreshView`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CollectionView` 包裹在 `RefreshView` 内。
- en: Bind the `RefreshCommand` property in `MainViewModel` to the `Command` property
    of `RefreshView` to trigger a refresh when the user performs a pull-to-refresh
    gesture.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MainViewModel` 中的 `RefreshCommand` 属性绑定到 `RefreshView` 的 `Command` 属性，以便在用户执行下拉刷新手势时触发刷新。
- en: 'To show a loading icon when the refresh is in progress, bind the `IsRefreshing`
    property in `MainViewModel` to the `IsRefreshing` property of `RefreshView`. When
    we are setting this up, we will also get a loading indicator when the initial
    load is running, as shown in the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在刷新进行时显示加载图标，将 `MainViewModel` 中的 `IsRefreshing` 属性绑定到 `RefreshView` 的 `IsRefreshing`
    属性。当我们设置这个时，我们也会在初始加载运行时获得一个加载指示器，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That concludes the views for the moment. Now, let’s wire them up into dependency
    injection so that we can see our work.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了当前视图的创建。现在，让我们将它们连接到依赖注入，以便我们可以看到我们的工作。
- en: Adding services and ViewModels to dependency injection
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加服务和 ViewModels 到依赖注入
- en: 'For our views to get an instance of `MainViewModel` and `MainViewModel` to
    get an instance of `OpenWeatherMapWeatherService`, we need to add them to dependency
    injection. Let’s set this up:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的视图获取 `MainViewModel` 的实例，以及让 `MainViewModel` 获取 `OpenWeatherMapWeatherService`
    的实例，我们需要将它们添加到依赖注入中。让我们设置这个：
- en: Open `MauiProgram.cs`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs`。
- en: 'Add the following highlighted code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码：
- en: '[PRE36]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the next section, we will add the navigation to the views based on the device’s
    form factor.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将根据设备的形态添加视图的导航。
- en: Navigating to different views based on the form factor
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据设备形态导航到不同的视图
- en: We now have two different views that should be loaded in the same place in the
    app. `Weather.Views.Desktop.MainView` should be loaded if the app is running on
    a tablet or a desktop, while `Weather.Views.Mobile.MainView` should be loaded
    if the app is running on a phone.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个不同的视图，它们应该在应用程序的同一位置加载。如果应用程序在平板或桌面上运行，则应加载 `Weather.Views.Desktop.MainView`；如果应用程序在手机上运行，则应加载
    `Weather.Views.Mobile.MainView`。
- en: The `Device` class in .NET MAUI has a static `Idiom` property that we can use
    to check which form factor the app is running on. The value of `Idiom` can be
    `Phone`, `Tablet`, `Desktop`, `Watch`, or `TV`. Because we only have one view
    in this app, we could have used an `if` statement when we were setting `MainPage`
    in `App.xaml.cs` and checked what the `Idiom` value was.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 中的 `Device` 类有一个静态的 `Idiom` 属性，我们可以使用它来检查应用程序正在哪个形态上运行。`Idiom` 的值可以是
    `Phone`、`Tablet`、`Desktop`、`Watch` 或 `TV`。因为我们在这个应用程序中只有一个视图，所以我们可以在 `App.xaml.cs`
    中设置 `MainPage` 时使用 `if` 语句来检查 `Idiom` 的值。
- en: 'Since we are only ever going to need one view, we can register just the view
    that we need in dependency injection – all we need is a common type to register
    the views with. Let’s create a new interface that our views will implement:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要一个视图，我们只需在依赖注入中注册我们需要的视图即可——我们只需要一个公共类型来注册视图。让我们创建一个新的接口，我们的视图将实现它：
- en: Create a new interface in the `Views` folder named `IMainView`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views` 文件夹中创建一个名为 `IMainView` 的新接口。
- en: We won’t add any additional properties or methods to the interface – we’ll just
    use it as a marker.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会向接口添加任何额外的属性或方法，我们只是将其用作标记。
- en: 'Open `Views\Desktop\MainView.xaml.cs` and add the `IMainView` interface to
    the class:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views\Desktop\MainView.xaml.cs` 并将 `IMainView` 接口添加到类中：
- en: '[PRE37]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'public partial class MainView : ContentPage, IMainView'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public partial class MainView : ContentPage, IMainView'
- en: '[PRE38]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have a common interface, we can register the views with dependency
    injection:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个公共接口，我们可以通过依赖注入注册视图：
- en: Open the `MauiProgram.cs` file.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 文件。
- en: 'Add the following code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE39]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With these changes, we can now test our application. If you run your app, you
    should see something like the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们现在可以测试我们的应用程序。如果你运行你的应用，你应该看到以下内容：
- en: '![Figure 8.10 – App running on macOS and iOS](img/B19214_08_10..jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 在 macOS 和 iOS 上运行的应用](img/B19214_08_10..jpg)'
- en: Figure 8.10 – App running on macOS and iOS
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 在 macOS 和 iOS 上运行的应用
- en: Next, let’s update the desktop views to handle resizing properly by using `VisualStateManager`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过使用 `VisualStateManager` 来更新桌面视图，以便正确处理调整大小。
- en: Handling states with VisualStateManager
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 VisualStateManager 处理状态
- en: '`VisualStateManager` is a way to make changes in the UI from the code. We can
    define states and set values for selected properties to apply to a specific state.
    `VisualStateManager` can be useful in cases where we want to use the same view
    for devices with different screen resolutions. It was first introduced in `VisualStateManager`
    is interesting for us as .NET MAUI developers, especially when both iOS and Android
    can run on both phones and tablets.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualStateManager` 是一种从代码中更改 UI 的方法。我们可以定义状态并为选定的属性设置值，以应用于特定状态。`VisualStateManager`
    在我们想要为具有不同屏幕分辨率的设备使用相同视图的情况下非常有用。对于我们这些 .NET MAUI 开发者来说，`VisualStateManager` 非常有趣，尤其是在
    iOS 和 Android 都可以在手机和平板上运行的情况下。'
- en: 'In this project, we will use it to make a `forecast` item bigger when the app
    is running in landscape mode on a tablet or a desktop. We will also make the weather
    icon bigger. Let’s set this up:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在此项目中，我们将使用它来在平板电脑或桌面上的横幅模式下运行应用时使 `forecast` 项更大。我们还将使天气图标更大。让我们设置它：
- en: Open the `Views\Desktop\MainView.xaml` file.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views\Desktop\MainView.xaml` 文件。
- en: 'In the first `FlexLayout` and `DataTemplate`, insert a `VisualStateManager.VisualStateGroups`
    element into the first `StackLayout`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个 `FlexLayout` 和 `DataTemplate` 中，将一个 `VisualStateManager.VisualStateGroups`
    元素插入到第一个 `StackLayout`：
- en: '[PRE40]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Regarding `VisualStateGroup`, we should add two states, as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `VisualStateGroup`，我们应该添加两个状态，如下所示：
- en: Add a new `VisualState` called `Portrait` to `VisualStateGroup`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `VisualStateGroup` 中添加一个名为 `Portrait` 的新 `VisualState`。
- en: Create a setter in `VisualState` and set `WidthRequest` to `150`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `VisualState` 中创建一个设置器，并将 `WidthRequest` 设置为 `150`。
- en: Add another `VisualState` called `Landscape` to `VisualStateGroup`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个名为 `Landscape` 的 `VisualState` 添加到 `VisualStateGroup` 中。
- en: 'Create a setter in `VisualState` and set `WidthRequest` to `200`, as shown
    in the following code:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `VisualState` 中创建一个设置器，并将 `WidthRequest` 设置为 `200`，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We also want the icons in a forecast item to be bigger when the item itself
    is bigger. To do this, we will use `VisualStateManager` again. Let’s set this
    up:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望当预测项本身更大时，预测项中的图标也更大。为此，我们将再次使用 `VisualStateManager`。让我们设置它：
- en: Insert a `VisualStateManager.VisualStateGroups` element into the second `FlexLayout`
    and in the `Image` element in `DataTemplate`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个 `FlexLayout` 和 `DataTemplate` 中的 `Image` 元素中插入一个 `VisualStateManager.VisualStateGroups`
    元素。
- en: Add `VisualState` for both `Portrait` and `Landscape`.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Portrait` 和 `Landscape` 添加 `VisualState`。
- en: 'Add setters to the states to set `WidthRequest` and `HeightRequest`. The value
    should be `100` in the `Portrait` state and `150` in the `Landscape` state, as
    shown in the following code:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向状态添加设置器以设置 `WidthRequest` 和 `HeightRequest`。在 `Portrait` 状态中，值应为 `100`，在 `Landscape`
    状态中，值应为 `150`，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Creating a behavior to set state changes
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个用于设置状态更改的行为
- en: With `Behavior`, we can add functionality to controls without having to subclass
    them. With behaviors, we can also create more reusable code than we could if we
    subclassed a control. The more specific `Behavior` we create, the more reusable
    it will be. For example, `Behavior` that inherits from `Behavior<View>` could
    be used on all controls, but `Behavior` that inherits from `Button` can only be
    used for buttons. Because of this, we always want to create behaviors with a less
    specific base class.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Behavior`，我们可以在不必须对控件进行子类化的情况下向控件添加功能。使用行为，我们还可以创建比子类化控件时更多的可重用代码。我们创建的
    `Behavior` 越具体，其可重用性就越高。例如，从 `Behavior<View>` 继承的 `Behavior` 可以用于所有控件，但仅从 `Button`
    继承的 `Behavior` 可以用于按钮。正因为如此，我们总是希望使用更不具体的基类来创建行为。
- en: 'When we create `Behavior`, we need to override two methods: `OnAttached` and
    `OnDetachingFrom`. It is really important to remove event listeners in the `OnDeattached`
    method if we have added them to the `OnAttached` method. This will make the app
    use less memory. It is also important to set values back to the values that they
    had before the `OnAppearing` method ran; otherwise, we might see some strange
    behavior, especially if the behavior is in a `CollectionView` or `ListView` view
    that is reusing cells.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `Behavior` 时，需要重写两个方法：`OnAttached` 和 `OnDetachingFrom`。如果我们在 `OnAttached`
    方法中添加了事件监听器，那么在 `OnDeattached` 方法中移除它们是非常重要的。这将使应用程序使用更少的内存。同样重要的是将值设置回 `OnAppearing`
    方法运行之前的状态；否则，我们可能会看到一些奇怪的行为，尤其是在行为位于重用单元格的 `CollectionView` 或 `ListView` 视图中。
- en: 'In this app, we will create a behavior for `FlexLayout`. This is because we
    can’t set the state of an item in `FlexLayout` from the code-behind. We could
    have added some code to check whether the app runs in portrait or landscape in
    `FlexLayout`, but if we use `Behavior` instead, we can separate that code from
    `FlexLayout` so that it will be more reusable. Perform the following steps to
    do so:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，我们将为 `FlexLayout` 创建一个行为。这是因为我们不能从代码后端设置 `FlexLayout` 中项的状态。我们可以在 `FlexLayout`
    中添加一些代码来检查应用程序是否以纵向或横向运行，但如果我们使用 `Behavior`，则可以将该代码从 `FlexLayout` 中分离出来，使其更具可重用性。执行以下步骤来完成此操作：
- en: Create a new folder called `Behaviors`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Behaviors` 的新文件夹。
- en: Create a new class called `FlexLayoutBehavior`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FlexLayoutBehavior` 的新类。
- en: Add `Behavior<FlexLayoutView>` as a base class.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Behavior<FlexLayoutView>` 作为基类添加。
- en: Create a `private` field of the `FlexLayout` type called `view`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `view` 的 `FlexLayout` 类型的 `private` 字段。
- en: 'The code should look as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应如下所示：
- en: '[PRE43]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`FlexLayout` is a class that inherits from the `Behavior<FlexLayout>` base
    class. This will give us the ability to override some virtual methods that will
    be called when we attach and detach the behavior from a `FlexLayout` class.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlexLayout` 是一个继承自 `Behavior<FlexLayout>` 基类的类。这将使我们能够覆盖一些在将行为附加到或从 `FlexLayout`
    类中移除时将被调用的虚拟方法。'
- en: 'But first, we need to create a method that will handle the change in state.
    Perform the following steps to do so:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要创建一个处理状态变化的方法。执行以下步骤来完成此操作：
- en: Open the `FlexlayoutBehavior.cs` file.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `FlexlayoutBehavior.cs` 文件。
- en: Create a `private` method called `SetState`. This method will have a `VisualElement`
    value and a `string` argument.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SetState` 的 `private` 方法。此方法将有一个 `VisualElement` 值和一个 `string` 参数。
- en: Call `VisualStateManager.GoToState` and pass the parameters to it.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `VisualStateManager.GoToState` 并传递参数给它。
- en: 'If the view is of the `Layout` type, there might be child elements that also
    need to get the new state. To do that, we will loop through all the children of
    the layout. Instead of just setting the state directly to the children, we will
    call the `SetState` method, which is the method that we are already inside. The
    reason for this is that some of the children may have their own children:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果视图是 `Layout` 类型，可能还有需要获取新状态的子元素。为此，我们将遍历布局的所有子元素。我们不会直接将状态设置到子元素，而是调用 `SetState`
    方法，这是我们已经在其中的方法。这样做的原因是，一些子元素可能有它们自己的子元素：
- en: '[PRE44]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we have created the `SetState` method, we need to write a method that
    uses it and determines what state to set. Perform the following steps to do so:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 `SetState` 方法，我们需要编写一个使用它并确定要设置什么状态的方法。执行以下步骤来完成此操作：
- en: Create a `private` method called `UpdateState`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `UpdateState` 的 `private` 方法。
- en: Run the code on `MainThread` to check whether the app is running in portrait
    or landscape mode.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainThread` 上运行代码以检查应用程序是否以纵向或横向模式运行。
- en: Create a variable called `page` and set its value to `Application.Current.MainPage`.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `page` 的变量，并将其值设置为 `Application.Current.MainPage`。
- en: 'Check whether `Width` is larger than `Height`. If this is `true`, set the `VisualState`
    property on the `view` variable to `Landscape`. If this is `false`, set the `VisualState`
    property on the `view` variable to `Portrait`, as shown in the following code:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`Width`是否大于`Height`。如果是`true`，将`view`变量的`VisualState`属性设置为`Landscape`。如果是`false`，将`view`变量的`VisualState`属性设置为`Portrait`，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With that, the `UpdateState` method has been added. Now, we need to override
    the `OnAttachedTo` method, which will be called when the behavior is added to
    `FlexLayout`. When it is, we want to update the state by calling this method and
    hook it up to the `SizeChanged` event of `MainPage` so that when the size changes,
    we will update the state again.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`UpdateState`方法已经添加。现在，我们需要重写`OnAttachedTo`方法，该方法将在行为添加到`FlexLayout`时被调用。当它被添加时，我们想要通过调用此方法并将其连接到`MainPage`的`SizeChanged`事件来更新状态，以便当大小改变时，我们将再次更新状态。
- en: 'Let’s set this up:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置如下：
- en: Open the `FlexLayoutBehavior` file.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FlexLayoutBehavior`文件。
- en: Override the `OnAttachedTo` method from the base class.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基类中重写`OnAttachedTo`方法。
- en: Set the `view` property to the parameter from the `OnAttachedTo` method.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`view`属性设置为`OnAttachedTo`方法中的参数。
- en: 'Add an event listener to `Application.Current.MainPage.SizeChanged`. In the
    event listener, add a call to the `UpdateState` method, as shown in the following
    code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Application.Current.MainPage.SizeChanged`添加事件监听器。在事件监听器中添加对`UpdateState`方法的调用，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we remove behaviors from a control, it’s very important to also remove
    any event handlers from it to avoid memory leaks, and in the worst case, the app
    crashing. Let’s do this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从控件中移除行为时，非常重要的一点是也要从其中移除任何事件处理器，以避免内存泄漏，在最坏的情况下，防止应用崩溃。让我们这样做：
- en: Open the `FlexLayoutBehavior.cs` file.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FlexLayoutBehavior.cs`文件。
- en: Override `OnDetachingFrom` from the base class.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基类中重写`OnDetachingFrom`方法。
- en: Remove the event listener from `Application.Current.MainPage.SizeChanged`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Application.Current.MainPage.SizeChanged`中移除事件监听器。
- en: 'Set the `view` field to `null`, as shown in the following code:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`view`字段设置为`null`，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Perform the following steps to add `behavior` to the view:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将`behavior`添加到视图中：
- en: Open the `MainView.xaml` file inside the `Views/Desktop` folder.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/Desktop`文件夹中的`MainView.xaml`文件。
- en: 'Import the `Weather.Behaviors` namespace, as shown in the following code:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码导入`Weather.Behaviors`命名空间：
- en: '[PRE48]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last thing we will do is add `FlexLayoutBehavior` to the second `FlexLayout`,
    as shown in the following code:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的就是将`FlexLayoutBehavior`添加到第二个`FlexLayout`中，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Congratulations – that is a wrap on the weather app!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——天气应用已经完成！
- en: '![Figure 8.11 – Completed app on tablet, phone, and desktop](img/B19214_08_11..jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11——平板电脑、手机和桌面上的完成应用](img/B19214_08_11..jpg)'
- en: Figure 8.11 – Completed app on tablet, phone, and desktop
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11——平板电脑、手机和桌面上的完成应用
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we successfully created an app for four different operating
    systems – iOS, macOS, Android, and Windows – and three different form factors
    – phones, tablets, and desktop computers. To create a good user experience on
    all platforms and form factors, we used `FlexLayout` and `VisualStateManager`.
    We also learned how to handle different views for different form factors, as well
    as how to use `Behaviors`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地为四个不同的操作系统——iOS、macOS、Android和Windows——以及三种不同的形态——手机、平板电脑和桌面电脑——创建了一个应用。为了在所有平台和形态上提供良好的用户体验，我们使用了`FlexLayout`和`VisualStateManager`。我们还学习了如何处理不同形态的不同视图，以及如何使用`Behaviors`。
- en: The next app we will build will be a game with real-time communication. In the
    next chapter, we will take a look at how we can use the **SignalR** service in
    **Azure** as the backend game service.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要构建的应用将是一个具有实时通信的游戏。在下一章中，我们将探讨如何使用**Azure**中的**SignalR**服务作为后端游戏服务。
- en: 'Part 3: Advanced Projects'
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：高级项目
- en: In this part, you will work with more advanced topics and complicated projects.
    You will learn how to create and deploy a service in Azure. Additionally, you
    will work with Azure Storage and SignalR services. You will learn how to call
    your service from a .NET MAUI application, properly handle error conditions, and
    integrate the camera into your app. You will explore a project using Blazor embedded
    into a .NET MAUI app, and learn how to integrate artificial intelligence services
    into a .NET MAUI app.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将处理更高级的主题和复杂的项目。你将学习如何在Azure中创建和部署服务。此外，你将使用Azure存储和SignalR服务。你将学习如何从.NET
    MAUI应用程序中调用你的服务，正确处理错误条件，并将摄像头集成到你的应用程序中。你将探索一个嵌入到.NET MAUI应用程序中的Blazor项目，并学习如何将人工智能服务集成到.NET
    MAUI应用程序中。
- en: 'This part has the following chapters:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B19214_09.xhtml#_idTextAnchor854), *Setting Up a Backend for
    a Game Using Azure Services*'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19214_09.xhtml#_idTextAnchor854), *使用Azure服务为游戏设置后端*'
- en: '[*Chapter 10*](B19214_10.xhtml#_idTextAnchor867), *Building a Real-Time Game*'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19214_10.xhtml#_idTextAnchor867), *构建实时游戏*'
- en: '[*Chapter 11*](B19214_11.xhtml#_idTextAnchor895), *Building a Calculator Using
    .NET MAUI Blazor*'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19214_11.xhtml#_idTextAnchor895), *使用.NET MAUI Blazor构建计算器*'
- en: '[*Chapter 12*](B19214_12.xhtml#_idTextAnchor919), *Hot Dog or Not Hot Dog Using
    Machine Learning*'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19214_12.xhtml#_idTextAnchor919), *使用机器学习判断热狗是否热*'
